2024-07-02
[09:24:11.0008] <rbuckton>
FYI, I have someone coming by today to repair some siding that came loose during a thunderstorm and it looks like they were delayed and will be here around 1pm EST (the start of the meeting today), so I may be delayed by a few minutes or interrupted.

[10:55:35.0763] <rbuckton>
ianhedoesit: Regarding your comment that the intuition is that "`async` affects the type", I disagree. Both `async` (and `*`) imply a _syntactic transformation in the function body_. Non `async` code can still return a `Promise`, and non `*` code can still return a generator.

[10:58:15.0251] <iain>
(I think you tagged the wrong Iain)

[10:59:44.0239] <iain>
I don't think that tracks. If I add "async" or `*` to a function definition, it returns a different sort of thing, in a way that my caller needs to know about. If I add `unsafe`, it doesn't change anything from the caller's perspective.

[10:59:53.0456] <iain>
 * I don't think that tracks. If I add `async` or `*` to a function definition, it returns a different sort of thing, in a way that my caller needs to know about. If I add `unsafe`, it doesn't change anything from the caller's perspective.

[11:02:43.0333] <iain>
Functions don't have typed signatures in raw JS, but if you return a promise or a generator from a function then that is reflected in the implicit return type. The same is not true for `unsafe`.

[11:03:20.0692] <rbuckton>
I did, oops.

[11:03:38.0658] <iain>
The distinction is whether the property is important to the caller, and since we're explicitly avoiding function colouring, I claim that `unsafe` is only relevant to the code inside the function.

[11:03:42.0528] <rbuckton>
 * iain: Regarding your comment that the intuition is that "`async` affects the type", I disagree. Both `async` (and `*`) imply a _syntactic transformation in the function body_. Non `async` code can still return a `Promise`, and non `*` code can still return a generator.

[11:05:18.0661] <iain>
My anecdotal evidence that this is potentially confusing is that I was personally confused by this while reading the explainer.

[11:05:47.0215] <rbuckton>
We tried to make this distinction in TypeScript fairly clear. While you can write `async function f(): Promise<void> { ... }` in your code, the output declaration is `declare function f(): Promise<void> { ... }`, as `async` only performs a syntactic transformation. It does certainly _inform_ the return type, but it is not part of the function signature from a type checking perspective.

[11:05:49.0531] <iain>
(Although it is certainly plausible that I am too easily confused!)

[11:07:29.0684] <rbuckton>
Decorators will further complicate that mental model, though, as a decorator could affect the return type of a function as well. At one point (after we had already shipped `async`/`await`), there were comments that we could have just used generators and `@async function* f() { ... }`.

[11:08:37.0985] <rbuckton>
Yes, `async` and `*` do imply a specific return type, but that is purely a result of the syntactic transformation. In the same way, `accessor` is also a syntactic transformation.

[11:09:41.0049] <rbuckton>
It could even be argued that `static` is a syntactic transformation insomuch as it applies to where a method or field is placed on a class. All of these potentially affect the type, but the type produced is purely a result of the transformation itself.

[11:13:30.0682] <rbuckton>
I'd also like to point out that `unsafe`, as I've proposed, is generally consistent with Rust as prior art. Rust allows `unsafe {}`, but also `unsafe fn`, `unsafe trait`, and `unsafe impl`:

> By default, `unsafe fn` also acts like an `unsafe {}` block around the code inside the function. This means it is not just a signal to the caller, but also promises that the preconditions for the operations inside the function are upheld. Mixing these two meanings can be confusing, so the `unsafe_op_in_unsafe_fn` lint can be enabled to warn against that and require explicit unsafe blocks even inside `unsafe fn`.

In rust, disallowing `unsafe fn` in favor of a nested unsafe block is specified as a lint rule.

[11:13:33.0889] <rbuckton>
 * I'd also like to point out that `unsafe`, as I've proposed, is generally consistent with Rust as prior art. Rust allows `unsafe {}`, but also `unsafe fn`, `unsafe trait`, and `unsafe impl`:

> By default, `unsafe fn` also acts like an `unsafe {}` block around the code inside the function. This means it is not just a signal to the caller, but also promises that the preconditions for the operations inside the function are upheld. Mixing these two meanings can be confusing, so the `unsafe_op_in_unsafe_fn` lint can be enabled to warn against that and require explicit unsafe blocks even inside `unsafe fn`.

In Rust, disallowing `unsafe fn` in favor of a nested unsafe block is specified as a lint rule.

[11:14:05.0118] <rbuckton>
https://doc.rust-lang.org/std/keyword.unsafe.html

[11:15:05.0111] <rbuckton>
Or am I misinterpreting? Does Rust require an `unsafe` block around an unsafe function call?

[11:15:15.0179] <iain>
In general, I would say that a function signature (broadly waving at all the parts of a function declaration outside the body) provides information that is important to the caller. This is especially true in statically typed languages, but even in JS I think it holds. By putting `unsafe` in such a prominent location, we imply that it is similarly important to the caller, which is not the case here.

[11:15:30.0026] <iain>
You are misinterpreting: Rust requires an unsafe block around calls to unsafe functions.

[11:15:44.0846] <rbuckton>
Ah, thanks. My mistake.

[11:15:53.0905] <iain>
That's a big part of why I misread your explainer.

[11:17:45.0897] <iain>
The purpose of the Rust lint is to encourage code to be precise about which parts of a function body are unsafe, even if the entire function must be called in an unsafe context.

[11:17:47.0164] <rbuckton>
An alternative to `unsafe function f() {}` that I'd also put on the explainer might be `function f() unsafe { }`. My concern is that this isn't obvious that it also affects the parameter list. Then again `function f() { "use strict"; }` affects the parameter list as well.

[11:19:17.0665] <iain>
The equivalent in JS of the Rust lint would be to have function colouring (where `unsafe function foo()` can only be called from inside an unsafe block) and also require explicit unsafe blocks inside the body of the function, which is the opposite of what you are proposing.

[11:19:23.0675] <rbuckton>
So, `class C unsafe { }` to make a class body unsafe, or `shared struct S unsafe { }` to make a shared struct body unsafe. We probably wouldn't do `unsafe const`/`unsafe let` in that case because it would be mixing up suffix vs. prefix, so we *would* need to depend on an unsafe IIFE or `unsafe do`

[11:21:37.0165] <rbuckton>
function coloring is a major DX pain. I see it as a necessity for `async` and `*` given that the syntactic transformations affect the return type, but it's not a practice I'm fond of continuing with new syntax if it isn't warranted.

[11:22:22.0514] <rbuckton>
> <@rbuckton:matrix.org> So, `class C unsafe { }` to make a class body unsafe, or `shared struct S unsafe { }` to make a shared struct body unsafe. We probably wouldn't do `unsafe const`/`unsafe let` in that case because it would be mixing up suffix vs. prefix, so we *would* need to depend on an unsafe IIFE or `unsafe do`

I suppose it would be `do unsafe {}`, to maintain the suffix position

[11:26:24.0021] <iain>
Function colouring in this case allows for the more nuanced expression of safety invariants. So for example you could have `function foo() { unsafe {...} }` and `unsafe function foo_AlreadyHoldingLock() {...}`, in which case `unsafe function` does not do a syntactic transformation, but it does impose restrictions on the callers to maintain invariants.

[11:27:14.0303] <iain>
I'm not convinced we want that, and I think adding it might impose a small performance overhead on unrelated code, but it's a point in design space.

[11:27:28.0921] <rbuckton>
There is one thing about function coloring an `unsafe` function has over `async`/`await` that makes it somewhat more palatable, which is that you can introduce an `unsafe {}` block in safe code to perform the operation. That almost makes me want to have both `unsafe function` ("it is unsafe to call me and my contents are unsafe") and `function () unsafe { }` ("it is safe to call me as I have done my due diligence to ensure I am safe at the boundaries"), mostly because I really am not a fan of the namespace nesting style often seen in C++, i.e.
```js
function f() { unsafe { 
  ...
} }
```

[11:28:09.0359] <rbuckton>
 * There is one thing about function coloring an `unsafe` function has over `async`/`await` that makes it somewhat more palatable, which is that you can introduce an `unsafe {}` block in safe code to perform the operation. That almost makes me want to have both `unsafe function` ("it is unsafe to call me and my contents are unsafe") and `function () unsafe { }` ("my contents are unsafe, but it is safe to call me as I have done my due diligence to ensure I am safe at the boundaries"), mostly because I really am not a fan of the namespace nesting style often seen in C++, i.e.

```js
function f() { unsafe { 
  ...
} }
```

[11:28:43.0993] <iain>
Yeah, given my previous experience in Rust, that's what I thought you were proposing initially. The problem is that then every call that is not in an unsafe context is responsible for checking that the callee is not an unsafe function, which potentially slows down polymorphic code.

[11:28:58.0366] <rbuckton>
Where `... unsafe { }` is just syntactic sugar for `... { unsafe { } }`

[11:29:32.0224] <iain>
(Although there's a chance that we could fold it into checks that we already have to do to ensure that you don't call a derived constructor without `new`)

[11:31:05.0883] <rbuckton>
Could that slow down be handled via a function stub, such that "safe" code has no overhead (if it calls the stub, the stub throws), while "unsafe" code has overhead as it must check for the stub to step over it, or to pass the stub a flag indicating safety.

[11:31:15.0109] <rbuckton>
 * Could that slow down be handled via a function stub, such that "safe" code has no overhead (if it calls the stub, the stub throws), while "unsafe" code has overhead as it must check for the stub to step over it, or to pass the stub a flag indicating safety?

[11:33:44.0340] <rbuckton>
We already expect "unsafe" code will have some additional complexity even without the notion of an `unsafe {}` block, purely because reads and writes potentially require agent coordination

[11:35:57.0145] <iain>
At a hardware level there isn't really any way to pass a flag that doesn't require the safe caller to do at least a little bit of work to not pass it

[11:37:53.0546] <iain>
(That's maybe not true if you imagine that we have some sort of global "are we in an unsafe block" flag that gets cleared when unsafe code calls into safe code and reset when we return, but keeping that flag set correctly seems potentially complicated.)

[11:38:32.0625] <rbuckton>
So "safe code just calls the function" as normal (which throws for the stub), and "unsafe code first checks if the function is an unsafe function stub and then calls the underlying function" isn't an option?

[11:38:33.0004] <iain>
The overall performance cost here is pretty small

[11:39:09.0058] <rbuckton>
I'll admit, I'm primarily coming at this from the spec perspective, and not the perspective of an implementer or optimizin gcompiler.

[11:40:00.0055] <iain>
Yeah, I guess I can see some ways of making that work. 

[11:41:03.0166] <iain>
Although they end up adding a fair bit of complexity to some already very complicated code

[11:41:05.0206] <rbuckton>
But I wouldn't expect a global flag is necessary given that `unsafe {}` is purely syntactic and could be used to drive transformations or optimizations based on its presence in the parse tree.

[11:44:44.0476] <iain>
Taking a step back: this can all be implemented, and with sufficient elbow grease the overhead could be minimized. The question is whether coloured functions provide enough value to justify engines spending their limited elbows on this instead of the million other things we could be implementing / optimizing.

[11:51:38.0938] <shu>
i don't think function coloring is problematic from engines' perspectives, but it is pretty bad for usability, especially since we already have async/non-async

[11:55:40.0735] <iain>
Actually, now that I'm thinking through the implementation, even normal `unsafe` blocks are at least a little annoying to implement, because it means that every GetProperty needs to know its location in the source. Or else you use a global flag, and clear it around calls?

[11:56:52.0924] <shu>
i was actually imagining something even dumber, like outputting different bytecode

[11:57:21.0897] <shu>
since it's lexical

[11:57:39.0753] <iain>
Oh, yeah, maybe that works too

[11:57:59.0559] <littledan>
could still be slightly annoying maybe to maintain two types of property access, with their ICs and such

[11:58:11.0811] <rbuckton>
My biggest concern was `unsafe` having `async`/`await`-like poisoning effects. Introducing `async` to a sync function normally poisons it's callers if they must maintain sequential execution. Given that you can nest an `unsafe{}` block in safe code, the concern is lessened somewhat. In the call I said that an `unsafe function` doesn't perform any implicit synchronization or coordination, so its up to the author to implement any necessary coordination, including none at all. The "none at all" coordination was meant as a way for you to decompose an `unsafe` function into multiple `unsafe` functions without having to guard against "safe" code invoking them unintentionally by leveraging scoping. Function coloring at this level isn't quite as bad as I'd feared, and has the benefit of pushing the user to implement safety in a function not marked `unsafe`.

[11:58:32.0422] <shu>
> <@littledan:matrix.org> could still be slightly annoying maybe to maintain two types of property access, with their ICs and such

V8 bytecodes at least can have immediate arguments. it could be a Get with an "in-unsafe-block" bit

[11:59:06.0490] <shu>
like, the same way "should throw" flags are threaded through for strict code

[12:00:04.0837] <iain>
SM has SetProp/StrictSetProp and so on

[12:00:21.0710] <iain>
Although most of the code is shared

[12:00:26.0344] <shu>
yeah, same

[12:00:28.0175] <iain>
It ends up being similar in practice

[12:00:31.0917] <shu>
same to "most of the code is shared"

[12:01:38.0020] <rbuckton>
In other words, this
```js
unsafe function readMessage(workArea) { ... }
unsafe function writeMessage(workArea, message) { ... }
unsafe function processMessage(message) { ... }

function processWorkArea(workArea) unsafe {
  let message;
  while (message = readMessage(workArea)) {
    const result = processMessage(message);
    writeMessage(workArea, result);
  }
}
```
Doesn't seem quite so bad to me (though I still prefer `function() unsafe { }` to `function() { unsafe { } }`)

[12:03:17.0239] <rbuckton>
 * In other words, this

```js
unsafe function readMessage(lck, workArea) { ... }
unsafe function writeMessage(workArea, message) { ... }
unsafe function processMessage(message) { ... }

function processWorkArea(mut, workArea) unsafe {
  using lck = new UniqueLock(mut);
  let message;
  while (message = readMessage(lck, workArea)) {
    const result = processMessage(message);
    writeMessage(workArea, result);
  }
}
```

Doesn't seem quite so bad to me (though I still prefer `function() unsafe { }` to `function() { unsafe { } }`)

[12:04:41.0124] <rbuckton>
It has the upside of preventing users from inadvertently invoking unsafe code from safe code and allows you to declare your function as not only containing unsafe code, but also indicating that it doesn't internally perform any coordination.

[12:08:57.0608] <rbuckton>
In C#, `unsafe` can apply to a function/method, but does not affect callers: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/unsafe

[12:09:41.0438] <rbuckton>
Though `unsafe` in C# is primarily around direct access to pointers (which Rust also shares).

[12:10:01.0273] <iain>
For me the uncertainty about the value of function colouring implies strongly that we should leave out `unsafe function` syntax for now. In the future we will have much more user experience to help determine what that syntax should mean.

[12:14:02.0398] <rbuckton>
I'd really like to be able to write conventional JS with shared structs when I know I already have exclusive access to an object. If we only have `unsafe {}`, I can't write this
```js
unsafe function doWork(task, timeout = task.timeout ?? 1000) { ... }
```
and instead must write this
```js
function doWork(task, timeout) {
  unsafe {
    timeout ??= task.timeout ?? 1000;
    ...
  }
}
```

[12:16:11.0644] <rbuckton>
However, I do see the potential value of safe code erroring if you invoke `doWork`, since `doWork` here _doesn't_ implement a coordination mechanism as it's intended to be used from another function that does. Instead, I must indicate it by convention, i.e. `function doWorkUnsafe()` to draw attention to its use.

[12:21:14.0726] <rbuckton>
Let me be clear on my position though. If we must have `unsafe`, but can only have `unsafe {}` for now, I'm fine with that. I do think the lack of an `unsafe` marker for functions and class/struct bodies is a major DX wart that will very likely need to be addressed at some point, function coloring or not. I just don't want to go down a road of allowing `import`/`export` inside of an `unsafe` block as it would likely be a long term aesthetic wart on the language *after* we introduce an `unsafe` marker in other contexts.

[12:23:54.0877] <rbuckton>
We *could* consider an alternative to make `import`/`export` work, by declaring the entire module as `unsafe` via something like `unsafe module;` (or some other incantation) at the top level.

[12:25:10.0966] <rbuckton>
Or use module blocks, i.e.:

```js
unsafe module M {
  export shared struct AtomicValue { ... }
}
export * from M;
```

[12:25:18.0769] <rbuckton>
 * Or use module blocks, e.g.:

```js
unsafe module M {
  export shared struct AtomicValue { ... }
}
export * from M;
```

[12:26:49.0541] <rbuckton>
(though that still uses `unsafe` as a prefix)

[12:32:55.0316] <rbuckton>
I'd also be fine with postfix-`unsafe` markers for declarations (`function f() unsafe { }`) and potentially allowing `unsafe` in both positions (`unsafe function f() {}` and `function f() unsafe {}`, though `unsafe function f() unsafe {}` is redundant). I'd also be fine with `unsafe` markers for parameters much like I suggested for variable and field initializers in a world where we either can't have postifx-`unsafe` or if postfix-`unsafe` can't include parameters, e.g.:
```js
function doWork(task, unsafe timeout = task.timeout ?? 1000) {
  unsafe { ... }
}
```


[12:35:39.0858] <rbuckton>
IMO, only having `unsafe {}` is not ideal, though `do unsafe {}` would make that *somewhat* more bearable, e.g.:
```js
function doWork(task, timeout = do unsafe { task.timeout } ?? 1000) {
  unsafe { }
}
```
But for that we would need `do {}` to advance.

[12:36:47.0395] <rbuckton>
Or we would have to advance `unsafe {}` as an expression as well, which would be confusing if we do end up advancing `do`.

[15:08:02.0343] <littledan>
It would be great if someone brought do expressions back to committee. My understanding is that bakkot is leaving that for others to champion. (Maybe there is some remaining controversy but I don’t know what it is)

[15:29:04.0986] <iain>
It looks like we decided in [March 2021](https://github.com/tc39/notes/blob/main/meetings/2021-03/mar-9.md) that we were going to do some sort of user study. Did anything ever come of that?

[16:24:54.0113] <Mathieu Hofman>
> <@rbuckton:matrix.org> An alternative to `unsafe function f() {}` that I'd also put on the explainer might be `function f() unsafe { }`. My concern is that this isn't obvious that it also affects the parameter list. Then again `function f() { "use strict"; }` affects the parameter list as well.

I am honestly suspicious of any code that attempts to do anything with a shared struct passed in arguments without first satisfying whatever synchronization mechanism is appropriate to access that shared struct. As such I suspect that only allowing unsafe blocks is actually a benefit as it would force authors to consider whether they've first satisfied the synchronization responsibility they're supposed to take on, and which seem hard to satisfy within the parameters list alone.

[16:35:18.0270] <Mathieu Hofman>
> <@rbuckton:matrix.org> I'd really like to be able to write conventional JS with shared structs when I know I already have exclusive access to an object. If we only have `unsafe {}`, I can't write this
> ```js
> unsafe function doWork(task, timeout = task.timeout ?? 1000) { ... }
> ```
> and instead must write this
> ```js
> function doWork(task, timeout) {
>   unsafe {
>     timeout ??= task.timeout ?? 1000;
>     ...
>   }
> }
> ```

Can't you define your `doWork` function inside an unsafe block instead?

[16:35:28.0469] <rbuckton>
In an earlier example I showed how you might decompose a series of `unsafe` operations into multiple functions, where only the entrypoint function would perform any coordination, i.e.:
```js
unsafe function readMessage(...) { ... }
unsafe function writeMessage(...) { ... }
unsafe function processMessage(...) { ... }
function processWorkArea(workArea) {
  unsafe {
    // performs locking
    // calls readMessage/writeMessage/processMessage
  }
}
```

If we have `unsafe function`, we can enforce that safe code cannot invoke an `unsafe` function directly, or inadvertently. 
If we do not have `unsafe function` and only have `unsafe {}`, then we cannot perform such enforcement and there is no clear delineation between a safe entrypoint and unsafe code:

```js
function readMessage(...) { unsafe { ... } }
function writeMessage(...) { unsafe { ... } }
function processMessage(...) { unsafe { ... } }
function processWorkArea(workArea) {
  unsafe {
    // performs locking
    // calls readMessage/writeMessage/processMessage
  }
}
```
Here, `readMessage` will not perform any independent coordination or locking as it expects to be called by `processWorkArea`, which is the function that would actually perform locking. A user could inadvertently invoke `readMessage` from "safe" code, resulting in a data race. The only way to enforce this is by convention, thus you would instead want to write this as:
```js
function readMessageUnsafe(...) { unsafe { ... } }
function writeMessageUnsafe(...) { unsafe { ... } }
function processMessageUnsafe(...) { unsafe { ... } }
function processWorkArea(workArea) {
  unsafe {
    // performs locking
    // calls readMessageUnsafe/writeMessageUnsafe/processMessageUnsafe
  }
}
```

[16:37:36.0948] <rbuckton>
> <@mhofman:matrix.org> Can't you define your `doWork` function inside an unsafe block instead?

It's not quite so easy if I want to make `doWork` available to code outside of the block:

```js
let doWork;
unsafe {
  doWork = function() { ... };
}
```

This would be a regular frustration developers would encounter, both here and with `import`/`export`, or shared struct bodies, etc.

[16:38:33.0274] <rbuckton>
Blocks are best for localizing the transition from safe to unsafe. They're terrible for encapsulating declarations since you generally want at least one declaration to escape the block to be actually usable.

[16:38:47.0903] <Mathieu Hofman>
I do find interesting the proposition that the user could define unsafe functions that like shared struct fields do need to be called from an unsafe context. As mentioned that seems to point we could for know reserve that space in the syntax for later 

[16:39:48.0661] <iain>
Note that we could also simply allow
```
unsafe {
  let doWork = ...; 
}
```

[16:40:45.0958] <iain>
An unsafe block doesn't have to be a separate lexical scope of its own

[16:41:04.0557] <shu>
i would strongly prefer that something that looks like `{ }` be its own lexical scope

[16:41:26.0835] <rbuckton>
lexical scoping should never escape a `{}`, that would be a terrible precedent.

[16:41:29.0154] <shu>
that is a pretty deep affordance

[16:41:30.0629] <shu>
yeah

[16:41:46.0642] <rbuckton>
We don't even let class decorators access lexically scoped private names.

[16:41:56.0983] <rbuckton>
 * We don't even let class decorators access lexically scoped private names since they're outside of the class body

[16:41:59.0689] <iain>
I point to the parallel of namespace blocks in C++, where indenting them like:
```
unsafe {

let doWork = ...

}
```
makes it less confusing.

[16:42:11.0219] <shu>
> <@mhofman:matrix.org> I do find interesting the proposition that the user could define unsafe functions that like shared struct fields do need to be called from an unsafe context. As mentioned that seems to point we could for know reserve that space in the syntax for later

runtime enforcement of colored functions like that is probably a no-go

[16:42:24.0330] <shu>
> <@iain:mozilla.org> I point to the parallel of namespace blocks in C++, where indenting them like:
> ```
> unsafe {
> 
> let doWork = ...
> 
> }
> ```
> makes it less confusing.

nty :)

[16:43:17.0028] <rbuckton>
I maintain that C++ `namespace`-like indentation is a terrible aesthetic that we should not go out of our way to replicate.

[16:43:54.0732] <shu>
there is the worse-is-worse alternative of `"use unsafe"` which doesn't imply anything about scoping

[16:44:07.0686] <shu>
however, i find directives bad precisely because of that

[16:44:27.0503] <Mathieu Hofman>
All this now makes me realize something. What is the compatibility story of shared structs (and I suppose unsafe functions in the future) with Proxy. I don't think that we should prevent constructing a proxy with such a target, but I also assume a proxy trap implementation wouldn't be exempted from unsafe checks when accessing the target, even if the trap was triggered from an unsafe block. Is the only option that proxy traps be updated to become unsafe themselves? Is there a way to dynamically test whether an object has an unsafe color?

[16:44:45.0296] <shu>
there is no function coloring

[16:44:50.0457] <shu>
proxies just work?

[16:45:06.0726] <rbuckton>
No, they wouldn't.

[16:45:20.0256] <shu>
why wouldn't proxies just work?

[16:45:38.0064] <iain>
You need to have an unsafe block inside the proxy trap, don't you?

[16:45:48.0429] <rbuckton>
They would work as long as you don't have a proxy trap for `get` or `set`

[16:46:21.0580] <rbuckton>
But I don't imagine that `unsafe` magically carries through to proxies via the `get` and `set` traps.

[16:46:34.0366] <shu>
sorry, that's what i mean. proxies "just compose", unless there's interposed user code like a trap

[16:46:41.0362] <Mathieu Hofman>
Also would the Reflect intrinsics be "forwarding" the unsafe environment? Aka throw if not called from an unsafe block when bottoming out in accessing an unsafe receiver?

[16:46:43.0204] <shu>
in which case, exactly as ron says, they'd need their own `unsafe { }` marker

[16:46:58.0673] <shu>
it works exactly like strict mode throwing

[16:47:42.0701] <rbuckton>
If you have a shared struct `s` and you need an `unsafe` block to read `s.x`, then `new Proxy(s, { get(target, key, receiver) { return Reflect.get(target, key, receiver); } }).x` would through because neither the `get` trap nor `Reflect.get` can read/write the struct's fields.

[16:48:10.0572] <rbuckton>
 * If you have a shared struct `s` and you need an `unsafe` block to read `s.x`, then `new Proxy(s, { get(target, key, receiver) { return Reflect.get(target, key, receiver); } }).x` would throw because neither the `get` trap nor `Reflect.get` can read/write the struct's fields.

[16:49:23.0588] <Mathieu Hofman>
* I do find interesting the proposition that the user could define unsafe functions that like shared struct fields do need to be called from an unsafe context. As mentioned that seems to point we could for now reserve that space in the syntax for later 

[16:49:24.0846] <rbuckton>
e.g., we might need a `Reflect.unsafeGet` and a `{ unsafeGet }` trap, or we'd need to be able to pass `unsafe` as a flag to the trap/Reflect.get

[16:50:31.0048] <rbuckton>
Would you want `Reflect.get(s, "x")` to work outside of an `unsafe` context?

[16:51:16.0916] <Mathieu Hofman>
> <@shuyuguo:matrix.org> runtime enforcement of colored functions like that is probably a no-go

How is calling different from field access? Doesn't the receiver need to perform some check in both cases?

[16:51:17.0715] <shu>
i feel like it really shouldn't?

[16:51:21.0331] <rbuckton>
`"use strict"` applies mostly to `set`, and informs how to react to the boolean return value of `Reflect.set()` or the `set` trap. It doesn't impact the `get` trap at all. 

[16:52:14.0849] <shu>
> <@mhofman:matrix.org> How is calling different from field access? Doesn't the receiver need to perform some check in both cases?

it's different in that Ron's sketch is completely lexical, so all property access lexically contained with `unsafe { }` can generate a different bytecode at parse time. there is no propagation from from frame to frame

[16:52:31.0827] <rbuckton>
We won't need an `unsafe` block to use `Atomics.load(s, "x")`, since that already has implications around memory order. I'm not sure where I stand on whether `Reflect.get` observes `unsafe` 

[16:53:38.0771] <rbuckton>
My design sketch is more loosely based on C#'s interpretation of `unsafe` than Rust's in that C# doesn't require `unsafe` functions be invoked from within an `unsafe` block, while Rust does.

[16:54:09.0256] <shu>
> <@rbuckton:matrix.org> We won't need an `unsafe` block to use `Atomics.load(s, "x")`, since that already has implications around memory order. I'm not sure where I stand on whether `Reflect.get` observes `unsafe`

i'm not sure mark would agree to that, actually. while it's true `Atomics.load` can't exhibit a *data* race, it can still exhibit races. so if mark's desired guarantee is "no non-deterministic races arising from shared memory at all", then it should also require `unsafe`. otherwise it can be outside of `unsafe`

[16:54:12.0914] <iain>
While I'm agnostic about the value of function colouring, I don't see why you can't generate different bytecode for calls in the same way you do for property access.

[16:55:19.0885] <iain>
It is definitely unfortunate that it would require calls to perform an extra check in safe contexts (aka normal code that isn't touching any of this stuff), but it seems technically feasible to enforce.

[16:55:46.0878] <shu>
> <@iain:mozilla.org> While I'm agnostic about the value of function colouring, I don't see why you can't generate different bytecode for calls in the same way you do for property access.

i guess i don't know how the unsafe propagation works. if i have `unsafe { safeFunction(); } function safeFunction() { unsafeFunction(); } unsafe unsafeFunction() { ... }`, does that work or does that throw?

[16:55:51.0703] <Mathieu Hofman>
> <@shuyuguo:matrix.org> it's different in that Ron's sketch is completely lexical, so all property access lexically contained with `unsafe { }` can generate a different bytecode at parse time. there is no propagation from from frame to frame

Can't you generate a different byte code for unsafeCall? An unsafe function would throw on regular call. A safe function would accept both call and unsafeCall

[16:56:27.0051] <iain>
That throws for the same reason as anything else

[16:56:40.0547] <shu>
okay, then yes, we can also generate a different bytecode

[16:56:47.0395] <shu>
and then it comes down to do we really want another function color

[16:57:11.0981] <rbuckton>
> <@shuyuguo:matrix.org> i'm not sure mark would agree to that, actually. while it's true `Atomics.load` can't exhibit a *data* race, it can still exhibit races. so if mark's desired guarantee is "no non-deterministic races arising from shared memory at all", then it should also require `unsafe`. otherwise it can be outside of `unsafe`

I don't see a way to have `Atomics.load` be aware of `unsafe` unless we start treating it like we do direct vs. indirect eval? Otherwise we essentially *would* have function coloring, but only for `Atomics` methods and only when they receive a `shared struct` argument.

[16:58:29.0886] <shu>
good point. for Atomics.load to require `unsafe` would require an `UnsafeCall` internal bytecode as we've been discussing

[16:58:47.0089] <rbuckton>
So would it be better to special case function coloring purely for the `Atomics` methods, or just make it a more general mechanism? 

[16:58:57.0860] <shu>
but that'll be an implementation detail, and is orthogonal to whether we expose that coloring to user code

[16:59:17.0349] <iain>
I don't see any backwards-compatible way to make Atomics methods usefully unsafe

[16:59:36.0783] <shu>
well, Atomics currently don't work on field names, only TAs and indices

[16:59:42.0696] <shu>
that will remain usable everywhere

[16:59:49.0756] <shu>
and there will be magic to make the new forms throw outside of `unsafe`


2024-07-03
[17:00:19.0016] <shu>
(the magic from a spec perspective will be, like, look at the current parse node being evaluated, and then find the nearest enclosing block)

[17:00:38.0982] <rbuckton>
I don't necessarily think we *need* general purpose function coloring, though I do like the additional guardrail that provides. I'm primarily interested in just improving the DX of `function f() { unsafe {` and `function f(x, y = do unsafe { x.y })` since those feel very awkward 

[17:01:29.0592] <rbuckton>
> <@shuyuguo:matrix.org> (the magic from a spec perspective will be, like, look at the current parse node being evaluated, and then find the nearest enclosing block)

Wouldn't we just look at the current lexical environment as part of Call?

[17:01:33.0867] <Mathieu Hofman>
To inform this intrinsics call coloring question, I think the `Reflect.get` case is interesting. Would you expect `unsafe { Reflect.get(sharedStruct, "foo") }` to work?

[17:01:46.0805] <shu>
> <@rbuckton:matrix.org> Wouldn't we just look at the current lexical environment as part of Call?

oh true, it'll always have one

[17:02:08.0183] <shu>
must be nice to have an implementation that never optimizes away scopes!

[17:04:12.0551] <rbuckton>
> <@mhofman:matrix.org> To inform this intrinsics call coloring question, I think the `Reflect.get` case is interesting. Would you expect `unsafe { Reflect.get(sharedStruct, "foo") }` to work?

IIRC, C#'s `unsafe` (which is primarily for working directly with pointers) does not require `unsafe` to interact with pointers via reflection, but C#'s reflection is significantly different from JS's.

[17:05:07.0422] <rbuckton>
If we did require `unsafe`, then `Reflect.get` et al would also need an UnsafeCall

[17:05:36.0154] <Mathieu Hofman>
Good point. I would expect `Reflect.get` to throw if not in an unsafe context. 

[17:06:46.0054] <rbuckton>
But there would still be no carryover of `unsafe { proxyForS.x }` through a `get` trap, and just marking every proxy trap `unsafe` is dangerous.

[17:07:04.0004] <Mathieu Hofman>
Which now means we need an unsafeCall trap for proxies if we expose this to user land. Ugh

[17:08:26.0484] <shu>
hey man i'm also happy being laissez-faire with data races

[17:08:33.0529] <rbuckton>
We could instead have `new Proxy(s, { get(target, key, receiver, unsafe) { return Reflect.get(target, key, receiver, unsafe); } })` and traffic the caller's `unsafe`-ness around as a parameter.

[17:10:01.0293] <shu>
seems fine

[17:10:50.0188] <Mathieu Hofman>
Seems not, that would effectively allow creating unsafe context without syntax

[17:12:04.0108] <shu>
maybe `unsafe` will be some unforgeable capability token?

[17:12:16.0300] <shu>
i guess we can't prevent it from being exfiltrated

[17:12:22.0375] <rbuckton>
We either have all of this complexity, or we say:
- no function coloring
- `Atomics` methods are internally `unsafe` (so `Atomics.load(s, "x")` doesn't require an `unsafe` block)
- `Reflect` methods are internally `unsafe` (so `Reflect.get(s, "x")` doesn't require an `unsafe` block)
- The fact that a shared struct field is unsafe is carried through a proxy as we do other invariants in proxies, so you can't transparently make a Proxy "safe" if its fields are unsafe.

[17:13:13.0750] <rbuckton>
For the 4th bullet, that would mean `new Proxy(s, { get() { } }).x` would throw outside of an `unsafe` block without ever invoking the `get` trap

[17:13:14.0379] <shu>
i am definitely coming around to Atomics being internally unsafe, after what i said above

[17:13:21.0325] <shu>
in fact that's basically all Atomics do, access shared memory

[17:13:30.0011] <shu>
so they have to be internally unsafe in a no function coloring world

[17:14:12.0281] <rbuckton>
> <@shuyuguo:matrix.org> in fact that's basically all Atomics do, access shared memory

Access shared memory and _enforce sequential ordering of memory accesses_, which _is_ a coordination mechanism.

[17:14:20.0574] <shu>
yes, fair

[17:14:38.0548] <Mathieu Hofman>
Maybe for atomics, but I'm a lot less comfortable for reflect

[17:15:15.0204] <iain>
Atomics are grandfathered in, and it's not too bad to say "grep for 'atomics' and 'unsafe' to audit"

[17:15:18.0233] <rbuckton>
Otherwise what's the purpose of all of the happens-before and all of the other ordering relations in https://tc39.es/ecma262/#sec-relations-of-candidate-executions

[17:15:22.0704] <iain>
I agree that reflect is a harder case

[17:16:04.0150] <shu>
it could also be that `Reflect` methods are not internally `unsafe`, so they just straight up don't work in any context on shared structs

[17:16:10.0855] <shu>
*i* can live with that

[17:16:17.0097] <rbuckton>
> <@iain:mozilla.org> Atomics are grandfathered in, and it's not too bad to say "grep for 'atomics' and 'unsafe' to audit"

I'm not so sure I would characterize Atomics as "grandfathered in", given they are already a complex coordination mechanism.

[17:16:49.0259] <shu>
you then have to add `Reflect.unsafeGet` and `Reflect.unsafeSet` that are internally `unsafe`

[17:16:53.0472] <iain>
What I mean is that if you want to audit potential data races in your code, you have to look at your uses of Atomics, and we can't put that horse back in the barn

[17:17:07.0898] <shu>
no, Atomics can never exhibit data races

[17:17:11.0398] <shu>
only normal races

[17:17:24.0518] <iain>
Sorry, yeah, that's what I meant

[17:20:04.0549] <shu>
i'm off for the rest of the week. good progress and discussion everyone

[17:20:15.0863] <rbuckton>
I think "no function coloring" is a far simpler approach, overall. We shouldn't buy into that complexity unless it is absolutely necessary.

[17:21:08.0196] <rbuckton>
I think it has some interesting benefits, but I don't know that they outweigh the implementation complexity.

[17:21:41.0855] <iain>
I think it is worth preserving flexibility to add it later if it does not significantly conflict with other goals

[17:21:47.0989] <iain>
But I do not want function colouring now

[17:23:02.0621] <rbuckton>
In which case, I would still argue in favor of `unsafe function f() {}` as meaning something closer to C#'s interpretation than Rust's, in that `unsafe` in this case is only tagging the declaration as having an `unsafe` lexical scope, since `unsafe` tagging readily solves issues with lifting safe entrypoints to unsafe code out of an `unsafe {}` block.

[17:24:46.0671] <rbuckton>
We already have this problem with private state, I'd like us not to repeat that mistake.

[17:31:32.0588] <rbuckton>
```js
// c.js

// expose #x to other declarations in the same lexical scope
let getX;

export class C {
  #x;
  static {
    getX = c => c.#x;
  }
}

export class FriendOfC {
  method(c) {
    x = getX(c); // privileged access to #x
  }
}

// other.js
import { C, FriendOfC } from "./c.js";

// can't get to C's #x
```

While it's one of the reasons I proposed `static {}`, it's still awkward to work with.


2024-07-09
[14:33:16.0855] <shu>
FYI i have a conflict for the next working session on Thu, July 18. there isn't also a good time to reschedule as i am OOO the week after, then the week after that is TC39

[14:34:31.0601] <shu>
i strongly encourage you all to have the call without me

[16:49:34.0170] <Mathieu Hofman>
I would be open to moving another day, like Tuesday 16th ? I'll double check with Mark, but according to his calendar that should be fine for him too


2024-07-10
[17:00:04.0971] <shu>
i can't do next 2 weeks at all

[17:00:16.0243] <shu>
will be at a team event in europe

[17:04:25.0500] <shu>
Mathieu Hofman: i can still discuss async though. perhaps we should start a thread about your ideas for a registry that's acceptable?

[17:08:25.0870] <Mathieu Hofman>
I'm honestly not sure I'll have the bandwidth to collect my thoughts on a capability based type registry. I would however love to hear more from littledan who suggested something around modules.


2024-07-11
[01:54:28.0827] <littledan>
I'd be happy to run the meeting on the 18th while Shu is absent. We can chat about capabilities and the module registry then, working it out together as a group. I really like Mark's thoughts around that. I think Nicolo also has some thoughts.

[11:19:35.0083] <Mathieu Hofman>
We probably also should close the loop on the Matrix discussion above about coloring of unsafe functions, and how Atomics/Reflect APIs should work with shared object in unsafe contexts

[13:34:30.0463] <littledan>
> <@mhofman:matrix.org> We probably also should close the loop on the Matrix discussion above about coloring of unsafe functions, and how Atomics/Reflect APIs should work with shared object in unsafe contexts

Could you summarize the positions on that here?

[13:34:48.0256] <littledan>
I thought we all agreed, no coloring

[13:35:06.0773] <littledan>
(Not sure how Atomics or Reflect should work, though)

[14:47:13.0461] <Mathieu Hofman>
I think we all agreed no function coloring for now, but multiple of us expressed we wanted to leave the option open for the future.

If we make Atomics and Reflect behave differently in unsafe vs safe contexts, function coloring could explain that. 

[15:53:04.0807] <rbuckton>
Though we don't necessarily need to justify special behavior for builtins, but coloring could explain that *later*, if we decided to extend it elsewhere in the language

[15:54:32.0700] <rbuckton>
Also, while I'd like a better DX for `unsafe` function bodies, I can live with that coming later in a follow on. 

[15:57:08.0139] <rbuckton>
But both `Atomics` and `Reflect` need to work, whether that is magically or blindly.


2024-07-12
[23:45:48.0284] <littledan>
What is the magical/non-coloring version of them working?

[00:22:52.0493] <Mathieu Hofman>
I think they could check whether they are in an unsafe context and only allow access to shared structs in that context. That could later be explained as having both a safe and an unsafe implementation.

[00:27:40.0576] <littledan>
what does it mean to check whether they are in an unsafe context? Does that refer to their immediate caller?

[01:03:24.0814] <Mathieu Hofman>
Good question. I'm not sure I have given it that much thought. 


2024-07-13
[10:06:30.0034] <snek>
i understand that it is proposed to require an unsafe scope to access shared values, but what does unsafe actually mean? like what is the model we are using to categorize things as safe or unsafe.

[10:14:33.0654] <snek>
 * i understand that it is proposed to require an unsafe scope to access shared values, but what does unsafe actually mean? like what is the model we are using to categorize things as safe or unsafe. and i guess in particular i'm curious if things we categorize as unsafe really justify the syntax. in rust and c# (i think?), unsafe marks a place where you can actually violate some fundamental model of the language, which i'm hoping you cannot do inside a js unsafe block?

[10:21:49.0453] <snek>
 * i understand that it is proposed to require an unsafe scope to access shared values, but what does unsafe actually mean? like what is the model we are using to categorize things as safe or unsafe. and i guess in particular i'm curious if things we categorize as unsafe really justify the syntax. in rust (and c# i think?), unsafe marks a place where you can actually violate some fundamental model of the language, which i'm hoping you cannot do inside a js unsafe block?

[12:11:41.0489] <rbuckton>
My impression from Mark's previous comments is that's evacuate what this is. Single-threaded, exclusive memory access is the fundamental model of JS (SAB aside). `unsafe` in this context is about JS code accessing data structures held in shared memory. 

[12:11:55.0904] <rbuckton>
* My impression from Mark's previous comments is that's exactly what this is. Single-threaded, exclusive memory access is the fundamental model of JS (SAB aside). 
unsafe in this context is about JS code accessing data structures held in shared memory.

[12:12:15.0608] <rbuckton>
* My impression from Mark's previous comments is that's exactly what this is. Single-threaded, exclusive memory access is the fundamental model of JS (SAB aside). `unsafe` in this context is about JS code accessing data structures held in shared memory.

[12:13:46.0269] <snek>
you're saying that inside unsafe you can put the js vm into a state that prevents it from continuing to evaluate javascript in the way that it expects?

[12:15:04.0809] <rbuckton>
While I don't imagine we'd ever add much else to `unsafe` in JS (e.g., pointers), we could if necessary. 

[12:16:29.0855] <rbuckton>
> <@devsnek:matrix.org> you're saying that inside unsafe you can put the js vm into a state that prevents it from continuing to evaluate javascript in the way that it expects?

So far, only the potential for deadlocks preventing execution, AFAIK, though you can still get in that state with SAB and `Atomics.wait`

[12:17:09.0419] <snek>
but SAB has a memory model that is defined for unsyncronized accesses.

[12:19:08.0416] <rbuckton>
But it can't easily be used for data structures, so it's adoption is quite low. Shared Structs will be far easier to adopt, and thus much more problematic 

[12:19:59.0372] <rbuckton>
* But it can't easily be used for data structures, so it's adoption is quite low. Shared Structs will be far easier to adopt, and thus users are more likely to run afoul of shared memory issues

[12:21:20.0466] <snek>
are you saying that the behavior will be undefined?

[12:21:34.0089] <snek>
i feel like mark, and all implementations, would object to that

[12:23:47.0076] <rbuckton>
No, not undefined. 

[12:26:58.0249] <rbuckton>
I'm not clear if your concern is the choice of keyword, or the need for any syntax at all. I'll happily entertain other keywords, but it seems like Mark is quite satisfied with there being a syntax with the semantic proposed as addressing his concern. 

[12:27:59.0178] <snek>
my question was "what does unsafe mean" and then i tacked on an opinion after that which was "if unsafe is just marking some particular way of creating logic bugs i'm not sure its worth it"

[12:28:30.0330] <snek>
 * sorry for the confusion, to rephrease... my question was "what does unsafe mean" and then i tacked on an opinion after that which was "if unsafe is just marking some particular way of creating logic bugs i'm not sure its worth it"

[12:37:48.0041] <snek>
 * sorry for the confusion, to rephrase... my question was "what does unsafe mean" and then i tacked on an opinion after that which was "if unsafe is just marking some particular way of creating logic bugs i'm not sure its worth it"


2024-07-14
[17:07:48.0433] <littledan>
Here’s an idea for the semantic details for unsafe, Reflect, Atomics, and MOP for shared structs:
- There is an abstract op, GetUnsafe(obj, propKey), which checks whether the obj is a shared struct, if so tries to get the propKey, if it is missing or if it isn’t a shared struct, fall back to Get. Analogously for SetUnsafe.
- Reflect.getUnsafe/setUnsafe expose these ops
- inside of an unsafe {} block, all direct property access is interpreted as GetUnsafe/SetUnsafe
- Get and Set on shared structs are missing their own data properties. Those props don’t show up for any other MOP things either. But the thread-local prototype is present (it isn’t unsafe; a method might call an unsafe thing as an implementation detail though)
- Atomics are always unsafe (that’s literally the point) so they are just overloaded for shared struct properties regardless of where they come from.
- if we were doing SAB today, we might also consider this same unsafe restriction, but what’s done is done. This only applies for shared structs.

[18:10:37.0743] <rbuckton>
The property keys need to show up in MOP operations. `in` and `hasOwnProperty` and `Reflect.has` are safe because structs have a fixed layout. 

[18:12:07.0932] <rbuckton>
Though [[Get]] and [[Set]] would throw

[18:14:34.0328] <rbuckton>
What do you mean by "Atomics are always unsafe?" my perspective is that Atomics should not need an `umsafe` block at all

[18:18:20.0291] <rbuckton>
* What do you mean by "Atomics are always unsafe?" my perspective is that Atomics should not need an `unsafe` block at all

[18:22:24.0856] <littledan>
> <@rbuckton:matrix.org> What do you mean by "Atomics are always unsafe?" my perspective is that Atomics should not need an `unsafe` block at all

I think we are saying the same thing 

[18:22:29.0811] <rbuckton>
OK

[18:23:06.0280] <littledan>
> <@rbuckton:matrix.org> The property keys need to show up in MOP operations. `in` and `hasOwnProperty` and `Reflect.has` are safe because structs have a fixed layout. 

Sure, that makes sense. The important thing is that normal MOP operations can’t get at the contents, it’s just this other operation that can

[18:23:22.0214] <rbuckton>
The rest of what you describe sounds like another namespace (like private names) which we absolutely do not want

[18:23:45.0668] <littledan>
> <@rbuckton:matrix.org> The rest of what you describe sounds like another namespace (like private names) which we absolutely do not want

Not sure what you mean. It is still strings (or maybe symbols)

[18:24:18.0648] <littledan>
I am not especially attached to the idea I wrote above, it is just the simplest thing I can imagine. How do you think unsafe blocks should work with respect to the MOP?

[18:24:49.0226] <rbuckton>
It sounded like you were saying that shared struct properties are transparent to MOP operations, which would not be correct

[18:25:11.0699] <littledan>
> <@rbuckton:matrix.org> It sounded like you were saying that shared struct properties are transparent to MOP operations, which would not be correct

Not transparent, just missing

[18:25:39.0950] <littledan>
Maybe that is what you meant

[18:25:45.0225] <rbuckton>
Yes, thats what I meant

[18:25:48.0412] <rbuckton>
they cannot be missing

[18:26:18.0953] <rbuckton>
You cannot have a [[Get]] outside of `unsafe` return a prototype property if there was a struct field of the same name.

[18:26:28.0074] <littledan>
Can you explain how you think it should work?

[18:26:39.0929] <rbuckton>
They have to treat them like normal properties, except that [[Get]] and [[Set]] throws.

[18:26:48.0147] <littledan>
How?

[18:27:03.0961] <rbuckton>
You override [[Get]] and [[Set]] for shared struct objects. 

[18:27:11.0257] <rbuckton>
Those are abstract.

[18:28:03.0827] <littledan>
Will GetOwnPropertyDescriptor throw?

[18:28:19.0055] <rbuckton>
Lets say you have [[Get]], [[Set]], [[UnsafeGet]], and [[UnsafeSet]]. On all objects, [[UnsafeGet]]/[[UnsafeSet]] just forwards on to the ordinary get/set behavior.

[18:28:28.0213] <littledan>
What happens in the unsafe blocks?

[18:28:30.0988] <rbuckton>
But shared structs have a [[Get]] and [[Set]] that throw.

[18:28:49.0179] <rbuckton>
In an unsafe block, get operations use [[UnsafeGet]]/[[UnsafeSet]] instead of [[Get]]/[[Set]]

[18:29:50.0003] <rbuckton>
Even without `unsafe` we need to do something similar to handle shared memory access for shared struct fields in [[Get]] and [[Set]], so we already expect to pay this cost.

[18:31:01.0615] <rbuckton>
GetOwnPropertyDescriptor would probably throw outside of `unsafe`, or possibly would return a new descriptor that is `{ enumerable: ?, writable: false, configurable: false, shared: true }` with no `value` property.

[18:31:41.0513] <littledan>
OK, so how does Object.getOwnPropertyDescriptor know if it’s in an unsafe block?

[18:31:47.0525] <rbuckton>
But `in` and `Reflect.has` et al should work outside of unsafe because for a given reference to a shared struct, it will still have a fixed shape.

[18:32:21.0828] <littledan>
I was trying to avoid functions changing behavior based on their caller

[18:33:38.0739] <littledan>
> <@rbuckton:matrix.org> You cannot have a [[Get]] outside of `unsafe` return a prototype property if there was a struct field of the same name.

I think this problem can be fixed in my suggestion without making any new MOP ops or anything

[18:33:44.0042] <rbuckton>
We could have gOPD return a new kind of descriptor both in and out of `unsafe`, and an `Reflect.unsafeGetOwnPropertyDescriptor` that has the same magic that `Reflect.unsafeGet`/`Reflect.unsafeSet` would have (if any).

[18:34:49.0920] <littledan>
Maybe gOPD would throw if you don’t call the unsafe one?

[18:35:01.0125] <rbuckton>
You need MOP operations to be reliable. What happens if I do `Object.create(sharedStruct)`? Now I have a normal JS object with a shared struct prototype. If I call [[Get]] on the result it should still throw if it tries to read a prototype field outside of `unsafe`.

[18:35:11.0468] <littledan>
Do we have unsafeDefineProperty?

[18:35:22.0775] <rbuckton>
getOPD shouldn't throw. Nothing causes it to throw today, to my knowledge.

[18:35:34.0236] <rbuckton>
No. You can't call defineProperty on a shared struct, it would fail.

[18:35:39.0595] <rbuckton>
Shared struct instances are sealed.

[18:35:46.0820] <rbuckton>
No new properties, no deleting properties.

[18:35:57.0754] <littledan>
Even if the property descriptor matches what’s already there?

[18:36:06.0907] <littledan>
> <@rbuckton:matrix.org> getOPD shouldn't throw. Nothing causes it to throw today, to my knowledge.

Proxy can 

[18:36:08.0243] <rbuckton>
Normal defineProperty would just fail because of the existing integrity checks

[18:36:43.0066] <littledan>
> <@rbuckton:matrix.org> Normal defineProperty would just fail because of the existing integrity checks

I don’t think that’s the case if you define it as what it’s already defined to be, but with a different value 

[18:36:44.0363] <rbuckton>
AFAIK, no developers code defensively against gOPD failing. 

[18:36:54.0908] <rbuckton>
That's fair

[18:37:10.0588] <rbuckton>
 * GetOwnPropertyDescriptor would probably throw outside of `unsafe`, or possibly would return a new descriptor that is `{ enumerable: ?, writable: ?, configurable: false, shared: true }` with no `value` property.

[18:37:38.0616] <rbuckton>
Maybe we do need `unsafeDefineProperty`. I do want to be able to change `writable`

[18:37:50.0780] <rbuckton>
But you can't create new properties with it, 

[18:37:55.0905] <rbuckton>
 * But you can't create new properties with it.

[18:39:06.0279] <rbuckton>
Maybe instead of `Reflect.unsafeX` we have `Reflect.unsafe.X` which just mirrors `Reflect`

[18:39:10.0058] <littledan>
I would start simple and omit unsafeGOPD and unsafeDP, letting these always throw on shared struct data props. That might be the only observable difference between the ways we are thinking about this.

[18:39:19.0738] <rbuckton>
(except for `deleteProperty` since that will never work?)

[18:39:58.0617] <littledan>
> <@rbuckton:matrix.org> Maybe instead of `Reflect.unsafeX` we have `Reflect.unsafe.X` which just mirrors `Reflect`

I am a fan of namespace objects, but I don’t know how much of this we need to fill in

[18:40:18.0053] <rbuckton>
I really would like to make fields non-writable, though I've been thinking we some kind of "init-only" modifier for fields that can only be initialized in the constructor.

[18:41:18.0267] <littledan>
> <@rbuckton:matrix.org> I really would like to make fields non-writable, though I've been thinking we some kind of "init-only" modifier for fields that can only be initialized in the constructor.

Yeah I don’t think nonwritable is a good solution for this. We would need initializer lists. Anyway I imagined shared struct fields would be nonconfigurable

[18:41:31.0569] <rbuckton>
But we probably should have some kind of `getOwnPropertyDescriptor` support at some point.

[18:41:38.0103] <rbuckton>
Yes, they are non-configurable

[18:42:20.0974] <littledan>
So… no particular use for defineProperty then

[18:42:52.0020] <littledan>
> <@rbuckton:matrix.org> But we probably should have some kind of `getOwnPropertyDescriptor` support at some point.

Some kind of introspection would be good, but maybe this should be focused on the class level

[18:43:00.0703] <rbuckton>
Even if we don't have gOPD, I want to make sure we can still do `{ ...sharedStruct }` inside of an `unsafe` block as it could be an efficient way to copy the properties off of the struct while in a lock.

[18:44:09.0788] <littledan>
> <@rbuckton:matrix.org> Even if we don't have gOPD, I want to make sure we can still do `{ ...sharedStruct }` inside of an `unsafe` block as it could be an efficient way to copy the properties off of the struct while in a lock.

Huh, how do you attach the right cross realm prototype identifier?

[18:44:30.0211] <rbuckton>
you don't? You're not creating a shared struct instance, just a normal object.

[18:44:46.0447] <rbuckton>
Shared struct instances can only be created via a constructor.

[18:45:03.0597] <littledan>
Oic. Yes that should be handled like . Access

[18:45:11.0808] <rbuckton>
`{ ...sharedStruct }` is "give me a normal object that is a copy of the struct fields"

[18:47:47.0410] <Mathieu Hofman>
I skipped a lot of the discussion, but do shared properties have to appear as data properties, or could they appear as own accessors?

[18:48:58.0743] <Mathieu Hofman>
I guess accessors would be a significant overhead and that engines wouldn't always be able to optimize the same as data props?

[18:55:13.0487] <littledan>
The problem we are trying to solve is how to explain unsafe blocks. I don’t see how accessors help.

[18:58:28.0599] <Mathieu Hofman>
Well accessors means there are no issues with any of the MOP and no special property descriptions 

[18:58:30.0700] <rbuckton>
get *already* has a lexical rule for `"use strict"`. We could just encode [[Unsafe]] on a Reference Record just as we do [[Strict]], and just have the relevant operations check [[Unsafe]] when resolving the reference.

[18:58:41.0766] <Mathieu Hofman>
* Well accessors means there are no issues with any of the MOP and no special property descriptors

[19:00:29.0055] <rbuckton>
i.e., `GetValue` checks for [[Strict]] for variable references. We could modify Step 3.d to check for [[Unsafe]] and call baseObj.[[UnsafeGet]] in that case.

[19:01:07.0161] <Mathieu Hofman>
Of course we're just pushing the problem down into a problem of function invocation working differently depending on the context where the call occurs, sometimes nested in the case of Reflect.get calling an "accessors"

[19:01:35.0371] <rbuckton>
Adding an [[UnsafeGet]] slot on objects seems to mesh better with the current spec than an UnsafeGet AO  

[19:02:34.0304] <Mathieu Hofman>
It really feels that function coloring actually explains all this much better

[19:02:45.0992] <rbuckton>
If we don't have function coloring, we could just allow you to call the `Reflect.unsafeX` outside of an `unsafe` block. Its in the name, so it's already labeled unsafe.

[19:03:23.0175] <littledan>
> <@mhofman:matrix.org> Well accessors means there are no issues with any of the MOP and no special property descriptors

How are accessors supposed to know whether they are in an unsafe block?

[19:05:13.0988] <Mathieu Hofman>
> <@littledan:matrix.org> How are accessors supposed to know whether they are in an unsafe block?

Yes that's the problem. Accessor simply reduce to a single kind of problem: function calls, instead of also dealing with the other meta ops. But it remains a problem that it's hard to explain the behavior without function coloring 

[19:06:12.0655] <littledan>
Could you describe how you picture function coloring to work?

[19:06:38.0697] <rbuckton>
e.g., something like this but with proper support for `receiver`
```js
Reflect.unsafeGet = (obj, key) => {
  if ({}.hasOwnProperty.call(obj, key)) {
    unsafe {
      return obj[key];
    }
  }
  return Reflect.get(obj, key);
}
```

[19:07:57.0255] <rbuckton>
> <@littledan:matrix.org> How are accessors supposed to know whether they are in an unsafe block?

Accessors like `get foo() { }`? They don't? They're just a function. If you expose a getter/setter on your struct you need to do your due diligence to make it safe to outside callers.

[19:09:25.0858] <rbuckton>
```js
shared struct S {
  #mut = new Atomics.Mutex();
  #x;
  get x() {
    unsafe {
      using lck = new Atomics.UniqueLock(this.#mut);
      return this.#x;
    }
  }
}
```
It's nasty, but I suppose that's the point?

[19:11:37.0503] <rbuckton>
Although, without function coloring I don't see how `accessor x;` could ever work. At least, not without doing `unsafe accessor x;` or `accessor x unsafe;` or something

[19:13:16.0506] <Mathieu Hofman>
The way I picture function coloring is that every callable now has 2 ops: `[[Call]]` and `[[CallUnsafe]]`. If you are in an unsafe block, it's CallUnsafe that gets executed. For normal functions, CallUnsafe is the same as Call (maybe it's missing and it falls back to Call when missing?). For shared functions, Call throws (can only be called from unsafe blocks). Reflect and other intrinsics can have different Call and CallUnsafe behaviors, that effectively "forward" the unsafe state of the call site.

[19:13:43.0125] <snek>
this example makes me wonder something... should a shared struct even be exposed? in rust for example you'd write your code like `struct Public(Mutex<Shared>)`, rather than `struct Public { mutex: Mutex<()>, shared: Shared }`

[19:14:01.0696] <rbuckton>
I'll have to follow up on any other discussion on Monday.

[19:14:04.0005] <snek>
 * this example makes me wonder something... should a shared struct even be exposed? in rust for example you'd write your code like `struct Public(Mutex<Shared>)`, rather than `struct Shared { mutex: Mutex<()>, ...Shared }`

[19:15:22.0594] <rbuckton>
That example I gave is a bad one 

[19:15:35.0083] <littledan>
> <@mhofman:matrix.org> The way I picture function coloring is that every callable now has 2 ops: `[[Call]]` and `[[CallUnsafe]]`. If you are in an unsafe block, it's CallUnsafe that gets executed. For normal functions, CallUnsafe is the same as Call (maybe it's missing and it falls back to Call when missing?). For shared functions, Call throws (can only be called from unsafe blocks). Reflect and other intrinsics can have different Call and CallUnsafe behaviors, that effectively "forward" the unsafe state of the call site.

this sounds coherent to me, but it's not what I would call "function coloring", which would apply recursively somehow, like async/await

[19:15:57.0369] <rbuckton>
But yes, we think a shared struct should be exposed. Mutex and shared struct are not strongly tied to each other.

[19:17:12.0247] <rbuckton>
Function coloring does not imply recursive application. Async/await poisoning occurs because you are taking an inherently sequential, synchronous operation and want to turn it into a sequential asynchronous operation.

[19:17:49.0191] <Mathieu Hofman>
> <@littledan:matrix.org> this sounds coherent to me, but it's not what I would call "function coloring", which would apply recursively somehow, like async/await

Right, technically you can have an `CallUnsafe` implementation that is not itself an unsafe scope 

[19:17:58.0110] <rbuckton>
Async/await has function coloring (of a sort), but function coloring is not async/await.

[19:18:12.0050] <snek>
no i don't mean you should have to use mutex specifically, that's just the example here.

[19:18:29.0852] <littledan>
(I'm not criticizing the approach, it's just drastically different from what I expected when people started using the term "function coloring")

[19:19:53.0814] <rbuckton>
> <@devsnek:matrix.org> no i don't mean you should have to use mutex specifically, that's just the example here.

you can organize your code however you want. My use cases have entire object graphs of shared objects with any coordination being through  lock-free concurrent collections.

[19:20:47.0723] <Mathieu Hofman>
> <@littledan:matrix.org> (I'm not criticizing the approach, it's just drastically different from what I expected when people started using the term "function coloring")

It's possible I also misunderstood what people had in mind, but that is what I understood could work

[19:22:38.0199] <rbuckton>
I was never concerned about function coloring, just that we didn't repeat async/await poisoning by essentially requiring your entire application to be inside of an `unsafe {}` block to use the feature. 

[19:22:45.0614] <Mathieu Hofman>
I think it would even be possible to make proxies work that way. As well as let user land do the same as intrinsics by having functions that have dual safe and unsafe behaviors

[19:23:12.0534] <rbuckton>
keeping `unsafe` localized to just the code that is actually unsafe is important. 

[19:24:18.0212] <rbuckton>
Having functions that are aware of the context with which they are invoked is nothing new. `unsafe` is more like `this` than `async`/`await`, to be honest. `async` functions don't care how you call them and its up to the callers to determine if they want to use `await` or `.then`.

[19:24:37.0871] <Mathieu Hofman>
> <@rbuckton:matrix.org> I was never concerned about function coloring, just that we didn't repeat async/await poisoning by essentially requiring your entire application to be inside of an `unsafe {}` block to use the feature. 

Yeah I think that's accomplished by letting you start an unsafe block without modifying the signature of the surrounding function 

[19:24:44.0573] <rbuckton>
Having an operation that throws outside of `unsafe` is more like having a function that throws if you give it the wrong `this`.

[19:26:22.0128] <rbuckton>
From a spec perspective, we just have to carry along this extra bit of information that indicates whether you were inside or outside of an `unsafe` block before you get/set.

[19:27:21.0658] <rbuckton>
Aside from whatever we decide for `Reflect`, we could just ship with `unsafe {}` and add "function coloring" later if needs be.

[19:29:43.0535] <rbuckton>
For something like `unsafe function f() {}` I was less concerned with "function coloring" and more about improving the DX by moving the `unsafe` out of the block to cover the contents of the whole function (including parameter lists). I think the fact I proposed it as a prefix keyword led to the "function coloring" implication of unsafe functions in Rust, that the function itself is somehow unsafe. But it could just as easily have been `function f() unsafe { }` (and is an alternative I mentioned in the related issue on the repo).

[19:30:50.0083] <rbuckton>
I'm just not a fan of the C++ namespace nesting style. It looks terrible and there's no reason we should repeat that approach.

[19:31:03.0944] <snek>
what if you want a function that should be unsafe to call

[19:32:19.0612] <snek>
 * what if you want a function that should be unsafe to call, `unsafe` on the declaration referring to the body seems inverted to the expectation of someone using that function.

[19:32:35.0960] <rbuckton>
> <@devsnek:matrix.org> what if you want a function that should be unsafe to call, `unsafe` on the declaration referring to the body seems inverted to the expectation of someone using that function.

Then we reserve the prefix position for that, where `unsafe <x> ...` means "x is unsafe and does unsafe things" while `<x> unsafe ...` means "x is safe, but does unsafe things".

[19:35:14.0995] <rbuckton>
i.e., `function f() unsafe {}` is just shorthand for `function f() { unsafe { } }`. You use that for functions in your API that are at the safe/unsafe boundary. `unsafe function f() {}`, if we added it, would only be intended to be used for functions inside of your library/app that don't perform any locking as they expect to be called from code that has already done any necessary coordination.

[19:36:23.0923] <snek>
that sounds reasonable

[19:36:32.0359] <snek>
i like composing with block syntax everywhere

[19:37:41.0348] <rbuckton>
`unsafe` should be as narrow as reasonable, while being as broad as is useful. I like the idea of being able to write `shared struct S unsafe {}` and have the whole body be unsafe, but also having `shared struct S { foo() unsafe { } }` when I want to limit exposure at the edges of a public API.

[19:37:53.0234] <rbuckton>
 * `unsafe` should be as narrow as is reasonable, while being as broad as is useful. I like the idea of being able to write `shared struct S unsafe {}` and have the whole body be unsafe, but also having `shared struct S { foo() unsafe { } }` when I want to limit exposure at the edges of a public API.

[19:40:02.0602] <rbuckton>
for example, I might have a `shared struct ConcurrentDeque<T> { ... }` whose public methods are safe to use and whose contents are private and encapsulated. But I might also want to have a `shared struct RingBuffer<T> unsafe { ... }` because the whole body will contain unsafe code and the struct won't be exposed outside of my API.

[19:42:26.0661] <rbuckton>
We can defer "function coloring" till later. For example, we could add `Reflect.unsafeGet` now, which internally applies `unsafe` and thus can be used outside of an `unsafe {}` block, and if we add "function coloring" we could possibly modify `Reflect.get` to have some way to know. Maybe even add a `function.unsafe` metaproperty that lets you know if you were called from an unsafe context (which better explains a `Reflect.get` that works conditionally based on invocation context)

[19:42:40.0596] <rbuckton>
 * We can defer "function coloring" 'til later. For example, we could add `Reflect.unsafeGet` now, which internally applies `unsafe` and thus can be used outside of an `unsafe {}` block, and if we add "function coloring" we could possibly modify `Reflect.get` to have some way to know. Maybe even add a `function.unsafe` metaproperty that lets you know if you were called from an unsafe context (which better explains a `Reflect.get` that works conditionally based on invocation context)

[19:43:45.0912] <rbuckton>
 * We can defer "function coloring" 'til later. For example, we could add `Reflect.unsafeGet` now, which internally applies `unsafe` and thus can be used outside of an `unsafe {}` block, and have `Reflect.get` always throw on shared struct fields. If we add "function coloring" later we could possibly modify `Reflect.get` to have some way to know. Maybe even add a `function.unsafe` metaproperty that lets you know if you were called from an unsafe context (which better explains a `Reflect.get` that works conditionally based on invocation context)

[19:47:17.0809] <rbuckton>
e.g., evolve in steps:
1. `unsafe {}` and _maybe_ postfix-`unsafe` for block declaration bodies. `Reflect.unsafeX` methods where necessary that can be used from normal code since they're labeled "unsafe".
2. `function.unsafe` metaproperty so you can explicitly check whether you're being called from `unsafe` code. Modify `Reflect.X` functions to conditionally work inside of `unsafe` using the same context.
3. prefix-`unsafe` keywords for functions/methods that essentially check `function.unsafe` for you and whose contents are implicitly `unsafe`.

[19:48:26.0058] <rbuckton>
 * e.g., evolve in steps:

1. `unsafe {}` . `Reflect.unsafeX` methods where necessary that can be used from normal code since they're labeled "unsafe".
2. postfix-`unsafe` keyword for block declaration bodies to improve DX.
3. `function.unsafe` metaproperty so you can explicitly check whether you're being called from `unsafe` code. Modify `Reflect.X` functions to conditionally work inside of `unsafe` using the same context.
4. prefix-`unsafe` keyword for functions/methods that essentially check `function.unsafe` for you and whose contents are implicitly `unsafe`.

[19:52:22.0812] <snek>
prefix should probably not make the body unsafe. rust is in the process of undoing that right now 😄

[19:57:22.0874] <rbuckton>
Why would it not? What would be the point otherwise? 

[19:58:53.0553] <rbuckton>
I definitely don't want to have to write `unsafe function f() unsafe {}`, that's repetitive and redundant and likely to confuse developers. 

[20:00:12.0771] <snek>
it prevents you from scoping unsafe code within the function

[20:03:18.0872] <snek>
i feel like unsafe as a concept is large enough to be its own proposal 😄

[20:04:48.0937] <rbuckton>
If you are limiting the unsafe scope in the function, why would you Cecelia the function unsafe? 

[20:04:59.0867] <rbuckton>
* If you are limiting the unsafe scope in the function, why would you declare the function unsafe? 

[20:05:23.0824] <rbuckton>
(on phone and autocorrect failed me)

[20:06:44.0291] <snek>
perhaps the function itself does not perform locking, and relies on the caller for that

[20:07:15.0158] <rbuckton>
If we decided to add a `function.unsafe` metaproperty, then we could handle the case of limiting scope while still "coloring the function" 

[20:09:21.0770] <snek>
i don't think function color is actually a problem here, it just exists to control how you think about your program. you can always write a safe wrapper around any function regardless of what color it is.

[20:09:58.0606] <rbuckton>
Ooh, better idea `in.unsafe` 🤔

[20:11:36.0624] <snek>
i feel like the reason for unsafe existing and making unsafe a magic property you can control flow on are kind of ad odds with each other

[20:11:42.0384] <rbuckton>
Well, maybe not better.

[20:11:44.0666] <snek>
 * i feel like the reason for unsafe existing and making unsafe a magic property you can control flow on are kind of at odds with each other

[20:13:13.0561] <rbuckton>
I think having `unsafe function f()` only color the function but not mark the body as `unsafe` would be terribly confusing.

[20:14:00.0727] <snek>
i think it makes a lot of sense, unless you require that every statement in an unsafe function is itself unsafe

[20:14:18.0415] <rbuckton>
But if we wanted to have `Reflect.get` only work on shared structs inside of `unsafe`, that is more dependent on a `function.unsafe`-like control flow operation than function coloring.

[20:15:20.0710] <rbuckton>
> <@devsnek:matrix.org> i think it makes a lot of sense, unless you require that every statement in an unsafe function is itself unsafe

That doesn't seem feasible or sensible.

[20:16:05.0124] <snek>
yeah i mean that's sort of my point. the implementation of the function is probably a mix of safe and unsafe, and you're likely interested in calling attention to certain parts of it without allowing more unsafe code to slip in unnoticed.

[20:17:43.0272] <rbuckton>
I absolutely don't want people to have to write dozens of `unsafe {}` blocks in a single function if they don't need to.

[20:17:56.0241] <snek>
and wrt reflect.get... if a struct wanted to participate in some existing code that uses reflect.get somewhere internally, it would have to expose a getter that enforces that access of that property is safe, so that the `reflect.get` is not unsafe. having an `unsafe` somewhere above it does not enforce the constraint that the `reflect.get` was written with reasonable intent.

[20:18:16.0968] <rbuckton>
They can if they want to, obviously, but that shouldn't be a requirement.

[20:19:04.0604] <snek>
> they don't need to.
what does need to mean? if the point of unsafe existing is to call your attention to certain code, i'd say the "need" is making each occurrence as targeted as possible.

[20:19:12.0530] <snek>
 * > they don't need to.

what does need to mean? if the point of unsafe existing is to call your attention to certain code, i'd say the "need" is making each occurrence as targeted as possible.

[20:19:19.0442] <rbuckton>
If we had the ability to mark a shared struct property as `writable: false`, then it could potentially become safe to read outside of an `unsafe {}` block since it can no longer change.

[20:19:52.0928] <snek>
it could also just be readable from [[Get]] in that case

[20:22:59.0167] <rbuckton>
> <@devsnek:matrix.org> > they don't need to.
> 
> what does need to mean? if the point of unsafe existing is to call your attention to certain code, i'd say the "need" is making each occurrence as targeted as possible.

I think I was taking your "only write unsafe statements in `unsafe {}` blocks" to the extreme. There are a lot of JS operations that are "safe" and juggling `unsafe {}` blocks to work around that would be a nightmare. The reality is more that `unsafe {}` should be scoped to the level that you, as a developer, need it to be.

[20:23:49.0774] <rbuckton>
But having `unsafe function f() {}` not making the body unsafe would break with existing JS paradigms like `async` and `function*`.

[20:24:09.0612] <snek>
wdym break

[20:24:28.0049] <rbuckton>
break with, as in differ from in a way that could be confusing.

[20:24:45.0324] <rbuckton>
break away from, deviate

[20:25:59.0238] <rbuckton>
I'd like to argue for the principle of least surprise here. If I say a function is `unsafe`, then I expect it to be unsafe.

[20:26:05.0674] <snek>
oh i see. i don't think i've seen any evidence that similar constructs are confusing in other languages. `unsafe`/`extern`/etc in rust and c++ and c and on and on are good prior art there

[20:26:25.0809] <snek>
i lack hard data one way or another though

[20:26:30.0185] <rbuckton>
If unsafe only colors the function and does not apply to the body, then it differs from `async` or `*` in that regard.

[20:27:35.0285] <snek>
its also not a dangerous confusion. if you expect the body to be unsafe and it isn't, you haven't done anything unsafe accidentally

[20:27:49.0519] <rbuckton>
If we wanted to give a way to just color a function without marking the lexical scope, we could offer up a decorator for that purpose.

[20:29:48.0003] <rbuckton>
But to back up for a bit, If we wanted `Reflect.get` to have different behavior inside or outside of `unsafe`, or for proxies to be able to convey whether their hooks are evaluated in unsafe code, that is not actually something that is solved by function coloring.

