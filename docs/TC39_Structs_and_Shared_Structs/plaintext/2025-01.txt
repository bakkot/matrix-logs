2025-01-15
[07:53:30.0230] <shu>
hi folks, i have no new topics to discuss for the next structs call, but would like someone there to jog my memory (kriskowal and nicolo-ribaudo preferably) on where exactly we left off and agreed on for the module identity thing for per-realm prototypes

[11:08:26.0633] <Mathieu Hofman>
Kris is out this week. I'm a bit tied up but if necessary I can free myself up tomorrow.

[11:43:09.0074] <shu>
we can also postpone until kris is back

[12:09:51.0404] <Mathieu Hofman>
Postponing by a week would work for us

[13:45:18.0187] <shu>
if i don't hear other concerns by EOD pi'll postpone by a week

[13:45:23.0001] <shu>
* if i don't hear other concerns by EOD i'll postpone by a week

[13:56:42.0545] <shu>
ah shoot i actually have a conflict from 1000-1030 PT next week

[13:56:48.0288] <shu>
i'll postpone to 1030-1100


2025-01-16
[19:47:45.0874] <Mathieu Hofman>
I let Mark know, but if you can, please update the calendar invite.


2025-01-22
[17:03:40.0296] <shu>
thoughts on prohibiting computed property names in struct bodies? with structs positioned as "restricted classes that trade expressivity for performance and analyzability", prohibiting computed property names furthers the analyzability goal

[17:19:00.0372] <iain>
I would support it. If I'd had to guess without looking, I'd have assumed they were already prohibited.

[18:23:12.0511] <shu>
they are currently allowed, but not really intentionally

[21:10:49.0989] <rbuckton>
Would this then prohibit using symbol named properties like `Symbol.dispose`? If so, I am not in favor. 

[22:14:32.0219] <shu>
the principle is statically analyzable name

[22:14:43.0818] <shu>
i wonder if there's a way to recover well-known symbol names and retaining analyzability

[22:17:24.0491] <ljharb>
then you also wouldn't be able to have a string property name?

[06:10:03.0124] <Ashley Claymore>
Was going to say: Well known `Symbol` fields are non-writable&non-configurable.
so `[Symbol.iterator]` is statically known.
 expect Symbol itself could be replaced

[07:01:29.0678] <rbuckton>
Allowing `[Symbol.dispose]` but not `[x]` would be inconsistent and a source of confusion for users.

[07:03:57.0133] <rbuckton>
Why is this static analyzability necessary? The shape will be locked down when the definition is evaluated. I'd be fine with implementations having fast paths for statically analyzable definitions, but not with disallowing them entirely. 

[07:06:01.0450] <rbuckton>
Static analysis for `Symbol` isn't necessarily reliable anyways given polyfills for new built in symbols, the fact you can redeclare `Symbol` in your module, and that you could have `const x = Symbol.iterator`.

[07:07:26.0611] <rbuckton>
I also have cases where I've used vm.Context in NodeJS to replace `Symbol` with a mock, which would likely violate static analysis. 

[07:22:48.0994] <shu>
it's not necessary for the engine, but came as a request from tooling folks internally

[07:23:55.0017] <shu>
not sure i follow

[07:28:37.0352] <rbuckton>
I would be opposed to disallowing computed properties for the reasons stated: Disallowing entirely would break important use cases (e.g., `Symbol.dispose`, `Symbol.iterator`), and only allowing a restricted set of "statically analyzable" computed properties would be confusing, fragile, and break user expectations. 

[07:29:14.0618] <shu>
a possibility is to disallow all computed property names for own fields, but allow it for instance fields (methods, getters), and static fields

[07:30:56.0892] <shu>
since:

- you get declarative instance layout with all known field names
- all static use cases today for computed names are about symbol protocols, which are on the prototype
- prototype shapes require analysis to get even without computed property names

