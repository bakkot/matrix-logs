2025-01-15
[07:53:30.0230] <shu>
hi folks, i have no new topics to discuss for the next structs call, but would like someone there to jog my memory (kriskowal and nicolo-ribaudo preferably) on where exactly we left off and agreed on for the module identity thing for per-realm prototypes

[11:08:26.0633] <Mathieu Hofman>
Kris is out this week. I'm a bit tied up but if necessary I can free myself up tomorrow.

[11:43:09.0074] <shu>
we can also postpone until kris is back

[12:09:51.0404] <Mathieu Hofman>
Postponing by a week would work for us

[13:45:18.0187] <shu>
if i don't hear other concerns by EOD pi'll postpone by a week

[13:45:23.0001] <shu>
* if i don't hear other concerns by EOD i'll postpone by a week

[13:56:42.0545] <shu>
ah shoot i actually have a conflict from 1000-1030 PT next week

[13:56:48.0288] <shu>
i'll postpone to 1030-1100


2025-01-16
[19:47:45.0874] <Mathieu Hofman>
I let Mark know, but if you can, please update the calendar invite.


2025-01-22
[17:03:40.0296] <shu>
thoughts on prohibiting computed property names in struct bodies? with structs positioned as "restricted classes that trade expressivity for performance and analyzability", prohibiting computed property names furthers the analyzability goal

[17:19:00.0372] <iain>
I would support it. If I'd had to guess without looking, I'd have assumed they were already prohibited.

[18:23:12.0511] <shu>
they are currently allowed, but not really intentionally

[21:10:49.0989] <rbuckton>
Would this then prohibit using symbol named properties like `Symbol.dispose`? If so, I am not in favor. 

[22:14:32.0219] <shu>
the principle is statically analyzable name

[22:14:43.0818] <shu>
i wonder if there's a way to recover well-known symbol names and retaining analyzability

[22:17:24.0491] <ljharb>
then you also wouldn't be able to have a string property name?

[06:10:03.0124] <Ashley Claymore>
Was going to say: Well known `Symbol` fields are non-writable&non-configurable.
so `[Symbol.iterator]` is statically known.
 expect Symbol itself could be replaced

[07:01:29.0678] <rbuckton>
Allowing `[Symbol.dispose]` but not `[x]` would be inconsistent and a source of confusion for users.

[07:03:57.0133] <rbuckton>
Why is this static analyzability necessary? The shape will be locked down when the definition is evaluated. I'd be fine with implementations having fast paths for statically analyzable definitions, but not with disallowing them entirely. 

[07:06:01.0450] <rbuckton>
Static analysis for `Symbol` isn't necessarily reliable anyways given polyfills for new built in symbols, the fact you can redeclare `Symbol` in your module, and that you could have `const x = Symbol.iterator`.

[07:07:26.0611] <rbuckton>
I also have cases where I've used vm.Context in NodeJS to replace `Symbol` with a mock, which would likely violate static analysis. 

[07:22:48.0994] <shu>
it's not necessary for the engine, but came as a request from tooling folks internally

[07:23:55.0017] <shu>
not sure i follow

[07:28:37.0352] <rbuckton>
I would be opposed to disallowing computed properties for the reasons stated: Disallowing entirely would break important use cases (e.g., `Symbol.dispose`, `Symbol.iterator`), and only allowing a restricted set of "statically analyzable" computed properties would be confusing, fragile, and break user expectations. 

[07:29:14.0618] <shu>
a possibility is to disallow all computed property names for own fields, but allow it for instance fields (methods, getters), and static fields

[07:30:56.0892] <shu>
since:

- you get declarative instance layout with all known field names
- all static use cases today for computed names are about symbol protocols, which are on the prototype
- prototype shapes require analysis to get even without computed property names

[08:43:37.0751] <littledan>
can you elaborate on static analyzability goals? Are we going for soundness or "works in practice"?

[08:52:17.0458] <rbuckton>
Disallowing for own fields but allowing for methods is just another source of confusion for users.

[08:53:15.0168] <rbuckton>
> all static use cases today for computed names are about symbol protocols, which are on the prototype

Not all use cases today are for symbols on the prototype. NodeJS internals are rife with symbols defined on instance objects.

[08:53:42.0594] <rbuckton>
And none of those protocols _require_ those symbols be on the prototype.

[08:57:35.0751] <shu>
and is it important to support those use cases with structs?

[08:58:58.0912] <shu>
"works in practice" for sure, but by construction than by, say, linting

[08:59:12.0197] <rbuckton>
I believe it is, yes. 

[08:59:23.0705] <shu>
can you show me an example?

[09:00:50.0949] <rbuckton>
Shortly, yes. I'm about to step into a meeting.

[09:00:53.0079] <iain>
I seem to recall that we were talking about source location as a mechanism for solving the coordination problem. Has that changed? If computed properties are allowed, then the same source location can define multiple distinct types.

[09:01:16.0445] <shu>
i've been talking about unshared structs

[09:01:40.0765] <shu>
but yeah that's a good point for the shared ones

[09:03:47.0132] <rbuckton>
If they didn't point to the same properties, they wouldn't match, much like how if you had two references to the same source location with different field layouts wouldn't match (say, due to a new version of the file being loaded in a worker)

[09:04:01.0670] <shu>
the use cases all revolve around symbols. i'd like to solve that more directly

[09:05:10.0046] <shu>
being declarative is a good goal; i think there's a world of difference between supporting Symbol.iterator, which is important, and supporting arbitrary computation for field names

