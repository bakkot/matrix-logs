2024-01-18
[09:59:49.0092] <rbuckton>
My apologies, I will be about 2 minutes late to the working session today

[11:01:18.0733] <rbuckton>
shu: At one point you had discussed having one shared struct inherit from another shared struct. If we ignore TLS prototypes and behavior for a moment, is there any specific benefit to modeling an actual inheritance model here, or would just having the inherited struct just maintain the initial field layout of the base struct be sufficient?

[11:01:32.0434] <rbuckton>
 * shu: At one point you had discussed having one shared struct inherit from another shared struct. If we ignore TLS prototypes and behavior for a moment, is there any specific benefit to modeling an actual inheritance model here, or would having the inherited struct just maintain the initial field layout of the base struct be sufficient?

[11:03:04.0001] <shu>
i think the benefit is more like "full composability with rest of the language", mainly

[11:03:24.0790] <shu>
i know the field has kind of soured on inheritance hierarchies vs inline storage of stuff

[11:03:59.0833] <shu>
but for e.g. AST nodes, you probably do want an inheritance hierarchy in the "layout prefix" sense that i was imagining

[11:04:11.0726] <shu>
`AstNodeBase` has `loc` or whatever

[11:04:46.0753] <rbuckton>
I'm more asking if there is any reason that `struct B extends A {}` needs to care about `A` other than its field layout (if you ignore TLS prototypes and constructor initialization logic)

[11:05:12.0670] <rbuckton>
(aside from internal AST reasons)

[11:05:39.0337] <shu>
ooh

[11:05:39.0973] <rbuckton>
It goes to simplifying the syntax I've been considering.

[11:05:50.0320] <shu>
i feel like no?

[11:05:55.0197] <shu>
my intention was literally for layout

[11:06:43.0099] <rbuckton>
In classes, field order is determined by calling `super()`, where each `super` constructor installs its fields and returns the thing to be the used as the `this` in the subclass constructor.

[11:06:53.0437] <rbuckton>
That helps

[11:08:35.0352] <shu>
what i want for struct inheritance semantics:

- one shot initialization. even if we allow field initializers or user-programmable constructors, they get a fully initialized instance with all fields initialized to a sentinel (`undefined`, i guess)
- superclass's fields precede your own fields

[11:08:57.0744] <shu>
the invariant is that a half-constructed, out-of-declared-order instance is not observable if you use structs

[11:14:10.0604] <rbuckton>
That syntax sketch I wrote up a few months back has a lot of corner cases to handle future complexity, like:
- declaring whether a struct has a `null` prototype, or a "shared" prototype, or a TLS prototype.
- declaring whether a struct field is "non-shared" on a shared struct (i.e., a TLS-backed field).
- indicating whether a method is shared or non-shared, for a potential future that might somehow include shared functions.

I'd like to cut a lot of that for simplicity's sake. For example, every `struct` declaration has a non-shared prototype (a TLS prototype for shared structs). You can use `extends null` if you don't need the prototype, and we can just make that work as opposed to how `class extends null` doesn't work today.

[11:14:53.0668] <rbuckton>
So `shared struct A extends B {}` gives `A` a TLS prototype that inherits from `B`'s TLS prototype.

