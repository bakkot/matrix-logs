2024-01-18
[09:59:49.0092] <rbuckton>
My apologies, I will be about 2 minutes late to the working session today

[11:01:18.0733] <rbuckton>
shu: At one point you had discussed having one shared struct inherit from another shared struct. If we ignore TLS prototypes and behavior for a moment, is there any specific benefit to modeling an actual inheritance model here, or would just having the inherited struct just maintain the initial field layout of the base struct be sufficient?

[11:01:32.0434] <rbuckton>
 * shu: At one point you had discussed having one shared struct inherit from another shared struct. If we ignore TLS prototypes and behavior for a moment, is there any specific benefit to modeling an actual inheritance model here, or would having the inherited struct just maintain the initial field layout of the base struct be sufficient?

[11:03:04.0001] <shu>
i think the benefit is more like "full composability with rest of the language", mainly

[11:03:24.0790] <shu>
i know the field has kind of soured on inheritance hierarchies vs inline storage of stuff

[11:03:59.0833] <shu>
but for e.g. AST nodes, you probably do want an inheritance hierarchy in the "layout prefix" sense that i was imagining

[11:04:11.0726] <shu>
`AstNodeBase` has `loc` or whatever

[11:04:46.0753] <rbuckton>
I'm more asking if there is any reason that `struct B extends A {}` needs to care about `A` other than its field layout (if you ignore TLS prototypes and constructor initialization logic)

[11:05:12.0670] <rbuckton>
(aside from internal AST reasons)

[11:05:39.0337] <shu>
ooh

[11:05:39.0973] <rbuckton>
It goes to simplifying the syntax I've been considering.

[11:05:50.0320] <shu>
i feel like no?

[11:05:55.0197] <shu>
my intention was literally for layout

[11:06:43.0099] <rbuckton>
In classes, field order is determined by calling `super()`, where each `super` constructor installs its fields and returns the thing to be the used as the `this` in the subclass constructor.

[11:06:53.0437] <rbuckton>
That helps

[11:08:35.0352] <shu>
what i want for struct inheritance semantics:

- one shot initialization. even if we allow field initializers or user-programmable constructors, they get a fully initialized instance with all fields initialized to a sentinel (`undefined`, i guess)
- superclass's fields precede your own fields

[11:08:57.0744] <shu>
the invariant is that a half-constructed, out-of-declared-order instance is not observable if you use structs

[11:14:10.0604] <rbuckton>
That syntax sketch I wrote up a few months back has a lot of corner cases to handle future complexity, like:
- declaring whether a struct has a `null` prototype, or a "shared" prototype, or a TLS prototype.
- declaring whether a struct field is "non-shared" on a shared struct (i.e., a TLS-backed field).
- indicating whether a method is shared or non-shared, for a potential future that might somehow include shared functions.

I'd like to cut a lot of that for simplicity's sake. For example, every `struct` declaration has a non-shared prototype (a TLS prototype for shared structs). You can use `extends null` if you don't need the prototype, and we can just make that work as opposed to how `class extends null` doesn't work today.

[11:14:53.0668] <rbuckton>
So `shared struct A extends B {}` gives `A` a TLS prototype that inherits from `B`'s TLS prototype.

[11:15:37.0614] <rbuckton>
If you do `shared struct A extends B {]` and `B` isn't shared, it doesn't matter. You just get `A` with the same layout as `B`, except it's shared, and the prototypes are non-shared anyways.

[11:15:43.0626] <rbuckton>
 * If you do `shared struct A extends B {}` and `B` isn't shared, it doesn't matter. You just get `A` with the same layout as `B`, except it's shared, and the prototypes are non-shared anyways.

[11:17:48.0969] <rbuckton>
In a `struct` constructor, `super()` could be designed such that it doesn't support return override tricks, since the layout is already wired up. 

[11:19:02.0492] <rbuckton>
And we could just assume methods are non-shared by default, and if shared functions ever becomes a thing you have to opt-in on a method-by-method basis. That seems like a good idea anyways, since you'd want to explicitly indicate that you'd thought about thread safety for a given "shared" method anyways.

[11:19:11.0764] <rbuckton>
All of that makes the syntax fairly simple.

[11:25:25.0873] <rbuckton>
Basically: 

```
// non-shared struct
struct S1 {
  foo; // fixed-layout, non-shared field

  constructor() { } // realm-local constructor

  bar() { } // attached to realm-local prototype
  get baz() { } // attached to realm-local prototype
  set baz(value) { } // attached to realm-local prototype
}

// shared struct
shared struct S2 {
  foo; // fixed-layout, shared field

  constructor() { } // realm-local constructor

  bar() { } // attached to realm-local prototype
  get baz() { } // attached to realm-local prototype
  set baz(value) { } // attached to realm-local prototype
}

// null prototypes
struct S3 extends null {
  foo; // fixed-layout, non-shared field

  constructor() { } // realm-local constructor

  // cannot have methods/getters/setters
}

shared struct S4 extends null {
  foo; // fixed-layout, shared field

  constructor() { } // realm-local constructor

  // cannot have methods/getters/setters
}

// subclassing
struct S5 extends S1 {} // ok
struct S6 extends S2 {} // ok? S6 would be non-shared, even though S2 is declared as shared
shared struct S7 extends S1 {} // ok? S7 would be shared, even though S1 is declared as non-shared
shared struct S8 extends S2 {} // ok
```

[11:27:20.0289] <rbuckton>
Ideally, we could find some way of supporting private names and `accessor`, as I'd also like to support decorators long term. The private names bit is tricky for shared structs, though, as you wouldn't be able to guarantee "hard privacy" if it were supported, but private names are necessary to support `accessor` for decorators.

