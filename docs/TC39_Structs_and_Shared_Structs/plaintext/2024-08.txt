2024-08-28
[10:08:41.0996] <Mathieu Hofman>
shu: could you update the TC39 calendar invite for the meeting? Looks like it never got updated when we switched to biweekly

[10:12:28.0979] <shu>
Mathieu Hofman: ah i only switched my personal one? my bad, let me fix it now


2024-08-29
[11:55:28.0663] <kriskowal>
I seem to have bludgeoned the Join button enough times for Matrix to acknowledge my presence.

[11:57:06.0457] <nicolo-ribaudo>
Welcome

[11:58:29.0501] <rbuckton>
kriskowal: I tried to DM you the link I mentioned, but there are two matrix identities for you in the delegates chat and I may have sent them to the wrong one. Here's what I sent, in any case:

For reference, this Gist contains a brief analysis of an earlier proposed handshaking mechanism: https://gist.github.com/rbuckton/08d020fc80da308ad3a1991384d4ff62 
Alternatively, this other gist details possible mechanisms to grant/deny correlation as well as to support bundlers when correlating by source location: https://gist.github.com/rbuckton/b00ca9660fb888486da07b22e38dd1e9

[11:59:53.0523] <kriskowal>
> <@rbuckton:matrix.org> kriskowal: I tried to DM you the link I mentioned, but there are two matrix identities for you in the delegates chat and I may have sent them to the wrong one. Here's what I sent, in any case:
> 
> For reference, this Gist contains a brief analysis of an earlier proposed handshaking mechanism: https://gist.github.com/rbuckton/08d020fc80da308ad3a1991384d4ff62 
> Alternatively, this other gist details possible mechanisms to grant/deny correlation as well as to support bundlers when correlating by source location: https://gist.github.com/rbuckton/b00ca9660fb888486da07b22e38dd1e9

Yeah, Matrix isn’t good at chat. One cannot simply start up a new Matrix instance with friends and migrate their identity, much less convince Matrix the old one is gone, especially when matrix.org has forgotten its side of the credentials for it.

[12:04:53.0579] <kriskowal>
By a glance, it looks like this design direction hasn’t been considered or was dismissed out-of-hand:
```
struct Foo {}
addEventListener('message', event => {
  const foo = new Foo(event.data.foo);
});
```
Wherein, `Foo` is an opaque struct definition closing over the vm-specific vagaries of padding, alignment, embedding, dereferencing, &c, `event.data.foo` is an opaque handle on shared memory without behavior, and `new Foo(event.data.foo)` unites the data and behavior.

[12:05:50.0783] <kriskowal>
And, of course `Foo.prototype` captures the behavior side.

[12:09:11.0957] <shu>
what would this union do

[12:09:33.0669] <shu>
one of the primary goal here is to actually share the objects, not just share the payload

[12:10:10.0432] <shu>
this is because application state, by volume, is a lot of pointers. recreating your object graph from payloads per thread means you are not scaling with the number of threads

[12:10:22.0050] <shu>
so any solution that requires creating wrapper objects per-thread is a nonstarter

[12:10:25.0905] <kriskowal>
i’m assuming you mean sharing the backing memory, since the objects are necessarily in different realms

[12:10:50.0009] <shu>
yes, payload and backing memory are interchangeable for what i said

[12:11:06.0354] <shu>
a related question is "why not create object overlays on top of SABs"

[12:11:11.0362] <nicolo-ribaudo>
> <@kriskowal:aelf.land> i’m assuming you mean sharing the backing memory, since the objects are necessarily in different realms

If objects don't capture any realm-specific state, you can actually share the objects 

[12:11:55.0117] <kriskowal>
oh, right, we’re talking about a new primitive.

[12:12:32.0722] <nicolo-ribaudo>
This would be different from SharedArrayBuffer, where there is a per-thread wrapper pointing to the same memory

[12:13:14.0543] <shu>
> <@kriskowal:aelf.land> oh, right, we’re talking about a new primitive.

well, they're objects

[12:13:29.0562] <shu>
but yes, internally you can think of them as new primitives

[12:13:34.0464] <shu>
they're objects with special behavior

[12:13:45.0831] <kriskowal>
alright, so the crux of this is that the _value_ capturing the union of the shared memory and behavior must also be a primitive.

[12:14:11.0842] <shu>
sorry, having trouble parsing that sentence

[12:14:21.0525] <kriskowal>
i now better understand how we arrive at the prototype walk algorithm

[12:15:00.0147] <shu>
there's another alternative that was dismissed, which is actually thread-safe functions

[12:15:04.0960] <kriskowal>
there’s no per-worker object that points to the local prototype and shared data

[12:15:08.0604] <shu>
that is just too much a can of worms, and nobody wants a new callable type

[12:15:16.0204] <shu>
> <@kriskowal:aelf.land> there’s no per-worker object that points to the local prototype and shared data

yeah

[12:15:38.0368] <kriskowal>
this seems cursed

[12:15:54.0723] <shu>
heh, in what way?

[12:16:39.0527] <kriskowal>
i can see why this design direction forces today’s debate about where to put the global state

[12:16:51.0946] <shu>
ah, yeah

[12:17:46.0350] <iain>
For the record, I think it would be good to explore the thread-safe functions option at least a little bit. 

[12:18:02.0220] <shu>
i agree, as long as in parallel

[12:18:24.0084] <shu>
but identity discontinuity makes it _really_ difficult

[12:18:24.0604] <kriskowal>
the Moddable folks would be good to involve in a conversation about thread-safe functions.

[12:19:31.0704] <kriskowal>
XS is a bit unique in its design constraints, but does have thread-safe functions and can sense when a subgraph can be safely captured in ROM.

[12:19:45.0410] <iain>
There are many parts of this proposal that make big changes; I'm not convinced that new callables would be worse than some of the other proposed changes

[12:19:53.0941] <iain>
What do you mean by identity discontinuity?

[12:20:10.0026] <shu>
> <@iain:mozilla.org> There are many parts of this proposal that make big changes; I'm not convinced that new callables would be worse than some of the other proposed changes

i am

[12:20:33.0315] <shu>
i'm gonna need something more specific than "this is already large, therefore it has room for other large changes"

[12:20:40.0140] <kriskowal>
Identity discontinuity is `const source = '{}', eval(source) !== eval(source)`.

[12:21:16.0799] <kriskowal>
Which is not an interesting example, but `const source = 'class Foo { #p }'` is more interesting.

[12:21:45.0190] <shu>
> <@iain:mozilla.org> What do you mean by identity discontinuity?

specifically, i'm talking about how each global has its own set of Math, Object, Function, etc, that have distinct identity

[12:22:19.0987] <shu>
JS functions are closures very deep down, not just the JS user code closed-over stuff

[12:22:32.0249] <shu>
so we'd have to answer the question of what does that mean for thread-safe functions

[12:22:35.0632] <shu>
do they become more dynamically scoped?

[12:24:07.0288] <iain>
Without having thought it through much, I would want to say that they can't capture anything other than global variables, and global variables are always looked up in the local global.

[12:24:57.0200] <shu>
okay, so dynamically scoped to the caller global

[12:25:29.0676] <iain>
Yes. If there were a clean way to distinguish between `shared function foo() { return Math; }` and `var x; shared function foo() { return x; }`, I would also like to prohibit the latter.

[12:26:59.0634] <shu>
is it basically this thing i wrote up a while ago

[12:27:00.0158] <shu>
https://github.com/tc39/proposal-structs/blob/main/CODE-SHARING-IDEAS.md

[12:27:36.0042] <iain>
So that modulo monkey-patching, all the "dynamically scoped" stuff you're closing over is basically the same between realms

[12:27:54.0960] <iain>
That looks like a better thought out version of my vague notion, yes

[12:29:07.0184] <shu>
my conclusion is that i think it's a lot of work and a lot of complexity for the language for not as much gain as you might think

[12:29:29.0440] <shu>
like, people are gonna want to close over state in a thread-local way during computation

[12:29:32.0070] <shu>
and i think that's fine

[12:30:23.0964] <kriskowal>
It it imagined that every get/set of an individual property on a shared struct is implicitly an atomic on that individual field?

[12:30:28.0247] <shu>
and i believe more and more that we actually get more mileage out of letting people use the functions we have today on shared data, but make that ergonomic

[12:30:56.0669] <iain>
My hope is that doing something like this would let us significantly simplify the prototype problem

[12:31:18.0874] <shu>
> <@kriskowal:aelf.land> It it imagined that every get/set of an individual property on a shared struct is implicitly an atomic on that individual field?

yes, Unordered by default. Atomics.load/store and friends are extended to be able to operate on struct fields should you want sequentially consistent atomic access

[12:31:48.0421] <shu>
the guarantee is the same as bare reads/writes on SABs via TypedArrays: if you have races, you can observe any of the written values, but they shall never tear

[12:32:02.0773] <shu>
i.e. you can't observe half of one write composed with half of another write

[12:33:01.0239] <kriskowal>
I gather from the requirements, that it’s imagined that incrementally replacing a `class` with a `shared struct` is a delicate-but-possible performance improving refactor that doesn’t require changes from the consuming code

[12:34:04.0200] <kriskowal>
I’m much more familiar with these shenanigans in other languages. I see that CAS is `Atomics.compareExchange`. Alright.

[12:34:05.0793] <shu>
that's not a hard requirement for me, but is certainly a goal. i believe that's harder requirement for Ron perhaps

[12:34:41.0580] <shu>
i said in the beginning of the call, before you joined, that i can live in a world where we don't solve the correlation problem because on net there's still enough value here for the power apps

[12:35:04.0391] <shu>
but if we can solve the correlation problem, we unlock things like incremental adoption that helps a larger amount of apps

[12:35:09.0352] <kriskowal>
So, you’d personally be satisfied with the data-only subset?

[12:35:22.0683] <shu>
i wouldn't equate "satisfied" with "can live with"

[12:35:27.0677] <kriskowal>
Or rather, on behalf of the economic interests your represent.

[12:35:43.0008] <shu>
by "can live with" as, if it was the only thing holding the rest of the proposal up, i'd drop it

[12:35:59.0140] <shu>
and iterate on it after the initial proposal

[12:37:28.0929] <shu>
> <@kriskowal:aelf.land> Or rather, on behalf of the economic interests your represent.

speaking only for myself, yes. i still think we'd be doing a disservice for many of the reasons we've gone into with Mark in the past. the most salient of which, i think, is that without ergonomically correlated methods, we're inviting people to use free functions, and it becomes _harder_ to encapsulate

[12:37:46.0898] <shu>
which ron and i think will result in higher likelihood of thread unsafe code being written

[12:38:20.0446] <shu>
> <@kriskowal:aelf.land> Or rather, on behalf of the economic interests your represent.

 * speaking only for myself, yes. i still think we'd be doing a disservice to the language for many of the reasons we've gone into with Mark in the past. the most salient of which, i think, is that without ergonomically correlated methods, we're inviting people to use free functions, and it becomes _harder_ to encapsulate

