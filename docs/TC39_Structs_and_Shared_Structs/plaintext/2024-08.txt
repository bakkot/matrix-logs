2024-08-28
[10:08:41.0996] <Mathieu Hofman>
shu: could you update the TC39 calendar invite for the meeting? Looks like it never got updated when we switched to biweekly

[10:12:28.0979] <shu>
Mathieu Hofman: ah i only switched my personal one? my bad, let me fix it now


2024-08-29
[11:55:28.0663] <kriskowal>
I seem to have bludgeoned the Join button enough times for Matrix to acknowledge my presence.

[11:57:06.0457] <nicolo-ribaudo>
Welcome

[11:58:29.0501] <rbuckton>
kriskowal: I tried to DM you the link I mentioned, but there are two matrix identities for you in the delegates chat and I may have sent them to the wrong one. Here's what I sent, in any case:

For reference, this Gist contains a brief analysis of an earlier proposed handshaking mechanism: https://gist.github.com/rbuckton/08d020fc80da308ad3a1991384d4ff62 
Alternatively, this other gist details possible mechanisms to grant/deny correlation as well as to support bundlers when correlating by source location: https://gist.github.com/rbuckton/b00ca9660fb888486da07b22e38dd1e9

[11:59:53.0523] <kriskowal>
> <@rbuckton:matrix.org> kriskowal: I tried to DM you the link I mentioned, but there are two matrix identities for you in the delegates chat and I may have sent them to the wrong one. Here's what I sent, in any case:
> 
> For reference, this Gist contains a brief analysis of an earlier proposed handshaking mechanism: https://gist.github.com/rbuckton/08d020fc80da308ad3a1991384d4ff62 
> Alternatively, this other gist details possible mechanisms to grant/deny correlation as well as to support bundlers when correlating by source location: https://gist.github.com/rbuckton/b00ca9660fb888486da07b22e38dd1e9

Yeah, Matrix isn’t good at chat. One cannot simply start up a new Matrix instance with friends and migrate their identity, much less convince Matrix the old one is gone, especially when matrix.org has forgotten its side of the credentials for it.

[12:04:53.0579] <kriskowal>
By a glance, it looks like this design direction hasn’t been considered or was dismissed out-of-hand:
```
struct Foo {}
addEventListener('message', event => {
  const foo = new Foo(event.data.foo);
});
```
Wherein, `Foo` is an opaque struct definition closing over the vm-specific vagaries of padding, alignment, embedding, dereferencing, &c, `event.data.foo` is an opaque handle on shared memory without behavior, and `new Foo(event.data.foo)` unites the data and behavior.

[12:05:50.0783] <kriskowal>
And, of course `Foo.prototype` captures the behavior side.

[12:09:11.0957] <shu>
what would this union do

[12:09:33.0669] <shu>
one of the primary goal here is to actually share the objects, not just share the payload

[12:10:10.0432] <shu>
this is because application state, by volume, is a lot of pointers. recreating your object graph from payloads per thread means you are not scaling with the number of threads

[12:10:22.0050] <shu>
so any solution that requires creating wrapper objects per-thread is a nonstarter

[12:10:25.0905] <kriskowal>
i’m assuming you mean sharing the backing memory, since the objects are necessarily in different realms

[12:10:50.0009] <shu>
yes, payload and backing memory are interchangeable for what i said

[12:11:06.0354] <shu>
a related question is "why not create object overlays on top of SABs"

[12:11:11.0362] <nicolo-ribaudo>
> <@kriskowal:aelf.land> i’m assuming you mean sharing the backing memory, since the objects are necessarily in different realms

If objects don't capture any realm-specific state, you can actually share the objects 

[12:11:55.0117] <kriskowal>
oh, right, we’re talking about a new primitive.

[12:12:32.0722] <nicolo-ribaudo>
This would be different from SharedArrayBuffer, where there is a per-thread wrapper pointing to the same memory

[12:13:14.0543] <shu>
> <@kriskowal:aelf.land> oh, right, we’re talking about a new primitive.

well, they're objects

[12:13:29.0562] <shu>
but yes, internally you can think of them as new primitives

[12:13:34.0464] <shu>
they're objects with special behavior

[12:13:45.0831] <kriskowal>
alright, so the crux of this is that the _value_ capturing the union of the shared memory and behavior must also be a primitive.

[12:14:11.0842] <shu>
sorry, having trouble parsing that sentence

[12:14:21.0525] <kriskowal>
i now better understand how we arrive at the prototype walk algorithm

[12:15:00.0147] <shu>
there's another alternative that was dismissed, which is actually thread-safe functions

[12:15:04.0960] <kriskowal>
there’s no per-worker object that points to the local prototype and shared data

