2024-09-01
[15:59:44.0179] <shu>
> <@littledan:matrix.org> Didn't V8 also initially consider banning shared to local edges? Do we know more about what led V8 to change their minds?

there are two things you get out of banning *all* shared->local edges:

1. language-level correctness/safety
2. independent GCs of separate threads

[16:02:30.0693] <shu>
as we experimented more, we realized that 2) wasn't possible. as part of the shared WasmGC proposal, it's very clear from the partner feedback that we can't get away with banning *all* shared->local edges. Flutter, among a bunch of other Google partners, have been clear that they need either thread-bound (i.e. a shared struct can hold a reference to some unshared thing, but it is an error to access that reference from another thread), or thread-local data

[16:03:08.0524] <shu>
implementing support for thread-bound or thread-local data in almost all cases, boil down to the same work required in the GC as implementing support for shared things as keys in WeakMaps

[16:03:53.0571] <shu>
the WeakMap itself isn't shared and is local to a particular thread, so you still have the correctness property (1) above. but it asks extra complexity of the GC because you now have a local things whose liveness depends on a shared thing

[16:04:25.0721] <shu>
the bulk of this discussion has been happening on the Wasm side

[16:07:47.0267] <shu>
the high-level recap for folks here is that the difficulty in the GC is in collecting cycles that span multiple threads. if you have a reference cycle T1 -> T2 -> T1, nobody's GC is set up to detect and collect that without significant work.

the main counterproposal is to say, don't support shared structs as WeakMap keys. instead let the toolchains and compilers figure it out. my counterargument to that counterproposal is, that means toolchains will use strong Maps, which means in practice applications will leak *everything*. that seems strictly worse to me than supporting shared structs as WeakMap keys, but leak the cycles in the meantime until the GC work can be done

[16:08:22.0731] <shu>
there is also another counteproposal which is to push manual memory management to the user: some kind of `dispose()` or `drop()` or whatever to manually break cycles

[16:08:54.0933] <shu>
 * the high-level recap for folks here is that the difficulty in the GC is in collecting cycles that span multiple threads. if you have a reference cycle T1 -> T2 -> T1, nobody's GC is set up to detect and collect that without significant work.

the main counterproposal is to say, don't support shared structs as WeakMap keys. instead let the toolchains and compilers figure it out. my counterargument to that counterproposal is, that means toolchains will use strong Maps, which means in practice applications will leak _everything_. that seems strictly worse to me than supporting shared structs as WeakMap keys, but leak the cycles in the meantime until the GC work can be done. acyclic entries can be collected without additional work

[16:09:58.0166] <shu>
i gave a presentation of this like a year ago in TC39

[16:10:02.0262] <shu>
but i don't think people were paying attention

