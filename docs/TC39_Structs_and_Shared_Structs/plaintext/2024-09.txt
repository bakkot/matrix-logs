2024-09-01
[15:59:44.0179] <shu>
> <@littledan:matrix.org> Didn't V8 also initially consider banning shared to local edges? Do we know more about what led V8 to change their minds?

there are two things you get out of banning *all* shared->local edges:

1. language-level correctness/safety
2. independent GCs of separate threads

[16:02:30.0693] <shu>
as we experimented more, we realized that 2) wasn't possible. as part of the shared WasmGC proposal, it's very clear from the partner feedback that we can't get away with banning *all* shared->local edges. Flutter, among a bunch of other Google partners, have been clear that they need either thread-bound (i.e. a shared struct can hold a reference to some unshared thing, but it is an error to access that reference from another thread), or thread-local data

[16:03:08.0524] <shu>
implementing support for thread-bound or thread-local data in almost all cases, boil down to the same work required in the GC as implementing support for shared things as keys in WeakMaps

[16:03:53.0571] <shu>
the WeakMap itself isn't shared and is local to a particular thread, so you still have the correctness property (1) above. but it asks extra complexity of the GC because you now have a local things whose liveness depends on a shared thing

[16:04:25.0721] <shu>
the bulk of this discussion has been happening on the Wasm side

[16:07:47.0267] <shu>
the high-level recap for folks here is that the difficulty in the GC is in collecting cycles that span multiple threads. if you have a reference cycle T1 -> T2 -> T1, nobody's GC is set up to detect and collect that without significant work.

the main counterproposal is to say, don't support shared structs as WeakMap keys. instead let the toolchains and compilers figure it out. my counterargument to that counterproposal is, that means toolchains will use strong Maps, which means in practice applications will leak *everything*. that seems strictly worse to me than supporting shared structs as WeakMap keys, but leak the cycles in the meantime until the GC work can be done

[16:08:22.0731] <shu>
there is also another counteproposal which is to push manual memory management to the user: some kind of `dispose()` or `drop()` or whatever to manually break cycles

[16:08:54.0933] <shu>
 * the high-level recap for folks here is that the difficulty in the GC is in collecting cycles that span multiple threads. if you have a reference cycle T1 -> T2 -> T1, nobody's GC is set up to detect and collect that without significant work.

the main counterproposal is to say, don't support shared structs as WeakMap keys. instead let the toolchains and compilers figure it out. my counterargument to that counterproposal is, that means toolchains will use strong Maps, which means in practice applications will leak _everything_. that seems strictly worse to me than supporting shared structs as WeakMap keys, but leak the cycles in the meantime until the GC work can be done. acyclic entries can be collected without additional work

[16:09:58.0166] <shu>
i gave a presentation of this like a year ago in TC39

[16:10:02.0262] <shu>
but i don't think people were paying attention

[16:11:15.0788] <shu>
the highest order bit here i think is, from the shared WasmGC side, WeakMap support is a hard requirement from our partners

[16:12:17.0828] <shu>
debates about language feature compositionality and implementation difficulty are both downstream from that

[16:13:03.0424] <shu>
that is, arguments against WeakMap support without an alternative that the partners can live with won't be compelling

[16:15:08.0232] <shu>
> <@iain:mozilla.org> I am not convinced that it makes incremental adoption so much harder that it outweighs the benefit of being able to ship something sooner.

it's not even incremental adoption, it's initial adoption

[16:15:47.0349] <shu>
perhaps incremental in the JS space, but "initial" when taking both JS+WasmGC into account given what i said above

[16:18:01.0681] <shu>
i think that's why we were talking past each other about the shipping timeline

[16:18:42.0931] <shu>
if this is the thing that delays shipping, then... yeah, it's gonna have to, because the folks the V8 team have been talking to who're most interested in the feature need it even for the MVP

[16:27:04.0898] <shu>
i think the takeaway here is "please wait for more implementation experience from V8", because it's certainly hard for us too but we have some ideas of threading the needle


2024-09-02
[03:39:11.0592] <nicolo-ribaudo>
Hey I have a question

[03:39:27.0312] <nicolo-ribaudo>
Can a shared struct store a SharedArrayBuffer in one of its fields?

[03:40:03.0085] <nicolo-ribaudo>
I was originally assuming yes, because a SharedArrayBuffer is shareable, however I'm now having doubts because the value of the field would actually be the object wrapper around the shared buffer

[06:43:29.0361] <rbuckton>
Unfortunately, no, due to how a SAB is a regular JS object. The proposal adds a SharedArray, but it's not quite the same. 

[07:13:25.0960] <shu>
> <@nicolo-ribaudo:matrix.org> I was originally assuming yes, because a SharedArrayBuffer is shareable, however I'm now having doubts because the value of the field would actually be the object wrapper around the shared buffer

no, not unless we introduce a SharedArrayBuffer2ThatsActuallySharedHaha or something

[07:13:37.0356] <shu>
which, i mean, we could

[07:14:40.0893] <shu>
like the easiest intermediate solution is probably a `SAB.token` that returns some opaque, shareable thing that can be passed back into a SAB constructor. this is not great because it encourages multiple wrappers, but that's already how SABs are

[07:16:47.0158] <nicolo-ribaudo>
If typed array constructors accept that opaque thing as a parameter, then probably we are good

[07:17:13.0694] <nicolo-ribaudo>
Since most uses of a SharedArrayBuffer is to just pass it to a TypedArray constructor

[09:06:33.0044] <littledan (PTO until September 16)>
shu: Can you give us any more information about the partner use cases?

[13:18:55.0035] <shu>
> <@littledan:matrix.org> shu: Can you give us any more information about the partner use cases?

flutter's is the easiest to explain, i think. they will be compiling Dart to shared WasmGC. they associate DOM nodes with Dart objects that represent app state, including event listener callbacks. Dart objects themselves will be shareable across threads, but the event listener will only be accessible on the main thread (what we're calling thread-bound data). event listener callbacks close over the DOM node (in the main thread heap), the DOM node references the Dart object (in the shared heap), forming a cross-heap cycle

[13:19:31.0385] <shu>
the simplest implementation technique for thread-bound data is a per-thread ephemeron map internally keyed by shared objects

[13:19:45.0850] <shu>
so the GC work needed to support that use case boils down to the same work as supporting shared objects as weakmap keys (if you want to collect cycles)

[13:20:26.0110] <shu>
does that help?

[13:21:37.0606] <shu>
> <@nicolo-ribaudo:matrix.org> If typed array constructors accept that opaque thing as a parameter, then probably we are good

yeah, that's what i'm thinking

[13:21:52.0978] <shu>
i'm not proposing it in this proposal though, since it's large enough. easy to tack on as a separate proposal

[13:26:57.0688] <shu>
> <@littledan:matrix.org> shu: Can you give us any more information about the partner use cases?

my suspicion is the event listener pattern will be responsible for the lion's share of actual use cases for cross-heap cycles. the interesting property there is that those really **only** concern cycles between the main thread (since the DOM only exists there) and the shared heap. V8's current prototyping plans (as an FYI, not as a promise) is to see if it's sufficient for memory use if we can only collect main thread cycles like that, not arbitrary cycles. the idea is that the main thread is already very special on the web, so, if we trace through the shared heap at the same time as a main thread major GC, that might be good enough. and indeed, for a full multithreaded GC we'd need actual workload data to determine how to tune / architect anyway

[13:29:18.0109] <shu>
and to bring it full circle, that's where we are in the "please wait for V8 impl experience" takeaway i said above


2024-09-06
[13:44:26.0744] <kriskowal>
I’ve made a rig to improve my understanding of the `primitive.prototypeMethod()` behavior empirically. My assumption proved false and that makes me more optimistic that a lexically scoped shared struct prototype registry could possibly maintain evaluator isolation https://gist.github.com/kriskowal/cd07cfcd93d79c1224c7036ca1e6c776

[13:47:42.0320] <kriskowal>
That is, there could be a hook on a `Module(source, hooks)` constructor that would provide the prototype for a struct, like `prototypeOf(source, keysOfSomeKind)`.

[13:47:50.0131] <kriskowal>
 * That is, there could be a hook on a `Module(source, hooks)` constructor that would provide the prototype for a struct, like `prototypeOf(source, keyOfSomeKind)`.

[13:48:09.0696] <kriskowal>
I believe nicolo-ribaudo was driving at that, and now I understand that it’s viable.

[14:01:06.0961] <nicolo-ribaudo>
I think that being able to completely virtualize that prototype attachment (i.e. have a hook for it) is neither needed nor desiderabile, but I'm happy to discuss it further :)

[14:01:51.0669] <nicolo-ribaudo>
By "not needed" I mean "not needed to maintain isolation"

