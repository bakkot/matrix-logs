2023-04-24
[16:58:49.0231] <shu>
finally catching up on old code sharing threads


2023-04-25
[17:03:07.0685] <shu>
rbuckton: i applaud the scope of "shared modules" but i feel that is tantamount to designing a new language, which is not incremental and significantly increases risk of adoption or shipping anything.

put another way, IMO the only realistic way to move the needle for multithreading for JS is to have an opt-in carve out for shared memory. shared structs _is_ that opt-in. to have "shared modules" seems to require the capability to write code that is actual parallel and threadsafe _in general_, including a threadsafe stdlib. were i to do a greenfield project i'd design a stdlib with that in mind but i feel like that would be too much to bite off at the moment?

[17:04:07.0407] <shu>
more i think about it, i think the non-threadsafe stdlib thing is the actual showstopper for me


2023-04-26
[05:00:10.0709] <rbuckton>
> <@shuyuguo:matrix.org> rbuckton: i applaud the scope of "shared modules" but i feel that is tantamount to designing a new language, which is not incremental and significantly increases risk of adoption or shipping anything.
> 
> put another way, IMO the only realistic way to move the needle for multithreading for JS is to have an opt-in carve out for shared memory. shared structs _is_ that opt-in. to have "shared modules" seems to require the capability to write code that is actual parallel and threadsafe _in general_, including a threadsafe stdlib. were i to do a greenfield project i'd design a stdlib with that in mind but i feel like that would be too much to bite off at the moment?

I'm coming at this from two different directions, with two different outcomes:

1. Design something transformative for the language, adding cohesive and comprehensive new capabilities.
2. Design something tacked on to the language, adding a minimal set of capabilities necessary to solve a specific problem.

Option 1 is complex, takes longer, and requires a fair amount of "big design upfront", all to support capabilities we may or may not need. However, the end goal is to have something cohesive that is future-leaning with few "warts". That's what "shared modules" is, or is intended to be.

Option 2 is far simpler (though not trivial), shorter term, and focused. While this approach allows for incremental change, we may in the future find that related capabilities are harder to implement in the future because of design decisions we make now, potentially leaving more "warts" in the design over time.

I'm not opposed to either direction, but its worth considering the former even if only to inform the latter.

[05:01:29.0557] <rbuckton>
> <@shuyuguo:matrix.org> more i think about it, i think the non-threadsafe stdlib thing is the actual showstopper for me

The "shared modules" approach would have required a threadsafe stdlib subset (i.e., make operations threadsafe if possible, and throw when not).

[05:02:42.0059] <rbuckton>
I find the "only share data, but register per-thread behavior" approach acceptable, so long as we have a reasonable way to register per-thread behavior.

[05:04:58.0534] <rbuckton>
That's the approach I took with https://esfx.js.org/esfx/api/struct-type.html?tabs=ts, though it's not so much "registration" and is more of a "wrap an ArrayBuffer with a DataView"-like approach.

[07:30:50.0550] <shu>
i'm saying something stronger for (1). my intuition is that "transformative" for JS actually means "not adoptable and unrealistic"

