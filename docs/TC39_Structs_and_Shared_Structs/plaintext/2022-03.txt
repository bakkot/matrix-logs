2022-03-10
[15:50:44.0290] <shu>
interesting limitation i just ran into during implementation of the shared struct prototype: on shared structs, `Atomics` operations that need to inspect the value for its operation cannot work for values that don't have identity

[15:51:11.0025] <shu>
for example, suppose there's a shared struct `s` with a field `p` that has the value `42`

[15:51:52.0033] <shu>
`Atomics.load(s, 'p')`, `Atomics.store(s, 'p', whatever)`, `Atomics.exchange(s, 'p', whatever)` all work fine since they just treat the field as bits, there's no inspection of the contents

[15:52:21.0246] <shu>
`Atomics.compareExchange(s, 'p', 42, whatever)` or `Atomics.add(s, 'p')`, by contrast, can't be made to work on all implementations

[15:54:24.0752] <shu>
if an implementation chooses to box its values like V8, then '42' is not the integer 42, but a heap allocation. the implementation complexity for making those Atomics operations work is quite high, will be slow, and also defeats the purpose (lightweight synchronization). for heavier weight synchronization, use plain reads/writes and operations then synchronize separately on a mutex

[15:55:46.0718] <shu>
if an implementation NaN-boxes, like JSC and SpiderMonkey, maybe treating double bit patterns as arbitrary atomic64s might work for a subset of operations like compareExchange, but can't be made to work for arithmetic operations

[15:55:54.0224] <shu>
since there are no hardware instructions for atomic floating point math

[15:57:55.0345] <shu>
OTOH if we extend structs with field types, then Atomics could work on certain field types (like the existing TA types)


2022-03-11
[16:03:20.0604] <shu>
so the upshot here is, i think: without field types, the kind of lock-free programming with shared structs will be pretty limited

[16:03:35.0146] <shu>
and that's probably fine, because you shouldn't be doing lock-free programming most of the time?

[19:18:05.0293] <rbuckton>
One of the uses for `compareExchange` is to implement lock-free updates (i.e., atomically compare and update, returning a value so you can see if you succeeded). Requiring locks to use `compareExchange` kind of defeats the purpose. 

[10:45:55.0484] <asumu>
That's interesting, so then `compareExchange`, `add`, `sub`, etc. will just error on a shared struct until types are added? The issue with the boxed case is that doing the loads atomically to read the actual value has high cost?

[10:51:53.0056] <asumu>
BTW, on another topic there's been some development on the Wasm GC side. The idea for now is to have a minimal JS API for the MVP proposal, that won't allow attaching a prototype or reading the fields off of a GC struct from JS (more precisely, you would need to call a Wasm function to do that). Then a richer JS API would be in a separate follow-up proposal. I think that's still compatible with JS structs, in that the connection to structs could come in the follow-up proposal (there is no need for GC structs to be reflected as JS structs if the fields are not readable from JS directly as properties).

But I'd like to make sure the minimal JS API won't preclude using structs in the future, by keeping the reflected Wasm GC struct as a frozen object (with no own properties) and a null, immutable prototype. Eventually the follow-up proposal could make those reflect as structs. Does that sound like it would work for future compatibility with structs?

[10:52:22.0191] <asumu>
 * BTW, on another topic there's been some development on the Wasm GC side. The idea for now is to have a minimal JS API for the MVP proposal, that won't allow attaching a prototype or reading the fields off of a GC struct from JS (more precisely, you would need to call a Wasm function to do that). Then a richer JS API would be in a separate follow-up proposal. I think that's still compatible with JS structs, in that the connection to structs could come in the follow-up proposal (there is no need for GC structs to be reflected as JS structs if the fields are not readable from JS directly).

But I'd like to make sure the minimal JS API won't preclude using structs in the future, by keeping the reflected Wasm GC struct as a frozen object (with no own properties) and a null, immutable prototype. Eventually the follow-up proposal could make those reflect as structs. Does that sound like it would work for future compatibility with structs?

[10:52:43.0631] <asumu>
 * BTW, on another topic there's been some development on the Wasm GC side. The idea for now is to have a minimal JS API for the MVP proposal, that won't allow attaching a prototype or reading the fields off of a GC struct from JS (more precisely, you would need to call a Wasm function to do that). Then a richer JS API would be in a separate follow-up proposal. I think that's still compatible with JS structs, in that the connection to structs could come in the follow-up proposal (there is no need for GC structs to be reflected as JS structs if the fields are not readable from JS directly as properties).

But I'd like to make sure the minimal JS API won't preclude using structs in the future, by keeping the reflected Wasm GC struct as a frozen object (with no own properties) and a null, immutable prototype. Eventually the follow-up proposal could make those reflect as structs. Does that sound like it would work for future compatibility with structs?


2022-03-15
[11:12:08.0839] <shu>
> <@rbuckton:matrix.org> One of the uses for `compareExchange` is to implement lock-free updates (i.e., atomically compare and update, returning a value so you can see if you succeeded). Requiring locks to use `compareExchange` kind of defeats the purpose.

agreed

[11:12:40.0688] <shu>
> <@atakikawa:igalia.com> That's interesting, so then `compareExchange`, `add`, `sub`, etc. will just error on a shared struct until types are added? The issue with the boxed case is that doing the loads atomically to read the actual value has high cost?

no, the issue is that there are no CPU instructions to do this in a way without locking it with an actual mutex, which as Ron said above, kinda defeats the purpose

[11:13:01.0912] <shu>
`add` and `sub` will just error without field types, yes

[11:13:26.0105] <shu>
`compareExchange` would work _only_ for things with identity, like objects

[11:13:35.0362] <shu>
i don't know how to make `compareExchange` work for e.g. numbers

[11:13:43.0672] <shu>
 * i don't know how to make `compareExchange` work for e.g. numbers

[11:14:40.0032] <shu>
specifically for cmpxcg i think that's probably fine

[11:15:17.0171] <shu>
most cmpxchg in my experience are for lock-free updates of state, and the workaround in this case is to wrap it in an Object so you can do pointer comparison on the Object pointer

[11:16:00.0943] <shu>
it's a bit annoying if you have a fixed number of states, like what you might use a int enum for in C++, since this means you'd need to make a few constant Objects ahead of time like

[11:16:07.0989] <shu>
for example, if you were writing a mutex yourself

[11:16:39.0681] <shu>
`const LOCKED_STATE = {}; const UNLOCKED_STATE = {}; const CONTENDED_LOCKED_STATE = {};` and use those objects for the cmpxchgs

[11:17:11.0607] <shu>
it is kind of annoying but also fundamental, we don't have ints in the language outside of TAs...

