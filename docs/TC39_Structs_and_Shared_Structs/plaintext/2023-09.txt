2023-09-06
[13:43:26.0749] <rbuckton>
shu: Are the origin trial shared structs not allowed to have fields that are stringified integers?

[14:25:56.0386] <shu>
rbuckton: it should, that looks like a bug

[14:26:01.0355] <shu>
i'll investigate soon, thanks for raising it

[15:32:40.0914] <rbuckton>
The more I tinker with this, trying to shoehorn it into the compiler, the more I want some mechanism to attach behavior.
I also had to implement a custom `Map`-like mechanism using shared structs to share some keyed data efficiently. 

[15:33:20.0290] <rbuckton>
I have made some progress on parallel parsing, however. 

[15:44:56.0565] <shu>
i am working on the behavior thing

[15:45:10.0955] <shu>
more specifically, the thread-local storage thing

[15:45:46.0842] <shu>
our current GC scheme makes inter-heap cycles uncollectable, and i'm trying to fix that, which is taking a bit due to GC being finnicky


2023-09-08
[16:48:21.0705] <rbuckton>
shu: are you aware of any issues debugging workers when - - harmony-structs or the Shared string table flag are enabled? I'm running issues debugging in VS Code and wanted to check if there were any known issues before I file an issue with VS Code. 

[16:50:12.0414] <rbuckton>
I'm not sure if it's Code, the chrome debug protocol, NodeJS, or V8 causing the issue, but the first breakpoint I hit after starting a worker and passing it a shared struct results in the debugger locking up. 

[16:57:14.0828] <rbuckton>
I finally reached a point where I can successfully parse a large project (xstate) using parallel parsing and the results aren't very promising yet. On a single thread, parse takes about 1.2s on my machine, and about 3.5s when running in parallel. However this is still very early and I'm having to copy the entire AST of each file from the struct representation into a normal JS object so it can be used by our existing checker and emitter. The limitations of structs mean we can't just use them as-is without a significant rewrite. 


2023-09-09
[17:06:01.0751] <shu>
rbuckton: re: VSCode debugging, i don't know but i wouldn't be surprised if devtools just doesn't work because nobody has looked at it. printf debugging is what we do unfortunately, devtools investment is unlikely to materialize without something like getting to stage 3 first

[17:06:17.0834] <shu>
yeah, copying into normal objects sounds like it would kill performance indeed

[17:06:31.0900] <shu>
what are the limitations? attaching behavior and that ownProperty bug?

[17:06:52.0555] <shu>
(please file issues for the limitations getting in your way in addition to the attaching behaviors thing)

[17:27:38.0514] <rbuckton>
> <@shuyuguo:matrix.org> what are the limitations? attaching behavior and that ownProperty bug?

If I limit this to just the command line compiler, the biggest issue is that I can't emulate our internal `NodeArray` with a `SharedArray`. A `NodeArray` is just an `Array` with a few extra properties attached, but that causes several issues:
- Can't define extra fields on `SharedArray`
- Alternatively, can't define numeric indexed properties on a regular struct.
- SharedArray is not iterable and you can't make a regular struct iterable, so I have to rewrite every `for..of` and array method call to work around. 

[17:27:53.0931] <rbuckton>
* In reply to @shuyuguo:matrix.org
what are the limitations? attaching behavior and that ownProperty bug?


If I limit this to just the command line compiler, the biggest issue is that I can't emulate our internal NodeArray with a SharedArray. A NodeArray is just an Array with a few extra properties attached, but that causes several issues:

Can't define extra fields on SharedArray

Alternatively, can't define numeric indexed properties on a regular struct.

SharedArray is not iterable and you can't make a regular struct iterable, so I have to rewrite every for..of and array method call to work around.


[17:28:20.0192] <rbuckton>
* In reply to shu
what are the limitations? attaching behavior and that ownProperty bug?


In reply to @shuyuguo:matrix.org
what are the limitations? attaching behavior and that ownProperty bug?

If I limit this to just the command line compiler, the biggest issue is that I can't emulate our internal NodeArray with a SharedArray. A NodeArray is just an Array with a few extra properties attached, but that causes several issues:
- Can't define extra fields on SharedArray

- Alternatively, can't define numeric indexed properties on a regular struct.

- SharedArray is not iterable and you can't make a regular struct iterable, so I have to rewrite every for..of and array method call to work around.


[17:28:32.0877] <rbuckton>
* In reply to shu
what are the limitations? attaching behavior and that ownProperty bug?


In reply to shu
what are the limitations? attaching behavior and that ownProperty bug?

In reply to @shuyuguo:matrix.org
what are the limitations? attaching behavior and that ownProperty bug?
If I limit this to just the command line compiler, the biggest issue is that I can't emulate our internal NodeArray with a SharedArray. A NodeArray is just an Array with a few extra properties attached, but that causes several issues:

Can't define extra fields on SharedArray

Alternatively, can't define numeric indexed properties on a regular struct.

SharedArray is not iterable and you can't make a regular struct iterable, so I have to rewrite every for..of and array method call to work around.


[17:30:00.0937] <rbuckton>
We also use data structures like `Map` that we can't emulate due to the inability to attach behavior, so there's a lot of copying in and out of data structures we can use. 

[17:33:14.0207] <rbuckton>
If I wanted to extend these structs to the language service, we're in the realm of needing behavior and the ability to freeze or lock down specific properties. Our AST is mostly treated as immutable, but if we were to vend struct based nodes from our API they would become unsafe to use if a consumer could make changes to properties outside of a lock. 

[17:37:52.0976] <rbuckton>
For now I've worked around a few other issues. I add a `__tag__` field to structs I create when type identity is important, as well as a field containing a pseudo- identity hash so I can use some structs as keys in a shared hashmap implementation I wrote (in place of Map where needed). 

[17:40:39.0203] <rbuckton>
I'm using classes and decorators to fake syntax to better work with the type system, like in the example above. The decorators just collect field names and create a SharedStructType attached to the class, behavior is just defined as static methods. 

[17:43:41.0680] <rbuckton>
I'm also experimenting with a `Mutex` wrapper that let's me write code like this:

```ts
{
  using lck = new UniqueLock(mutex);
  ...
}
```

Though the mutex wrapper is slower than `Atomics.Mutex`.

[18:11:10.0329] <rbuckton>
> <@rbuckton:matrix.org> In reply to shu
> what are the limitations? attaching behavior and that ownProperty bug?
> 
> 
> In reply to shu
> what are the limitations? attaching behavior and that ownProperty bug?
> 
> In reply to @shuyuguo:matrix.org
> what are the limitations? attaching behavior and that ownProperty bug?
> If I limit this to just the command line compiler, the biggest issue is that I can't emulate our internal NodeArray with a SharedArray. A NodeArray is just an Array with a few extra properties attached, but that causes several issues:
> 
> Can't define extra fields on SharedArray
> 
> Alternatively, can't define numeric indexed properties on a regular struct.
> 
> SharedArray is not iterable and you can't make a regular struct iterable, so I have to rewrite every for..of and array method call to work around.

This ended up horribly formatted due to trying to edit the message on my phone :/

[18:11:26.0750] <rbuckton>
> <@shuyuguo:matrix.org> what are the limitations? attaching behavior and that ownProperty bug?

 * If I limit this to just the command line compiler, the biggest issue is that I can't emulate our internal NodeArray with a SharedArray. A NodeArray is just an Array with a few extra properties attached, but that causes several issues:

- Can't define extra fields on SharedArray

- Alternatively, can't define numeric indexed properties on a regular struct.

- SharedArray is not iterable and you can't make a regular struct iterable, so I have to rewrite every for..of and array method call to work around.


2023-09-11
[13:54:53.0035] <shu>
rbuckton: we should figure out how to get builds of node with tip-of-tree V8. your indexed property woes seems to have been long fixed, but the V8 version that your version of node uses hasn't picked it up

[13:55:16.0170] <shu>
```
~/v8/v8 $ out/x64.debug/d8 --harmony-struct ./test-shared-struct-elements-own-prop.js 
V8 is running with experimental features enabled. Stability and security will suffer.
0,1
{"writable":true,"enumerable":true,"configurable":false}

~/v8/v8 $ cat ./test-shared-struct-elements-own-prop.js 
var t = new SharedStructType(["0", "1"]);
var s = new t();
print(Object.keys(s));
print(JSON.stringify(Object.getOwnPropertyDescriptor(s, "0")));
```

[16:32:36.0304] <rbuckton>
I'll have to take some time next week to spin up a NodeJS build environment


2023-09-12
[09:13:28.0069] <Mathieu Hofman>
I've used https://nodejs.org/download/v8-canary/ successfully before

[09:14:35.0250] <Mathieu Hofman>
Built from https://github.com/nodejs/node-v8

[13:29:19.0844] <rbuckton>
> <@mhofman:matrix.org> Built from https://github.com/nodejs/node-v8

Thanks! This works perfectly

[13:32:42.0538] <rbuckton>
`instanceof` for Mutex/Condition/SharedArray is great. I see that it works for instances of instances of `SharedStructType` as well, though there's still no fast way to see if a value is *any* shared struct (i.e., without access to its specific constructor)

[13:33:47.0149] <shu>
rbuckton: there is, i also added `SharedStructType.isSharedStruct` iirc

[13:35:52.0909] <rbuckton>
Ah, great

[13:41:14.0625] <rbuckton>
Hmm. I was hoping I could use `SharedStructType` to emulate `SharedArray` when I also need extra fields, but its significantly slower so that's a no-go.

[13:44:18.0721] <shu>
yes -- that's a possible optimization that's not implemented due to complexity/effort

[13:44:37.0995] <shu>
if you use indexed fields in SharedStructTypes, those are _always_ backed by "dictionary elements", i.e. a hash table

[13:44:41.0700] <shu>
SharedArrays are contiguous arrays

[13:45:09.0605] <shu>
we can optimize SharedStructTypes to use fast elements when those indexes are all packed, or something

[13:45:22.0754] <shu>
i could put it on the queue if it's a blocker

[13:47:08.0594] <Ashley Claymore>
> <@rbuckton:matrix.org> Hmm. I was hoping I could use `SharedStructType` to emulate `SharedArray` when I also need extra fields, but its significantly slower so that's a no-go.

Could the N extra fields be hidden at the start of the sharedarray? Their names map to fixed indexes 0,1,2 etc, and all array looping logic knows to start index at N? Or too big a refactor?

[13:48:54.0852] <rbuckton>
Thats just as much of a refactor as what I was doing, which was stashing a SharedArray in an `items` field in another struct. The biggest issue with that approach is that every function that expected a `NodeArray` with indexable elements has to check if it's instead a `SharedNodeArray` to use its `items` field.

[13:49:22.0691] <shu>
rbuckton: what's the full list of field names you'd like to be fast?

[13:49:29.0585] <shu>
might not be too bad, i'll see if i have time next week

