<!DOCTYPE html><html><head>
  <title>TC39 Structs and Shared Structs on 2023-09-20</title>
  <link rel="stylesheet" href="../style.css">
  <script>window.room = "TC39 Structs and Shared Structs";</script><script src="../render-roomlist.js"></script>
  <script src="../logs.js"></script>
</head>
<body><div class="wrapper">
<div class="sidebar">
<div class="title">TC39 Structs and Shared Structs<br>2023-09-20<br><a href="plaintext/">plaintext logs</a></div>
<div class="nav">
<a href="2023-09-19" class="nav-link"><span>prev</span></a>
<span style="float:right">next</span>
</div>
    <div class="all-rooms"><noscript>JavaScript is required to load the channel index, but you can go to <a href="../..">the static index</a> directly.</noscript></div>
<div class="footer"><a href="https://github.com/bakkot/matrix-archive-bot">source on github</a></div>
</div>
<div class="rhs">
<div class="rhs-header">
<span id="error" style="color: red; display:none">error</span>

<input type="text" id="query" size="25" placeholder="Search TC39 Structs and Shared Structs">
<a id="search-submit" class="button icon-link" title="Search">
  <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg>
</a>
</div>

<div class="log"><table id="log-table"><tbody id="log-tbody">

  <tr class="msg" id="L0"><td class="ts-cell"><a class="ts" href="#L0" alt="Tue Sep 19 2023 18:01:08 GMT-0700 (Pacific Daylight Time)">01:01</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><ul>
<li>When A handshakes with M:
<ul>
<li>M is able to establish that a PointA should have a PointM prototype and it will apply to every PointA it receives, from anywhere, within the scope of M's Agent.</li>
<li>A is able to establish that a PointM should have a PointA prototype and it will apply to every PointM it receives, from anywhere, within the scope of A's Agent.</li>
</ul>
</li>
<li>When B handshakes with M:
<ul>
<li>M is able to establish that a PointB should have a PointM prototype and it will apply to every PointB it receives, from anywhere, within the scope of M's Agent.</li>
<li>B is able to establish that a PointM should have a PointB prototype and it will apply to every PointM it receives, from anywhere, within the scope of B's Agent.</li>
</ul>
</li>
</ul>
<p>As such:</p>
<ul>
<li>M will be able to find behavior for both rect1.topLeft and rect1.topRight, because the handshake between M-A and M-B established that.</li>
<li>B will not be able to find a behavior for rect1.topLeft because registries RA and RB are independent.</li>
<li>A will not be able to find a behavior for rect1.bottomRight because registries RA and RB are independent.</li>
</ul>
</td></tr>
  <tr class="msg" id="L1"><td class="ts-cell"><a class="ts" href="#L1" alt="Tue Sep 19 2023 18:03:11 GMT-0700 (Pacific Daylight Time)">01:03</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><p>However, if you use the same registry RAB with A and B:</p>
<ul>
<li>B is able to establish that a PointA should have a PointB prototype because the registry correlates both PointA and PointB with PointM.</li>
<li>A is able to establish that a PointB should have a PointA prototype because the registry correlates both PointA and PointB with PointM.</li>
</ul>
</td></tr>
  <tr class="msg" id="L2"><td class="ts-cell"><a class="ts" href="#L2" alt="Tue Sep 19 2023 18:06:29 GMT-0700 (Pacific Daylight Time)">01:06</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">If such a prototype is initialized lazily in <code>[[GetPrototypeOf]]</code>, by the time B can receive a PointA, or that A can receive a PointB, both agents will have completed their handshake with M, so all information is known. This is another reason why my proposal uses a preload script. The preload script performs the worker side of the handshake before any other data can be shared between the worker and M, so you cannot have a stray PointA sent to B, or PointB sent to A, prior to a completed handshake on both sides.</td></tr>
  <tr class="msg" id="L3"><td class="ts-cell"><a class="ts" href="#L3" alt="Tue Sep 19 2023 18:13:19 GMT-0700 (Pacific Daylight Time)">01:13</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Now, we could theoretically have a global registry instead, with the <code>structs: {}</code> map only used to correlate PointM and PointA when A is established. Workers will always be part of a tree that points back to some root agent, so there's always a way to collect these things. If the handshake establishes the relationship without the ability to pass messages, would that be sufficient to address concerns about a global registry?</td></tr>
  <tr class="msg" id="L4"><td class="ts-cell"><a class="ts" href="#L4" alt="Tue Sep 19 2023 18:16:52 GMT-0700 (Pacific Daylight Time)">01:16</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Especially if the worker can't actually observe the exemplar during handshake, since the handshake process is handled by the runtime. We wouldn't even need communicate the actual exemplars through the handshake process, just the type identities of the exemplars. </td></tr>
  <tr class="msg" id="L5"><td class="ts-cell"><a class="ts" href="#L5" alt="Tue Sep 19 2023 18:21:15 GMT-0700 (Pacific Daylight Time)">01:21</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Though there is the caveat that M could try to pass off a PointA as an exemplar to B's Rect, but we could probably just make that an error, i.e. the exemplars M sends during the handshake must have been created by a type created in M's Agent</td></tr>
  <tr class="msg" id="L6"><td class="ts-cell"><a class="ts" href="#L6" alt="Tue Sep 19 2023 18:22:54 GMT-0700 (Pacific Daylight Time)">01:22</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">and the same thing goes for A (or B) spinning up a Worker (A2) during handshake and passing off one A2's exemplars as one of its own.</td></tr>
  <tr class="msg" id="L7"><td class="ts-cell"><a class="ts" href="#L7" alt="Tue Sep 19 2023 20:05:31 GMT-0700 (Pacific Daylight Time)">03:05</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell"><p>Right I think an agent based registry can only work if:</p>
<ul>
<li>the internal agent wide registry is an association from type to local behavior definition</li>
<li>there is a unique connection registry between 2 agents, and preparing a connection registry mapping (as creator or as a worker setting up), associates a connection specific string to a locally defined type only</li>
<li>you can only populate the agent wide registry through connection registries.</li>
</ul>
<p>that means a worker A connected to a worker B through M but not sharing the same connection registry will not be able share behavior throughout. I'm still wondering about the special parent - child relationship these connection based registries seem to have, and how you can only have one connection registry between 2 agents or things fall apart. I can't explain why exactly right now, but this all feels awkward.</p>
</td></tr>
  <tr class="msg" id="L8"><td class="ts-cell"><a class="ts" href="#L8" alt="Wed Sep 20 2023 05:38:13 GMT-0700 (Pacific Daylight Time)">12:38</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">I'm wondering if we even need a connection-based registry if we can devise a global registry strategy that addresses Agoric's concerns about security. You'd discussed how a mutable global registry is a possible side channel for data exfiltration? I'm curious how serious the concern is and if you have a link to a paper or something else that could provide additional context? Is the concern related to how a Worker could abuse such a global registry, or how a script or module in the same Agent could abuse such a registry?</td></tr>
  <tr class="msg" id="L9"><td class="ts-cell"><a class="ts" href="#L9" alt="Wed Sep 20 2023 09:32:43 GMT-0700 (Pacific Daylight Time)">16:32</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> <p>the two choices are:</p>
<ol>
<li>a shared struct instance's [[Prototype]] is a shared field and holds a shared struct, with <code>nonshared</code> fields, into which you assign methods</li>
<li>a shared struct instance's [[Prototype]] is a <code>nonshared</code> field and points to a per-agent local struct</li>
</ol>
</blockquote></mx-reply><span class="nick-15">rbuckton</span>: after chatting with some other V8 engineers i'm coming back to the idea that perhaps (2) is better</td></tr>
  <tr class="msg" id="L10"><td class="ts-cell"><a class="ts" href="#L10" alt="Wed Sep 20 2023 09:53:32 GMT-0700 (Pacific Daylight Time)">16:53</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> I'm wondering if we even need a connection-based registry if we can devise a global registry strategy that addresses Agoric's concerns about security. You'd discussed how a mutable global registry is a possible side channel for data exfiltration? I'm curious how serious the concern is and if you have a link to a paper or something else that could provide additional context? Is the concern related to how a Worker could abuse such a global registry, or how a script or module in the same Agent could abuse such a registry?</blockquote></mx-reply>The concern has usually manifested itself in the form of Realm-wide or Agent-wide state, but it's conceivable that the same concern could manifest for Agent cluster-wide state. The problem is that such global mutable state allows 2 parties that do not share any references besides the primordials objects to communicate. In JavaScript today, you can freeze all the intrinsics, and it's not possible for 2 pieces of code to communicate unless they're explicitly provided a reference to each other, or to a shared mutable object.</td></tr>
  <tr class="msg" id="L11"><td class="ts-cell"><a class="ts" href="#L11" alt="Wed Sep 20 2023 09:55:33 GMT-0700 (Pacific Daylight Time)">16:55</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> <span class="nick-15">rbuckton</span>: after chatting with some other V8 engineers i'm coming back to the idea that perhaps (2) is better</blockquote></mx-reply>Would this affect subclassing or no? I imagine in a subclassing case, we would just collect all of the shared fields up front and put them on the instance, much like we do for private fields today, so I don't imagine it would.</td></tr>
  <tr class="msg" id="L12"><td class="ts-cell"><a class="ts" href="#L12" alt="Wed Sep 20 2023 09:57:31 GMT-0700 (Pacific Daylight Time)">16:57</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell"><span class="nick-15">rbuckton</span>: that's not clear to me yet. one challenge here is how to express the thread-localness of a superclass</td></tr>
  <tr class="msg" id="L13"><td class="ts-cell"><a class="ts" href="#L13" alt="Wed Sep 20 2023 09:58:51 GMT-0700 (Pacific Daylight Time)">16:58</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">we want the fixed layout invariant to hold, so do you say like "shared struct A extends per-agent B", but what is B? it could be itself a shared struct but its layout gets copied into a thread-local version of the struct the first time [[Prototype]] is accessed in a thread</td></tr>
  <tr class="msg" id="L14"><td class="ts-cell"><a class="ts" href="#L14" alt="Wed Sep 20 2023 09:58:59 GMT-0700 (Pacific Daylight Time)">16:58</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">should it be a non-shared struct declaration?</td></tr>
  <tr class="msg" id="L15"><td class="ts-cell"><a class="ts" href="#L15" alt="Wed Sep 20 2023 09:59:05 GMT-0700 (Pacific Daylight Time)">16:59</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">(but it gets that layout copy behavior)</td></tr>
  <tr class="msg" id="L16"><td class="ts-cell"><a class="ts" href="#L16" alt="Wed Sep 20 2023 10:26:57 GMT-0700 (Pacific Daylight Time)">17:26</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> The concern has usually manifested itself in the form of Realm-wide or Agent-wide state, but it's conceivable that the same concern could manifest for Agent cluster-wide state. The problem is that such global mutable state allows 2 parties that do not share any references besides the primordials objects to communicate. In JavaScript today, you can freeze all the intrinsics, and it's not possible for 2 pieces of code to communicate unless they're explicitly provided a reference to each other, or to a shared mutable object.</blockquote></mx-reply>Do you imagine such communication is possible in this case?</td></tr>
  <tr class="msg" id="L17"><td class="ts-cell"><a class="ts" href="#L17" alt="Wed Sep 20 2023 10:30:10 GMT-0700 (Pacific Daylight Time)">17:30</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Lets assume you can't use the exemplar values themselves to communicate, i.e., the actual exemplars aren't exposed to user code on the other Agent.</td></tr>
  <tr class="msg" id="L18"><td class="ts-cell"><a class="ts" href="#L18" alt="Wed Sep 20 2023 10:32:16 GMT-0700 (Pacific Daylight Time)">17:32</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">The child thread can't send or receive structs to the parent thread during handshake, and by the time handshake has completed all correlation between the parent and child is frozen.</td></tr>
  <tr class="msg" id="L19"><td class="ts-cell"><a class="ts" href="#L19" alt="Wed Sep 20 2023 10:34:44 GMT-0700 (Pacific Daylight Time)">17:34</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">By the time A can observe a struct from B, the correlation between M, A, and B has already occurred and is frozen. You cannot dynamically attach new behavior, but we do lazily resolve the prototype based on correlation.</td></tr>
  <tr class="msg" id="L20"><td class="ts-cell"><a class="ts" href="#L20" alt="Wed Sep 20 2023 10:40:22 GMT-0700 (Pacific Daylight Time)">17:40</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Maybe there's a small possibility of a timing related exploit if I can somehow spin up multiple additional workers on M and send an existing corelated struct to A to indicate <code>0</code> and new correlated struct to A indicating <code>1</code> and somehow measure the timing? That might be mitigated if correlation happens before normal communication can occur and prototype lookup always follows the same path, but you could potentially use structs who have narrow and wide correlation sets and measure timing that way, or update an agent-local correlation registry when two agent's communicate for the first time so that you pay that cost once.</td></tr>
  <tr class="msg" id="L21"><td class="ts-cell"><a class="ts" href="#L21" alt="Wed Sep 20 2023 10:43:10 GMT-0700 (Pacific Daylight Time)">17:43</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">There are possibly other ways to mitigate that as well.</td></tr>
  <tr class="msg" id="L22"><td class="ts-cell"><a class="ts" href="#L22" alt="Wed Sep 20 2023 10:46:27 GMT-0700 (Pacific Daylight Time)">17:46</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Within a single Agent, when worker's aren't involved, you wouldn't be able to use this registry for communication because it would be inaccessible. You can also use CSP to lock down Worker to specific scripts, or disable it entirely.</td></tr>
  <tr class="msg" id="L23"><td class="ts-cell"><a class="ts" href="#L23" alt="Wed Sep 20 2023 10:49:21 GMT-0700 (Pacific Daylight Time)">17:49</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">If <code>Worker</code> is locked down via CSP, the only way you could leverage these for a timing attack would be to be handed a reference to a shared struct, which I would argue qualifies for being provided a reference to a shared mutable object.</td></tr>
  <tr class="msg" id="L24"><td class="ts-cell"><a class="ts" href="#L24" alt="Wed Sep 20 2023 11:00:39 GMT-0700 (Pacific Daylight Time)">18:00</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">If you have two isolated pieces of code in the same Agent that both have access to an unrestricted <code>Worker</code>, its possible they could already communicate with each other via resource starvation and timing attacks.</td></tr>
  <tr class="msg" id="L25"><td class="ts-cell"><a class="ts" href="#L25" alt="Wed Sep 20 2023 12:06:52 GMT-0700 (Pacific Daylight Time)">19:06</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">For same realm/agent, if the registry is string keyed, Alice can register "foo". If Bob can somehow figure out that "foo" is already registered, this is a one bit communication channel. There are likely multiple ways Bob could sense whether "foo" is registered.</td></tr>
  <tr class="msg" id="L26"><td class="ts-cell"><a class="ts" href="#L26" alt="Wed Sep 20 2023 12:20:53 GMT-0700 (Pacific Daylight Time)">19:20</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">With the global registry concept, all registration within a single Agent would happen via <code>new SharedStructType</code> (or via <code>shared struct Foo {}</code>). No errors would be reported except for running out of heap space (and crashing). When setting up a <code>Worker</code>, there is a correlation step to correlate the registrations within both Agents, but this only occurs at the time of the Worker handshake and should only be observable by interacting with that Worker or a shared struct provided to the worker.</td></tr>
  <tr class="msg" id="L27"><td class="ts-cell"><a class="ts" href="#L27" alt="Wed Sep 20 2023 12:22:38 GMT-0700 (Pacific Daylight Time)">19:22</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">As far as I can tell, there's no way to observe that within a single Agent/realm. You can't check if something is "registered" because all "registration" happens before the thing you would test exists.</td></tr>
  <tr class="msg" id="L28"><td class="ts-cell"><a class="ts" href="#L28" alt="Wed Sep 20 2023 12:24:00 GMT-0700 (Pacific Daylight Time)">19:24</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">The only way to observe correlation would be to use a Worker and a shared reference, which still only observes correlation between those two Agents.</td></tr>
  <tr class="msg" id="L29"><td class="ts-cell"><a class="ts" href="#L29" alt="Wed Sep 20 2023 12:25:18 GMT-0700 (Pacific Daylight Time)">19:25</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">There should be no way to get at the registry itself, and the only way to establish correlation is to already have a reference to the shared struct type. </td></tr>
  <tr class="msg" id="L30"><td class="ts-cell"><a class="ts" href="#L30" alt="Wed Sep 20 2023 12:26:02 GMT-0700 (Pacific Daylight Time)">19:26</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">You could observe whether A and B share correlation with M, but only if you already have access to shared data from A and B</td></tr>
  <tr class="msg" id="L31"><td class="ts-cell"><a class="ts" href="#L31" alt="Wed Sep 20 2023 12:27:40 GMT-0700 (Pacific Daylight Time)">19:27</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">There would be no error upon registration, because there is no addressable identity to forge, nor a way to forge it. Every shared struct type would have its own type identity, defined at the time of creation.</td></tr>
  <tr class="msg" id="L32"><td class="ts-cell"><a class="ts" href="#L32" alt="Wed Sep 20 2023 12:56:19 GMT-0700 (Pacific Daylight Time)">19:56</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">I think it depends on how the global registry works, how it handles collisions? Any mechanism that uses a forgeable value as key is likely observable, whether it errors, or first / last win. In the latter case, as you mention starting a worker and asking it to send you that type, and seeing what behavior you get, yours or the other one registered in the same realm. I really cannot imagine any way where a registry with forgeable keys can be made unobservable.
You do mention "no way to get at the registry itself", which instead sounds like design we were talking about yesterday, not an agent wide string keyed registry, but instead a connection based string-keyed mapper. I agree that it may be possible to make that work, but I think it requires the "correlation registry" between 2 agents to be unique and immutable after start.</td></tr>
  <tr class="msg" id="L33"><td class="ts-cell"><a class="ts" href="#L33" alt="Wed Sep 20 2023 12:57:33 GMT-0700 (Pacific Daylight Time)">19:57</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell"><span class="nick-15">rbuckton</span>: actually how <em>do</em> you think we can syntactically express the shape of a shared struct's prototype, if that prototype is to be fixed layout but per-thread?</td></tr>
  <tr class="msg" id="L34"><td class="ts-cell"><a class="ts" href="#L34" alt="Wed Sep 20 2023 12:57:46 GMT-0700 (Pacific Daylight Time)">19:57</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">there's not a good precedent to fall back on in <code>class</code> syntax</td></tr>
  <tr class="msg" id="L35"><td class="ts-cell"><a class="ts" href="#L35" alt="Wed Sep 20 2023 13:01:05 GMT-0700 (Pacific Daylight Time)">20:01</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> <span class="nick-15">rbuckton</span>: actually how <em>do</em> you think we can syntactically express the shape of a shared struct's prototype, if that prototype is to be fixed layout but per-thread?</blockquote></mx-reply>How important is it that the prototype be fixed shape, especially if we're not actually sharing the prototype around anywhere?</td></tr>
  <tr class="msg" id="L36"><td class="ts-cell"><a class="ts" href="#L36" alt="Wed Sep 20 2023 13:01:36 GMT-0700 (Pacific Daylight Time)">20:01</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">it's not <em>as</em> important but i feel it is still important</td></tr>
  <tr class="msg" id="L37"><td class="ts-cell"><a class="ts" href="#L37" alt="Wed Sep 20 2023 13:03:02 GMT-0700 (Pacific Daylight Time)">20:03</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">part of my mental model of structs (shared or not) over ordinary objects is "the shape doesn't change", and that transitively applies via the prototype chain</td></tr>
  <tr class="msg" id="L38"><td class="ts-cell"><a class="ts" href="#L38" alt="Wed Sep 20 2023 13:03:13 GMT-0700 (Pacific Daylight Time)">20:03</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> I think it depends on how the global registry works, how it handles collisions? Any mechanism that uses a forgeable value as key is likely observable, whether it errors, or first / last win. In the latter case, as you mention starting a worker and asking it to send you that type, and seeing what behavior you get, yours or the other one registered in the same realm. I really cannot imagine any way where a registry with forgeable keys can be made unobservable.<br>You do mention "no way to get at the registry itself", which instead sounds like design we were talking about yesterday, not an agent wide string keyed registry, but instead a connection based string-keyed mapper. I agree that it may be possible to make that work, but I think it requires the "correlation registry" between 2 agents to be unique and immutable after start.</blockquote></mx-reply>What collisions? What is forgeable? The only thing user-provided is the correlation token used to explain what prototype to choose for a foreign struct within an Agent, and that only affects that Agent's view of the struct, not any other agent.</td></tr>
  <tr class="msg" id="L39"><td class="ts-cell"><a class="ts" href="#L39" alt="Wed Sep 20 2023 13:04:29 GMT-0700 (Pacific Daylight Time)">20:04</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> part of my mental model of structs (shared or not) over ordinary objects is "the shape doesn't change", and that transitively applies via the prototype chain</blockquote></mx-reply>Way back when I'd thought to have structs act as value objects, my intuition was that the prototype would be looked up during ToObject just like we do for <code>Number</code>, <code>String</code>, etc. so it had no bearing on the shape of struct's runtime representation.</td></tr>
  <tr class="msg" id="L40"><td class="ts-cell"><a class="ts" href="#L40" alt="Wed Sep 20 2023 13:04:55 GMT-0700 (Pacific Daylight Time)">20:04</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">yes, that is a competing model</td></tr>
  <tr class="msg" id="L41"><td class="ts-cell"><a class="ts" href="#L41" alt="Wed Sep 20 2023 13:05:11 GMT-0700 (Pacific Daylight Time)">20:05</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">That's not the case now, but I still don't find see the necessity for a fixed shape for the prototype.</td></tr>
  <tr class="msg" id="L42"><td class="ts-cell"><a class="ts" href="#L42" alt="Wed Sep 20 2023 13:05:22 GMT-0700 (Pacific Daylight Time)">20:05</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">and i am open to be convinced of that competing model</td></tr>
  <tr class="msg" id="L43"><td class="ts-cell"><a class="ts" href="#L43" alt="Wed Sep 20 2023 13:05:40 GMT-0700 (Pacific Daylight Time)">20:05</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">it has some attractive properties, like, the dynamism feels more at home with the rest of the language</td></tr>
  <tr class="msg" id="L44"><td class="ts-cell"><a class="ts" href="#L44" alt="Wed Sep 20 2023 13:05:49 GMT-0700 (Pacific Daylight Time)">20:05</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">it has an exact parallel to primitive prototype wrapping, as you've pointed out</td></tr>
  <tr class="msg" id="L45"><td class="ts-cell"><a class="ts" href="#L45" alt="Wed Sep 20 2023 13:06:10 GMT-0700 (Pacific Daylight Time)">20:06</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">The caveat is that it doesn't translate well to multiple realms in the same Agent</td></tr>
  <tr class="msg" id="L46"><td class="ts-cell"><a class="ts" href="#L46" alt="Wed Sep 20 2023 13:06:34 GMT-0700 (Pacific Daylight Time)">20:06</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Unless you need to somehow define behavior independently per realm.</td></tr>
  <tr class="msg" id="L47"><td class="ts-cell"><a class="ts" href="#L47" alt="Wed Sep 20 2023 13:07:08 GMT-0700 (Pacific Daylight Time)">20:07</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Which would be another spanner to throw into the behavior assignment discussion :)</td></tr>
  <tr class="msg" id="L48"><td class="ts-cell"><a class="ts" href="#L48" alt="Wed Sep 20 2023 13:07:37 GMT-0700 (Pacific Daylight Time)">20:07</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">the downside to the primitive-like wrapping model is i had harbored some hopes "fixed layout" would translate to "easy" static analyzability of static property access on struct instances</td></tr>
  <tr class="msg" id="L49"><td class="ts-cell"><a class="ts" href="#L49" alt="Wed Sep 20 2023 13:08:06 GMT-0700 (Pacific Daylight Time)">20:08</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">but if for knowing the location <code>s.p</code> requires giving up if <code>p</code> is from the prototype, that's too bad</td></tr>
  <tr class="msg" id="L50"><td class="ts-cell"><a class="ts" href="#L50" alt="Wed Sep 20 2023 13:08:11 GMT-0700 (Pacific Daylight Time)">20:08</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">it's not the end of the world or anything</td></tr>
  <tr class="msg" id="L51"><td class="ts-cell"><a class="ts" href="#L51" alt="Wed Sep 20 2023 13:09:11 GMT-0700 (Pacific Daylight Time)">20:09</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> The caveat is that it doesn't translate well to multiple realms in the same Agent</blockquote></mx-reply>eh, i don't think it's a big stretch to choose per-realm instead of per-agent. in the p95 case i imagine apps have 1 realm per agent</td></tr>
  <tr class="msg" id="L52"><td class="ts-cell"><a class="ts" href="#L52" alt="Wed Sep 20 2023 13:09:47 GMT-0700 (Pacific Daylight Time)">20:09</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">i'm pretty neutral on whether to choose per-realm or per-agent. agent is not a notion we expose right now, but realms are, so that's more natural</td></tr>
  <tr class="msg" id="L53"><td class="ts-cell"><a class="ts" href="#L53" alt="Wed Sep 20 2023 13:10:15 GMT-0700 (Pacific Daylight Time)">20:10</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">you end up with weird DX papercuts if you <em>do</em> work with multiple realms in the same agent, but i guess any app that works with multiple realms already must deal with identity discontinuity to some extent</td></tr>
  <tr class="msg" id="L54"><td class="ts-cell"><a class="ts" href="#L54" alt="Wed Sep 20 2023 13:11:21 GMT-0700 (Pacific Daylight Time)">20:11</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">okay, let's continue the thought experiment down the path of relaxing the fixed layout constraint to not apply to nonshared prototypes</td></tr>
  <tr class="msg" id="L55"><td class="ts-cell"><a class="ts" href="#L55" alt="Wed Sep 20 2023 13:11:25 GMT-0700 (Pacific Daylight Time)">20:11</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">how would you express that in syntax?</td></tr>
  <tr class="msg" id="L56"><td class="ts-cell"><a class="ts" href="#L56" alt="Wed Sep 20 2023 13:12:03 GMT-0700 (Pacific Daylight Time)">20:12</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">and how would we take care to not preclude a future with actual shareable functions</td></tr>
  <tr class="msg" id="L57"><td class="ts-cell"><a class="ts" href="#L57" alt="Wed Sep 20 2023 13:12:29 GMT-0700 (Pacific Daylight Time)">20:12</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> What collisions? What is forgeable? The only thing user-provided is the correlation token used to explain what prototype to choose for a foreign struct within an Agent, and that only affects that Agent's view of the struct, not any other agent.</blockquote></mx-reply>Ok so we're in the case of the agent pair having a string keyed correlation registry at initialization of the connection, which I agreed seems fine at first sight, but I still feel weird about, and need to think more about it.</td></tr>
  <tr class="msg" id="L58"><td class="ts-cell"><a class="ts" href="#L58" alt="Wed Sep 20 2023 13:13:20 GMT-0700 (Pacific Daylight Time)">20:13</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Which would be another spanner to throw into the behavior assignment discussion :)</blockquote></mx-reply>Yeah I've been pondering that one myself, but avoided bringing it up</td></tr>
  <tr class="msg" id="L59"><td class="ts-cell"><a class="ts" href="#L59" alt="Wed Sep 20 2023 13:13:44 GMT-0700 (Pacific Daylight Time)">20:13</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell"><span class="nick-2">Mathieu Hofman</span>: i take it you'd prefer per-realm over per-agent?</td></tr>
  <tr class="msg" id="L60"><td class="ts-cell"><a class="ts" href="#L60" alt="Wed Sep 20 2023 13:15:28 GMT-0700 (Pacific Daylight Time)">20:15</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">I'm not sure any handshake mechanism will work per-realm unless you have to establish the handshake when the realm is created, and you can't do that in the browser on the main thread with frames.</td></tr>
  <tr class="msg" id="L61"><td class="ts-cell"><a class="ts" href="#L61" alt="Wed Sep 20 2023 13:15:55 GMT-0700 (Pacific Daylight Time)">20:15</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">ah i hadn't thought that far, that's what you meant by spanner</td></tr>
  <tr class="msg" id="L62"><td class="ts-cell"><a class="ts" href="#L62" alt="Wed Sep 20 2023 13:16:47 GMT-0700 (Pacific Daylight Time)">20:16</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">Well let's say I don't want this to enable a realm to discover the object graph of another realm, if they were previously isolated. I think that's my constraint</td></tr>
  <tr class="msg" id="L63"><td class="ts-cell"><a class="ts" href="#L63" alt="Wed Sep 20 2023 13:17:17 GMT-0700 (Pacific Daylight Time)">20:17</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell"><p>to answer my own syntax question earlier, this could work:</p>
<pre><code>shared struct class S {
  static nonshared prototype;
}
</code></pre>
</td></tr>
  <tr class="msg" id="L64"><td class="ts-cell"><a class="ts" href="#L64" alt="Wed Sep 20 2023 13:17:27 GMT-0700 (Pacific Daylight Time)">20:17</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">since currently, having <code>static prototype</code> is an early error</td></tr>
  <tr class="msg" id="L65"><td class="ts-cell"><a class="ts" href="#L65" alt="Wed Sep 20 2023 13:18:21 GMT-0700 (Pacific Daylight Time)">20:18</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">That's a bit strange, and it doesnt seem like it would work well with method declarations.</td></tr>
  <tr class="msg" id="L66"><td class="ts-cell"><a class="ts" href="#L66" alt="Wed Sep 20 2023 13:19:15 GMT-0700 (Pacific Daylight Time)">20:19</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">why wouldn't it work well with method declarations?</td></tr>
  <tr class="msg" id="L67"><td class="ts-cell"><a class="ts" href="#L67" alt="Wed Sep 20 2023 13:19:41 GMT-0700 (Pacific Daylight Time)">20:19</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">It looks a bit like a field declaration.</td></tr>
  <tr class="msg" id="L68"><td class="ts-cell"><a class="ts" href="#L68" alt="Wed Sep 20 2023 13:20:04 GMT-0700 (Pacific Daylight Time)">20:20</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">(and to clarify, are you thinking of method declarations in the possible future where they are specially-packaged-and-cloned, or the possible future where we have some exotic new callable that's truly shared)</td></tr>
  <tr class="msg" id="L69"><td class="ts-cell"><a class="ts" href="#L69" alt="Wed Sep 20 2023 13:20:48 GMT-0700 (Pacific Daylight Time)">20:20</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">I'm considering both</td></tr>
  <tr class="msg" id="L70"><td class="ts-cell"><a class="ts" href="#L70" alt="Wed Sep 20 2023 13:21:17 GMT-0700 (Pacific Daylight Time)">20:21</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> It looks a bit like a field declaration.</blockquote></mx-reply>indeed. my thought it's "modifying" the field</td></tr>
  <tr class="msg" id="L71"><td class="ts-cell"><a class="ts" href="#L71" alt="Wed Sep 20 2023 13:21:22 GMT-0700 (Pacific Daylight Time)">20:21</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">well, the internal slot</td></tr>
  <tr class="msg" id="L72"><td class="ts-cell"><a class="ts" href="#L72" alt="Wed Sep 20 2023 13:22:00 GMT-0700 (Pacific Daylight Time)">20:22</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">I need to think on that a bit.</td></tr>
  <tr class="msg" id="L73"><td class="ts-cell"><a class="ts" href="#L73" alt="Wed Sep 20 2023 13:22:44 GMT-0700 (Pacific Daylight Time)">20:22</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">it's by all means just an incantation</td></tr>
  <tr class="msg" id="L74"><td class="ts-cell"><a class="ts" href="#L74" alt="Wed Sep 20 2023 13:22:47 GMT-0700 (Pacific Daylight Time)">20:22</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">not a composable bit of syntax</td></tr>
  <tr class="msg" id="L75"><td class="ts-cell"><a class="ts" href="#L75" alt="Wed Sep 20 2023 13:22:58 GMT-0700 (Pacific Daylight Time)">20:22</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-8" title="@shuyuguo:matrix.org">shu</span>&gt;</div></td><td class="msg-cell">ideas welcome, certainly, most things i've thought of are even uglier</td></tr>
  <tr class="msg" id="L76"><td class="ts-cell"><a class="ts" href="#L76" alt="Wed Sep 20 2023 13:25:05 GMT-0700 (Pacific Daylight Time)">20:25</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><p>You want a syntax that:</p>
<ul>
<li>allows you to opt in or out of sharing for <code>struct</code> (for non-shared structs)</li>
<li>allows you to opt in or out of sharing for instance fields (for shared structs)</li>
<li>allows you to opt in or out of sharing for prototype methods (for shared structs in a future where code sharing exists)</li>
<li>allows you to opt in or out of fixed layout for the prototype (for shared and non-shared structs)</li>
<li>allows you to opt in or out of sharing for the prototype (for shared structs)</li>
<li>allows you to opt in or out of sharing for the constructor (for shared structs in a future where code sharing exists)</li>
<li>maybe even allows you to opt in or out of sharing for static methods and static fields (for shared structs in a future where code sharing exists)<br>Does that cover everything?</li>
</ul>
</td></tr>

</tbody></table></div></div></div>
</body></html>