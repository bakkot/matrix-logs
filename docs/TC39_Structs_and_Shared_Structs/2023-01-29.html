<!DOCTYPE html><html><head>
  <title>TC39 Structs and Shared Structs on 2023-01-29</title>
  <link rel="stylesheet" href="../style.css">
  <script>window.room = "TC39 Structs and Shared Structs";</script><script src="../render-roomlist.js"></script>
  <script src="../logs.js"></script>
</head>
<body><div class="wrapper">
<div class="sidebar">
<div class="title">TC39 Structs and Shared Structs<br>2023-01-29<br><a href="plaintext/">plaintext logs</a></div>
<div class="nav">
<a href="2023-01-27" class="nav-link"><span>prev</span></a>
<span style="float:right">next</span>
</div>
    <div class="all-rooms"><noscript>JavaScript is required to load the channel index, but you can go to <a href="../..">the static index</a> directly.</noscript></div>
<div class="footer"><a href="https://github.com/bakkot/matrix-archive-bot">source on github</a></div>
</div>
<div class="rhs">
<div class="rhs-header">
<span id="error" style="color: red; display:none">error</span>

<input type="text" id="query" size="25" placeholder="Search TC39 Structs and Shared Structs">
<a id="search-submit" class="button icon-link" title="Search">
  <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg>
</a>
</div>

<div class="log"><table id="log-table"><tbody id="log-tbody">

  <tr class="msg" id="L0"><td class="ts-cell"><a class="ts" href="#L0" alt="Sun Jan 29 2023 14:17:24 GMT-0800 (Pacific Standard Time)">22:17</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> I fail to see how a user supplied value provided after shared struct creation would work. Unless you'd somehow remap types you may have already seen. IMO you'd at least need to pass your unique ID as part of the <code>SharedStructType.prepare</code> call. But in general I don't like strings for unique IDs, and since we already have object that carry identity across agents, I thought it'd make sense to reuse them.</blockquote></mx-reply>The API I suggested would only be for the origin trial, not the final proposal. The user supplied type identity and prototype isn't "provided after shared struct creation", but rather, the shared struct constructor isn't usable until after it is registered. This is why shared struct type creation that depends on a prototype is different from data-only shared structs. You would have to call <code>register</code> to make the struct type valid.</td></tr>
  <tr class="msg" id="L1"><td class="ts-cell"><a class="ts" href="#L1" alt="Sun Jan 29 2023 14:18:48 GMT-0800 (Pacific Standard Time)">22:18</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> I fail to see how a user supplied value provided after shared struct creation would work. Unless you'd somehow remap types you may have already seen. IMO you'd at least need to pass your unique ID as part of the <code>SharedStructType.prepare</code> call. But in general I don't like strings for unique IDs, and since we already have object that carry identity across agents, I thought it'd make sense to reuse them.</blockquote></mx-reply>"Objects that carry identity across agents" doesn't help with the model I was proposing. In my model, each agent must independently register the type associated with the struct.</td></tr>
  <tr class="msg" id="L2"><td class="ts-cell"><a class="ts" href="#L2" alt="Sun Jan 29 2023 14:20:16 GMT-0800 (Pacific Standard Time)">22:20</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> The API I suggested would only be for the origin trial, not the final proposal. The user supplied type identity and prototype isn't "provided after shared struct creation", but rather, the shared struct constructor isn't usable until after it is registered. This is why shared struct type creation that depends on a prototype is different from data-only shared structs. You would have to call <code>register</code> to make the struct type valid.</blockquote></mx-reply>That's doesn't answer my concern. What would happen if 2 types with different shapes are registered with the same user supplied identity?</td></tr>
  <tr class="msg" id="L3"><td class="ts-cell"><a class="ts" href="#L3" alt="Sun Jan 29 2023 14:20:17 GMT-0800 (Pacific Standard Time)">22:20</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> <pre><code class="language-js">// vector2d.js
// Each shared struct type, whether data only or "prepared" has its own unique type
export const vector2Dtype = SharedStructType.prepare(["x", "y"]);

const _Vector2D = SharedStructType.getConstructor(vector2Dtype);

// custom construction behavior
export function Vector2D(x = 0, y = 0) {
  const _this = Reflect.construct(_Vector2D, [], new.target);
  _this.x = x;
  _this.y = y;
  return _this;
}

// prototype methods
Vector2D.prototype.distanceTo = function (v) {
  const dx = this.x - v.x;
  const dy = this.y - v.y;
  return Math.sqrt(dx * dx + dy * dy);
};

SharedStructType.registerPrototype(vector2Dtype, Vector2D.prototype);

// main.js
import { Vector2D, vector2DType } from "./vector2d.js";
const v1 = new Vector2D(1, 2);
const worker = new Worker("worker.js");
worker.postMessage([vector2DType, v1]);

// worker.js
// worker imports Vector2D, which causes registration as a side-effect.
import { Vector2D, vector2DType } from "./vector2d.js";

const v2 = new Vector2D(3, 4);

parentPort.on("message", ([mainVector2DType, v1]) =&gt; {
  SharedStructType.registerPrototype(mainVector2DType, Vector2D.prototype);
  assert(mainVector2DType !== vector2DType);
  assert(
    SharedStructType.getConstructor(mainVector2DType) !==
      SharedStructType.getConstructor(vector2Dtype)
  );
  assert(v1 instanceof Vector2D); // by virtue of sharing a prototype
  v1.x; // 1
  v1.distanceTo(v2); // ok
  v1.toString(); // ok
});

</code></pre>
<p>SharedStructType.getConstructor() is needed to allow the program to avoid duplicating type definitions in each agent/realm. I think the burden of such deduplication should be on the program, not on the engine.</p>
<p>If the engine had to deduplicate itself, you'd either need a user provided type identifier at "prepare" time, and a global lock around such type definitions, or you'd need to somehow be able to collapse separate definitions into a single one. In either case you'd have to figure out what to do if the shape definition does not match, and in the case of definition collapse, how do you communicate the error to the program?</p>
<p>By having the type definition generate the unique type identifier, you avoid all those complications in the engine, at the cost of putting more type hydration burden on the program.</p>
</blockquote></mx-reply>This assumes the worker can be sure the incoming message is actually for that prototype, which might not be the case if there are multiple possible values for the message. This design seems very hard to implement in user code, while my suggestion is more reliable for write-once and reuse.</td></tr>
  <tr class="msg" id="L4"><td class="ts-cell"><a class="ts" href="#L4" alt="Sun Jan 29 2023 14:20:52 GMT-0800 (Pacific Standard Time)">22:20</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> That's doesn't answer my concern. What would happen if 2 types with different shapes are registered with the same user supplied identity?</blockquote></mx-reply>An error. If the user defined identity is already registered to a different shape, it should throw.</td></tr>
  <tr class="msg" id="L5"><td class="ts-cell"><a class="ts" href="#L5" alt="Sun Jan 29 2023 14:23:13 GMT-0800 (Pacific Standard Time)">22:23</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">The bigger question is, what do we want the final, shipping version of this to look like? Do we want package authors to be able to define structs that package consumers can just use, or do we want package consumers to need to register shared structs themselves in any messaging scaffolding?</td></tr>
  <tr class="msg" id="L6"><td class="ts-cell"><a class="ts" href="#L6" alt="Sun Jan 29 2023 14:23:38 GMT-0800 (Pacific Standard Time)">22:23</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> This assumes the worker can be sure the incoming message is actually for that prototype, which might not be the case if there are multiple possible values for the message. This design seems very hard to implement in user code, while my suggestion is more reliable for write-once and reuse.</blockquote></mx-reply>Right it requires more setup dance from the program, and it's that setup dance that we should try to make easier. But I'm very doubtful we can overcome the issue with a user supplied identity.</td></tr>
  <tr class="msg" id="L7"><td class="ts-cell"><a class="ts" href="#L7" alt="Sun Jan 29 2023 14:28:04 GMT-0800 (Pacific Standard Time)">22:28</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">If we want to make this simple for application developers, then they should be able to install a package, import the struct type (or at least use a side-effecting import for the file containing the struct type to make it visible to the agent), and just use it. This means some kind of per-agent registration would need to occur within the file that contains the struct itself. One mechanism we discussed for that was to depend on the resolved module ID (i.e., if we were depending on the module loader cache). However, that doesn't work well with bundling scenarios where I have one bundle for the main thread, and another bundle for a worker.</td></tr>
  <tr class="msg" id="L8"><td class="ts-cell"><a class="ts" href="#L8" alt="Sun Jan 29 2023 14:29:00 GMT-0800 (Pacific Standard Time)">22:29</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">So there would need to be some way to uniquely identify a struct type regardless of path, such that the same struct types in each bundle can be associated with each other.</td></tr>
  <tr class="msg" id="L9"><td class="ts-cell"><a class="ts" href="#L9" alt="Sun Jan 29 2023 14:31:04 GMT-0800 (Pacific Standard Time)">22:31</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">User-defined IDs are used <em>everywhere</em> for this in many languages and runtimes: UUIDs, URNs, DTDs, etc.</td></tr>
  <tr class="msg" id="L10"><td class="ts-cell"><a class="ts" href="#L10" alt="Sun Jan 29 2023 14:33:23 GMT-0800 (Pacific Standard Time)">22:33</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">My main concern is that any burden for registration should fall on the package developer, not the application developer, whatever the design looks like in the end.</td></tr>
  <tr class="msg" id="L11"><td class="ts-cell"><a class="ts" href="#L11" alt="Sun Jan 29 2023 14:36:02 GMT-0800 (Pacific Standard Time)">22:36</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">I think the question raised by <span class="nick-4">Ashley Claymore</span>is relevant: how do you handle the fan in case where multiple agents setup a shared type before being introduced to each other. A forgeable type identifier in my opinion is not safe, and I'm pretty sure it'd never make it through committee. However I'm not convinced we need prototype/constructor continuity here.</td></tr>
  <tr class="msg" id="L12"><td class="ts-cell"><a class="ts" href="#L12" alt="Sun Jan 29 2023 14:36:05 GMT-0800 (Pacific Standard Time)">22:36</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">And that whatever that design is should be able to take into account bundling, be that with module declarations/module expressions, or traditional bundlers</td></tr>
  <tr class="msg" id="L13"><td class="ts-cell"><a class="ts" href="#L13" alt="Sun Jan 29 2023 14:38:56 GMT-0800 (Pacific Standard Time)">22:38</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> I think the question raised by <span class="nick-4">Ashley Claymore</span>is relevant: how do you handle the fan in case where multiple agents setup a shared type before being introduced to each other. A forgeable type identifier in my opinion is not safe, and I'm pretty sure it'd never make it through committee. However I'm not convinced we need prototype/constructor continuity here.</blockquote></mx-reply>Since this wouldn't be a global registry, it wouldn't matter. Your code defines the relationship between an id and a constructor/prototype on your agent. If your code tries to register the same unique id twice, it should be an error so you can isolate the problem early. If the constructor/prototype on one agent doesn't match the constructor/prototype on another agent, that's fine. In fact, that may even be a value add, since bundlers could potentially tree-shake away prototype methods that aren't used.</td></tr>
  <tr class="msg" id="L14"><td class="ts-cell"><a class="ts" href="#L14" alt="Sun Jan 29 2023 14:42:13 GMT-0800 (Pacific Standard Time)">22:42</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">How is it not a global registry?</td></tr>
  <tr class="msg" id="L15"><td class="ts-cell"><a class="ts" href="#L15" alt="Sun Jan 29 2023 14:42:57 GMT-0800 (Pacific Standard Time)">22:42</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">You're assuming there is a single author to code running in an agent</td></tr>
  <tr class="msg" id="L16"><td class="ts-cell"><a class="ts" href="#L16" alt="Sun Jan 29 2023 14:42:59 GMT-0800 (Pacific Standard Time)">22:42</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><p>All that matters is that a given struct type has the same type identity on multiple Agents, so that each Agent can bind a prototype to that type identity. Producing an instance of a struct type should be possible on any Agent, such that I could do:</p>
<pre><code class="language-js">// main.js
const v1 = new Vector2D(1, 2);
worker.postMessage(v1);
worker.on("message", e =&gt; console.log(e instanceof Vector2D));

// worker.js
const v2 = new Vector2D(3, 4);
remotePort.postMessage(v1);
remotePort.on("message", e =&gt; console.log(e instanceof Vector2D));
</code></pre>
</td></tr>
  <tr class="msg" id="L17"><td class="ts-cell"><a class="ts" href="#L17" alt="Sun Jan 29 2023 14:43:13 GMT-0800 (Pacific Standard Time)">22:43</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">And a single author to code running in communicating agents</td></tr>
  <tr class="msg" id="L18"><td class="ts-cell"><a class="ts" href="#L18" alt="Sun Jan 29 2023 14:43:29 GMT-0800 (Pacific Standard Time)">22:43</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> How is it not a global registry?</blockquote></mx-reply>I don't understand. Each Agent would have an independent registry mapping a type identity to a prototype.</td></tr>
  <tr class="msg" id="L19"><td class="ts-cell"><a class="ts" href="#L19" alt="Sun Jan 29 2023 14:44:25 GMT-0800 (Pacific Standard Time)">22:44</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> You're assuming there is a single author to code running in an agent</blockquote></mx-reply>I'm assuming that if you want to consistently use the same data in multiple agents, with the same underling behavior, then you should use a consistent definition.</td></tr>
  <tr class="msg" id="L20"><td class="ts-cell"><a class="ts" href="#L20" alt="Sun Jan 29 2023 14:44:50 GMT-0800 (Pacific Standard Time)">22:44</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> <p>All that matters is that a given struct type has the same type identity on multiple Agents, so that each Agent can bind a prototype to that type identity. Producing an instance of a struct type should be possible on any Agent, such that I could do:</p>
<pre><code class="language-js">// main.js
const v1 = new Vector2D(1, 2);
worker.postMessage(v1);
worker.on("message", e =&gt; console.log(e instanceof Vector2D));

// worker.js
const v2 = new Vector2D(3, 4);
remotePort.postMessage(v1);
remotePort.on("message", e =&gt; console.log(e instanceof Vector2D));
</code></pre>
</blockquote></mx-reply>Do you expect these console logs to print true or false?</td></tr>
  <tr class="msg" id="L21"><td class="ts-cell"><a class="ts" href="#L21" alt="Sun Jan 29 2023 14:44:59 GMT-0800 (Pacific Standard Time)">22:44</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">I expect them to print <code>true</code>.</td></tr>
  <tr class="msg" id="L22"><td class="ts-cell"><a class="ts" href="#L22" alt="Sun Jan 29 2023 14:45:55 GMT-0800 (Pacific Standard Time)">22:45</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">Then you expect continuity of constructor / prototype across agents</td></tr>
  <tr class="msg" id="L23"><td class="ts-cell"><a class="ts" href="#L23" alt="Sun Jan 29 2023 14:45:57 GMT-0800 (Pacific Standard Time)">22:45</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">If both the main thread and worker register their version of <code>Vector2D.prototype</code> for the same type identity, then creating those structs on either side and sending them to the other side should be consistent.</td></tr>
  <tr class="msg" id="L24"><td class="ts-cell"><a class="ts" href="#L24" alt="Sun Jan 29 2023 14:46:38 GMT-0800 (Pacific Standard Time)">22:46</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Then you expect continuity of constructor / prototype across agents</blockquote></mx-reply>No. I would <em>recommend</em> continuity of the prototype across agents. Constructor doesn't actually matter.</td></tr>
  <tr class="msg" id="L25"><td class="ts-cell"><a class="ts" href="#L25" alt="Sun Jan 29 2023 14:46:57 GMT-0800 (Pacific Standard Time)">22:46</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">As I said, a bundler could potentially tree-shake away prototype methods on either side based on use, and it should still work.</td></tr>
  <tr class="msg" id="L26"><td class="ts-cell"><a class="ts" href="#L26" alt="Sun Jan 29 2023 14:47:21 GMT-0800 (Pacific Standard Time)">22:47</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> I don't understand. Each Agent would have an independent registry mapping a type identity to a prototype.</blockquote></mx-reply>Yes that we agree on. The question is who generates the key of that mapping. If it's user controlled, you have code running in an agent that can interfere with other code running in the same agent.</td></tr>
  <tr class="msg" id="L27"><td class="ts-cell"><a class="ts" href="#L27" alt="Sun Jan 29 2023 14:50:04 GMT-0800 (Pacific Standard Time)">22:50</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> No. I would <em>recommend</em> continuity of the prototype across agents. Constructor doesn't actually matter.</blockquote></mx-reply>By continuity I mean recognition of the prototype objects identity. It doesn't need to be the same in multiple agents, obviously, but an object of the type registered in agent1 and sent to agent2 is expected to have the same prototype as an object of the "same type" created in agent2. I am not convinced we need that</td></tr>
  <tr class="msg" id="L28"><td class="ts-cell"><a class="ts" href="#L28" alt="Sun Jan 29 2023 14:51:32 GMT-0800 (Pacific Standard Time)">22:51</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">I believe we could get away with duck typing here</td></tr>
  <tr class="msg" id="L29"><td class="ts-cell"><a class="ts" href="#L29" alt="Sun Jan 29 2023 14:52:28 GMT-0800 (Pacific Standard Time)">22:52</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><p>Basically, imagine this:</p>
<ul>
<li>A Struct Type has a type identity (be it system or user produced).</li>
<li>A Struct instance has a private slot containing that type identity.</li>
<li>An Agent has a mapping of type identity to a prototype.</li>
<li>Agent A registers a Struct type (<code>Foo</code>) for a given type identity and a prototype defined in a realm in Agent A.</li>
<li>Agent B registers a Struct type (<code>Foo</code>) for the same type identity and a prototype defined in a realm in Agent B.</li>
<li>Agent A constructs an instance of Agent A's struct type <code>Foo</code>, sends it to Agent B.</li>
<li>Agent B receives the struct value. When Agent B performs ToObject on the struct value, it looks up the type identity in its internal slot in Agent B's registry to find the prototype.</li>
<li>Agent B constructs an instance of Agent B's struct type <code>Foo</code>, sends it to Agent A.</li>
<li>Agent A receives the struct value. When Agent A performs ToObject on the struct value, it looks up the type identity in its internal slot in Agent A's registry to find the prototype.</li>
</ul>
</td></tr>
  <tr class="msg" id="L30"><td class="ts-cell"><a class="ts" href="#L30" alt="Sun Jan 29 2023 14:53:40 GMT-0800 (Pacific Standard Time)">22:53</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">The type identity we transfer from A to B, or vise versa, could also encode the expected shape of the struct type. That way, if Agent A and Agent B disagree on the shape associated with the type identity, that error would be thrown on prototype lookup in ToObject.</td></tr>
  <tr class="msg" id="L31"><td class="ts-cell"><a class="ts" href="#L31" alt="Sun Jan 29 2023 14:54:15 GMT-0800 (Pacific Standard Time)">22:54</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Neither agent needs to communicate their registry to the other agents, thus no global registry.</td></tr>
  <tr class="msg" id="L32"><td class="ts-cell"><a class="ts" href="#L32" alt="Sun Jan 29 2023 14:55:14 GMT-0800 (Pacific Standard Time)">22:55</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">If Agent A sends a struct value to Agent B that B doesn't have registered, Agent B could still allow access to the data, just not a prototype walk.</td></tr>
  <tr class="msg" id="L33"><td class="ts-cell"><a class="ts" href="#L33" alt="Sun Jan 29 2023 14:57:58 GMT-0800 (Pacific Standard Time)">22:57</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> By continuity I mean recognition of the prototype objects identity. It doesn't need to be the same in multiple agents, obviously, but an object of the type registered in agent1 and sent to agent2 is expected to have the same prototype as an object of the "same type" created in agent2. I am not convinced we need that</blockquote></mx-reply>The prototype shape on each side doesn't matter. Just the type identity. I could have a <code>Foo { x, y, bar() {} }</code> on A and a <code>Baz { x, y, quxx() {} }</code> on B registered to the same type identity. If I create a <code>Foo</code> on A and send it to B, B will see it as a <code>Bar</code>. If I construct a <code>Bar</code> on B and send it to A, A will see it as a <code>Foo</code>.</td></tr>
  <tr class="msg" id="L34"><td class="ts-cell"><a class="ts" href="#L34" alt="Sun Jan 29 2023 14:58:12 GMT-0800 (Pacific Standard Time)">22:58</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">What I care about is consistency in round-tripping.</td></tr>
  <tr class="msg" id="L35"><td class="ts-cell"><a class="ts" href="#L35" alt="Sun Jan 29 2023 14:58:20 GMT-0800 (Pacific Standard Time)">22:58</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">My concern is with regards to who mints the type identity, as that grants the right to register it. A forgeable value allows code that doesn't trust each other to interfere with each other. That code could be running in the same realm. If the type is minted by the engine, how is it recovered by the code.</td></tr>
  <tr class="msg" id="L36"><td class="ts-cell"><a class="ts" href="#L36" alt="Sun Jan 29 2023 14:58:39 GMT-0800 (Pacific Standard Time)">22:58</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">And the <code>Foo</code> vs <code>Bar</code> idea isn't farfetched, bundlers can and do tree shake methods, and can and do rename classes.</td></tr>
  <tr class="msg" id="L37"><td class="ts-cell"><a class="ts" href="#L37" alt="Sun Jan 29 2023 15:00:15 GMT-0800 (Pacific Standard Time)">23:00</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> My concern is with regards to who mints the type identity, as that grants the right to register it. A forgeable value allows code that doesn't trust each other to interfere with each other. That code could be running in the same realm. If the type is minted by the engine, how is it recovered by the code.</blockquote></mx-reply>In the real proposal structs are top-level declarations. Evaluation and registration of structs occurs mostly during initial module loading. Defensive JavaScript does what it always does, today, which is ensure code they trust runs first.</td></tr>
  <tr class="msg" id="L38"><td class="ts-cell"><a class="ts" href="#L38" alt="Sun Jan 29 2023 15:01:02 GMT-0800 (Pacific Standard Time)">23:01</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">Why would a struct decalration be top level? </td></tr>
  <tr class="msg" id="L39"><td class="ts-cell"><a class="ts" href="#L39" alt="Sun Jan 29 2023 15:01:05 GMT-0800 (Pacific Standard Time)">23:01</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">You error on conflicts rather than silently allowing them, so most applications will fail immediately if malicious code tries to forge an identity.</td></tr>
  <tr class="msg" id="L40"><td class="ts-cell"><a class="ts" href="#L40" alt="Sun Jan 29 2023 15:01:15 GMT-0800 (Pacific Standard Time)">23:01</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">And how does that even matter to type identity </td></tr>
  <tr class="msg" id="L41"><td class="ts-cell"><a class="ts" href="#L41" alt="Sun Jan 29 2023 15:01:34 GMT-0800 (Pacific Standard Time)">23:01</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">It would have to be if you want to use module id + offset or something as a default type identity.</td></tr>
  <tr class="msg" id="L42"><td class="ts-cell"><a class="ts" href="#L42" alt="Sun Jan 29 2023 15:02:27 GMT-0800 (Pacific Standard Time)">23:02</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">How would that be compatible with bundlers?</td></tr>
  <tr class="msg" id="L43"><td class="ts-cell"><a class="ts" href="#L43" alt="Sun Jan 29 2023 15:02:29 GMT-0800 (Pacific Standard Time)">23:02</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">If a function can return a <code>struct</code> declaration that produces a different object identity for each function call, there'd be no way to differentiate them.</td></tr>
  <tr class="msg" id="L44"><td class="ts-cell"><a class="ts" href="#L44" alt="Sun Jan 29 2023 15:03:08 GMT-0800 (Pacific Standard Time)">23:03</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> How would that be compatible with bundlers?</blockquote></mx-reply>It isn't, that's why you'd also need a way to override the type identity. But having a working default behavior is also a good idea.</td></tr>
  <tr class="msg" id="L45"><td class="ts-cell"><a class="ts" href="#L45" alt="Sun Jan 29 2023 15:04:10 GMT-0800 (Pacific Standard Time)">23:04</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">I'm just saying. I don't see how you can have an unforgeable type identity generated or derived by the  engine, and have automatic mapping of these types across agents in a way to allows for prototype continuity as you described earlier</td></tr>
  <tr class="msg" id="L46"><td class="ts-cell"><a class="ts" href="#L46" alt="Sun Jan 29 2023 15:05:45 GMT-0800 (Pacific Standard Time)">23:05</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">Specifying the type identity when registering must require an unforgeable value, that obviously must have a stable identity when sent between agents</td></tr>
  <tr class="msg" id="L47"><td class="ts-cell"><a class="ts" href="#L47" alt="Sun Jan 29 2023 15:05:47 GMT-0800 (Pacific Standard Time)">23:05</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">I don't think the type identity being "unforgeable" is important. If you error on an attempted redefinition, and those errors occur during application startup, then we do what we always do and run code we rely on first.</td></tr>
  <tr class="msg" id="L48"><td class="ts-cell"><a class="ts" href="#L48" alt="Sun Jan 29 2023 15:07:06 GMT-0800 (Pacific Standard Time)">23:07</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Each struct type needs a type identity. For the bundler case, you could supply one. For the "I'm just loading the same module from the same path in the main thread and the worker" case, you could rely on module id and source text offset within the module as a stable identity.</td></tr>
  <tr class="msg" id="L49"><td class="ts-cell"><a class="ts" href="#L49" alt="Sun Jan 29 2023 15:07:17 GMT-0800 (Pacific Standard Time)">23:07</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">A forgeable value will not be acceptable. An error is at best a denial of service for code that doesn't trust each other</td></tr>
  <tr class="msg" id="L50"><td class="ts-cell"><a class="ts" href="#L50" alt="Sun Jan 29 2023 15:08:14 GMT-0800 (Pacific Standard Time)">23:08</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Then the registry need not be per-agent, but per-realm, just like for <code>Number</code>, <code>String</code>, etc. Have untrusted code run in another realm/compartment/etc.</td></tr>
  <tr class="msg" id="L51"><td class="ts-cell"><a class="ts" href="#L51" alt="Sun Jan 29 2023 15:08:46 GMT-0800 (Pacific Standard Time)">23:08</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">Again there can be code that doesn't trust each other in the same realm</td></tr>
  <tr class="msg" id="L52"><td class="ts-cell"><a class="ts" href="#L52" alt="Sun Jan 29 2023 15:09:56 GMT-0800 (Pacific Standard Time)">23:09</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">At best you could have this registry per compartment</td></tr>

</tbody></table></div></div></div>
</body></html>