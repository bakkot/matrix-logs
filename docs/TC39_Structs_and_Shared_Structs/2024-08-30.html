<!DOCTYPE html><html><head>
  <title>TC39 Structs and Shared Structs on 2024-08-30</title>
  <link rel="stylesheet" href="../style.css">
  <script>window.room = "TC39 Structs and Shared Structs";</script><script src="../render-roomlist.js"></script>
  <script src="../logs.js"></script>
</head>
<body><div class="wrapper">
<div class="sidebar">
<div class="title">TC39 Structs and Shared Structs<br>2024-08-30<br><a href="plaintext/">plaintext logs</a></div>
<div class="nav">
<a href="2024-08-29" class="nav-link"><span>prev</span></a>
<span style="float:right">next</span>
</div>
    <div class="all-rooms"><noscript>JavaScript is required to load the channel index, but you can go to <a href="../..">the static index</a> directly.</noscript></div>
<div class="footer"><a href="https://github.com/bakkot/matrix-archive-bot">source on github</a></div>
</div>
<div class="rhs">
<div class="rhs-header">
<span id="error" style="color: red; display:none">error</span>

<input type="text" id="query" size="25" placeholder="Search TC39 Structs and Shared Structs">
<a id="search-submit" class="button icon-link" title="Search">
  <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg>
</a>
</div>

<div class="log"><table id="log-table"><tbody id="log-tbody">

  <tr class="msg" id="L0"><td class="ts-cell"><a class="ts" href="#L0" alt="Thu Aug 29 2024 23:51:33 GMT-0700 (Pacific Daylight Time)">06:51</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> The proposal very nearly avoids the need to support shared-&gt;local edges. The incremental cost of having to overhaul GC is significantly larger than the incremental benefits for the few use cases.</blockquote></mx-reply>Well there is the other problem that currently all JS objects are usable as WeakMap keys, and that some libraries rely on that to hold true, possibly some that never attempt to access the fields of the object. If we're talking about shared structs being a drop-in replacement for class instances in some cases, I'd argue we need to uphold that current property of the language.</td></tr>
  <tr class="msg" id="L1"><td class="ts-cell"><a class="ts" href="#L1" alt="Fri Aug 30 2024 08:55:19 GMT-0700 (Pacific Daylight Time)">15:55</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@iain:mozilla.org">iain</span>&gt;</div></td><td class="msg-cell">I think everybody agrees that in the long run it would be good to have shared structs that can be used as weakmap keys. My argument is that in terms of the actual implementation effort, supporting shared-to-local edges (which is required to implement weakmaps that don't leak) is a major implementation challenge (like, 1/3 to 1/2 of the overall proposal?). The new capabilities that it unlocks are relatively small (compared to the overall proposal). So the question is whether it is better to ship a complete version of shared structs in N years, or a more restricted version in N/2 years followed by a complete version N/2 years later.</td></tr>
  <tr class="msg" id="L2"><td class="ts-cell"><a class="ts" href="#L2" alt="Fri Aug 30 2024 08:59:05 GMT-0700 (Pacific Daylight Time)">15:59</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@iain:mozilla.org">iain</span>&gt;</div></td><td class="msg-cell">I also expect that getting implementation feedback from more than one engine before locking in the final proposal will lead to a better end result.</td></tr>
  <tr class="msg" id="L3"><td class="ts-cell"><a class="ts" href="#L3" alt="Fri Aug 30 2024 09:22:43 GMT-0700 (Pacific Daylight Time)">16:22</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">Didn't V8 also initially consider banning shared to local edges? Do we know more about what led V8 to change their minds?</td></tr>
  <tr class="msg" id="L4"><td class="ts-cell"><a class="ts" href="#L4" alt="Fri Aug 30 2024 09:28:03 GMT-0700 (Pacific Daylight Time)">16:28</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@iain:mozilla.org">iain</span>&gt;</div></td><td class="msg-cell">Sometimes you want to associate some necessarily local data (eg an event handler, a DOM node) with a shared struct.</td></tr>
  <tr class="msg" id="L5"><td class="ts-cell"><a class="ts" href="#L5" alt="Fri Aug 30 2024 09:29:10 GMT-0700 (Pacific Daylight Time)">16:29</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">are you saying, we could support those edges, just not for WeakMaps?</td></tr>
  <tr class="msg" id="L6"><td class="ts-cell"><a class="ts" href="#L6" alt="Fri Aug 30 2024 09:33:55 GMT-0700 (Pacific Daylight Time)">16:33</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@iain:mozilla.org">iain</span>&gt;</div></td><td class="msg-cell">V8 isn't proposing unrestricted shared to local edges. But putting shared structs in weak maps ends up in a similar situation with respect to cycles through the shared space.</td></tr>
  <tr class="msg" id="L7"><td class="ts-cell"><a class="ts" href="#L7" alt="Fri Aug 30 2024 09:35:26 GMT-0700 (Pacific Daylight Time)">16:35</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@iain:mozilla.org">iain</span>&gt;</div></td><td class="msg-cell">Eg if you have two shared structs and two workers, and each worker has a weakmap with one shared struct as a key and the other as the corresponding value, then how do you collect that?</td></tr>
  <tr class="msg" id="L8"><td class="ts-cell"><a class="ts" href="#L8" alt="Fri Aug 30 2024 09:38:58 GMT-0700 (Pacific Daylight Time)">16:38</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@iain:mozilla.org">iain</span>&gt;</div></td><td class="msg-cell">The "no shared to local edges" principle, if robustly enforced, means that you can do local collections without having to coordinate with anybody else. Once you break it, then you can have cycles that (as far as anybody can tell) require you to stop the world occasionally to avoid leaking memory.</td></tr>
  <tr class="msg" id="L9"><td class="ts-cell"><a class="ts" href="#L9" alt="Fri Aug 30 2024 09:40:01 GMT-0700 (Pacific Daylight Time)">16:40</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">oh I see. Yeah, if we want to restrict those edges, then restricting weakmap keys is part of it. Seems reasonable</td></tr>
  <tr class="msg" id="L10"><td class="ts-cell"><a class="ts" href="#L10" alt="Fri Aug 30 2024 11:16:30 GMT-0700 (Pacific Daylight Time)">18:16</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-6" title="@ljharb:matrix.org">ljharb</span>&gt;</div></td><td class="msg-cell">having an object that you can't store in a weakmap seems like a nonstarter tho</td></tr>
  <tr class="msg" id="L11"><td class="ts-cell"><a class="ts" href="#L11" alt="Fri Aug 30 2024 11:20:07 GMT-0700 (Pacific Daylight Time)">18:20</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@iain:mozilla.org">iain</span>&gt;</div></td><td class="msg-cell">Shared structs are going to be weird in all sorts of ways. Why is this specific restriction a non-starter (compared to, say, not being able to store references to local objects)?</td></tr>
  <tr class="msg" id="L12"><td class="ts-cell"><a class="ts" href="#L12" alt="Fri Aug 30 2024 11:24:02 GMT-0700 (Pacific Daylight Time)">18:24</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@iain:mozilla.org">iain</span>&gt;</div></td><td class="msg-cell">I reiterate that from an implementation perspective this is genuinely a major additional effort to implement well, on the rough order of magnitude as the rest of the proposal put together.</td></tr>
  <tr class="msg" id="L13"><td class="ts-cell"><a class="ts" href="#L13" alt="Fri Aug 30 2024 11:25:39 GMT-0700 (Pacific Daylight Time)">18:25</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@iain:mozilla.org">iain</span>&gt;</div></td><td class="msg-cell">(It can be implemented badly with less effort, but there are significant web-compat concerns there.)</td></tr>
  <tr class="msg" id="L14"><td class="ts-cell"><a class="ts" href="#L14" alt="Fri Aug 30 2024 11:28:04 GMT-0700 (Pacific Daylight Time)">18:28</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">I there a middle ground where collecting non cyclic shared-&gt;local edges created by weakmaps would not cause significantly more implementation work? I think it's totally acceptable for some non common cases to leak at first</td></tr>
  <tr class="msg" id="L15"><td class="ts-cell"><a class="ts" href="#L15" alt="Fri Aug 30 2024 11:29:37 GMT-0700 (Pacific Daylight Time)">18:29</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mhofman:matrix.org">Mathieu Hofman</span>&gt;</div></td><td class="msg-cell">The concern with not being able to blindly put a <code>typeof foo === 'object' &amp;&amp; foo !== null</code> in a WeakMap is a compat concern when an app gradually adopts shared structs</td></tr>
  <tr class="msg" id="L16"><td class="ts-cell"><a class="ts" href="#L16" alt="Fri Aug 30 2024 11:32:54 GMT-0700 (Pacific Daylight Time)">18:32</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@iain:mozilla.org">iain</span>&gt;</div></td><td class="msg-cell">I think that roughly works out to be "WeakMap as a way to implement main-thread TBS" in the V8 design doc <a href="https://docs.google.com/document/d/1GoIWdfsKuKb0PS3gSF8b1U0RoHs5ALPzXAMx-QPHHNg/edit#heading=h.pbq4b3s54rlj">here</a>. I would have to double-check with our GC experts, but I think that's less effort. My concern there is webcompat: if one browser implements that, and another browser implements full cycle collection, then you're going to have websites that leak in one browser but not the other.</td></tr>
  <tr class="msg" id="L17"><td class="ts-cell"><a class="ts" href="#L17" alt="Fri Aug 30 2024 11:33:44 GMT-0700 (Pacific Daylight Time)">18:33</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@iain:mozilla.org">iain</span>&gt;</div></td><td class="msg-cell">So in practice there's no difference between that middle ground and the full requirement.</td></tr>
  <tr class="msg" id="L18"><td class="ts-cell"><a class="ts" href="#L18" alt="Fri Aug 30 2024 11:34:54 GMT-0700 (Pacific Daylight Time)">18:34</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@iain:mozilla.org">iain</span>&gt;</div></td><td class="msg-cell">I acknowledge that this makes incremental adoption harder.</td></tr>
  <tr class="msg" id="L19"><td class="ts-cell"><a class="ts" href="#L19" alt="Fri Aug 30 2024 11:35:41 GMT-0700 (Pacific Daylight Time)">18:35</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@iain:mozilla.org">iain</span>&gt;</div></td><td class="msg-cell">I am not convinced that it makes incremental adoption so much harder that it outweighs the benefit of being able to ship something sooner.</td></tr>
  <tr class="msg" id="L20"><td class="ts-cell"><a class="ts" href="#L20" alt="Fri Aug 30 2024 11:36:43 GMT-0700 (Pacific Daylight Time)">18:36</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@iain:mozilla.org">iain</span>&gt;</div></td><td class="msg-cell">To be clear, I'm also not convinced of the converse! I just want to make sure that we're all clear on the decision we're making.</td></tr>
  <tr class="msg" id="L21"><td class="ts-cell"><a class="ts" href="#L21" alt="Fri Aug 30 2024 12:04:10 GMT-0700 (Pacific Daylight Time)">19:04</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-6" title="@ljharb:matrix.org">ljharb</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Shared structs are going to be weird in all sorts of ways. Why is this specific restriction a non-starter (compared to, say, not being able to store references to local objects)?</blockquote></mx-reply><p>a new thing accepting a subset of values is fine. an existing thing suddenly changing its current invariants (all objects can be weakly held) is not. this would apply to weakmap, weakset, weakref, and finalizationregistry - that's a lot of things to have changed invariants.</p>
<p>if browsers were OK with a <code>isWeakable</code> predicate - proposed for precisely this problem when non-global symbols became allowed - then it'd have been OK to change, but sans that predicate, it's not</p>
</td></tr>
  <tr class="msg" id="L22"><td class="ts-cell"><a class="ts" href="#L22" alt="Fri Aug 30 2024 12:08:54 GMT-0700 (Pacific Daylight Time)">19:08</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-7" title="@devsnek:matrix.org">snek</span>&gt;</div></td><td class="msg-cell"><code>let isWeakable = (o) =&gt; try { new WeakMap([o, 1]); return true; } catch { return false; }</code></td></tr>
  <tr class="msg" id="L23"><td class="ts-cell"><a class="ts" href="#L23" alt="Fri Aug 30 2024 12:12:18 GMT-0700 (Pacific Daylight Time)">19:12</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-6" title="@ljharb:matrix.org">ljharb</span>&gt;</div></td><td class="msg-cell">indeed, that'd be a polyfill for it :-) but unless it's built in, the ecosystem won't use it, and there'll be tons of checks like <code>Object(o) === o</code> or <code>o &amp;&amp; typeof o === 'object'</code> that naively check for a subset of weakable values, that will break if a non-weakable object suddenly gets passed into something</td></tr>
  <tr class="msg" id="L24"><td class="ts-cell"><a class="ts" href="#L24" alt="Fri Aug 30 2024 12:56:23 GMT-0700 (Pacific Daylight Time)">19:56</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">I'm still very concerned that shipping shared structs "fast" by dropping agent/realm-local prototypes and not supporting WeakMap is going to significantly hamper adoption for the teams actually requesting this feature. If I don't have the ability to define behavior on the prototype, then I would need to create a membrane over shared data to be able to incrementally adopt. If I can't put the shared structs in a WeakMap to ensure I only ever produce a single proxy for a given shared struct, then I have to put them in a Map. If I put them in a Map, they will leak. If I don't want them to leak, I need to force all of my API consumers to perform manual memory management, which would be a brand new requirement for <em>all</em> API consumers, so we probably just end up leaking memory. That is not a great outcome.</td></tr>
  <tr class="msg" id="L25"><td class="ts-cell"><a class="ts" href="#L25" alt="Fri Aug 30 2024 12:58:27 GMT-0700 (Pacific Daylight Time)">19:58</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">I would be happy with a scenario where A) we get agent-local prototypes, but B) we can't have shared structs as WeakMap keys, since for (A) those prototypes would probably never be collected anyways since they will be retained by the shared struct constructors and the module graph.</td></tr>
  <tr class="msg" id="L26"><td class="ts-cell"><a class="ts" href="#L26" alt="Fri Aug 30 2024 14:19:56 GMT-0700 (Pacific Daylight Time)">21:19</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">Actually, having prototypes but not WeakMap support is still a problem. Since prototypes would give us behavior, we wouldn't need a membrane for Nodes, but we still need one for <code>NodeArray</code>. A TypeScript <code>NodeArray</code> is essentially an <code>Array</code> with extra <code>pos</code>/<code>end</code> properties attached. Unfortunately, the <code>SharedArray</code> type introduced in the shared structs dev trial doesn't allow for additional (non-indexed) properties. The only way to handle that transparently/incrementally would still be via a <code>Proxy</code>, which means we still have a potential memory leak if we don't have WeakMap.</td></tr>
  <tr class="msg" id="L27"><td class="ts-cell"><a class="ts" href="#L27" alt="Fri Aug 30 2024 14:24:17 GMT-0700 (Pacific Daylight Time)">21:24</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><p>If we have prototypes and WeakMaps, something like <code>SourceFile</code> could have a <code>statements</code> getter that could return a <code>Proxy</code> for a struct like</p>
<pre><code class="language-js">shared struct NodeArrayData {
  pos; // number
  end; // number
  items; // SharedArray&lt;Node&gt;
}
</code></pre>
<p>where the proxy emulates <code>NodeArray</code> and redirects numeric indexed access to <code>items</code>. The performance would be abysmal though.</p>
</td></tr>
  <tr class="msg" id="L28"><td class="ts-cell"><a class="ts" href="#L28" alt="Fri Aug 30 2024 14:26:03 GMT-0700 (Pacific Daylight Time)">21:26</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">I experimented with just creating a shared struct with properties like <code>{ length; "0"; "1"; }</code>, but the dev trial had major perf issues with struct fields whose names were integer indexes.</td></tr>
  <tr class="msg" id="L29"><td class="ts-cell"><a class="ts" href="#L29" alt="Fri Aug 30 2024 14:40:05 GMT-0700 (Pacific Daylight Time)">21:40</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell"><p>If a <code>SharedArray</code> were essentially like a <code>shared struct</code>, maybe we could leverage subclassing somehow?</p>
<pre><code class="language-js">shared struct NodeArray extends SharedArray {
  pos = -1;
  end = -1;
  constructor(length) {
    super(length);
  }
}
</code></pre>
</td></tr>
  <tr class="msg" id="L30"><td class="ts-cell"><a class="ts" href="#L30" alt="Fri Aug 30 2024 14:41:30 GMT-0700 (Pacific Daylight Time)">21:41</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@rbuckton:matrix.org">rbuckton</span>&gt;</div></td><td class="msg-cell">If we can get that to work, then my need for WeakMap support drops significantly so long as we have prototypes.</td></tr>

</tbody></table></div></div></div>
</body></html>