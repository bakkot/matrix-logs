2022-05-02
[10:39:56.0420] <legendecas>
> <@legendecas:matrix.org> That will be great. I'd be happy to volunteer to work on test262 :D

Just submitted the initial setup https://github.com/tc39/test262/pull/3512


2022-05-04
[10:43:05.0879] <rbuckton>
I was looking at the outline for parameter decorators mentioned here: https://github.com/tc39/proposal-decorators/blob/master/EXTENSIONS.md#parameter-decorators-and-annotations, and was thinking about the shape of the context object. I think there are a few things we could add aside from `kind`:

```ts
interface ParameterDecoratorContext {
  kind: "parameter";
  index: number; // ordinal position of parameter
  name?: string; // name if an Identifier, `undefined` if a binding pattern
  rest: boolean; // indicates a rest parameter (i.e., `...`)
  parent:
    | {
        kind: "function";
        name?: string;
      }
    | {
        kind: "method" | "getter" | "setter";
        name: string | symbol;
        private: boolean;
        static: boolean;
        parent: // may be other parents in the future such as `struct`, `object`, etc.
          | {
              kind: "class";
              name?: string;
            }
      };
  // phase: "function" runs initializers at the start of the function body
  addInitializer(cb: () => unknown, phase?: "class" | "static" | "instance" | "function"): void;
}
```
The above also incorporates the parent context idea from https://github.com/tc39/proposal-decorators/issues/466

[10:46:08.0407] <rbuckton>
TS parameter decorators get the parameter index which is necessary for DI, RTTI, and RTTC, so that seems a minimum requirement for a parameter context.

[11:41:33.0595] <Mathieu Hofman>
index and a way to get the context / add an initializer to the method/function so that the parameter and function/method decorators can cooperate would be my requirements

[16:35:41.0406] <rbuckton>
I imagine "add an initializer" would match the behavior already proposed in EXTENSIONS.md and be somewhat similar to fields.

[16:36:37.0717] <rbuckton>
We might need to bifurcate `ParameterDecoratorContext` into `kind: "parameter"` and `kind: "rest-parameter"` (as opposed to a `rest: boolean` property on the context), because rest parameters can't have initializers.

[16:38:17.0794] <rbuckton>
I'm not sure what you mean by "get the context" however. Would that be similar to the opaque metadata context object proposal?

[16:40:11.0987] <Mathieu Hofman>
But you should still be able to add an initializer to the function/method definition, no? so it'd just be a runtime error to add an initializer to the rest param?

[16:40:23.0484] <Mathieu Hofman>
 * But you should still be able to add an initializer to the function/method definition, no? so it'd just be a runtime error to add an initializer to the rest param?

[16:41:21.0830] <Mathieu Hofman>
Right, I was referring to the opaque metadata, be able to reference the opaque object of the function/method

[16:44:36.0905] <Mathieu Hofman>
As I mentioned, I'm mostly interested in runtime checks, and would want to be able to express things like

```
const foo = (@string name, @array(number) ...values) => {}
```

[16:54:51.0806] <Mathieu Hofman>
But also be able to add runtime metadata so that I can do things like:
```
import { remotable, awaited } from 'rpc-lib';

const foo = remotable({
  foo: (@awaited thing) => {
    if (myCollection.has(thing)) {
      ...
    } else {
      ...
    }
  }
});
```

Where the `remotable` helper (which could be written as an object literal decorator) would be able to get the annotations for the `foo` method on the object it received, and (to really simplify) build a new object with a new `foo` method that will implicitly await on the first argument.



2022-05-05
[17:01:40.0373] <Mathieu Hofman>
So in the first case of runtime checks, I need the param decorator to be able to modify the function in such a way that param validation can run when the function is invoked (hopefully without requiring to decorate the function itself).

[17:01:41.0842] <Mathieu Hofman>
And in the second case, I need to annotate the object literal's method parameters in such a way that a related helper can read the annotations starting from the object itself

[18:33:50.0974] <rbuckton>
> <@mhofman:matrix.org> But you should still be able to add an initializer to the function/method definition, no? so it'd just be a runtime error to add an initializer to the rest param?

`addInitializer` (normal and rest params) would be for adding initializers in general, while returning an initializer would be for piping through the passed argument (non rest params). So `addInitializer` would probably be what you would use in this case. 

[18:38:51.0551] <rbuckton>
In other words, you'd write the `string` decorator above like this:

```js
const string = (_, { index, addInitializer }) => {
  addInitializer((...args) => {
    if (typeof args[index] !== "string") throw new TypeError();
  });
};
```

[18:39:10.0564] <rbuckton>
* In other words, you'd write the decorators above like this:

```js
const string = (_, { index, addInitializer }) => {
  addInitializer((...args) => {
    if (typeof args[index] !== "string") throw new TypeError();
  });
};
```

[18:39:52.0769] <rbuckton>
* In other words, you'd write the `string` decorator above like this:

```js
const string = (_, { index, addInitializer }) => {
  addInitializer((...args) => {
    if (typeof args[index] !== "string") throw new TypeError();
  });
};
```

