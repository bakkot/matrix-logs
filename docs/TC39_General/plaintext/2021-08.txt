2021-08-01
[20:47:37.0468] <bakkot>
Domenic: tracking that specifically at https://github.com/tc39/ecmarkup/issues/116, though it's not my highest priority


2021-08-02

2021-08-03

2021-08-04
[11:52:56.0139] <sideshowbarker>
help with https://github.com/mdn/content/issues/7593 would be much welcome

[11:53:27.0800] <sideshowbarker>
 * help with https://github.com/mdn/content/issues/7592 would be much welcome

[11:54:34.0062] <sideshowbarker>
‚Ä¶even if just a comment added to this issue (short of a patch/PR)

[11:55:30.0002] <jmdyck>
ES doesn't define ServiceWorker.

[11:57:10.0755] <jmdyck>
Though there might be people here who could help anyway.

[11:58:16.0779] <sideshowbarker>
jmdyck: sorry yeah I initially pasted in the wrong URL ‚Äî the right one is actually https://github.com/mdn/content/issues/7592

[11:59:04.0440] <jmdyck>
Ah! I didn't notice the change.

[11:59:46.0046] <bakkot>
sideshowbarker: commented

[12:00:30.0693] <bakkot>
shu: do you know if there is an existing bug for v8 failing to throw on `new BigInt64Array( new Int32Array(0) )`

[12:00:43.0432] <bakkot>
it does (correctly) when `s/0/1/`

[12:01:01.0982] <bakkot>
I guess I'll just open one and let it get triaged

[12:02:47.0634] <shu>
no idea, the list of TA-related historical issues that're technically non-compliant with ecma262 is large and forboding, and mostly not worth the risk to try to fix

[12:03:18.0307] <shu>
though BigInt64Array is a new type...

[12:05:04.0845] <bakkot>
yeah, this is specifically an error which should happen when converting to (or from) one of the new Big* arrays, not a historical thing

[12:11:22.0143] <shu>
yeah, file it and assign it to me

[12:13:00.0975] <bakkot>
lol I get a 500 when trying to open an issue

[12:13:06.0337] <bakkot>
where do I file bugs in the bugtracker

[12:14:26.0782] <shu>
it... wfm?

[12:14:53.0011] <bakkot>
worked this time: https://bugs.chromium.org/p/v8/issues/detail?id=12052

[12:15:11.0926] <bakkot>
I can't assign to you because I still don't have a Chromium account

[12:30:03.0779] <shu>
wait what is [[ContentType]]

[12:30:19.0158] <shu>
it's just to distinguish bigint or not bigint?

[12:30:28.0809] <bakkot>
yup

[12:31:18.0009] <shu>
hm, would've been clearer to encode that directly by casing on the element type rather than a field named [[ContentType]]

[12:39:56.0799] <bakkot>
possibly even in an AO?

[12:40:00.0165] <bakkot>
PRs welcome :P

[12:47:14.0045] <jmdyck>
origin story: https://github.com/tc39/ecma262/pull/1515#discussion_r305633166


2021-08-05
[16:18:38.0882] <rkirsling>
it appears the Temporal.Duration polyfill and spec are out of alignment on the case `new Temporal.Duration().toString({ fractionalSecondDigits: 2})`

[16:18:42.0913] <rkirsling>
 * it appears the Temporal.Duration polyfill and spec are out of alignment on the case `new Temporal.Duration().toString({ fractionalSecondDigits: 2 })`

[16:21:00.0603] <rkirsling>
 * it appears the Temporal.Duration polyfill and spec are out of alignment on the case `new Temporal.Duration().toString({ fractionalSecondDigits: 2 })` (_where 2 can be anything between 1 and 9_)

[16:37:14.0320] <rkirsling>
(in particular, step 13 of https://tc39.es/proposal-temporal/#sec-temporal-temporaldurationtostring is super unambiguous)

[16:39:24.0834] <ptomato>
that looks like a spec bug. probably we missed that case when adding fractionalSecondDigits. if you file an issue for it, I'll try and include it in the presentation for August TC39 plenary

[16:48:19.0897] <rkirsling>
ah okay


2021-08-06
[17:02:55.0763] <rkirsling>
https://github.com/tc39/proposal-temporal/issues/1697

[11:01:25.0023] <jschoi>
Does anyone know of any way to view the most popular NPM packages that depend on a specific NPM package, other than downloading a Gzemnid dataset? (npmjs.com can sort packages by popularity in its name search, and it can list the dependees of a specific package, but it can‚Äôt do both at the same time.)

[11:08:58.0116] <jschoi>
(Use case: Trying to find maximally impactful real-world examples of a library‚Äôs usage in the wild.)

[11:09:33.0621] <jschoi>
* (Use case: Trying to find maximally impactful real-world examples of a library‚Äôs usage in the wild, while writing a proposal explainer.)

[11:11:48.0316] <jschoi>
Also, I might be confused, but has https://gzemnid.nodejs.org/datasets/ not been updated since 2019?

[13:14:11.0512] <Justin Ridgewell>
Hacker News is linking to a new IETF for UUID formats: https://datatracker.ietf.org/doc/html/draft-peabody-dispatch-new-uuid-format

[13:30:50.0686] <ryzokuken>
Looks pretty neat! UUID v6 perhaps? 

[13:31:18.0696] <ryzokuken>
(in the meantime, I still find 99% of UUID usages in the wild being v4)

[13:31:30.0934] <ryzokuken>
* (in the meantime, I still find 95% or more of UUID usages in the wild being v4)

[13:38:23.0588] <ptomato>
is "the integral part of _x_", where _x_ is a mathematical value, valid ecma262-speak?

[13:39:47.0310] <ptomato>
the only instance I can find in the current text is in the prose description of Math.trunc

[13:40:28.0283] <ptomato>
similarly, there are no references to "the fractional part of _x_"

[15:11:50.0544] <jmdyck>
ptomato: I think you'd be better off using floor(x) and (x modulo 1), assuming that the semantics for x<0 are what you want.

[15:13:24.0213] <jmdyck>
If they're *not* what you want, then you might have to define it, rather than just saying "the integral/fractional part". 

[15:19:35.0674] <ptomato>
they are not, which is how I landed on this question

[15:19:51.0777] <ptomato>
I've currently got something like "Let _y_ be the mathematical value whose sign is the sign of _x_ and whose magnitude is _x_ modulo 1"

[15:20:07.0261] <ptomato>
for the fractional part

[15:20:29.0598] <ptomato>
which is a mouthful!

[15:22:36.0854] <jmdyck>
I don't even think it'

[15:22:41.0973] <jmdyck>
 * I don't even think it's what you want.

[15:23:37.0676] <jmdyck>
e.g. -3.1 modulo 1 is 0.9, so you'd be saying that the fractional part of -3.1 is -0.9

[15:25:47.0448] <ptomato>
ah. the magnitude should be abs(_x_) modulo 1, then

[15:49:25.0251] <TabAtkins>
Alternately, "Let y be the mathematical value resulting from x - the integral part of x", or however exactly you spec-ese that.


2021-08-07

2021-08-08
[23:32:33.0510] <bakkot>
shu: you may be interested in https://bugzilla.mozilla.org/show_bug.cgi?id=1724618 in the context of proposal-rm-builtin-subclassing

[23:47:58.0455] <bakkot>
and also https://github.com/chakra-core/ChakraCore/issues/6736, https://github.com/Moddable-OpenSource/moddable/issues/680, and https://github.com/oracle/graaljs/issues/488


2021-08-09
[13:14:22.0162] <bakkot>
yulia: I pushed up a handful of minor editorial tweaks to the TLA PR (see https://github.com/tc39/ecma262/pull/2408/commits; my first one was "adopt 545-style structured headers for new AOs", which you can ignore) - can you take a look over those when you get a chance? I think editors are all happy with it now, otherwise

[13:14:42.0975] <bakkot>
No rush though; I'll keep it rebased


2021-08-10
[00:47:02.0081] <yulia>
sure i will look today

[02:04:25.0078] <ryzokuken>
matrix spaces seem to be getting more stable. should we assign a stable alias to the TC39 space and start publicizing the link?

[03:10:52.0216] <yulia>
bakkot: i read through everything, I think it looks good

[03:11:08.0040] <yulia>
I have one question: is there a guidance I can follow on return values? https://github.com/tc39/ecma262/pull/2408/commits/b3e00d294a4fb150197bad80f236815a3de5608c

[03:25:03.0095] <yulia>
this is also adjusted according to anba's comments https://github.com/tc39/ecma262/pull/2267

[09:25:00.0038] <bakkot>
yulia: on returns, the guidance is basically, 1) if the return value isn't going to be consumed, use `Return.` rather than `Return *undefined*`, and conversely, and 2) don't bother with `Return.` as the final step in an AO (unless it would otherwise be empty).

[09:25:46.0935] <bakkot>
we're not 100% consistent with this right now, but we're close, and I'll fix it up in https://github.com/tc39/ecma262/pull/2429 and https://github.com/tc39/ecma262/pull/2397 once TLA is in

[10:36:39.0539] <shu>
bakkot: thanks, and yes, that is dumb

[12:03:52.0230] <Domenic>
Thoughts on whether web APIs should use JS SyntaxError for parsing problems? (Specific API is https://github.com/WICG/urlpattern/.) I see the ES spec uses it for BigInt and JSON.parse, in addition to actual syntax errors.

[12:57:26.0490] <bakkot>
SyntaxError seems like a reasonable choice to me

[12:58:39.0565] <bakkot>
JS also uses it for RegExp, which seems like the nearest cousin here

[13:08:34.0769] <bakkot>
as a bonus, it makes it marginally less awkward to move it into the JS spec if there is ever reason to do so

[13:13:55.0897] <Domenic>
Sigh

[13:19:38.0215] <bakkot>
I am mostly thinking of that in the context of moving structured clone, which it sounded like you were interested in doing

[13:19:49.0335] <bakkot>
and which will be marginally awkward because of the error type differences

[13:19:54.0991] <bakkot>
only very marginally, though


2021-08-11
[02:01:05.0019] <yulia>
moving structured clone sounds like a great idea

[02:51:26.0999] <littledan>
> <@yulia:mozilla.org> moving structured clone sounds like a great idea

I like this idea too. Others opposed it historically, e.g., Mark has expressed opposition recently. I think it would be a complicated negotiation.

[08:47:25.0421] <Domenic>
I mainly just want to stop being on the hook for updating structured clone with new error types/builtins

[08:47:42.0994] <Domenic>
Like temporal objects are just not going to be structured cloneable I guess because I don't have the time to work on that

[08:47:57.0826] <Domenic>
An alternative would be if structured clone was explicitly remembered as a stage 3 cross-cutting concern criteria

[09:00:16.0747] <ptomato>
Domenic: I don't think you are on the hook for structured clone for Temporal objects? it was identified as a concern and there is a pull request for it: https://github.com/tc39/proposal-temporal/issues/548 / https://github.com/whatwg/html/pull/6284

[09:01:05.0019] <Jack Works>
https://github.com/Jack-Works/proposal-serializer

[09:01:16.0558] <Jack Works>
does anyone interested?

[09:01:44.0782] <Jack Works>
this is my try on the bringing user-extensible structured clone in to the language

[09:03:03.0428] <Domenic>
> <@pchimento:igalia.com> Domenic: I don't think you are on the hook for structured clone for Temporal objects? it was identified as a concern and there is a pull request for it: https://github.com/tc39/proposal-temporal/issues/548 / https://github.com/whatwg/html/pull/6284

Oh wow, somehow I totally missed that! Sorry, that's my bad. I was assuming the unfortunate precedent set by AggregateError/error.cause would carry over for temporal, but you did the right thing.

[09:07:00.0121] <littledan>
we haven't written the PR for Record and Tuple structured clone, but it's definitely on our todo list https://github.com/tc39/proposal-record-tuple/issues/45

[09:08:48.0396] <littledan>
Being friendly to contributors is a great way to encourage more involvement and avoid maintainer burnout

[09:11:35.0459] <littledan>
> <@domenicdenicola:matrix.org> Oh wow, somehow I totally missed that! Sorry, that's my bad. I was assuming the unfortunate precedent set by AggregateError/error.cause would carry over for temporal, but you did the right thing.

I don't think there's any particular precedent here; TC39 delegates have been doing a lot of the HTML integration work for recent proposals.

[09:13:26.0940] <littledan>
We're talking about the process for host integration in TC39 proposals at https://github.com/tc39/Reflector/issues/375 (sorry, delegates/IEs only)

[09:31:15.0605] <bakkot>
> I like this idea too. Others opposed it historically, e.g., Mark has expressed opposition recently. I think it would be a complicated negotiation.

shu suggested we might move the algorithm without exposing it directly in 262, at least initially, so it would _just_ be a matter of making it the 262 editors' responsibility to handle ongoing maintenance for the JS parts of it; my hope was that this would alleviate Mark's concerns

[09:45:11.0005] <shu>
yes, the high order bit is to decouple any normative changes to JS wrt structured clone

[10:20:42.0640] <Domenic>
Aww https://github.com/tc39/notes/blob/master/meetings/2020-06/june-4.md#generic-comparison is sad, I didn't realize the spaceship operator worked so poorly in JavaScript. I really like it as a unifying concept.


2021-08-12
[21:34:38.0215] <ljharb>
yeah that was a bummer :-(

[07:40:20.0312] <Hemanth H.M>
Do we still have a chance to resurface it with array-equality? 

[07:41:49.0170] <littledan>
I think there are lots of chances to resurface the spaceship operator, array comparison, etc. For me, the symbol-based protocol which was disconnected from how < etc work was what I didn't like so much, not the spaceship operator itself.

[07:42:28.0646] <littledan>
anyway yes we agreed on Stage 1 for a proposal for array equality tests

[10:25:11.0060] <bakkot>
oh hey, someone actually using Atomics! https://jlongster.com/future-sql-web

[10:56:01.0732] <shu>
ü•≤

[10:56:37.0261] <shu>
"The real magic is the Atomics.wait API. It‚Äôs a beautiful thing." i don't know if i'd call futexes beautiful personally

[11:55:10.0014] <bakkot>
keep in mind this is the opinion of someone who has just implemented sqlite _on top of_ indexdb

[13:23:53.0734] <bradleymeck>
I'm back! Also I still hate @@species

[13:26:12.0461] <bradleymeck>
did a brute force replace of globals to see what node is leaking and can't think of a clean way to not have @@species leak out a mutable vector when calling some builtins

[13:27:21.0008] <bradleymeck>
so, if anyone knows how to safely act like Array.prototype.concat but not call @@species without subclassing Array or mutating the receiver that would be nice

[13:52:17.0072] <bakkot>
proxy the receiver instead of mutating it :P

[14:40:01.0552] <Richard Gibson>
bradleymeck: can you clarify the question? Array.prototype.concat requires getting @@species only when the receiver was initialized by ArrayCreate and getting its constructor returns an Object that is not a cross-realm %Array% intrinsic, but it _requires_ getting @@species in those cases so "act like Array.prototype.concat" would be violated by skipping it.


2021-08-13
[04:01:18.0379] <devsnek>
I don't remember why I removed extending null from the March agenda but perhaps I can bring it to August.

[06:58:20.0253] <jschoi>
New proposal for extending `Math` methods to handle BigInts. https://github.com/js-choi/proposal-bigint-math, https://jschoi.org/21/es-bigint-math/

[06:58:27.0132] <jschoi>
Might present at next meeting for Stage¬†1. Stuck on a couple of questions.

[07:00:09.0309] <jschoi>
1. Should there be any methods that would return Numbers from BigInts, like `Math.sin`? (Trigonometric functions would have to return Numbers, although hyperbolic functions would not.)
2. Should `round`, `floor`, etc. take BigInts, acting as identity functions?
3. Are there any real-use cases for hyperbolic functions on BigInts?

[07:00:43.0170] <jschoi>
 * 1. Should there be any methods that would return Numbers from BigInts, like `Math.sin`? (Trigonometric functions would have to return Numbers, although hyperbolic functions would not.) Answer is currently no.
2. Should `round`, `floor`, etc. take BigInts, acting as identity functions? Answer is currently no.
3. Are there any real-use cases for hyperbolic functions on BigInts? Answer is currently don‚Äôt know but they‚Äôre specified anyway.

[07:05:12.0009] <jschoi>
 * 1. Should there be any methods that would return Numbers from BigInts, like `Math.sin`? (Trigonometric functions would have to return Numbers, although hyperbolic functions would not.) Answer is currently no.
2. Should `round`, `floor`, etc. take BigInts, acting as identity functions? Answer is currently no.
3. Are there any real-use cases for hyperbolic/root/logarithm/irrational functions on BigInts? Answer is currently don‚Äôt know but they‚Äôre specified anyway.
4. If we do extend hyperbolic/root/logarithm/irrational functions to accept BigInts, then should they return BigInts, and if so, how should they be rounded? Answer is currently yes and ‚Äúit‚Äôs ‚Äòimplementation-approximated‚Äô‚Äù.

[07:05:33.0814] <jschoi>
ljharb: You mentioned a few months ago you were interested in such a proposal.

[07:09:02.0869] <jschoi>
 * 1. Should there be any methods that would have to return Numbers from BigInts, like `Math.sin`, which ranges within ¬±1? (Trigonometric functions would have to return Numbers, although hyperbolic functions would not.) Answer is currently no.
2. Should `round`, `floor`, etc. take BigInts, acting as identity functions? Answer is currently no.
3. Are there any real-use cases for hyperbolic/root/logarithm/irrational functions on BigInts? Answer is currently don‚Äôt know but they‚Äôre specified anyway.
4. If we do extend hyperbolic/root/logarithm/irrational functions to accept BigInts, then should they return BigInts, and if so, how should they be rounded? Answer is currently yes and ‚Äúit‚Äôs ‚Äòimplementation-approximated‚Äô‚Äù.

[07:13:26.0763] <jschoi>
 * 1. Should there be any methods that would have to return Numbers from BigInts, like `Math.sin`, which ranges within ¬±1? (Trigonometric functions would have to return Numbers, although hyperbolic functions would not.) Answer is currently no.
2. Should `round`, `floor`, etc. take BigInts, acting as identity functions? Answer is currently no.
3. Are there any real-use cases for hyperbolic/root/logarithm/irrational functions on BigInts? Answer is currently don‚Äôt know but they‚Äôre specified anyway.
4. If we do extend hyperbolic/root/logarithm/irrational functions to accept BigInts, then should they return BigInts, and if so, how should they be rounded? Answer is currently yes and ‚Äúit‚Äôs ‚Äòimplementation-approximated‚Äô‚Äù.
5. What should the variadic `Math.hypot`, `max`, and `min` return when given no BigInt arguments? (Answer: We make new `big` versions of each of them, and we make `bigHypot` return `0`, and `bigMax`/`bigMin` throw a TypeError.

[07:13:28.0292] <bradleymeck>
Richard Gibson: yup, basically want a bunch of intrinsics methods that act like @@species is never anything except what the intrinsic they are directly on the prototype of

[07:13:32.0218] <jschoi>
 * 1. Should there be any methods that would have to return Numbers from BigInts, like `Math.sin`, which ranges within ¬±1? (Trigonometric functions would have to return Numbers, although hyperbolic functions would not.) Answer is currently no.
2. Should `round`, `floor`, etc. take BigInts, acting as identity functions? Answer is currently no.
3. Are there any real-use cases for hyperbolic/root/logarithm/irrational functions on BigInts? Answer is currently don‚Äôt know but they‚Äôre specified anyway.
4. If we do extend hyperbolic/root/logarithm/irrational functions to accept BigInts, then should they return BigInts, and if so, how should they be rounded? Answer is currently yes and ‚Äúit‚Äôs ‚Äòimplementation-approximated‚Äô‚Äù.
5. What should the variadic `Math.hypot`, `max`, and `min` return when given no BigInt arguments? Answer: We make new `big` versions of each of them, and we make `bigHypot` return `0`, and `bigMax`/`bigMin` throw a TypeError.

[07:49:44.0518] <jschoi>
 * 1. Should `round`, `floor`, etc. take BigInts, acting as identity functions? Answer is currently no.
2. Are there any real-use cases for hyperbolic/root/logarithm/irrational functions on BigInts? Answer is currently don‚Äôt know but they‚Äôre specified anyway.
3. If we do extend hyperbolic/root/logarithm/irrational functions to accept BigInts, then should they return BigInts, and if so, how should they be rounded? Answer is currently yes and ‚Äúit‚Äôs ‚Äòimplementation-approximated‚Äô‚Äù.
4. Should trigonometric functions, which generally have small domains and ranges, return Numbers when given BigInts? Answer is currently no.
5. What should the variadic `Math.hypot`, `max`, and `min` return when given no BigInt arguments? Answer: We make new `big` versions of each of them, and we make `bigHypot` return `0`, and `bigMax`/`bigMin` throw a TypeError.

[07:51:11.0523] <jschoi>
 * 1. Should `round`, `floor`, etc. take BigInts, acting as identity functions? Answer is currently no.
2. Are there any real-use cases for hyperbolic/root/logarithm functions on BigInts? Answer is currently ‚Äúdon‚Äôt know‚Äù but they‚Äôre specified anyway.
3. If we do extend hyperbolic/root/logarithm/irrational functions to accept BigInts, then should they return BigInts, and if so, how should they be rounded? Answer is currently yes and ‚Äúit‚Äôs ‚Äòimplementation-approximated‚Äô‚Äù.
4. Should trigonometric functions, which generally have small domains and ranges, return Numbers when given BigInts? Answer is currently no.
5. What should the variadic `Math.hypot`, `max`, and `min` return when given no BigInt arguments? Answer: We make new `big` versions of each of them, and we make `bigHypot` return `0`, and `bigMax`/`bigMin` throw a TypeError.

[07:52:42.0098] <jschoi>
 * 1. Should `round`, `floor`, etc. take BigInts, acting as identity functions? Answer is currently no.
2. Are there any real-use cases for hyperbolic/root/logarithm functions on BigInts? Answer is currently ‚Äúdon‚Äôt know‚Äù but they‚Äôre specified anyway.
3. If we do extend hyperbolic/root/logarithm/irrational functions to accept BigInts, then should they return BigInts, and if so, how should they be rounded? Answer is currently yes and ‚Äúit‚Äôs ‚Äòimplementation-approximated‚Äô‚Äù.
4. Should trigonometric functions, which generally have small domains and ranges, return Numbers when given BigInts? Answer is currently no, we are not currently extending the trigonometric functions.
5. What should the variadic `Math.hypot`, `max`, and `min` return when given no BigInt arguments? Answer: We make new `big` versions of each of them, and we make `bigHypot` return `0`, and `bigMax`/`bigMin` throw a TypeError.

[07:53:20.0619] <jschoi>
 * 1. Should `round`, `floor`, etc. take BigInts, acting as identity functions? Answer is currently no.
2. Are there any real-use cases for hyperbolic/root/logarithm functions on BigInts? Answer is currently ‚Äúdon‚Äôt know‚Äù but they‚Äôre specified anyway.
3. If we do extend hyperbolic/root/logarithm/irrational functions to accept BigInts, then should they return BigInts, and if so, how should they be rounded? Answer is currently yes and ‚Äúit‚Äôs ‚Äòimplementation-approximated‚Äô‚Äù.
4. Should trigonometric functions, which generally have small domains and ranges, return Numbers when given BigInts? Answer is no, and because of this we are not currently extending the trigonometric functions.
5. What should the variadic `Math.hypot`, `max`, and `min` return when given no BigInt arguments? Answer: We make new `big` versions of each of them, and we make `bigHypot` return `0`, and `bigMax`/`bigMin` throw a TypeError.

[08:18:10.0240] <ljharb>
@jschoi my answers are yes, don‚Äôt know, sounds good, probably reasonable, and I‚Äôd prefer not making new versions if possible 

[08:23:21.0684] <jschoi>
> <@ljharb:matrix.org> @jschoi my answers are yes, don‚Äôt know, sounds good, probably reasonable, and I‚Äôd prefer not making new versions if possible

What I‚Äôm concerned about is `Math.max(0n, 1n)` and `Math.max()` returning different things, which might cause bugs if that breaks programmer intuition.

[08:23:30.0780] <jschoi>
> <@ljharb:matrix.org> @jschoi my answers are yes, don‚Äôt know, sounds good, probably reasonable, and I‚Äôd prefer not making new versions if possible

 * What I‚Äôm concerned about is `Math.max(0n, 1n)` and `Math.max()` returning different types, which might cause bugs if that breaks programmer intuition.

[08:23:58.0277] <jschoi>
Likewise with `Math.hypot(arrayOfBigIntsButItIsActuallyEmpty)` returning `+0` the Number.

[08:24:15.0687] <jschoi>
 * Likewise with `Math.hypot(...arrayOfBigIntsButItIsActuallyEmpty)` returning `+0` the Number.

[08:25:01.0208] <jschoi>
This probably would cause the same sort of implicit Number/BigInt type mixing that the original design was trying to avoid.

[08:25:29.0901] <jschoi>
 * Regarding the last question‚ÄîWhat I‚Äôm concerned about is `Math.max(0n, 1n)` and `Math.max()` returning different types, which might cause bugs if that breaks programmer intuition.

[08:28:57.0418] <jschoi>
 * Regarding the last question‚ÄîWhat I‚Äôm concerned about is `Math.max(0n, 1n)` and `Math.max()` returning different types `1n` and `+Infinity`, which might cause bugs if that type switching breaks programmer intuition with arrays of BigInts.

[08:36:33.0596] <jschoi>
* Likewise with `Math.hypot(...arrayOfBigIntsThatMightActuallyBeEmpty)` returning `+0` the Number.

[08:36:41.0128] <jschoi>
* Likewise with `Math.hypot(...arrayOfBigIntsThatMightActuallyBeEmpty)` returning `+0` the Number whenever it is empty. 

[08:37:04.0943] <jschoi>
* Likewise with `Math.hypot(...arrayOfBigIntsThatMightActuallyBeEmpty)` returning `+0` the Number instead of a BigInt whenever the array is empty. 

[08:37:55.0300] <jschoi>
* This probably would cause the same sort of implicit Number/BigInt type mixing that the original design was trying to avoid. Hence `bigHypot` etc.

[08:38:19.0126] <jschoi>
* This probably would cause the same sort of implicit Number/BigInt type mixing that the original design was trying to avoid. Hence `bigHypot` and `bigMax`.

[08:39:23.0231] <ljharb>
I‚Äôm much more convinced by the second case than the first

[08:40:28.0736] <jschoi>
Yeah, basically the second case. 

[08:41:05.0766] <jschoi>
* Yeah, basically the second case. It applies to all three variadic functions. 

[10:30:42.0279] <Richard Gibson>
bradleymeck: so, this?
```
concat = function() {
  const receiverSpreadableValue = this[nativeIsConcatSpreadable];
  const isReceiverSpreadable = receiverSpreadableValue !== undefined ? !!receiverSpreadableValue : nativeIsArray(this);
  const substituteReceiver = isReceiverSpreadable ?
    { [nativeIsConcatSpreadable]: true, __proto__: this } :
    { [nativeIsConcatSpreadable]: true, length: 1, 0: this };
  return applyNativeConcat(substituteReceiver, arguments)}
```

[10:30:53.0635] <Richard Gibson>
 * bradleymeck: so, this?
```
concat = function() {
  const receiverSpreadableValue = this[nativeIsConcatSpreadable];
  const isReceiverSpreadable = receiverSpreadableValue !== undefined ? !!receiverSpreadableValue : nativeIsArray(this);
  const substituteReceiver = isReceiverSpreadable ?
    { [nativeIsConcatSpreadable]: true, __proto__: this } :
    { [nativeIsConcatSpreadable]: true, length: 1, 0: this };
  return applyNativeConcat(substituteReceiver, arguments);
};
```

[11:03:27.0482] <bradleymeck>
Richard Gibson: yup but not slow XD that is the problem

[11:04:28.0136] <Richard Gibson>
quit moving the goalposts! üòù

[11:13:49.0073] <bradleymeck>
hah

[15:13:40.0934] <Richard Gibson>
I suspect it would be faster if it also deviated from Array.prototype.concat by ignoring the receiver, but I don't know if that works for your use case:
```
const noSpecies = { [nativeIsConcatSpreadable]: true, length: 0 };
concat = function(/*...items*/) { return appyNativeConcat(noSpecies, arguments); };
```


2021-08-14

2021-08-15
[14:05:25.0363] <jmdyck>
oo, lots of merges


2021-08-16
[19:41:42.0647] <devsnek>
exciting times

[10:40:13.0472] <ptomato>
is it a normative change to turn ! into ?, if the ! assertion was incorrect?

[10:40:53.0514] <yulia>
I believe so -- it changes the behavior of the spec, even if it is wrong and unimplementedd

[10:40:56.0537] <yulia>
 * I believe so -- it changes the behavior of the spec, even if it is wrong and unimplemented

[10:41:19.0102] <ptomato>
thanks!

[10:45:32.0848] <shu>
incorrect assertions are editorial errors, because the spec was incoherent

[10:45:40.0352] <shu>
now, some of them could've been implemented wrong and we need to think harder

[10:45:52.0643] <shu>
but if nobody implemented it wrong, fixing assertions don't need consensus imo

[10:46:55.0701] <ptomato>
this one is in Temporal, so I'm not sure in how far it's been implemented wrong

[10:47:15.0880] <ptomato>
Frank (who I don't think is in this channel?) caught it, presumably in the process of implementing it for v8

[10:49:06.0109] <Domenic>
In case people have opinions on SyntaxError vs. TypeError for URLPattern, I'm currently leaning TypeError to match URL instead of SyntaxError to match RegExp. https://github.com/WICG/urlpattern/issues/74

[10:52:24.0702] <ptomato>
is it fair to say that fixing something unimplementable as written, is an editorial change, while fixing something that's implementable as written, even if nonsensical, is normative?

[10:54:22.0338] <ptomato>
I think I have a mostly accurate understanding, but doing this as a first-timer it would be helpful if there was a clear dividing line

[11:27:16.0838] <ptomato>
(I guess, something something observability, in addition to the above)

[11:29:57.0427] <bakkot>
ptomato: if it's implementable as written I wouldn't call it nonsensical, but yes, that's the usual rule we follow

[11:32:34.0592] <bakkot>
(but if there's an assertion which is violated, obviously it isn't implementable)

[11:37:38.0119] <ptomato>
I mean, from an implementor perspective I could see changing "? Operation(...)" to "! Operation(...)" means you have to change an implementation of, roughly, `bool ok = operation(...); assert(ok);` to `if (!operation(...)) return failure();`

[11:38:31.0006] <bakkot>
I'm saying I personally would regard "it's implementable but you have an `assert` which is violated" as "it is not implementable".

[12:07:17.0528] <shu>
my bar of "implemented wrong" is slightly different, i meant more like "different impls implemented it differently"

[12:07:34.0777] <shu>
if an implementation copied the incoherent assert and is crashing debug builds, i don't really consider that an issue

[15:50:39.0013] <rkirsling>
Temporal is also an interesting case of normativity since nobody's even allowed to ship it, but there's still a huge spec to battle-harden prior to landing

[15:52:32.0058] <rkirsling>
so "implementedness" still implies an investment of labor, but is totally separated from usual concerns of web reality 


2021-08-17
[22:31:46.0799] <sideshowbarker>
new ‚Äúhelp wanted‚Äù MDN issue https://github.com/mdn/content/issues/7995


2021-08-18
[18:25:39.0147] <devsnek>
someone might help if it was a wiki

[23:38:12.0930] <sideshowbarker>
devsnek: https://github.com/mdn/content/edit/main/files/en-us/web/javascript/reference/functions/get/index.md

[23:42:25.0430] <sideshowbarker>
The source can be edited there directly ‚Äî¬†and that source is in Markdown, so it‚Äôs now functionally the equivalent of a wiki editing experience. Or better, really. And from there it‚Äôs literally one button push to submit the update contented.

[23:44:51.0800] <sideshowbarker>
And yeah of course the big difference is, rather than that button push making the change immediately go live in the production site, it creates a PR and requires the content to then be scrutinized for technical accuracy and proofreading.

[23:49:06.0874] <sideshowbarker>
But that‚Äôs a feature, not a deficiency. The previous wiki system, while it made things easier for contributors with a very high level of JS domain knowledge to get their changes directly into MDN without anybody standing in their way ‚Äî¬†it also made things easy for contributors without very good JS domain knowledge to get a lot of suboptimal and outright-wrong changes directly into MDN without anybody standing in their way.

[23:53:29.0075] <sideshowbarker>
And so now we‚Äôre somewhat left with a big ongoing opportunity cost of contributors needing to spend time correcting problems in content that made its way in with zero review back in the wiki days ‚Äî time those contributors could maybe be spending instead on things like writing new content for newer JS features that are so far undocumented or (under-documented) in MDN

[23:53:37.0645] <sideshowbarker>
```

[23:53:52.0498] <sideshowbarker>
 * ```
// end sermon
```

[23:55:19.0000] <sideshowbarker>
 * But that‚Äôs a feature, not a deficiency.

The previous wiki system, while it made things easier for contributors with a very high level of JS domain knowledge to get their changes directly into MDN without anybody standing in their way ‚Äî¬†it also made things easy for contributors without very good JS domain knowledge to get a lot of suboptimal and outright-wrong changes directly into MDN without anybody standing in their way.

[23:55:37.0032] <sideshowbarker>
 * But that‚Äôs a feature, not a deficiency.

The previous wiki system, while it made things easier for contributors with a very high level of JS domain knowledge to get their changes directly into MDN without anybody standing in their way ‚Äî¬†it also made things easy for contributors _without_ very good JS domain knowledge to get a lot of suboptimal and outright-wrong changes directly into MDN without anybody standing in their way.

[23:56:18.0219] <sideshowbarker>
 * And so now we‚Äôre somewhat left with a big ongoing opportunity cost of contributors needing to spend time correcting problems in content that made its way in with zero review back in the wiki days ‚Äî time those contributors could maybe be spending instead on things like writing new content for newer JS features that, so far, are undocumented or (under-documented) in MDN

[00:16:55.0301] <yulia>
The MDN team did a really amazing job with the migration, plus github is a workflow most developers are familiar with already

[00:51:35.0767] <yulia>
Does anyone recall how this stalled? https://github.com/tc39/proposal-setmap-offrom

[00:53:34.0566] <yulia>
 * Does anyone recall how / why this stalled? https://github.com/tc39/proposal-setmap-offrom (pinging bakkot as he most likely knows)

[08:30:09.0307] <Domenic>
> <@yulia:mozilla.org> Does anyone recall how / why this stalled? https://github.com/tc39/proposal-setmap-offrom (pinging bakkot as he most likely knows)

I recall it stalling because people thought it wasn't well-motivated. Array.of/from exist because the Array constructor sucks. The Set and Map constructors are good already and adding Set.of(x, y)/Set.from(iterable) as a duplicate of new Set([x, y])/new Set(iterable) was not wanted.

[08:31:20.0796] <bradleymeck>
yulia: last i saw on this kind of stuff was from leobalter  I believe, there was a lack of agreement on need (isn't there always) / concerns about expanding API area without usage demands

[08:31:47.0619] <bradleymeck>
so... pretty close to what any Set/Map thing seems to face

[08:34:51.0177] <bakkot>
I am still fond of it; I'm more likely to bring it back if we get consensus on the extent to which we intend to support subclassing builtins (relevant because, does `(class extends Set { add(x){ } }).of('element')` invoke the subclass's `add` method?)

[08:36:13.0706] <bakkot>
Given that people were only lukewarm on the proposal, I didn't really want to deal with the fight about subclassing again for this proposal's sake

[08:38:09.0324] <bradleymeck>
if it helps, Symbol.species once again was a way to get a bug bounty

[08:38:22.0350] <bradleymeck>
I'm quite skeptical on this whole subclassing builtins, but I've said that before

[09:59:37.0220] <leobalter>
> <@domenicdenicola:matrix.org> I recall it stalling because people thought it wasn't well-motivated. Array.of/from exist because the Array constructor sucks. The Set and Map constructors are good already and adding Set.of(x, y)/Set.from(iterable) as a duplicate of new Set([x, y])/new Set(iterable) was not wanted.

this captures well the feedback received and I'm yet to build a better explainer, unfortunately with no cycles to prioritize this work so far. 

bradleymeck yulia bakkot it's up for grabs if anyone wants to champion it, otherwise I hope I can eventually find someone from my org who wants to do it.


2021-08-19
[10:37:06.0569] <sideshowbarker>
what do we call the object that results from parsing a script? 

[10:37:47.0936] <sideshowbarker>
parsing an HTML document produces a DOM tree, parsing a CSS stylesheet produces a CSSOM structure

[10:39:44.0019] <bradleymeck>
sideshowbarker: "Parse Node"

