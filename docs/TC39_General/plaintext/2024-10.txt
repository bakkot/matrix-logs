2024-10-02
[22:36:09.0957] <rkirsling>
wait I don't think I realized that it's legal to return random crap from a constructor

[22:37:22.0625] <rkirsling>
so `class C { foo() { return 3; } constructor() { return [1]; } }` in an uninstantiable class then? (in the sense that you can call `new C()` but you can never get "a `C`")

[22:37:39.0164] <rkirsling>
does that have a non-illegitimate usage?

[22:38:02.0907] <rkirsling>
 * so `class C { foo() { return 3; } constructor() { return [1]; } }` is an uninstantiable class then?
(in the sense that you can call `new C()` but you can never get "a `C`")

[22:39:04.0984] <rkirsling>
 * so `class C { foo() { return 3; } constructor() { return [1]; } }` is an uninstantiable class then?
(in the sense that you can call `new C()` but you can never get "a `C`" and you could only access `foo` via `C.prototype`)

[22:40:02.0974] <rkirsling>
 * so `class C { foo() { return 3; } constructor() { return [1]; } }` is an uninstantiable class then?
(in the sense that you can call `new C()` but you can never get "a `C`", so `foo` could only be accessed via `C.prototype`)

[08:15:26.0788] <Aapo Alasuutari>
> <@rkirsling:matrix.org> so `class C { foo() { return 3; } constructor() { return [1]; } }` is an uninstantiable class then?
> (in the sense that you can call `new C()` but you can never get "a `C`", so `foo` could only be accessed via `C.prototype`)

Returning an object is valid.

[08:16:47.0222] <rkirsling>
it is valid code, yes, otherwise I wouldn't be talking about it lol

[08:19:06.0972] <bakkot>
depends on what you mean by "illegitimate". i believe the functionality is there so you could match es5-style "classes" which did the same thing. also lets you wrap the return value in a Proxy or whatever

[08:20:31.0769] <bakkot>
these days the only real use I see for it is to stamp private fields on existing objects (`class id { constructor(x){ return x } }; class stamp { #priv; constructor(o){ super(o) } }; new stamp(foo); // foo now has .#priv`

[08:20:36.0076] <bakkot>
the "return override trick"

[08:20:40.0225] <bakkot>
but this is hateful and you shouldn't do it

[08:41:33.0407] <shu>
loathsome return override

[09:01:31.0331] <rkirsling>
yeah by legitimate I meant not hateful/loathsome ðŸ˜… thanks for confirming

[09:01:54.0232] <rkirsling>
I learned this from Shu's Shared Structs deck

[09:02:03.0112] <rkirsling>
* (I learned this from Shu's Shared Structs deck)

[09:17:11.0251] <Michael Ficarra>
I think it was used for like "decorating" a constructor back in the day

[09:17:30.0574] <Michael Ficarra>
something like `C = doParameterValidation(C);`

[09:20:10.0294] <Michael Ficarra>
but while that is a use case for return override in functions, it is not a use case for return override in class constructors

[09:20:20.0950] <Michael Ficarra>
that feature probably should've been left on the ES2015 cutting room floor

[12:03:39.0498] <Bradford Smith>
A factory function is better, but I have seen the "return from constructor" feature used to allow `new Foo(x)` to always return the same object for a given `x` value.

[12:04:26.0599] <shu>
that's high-level hating

[12:04:35.0728] <shu>
why would you want `new` to not be actually new


2024-10-05
[21:49:11.0458] <Tushar Vaswani>

Hey guys I was reading about environment records and lexical environment and I got a confusion. Don't know if this is the right channel to discuss about this. But basically my question is this:

If we have this code:

{
    const x = 2;
    var y = 3;
}

console.log(x); // will fail
console.log(y); // will work fine

Then here x was part of lexical environment(and ultimately environment record) of the block. That's why it will not be accessible outside the block.

But var is accessible becasue it's not block scoped. So does that mean it's not stored in environment record of block and stored directly in global environment record (and global object basically?) or in both global environment record and environment record of block.

[21:49:28.0654] <Tushar Vaswani>
 * 
Hey guys I was reading about environment records and lexical environment and I got a confusion. Don't know if this is the right channel to discuss about this. But basically my question is this:

If we have this code:

```js
{
    const x = 2;
    var y = 3;
}

console.log(x); // will fail
console.log(y); // will work fine
```

Then here x was part of lexical environment(and ultimately environment record) of the block. That's why it will not be accessible outside the block.

But var is accessible becasue it's not block scoped. So does that mean it's not stored in environment record of block and stored directly in global environment record (and global object basically?) or in both global environment record and environment record of block.

[21:51:33.0444] <rkirsling>
yeah, `var` effectively "doesn't see" `{}`

[21:53:04.0827] <Tushar Vaswani>
> <@rkirsling:matrix.org> yeah, `var` effectively "doesn't see" `{}`

Thanks for help, so that basically means it will be be stored in global environment record only?

[21:54:00.0086] <Tushar Vaswani>
I am mainly confused because its not clearly outlined in spec

[21:54:05.0630] <Tushar Vaswani>
 * I was mainly confused because its not clearly outlined in spec

[21:55:23.0191] <rkirsling>
yeah, "lexical" refers to the `{}`, `let`, `const` mechanism

[21:55:45.0030] <rkirsling>
`var` just knows about function scopes and global scope

[21:55:51.0177] <Jessidhia>
that depends on strict mode and on whether itâ€™s inside or outside a function body

[21:56:26.0859] <Jessidhia>
it wonâ€™t be global on a strict mode scriptâ€¦ IIRC

[21:58:27.0791] <Tushar Vaswani>
> <@rkirsling:matrix.org> `var` just knows about function scopes and global scope

Thanks that makes a lot more sense now

[22:01:10.0967] <Tushar Vaswani>
> <@jessidhia:matrix.org> it wonâ€™t be global on a strict mode scriptâ€¦ IIRC

so does that mean we wont be able to access var variables outside block in strict mode?

[22:02:24.0524] <Tushar Vaswani>
Well actually maybe I misunderstood it because I just tried it and it seems to work still:

```js
"use strict";
{
    var a = 1;
    console.log(a);
}
console.log(a);
```

[22:03:37.0861] <rkirsling>
you'd want to check `globalThis.a` but I do think it works, yeah

[22:03:49.0080] <rkirsling>
 * you'd want to check `globalThis.a` but I do think it works, yeah

[22:04:25.0768] <Tushar Vaswani>
> <@rkirsling:matrix.org> you'd want to check `globalThis.a` but I do think it works, yeah

yeah even that is printing the value

