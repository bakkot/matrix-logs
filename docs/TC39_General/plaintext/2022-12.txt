2022-12-01
[17:29:17.0431] <ljharb>
tolmasky: what's the use case? it might be relevant for the get-intrinsic proposal :-)

[22:07:17.0342] <sirisian>
Is there a new cancelable promise proposal? Was going through and refreshing myself on proposals and noticed the last one was withdrawn recently.

[22:32:39.0638] <Jessidhia>
> <@kriskowal:matrix.org> To wit, if we renamed `module` to something like `moduleInstance`, it would also make sense to use `moduleInstace {}` as the introducer for module expressions.

for some reason this started looking like an F# computation expression to me

[22:39:09.0632] <Jessidhia>
> <@ljharb:matrix.org> Thatâ€™s not what they do, thatâ€™s what the modules are.

IIUC, the objection youâ€™re making here is more on the grounds of, for example, `import * as foo from './foo.css' with { type: 'css' }` having the capability of `foo` being a different module record than `import * as foo from './foo.css' with { type: 'cssmodule' }` despite the URLs being equal?

[01:08:18.0102] <ljharb>
Jessidhia: yes, exactly right - the spec for assertions forbids those from being a different module record.

[02:48:33.0108] <Justin Ridgewell>
We can enforce that at the bundler level as well

[02:48:39.0988] <Justin Ridgewell>
 * We can enforce that at the bundler level as well

[07:06:43.0579] <tolmasky>
If I change an intrinsic object (for example, Array.prototype), is it technically not "the" intrinsic anymore. Like if I do Array.prototype.cheese = 10, then in a hypothetical world where I did GetIntrinsic("Array").prototype (or GetIntrinsic("Array.prototype"), would I get back the object with the cheese property, or would it try to give me a "fresh" object?

[09:16:37.0442] <ljharb>
tolmasky: it is still the same intrinsic object. it has the same identity.

[09:17:09.0641] <ljharb>
"intrinsic" describes its state at the birth of the realm; the state doesn't matter after that


2022-12-02
[03:41:48.0293] <Mathieu Hofman>
I believe Mark would say it's the primordial state

[13:44:23.0192] <Rob Palmer>
Ask for the polyfill! 

[13:44:52.0176] <ljharb>
haha i'll try. it does understand "in ES3 CJS format", at least

[13:45:43.0440] <ljharb>
nah, not good at all

[13:46:02.0852] <ljharb>
it seems to think `union` takes variadic args of 0-N sets :-/

[13:56:38.0249] <bakkot>
that one will actually produce the right answer, though it goes about it the wrong way

[14:07:42.0940] <ljharb>
right

[14:07:50.0926] <ljharb>
which is certainly a level of impressive


2022-12-03
[18:34:47.0314] <snek>
it checks if union exists though, throw it out ðŸ—‘

[19:55:11.0068] <sirisian>
It's fun to ask ChatGPT: "What language feature from another language would you add to Javascript?" Fascinating how it can talk about anything.

[20:46:50.0075] <Domenic>
https://github.com/tc39/proposal-arraybuffer-transfer looks great, no notes!

[08:12:49.0349] <tolmasky>
rbuckton: parseH1 in ecmarkup seems to not be able to parse rest variables (which show up in the spec). I tried finding if they were handled somewhere else in ecmarkup, but couldn't seem to find it anywhere. Could you point me to where that's handled? https://runkit.com/tolmasky/parsing-in-ecmarkup-h1s

[08:47:54.0128] <bakkot>
tolmasky: it might well just not handle it; ecmarkup is generally pretty permissive with stuff it doesn't recognize, outside of a few contexts

[08:48:05.0125] <bakkot>
also I'm the current ecmarkup maintainer if you have questions about it

[10:02:47.0559] <Andreu Botella>
I was looking at the `ArrayBuffer.transfer` proposal, and it feels odd to have my only contribution to a JS engine at all so far listed as prior art for `get detached`

[10:03:54.0214] <Andreu Botella>
but yeah, I worked on that because it was needed for Deno to be able to implement web APIs like streams and `structuredClone`

[10:04:54.0273] <Andreu Botella>
and it was particularly necessary looking forwards to the resizable proposal, since at this point web APIs wouldn't be the only ones detaching buffers

[11:56:10.0132] <tolmasky>
bakkot ah my mistake! apologies for that. Is there some other part of the process I should look into that takes it and turns it in ( ... <var>values</var> ), because it seems to somehow go from "( ..._values_ )" to "<var>values</var>" at some point

[13:36:56.0371] <Richard Gibson>
> <@tolmasky:matrix.org> bakkot ah my mistake! apologies for that. Is there some other part of the process I should look into that takes it and turns it in ( ... <var>values</var> ), because it seems to somehow go from "( ..._values_ )" to "<var>values</var>" at some point

I'm pretty sure the dots are just ignored, e.g.
```
$ printf '\n<emu-clause id="POC">\n<h1>POC ( ..._a_, ..._b_, ???_c_, !@#$%%^&-+=_d_ )</h1>\n</emu-clause>' | npx ecmarkup /dev/stdin /dev/stdout 2>/dev/null | sed -n 's/.*<emu-clause/<emu-clause/; /id="POC"/,$p'
<emu-clause id="POC">
<h1><span class="secnum">1</span> POC ( ...<var>a</var>, ...<var>b</var>, ???<var>c</var>, !@#$%^&amp;-+=<var>d</var> )</h1>
</emu-clause></div></body>
```


2022-12-04
[23:54:16.0442] <bakkot>
yeah `_a_` is turned to `<var>a</var>` (by ecmarkdown, via emdTextNode) pretty much everywhere

[23:55:08.0269] <bakkot>
callsite is https://github.com/tc39/ecmarkup/blob/a004ca7d8e95452e680e284c9a4a86a0d31e9914/src/Spec.ts#L1982 I believe

[11:24:05.0664] <Andreu Botella>
I was wondering whether promise jobs and `Atomics.waitAsync` effectively require ECMAScript implementers to have an event loop, or if those requirements could in theory be fulfilled in other ways


2022-12-05
[00:31:11.0648] <annevk>
Andreu Botella: yes, see https://tc39.es/ecma262/#sec-jobs

[00:33:56.0239] <Andreu Botella>
Hm, yeah, I guess the job requirements pretty much rule anything other than an event loop

[06:15:53.0891] <littledan>
Sure but still some people in TC39 spaces will not like to hear those wordsâ€¦ so it is fine to have as a mental model but not how proposal spec text should be written.

[06:17:24.0227] <littledan>
The module map is a similar situationâ€”the idempotency requirement on imports necessitates it exist at some level, but it is defined outside of Ecma-262.

[10:09:04.0899] <tolmasky>
Is there a stylistic/documentation reason that hasOwnProperty's argument is named "V", when (I think?) most other places that take a thing that is meant to be a property key (by that I mean, they immediately call ToPropertyKey() on it) use "P" instead (for example, defineProperty uses P, getOwnPropertyDescriptor, etc.)

[10:09:40.0263] <tolmasky>
Including, notably, hasOwn, which also uses "P" instead of "V"

[10:10:50.0226] <bakkot>
I don't know offhand, but probably not; parameter names are currently not particularly consistent and so I wouldn't suggest reading into them much

[10:39:53.0557] <jmdyck>
Object.p.hasOwnProperty was introduced in 3rd edition, where all Object.p.foo had at most one parameter, always named V regardless of its purpose. Object.{defineProperty,getOwnPropertyDescriptor} were added in 5th edition, along with other Object.foo functions. Some of these had more than one parameter, so I imagine a bit more thought went into choosing their names. So: 2 different kinds of consistency, at 2 different times, in 2 different sections. Historical accident, I'd say.

[10:40:14.0898] <jmdyck>
 * Object.p.hasOwnProperty was introduced in 3rd edition, where all Object.p.foo had at most one parameter, always named V regardless of its purpose.
Object.{defineProperty,getOwnPropertyDescriptor} were added in 5th edition, along with other Object.foo functions. Some of these had more than one parameter, so I imagine a bit more thought went into choosing their names. So: 2 different kinds of consistency, at 2 different times, in 2 different sections. Historical accident, I'd say.

[11:52:44.0912] <tolmasky>
Would their be opposition to submitting changes that made it more consistent, specifically making them all P for example (for larger context, this is to make tooling I'm writing around this easier -- it would be nice to just be able to call everything "P" propertyKey or whatever, without needing to special case 3rd edition stuff with a bunch of manual overrides)

