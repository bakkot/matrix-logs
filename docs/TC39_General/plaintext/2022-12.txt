2022-12-01
[17:29:17.0431] <ljharb>
tolmasky: what's the use case? it might be relevant for the get-intrinsic proposal :-)

[22:07:17.0342] <sirisian>
Is there a new cancelable promise proposal? Was going through and refreshing myself on proposals and noticed the last one was withdrawn recently.

[22:32:39.0638] <Jessidhia>
> <@kriskowal:matrix.org> To wit, if we renamed `module` to something like `moduleInstance`, it would also make sense to use `moduleInstace {}` as the introducer for module expressions.

for some reason this started looking like an F# computation expression to me

[22:39:09.0632] <Jessidhia>
> <@ljharb:matrix.org> That’s not what they do, that’s what the modules are.

IIUC, the objection you’re making here is more on the grounds of, for example, `import * as foo from './foo.css' with { type: 'css' }` having the capability of `foo` being a different module record than `import * as foo from './foo.css' with { type: 'cssmodule' }` despite the URLs being equal?

[01:08:18.0102] <ljharb>
Jessidhia: yes, exactly right - the spec for assertions forbids those from being a different module record.

[02:48:33.0108] <Justin Ridgewell>
We can enforce that at the bundler level as well

[02:48:39.0988] <Justin Ridgewell>
 * We can enforce that at the bundler level as well

[07:06:43.0579] <tolmasky>
If I change an intrinsic object (for example, Array.prototype), is it technically not "the" intrinsic anymore. Like if I do Array.prototype.cheese = 10, then in a hypothetical world where I did GetIntrinsic("Array").prototype (or GetIntrinsic("Array.prototype"), would I get back the object with the cheese property, or would it try to give me a "fresh" object?

[09:16:37.0442] <ljharb>
tolmasky: it is still the same intrinsic object. it has the same identity.

[09:17:09.0641] <ljharb>
"intrinsic" describes its state at the birth of the realm; the state doesn't matter after that

