2022-12-01
[17:29:17.0431] <ljharb>
tolmasky: what's the use case? it might be relevant for the get-intrinsic proposal :-)

[22:07:17.0342] <sirisian>
Is there a new cancelable promise proposal? Was going through and refreshing myself on proposals and noticed the last one was withdrawn recently.

[22:32:39.0638] <Jessidhia>
> <@kriskowal:matrix.org> To wit, if we renamed `module` to something like `moduleInstance`, it would also make sense to use `moduleInstace {}` as the introducer for module expressions.

for some reason this started looking like an F# computation expression to me

[22:39:09.0632] <Jessidhia>
> <@ljharb:matrix.org> Thatâ€™s not what they do, thatâ€™s what the modules are.

IIUC, the objection youâ€™re making here is more on the grounds of, for example, `import * as foo from './foo.css' with { type: 'css' }` having the capability of `foo` being a different module record than `import * as foo from './foo.css' with { type: 'cssmodule' }` despite the URLs being equal?

[01:08:18.0102] <ljharb>
Jessidhia: yes, exactly right - the spec for assertions forbids those from being a different module record.

[02:48:33.0108] <Justin Ridgewell>
We can enforce that at the bundler level as well

[02:48:39.0988] <Justin Ridgewell>
 * We can enforce that at the bundler level as well

[07:06:43.0579] <tolmasky>
If I change an intrinsic object (for example, Array.prototype), is it technically not "the" intrinsic anymore. Like if I do Array.prototype.cheese = 10, then in a hypothetical world where I did GetIntrinsic("Array").prototype (or GetIntrinsic("Array.prototype"), would I get back the object with the cheese property, or would it try to give me a "fresh" object?

[09:16:37.0442] <ljharb>
tolmasky: it is still the same intrinsic object. it has the same identity.

[09:17:09.0641] <ljharb>
"intrinsic" describes its state at the birth of the realm; the state doesn't matter after that


2022-12-02
[03:41:48.0293] <Mathieu Hofman>
I believe Mark would say it's the primordial state

[13:44:23.0192] <Rob Palmer>
Ask for the polyfill! 

[13:44:52.0176] <ljharb>
haha i'll try. it does understand "in ES3 CJS format", at least

[13:45:43.0440] <ljharb>
nah, not good at all

[13:46:02.0852] <ljharb>
it seems to think `union` takes variadic args of 0-N sets :-/

[13:56:38.0249] <bakkot>
that one will actually produce the right answer, though it goes about it the wrong way

[14:07:42.0940] <ljharb>
right

[14:07:50.0926] <ljharb>
which is certainly a level of impressive


2022-12-03
[18:34:47.0314] <snek>
it checks if union exists though, throw it out ðŸ—‘

[19:55:11.0068] <sirisian>
It's fun to ask ChatGPT: "What language feature from another language would you add to Javascript?" Fascinating how it can talk about anything.

[20:46:50.0075] <Domenic>
https://github.com/tc39/proposal-arraybuffer-transfer looks great, no notes!

[08:12:49.0349] <tolmasky>
rbuckton: parseH1 in ecmarkup seems to not be able to parse rest variables (which show up in the spec). I tried finding if they were handled somewhere else in ecmarkup, but couldn't seem to find it anywhere. Could you point me to where that's handled? https://runkit.com/tolmasky/parsing-in-ecmarkup-h1s

[08:47:54.0128] <bakkot>
tolmasky: it might well just not handle it; ecmarkup is generally pretty permissive with stuff it doesn't recognize, outside of a few contexts

[08:48:05.0125] <bakkot>
also I'm the current ecmarkup maintainer if you have questions about it

[10:02:47.0559] <Andreu Botella>
I was looking at the `ArrayBuffer.transfer` proposal, and it feels odd to have my only contribution to a JS engine at all so far listed as prior art for `get detached`

[10:03:54.0214] <Andreu Botella>
but yeah, I worked on that because it was needed for Deno to be able to implement web APIs like streams and `structuredClone`

[10:04:54.0273] <Andreu Botella>
and it was particularly necessary looking forwards to the resizable proposal, since at this point web APIs wouldn't be the only ones detaching buffers

