2022-12-01
[17:29:17.0431] <ljharb>
tolmasky: what's the use case? it might be relevant for the get-intrinsic proposal :-)

[22:07:17.0342] <sirisian>
Is there a new cancelable promise proposal? Was going through and refreshing myself on proposals and noticed the last one was withdrawn recently.

[22:32:39.0638] <Jessidhia>
> <@kriskowal:matrix.org> To wit, if we renamed `module` to something like `moduleInstance`, it would also make sense to use `moduleInstace {}` as the introducer for module expressions.

for some reason this started looking like an F# computation expression to me

[22:39:09.0632] <Jessidhia>
> <@ljharb:matrix.org> That’s not what they do, that’s what the modules are.

IIUC, the objection you’re making here is more on the grounds of, for example, `import * as foo from './foo.css' with { type: 'css' }` having the capability of `foo` being a different module record than `import * as foo from './foo.css' with { type: 'cssmodule' }` despite the URLs being equal?

[01:08:18.0102] <ljharb>
Jessidhia: yes, exactly right - the spec for assertions forbids those from being a different module record.

[02:48:33.0108] <Justin Ridgewell>
We can enforce that at the bundler level as well

[02:48:39.0988] <Justin Ridgewell>
 * We can enforce that at the bundler level as well

[07:06:43.0579] <tolmasky>
If I change an intrinsic object (for example, Array.prototype), is it technically not "the" intrinsic anymore. Like if I do Array.prototype.cheese = 10, then in a hypothetical world where I did GetIntrinsic("Array").prototype (or GetIntrinsic("Array.prototype"), would I get back the object with the cheese property, or would it try to give me a "fresh" object?

[09:16:37.0442] <ljharb>
tolmasky: it is still the same intrinsic object. it has the same identity.

[09:17:09.0641] <ljharb>
"intrinsic" describes its state at the birth of the realm; the state doesn't matter after that


2022-12-02
[03:41:48.0293] <Mathieu Hofman>
I believe Mark would say it's the primordial state

[13:44:23.0192] <Rob Palmer>
Ask for the polyfill! 

[13:44:52.0176] <ljharb>
haha i'll try. it does understand "in ES3 CJS format", at least

[13:45:43.0440] <ljharb>
nah, not good at all

[13:46:02.0852] <ljharb>
it seems to think `union` takes variadic args of 0-N sets :-/

[13:56:38.0249] <bakkot>
that one will actually produce the right answer, though it goes about it the wrong way

[14:07:42.0940] <ljharb>
right

[14:07:50.0926] <ljharb>
which is certainly a level of impressive


2022-12-03
[18:34:47.0314] <snek>
it checks if union exists though, throw it out 🗑

[19:55:11.0068] <sirisian>
It's fun to ask ChatGPT: "What language feature from another language would you add to Javascript?" Fascinating how it can talk about anything.

[20:46:50.0075] <Domenic>
https://github.com/tc39/proposal-arraybuffer-transfer looks great, no notes!

[08:12:49.0349] <tolmasky>
rbuckton: parseH1 in ecmarkup seems to not be able to parse rest variables (which show up in the spec). I tried finding if they were handled somewhere else in ecmarkup, but couldn't seem to find it anywhere. Could you point me to where that's handled? https://runkit.com/tolmasky/parsing-in-ecmarkup-h1s

[08:47:54.0128] <bakkot>
tolmasky: it might well just not handle it; ecmarkup is generally pretty permissive with stuff it doesn't recognize, outside of a few contexts

[08:48:05.0125] <bakkot>
also I'm the current ecmarkup maintainer if you have questions about it

[10:02:47.0559] <Andreu Botella>
I was looking at the `ArrayBuffer.transfer` proposal, and it feels odd to have my only contribution to a JS engine at all so far listed as prior art for `get detached`

[10:03:54.0214] <Andreu Botella>
but yeah, I worked on that because it was needed for Deno to be able to implement web APIs like streams and `structuredClone`

[10:04:54.0273] <Andreu Botella>
and it was particularly necessary looking forwards to the resizable proposal, since at this point web APIs wouldn't be the only ones detaching buffers

[11:56:10.0132] <tolmasky>
bakkot ah my mistake! apologies for that. Is there some other part of the process I should look into that takes it and turns it in ( ... <var>values</var> ), because it seems to somehow go from "( ..._values_ )" to "<var>values</var>" at some point

[13:36:56.0371] <Richard Gibson>
> <@tolmasky:matrix.org> bakkot ah my mistake! apologies for that. Is there some other part of the process I should look into that takes it and turns it in ( ... <var>values</var> ), because it seems to somehow go from "( ..._values_ )" to "<var>values</var>" at some point

I'm pretty sure the dots are just ignored, e.g.
```
$ printf '\n<emu-clause id="POC">\n<h1>POC ( ..._a_, ..._b_, ???_c_, !@#$%%^&-+=_d_ )</h1>\n</emu-clause>' | npx ecmarkup /dev/stdin /dev/stdout 2>/dev/null | sed -n 's/.*<emu-clause/<emu-clause/; /id="POC"/,$p'
<emu-clause id="POC">
<h1><span class="secnum">1</span> POC ( ...<var>a</var>, ...<var>b</var>, ???<var>c</var>, !@#$%^&amp;-+=<var>d</var> )</h1>
</emu-clause></div></body>
```


2022-12-04
[23:54:16.0442] <bakkot>
yeah `_a_` is turned to `<var>a</var>` (by ecmarkdown, via emdTextNode) pretty much everywhere

[23:55:08.0269] <bakkot>
callsite is https://github.com/tc39/ecmarkup/blob/a004ca7d8e95452e680e284c9a4a86a0d31e9914/src/Spec.ts#L1982 I believe

[11:24:05.0664] <Andreu Botella>
I was wondering whether promise jobs and `Atomics.waitAsync` effectively require ECMAScript implementers to have an event loop, or if those requirements could in theory be fulfilled in other ways


2022-12-05
[00:31:11.0648] <annevk>
Andreu Botella: yes, see https://tc39.es/ecma262/#sec-jobs

[00:33:56.0239] <Andreu Botella>
Hm, yeah, I guess the job requirements pretty much rule anything other than an event loop

[06:15:53.0891] <littledan>
Sure but still some people in TC39 spaces will not like to hear those words… so it is fine to have as a mental model but not how proposal spec text should be written.

[06:17:24.0227] <littledan>
The module map is a similar situation—the idempotency requirement on imports necessitates it exist at some level, but it is defined outside of Ecma-262.

[10:09:04.0899] <tolmasky>
Is there a stylistic/documentation reason that hasOwnProperty's argument is named "V", when (I think?) most other places that take a thing that is meant to be a property key (by that I mean, they immediately call ToPropertyKey() on it) use "P" instead (for example, defineProperty uses P, getOwnPropertyDescriptor, etc.)

[10:09:40.0263] <tolmasky>
Including, notably, hasOwn, which also uses "P" instead of "V"

[10:10:50.0226] <bakkot>
I don't know offhand, but probably not; parameter names are currently not particularly consistent and so I wouldn't suggest reading into them much

[10:39:53.0557] <jmdyck>
Object.p.hasOwnProperty was introduced in 3rd edition, where all Object.p.foo had at most one parameter, always named V regardless of its purpose. Object.{defineProperty,getOwnPropertyDescriptor} were added in 5th edition, along with other Object.foo functions. Some of these had more than one parameter, so I imagine a bit more thought went into choosing their names. So: 2 different kinds of consistency, at 2 different times, in 2 different sections. Historical accident, I'd say.

[10:40:14.0898] <jmdyck>
 * Object.p.hasOwnProperty was introduced in 3rd edition, where all Object.p.foo had at most one parameter, always named V regardless of its purpose.
Object.{defineProperty,getOwnPropertyDescriptor} were added in 5th edition, along with other Object.foo functions. Some of these had more than one parameter, so I imagine a bit more thought went into choosing their names. So: 2 different kinds of consistency, at 2 different times, in 2 different sections. Historical accident, I'd say.

[11:52:44.0912] <tolmasky>
Would their be opposition to submitting changes that made it more consistent, specifically making them all P for example (for larger context, this is to make tooling I'm writing around this easier -- it would be nice to just be able to call everything "P" propertyKey or whatever, without needing to special case 3rd edition stuff with a bunch of manual overrides)

[11:59:26.0236] <ptomato>
I don't know if this is intentional editorial guidance, but I've seen single-letter parameter/variable names become much less common in additions from recent years

[12:01:19.0488] <tolmasky>
I certainly would be fine changing it to propertyKey or key or whatever too of course (I am already about to map all the P's to propertyKey, etc.)


2022-12-06
[20:56:08.0311] <Domenic>
James M Snell: BTW I think it would be really cool if there were some sort of language feature (?) where we could give a BufferSource to platform APIs and say "please transfer this to yourself, I won't use it" and then they wouldn't need to do copies. It's hard to imagine how it would work though... there's nothing straightforward, like there is in languages with move semantics that parameters can declare themselves as having.

[20:56:49.0901] <Domenic>
I guess if we were starting from scratch maybe we'd design every BufferSource-taking API as transferring, and ask you to make a copy if you plan to use it later?

[20:58:20.0512] <Domenic>
But something like `new Response(body.take())` or `new Response(take body)` or something would be neat, where it's a call-site opt-in. I guess maybe `new Response(body.transfer())` (with https://github.com/tc39/proposal-arraybuffer-transfer) is possible for a highly-integrated platform + JS engine to recognize and optimize, but that's a hard lift.

[21:10:01.0109] <James M Snell>
Yeah definitely difficult. For apis like the Request and Response constructors we could probably get away with a new option that communicates the intent, e.g. `new Response(but, { transfer: true })`... but that's difficult to do consistently for all apis. 

[21:10:23.0114] <James M Snell>
* Yeah definitely difficult. For apis like the Request and Response constructors we could probably get away with a new option that communicates the intent, e.g. `new Response(buf, { transfer: true })`... but that's difficult to do consistently for all apis. 

[21:12:56.0280] <James M Snell>
I certainly wouldn't mind a language level take/move type construct tho

[21:15:10.0716] <Domenic>
Yeah and it feels unfortunate to have to program it in one-off for each API. Then you have to litigate whether that API's really in the fast-path or not, and that'll have different answers for web vs. server... this feels like an area where the language can come in and just say "now there's a global fast thing available" because it doesn't have to judge.

[21:16:58.0908] <bakkot>
I wonder how hard the `new Response(body.transfer())` pattern actually is to optimize

[21:17:00.0891] <Domenic>
I guess the most feasible path would be trying to hack on an engine to see how optimizable `new Response(body.transfer())` can be, and then whether that hack can be generalized, or if generalizing it would benefit from some annotation (ideally in IDL to do code-gen for all BufferSource cases)

[21:17:41.0805] <Domenic>
I think the difficulty is not as much technical as "codebase-organizational" in that the teams that implement `new Response()` are pretty far from the teams that implement the JS engine, and want to operate without too much interaction and intertwingling of code.

[21:18:39.0920] <bakkot>
I'm imagining an internal bit on array buffers which is like "this is not aliased anywhere", which could be checked by platform APIs

[21:19:15.0467] <bakkot>
So the JS engine people could be responsible for figuring out how to set that bit, and the platform people would just need to check it

[21:19:24.0781] <bakkot>
Don't actually know if that's at all feasible though.

[21:19:36.0141] <Domenic>
Yeah if you could pull that off it seems pretty reasonable.

[00:45:21.0578] <Luca Casonato>
> <@domenicdenicola:matrix.org> But something like `new Response(body.take())` or `new Response(take body)` or something would be neat, where it's a call-site opt-in. I guess maybe `new Response(body.transfer())` (with https://github.com/tc39/proposal-arraybuffer-transfer) is possible for a highly-integrated platform + JS engine to recognize and optimize, but that's a hard lift.

Yeah - we’ve been thinking about this a lot for Deno. The least invasive solution we’ve been able to come up with so far is copy-on-write clones, but unfortunately V8 looks unlikely to implement these due to security concerns

[00:47:05.0828] <Luca Casonato>
> <@bakkot:matrix.org> I wonder how hard the `new Response(body.transfer())` pattern actually is to optimize

I can’t speak for all runtimes, but for Deno this would maybe be a 100 LOC change after we’ve specified the behavior

[00:47:23.0802] <Luca Casonato>
It doesn’t seem very difficult

[00:49:22.0460] <Luca Casonato>
Oh actually I think I misunderstood - the idea for the optimization is to prevent the clone in `new Response` because they passed in buffer is “fresh” and not anymore accessible by any other JS? This would be much more difficult, maybe impossible at our current integration level with V8

[00:52:24.0833] <Andreu Botella>
Would it be that difficult? You could use the `BackingStore` as the "owned buffer".

[00:53:34.0034] <Andreu Botella>
The issue that we've been thinking about a lot for Deno is that there are a number of async APIs that take buffers, and those can lead to data races

[07:40:45.0277] <shu>
yes, that would be difficult for an API to tell its argument is in fact not aliased without some pretty deep VM support exposed at the API boundary, if there's no language equivalent to, like, rvalue references

[07:41:28.0109] <shu>
dynamic rvalue references also does not seem like a thing that anyone would want to implement

[07:41:51.0242] <shu>
well, i guess it doesn't have to be dynamic

[07:42:01.0739] <littledan>
can we just transition to refcounting? that makes alias detection easier.

[07:42:37.0417] <shu>
i hear refcounting is also faster

[07:42:51.0117] <littledan>
totally

[07:59:36.0240] <bakkot>
shu: hard to do precisely, but what about a conservative thing where it can say "not aliased" or "maybe aliased" and be precise enough for `new Response(body.transfer())` to be analyzed as "not aliased"

[08:14:45.0093] <littledan>
this is the kind of thing Swift uses to omit the refcounting operations. It just composes so beautifully.

[08:15:08.0897] <littledan>
Stage 1? 🥺

[08:17:07.0552] <shu>
bakkot: where do we track this bit, for every single argument?

[08:26:28.0535] <bakkot>
just for array buffers

[08:27:46.0534] <shu>
the "may aliased" analysis is a static one, no?

[08:28:24.0797] <shu>
like, once things are compiled to bytecode, how do i know if a virtual register store (in a register VM) or a stack push (in a stack VM) is an actual binding assignment or a temporary?

