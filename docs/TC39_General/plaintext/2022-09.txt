2022-09-02
[14:23:35.0122] <iain>
Working on implementing Atomics.waitAsync: the spec text doesn't appear to say anything about what happens to a WaiterRecord if the agent that called waitAsync to create it terminates before it is notified. My initial expectation is that it would be removed from the WaiterList, but testing Chrome's implementation seems to indicate that there's still an entry

[14:24:53.0562] <iain>
(Methodology: create two workers, each of which calls Atomics.waitAsync on the same location, then terminate the first one. Atomics.notify has to be called twice to resolve the promise in the second worker, implying that the first worker's WaiterRecord is still hanging around)

[14:25:11.0720] <iain>
Is this the intended behaviour?

[15:58:39.0931] <shu>
yes, this is unfortunately a known leak

[15:58:45.0478] <shu>
i think there's some kind of lazy sweeping

[15:59:33.0553] <shu>
as for what the specified semantics are, i think it is currently underspecified. ecma262 doesn't really have a concept of "agent terminated"

[15:59:41.0357] <shu>
 * as for what the specified semantics are, i think it is currently underspecified. tc39 doesn't really have a concept of "agent terminated"

[15:59:48.0013] <shu>
 * as for what the specified semantics are, i think it is currently underspecified. ecma262 doesn't really have a concept of "agent terminated"

[16:02:03.0416] <shu>
it's not clear to me right now how easy it is to do this kind of sweeping eagerly

[16:02:13.0132] <shu>
iain: can it be done in Firefox easily?

[16:02:46.0497] <shu>
i agree with your intuition, it'd be nice if terminated agents made those entries disappear

[16:02:55.0793] <shu>
but like, how do you define when it's terminated?

[16:05:06.0289] <iain>
shu: I don't have any of it working yet in Firefox, so it's hard to say for sure how difficult it would be

[16:05:45.0049] <iain>
I thought I had a plan for clearing entries out when the runtime was shut down, but as I type this I realize that my current design only handles entries with an associated timeout

[16:09:14.0657] <iain>
But in any case, we already have code that cleans up when the runtime/context goes away: https://searchfox.org/mozilla-central/source/js/src/vm/JSContext.cpp#221

[16:11:10.0621] <iain>
In my test I just used `worker.terminate()`

[16:22:26.0297] <iain>
Actually, I don't understand why [this code](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/execution/futex-emulation.cc;l=876;drc=2d80b7b69c11da0716326b7fdc15568fc30820c2) in V8 doesn't already clean out the waiter when the isolate for the terminated worker thread goes away

