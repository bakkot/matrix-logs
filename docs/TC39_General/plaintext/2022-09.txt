2022-09-02
[14:23:35.0122] <iain>
Working on implementing Atomics.waitAsync: the spec text doesn't appear to say anything about what happens to a WaiterRecord if the agent that called waitAsync to create it terminates before it is notified. My initial expectation is that it would be removed from the WaiterList, but testing Chrome's implementation seems to indicate that there's still an entry

[14:24:53.0562] <iain>
(Methodology: create two workers, each of which calls Atomics.waitAsync on the same location, then terminate the first one. Atomics.notify has to be called twice to resolve the promise in the second worker, implying that the first worker's WaiterRecord is still hanging around)

[14:25:11.0720] <iain>
Is this the intended behaviour?

[15:58:39.0931] <shu>
yes, this is unfortunately a known leak

[15:58:45.0478] <shu>
i think there's some kind of lazy sweeping

[15:59:33.0553] <shu>
as for what the specified semantics are, i think it is currently underspecified. ecma262 doesn't really have a concept of "agent terminated"

[15:59:41.0357] <shu>
 * as for what the specified semantics are, i think it is currently underspecified. tc39 doesn't really have a concept of "agent terminated"

[15:59:48.0013] <shu>
 * as for what the specified semantics are, i think it is currently underspecified. ecma262 doesn't really have a concept of "agent terminated"

[16:02:03.0416] <shu>
it's not clear to me right now how easy it is to do this kind of sweeping eagerly

[16:02:13.0132] <shu>
iain: can it be done in Firefox easily?

[16:02:46.0497] <shu>
i agree with your intuition, it'd be nice if terminated agents made those entries disappear

[16:02:55.0793] <shu>
but like, how do you define when it's terminated?

