2022-11-02
[04:24:25.0724] <Domenic>
Anyone want to help back me up on https://github.com/web-platform-tests/wpt/pull/36746 ? The perennial confusion about the vague spec language like "For each own property key P of O"

[04:42:03.0275] <annevk>
Domenic: I think I agree with your conclusion, unless `OrdinaryOwnPropertyKeys` actually does something with the hook we do override, there's no reason to expect there would be additional own properties.

[04:42:29.0127] <annevk>
(Now whether that's good or bad, ...)


2022-11-07
[10:38:01.0228] <ptomato>
I'm looking into the Array.fromAsync proposal and have a question about what people's understanding of "Zalgo" is (to explain the [jargon](https://blog.izs.me/2013/08/designing-apis-for-asynchrony/), Zalgo is a reference to a meme, that is used as shorthand for the situation where an async operation sometimes calls a callback and sometimes doesn't)

[10:39:11.0388] <ptomato>
is throwing an error immediately, on bad input, Zalgo?

[10:40:14.0234] <ptomato>
i.e.
```js
function myfunc(input) {
  if (isBad(input)) throw new Error('bad!');
  return promiseFromAsyncOperation(input);
}
```

[10:41:12.0352] <ptomato>
the Array.fromAsync proposal [says yes](https://github.com/tc39/proposal-array-from-async#errors) and takes care to check its input only inside its async closure, which means rejecting the promise, not throwing an error synchronously

[10:41:51.0206] <ptomato>
Atomics.waitAsync, on the other hand, does throw errors synchronously on bad input: (steps 1 and 2 of https://tc39.es/proposal-atomics-wait-async/#sec-dowait)

[10:43:21.0323] <ptomato>
reading the [original](https://blog.izs.me/2013/08/designing-apis-for-asynchrony/) [definitions](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/) of Zalgo, I'd say this is not Zalgo as originally defined

[10:44:12.0226] <ptomato>
however, maybe it is still desirable to do one or the other; in which case we should probably adjust one of these two proposals

[10:45:06.0162] <Kris Kowal>
Zalgo in short is a combinatoric explosion of behaviors that may be either synchronous or anachronous, such that it is not practical to test every combination that will be seen in production.

[10:46:35.0793] <Kris Kowal>
Vetting inputs is I believe debatable. It depends on whether the errant behavior can possibly vary at runtime.

[10:47:05.0899] <Kris Kowal>
Being JavaScript, it almost certainly can.

[10:47:15.0497] <ljharb>
the language has explicit decided with `async function` that sync exceptions should *never* be thrown from something that returns a promise. there's a few exceptions, i think, if you're calling something on the wrong receiver, but generally we should avoid that

[10:47:26.0709] <bakkot>
ptomato: I would say that Atomics.waitAsync is actually a sync function, despite the name

[10:47:35.0970] <bakkot>
it does not return a promise; it returns an object which is synchronously usable

[10:47:37.0128] <ljharb>
can it return a promise?

[10:47:39.0233] <ljharb>
ah ok

[10:47:42.0632] <ljharb>
then i would agree

[10:47:49.0999] <bakkot>
(one of the properties of that object can be a promise)

[10:47:57.0568] <shu>
Atomics.waitAsync is the way it is explicitly to avoid zalgo

[10:47:58.0169] <ljharb>
zalgo is basically "always, or never, return a promise"

[10:48:13.0997] <ljharb>
"an object containing a promise" is definitely not a promise :-)

[10:48:53.0680] <shu>
in particular, Atomics.waitAsync *needs* to fail fast because it's built to mutexes -- you can't wait until the next microtask tick to find out you couldn't acquire the lock and need to go into the slow path 

[10:49:01.0138] <Kris Kowal>
> <@ljharb:matrix.org> the language has explicit decided with `async function` that sync exceptions should *never* be thrown from something that returns a promise. there's a few exceptions, i think, if you're calling something on the wrong receiver, but generally we should avoid that

And also the Promise constructor.

[10:49:04.0650] <shu>
so, instead of always returning a Promise it does this wrapping

[10:49:34.0656] <ptomato>
fair enough. I got misled by the first sentence of MDN on Atomics.waitAsync: "The static Atomics.waitAsync() method waits asynchronously on a shared memory location and returns a Promise."

[10:49:48.0595] <shu>
it waits asynchronously if it waits at all

[10:49:52.0802] <ptomato>
reading further down, you are right that it actually does not return a Promise

[10:49:56.0835] <shu>
if it doesn't wait, you can find out synchronously

[10:52:27.0581] <ptomato>
> <@ljharb:matrix.org> the language has explicit decided with `async function` that sync exceptions should *never* be thrown from something that returns a promise. there's a few exceptions, i think, if you're calling something on the wrong receiver, but generally we should avoid that

is there documentation for this decision? seems like a good thing to put in https://github.com/tc39/how-we-work/pull/119 once that document is established

[10:52:34.0713] <shu>
all that said i love zalgo

[10:52:36.0957] <shu>
i wish we had zalgo

[10:52:38.0139] <shu>
but alas

[11:02:17.0463] <ptomato>
well, in lieu of spec conventions, if anyone has a pointer to context about that decision, I'd be happy to read more. maybe I'll write a blog post on this or something

[11:03:14.0094] <joepie91 üè≥Ô∏è‚Äçüåà>
ptomato: https://blog.izs.me/2013/08/designing-apis-for-asynchrony/ is pretty much the canonical source on this topic

[11:03:52.0080] <ptomato>
thanks, but I linked that document above already üòÑ

[11:04:01.0652] <joepie91 üè≥Ô∏è‚Äçüåà>
oh, sorry.

[11:04:08.0483] <joepie91 üè≥Ô∏è‚Äçüåà>
only half paying attention today

[11:04:34.0451] <ptomato>
sync exceptions are not Zalgo according to that definition, so that's why I'm interested in the context of where we decided to depart from that

[11:05:42.0572] <joepie91 üè≥Ô∏è‚Äçüåà>
I'm unsure of the exact process behind that decision, but it does meet the *principles* behind zalgo; errors that are sometimes synchronous and sometimes asynchronous make it difficult to reason about the behaviour of a function

[11:09:17.0208] <ptomato>
I tend to agree, although the article (and the one from Havoc Pennington before it) concentrates, rightly IMO, on the situation where a callback is called sometimes synchronously and sometimes asynchronously, which is much, much worse

[11:10:09.0477] <Ashley Claymore>
I found it more of an issue when `.then` was more common. Would frequently see code like `.catch(handleError)` but sometimes the code would sync throw and that wasn‚Äôt handled.
Now `await` is here it‚Äôs less common, and code uses a catch block for both paths. But still seems like a good principle to follow 

[11:11:30.0057] <ptomato>
it's effectively a slightly different question; is it OK for the callback to not be called at all? (and I think there is good reason to answer no)

[11:13:51.0054] <ptomato>
which is apparently also what TC39 has concluded as well

[11:17:58.0860] <Ashley Claymore>
Many people, myself included, use zalgo also for when an api always calls the callback, but can either get the call before the outer call returns (current tick) or after (fresh tick)

[11:19:28.0254] <Ashley Claymore>
I think it is ok to further expand that to: when will the error information be available

[11:19:59.0420] <Ashley Claymore>
cuts down code paths if always async

[11:20:15.0973] <ptomato>
if the call happens before the outer call returns, isn't that effectively calling it synchronously?

[11:25:51.0284] <Ashley Claymore>
yeah

[11:28:13.0363] <Ashley Claymore>
ah right, and a sync error would be ‚Äúnot calling the callback at all‚Äù. Which yes is annoying. If the API returns a Result like container, then it has somewhere to return errors. It something is sync returning a value directly, it kinda has to throw if it wants to ‚Äúreturn‚Äù an error 


2022-11-08
[00:59:21.0662] <Jack Works>
Is it possible to freeze the [[Prototype]] of an ordinary object without wrapping it with Proxy? 

[02:13:54.0448] <Ashley Claymore>
Nope. Can only make it non-extensible. Props and prototype all part of the same bag

[02:40:45.0803] <Ashley Claymore>
https://github.com/tc39/proposal-freeze-prototype

[02:42:23.0611] <Ashley Claymore>
https://matrixlogs.bakkot.com/TC39_Delegates/2021-09-20#L1

[07:30:19.0394] <nicolo-ribaudo>
Is there an es5 way of creating a function with length n (where n is known statically when I'm writing the code), and for which `IsConstructor` returns `false`?

[07:51:06.0837] <jmdyck>
As far as I can tell, in es5, the only functions that don't have a [[Construct]] internal method are all built-ins. So even without the length constraint, the answer looks like no.

[08:11:23.0082] <nicolo-ribaudo>
Ok thanks, that matches what I expected but I was hoping for secret hacks üòÇ
I know that I can create functions with length 0 and 1 using getters and setters in object literals, but it does not generalize to 2+ args.

[08:11:43.0973] <nicolo-ribaudo>
 * Ok thanks, that matches what I expected but I was hoping for secret hacks üòÇ
I know that I can create functions with length 0 and 1 using getters and setters in object literals, but it does not generalize to 2+ args.

[10:19:22.0093] <ljharb>
those functions are constructors tho, aren't they?

[10:24:53.0373] <nicolo-ribaudo>
Nope:
```js
new (Object.getOwnPropertyDescriptor({ get x() {} }, "x").get) 
// TypeError: Object.getOwnPropertyDescriptor(...).get is not a constructor
```

[10:26:51.0182] <littledan>
yeah, all concise methods, e.g., `new ({x() {}}.x)`

[10:26:58.0030] <littledan>
and arrow functions

[10:44:49.0514] <jmdyck>
Are you running that in an ES5 engine?

[10:45:42.0337] <littledan>
I am saying, those things are not constructors, and that code throws. I am using a new engine

[10:46:16.0239] <jmdyck>
and nicolo-ribaudo ?

[10:46:50.0332] <littledan>
oh sorry I missed the "es5" part of the question!

[10:47:26.0572] <jmdyck>
looks like semantics changed between es5 and es6

[10:56:14.0976] <Ashley Claymore>
Does that work in ES5? alt: Using a getter, but re defining length and accessing args via `arguments`

[10:56:26.0511] <Ashley Claymore>
or is it a valid constructor in es5?

[11:02:58.0182] <nicolo-ribaudo>
No, I only tested it in modern browsers. Thank you!

[11:03:22.0469] <nicolo-ribaudo>
> <@jmdyck:matrix.org> Are you running that in an ES5 engine?

 * No, I only tested it in modern browsers. Thank you!

[11:04:14.0771] <nicolo-ribaudo>
For context, I was trying to figure out how to compile arrow functions to es5 in a 100% spec compliant way (mostly for fun, I'm not going to add this to Babel)

[11:05:25.0299] <nicolo-ribaudo>
> <@aclaymore:matrix.org> sent an image.

I thought that the length was non-configurable, this might work to at least keep the semantics of compiled code valid in modern engines üëÄ

[11:07:32.0708] <jmdyck>
In ES5, `get` PropertyName etc involves "the result of creating a new Function object as specified in 13.2", which always sets both [[Call]] and [[Construct]].

[11:07:45.0784] <jmdyck>
In ES6, it involves  "FunctionCreate(~Method~, ...)", which leads to FunctionAllocate being called with `_functionKind_` = "non-constructor", which causes \[\[Construct\]\] to not be set.

[11:09:30.0791] <jmdyck>
 * In ES6, it involves  "FunctionCreate(~Method~, ...)", which leads to FunctionAllocate being called with `_functionKind_` = "non-constructor", which causes \[\[Construct\]\] to not be set.


2022-11-10
[03:56:24.0072] <Jessidhia>
Is there a good reason as to why https://tc39.es/ecma402/#sec-defaultlocale ignores the document language?

Like, I know the language is intentionally underspecified, but is there a reason to prefer the chrome's language instead of the document's language? From what I can gather this would just result in out-of-place formatting if `Intl` formatting is used in documents where a `document.documentElement.lang` is specified and doesn't match the chrome's settings.

[03:57:26.0938] <Jessidhia>
on Firefox it ignores the document language *even if* it's present in `navigator.languages`; only the primary `navigator.language` is ever used

[04:00:53.0296] <Jessidhia>
this is kind of a blocker on me using `Intl.DateTimeFormat` without very careful wrapping üòÖ

[04:02:04.0310] <Jessidhia>
 * Is there a good reason as to why https://tc39.es/ecma402/#sec-defaultlocale ignores the document language?

Like, I know the spec language is intentionally underspecified here, but is there a reason to prefer the chrome's language instead of the document's language? From what I can gather this would just result in out-of-place formatting if `Intl` formatting is used in documents where a `document.documentElement.lang` is specified and doesn't match the chrome's settings.

[04:03:43.0935] <Jessidhia>
(on the other hand this gets into trouble with SSR because there's no document language during SSR so I guess my problem formulation is incomplete)

[04:34:37.0279] <annevk>
"host environment's current locale" seems kinda bogus

[04:36:28.0621] <annevk>
Well, I guess it's good enough, but I haven't seen a PR for HTML that maps "current locale" to `navigator.language`'s underlying primitive.

[04:38:55.0747] <annevk>
(Using the language of a document wouldn't work in quite a few environments, e.g., all workers, worklets. And it's not necessarily declared on the root element all of the time either, although it kinda ought to be. So if you want to write portable code you probably want that to be a separate input from the end user locale.)

[04:41:38.0319] <ryzokuken>
Jessidhia: did you come across this by any chance? https://github.com/WICG/proposals/issues/78

[04:41:59.0885] <ryzokuken>
basically "fetch the user's preferred locale" is a known problem in Intl

[04:43:42.0113] <Jessidhia>
I had come across https://github.com/tc39/ecma402/issues/38 which I guess is similar enough to WICG#78

[04:43:54.0764] <ryzokuken>
it's a complicated problem to solve while protecting the users' privacy but we're working on it

[04:44:16.0507] <ryzokuken>
> <@jessidhia:matrix.org> I had come across https://github.com/tc39/ecma402/issues/38 which I guess is similar enough to WICG#78

yes, basically this entire label: https://github.com/tc39/ecma402/labels/User%20Preferences

[04:44:50.0355] <ryzokuken>
it was an impetus for us to start looking into the problem, but the solution requires a non-trivial amount of API design and privacy auditing.

[04:45:04.0088] <Jessidhia>
but it's not quite what I was looking for; more of a way to include the application's preferences (say, user accessing page with document language set to Japanese while using an English language browser, which is my case as a developer of a Japanese web app üòÖ)

[04:46:04.0505] <ryzokuken>
ah, essentially the other way around, I guess?

[04:46:28.0665] <ryzokuken>
_enforcing_ a locale instead of inferring the user's preference, I mean

[04:48:55.0716] <Jessidhia>
yes, due to the document language; in my example the default result would produce a result with `/` separators instead of `YYYYÂπ¥MMÊúàDDÊó•`, which would look out of place in a japanese language phrase (user preference for the website being `lang="ja"`)

[04:50:09.0436] <Jessidhia>
`luxon` somewhat has a facility for this (`Settings.defaultLocale`) but it doesn't handle dynamic updates well

[04:50:28.0910] <ryzokuken>
why can't you just call all the formatters with `"ja-JP"`?

[04:50:40.0383] <ryzokuken>
by hardcoding the locale argument

[04:50:46.0301] <ryzokuken>
 * by hardcoding the locale argument

[04:52:25.0727] <Jessidhia>
the locale is actually user preference (out of 4 supported languages) but yes, I can supply a locale -- the problem then becomes coworkers using Japanese browsers accidentally getting "correct" output while omitting the argument if they don't test changing the language

[04:52:35.0342] <Jessidhia>
 * the locale is actually user preference (out of 4 supported languages) but yes, I can supply a locale -- the problem then becomes coworkers accidentally getting correct output while omitting it if they don't use a mismatched browser/document language

[04:52:57.0274] <Jessidhia>
 * the locale is actually user preference (out of 4 supported languages) but yes, I can supply a locale -- the problem then becomes coworkers accidentally getting "correct" output while omitting the argument if they don't use a mismatched browser/document language

[04:53:35.0737] <Jessidhia>
 * the locale is actually user preference (out of 4 supported languages) but yes, I can supply a locale -- the problem then becomes coworkers using Japanese browsers accidentally getting "correct" output while omitting the argument if they don't test changing the language

[04:55:55.0002] <Jessidhia>
 * the locale is actually user preference (out of 4 supported languages) but yes, I can supply a locale (or `document.documentElement.lang`) -- the problem then becomes coworkers using Japanese browsers accidentally getting "correct" output while omitting the argument if they don't test changing the language

[04:56:10.0891] <Jessidhia>
 * the locale is actually user preference (out of 4 supported languages) but yes, I can supply a locale (or `document.documentElement.lang` on the browser side) -- the problem then becomes coworkers using Japanese browsers accidentally getting "correct" output while omitting the argument if they don't test changing the language

[04:56:28.0939] <ryzokuken>
I see

[04:56:43.0465] <ryzokuken>
well, this seems to be more of a host problem than a language problem üòÖ

[04:56:58.0023] <ryzokuken>
all ways to override would be host-defined behavior I'm afraid

[04:58:22.0668] <Jessidhia>
prioritizing document language would be sufficient for this use case

[04:58:57.0351] <Jessidhia>
the complication is on hosts without a document (like node), that would necessitate a host-defined override

[04:59:24.0295] <ryzokuken>
yes, but `DefaultLocale` is completely host-defined too (https://tc39.es/ecma402/#sec-defaultlocale)

[04:59:44.0994] <ryzokuken>
oh wait, we've looped around to the start

[05:00:04.0334] <ryzokuken>
but yes, essentially hosts can choose to do whatever they prefer as long as the result is a valid locale

[05:40:25.0755] <annevk>
ryzokuken: why is there no HTML PR for this feature?

[05:55:15.0393] <ryzokuken>
annevk: it's still under active development. We're only just starting to narrow down the final semantics after consultation with different browser privacy teams.

[05:55:27.0079] <ryzokuken>
but yes, hopefully a PR should be out soon.

[07:08:45.0425] <littledan>
maybe we could start with an HTML issue then?

[07:17:58.0692] <annevk>
ryzokuken: oh weird, I thought that by the time something is in the main spec it would be stage 4/done?

[07:20:01.0217] <littledan>
The Intl default locale logic came before ES6 even; as you know very well, annevk , HTML/JS spec coherence wasn't so great back then

[07:21:16.0834] <annevk>
Hah, I might have known for sure, but my memory isn't always up-to-date :-)

[07:22:25.0884] <littledan>
My understanding of the history is that actually, Intl was initially going to be proposed as a web spec, but the web standards folks felt the platform wasn't ready for it yet; TC39 OTOH was excited about making this happen, and worked with the internationalization teams of all the same companies, and shipped it :)

[07:22:27.0245] <annevk>
I recall some effort around an event for the default locale changing, but I'm not sure if that ever landed

[07:22:42.0368] <littledan>
IIRC that did land but only Firefox actually exposed that event

[07:22:52.0486] <littledan>
for the language changing

[07:23:10.0342] <littledan>
there was also an idea about exposing a more detailed locale; this is what ryzokuken is working on now

[07:32:42.0481] <Jack Works>
The compartment proposal used to contain that part. You were able to virtualize the default locale within a compartment

[07:32:57.0210] <Jack Works>
But after the proposal is simplified, those abilities are removed. 

[07:33:08.0072] <Jack Works>
* But after the proposal is simplified, those abilities are removed. 

[07:35:06.0822] <annevk>
Filed https://github.com/whatwg/html/issues/8493 as a start

[07:36:09.0665] <annevk>
(And yeah, `languagechange` did happen, `timezonechange` not yet.)

[07:38:40.0713] <nicolo-ribaudo>
Maybe following a similar naming scheme as ECMA-262 (e.g. HostGetDefaultLocale()) makes it easier to see what needs to be defined at the host level

[07:57:45.0722] <littledan>
Definitely. Historically, I think these algorithms were written without the intention to be hookable in this sort of way.

[07:58:50.0907] <littledan>
Allen always said, the spec is not an API, and hosts can go in and do whatever, subject to the documented constraints on hosts. The idea to mark all things as Host* is sort of a rejection of this idea.

[08:03:53.0931] <nicolo-ribaudo>
The Host* hooks are more an "API" that ecma262 expects the host to provide, than an API exposed by ecma262 to the host - they mark AOs that _must_ be provided by the host

[08:35:53.0372] <littledan>
Yeah, I agree with that idea. We can collectively change our minds on these things.

[08:36:28.0794] <littledan>
if we're trying to understand why the spec is how it is, it helps to understand that articulating host APIs like this was an anti-goal in the past.

[09:12:28.0185] <annevk>
I would love for it to be an even more concrete API and scope certain host hooks by tying them to agent clusters and such.

[10:46:05.0833] <ljharb>
definitely critical to keep the historical context; it seems to me that we've largely discovered the hazards of underspecifying and being too implicit, and are trying to avoid repeating those mistakes :-)


2022-11-13
[02:10:29.0133] <rkirsling>
well this is odd. we got a JSC bug report suggesting that `"use strict"; x = this.x = 0;` should throw, but V8 and SM don't throw either. engine262 does, confirming the spec interpretation, but I wonder if it's web compatible to fix...

[02:20:29.0024] <rkirsling>
okay so the same reporter created V8 and SM bugs too, but the SM one was closed as duplicate of a 12(!)-year-old bug üëÄ

[02:21:01.0319] <rkirsling>
yet there's no documented reason for the non-fix: https://bugzilla.mozilla.org/show_bug.cgi?id=605515


2022-11-14
[16:54:47.0033] <bakkot>
rkirsling: this is one of the older known flaws in the spec; see e.g. https://github.com/tc39/ecma262/issues/467

[16:55:16.0152] <bakkot>
there have been some recent attempts to improve the situation e.g. https://github.com/tc39/ecma262/pull/2267

[16:55:37.0540] <bakkot>
although with their own issues e.g. https://github.com/tc39/ecma262/issues/2659

[16:55:48.0203] <bakkot>
for your specific issue https://github.com/tc39/ecma262/pull/2205 is the best reference probably

[16:56:13.0610] <bakkot>
if you feel inclined to figure out what exactly web reality _is_, and how to write that down, most everyone would be happy with such a PR I think

[16:57:13.0989] <bakkot>
don't know that there would be much appetite for going the other way and trying to get implementations to match the spec

[17:18:58.0976] <rkirsling>
cool

[17:44:31.0220] <rkirsling>
I'm not sure if I fully understand where that ended up at a glance but I suppose i could have a chat with shu about it

[05:02:33.0507] <ryzokuken>
is there a `FlatList` operation somewhere?

[07:10:52.0152] <Jack Works>
Apply(%Array.prototype.flat%)?

[07:11:27.0301] <ryzokuken>
would that work on ECMAScript List thingies?

[07:11:47.0761] <Jack Works>
No

[07:12:07.0994] <ryzokuken>
that's what I was looking for

[07:29:01.0974] <jmdyck>
So the input would be a List whose elements could themselves be Lists?

[07:30:40.0927] <littledan>
It would be cool to have the full set of stuff like https://infra.spec.whatwg.org/ in ECMA-262. But they don't seem to have List flat either.

[08:09:18.0050] <ryzokuken>
> <@jmdyck:matrix.org> So the input would be a List whose elements could themselves be Lists?

right, a list whose elements might optionally be further nested lists

[08:09:42.0833] <ryzokuken>
and a `FlatList` AO that would flatten it into a flat (?) list

[08:09:46.0823] <ryzokuken>
 * and a `FlatList` AO that would flatten it into a flat (?) list

[08:11:11.0868] <jmdyck>
I think a List-of-(possible)-Lists doesn't really happen in the current spec.

[08:11:43.0267] <ryzokuken>
not so far, but I'm dropping some hot spec text atm üôà

[08:11:53.0766] <ryzokuken>
it's for a proposal, but the point still stands I guess

[12:56:38.0045] <bakkot>
would anything important break if we made Array.prototype and Object.prototype reject numeric properties, do you figure

[12:57:14.0589] <bakkot>
that is, making them a new kind of exotic object which would silently (or loudly, I guess) prevent adding properties which could be array indices

[13:55:39.0293] <shu>
oh man

[13:56:08.0228] <littledan>
Can we fix the override mistake in all cases except the one lodash runs into at the same time?

[13:56:24.0783] <littledan>
I mean, an exotic object can have a different kind of Set()

[14:13:17.0449] <bakkot>
what's the one lodash runs into?

[14:15:01.0851] <littledan>
(I don't remember the details offhand)

[15:18:47.0105] <Domenic>
> <@littledan:matrix.org> It would be cool to have the full set of stuff like https://infra.spec.whatwg.org/ in ECMA-262. But they don't seem to have List flat either.

You're welcome to use Infra yourselves! (And send PRs for missing stuff.)

[15:19:09.0306] <Domenic>
No need to copy it over, specs are allowed to reference other specs.

[15:19:20.0541] <littledan>
I wouldn't mind adopting the sentence-based notation that infra uses, tbh

[15:28:10.0146] <TabAtkins>
it is very nice to use in practice


2022-11-15
[07:38:40.0993] <nicolo-ribaudo>
Hello, maybe someone here knows the history of block-scoped functions.

We have a very old Babel plugin, enabled by default, that does this transform ([@babel/plugin-transform-block-scoped-functions](https://babeljs.io/docs/en/babel-plugin-transform-block-scoped-functions)):
```js
{ function f() {} }
// --->
{ let f = function f() {} }
```

This plugin was created in response to this issue: https://github.com/babel/babel/issues/514

Does anyone know:
- why does Babel need to transform functions in blocks? Do they not work in older engines or older ECMAScript versions?
- should the transform use `let` or `var`?

[07:47:29.0402] <littledan>
the transform should use `let` because the semantics of JS of functions in a block is that they're lexically scoped to the block (modulo Annex B 3.3)

[07:48:01.0796] <littledan>
The history is that, prior to ES6, in sloppy mode, each engine had its own way of hoisting functions out of blocks. This transform prevents that non-standard behavior.

[07:49:00.0825] <littledan>
it sounds like the transform implements the strict mode semantics. Sloppy mode semantics, in Annex B 3.3, is a mess and I don't recommend looking at it if you want to maintain your sanity :)

[07:49:26.0059] <littledan>
I think it's not necessary to enable this plugin by default since it is only needed if you target a pretty old JS engine

[07:51:51.0184] <nicolo-ribaudo>
Thank you! Follow-up question:

We also have this test, that ensures that the function is hoisted to the outer scope when there is a variable with the same name (but only when we are also compiling `let`/`const` to `var`):
```js
var run = function () {
  return false;
};

if (true) {
  function run() {
    return true;
  }
}

function test() {
  return run();
}

// ---- OUTPUT --->

var run = function () {
  return false;
};
if (true) {
  var run = function () {
    return true;
  };
}
function test() {
  return run();
}
```

is this annex b behavior?

[07:52:14.0338] <nicolo-ribaudo>
> <@littledan:matrix.org> I think it's not necessary to enable this plugin by default since it is only needed if you target a pretty old JS engine

Yeah right now we compile down to the oldest targets we support; this is going to change in Babel 8

[07:55:04.0611] <littledan>
> <@nicolo-ribaudo:matrix.org> Thank you! Follow-up question:
> 
> We also have this test, that ensures that the function is hoisted to the outer scope when there is a variable with the same name (but only when we are also compiling `let`/`const` to `var`):
> ```js
> var run = function () {
>   return false;
> };
> 
> if (true) {
>   function run() {
>     return true;
>   }
> }
> 
> function test() {
>   return run();
> }
> 
> // ---- OUTPUT --->
> 
> var run = function () {
>   return false;
> };
> if (true) {
>   var run = function () {
>     return true;
>   };
> }
> function test() {
>   return run();
> }
> ```
> 
> is this annex b behavior?

reviewing https://tc39.es/ecma262/#sec-block-level-function-declarations-web-legacy-compatibility-semantics  (actually B 3.2 now), yeah, it looks like an outer var declaration does not block this hoisting, though a let declaration would

[07:56:29.0903] <nicolo-ribaudo>
Thank you!

Another thing we should to in Babel 8 is deciding if we want to consider Annex B or not, instead of enabling it _sometimes_

[07:59:15.0531] <littledan>
IMO it should be enabled always in Babel, given that Babel tends to target web/Node environments, which always enable Annex B

[08:00:31.0999] <nicolo-ribaudo>
And whichever choice we make, there will be a plugin to do the opposite

[08:01:13.0300] <littledan>
ah so it is an even lower pressure decision than I was imagining


2022-11-16
[02:44:42.0733] <Jessidhia>
maybe one day UTF-16 can be relegated to Annex B‚Ä¶ ü´†


2022-11-17
[18:57:58.0343] <Jack Works>
oh I wonder what's the motivation for BigInt TAs

[18:58:33.0018] <Jack Works>
I thought TA is for low level calculations, is there a cross-platform representation (like IEEE floating points) for BigInt?

[18:58:45.0499] <shu>
oh the TAs aren't actually storing BigInts, they're storing (u)int64

[18:59:02.0343] <shu>
but to get the values out / or assign into them we need to put them into BigInts

[18:59:08.0922] <shu>
since Numbers don't have enough bits to hold int64s

[19:01:32.0051] <Jack Works>
ü§î so it cannot store infinitely big number?

[19:02:24.0926] <Jack Works>
oh I see

[00:46:13.0912] <Domenic>
So here is a fun case. On the web platform we have `Headers`, which is supposed to be `Map`-like. However, we want its entries to be sorted (based on their keys), when iterating.

OK. So what happens if you mutate during iteration? In particular, consider starting with keys `["a", "c", "d"]`. `"a"` is visited. `"c"` is visited. At this point `"b"` is inserted. Now what?

If we naively copy `Map`'s iteration algorithm, we get `["a", "c", "c", "d"]`, since `"c"` moved from index 1 to index 2 when we inserted `"b"`.

We could output `["a", "c", "b", "d"]` (breaking the ordering invariant), or `["a", "c", "d"]` (breaking the invariant that things added during iteration are always visited). Or we could stick with the natural extension of `Map`'s behavior and do `["a", "c", "c", "d"]`. Which is least-bad?

[00:58:45.0289] <Robert Pamely>
I haven't run this, but from what I can tell in c++ it would just move on to "d" because "b" is behind the iterator. That's logically what I would expect myself. 

[01:01:35.0012] <Robert Pamely>
So I guess that's the middle option you gave reading again. If you insert during iteration you could miss elements. 

[01:28:59.0858] <Ashley Claymore>
TIL, Map delete doesn't actually remove the entry from the list (but implementations can avoid the memory leak)

[01:29:20.0432] <Ashley Claymore>
```
let m = new Map();
[..."abcde"].forEach(m.set.bind(m));

for (const [k] of m) {
  console.log(k);
  if (k === "c") m.delete("b");
}


„Ä†> a
„Ä†> b
„Ä†> c
„Ä†> d
„Ä†> e
```

[01:33:14.0095] <Ashley Claymore>
so to see a map key twice looks like need to delete and then re-set

[01:35:21.0955] <Ashley Claymore>
I'm +1 on Robert Pamely . Inserting behind the sorted position of the iterator would result in that entry not being seen, and the current entry not being seen twice

[07:45:13.0120] <bakkot>
+1 to `["a", "c", "d"]`; that's also consistent with e.g. Java's ConcurrentSkipListMap and separately I think is the least unexpected from first principles

[07:45:44.0439] <bakkot>
I think for sorted collections you should not expect that things added during iteration are necessarily visited


2022-11-18
[16:07:11.0550] <jmdyck>
What is a "promise-like object"? (https://tc39.es/ecma262/#sec-promisecapability-records is the only occurrence in the spec)

[16:11:42.0589] <bakkot>
it deliberately doesn't have a formal definition

[16:13:47.0278] <bakkot>
formally it ends up being anything which can be produced by a constructor which takes a callback as an argument and immediately invokes that callback with two arguments, both of which are callable

[16:13:51.0730] <bakkot>
but that's not, like, useful

[16:13:59.0156] <bakkot>
so you should think of it as a promise-like object

[16:18:30.0688] <jmdyck>
Seems like that generality (allowing a promise-like object) isn't propagated through the spec.

[16:19:49.0433] <bakkot>
do you have a concrete case in mind?

[16:21:27.0665] <jmdyck>
e.g. Evaluate for a Cyclic Module Record says it returns "a Promise", but 2 of its returns are returning a capability's [[Promise]] field, which might be a promise-like object (or are we somehow guaranteed that it isn't?)

[16:22:25.0957] <bakkot>
in that case the promise is generated by `NewPromiseCapability(%Promise%)`, which does indeed create a capability which hold a genuine promise

[16:22:48.0915] <nicolo-ribaudo>
Step 6 of evaluate ensures that it's a real Promise, because it uses the %Promise% intrinsic. I think we can only get promise-likes when there are calls to `NewPromiseCapability` with user-provided consructors

[16:24:16.0931] <nicolo-ribaudo>
For example, `PromiseSubclass.all` will internally create a `PromiseCapability Record` containing an instance of `ProiseSubclass`, and will return that instance instead of a Promise

[16:26:02.0490] <nicolo-ribaudo>
We could link promise-like to step 2 of `NewPromiseCapability`, where it's defined (even if that step doesn't use the name promise-like)

[16:26:42.0153] <nicolo-ribaudo>
 * For example, `PromiseSubclass.all` will internally create a `PromiseCapability Record` containing an instance of `PromiseSubclass`, and will return that instance instead of a Promise

