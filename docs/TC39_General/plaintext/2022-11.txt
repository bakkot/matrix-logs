2022-11-02
[04:24:25.0724] <Domenic>
Anyone want to help back me up on https://github.com/web-platform-tests/wpt/pull/36746 ? The perennial confusion about the vague spec language like "For each own property key P of O"

[04:42:03.0275] <annevk>
Domenic: I think I agree with your conclusion, unless `OrdinaryOwnPropertyKeys` actually does something with the hook we do override, there's no reason to expect there would be additional own properties.

[04:42:29.0127] <annevk>
(Now whether that's good or bad, ...)


2022-11-07
[10:38:01.0228] <ptomato>
I'm looking into the Array.fromAsync proposal and have a question about what people's understanding of "Zalgo" is (to explain the [jargon](https://blog.izs.me/2013/08/designing-apis-for-asynchrony/), Zalgo is a reference to a meme, that is used as shorthand for the situation where an async operation sometimes calls a callback and sometimes doesn't)

[10:39:11.0388] <ptomato>
is throwing an error immediately, on bad input, Zalgo?

[10:40:14.0234] <ptomato>
i.e.
```js
function myfunc(input) {
  if (isBad(input)) throw new Error('bad!');
  return promiseFromAsyncOperation(input);
}
```

[10:41:12.0352] <ptomato>
the Array.fromAsync proposal [says yes](https://github.com/tc39/proposal-array-from-async#errors) and takes care to check its input only inside its async closure, which means rejecting the promise, not throwing an error synchronously

[10:41:51.0206] <ptomato>
Atomics.waitAsync, on the other hand, does throw errors synchronously on bad input: (steps 1 and 2 of https://tc39.es/proposal-atomics-wait-async/#sec-dowait)

[10:43:21.0323] <ptomato>
reading the [original](https://blog.izs.me/2013/08/designing-apis-for-asynchrony/) [definitions](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/) of Zalgo, I'd say this is not Zalgo as originally defined

[10:44:12.0226] <ptomato>
however, maybe it is still desirable to do one or the other; in which case we should probably adjust one of these two proposals

[10:45:06.0162] <Kris Kowal>
Zalgo in short is a combinatoric explosion of behaviors that may be either synchronous or anachronous, such that it is not practical to test every combination that will be seen in production.

[10:46:35.0793] <Kris Kowal>
Vetting inputs is I believe debatable. It depends on whether the errant behavior can possibly vary at runtime.

[10:47:05.0899] <Kris Kowal>
Being JavaScript, it almost certainly can.

[10:47:15.0497] <ljharb>
the language has explicit decided with `async function` that sync exceptions should *never* be thrown from something that returns a promise. there's a few exceptions, i think, if you're calling something on the wrong receiver, but generally we should avoid that

[10:47:26.0709] <bakkot>
ptomato: I would say that Atomics.waitAsync is actually a sync function, despite the name

[10:47:35.0970] <bakkot>
it does not return a promise; it returns an object which is synchronously usable

[10:47:37.0128] <ljharb>
can it return a promise?

[10:47:39.0233] <ljharb>
ah ok

[10:47:42.0632] <ljharb>
then i would agree

[10:47:49.0999] <bakkot>
(one of the properties of that object can be a promise)

[10:47:57.0568] <shu>
Atomics.waitAsync is the way it is explicitly to avoid zalgo

[10:47:58.0169] <ljharb>
zalgo is basically "always, or never, return a promise"

[10:48:13.0997] <ljharb>
"an object containing a promise" is definitely not a promise :-)

[10:48:53.0680] <shu>
in particular, Atomics.waitAsync *needs* to fail fast because it's built to mutexes -- you can't wait until the next microtask tick to find out you couldn't acquire the lock and need to go into the slow path 

[10:49:01.0138] <Kris Kowal>
> <@ljharb:matrix.org> the language has explicit decided with `async function` that sync exceptions should *never* be thrown from something that returns a promise. there's a few exceptions, i think, if you're calling something on the wrong receiver, but generally we should avoid that

And also the Promise constructor.

[10:49:04.0650] <shu>
so, instead of always returning a Promise it does this wrapping

[10:49:34.0656] <ptomato>
fair enough. I got misled by the first sentence of MDN on Atomics.waitAsync: "The static Atomics.waitAsync() method waits asynchronously on a shared memory location and returns a Promise."

[10:49:48.0595] <shu>
it waits asynchronously if it waits at all

[10:49:52.0802] <ptomato>
reading further down, you are right that it actually does not return a Promise

[10:49:56.0835] <shu>
if it doesn't wait, you can find out synchronously

[10:52:27.0581] <ptomato>
> <@ljharb:matrix.org> the language has explicit decided with `async function` that sync exceptions should *never* be thrown from something that returns a promise. there's a few exceptions, i think, if you're calling something on the wrong receiver, but generally we should avoid that

is there documentation for this decision? seems like a good thing to put in https://github.com/tc39/how-we-work/pull/119 once that document is established

[10:52:34.0713] <shu>
all that said i love zalgo

[10:52:36.0957] <shu>
i wish we had zalgo

[10:52:38.0139] <shu>
but alas

[11:02:17.0463] <ptomato>
well, in lieu of spec conventions, if anyone has a pointer to context about that decision, I'd be happy to read more. maybe I'll write a blog post on this or something

[11:03:14.0094] <joepie91 ðŸ³ï¸â€ðŸŒˆ>
ptomato: https://blog.izs.me/2013/08/designing-apis-for-asynchrony/ is pretty much the canonical source on this topic

[11:03:52.0080] <ptomato>
thanks, but I linked that document above already ðŸ˜„

[11:04:01.0652] <joepie91 ðŸ³ï¸â€ðŸŒˆ>
oh, sorry.

[11:04:08.0483] <joepie91 ðŸ³ï¸â€ðŸŒˆ>
only half paying attention today

[11:04:34.0451] <ptomato>
sync exceptions are not Zalgo according to that definition, so that's why I'm interested in the context of where we decided to depart from that

[11:05:42.0572] <joepie91 ðŸ³ï¸â€ðŸŒˆ>
I'm unsure of the exact process behind that decision, but it does meet the *principles* behind zalgo; errors that are sometimes synchronous and sometimes asynchronous make it difficult to reason about the behaviour of a function

[11:09:17.0208] <ptomato>
I tend to agree, although the article (and the one from Havoc Pennington before it) concentrates, rightly IMO, on the situation where a callback is called sometimes synchronously and sometimes asynchronously, which is much, much worse

[11:10:09.0477] <Ashley Claymore>
I found it more of an issue when `.then` was more common. Would frequently see code like `.catch(handleError)` but sometimes the code would sync throw and that wasnâ€™t handled.
Now `await` is here itâ€™s less common, and code uses a catch block for both paths. But still seems like a good principle to follow 

[11:11:30.0057] <ptomato>
it's effectively a slightly different question; is it OK for the callback to not be called at all? (and I think there is good reason to answer no)

[11:13:51.0054] <ptomato>
which is apparently also what TC39 has concluded as well

[11:17:58.0860] <Ashley Claymore>
Many people, myself included, use zalgo also for when an api always calls the callback, but can either get the call before the outer call returns (current tick) or after (fresh tick)

[11:19:28.0254] <Ashley Claymore>
I think it is ok to further expand that to: when will the error information be available

[11:19:59.0420] <Ashley Claymore>
cuts down code paths if always async

