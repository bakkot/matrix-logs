2022-11-02
[04:24:25.0724] <Domenic>
Anyone want to help back me up on https://github.com/web-platform-tests/wpt/pull/36746 ? The perennial confusion about the vague spec language like "For each own property key P of O"

[04:42:03.0275] <annevk>
Domenic: I think I agree with your conclusion, unless `OrdinaryOwnPropertyKeys` actually does something with the hook we do override, there's no reason to expect there would be additional own properties.

[04:42:29.0127] <annevk>
(Now whether that's good or bad, ...)


2022-11-07
[10:38:01.0228] <ptomato>
I'm looking into the Array.fromAsync proposal and have a question about what people's understanding of "Zalgo" is (to explain the [jargon](https://blog.izs.me/2013/08/designing-apis-for-asynchrony/), Zalgo is a reference to a meme, that is used as shorthand for the situation where an async operation sometimes calls a callback and sometimes doesn't)

[10:39:11.0388] <ptomato>
is throwing an error immediately, on bad input, Zalgo?

[10:40:14.0234] <ptomato>
i.e.
```js
function myfunc(input) {
  if (isBad(input)) throw new Error('bad!');
  return promiseFromAsyncOperation(input);
}
```

[10:41:12.0352] <ptomato>
the Array.fromAsync proposal [says yes](https://github.com/tc39/proposal-array-from-async#errors) and takes care to check its input only inside its async closure, which means rejecting the promise, not throwing an error synchronously

[10:41:51.0206] <ptomato>
Atomics.waitAsync, on the other hand, does throw errors synchronously on bad input: (steps 1 and 2 of https://tc39.es/proposal-atomics-wait-async/#sec-dowait)

[10:43:21.0323] <ptomato>
reading the [original](https://blog.izs.me/2013/08/designing-apis-for-asynchrony/) [definitions](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/) of Zalgo, I'd say this is not Zalgo as originally defined

[10:44:12.0226] <ptomato>
however, maybe it is still desirable to do one or the other; in which case we should probably adjust one of these two proposals

[10:45:06.0162] <Kris Kowal>
Zalgo in short is a combinatoric explosion of behaviors that may be either synchronous or anachronous, such that it is not practical to test every combination that will be seen in production.

[10:46:35.0793] <Kris Kowal>
Vetting inputs is I believe debatable. It depends on whether the errant behavior can possibly vary at runtime.

[10:47:05.0899] <Kris Kowal>
Being JavaScript, it almost certainly can.

[10:47:15.0497] <ljharb>
the language has explicit decided with `async function` that sync exceptions should *never* be thrown from something that returns a promise. there's a few exceptions, i think, if you're calling something on the wrong receiver, but generally we should avoid that

[10:47:26.0709] <bakkot>
ptomato: I would say that Atomics.waitAsync is actually a sync function, despite the name

[10:47:35.0970] <bakkot>
it does not return a promise; it returns an object which is synchronously usable

[10:47:37.0128] <ljharb>
can it return a promise?

[10:47:39.0233] <ljharb>
ah ok

[10:47:42.0632] <ljharb>
then i would agree

[10:47:49.0999] <bakkot>
(one of the properties of that object can be a promise)

[10:47:57.0568] <shu>
Atomics.waitAsync is the way it is explicitly to avoid zalgo

[10:47:58.0169] <ljharb>
zalgo is basically "always, or never, return a promise"

[10:48:13.0997] <ljharb>
"an object containing a promise" is definitely not a promise :-)

[10:48:53.0680] <shu>
in particular, Atomics.waitAsync *needs* to fail fast because it's built to mutexes -- you can't wait until the next microtask tick to find out you couldn't acquire the lock and need to go into the slow path 

[10:49:01.0138] <Kris Kowal>
> <@ljharb:matrix.org> the language has explicit decided with `async function` that sync exceptions should *never* be thrown from something that returns a promise. there's a few exceptions, i think, if you're calling something on the wrong receiver, but generally we should avoid that

And also the Promise constructor.

[10:49:04.0650] <shu>
so, instead of always returning a Promise it does this wrapping

[10:49:34.0656] <ptomato>
fair enough. I got misled by the first sentence of MDN on Atomics.waitAsync: "The static Atomics.waitAsync() method waits asynchronously on a shared memory location and returns a Promise."

[10:49:48.0595] <shu>
it waits asynchronously if it waits at all

[10:49:52.0802] <ptomato>
reading further down, you are right that it actually does not return a Promise

[10:49:56.0835] <shu>
if it doesn't wait, you can find out synchronously

