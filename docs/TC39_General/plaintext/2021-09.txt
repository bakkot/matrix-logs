2021-09-01
[03:39:35.0977] <jschoi>
Does anyone have any background on why `Math` got so many functions like `abs` that might have gotten put in `Number`? Having trouble finding in the meeting notes; I think this might predate them. 

[04:33:15.0594] <jmdyck>
The Math object goes back to ES1

[05:16:57.0309] <jschoi>
> <@jmdyck:matrix.org> The Math object goes back to ES1

Right, and as far as I can tell, post-ES1 mathematical functions were subsequently added to Math rather than Number simply to be consistent with that status quo. Is that correct?

For example, in the notes, I see some old talk of making clz32 an instance method on Number.prototype, and later it got switched to a “static” method, presumably to avoid boxing primitive numbers. But I can’t really find any explicit reasoning why Math was chosen as its home instead of Number.

[05:20:02.0133] <Ashley Claymore>
Looks like Number.{isInteger,isSafeInterger} and Math.{sign,trunc,log10,hypot} were added in ES6

[05:20:22.0420] <Ashley Claymore>
* Looks like Number.{isInteger,isSafeInteger} and Math.{sign,trunc,log10,hypot} were added in ES6

[05:21:07.0387] <Ashley Claymore>
Those homes seem logical, at least to me.

[05:54:11.0731] <jschoi>
> <@aclaymore:matrix.org> Those homes seem logical, at least to me.

Yeah. An issue I’m going to raise during my BigInt Math presentation is that of `max` (and `min` and `hypot`). The issue is that if we simply extend `Math.max` to accept BigInts, then `Math.max(…arrOfBigInts)` would unexpectedly return `+Infinity` whenever `arrOfBigInts` happens to be empty—this would basically be an unexpected implicit type conversion from an array of BigInts to a Number value. 

The choices I see are to either add a separate `Math.bigMax` function (and `bigMin` and `bigHypot`)…or add a `BigInt.max` method (in which case…why don’t we have `Number.max`—and then what about the other `Math` functions, do they get copied to `Number` and `BigInt` too?). So that’s why I’m wondering about the original “philosophy” behind `Number` versus `Math`.

[05:55:10.0974] <jschoi>
All the other `Math` methods can be extended for BigInts with no conversion problems. It’s just those three variadic functions…

[06:12:44.0277] <jschoi>
* > <@aclaymore:matrix.org> Those homes seem logical, at least to me.

Yeah. An issue I’m going to raise during my BigInt Math presentation is that of `max` (and `min` and `hypot`). The issue is that if we simply extend `Math.max` to accept BigInts, then `Math.max(…arrOfBigInts)` would unexpectedly return `+Infinity` whenever `arrOfBigInts` happens to be empty—this would basically be an unexpected implicit type conversion from an array of BigInts to a Number value. 

The choices I see are to either add a separate `Math.bigMax` function (and `bigMin` and `bigHypot`)…or add a `BigInt.max` method (in which case…why don’t we have `Number.max`—and then what about the other `Math` functions, do they get copied to `Number` and `BigInt` too?).

[06:12:53.0061] <jschoi>
* So that’s why I’m wondering about the original “philosophy” behind `Number` versus `Math`. All the other `Math` methods can be extended for BigInts with no conversion problems. It’s just those three variadic functions…

[06:14:42.0623] <jmdyck>
Note that max and min weren't variadic originally, so even if they'd anticipated other numeric types, there wouldn't have been that reason to put them in Number. 

[06:17:56.0630] <jschoi>
Yeah—I suppose I’m wondering if anyone knows the reasoning behind the original decision to separate `Math` and `Number` functions in the first place. The original philosophy. Perhaps that would help inform this decision. 

[06:18:32.0196] <jschoi>
* Yeah—I suppose I’m wondering if anyone knows the reasoning behind the original decision to separate `Math` and `Number` functions in the first place. The original philosophy behind ES1 `Math.abs` rather than `Number.abs`. Perhaps that would help inform this decision. 

[06:42:56.0466] <Domenic>
Totally uninformed guess: Brendan was used to C's `#include <math.h>` as the way to get access to functions like max()/abs()/etc. So he carried that over to JS as using the Math namespace object to get access to functions like max()/abs()/etc.

[08:05:05.0975] <danielrosenwasser>
> <@domenicdenicola:matrix.org> Totally uninformed guess: Brendan was used to C's `#include <math.h>` as the way to get access to functions like max()/abs()/etc. So he carried that over to JS as using the Math namespace object to get access to functions like max()/abs()/etc.


alternative guess: it's on the Math class because they were trying to script java

https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html

[08:06:36.0431] <danielrosenwasser>
> <@danielrosenwasser:matrix.org> alternative guess: it's on the Math class because they were trying to script java
> 
> https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html

https://twitter.com/BrendanEich/status/1263386663679438850

[08:13:01.0356] <Domenic>
That makes more sense

[08:50:42.0506] <jschoi>


https://twitter.com/benawad/status/1263183829235269634?s=20

I wonder if a precision argument for `Math.round` might be worth pursuing………

[08:50:46.0612] <jschoi>
> <@danielrosenwasser:matrix.org> https://twitter.com/BrendanEich/status/1263386663679438850

 * > 
https://twitter.com/benawad/status/1263183829235269634?s=20

I wonder if pursuing a precision argument for `Math.round` might be worth pursuing………


[08:50:58.0817] <devsnek>
i like proto methods

[08:51:04.0199] <jschoi>
 * 

https://twitter.com/benawad/status/1263183829235269634?s=20

I wonder if a precision argument for `Math.round` might be worth pursuing………

[08:51:39.0613] <devsnek>
they also make stuff like "empty arguments" not an issue anymore

[08:52:35.0143] <bakkot>
how does a proto method make sense for max?

[08:52:47.0524] <devsnek>
`a.max(...others)`

[08:52:54.0169] <devsnek>
if others is empty you return a instead of Infinity

[08:52:54.0949] <bakkot>
... no

[08:53:09.0100] <devsnek>
?

[08:54:16.0457] <bakkot>
uhh I guess I will just say that I find that extremely aesthetically distasteful

[08:54:38.0021] <ryzokuken>
static methods are nice though

[08:54:46.0548] <ryzokuken>
`Number.max(...args)`

[08:54:50.0675] <devsnek>
static methods make you have to care about which item you're dealing with

[08:55:03.0591] <devsnek>
 * static methods make you have to care about which type you're dealing with

[08:55:07.0978] <devsnek>
like how we do Type(x)::foo in the spec

[08:55:40.0094] <devsnek>
i guess you could do `a.constructor.max(a, b)`

[08:56:04.0491] <ryzokuken>
oh right

[08:56:24.0110] <ryzokuken>
but I do still like the idea of polymorphic functions that work on mixed lists

[08:56:32.0201] <ryzokuken>
so namespaced makes sense for those

[08:56:54.0664] <devsnek>
i mean they could still be polymorphic in cases where that makes sense

[08:57:37.0148] <ryzokuken>
proto functions, sure, but for static methods it might not be great to make them polymorphic?

