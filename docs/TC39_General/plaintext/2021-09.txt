2021-09-01
[03:39:35.0977] <jschoi>
Does anyone have any background on why `Math` got so many functions like `abs` that might have gotten put in `Number`? Having trouble finding in the meeting notes; I think this might predate them. 

[04:33:15.0594] <jmdyck>
The Math object goes back to ES1

[05:16:57.0309] <jschoi>
> <@jmdyck:matrix.org> The Math object goes back to ES1

Right, and as far as I can tell, post-ES1 mathematical functions were subsequently added to Math rather than Number simply to be consistent with that status quo. Is that correct?

For example, in the notes, I see some old talk of making clz32 an instance method on Number.prototype, and later it got switched to a “static” method, presumably to avoid boxing primitive numbers. But I can’t really find any explicit reasoning why Math was chosen as its home instead of Number.

[05:20:02.0133] <Ashley Claymore>
Looks like Number.{isInteger,isSafeInterger} and Math.{sign,trunc,log10,hypot} were added in ES6

[05:20:22.0420] <Ashley Claymore>
* Looks like Number.{isInteger,isSafeInteger} and Math.{sign,trunc,log10,hypot} were added in ES6

[05:21:07.0387] <Ashley Claymore>
Those homes seem logical, at least to me.

[05:54:11.0731] <jschoi>
> <@aclaymore:matrix.org> Those homes seem logical, at least to me.

Yeah. An issue I’m going to raise during my BigInt Math presentation is that of `max` (and `min` and `hypot`). The issue is that if we simply extend `Math.max` to accept BigInts, then `Math.max(…arrOfBigInts)` would unexpectedly return `+Infinity` whenever `arrOfBigInts` happens to be empty—this would basically be an unexpected implicit type conversion from an array of BigInts to a Number value. 

The choices I see are to either add a separate `Math.bigMax` function (and `bigMin` and `bigHypot`)…or add a `BigInt.max` method (in which case…why don’t we have `Number.max`—and then what about the other `Math` functions, do they get copied to `Number` and `BigInt` too?). So that’s why I’m wondering about the original “philosophy” behind `Number` versus `Math`.

[05:55:10.0974] <jschoi>
All the other `Math` methods can be extended for BigInts with no conversion problems. It’s just those three variadic functions…

[06:12:44.0277] <jschoi>
* > <@aclaymore:matrix.org> Those homes seem logical, at least to me.

Yeah. An issue I’m going to raise during my BigInt Math presentation is that of `max` (and `min` and `hypot`). The issue is that if we simply extend `Math.max` to accept BigInts, then `Math.max(…arrOfBigInts)` would unexpectedly return `+Infinity` whenever `arrOfBigInts` happens to be empty—this would basically be an unexpected implicit type conversion from an array of BigInts to a Number value. 

The choices I see are to either add a separate `Math.bigMax` function (and `bigMin` and `bigHypot`)…or add a `BigInt.max` method (in which case…why don’t we have `Number.max`—and then what about the other `Math` functions, do they get copied to `Number` and `BigInt` too?).

[06:12:53.0061] <jschoi>
* So that’s why I’m wondering about the original “philosophy” behind `Number` versus `Math`. All the other `Math` methods can be extended for BigInts with no conversion problems. It’s just those three variadic functions…

[06:14:42.0623] <jmdyck>
Note that max and min weren't variadic originally, so even if they'd anticipated other numeric types, there wouldn't have been that reason to put them in Number. 

[06:17:56.0630] <jschoi>
Yeah—I suppose I’m wondering if anyone knows the reasoning behind the original decision to separate `Math` and `Number` functions in the first place. The original philosophy. Perhaps that would help inform this decision. 

[06:18:32.0196] <jschoi>
* Yeah—I suppose I’m wondering if anyone knows the reasoning behind the original decision to separate `Math` and `Number` functions in the first place. The original philosophy behind ES1 `Math.abs` rather than `Number.abs`. Perhaps that would help inform this decision. 

[06:42:56.0466] <Domenic>
Totally uninformed guess: Brendan was used to C's `#include <math.h>` as the way to get access to functions like max()/abs()/etc. So he carried that over to JS as using the Math namespace object to get access to functions like max()/abs()/etc.

[08:05:05.0975] <danielrosenwasser>
> <@domenicdenicola:matrix.org> Totally uninformed guess: Brendan was used to C's `#include <math.h>` as the way to get access to functions like max()/abs()/etc. So he carried that over to JS as using the Math namespace object to get access to functions like max()/abs()/etc.


alternative guess: it's on the Math class because they were trying to script java

https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html

[08:06:36.0431] <danielrosenwasser>
> <@danielrosenwasser:matrix.org> alternative guess: it's on the Math class because they were trying to script java
> 
> https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html

https://twitter.com/BrendanEich/status/1263386663679438850

[08:13:01.0356] <Domenic>
That makes more sense

[08:50:42.0506] <jschoi>


https://twitter.com/benawad/status/1263183829235269634?s=20

I wonder if a precision argument for `Math.round` might be worth pursuing………

[08:50:46.0612] <jschoi>
> <@danielrosenwasser:matrix.org> https://twitter.com/BrendanEich/status/1263386663679438850

 * > 
https://twitter.com/benawad/status/1263183829235269634?s=20

I wonder if pursuing a precision argument for `Math.round` might be worth pursuing………


[08:50:58.0817] <devsnek>
i like proto methods

[08:51:04.0199] <jschoi>
 * 

https://twitter.com/benawad/status/1263183829235269634?s=20

I wonder if a precision argument for `Math.round` might be worth pursuing………

[08:51:39.0613] <devsnek>
they also make stuff like "empty arguments" not an issue anymore

[08:52:35.0143] <bakkot>
how does a proto method make sense for max?

[08:52:47.0524] <devsnek>
`a.max(...others)`

[08:52:54.0169] <devsnek>
if others is empty you return a instead of Infinity

[08:52:54.0949] <bakkot>
... no

[08:53:09.0100] <devsnek>
?

[08:54:16.0457] <bakkot>
uhh I guess I will just say that I find that extremely aesthetically distasteful

[08:54:38.0021] <ryzokuken>
static methods are nice though

[08:54:46.0548] <ryzokuken>
`Number.max(...args)`

[08:54:50.0675] <devsnek>
static methods make you have to care about which item you're dealing with

[08:55:03.0591] <devsnek>
 * static methods make you have to care about which type you're dealing with

[08:55:07.0978] <devsnek>
like how we do Type(x)::foo in the spec

[08:55:40.0094] <devsnek>
i guess you could do `a.constructor.max(a, b)`

[08:56:04.0491] <ryzokuken>
oh right

[08:56:24.0110] <ryzokuken>
but I do still like the idea of polymorphic functions that work on mixed lists

[08:56:32.0201] <ryzokuken>
so namespaced makes sense for those

[08:56:54.0664] <devsnek>
i mean they could still be polymorphic in cases where that makes sense

[08:57:37.0148] <ryzokuken>
proto functions, sure, but for static methods it might not be great to make them polymorphic?

[15:12:20.0413] <devsnek>
so class fields use define instead of set right

[15:12:27.0513] <devsnek>
so there's no way for the superclass to see that happen

[15:12:59.0150] <bakkot>
in general superclasses do not see things subclasses do, correct

[15:13:05.0697] <bakkot>
same goes for methods defined by the subclass

[15:13:12.0276] <devsnek>
there's a cool python library i want to mimic

[15:13:15.0698] <devsnek>
where you can do like

[15:13:33.0855] <devsnek>
```py
class Foo(lib.Model):
  field = lib.Int()
  field = lib.String()
```

[15:13:44.0289] <devsnek>
and that builds a validator on foo that you can use on incoming requests

[15:13:52.0846] <devsnek>
and you can also add methods and stuff to the instance cuz its a normal class

[15:14:09.0411] <devsnek>
but it requires the superclass knowing the fields to build the validator

[15:14:26.0339] <devsnek>
i think in python that's done using metaclasses

[15:14:57.0586] <bakkot>
that seems like a use case for decorators, at a glance

[15:15:08.0055] <devsnek>
hmmm interesting

[15:15:31.0984] <devsnek>
where would the data from the decorators be stored

[15:17:11.0715] <bakkot>
wait, maybe I'm not understanding

[15:17:18.0631] <bakkot>
how do you use `Foo` after setting it up like that?

[15:17:22.0699] <bakkot>
or do you have a link to the library?

[15:17:38.0871] <devsnek>
not a public library unfortunately

[15:17:45.0557] <devsnek>
but you can do `Foo(some raw data)`

[15:18:09.0788] <devsnek>
and it will attempt to pull the fields from the raw data and either coerce them into something matching what you specified (Int/String/etc) or throw

[15:18:41.0784] <devsnek>
 * ```py
class Foo(lib.Model):
  field1 = lib.Int()
  field2 = lib.String()
```

[15:19:29.0879] <devsnek>
its nothing too magical, i'm just trying to imagine how i'd duplicate the sort of declarative schema info pattern in js

[15:21:26.0038] <devsnek>
i guess there could be like `Foo._fields` that the decorators populate, and then lib.Model can check for `this._fields` when its being used?

[15:21:39.0815] <devsnek>
or Symbol('lib.Fields') would be more proper i guess :P

[15:22:36.0847] <bakkot>
the current decorator proposal has a concept of metadata, which I think is intended to be used for that sort of thing?

[15:22:46.0173] <bakkot>
I haven't been following too closely though

[15:25:01.0888] <bakkot>
I think the thing I'd actually do with a decorator would be more like

```
@fields({ field1: lib.Int, field2: lib.String })
class Foo {
 ...
}
```
where `@fields` would replace the class with a subclass which called `super` and then validated and installed the fields named by the decorator

[15:25:17.0303] <devsnek>
this seems like it could work https://gc.gy/e5d1ed0d-50fd-4394-8cfd-4f28fe049b5f.png

[15:25:25.0885] <bakkot>
you can probably do something closer to the Python version where the fields are inline, it's just not how I'd write it

[15:26:12.0106] <devsnek>
yeah, the thing that annoys me about schema libraries in js i'm familiar with is that they're all out of line

[15:48:10.0192] <devsnek>
this syntax is rough lol https://gc.gy/3ef68645-496c-41e2-b2db-15eac94f8244.png

[16:08:58.0761] <devsnek>
can a decorator remove a field

[16:09:56.0319] <devsnek>
this define behavior is terrible we shouldn't have done it lol

