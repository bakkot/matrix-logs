2021-09-01
[03:39:35.0977] <jschoi>
Does anyone have any background on why `Math` got so many functions like `abs` that might have gotten put in `Number`? Having trouble finding in the meeting notes; I think this might predate them. 

[04:33:15.0594] <jmdyck>
The Math object goes back to ES1

[05:16:57.0309] <jschoi>
> <@jmdyck:matrix.org> The Math object goes back to ES1

Right, and as far as I can tell, post-ES1 mathematical functions were subsequently added to Math rather than Number simply to be consistent with that status quo. Is that correct?

For example, in the notes, I see some old talk of making clz32 an instance method on Number.prototype, and later it got switched to a “static” method, presumably to avoid boxing primitive numbers. But I can’t really find any explicit reasoning why Math was chosen as its home instead of Number.

[05:20:02.0133] <Ashley Claymore>
Looks like Number.{isInteger,isSafeInterger} and Math.{sign,trunc,log10,hypot} were added in ES6

[05:20:22.0420] <Ashley Claymore>
* Looks like Number.{isInteger,isSafeInteger} and Math.{sign,trunc,log10,hypot} were added in ES6

[05:21:07.0387] <Ashley Claymore>
Those homes seem logical, at least to me.

[05:54:11.0731] <jschoi>
> <@aclaymore:matrix.org> Those homes seem logical, at least to me.

Yeah. An issue I’m going to raise during my BigInt Math presentation is that of `max` (and `min` and `hypot`). The issue is that if we simply extend `Math.max` to accept BigInts, then `Math.max(…arrOfBigInts)` would unexpectedly return `+Infinity` whenever `arrOfBigInts` happens to be empty—this would basically be an unexpected implicit type conversion from an array of BigInts to a Number value. 

The choices I see are to either add a separate `Math.bigMax` function (and `bigMin` and `bigHypot`)…or add a `BigInt.max` method (in which case…why don’t we have `Number.max`—and then what about the other `Math` functions, do they get copied to `Number` and `BigInt` too?). So that’s why I’m wondering about the original “philosophy” behind `Number` versus `Math`.

[05:55:10.0974] <jschoi>
All the other `Math` methods can be extended for BigInts with no conversion problems. It’s just those three variadic functions…

[06:12:44.0277] <jschoi>
* > <@aclaymore:matrix.org> Those homes seem logical, at least to me.

Yeah. An issue I’m going to raise during my BigInt Math presentation is that of `max` (and `min` and `hypot`). The issue is that if we simply extend `Math.max` to accept BigInts, then `Math.max(…arrOfBigInts)` would unexpectedly return `+Infinity` whenever `arrOfBigInts` happens to be empty—this would basically be an unexpected implicit type conversion from an array of BigInts to a Number value. 

The choices I see are to either add a separate `Math.bigMax` function (and `bigMin` and `bigHypot`)…or add a `BigInt.max` method (in which case…why don’t we have `Number.max`—and then what about the other `Math` functions, do they get copied to `Number` and `BigInt` too?).

[06:12:53.0061] <jschoi>
* So that’s why I’m wondering about the original “philosophy” behind `Number` versus `Math`. All the other `Math` methods can be extended for BigInts with no conversion problems. It’s just those three variadic functions…

[06:14:42.0623] <jmdyck>
Note that max and min weren't variadic originally, so even if they'd anticipated other numeric types, there wouldn't have been that reason to put them in Number. 

[06:17:56.0630] <jschoi>
Yeah—I suppose I’m wondering if anyone knows the reasoning behind the original decision to separate `Math` and `Number` functions in the first place. The original philosophy. Perhaps that would help inform this decision. 

[06:18:32.0196] <jschoi>
* Yeah—I suppose I’m wondering if anyone knows the reasoning behind the original decision to separate `Math` and `Number` functions in the first place. The original philosophy behind ES1 `Math.abs` rather than `Number.abs`. Perhaps that would help inform this decision. 

[06:42:56.0466] <Domenic>
Totally uninformed guess: Brendan was used to C's `#include <math.h>` as the way to get access to functions like max()/abs()/etc. So he carried that over to JS as using the Math namespace object to get access to functions like max()/abs()/etc.

[08:05:05.0975] <danielrosenwasser>
> <@domenicdenicola:matrix.org> Totally uninformed guess: Brendan was used to C's `#include <math.h>` as the way to get access to functions like max()/abs()/etc. So he carried that over to JS as using the Math namespace object to get access to functions like max()/abs()/etc.


alternative guess: it's on the Math class because they were trying to script java

https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html

[08:06:36.0431] <danielrosenwasser>
> <@danielrosenwasser:matrix.org> alternative guess: it's on the Math class because they were trying to script java
> 
> https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html

https://twitter.com/BrendanEich/status/1263386663679438850

[08:13:01.0356] <Domenic>
That makes more sense

[08:50:42.0506] <jschoi>


https://twitter.com/benawad/status/1263183829235269634?s=20

I wonder if a precision argument for `Math.round` might be worth pursuing………

[08:50:46.0612] <jschoi>
> <@danielrosenwasser:matrix.org> https://twitter.com/BrendanEich/status/1263386663679438850

 * > 
https://twitter.com/benawad/status/1263183829235269634?s=20

I wonder if pursuing a precision argument for `Math.round` might be worth pursuing………


[08:50:58.0817] <devsnek>
i like proto methods

[08:51:04.0199] <jschoi>
 * 

https://twitter.com/benawad/status/1263183829235269634?s=20

I wonder if a precision argument for `Math.round` might be worth pursuing………

[08:51:39.0613] <devsnek>
they also make stuff like "empty arguments" not an issue anymore

[08:52:35.0143] <bakkot>
how does a proto method make sense for max?

[08:52:47.0524] <devsnek>
`a.max(...others)`

[08:52:54.0169] <devsnek>
if others is empty you return a instead of Infinity

[08:52:54.0949] <bakkot>
... no

[08:53:09.0100] <devsnek>
?

[08:54:16.0457] <bakkot>
uhh I guess I will just say that I find that extremely aesthetically distasteful

[08:54:38.0021] <ryzokuken>
static methods are nice though

[08:54:46.0548] <ryzokuken>
`Number.max(...args)`

[08:54:50.0675] <devsnek>
static methods make you have to care about which item you're dealing with

[08:55:03.0591] <devsnek>
 * static methods make you have to care about which type you're dealing with

[08:55:07.0978] <devsnek>
like how we do Type(x)::foo in the spec

[08:55:40.0094] <devsnek>
i guess you could do `a.constructor.max(a, b)`

[08:56:04.0491] <ryzokuken>
oh right

[08:56:24.0110] <ryzokuken>
but I do still like the idea of polymorphic functions that work on mixed lists

[08:56:32.0201] <ryzokuken>
so namespaced makes sense for those

[08:56:54.0664] <devsnek>
i mean they could still be polymorphic in cases where that makes sense

[08:57:37.0148] <ryzokuken>
proto functions, sure, but for static methods it might not be great to make them polymorphic?

[15:12:20.0413] <devsnek>
so class fields use define instead of set right

[15:12:27.0513] <devsnek>
so there's no way for the superclass to see that happen

[15:12:59.0150] <bakkot>
in general superclasses do not see things subclasses do, correct

[15:13:05.0697] <bakkot>
same goes for methods defined by the subclass

[15:13:12.0276] <devsnek>
there's a cool python library i want to mimic

[15:13:15.0698] <devsnek>
where you can do like

[15:13:33.0855] <devsnek>
```py
class Foo(lib.Model):
  field = lib.Int()
  field = lib.String()
```

[15:13:44.0289] <devsnek>
and that builds a validator on foo that you can use on incoming requests

[15:13:52.0846] <devsnek>
and you can also add methods and stuff to the instance cuz its a normal class

[15:14:09.0411] <devsnek>
but it requires the superclass knowing the fields to build the validator

[15:14:26.0339] <devsnek>
i think in python that's done using metaclasses

[15:14:57.0586] <bakkot>
that seems like a use case for decorators, at a glance

[15:15:08.0055] <devsnek>
hmmm interesting

[15:15:31.0984] <devsnek>
where would the data from the decorators be stored

[15:17:11.0715] <bakkot>
wait, maybe I'm not understanding

[15:17:18.0631] <bakkot>
how do you use `Foo` after setting it up like that?

[15:17:22.0699] <bakkot>
or do you have a link to the library?

[15:17:38.0871] <devsnek>
not a public library unfortunately

[15:17:45.0557] <devsnek>
but you can do `Foo(some raw data)`

[15:18:09.0788] <devsnek>
and it will attempt to pull the fields from the raw data and either coerce them into something matching what you specified (Int/String/etc) or throw

[15:18:41.0784] <devsnek>
 * ```py
class Foo(lib.Model):
  field1 = lib.Int()
  field2 = lib.String()
```

[15:19:29.0879] <devsnek>
its nothing too magical, i'm just trying to imagine how i'd duplicate the sort of declarative schema info pattern in js

[15:21:26.0038] <devsnek>
i guess there could be like `Foo._fields` that the decorators populate, and then lib.Model can check for `this._fields` when its being used?

[15:21:39.0815] <devsnek>
or Symbol('lib.Fields') would be more proper i guess :P

[15:22:36.0847] <bakkot>
the current decorator proposal has a concept of metadata, which I think is intended to be used for that sort of thing?

[15:22:46.0173] <bakkot>
I haven't been following too closely though

[15:25:01.0888] <bakkot>
I think the thing I'd actually do with a decorator would be more like

```
@fields({ field1: lib.Int, field2: lib.String })
class Foo {
 ...
}
```
where `@fields` would replace the class with a subclass which called `super` and then validated and installed the fields named by the decorator

[15:25:17.0303] <devsnek>
this seems like it could work https://gc.gy/e5d1ed0d-50fd-4394-8cfd-4f28fe049b5f.png

[15:25:25.0885] <bakkot>
you can probably do something closer to the Python version where the fields are inline, it's just not how I'd write it

[15:26:12.0106] <devsnek>
yeah, the thing that annoys me about schema libraries in js i'm familiar with is that they're all out of line

[15:48:10.0192] <devsnek>
this syntax is rough lol https://gc.gy/3ef68645-496c-41e2-b2db-15eac94f8244.png

[16:08:58.0761] <devsnek>
can a decorator remove a field

[16:09:56.0319] <devsnek>
this define behavior is terrible we shouldn't have done it lol

[16:15:24.0113] <bakkot>
having `[[Set]]` would not make this task any easier, because you can't have a setter for arbitrary properties

[16:15:56.0573] <bakkot>
you have to use a proxy trap for that, and you can trap `[[DefineOwnProperty]]` just as readily as `[[Set]]` if you're using a proxy

[16:16:45.0819] <bakkot>
anyway I don't think you can have a decorator which removes a field, no; in fact I think that was basically a design constraint for it to get through committee

[16:18:08.0191] <devsnek>
that means the base constructor can't set the new field values after they're schema validated

[16:18:18.0414] <devsnek>
cuz the define overwrites it

[16:19:01.0491] <bakkot>
... right, base classes run before subclasses, that's how that works

[16:19:10.0975] <bakkot>
[[Set]] would not help you there because the base class would not know about the fields

[16:19:53.0510] <devsnek>
well my train of thinking was, using [[set]] would make it reasonable to not perform any operation for `x;` instead of doing `this.x = undefined;`

[16:20:04.0571] <devsnek>
but it doesn't matter much now

[16:21:06.0436] <bakkot>
also I think this works: https://gist.github.com/bakkot/71bb439da868db191467762a82e85e61

[16:22:12.0465] <devsnek>
ah interesting

[16:22:16.0167] <bakkot>
not sure if it's what you were looking for though

[16:22:31.0716] <devsnek>
the extra constructor certainly gets around this

[16:22:36.0851] <devsnek>
thanks for the idea

[16:30:19.0958] <bakkot>
the only annoying part is that you wouldn't be able to use the fields in C's constructor, if you were trying to do something there

[16:30:27.0641] <bakkot>
I don't see a way around that without requiring a tiny bit of boilerplate

[16:31:10.0321] <bakkot>
i.e. something like

```
@data
class C {
  x = data.int;
  constructor(obj) {
    data.init(obj);
    // other stuff
  }
}
```

[16:31:41.0464] <bakkot>
... actually you don't even need the decorator at that point

[16:31:51.0570] <bakkot>
you can do that today

[16:34:05.0766] <bakkot>
https://gist.github.com/bakkot/9b22363769a8d88934d08d2b597dd986


2021-09-02
[23:21:37.0659] <bakkot>
shu: for resizable array buffers, was there any thought of making TA.p.set(other buffer) grow the target buffer to fit the new data?

[23:24:04.0029] <bakkot>
I guess the expectation is that users can just manually call `.resize` first, which is not so bad

[07:27:15.0121] <shu>
bakkot: i can see an argument for either the current behavior or growing behavior if the argument is growable

[07:27:33.0718] <shu>
but i haven't actually thought too much about it


2021-09-03
[17:15:56.0797] <jschoi>
In the spec, is there a way to split an abstract List into a first element and another List of the other elements?

[17:16:20.0077] <jschoi>
“Let «_first_, ..._rest_» be _list_”…

[17:16:30.0159] <bakkot>
Nope

[17:18:55.0768] <jschoi>
I’ll just say, “Let _rest_ be the List of all elements of _list_ except its first.”

[17:20:54.0006] <bakkot>
If you own the list, you could just mutate it

[17:21:14.0483] <jschoi>
Well, how would I express that in spec language?

[17:21:20.0395] <jschoi>
It’d still be prose, right?

[17:21:22.0636] <bakkot>
i. Let r be the first element of remaining.
ii. Remove the first element from remaining.

[17:21:30.0601] <jschoi>
Ah…

[17:21:43.0851] <bakkot>
or

[17:21:44.0770] <bakkot>
ii. Let kValue be the first element of values and remove that element from values.

[17:21:57.0463] <jschoi>
Nice. Thank you!

[17:22:45.0194] <bakkot>
Which thing are you writing that needs this? For bigint math I'd think you could just copy the Number ones

[17:23:17.0818] <jschoi>
`Math.hypot`. Killing `Math.bigHypot` and merging its behavior into `hypot`.

[17:23:32.0520] <jschoi>
Dispatching on the type of the first argument.

[17:24:18.0147] <bakkot>
Math.hypot just iterates over the list; that seems better than splitting it

[17:24:19.0116] <jschoi>
Coercing the rest of the arguments.

[17:24:41.0325] <jschoi>
 * Well, it needs to coerce the rest of the arguments based on the first argument’s type, though.

[17:28:37.0662] <jschoi>
https://github.com/js-choi/proposal-bigint-math/commit/2b865923a97879b3807b27fbf7f3d275f9928e40

[17:29:28.0025] <bakkot>
Yeah but you don't need to take the tail of the list for that.

I'd do something like
```
1. If _args_ is empty, return +0𝔽.
1. If Type(_args_[0]) is BigInt, let _isBigInt_ be *true*.
1. Else, let _isBigInt_ be *false*.
1. For each element _arg_ of _args_, do
  1. If _isBigInt_ is *true*, then let _n_ be ? ToBigInt(_arg_)
  1. Else, let _n_ be ? ToNumber(_arg_).
```
etc

[17:29:48.0869] <bakkot>
there's other ways you can write it but none of them obviously require you to construct the list-except-head

[17:29:59.0977] <bakkot>
just to peek at the head to determine which coercer to use

[17:31:01.0713] <jschoi>
 * https://github.com/js-choi/proposal-bigint-math/commit/b5ece4e1543c35375f13f02653c0a7119ed0c495

[17:31:26.0691] <jschoi>
Wouldn’t that cause an unnecessary call to ToBigInt or ToNumber for the first element?

[17:31:41.0571] <bakkot>
Type() does not perform coercion, no

[17:31:46.0871] <jschoi>
 * Wouldn’t that cause an unnecessary call to ToBigInt or ToNumber for the first element?

[17:32:17.0939] <bakkot>
Though, I guess you probably want ToNumeric?

[17:32:20.0322] <jschoi>
I mean ToBigInt, though. It’s calling ToBigInt on _args_[0] unnecessarily. 

[17:32:35.0224] <bakkot>
Yeah but that's unobservable

[17:32:35.0747] <jschoi>
Oh, yeah, right, ugh, I forgot.

[17:32:47.0818] <jschoi>
> <@bakkot:matrix.org> Yeah but that's unobservable

If we’re fine with that in the spec, I can change it.

[17:32:58.0636] <jschoi>
> <@bakkot:matrix.org> Yeah but that's unobservable

 * If we’re fine with unobservable redundant calls the spec, I can change it.

[17:33:09.0222] <bakkot>
If that makes the algorithm easier to read, absolutely.

[17:33:10.0999] <jschoi>
 * Oh, yeah, right, ugh, I forgot that I need to call ToNumeric on the first.

[17:40:22.0671] <jschoi>
https://github.com/js-choi/proposal-bigint-math/commit/32152ba671e6b94e9912139db5b3a31e35ad9021

[17:40:28.0053] <jschoi>
Thanks for the help, bakkot!

[17:42:20.0774] <jschoi>
…Though would it work with `Math.hypot(Object(4n))`?

[17:42:40.0479] <jschoi>
Wouldn’t the Type(_args_[0]) return Object?

[17:43:48.0857] <bakkot>
Right, that's why I suggested ToNumeric

[17:43:53.0424] <jschoi>
Ah, ah.

[17:45:10.0352] <jschoi>
So we’re fine with just replacing it with Type(ToNumeric(_args_[0])), because the extra coercion is invisible to the user.

[17:45:25.0969] <bakkot>
Well, no, that ends up being visible, unfortunately

[17:45:39.0045] <jschoi>
Ah…

[17:46:06.0151] <bakkot>
So you do probably want to pop the list after all, I'm afraid

[17:46:24.0058] <bakkot>
I hadn't thought through the fact that you'd want to ToNumeric before doing the Type

[17:46:54.0665] <jschoi>
Thanks for the big help anyway, though. 👍️

[17:54:51.0069] <jschoi>
I wonder if ToPrimitive would work…

[07:36:32.0456] <jschoi>
Could someone familiar with TypeScript type inference explain the problem being described in https://github.com/js-choi/proposal-hack-pipes/issues/18 ? I’m not sure why the type of `userOption |> map(user => user.name)(^)` cannot be inferred from `userOption` and `map`.

[07:37:46.0974] <jschoi>
It’s just the same as `map(user => user.name)(userOption)`, after all…

[07:53:44.0708] <devsnek>
does anyone else keep getting surprised that optional chaining doesn't work with assignment

[07:58:15.0257] <devsnek>
jschoi: i think they mean this https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAWwIYAcA8AVANIgVQD4AKYALkRIDdLsBKRAXiMPspNToG0BdRloT6IA3gChEkxACcAplBDSkNVABsQsgM49+zVtTUbNAOjToy9ANxiAvmLEQEmqIlTTpqAJ7NE3EQCNKAEYbXmszEk4BVlRjf3pOdy8rIA

[07:58:36.0444] <devsnek>
i'd say that's just a dumb limitation of TS though, and you can manually annotate it, so i don't think it matters

[08:04:59.0351] <jschoi>
Huh, I see. So the problem is that TypeScript cannot infer the type of even `map(user => user.name)(userOption)`…but, apparently, somehow it can infer the types in `pipe(userOption, map(user => user.name))`? 🤔 

[08:05:16.0152] <devsnek>
yeah for some reason it doesn't unify the types in the former case

[08:05:30.0501] <devsnek>
personally i'd say its probably just better for microsoft to fix that

[08:08:39.0435] <jschoi>
I wonder if they’ve tried but there’s a fundamental reason why they can’t, hmm. Anyways, thanks for help!

[08:09:02.0046] <jschoi>
* I wonder if the TypeScript team has tried adding that inference but there’s a fundamental reason why they can’t, hmm. Anyways, thanks for help!

[08:09:46.0883] <devsnek>
its weird cuz its not really even an inference, it's just unifying `unknown` and `{b: number}` :/

[08:16:53.0495] <jschoi>
> <@devsnek:matrix.org> jschoi: i think they mean this https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAWwIYAcA8AVANIgVQD4AKYALkRIDdLsBKRAXiMPspNToG0BdRloT6IA3gChEkxACcAplBDSkNVABsQsgM49+zVtTUbNAOjToy9ANxiAvmLEQEmqIlTTpqAJ7NE3EQCNKAEYbXmszEk4BVlRjf3pOdy8rIA

I’ll use your example in my reply on that issue, if that’s okay.

[08:16:59.0014] <devsnek>
sure

[08:19:56.0013] <jschoi>
Hm, maybe it’s a fundamental limitation of how TypeScript’s “type inference works left to right”.

[08:21:59.0855] <jschoi>
Perhaps in `map(user => user.name)(userOption)` it can’t unify the types of `user` and `userOption` because…I don’t know, maybe it’s somehow unidirectional, it expects a type right away in that arrow function, and it eagerly throws an error right there before moving onto `(userOption)`? I wonder how solvable this would be for the TypeScript team, but having to use `pipe` functions seems like a pretty brittle way to work around it.

[08:41:09.0506] <jschoi>
Hmmm. https://github.com/microsoft/TypeScript/issues/15680

[08:56:07.0757] <jschoi>
 * Hmmm. https://github.com/microsoft/TypeScript/issues/15680
https://github.com/microsoft/TypeScript/issues/25826
https://github.com/microsoft/TypeScript/issues/30134

[10:09:55.0358] <TabAtkins>
Okay yeah sounds like it's just "we don't actually unify types, just do some inference tricks that fail in a lot of cases", but I'm still confused why `pipe(val, map(user=>user.name))` infers properly.

[10:19:30.0030] <devsnek>
tsc continues to befuddle me

[10:20:25.0517] <devsnek>
TabAtkins: it seems to just be the order in which the graph is visited, one of those issues has an example of changing the order of arguments breaking inference 

[10:23:37.0844] <TabAtkins>
Yeah, seems like there's some special-casing thrown around to address some cases. If this becomes a big issue, I suspect TypeScript can special-case "trailing `(^)` in a pipe body" and make it work like we'd expect, even without full inference.

[10:33:12.0313] <devsnek>
apparently the swc person is writing a new typescript type checker

[10:33:17.0757] <devsnek>
maybe it can handle this properly 

[11:56:25.0153] <bakkot>
we should make `let { #x: a } = foo` work, to mean `let a = foo.#x`: y/n?

[11:57:03.0319] <bakkot>
I have seeded the emoji reacts so you can more easily just click on the appropriate one to express your opinion

[11:57:54.0506] <TabAtkins>
Tho `let {#x} = foo;` would still not work, right?

[11:59:30.0607] <bakkot>
yup

[11:59:38.0647] <bakkot>
or at least I am not proposing to allow it, and I think it should not work

[12:47:08.0944] <Domenic>
My personal opinion is that renaming while destructuring is generally distasteful, so I am not voting. (I.e. I think `let x = y.z` is clearer than `let { z: x } = y`.)

[12:53:18.0906] <devsnek>
i vote for whatever increases the number of productions in the spec


2021-09-04
[10:01:25.0570] <devsnek>
anyone here familiar with unicode? trying to figure out how to submit corrections/additions to confusables.txt

[10:01:38.0517] <devsnek>
 * anyone here familiar with unicode consortium stuff? trying to figure out how to submit corrections/additions to confusables.txt

[12:27:21.0894] <jschoi>
> <@devsnek:matrix.org> anyone here familiar with unicode consortium stuff? trying to figure out how to submit corrections/additions to confusables.txt

https://corp.unicode.org/reporting.html, I believe.

[12:27:33.0446] <jschoi>
Mark it as “errata”.


2021-09-05

2021-09-06

2021-09-07

2021-09-08
[18:23:16.0523] <babaca>

https://skidson.online/ Best AQW Private server 
AQW Is a free to play browser mmorpg you can play with your friends join us now!

Join our discord below:
https://discord.gg/ZAebPzpsbR


[18:48:17.0715] <Jack Works>
https://es.discourse.group/t/cooperative-async-function/975

[18:48:27.0144] <Jack Works>
Anyone interested in this?

