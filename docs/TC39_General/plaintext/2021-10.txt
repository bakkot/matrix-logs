2021-10-01
[17:00:01.0754] <bakkot>
we're moving progressively further in that direction with our internal tooling and it's been basically fine

[17:00:34.0404] <bakkot>
you need to do some basic conservative type analysis but at least in the code I've been working with that type analysis is feasible

[17:01:30.0942] <Justin Ridgewell>
I absolutely don’t agree. Even with a full type system, the difficulty of banning `Nodelist.p.forEach` had lead to bugs for us.

[17:02:05.0437] <Justin Ridgewell>
As soon as you cast to avoid a typecheck, we get ambiguities that let it slip back in

[17:02:46.0763] <Justin Ridgewell>
Even with a type system and full typing, it’s a difficult problem

[17:03:34.0053] <Justin Ridgewell>
Requiring us to rewrite tooling infra on top of another’s type system seems bad.

[17:04:26.0200] <Justin Ridgewell>
Devirtualized methods are simple, tiny, fast, and extremely easy to tree shake statically

[17:43:38.0070] <Justin Ridgewell>
 * Requiring us to rewrite tooling infra on top of another’s type system (even if it's as beloved as TS) seems bad.

[17:43:57.0702] <Justin Ridgewell>
 * Devirtualized methods are simple, fast, and extremely easy to tree shake statically

[18:09:11.0337] <shu>
rkirsling: actually pun was not intended!

[18:26:35.0026] <pokute>
Concerning proposed Partial Function Application, should partially applying `import()`work?

[21:42:06.0211] <TabAtkins>
The import() function is just an ordinary function, yeah? Nothing special syntactically?

[21:42:18.0554] <TabAtkins>
Assuming that's true, then yeah

[21:56:11.0629] <bakkot>
no, it is a special syntactic form, not a function

[21:56:29.0805] <bakkot>
(it has to be, since it's module-relative - it's not something you could coherently pass around)

[00:12:20.0999] <Ashley Claymore>
jschoi: maybe the readme could say how it differs from the `::` bind proposal? Unless maybe it is already obvious and I am just being slow

[00:17:16.0743] <Ashley Claymore>
 * jschoi: maybe the readme could say how it differs from the `::` bind proposal? Unless maybe it is already obvious and I am just being slow. Or is it just that there is nothing stopping there being similar proposals, lead by different groups of people? Healthy competition type of thing?

[04:24:46.0158] <jschoi>
> <@aclaymore:matrix.org> jschoi: maybe the readme could say how it differs from the `::` bind proposal? Unless maybe it is already obvious and I am just being slow. Or is it just that there is nothing stopping there being similar proposals, lead by different groups of people? Healthy competition type of thing?

Yeah, good idea. The new proposal is pretty much the same as the old bind proposal except it has no unary form. Michael has recommended to open a new repository because of the baggage with the old proposal in https://github.com/tc39/proposal-bind-operator/issues/56#issuecomment-698444297.

There’s also a Gist comparing the new proposal with the Stage-1 Extensions proposal, but it focuses on security rather than “call/bind are common”, so it’s out of date. I plan to edit it and add it to the repository later. https://gist.github.com/js-choi/eca7c67f88a2e82c3353fb11e8da46f7

[05:52:34.0745] <Ashley Claymore>
thanks for that info jschoi !


2021-10-02

2021-10-04
[08:43:20.0818] <pokute>
I made a [TypeScript PR](https://github.com/microsoft/TypeScript/pull/37973) for the new Syntatic Marker variant of Partial Application proposal. There's a [Playground link](https://www.staging-typescript.org/play?ts=4.5.0-pr-37973-15#code/PTAEAUBsEME8HMBOB7ArgOwCagGbMRNIgC4CW0koAggA42SkDG0Zy6oAFscTQM4BcIeKWIdUAIwB0jZAFtgxRgGYAnMBooayXhQC0NImT3Q6DZq3QAoEKAAqsGgFMAyo0SkaxCACV+nbnyCwMKiEtJywLJMKLzIOMTA9k6u7p7qqJCQwEoA7Co5StZgzqh0+MS8oOLIorgAFAD8ADSgAIwAlKDQWLgAfo0tHaC6eIiyvJJF1KRR6PCgxMigvADuIowcpHMLS1w8AkIiYlIy8oqq6praegYk5JC6JvRMLKRswKS8vKiOvMAALAAOYYANyI5HQXjioA0yC0OkosTYkxsAFloFtQFEvlt5lotl5GKhEIhHJDILBQJ8YYZ7hSuqZYLjQJJWcNSbwvLdoLJHMRHIhJpYZOhOcsAI6oIiOUAAXlA6NEki0K36zVAACZ2gBuSzCtixSCOSSQZDwOq8SXSur-do6yxAA) for it too! Test it out!

[08:44:20.0190] <Jack Works>
Partial application on generics? 

[08:44:32.0687] <Jack Works>
Oh on values Cool

[08:45:20.0127] <pokute>
 * I made a [TypeScript PR](https://github.com/microsoft/TypeScript/pull/37973) for the new [Syntatic Marker variant of Partial Application proposal](https://github.com/tc39/proposal-partial-application/issues/48). There's a [Playground link](https://www.staging-typescript.org/play?ts=4.5.0-pr-37973-15#code/PTAEAUBsEME8HMBOB7ArgOwCagGbMRNIgC4CW0koAggA42SkDG0Zy6oAFscTQM4BcIeKWIdUAIwB0jZAFtgxRgGYAnMBooayXhQC0NImT3Q6DZq3QAoEKAAqsGgFMAyo0SkaxCACV+nbnyCwMKiEtJywLJMKLzIOMTA9k6u7p7qqJCQwEoA7Co5StZgzqh0+MS8oOLIorgAFAD8ADSgAIwAlKDQWLgAfo0tHaC6eIiyvJJF1KRR6PCgxMigvADuIowcpHMLS1w8AkIiYlIy8oqq6praegYk5JC6JvRMLKRswKS8vKiOvMAALAAOYYANyI5HQXjioA0yC0OkosTYkxsAFloFtQFEvlt5lotl5GKhEIhHJDILBQJ8YYZ7hSuqZYLjQJJWcNSbwvLdoLJHMRHIhJpYZOhOcsAI6oIiOUAAXlA6NEki0K36zVAACZ2gBuSzCtixSCOSSQZDwOq8SXSur-do6yxAA) for it too! Test it out!


2021-10-05
[16:19:57.0294] <jschoi>
If we were to guess which standard functions do developers most commonly use explicitly, among all JavaScript code, then what would those functions be? `console.log`? `Array.prototype.push`? `Function.prototype.call`? `Array.from`?

[16:20:30.0075] <pokute>
`Array.map`

[16:20:47.0892] <pokute>
 * Array.map

[16:20:55.0784] <pokute>
 * `Array.map`

[16:22:13.0828] <jschoi>
Indeed, when I count occurrences in Gzemnid’s dataset of top-1000 downloaded NPM packages in 2019-09, then I get the following results:

```bash
> ls
search.topcode.sh
slim.topcode.1000.txt.lz4
> ./search.topcode.sh '\b.map\b' | awk 'END { print NR }'
1016503
> ./search.topcode.sh '\.call\b' | awk 'END { print NR }'
500084
> ./search.topcode.sh '\bconsole.log\b' | awk 'END { print NR }'
271915
> ./search.topcode.sh '\.apply\b' | awk 'END { print NR }'
225315
> ./search.topcode.sh '\.bind\b' | awk 'END { print NR }'
170248
> ./search.topcode.sh '\.set\b' | awk 'END { print NR }'
168872
> ./search.topcode.sh '\.push\b' | awk 'END { print NR }'
70116
```


[16:24:22.0849] <jschoi>
Obviously though these are only rough surrogates for the actual total JavaScript codebase of humankind.

[16:24:31.0844] <jschoi>
 * Obviously though these are only rough surrogates for the actual total JavaScript codebase of humankind.

[16:25:00.0302] <pokute>
I don't trust minimized/transpiled code as much tho. It's no exactly what people write.

[16:26:33.0410] <jschoi>
As far as I can tell, Gzemnid tries to exclude minified code (https://github.com/nodejs/Gzemnid/blob/main/README.md#deception), although it has lots of other limitations…

[16:27:06.0717] <jschoi>
I don’t think the “slim” in the filename means minified. I think it means LZ4 compressed.

[16:27:27.0317] <jschoi>
There’s `slim.code.coffee.txt.lz4` and `slim.code.ts.txt.lz4` too.

[16:27:38.0731] <jschoi>
 * I don’t think the “slim” in the filename means minified. It means LZ4 compressed.

[16:28:05.0457] <jschoi>
 * I don’t think the “slim” in the filename means minified. I think means LZ4 compressed.

[16:28:08.0638] <jschoi>
 * I don’t think the “slim” in the filename means minified. I think it means LZ4 compressed.


2021-10-06
[17:24:54.0948] <TabAtkins>
I highly, highly doubt `.call` is actually used that much in real code. It might be counting library code a bunch?

[17:25:38.0740] <jschoi>
> <@tabatkins:matrix.org> I highly, highly doubt `.call` is actually used that much in real code. It might be counting library code a bunch?

I actually checked the first thousand lines of its output and they all generally seem legitimate to me. 

[17:25:48.0641] <jschoi>
I can dump them in a Gist.

[17:26:39.0453] <jschoi>
Mostly stuff like `_super.call(this, destination)` or `tryCatch(onCancelCallback).call(this._boundValue())`.

[17:27:08.0466] <jschoi>
Oh, you’re asking if it’s double-counting dependencies.

[17:27:48.0504] <jschoi>
I don’t…think it should…

[17:28:32.0281] <jschoi>
I’ll check with `uniq`.

[17:40:14.0322] <jschoi>
Sorting the output then running `uniq -d` doesn’t return any duplicate lines. It doesn’t seem to be double-counting dependencies. 
At most, a library might manually include the code of another library in its own source code, but that problem is probably pretty small. And it applies to all the other functions’ counts, too.

[17:53:53.0630] <jschoi>
…I’d upload the sorted dump, but I just realized not everyone might want to download a 75.9-MB file, and I don’t know how Matrix’s file sharing works, haha.

[17:59:49.0663] <jschoi>
(Fun fact: The most-downloaded NPM library that uses `.call`, as of 2019-09, was debug, and it uses `.call` twice: in `createDebug.formatArgs.call(self, args)` and in `match = formatter.call(self, val);`.)

[18:00:42.0866] <jschoi>
(Next up is kind-of, which uses `.call` once, followed by readable-stream…which uses `.call` nineteen times.)

[18:12:58.0457] <jschoi>
 * (Next up is kind-of, which uses `.call` once, followed by readable-stream…which uses `.call` nineteen times. And lodash uses `.call` 127 times.)

[21:32:19.0342] <devsnek>
jschoi: https://sourcegraph.com/search?q=context:global+.call%28+lang:javascript&patternType=literal

[22:21:32.0617] <annevk>
Is there a place to follow what is outstanding on https://datatracker.ietf.org/doc/html/draft-ietf-dispatch-javascript-mjs? There was a GitHub repo at some point...

[23:27:58.0522] <annevk>
/me finds https://github.com/linuxwolf/bmeck-ids

[23:58:51.0050] <jschoi>
> <@devsnek:matrix.org> jschoi: https://sourcegraph.com/search?q=context:global+.call%28+lang:javascript&patternType=literal

Excellent, thank you. 
Though it doesn’t seem to quantify results (“500+ results”), this will still be very useful…It sure seems a lot better than GitHub’s code search; that’s for sure.

[09:20:30.0255] <jmdyck>
Ashley Claymore: I think it would be incorrect to call a Symbol's [[Description]] an internal slot. It's just something else ("an associated value") that happens to use the same metasyntax.

[09:30:18.0554] <Ashley Claymore>
thanks :D

[09:37:58.0444] <jmdyck>
When Symbols were first introduced in the early drafts of ES 6, they were a kind of exotic object, so at that time, [[Description]] *would* have been an internal slot, except that by the time [[Description]] showed up, Symbols had already changed to be a new kind of primitive.

[09:47:18.0824] <Ashley Claymore>
ah - that's an interesting bit of history

[11:13:29.0344] <ptomato>
does anyone have any background reading on the discussion from last week, that pipeline-operator and call-this are the future of writing tree-shakeable code? I would like to understand this better

[14:14:33.0524] <ljharb>
jmdyck: symbol descriptions are 100% an internal slot, and the getter works across realms

[14:14:52.0894] <ljharb>
unless you're saying primitives can't have one and that's the fudge factor?

[16:49:06.0980] <jmdyck>
@ljharb: I wouldn't say that primitives *can't* have internal slots, rather that the spec doesn't describe them as having internal slots. The spec talks about 'internal slots' only in connection with objects, and in particular does not describe a Symbol's [[Description]] as an 'internal slot'. So calling it an internal slot isn't supported by the spec.

[16:49:21.0036] <ljharb>
hm

[16:49:38.0820] <ljharb>
i mean, it has the same semantics. and on boxed symbol objects it acts just like an internal slot too.

[16:55:36.0689] <jmdyck>
I don't think the spec has such a thing as boxed symbol objects. You mean like Number Objects and String Objects?

[16:57:51.0298] <jmdyck>
Like, a Number Object is an object-box around a Number value? I don't think there's a similar object-box for Symbol values.

[16:58:46.0331] <bakkot>
jmdyck: there is, see 20.4

[16:58:48.0340] <bakkot>
 * jmdyck: there is, see 20.4

[16:59:13.0451] <bakkot>
or I guess better see Table 18 for Symbol

[16:59:20.0195] <bakkot>
https://tc39.es/ecma262/multipage/abstract-operations.html#table-toobject-conversions

[16:59:24.0141] <jmdyck>
that returns "a new Symbol value", not an object

[16:59:48.0047] <bakkot>
ToObject applied to Symbol says "Return a new Symbol object whose [[SymbolData]] internal slot is set to argument."


2021-10-07
[17:00:01.0800] <bakkot>
and indeed `typeof Object(Symbol()) === 'object'`

[17:00:22.0563] <jmdyck>
ah, there it is, thanks.

[17:00:59.0367] <jmdyck>
I'm going to have to look at this more.

[17:01:36.0709] <bakkot>
however, boxed symbols do not have a [[Description]] internal slot

[17:02:13.0800] <bakkot>
they instead have a [[SymbolData]] internal slot, which holds the underlying symbol, which is what e.g. `Symbol.prototype.description` uses

[17:06:01.0057] <jmdyck>
So it looks like the only way to create a Symbol object is by invoking ToObject on a Symbol value. Is that right?

[17:11:48.0486] <jmdyck>
(e.g., there isn't an analogue to `new Number(3)`)

[17:18:00.0187] <bakkot>
afaik yes

[17:18:05.0581] <bakkot>
same deal for BigInts, I think

[17:19:54.0936] <jmdyck>
And referring to `Symbol()` as "the Symbol constructor" is technically correct, but maybe misleading (same with BigInt).

