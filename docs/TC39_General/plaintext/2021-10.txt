2021-10-01
[17:00:01.0754] <bakkot>
we're moving progressively further in that direction with our internal tooling and it's been basically fine

[17:00:34.0404] <bakkot>
you need to do some basic conservative type analysis but at least in the code I've been working with that type analysis is feasible

[17:01:30.0942] <Justin Ridgewell>
I absolutely don‚Äôt agree. Even with a full type system, the difficulty of banning `Nodelist.p.forEach` had lead to bugs for us.

[17:02:05.0437] <Justin Ridgewell>
As soon as you cast to avoid a typecheck, we get ambiguities that let it slip back in

[17:02:46.0763] <Justin Ridgewell>
Even with a type system and full typing, it‚Äôs a difficult problem

[17:03:34.0053] <Justin Ridgewell>
Requiring us to rewrite tooling infra on top of another‚Äôs type system seems bad.

[17:04:26.0200] <Justin Ridgewell>
Devirtualized methods are simple, tiny, fast, and extremely easy to tree shake statically

[17:43:38.0070] <Justin Ridgewell>
 * Requiring us to rewrite tooling infra on top of another‚Äôs type system (even if it's as beloved as TS) seems bad.

[17:43:57.0702] <Justin Ridgewell>
 * Devirtualized methods are simple, fast, and extremely easy to tree shake statically

[18:09:11.0337] <shu>
rkirsling: actually pun was not intended!

[18:26:35.0026] <pokute>
Concerning proposed Partial Function Application, should partially applying `import()`work?

[21:42:06.0211] <TabAtkins>
The import() function is just an ordinary function, yeah? Nothing special syntactically?

[21:42:18.0554] <TabAtkins>
Assuming that's true, then yeah

[21:56:11.0629] <bakkot>
no, it is a special syntactic form, not a function

[21:56:29.0805] <bakkot>
(it has to be, since it's module-relative - it's not something you could coherently pass around)

[00:12:20.0999] <Ashley Claymore>
jschoi: maybe the readme could say how it differs from the `::` bind proposal? Unless maybe it is already obvious and I am just being slow

[00:17:16.0743] <Ashley Claymore>
 * jschoi: maybe the readme could say how it differs from the `::` bind proposal? Unless maybe it is already obvious and I am just being slow. Or is it just that there is nothing stopping there being similar proposals, lead by different groups of people? Healthy competition type of thing?

[04:24:46.0158] <jschoi>
> <@aclaymore:matrix.org> jschoi: maybe the readme could say how it differs from the `::` bind proposal? Unless maybe it is already obvious and I am just being slow. Or is it just that there is nothing stopping there being similar proposals, lead by different groups of people? Healthy competition type of thing?

Yeah, good idea. The new proposal is pretty much the same as the old bind proposal except it has no unary form. Michael has recommended to open a new repository because of the baggage with the old proposal in https://github.com/tc39/proposal-bind-operator/issues/56#issuecomment-698444297.

There‚Äôs also a Gist comparing the new proposal with the Stage-1 Extensions proposal, but it focuses on security rather than ‚Äúcall/bind are common‚Äù, so it‚Äôs out of date. I plan to edit it and add it to the repository later. https://gist.github.com/js-choi/eca7c67f88a2e82c3353fb11e8da46f7

[05:52:34.0745] <Ashley Claymore>
thanks for that info jschoi !


2021-10-02

2021-10-04
[08:43:20.0818] <pokute>
I made a [TypeScript PR](https://github.com/microsoft/TypeScript/pull/37973) for the new Syntatic Marker variant of Partial Application proposal. There's a [Playground link](https://www.staging-typescript.org/play?ts=4.5.0-pr-37973-15#code/PTAEAUBsEME8HMBOB7ArgOwCagGbMRNIgC4CW0koAggA42SkDG0Zy6oAFscTQM4BcIeKWIdUAIwB0jZAFtgxRgGYAnMBooayXhQC0NImT3Q6DZq3QAoEKAAqsGgFMAyo0SkaxCACV+nbnyCwMKiEtJywLJMKLzIOMTA9k6u7p7qqJCQwEoA7Co5StZgzqh0+MS8oOLIorgAFAD8ADSgAIwAlKDQWLgAfo0tHaC6eIiyvJJF1KRR6PCgxMigvADuIowcpHMLS1w8AkIiYlIy8oqq6praegYk5JC6JvRMLKRswKS8vKiOvMAALAAOYYANyI5HQXjioA0yC0OkosTYkxsAFloFtQFEvlt5lotl5GKhEIhHJDILBQJ8YYZ7hSuqZYLjQJJWcNSbwvLdoLJHMRHIhJpYZOhOcsAI6oIiOUAAXlA6NEki0K36zVAACZ2gBuSzCtixSCOSSQZDwOq8SXSur-do6yxAA) for it too! Test it out!

[08:44:20.0190] <Jack Works>
Partial application on generics? 

[08:44:32.0687] <Jack Works>
Oh on values Cool

[08:45:20.0127] <pokute>
 * I made a [TypeScript PR](https://github.com/microsoft/TypeScript/pull/37973) for the new [Syntatic Marker variant of Partial Application proposal](https://github.com/tc39/proposal-partial-application/issues/48). There's a [Playground link](https://www.staging-typescript.org/play?ts=4.5.0-pr-37973-15#code/PTAEAUBsEME8HMBOB7ArgOwCagGbMRNIgC4CW0koAggA42SkDG0Zy6oAFscTQM4BcIeKWIdUAIwB0jZAFtgxRgGYAnMBooayXhQC0NImT3Q6DZq3QAoEKAAqsGgFMAyo0SkaxCACV+nbnyCwMKiEtJywLJMKLzIOMTA9k6u7p7qqJCQwEoA7Co5StZgzqh0+MS8oOLIorgAFAD8ADSgAIwAlKDQWLgAfo0tHaC6eIiyvJJF1KRR6PCgxMigvADuIowcpHMLS1w8AkIiYlIy8oqq6praegYk5JC6JvRMLKRswKS8vKiOvMAALAAOYYANyI5HQXjioA0yC0OkosTYkxsAFloFtQFEvlt5lotl5GKhEIhHJDILBQJ8YYZ7hSuqZYLjQJJWcNSbwvLdoLJHMRHIhJpYZOhOcsAI6oIiOUAAXlA6NEki0K36zVAACZ2gBuSzCtixSCOSSQZDwOq8SXSur-do6yxAA) for it too! Test it out!


2021-10-05
[16:19:57.0294] <jschoi>
If we were to guess which standard functions do developers most commonly use explicitly, among all JavaScript code, then what would those functions be? `console.log`? `Array.prototype.push`? `Function.prototype.call`? `Array.from`?

[16:20:30.0075] <pokute>
`Array.map`

[16:20:47.0892] <pokute>
 * Array.map

[16:20:55.0784] <pokute>
 * `Array.map`

[16:22:13.0828] <jschoi>
Indeed, when I count occurrences in Gzemnid‚Äôs dataset of top-1000 downloaded NPM packages in 2019-09, then I get the following results:

```bash
> ls
search.topcode.sh
slim.topcode.1000.txt.lz4
> ./search.topcode.sh '\b.map\b' | awk 'END { print NR }'
1016503
> ./search.topcode.sh '\.call\b' | awk 'END { print NR }'
500084
> ./search.topcode.sh '\bconsole.log\b' | awk 'END { print NR }'
271915
> ./search.topcode.sh '\.apply\b' | awk 'END { print NR }'
225315
> ./search.topcode.sh '\.bind\b' | awk 'END { print NR }'
170248
> ./search.topcode.sh '\.set\b' | awk 'END { print NR }'
168872
> ./search.topcode.sh '\.push\b' | awk 'END { print NR }'
70116
```


[16:24:22.0849] <jschoi>
Obviously though these are only rough surrogates for the actual total JavaScript codebase of humankind.

[16:24:31.0844] <jschoi>
 * Obviously though these are only rough surrogates for the actual total JavaScript codebase of humankind.

[16:25:00.0302] <pokute>
I don't trust minimized/transpiled code as much tho. It's no exactly what people write.

[16:26:33.0410] <jschoi>
As far as I can tell, Gzemnid tries to exclude minified code (https://github.com/nodejs/Gzemnid/blob/main/README.md#deception), although it has lots of other limitations‚Ä¶

[16:27:06.0717] <jschoi>
I don‚Äôt think the ‚Äúslim‚Äù in the filename means minified. I think it means LZ4 compressed.

[16:27:27.0317] <jschoi>
There‚Äôs `slim.code.coffee.txt.lz4` and `slim.code.ts.txt.lz4` too.

[16:27:38.0731] <jschoi>
 * I don‚Äôt think the ‚Äúslim‚Äù in the filename means minified. It means LZ4 compressed.

[16:28:05.0457] <jschoi>
 * I don‚Äôt think the ‚Äúslim‚Äù in the filename means minified. I think means LZ4 compressed.

[16:28:08.0638] <jschoi>
 * I don‚Äôt think the ‚Äúslim‚Äù in the filename means minified. I think it means LZ4 compressed.


2021-10-06
[17:24:54.0948] <TabAtkins>
I highly, highly doubt `.call` is actually used that much in real code. It might be counting library code a bunch?

[17:25:38.0740] <jschoi>
> <@tabatkins:matrix.org> I highly, highly doubt `.call` is actually used that much in real code. It might be counting library code a bunch?

I actually checked the first thousand lines of its output and they all generally seem legitimate to me. 

[17:25:48.0641] <jschoi>
I can dump them in a Gist.

[17:26:39.0453] <jschoi>
Mostly stuff like `_super.call(this, destination)` or `tryCatch(onCancelCallback).call(this._boundValue())`.

[17:27:08.0466] <jschoi>
Oh, you‚Äôre asking if it‚Äôs double-counting dependencies.

[17:27:48.0504] <jschoi>
I don‚Äôt‚Ä¶think it should‚Ä¶

[17:28:32.0281] <jschoi>
I‚Äôll check with `uniq`.

[17:40:14.0322] <jschoi>
Sorting the output then running `uniq -d` doesn‚Äôt return any duplicate lines. It doesn‚Äôt seem to be double-counting dependencies. 
At most, a library might manually include the code of another library in its own source code, but that problem is probably pretty small. And it applies to all the other functions‚Äô counts, too.

[17:53:53.0630] <jschoi>
‚Ä¶I‚Äôd upload the sorted dump, but I just realized not everyone might want to download a 75.9-MB file, and I don‚Äôt know how Matrix‚Äôs file sharing works, haha.

[17:59:49.0663] <jschoi>
(Fun fact: The most-downloaded NPM library that uses `.call`, as of 2019-09, was debug, and it uses `.call` twice: in `createDebug.formatArgs.call(self, args)` and in `match = formatter.call(self, val);`.)

[18:00:42.0866] <jschoi>
(Next up is kind-of, which uses `.call` once, followed by readable-stream‚Ä¶which uses `.call` nineteen times.)

[18:12:58.0457] <jschoi>
 * (Next up is kind-of, which uses `.call` once, followed by readable-stream‚Ä¶which uses `.call` nineteen times. And lodash uses `.call` 127 times.)

[21:32:19.0342] <devsnek>
jschoi: https://sourcegraph.com/search?q=context:global+.call%28+lang:javascript&patternType=literal

[22:21:32.0617] <annevk>
Is there a place to follow what is outstanding on https://datatracker.ietf.org/doc/html/draft-ietf-dispatch-javascript-mjs? There was a GitHub repo at some point...

[23:27:58.0522] <annevk>
/me finds https://github.com/linuxwolf/bmeck-ids

[23:58:51.0050] <jschoi>
> <@devsnek:matrix.org> jschoi: https://sourcegraph.com/search?q=context:global+.call%28+lang:javascript&patternType=literal

Excellent, thank you. 
Though it doesn‚Äôt seem to quantify results (‚Äú500+ results‚Äù), this will still be very useful‚Ä¶It sure seems a lot better than GitHub‚Äôs code search; that‚Äôs for sure.

[09:20:30.0255] <jmdyck>
Ashley Claymore: I think it would be incorrect to call a Symbol's [[Description]] an internal slot. It's just something else ("an associated value") that happens to use the same metasyntax.

[09:30:18.0554] <Ashley Claymore>
thanks :D

[09:37:58.0444] <jmdyck>
When Symbols were first introduced in the early drafts of ES 6, they were a kind of exotic object, so at that time, [[Description]] *would* have been an internal slot, except that by the time [[Description]] showed up, Symbols had already changed to be a new kind of primitive.

[09:47:18.0824] <Ashley Claymore>
ah - that's an interesting bit of history

[11:13:29.0344] <ptomato>
does anyone have any background reading on the discussion from last week, that pipeline-operator and call-this are the future of writing tree-shakeable code? I would like to understand this better

[14:14:33.0524] <ljharb>
jmdyck: symbol descriptions are 100% an internal slot, and the getter works across realms

[14:14:52.0894] <ljharb>
unless you're saying primitives can't have one and that's the fudge factor?

[16:49:06.0980] <jmdyck>
@ljharb: I wouldn't say that primitives *can't* have internal slots, rather that the spec doesn't describe them as having internal slots. The spec talks about 'internal slots' only in connection with objects, and in particular does not describe a Symbol's [[Description]] as an 'internal slot'. So calling it an internal slot isn't supported by the spec.

[16:49:21.0036] <ljharb>
hm

[16:49:38.0820] <ljharb>
i mean, it has the same semantics. and on boxed symbol objects it acts just like an internal slot too.

[16:55:36.0689] <jmdyck>
I don't think the spec has such a thing as boxed symbol objects. You mean like Number Objects and String Objects?

[16:57:51.0298] <jmdyck>
Like, a Number Object is an object-box around a Number value? I don't think there's a similar object-box for Symbol values.

[16:58:46.0331] <bakkot>
jmdyck: there is, see 20.4

[16:58:48.0340] <bakkot>
 * jmdyck: there is, see 20.4

[16:59:13.0451] <bakkot>
or I guess better see Table 18 for Symbol

[16:59:20.0195] <bakkot>
https://tc39.es/ecma262/multipage/abstract-operations.html#table-toobject-conversions

[16:59:24.0141] <jmdyck>
that returns "a new Symbol value", not an object

[16:59:48.0047] <bakkot>
ToObject applied to Symbol says "Return a new Symbol object whose [[SymbolData]] internal slot is set to argument."


2021-10-07
[17:00:01.0800] <bakkot>
and indeed `typeof Object(Symbol()) === 'object'`

[17:00:22.0563] <jmdyck>
ah, there it is, thanks.

[17:00:59.0367] <jmdyck>
I'm going to have to look at this more.

[17:01:36.0709] <bakkot>
however, boxed symbols do not have a [[Description]] internal slot

[17:02:13.0800] <bakkot>
they instead have a [[SymbolData]] internal slot, which holds the underlying symbol, which is what e.g. `Symbol.prototype.description` uses

[17:06:01.0057] <jmdyck>
So it looks like the only way to create a Symbol object is by invoking ToObject on a Symbol value. Is that right?

[17:11:48.0486] <jmdyck>
(e.g., there isn't an analogue to `new Number(3)`)

[17:18:00.0187] <bakkot>
afaik yes

[17:18:05.0581] <bakkot>
same deal for BigInts, I think

[17:19:54.0936] <jmdyck>
And referring to `Symbol()` as "the Symbol constructor" is technically correct, but maybe misleading (same with BigInt).

[17:28:25.0080] <jmdyck>
i.e., it has a [[Construct]] internal method so satisfies the definition of "constructor", but if you invoke it, you just get a TypeError, same as if it didn't have a [[Construct]] method, so it's kinda tenuous to call it a constructor?

[17:33:32.0155] <jmdyck>
It looks like `Symbol()` and `BigInt()` are the only things described as constructors that nevertheless are "not intended to be used with the `new` operator".

[17:33:47.0212] <jmdyck>
 * It looks like `Symbol()` and `BigInt()` are the only things described as constructors that nevertheless are "not intended to be used with the `new` operator".

[17:40:38.0782] <bakkot>
true, but otoh it's the only way I've ever heard anyone refer to it, so I'd be reluctant to change it

[17:41:45.0145] <jmdyck>
huh, interesting.

[09:11:30.0196] <ljharb>
it starts with a capital letter and its .prototype is the [[Prototype]] of the instances, that colloquially makes it the constructor even if you can‚Äôt new it

[09:12:09.0412] <ljharb>
All the DOM element constructors can‚Äôt be newed either, and they‚Äôre all still called constructors

[09:12:22.0812] <Ashley Claymore>
I think of it as a 'newless constructor'

[09:14:19.0121] <Ashley Claymore>
or a standard constructor like `Number`, except that if I try and create a Number object instance it very loudly says "I'm not sure you want to do that"

[09:14:35.0562] <Ashley Claymore>
s/Number/Symbol/

[09:16:38.0251] <Ashley Claymore>
maybe in the future if there was ever direct support for `#constructor` then could say that's what is happening in the case of `Symbol` and `BigInt`

[16:14:58.0123] <Mathieu Hofman>
Does anyone know why the following syntax was not included when getters/setters were added? And has it ever been proposed?
```
const getFoo = () => foo;
obj = {get foo: getFoo};
```

[16:15:10.0719] <Mathieu Hofman>
 * Does anyone know why the following syntax was not included when getters/setters were added? And has it ever been proposed?
```
const getFoo = () => foo;
const obj = {get foo: getFoo};
```

[16:16:26.0956] <Mathieu Hofman>
Alternative is to jump through `defineProperty` hoops, which is not very ergonomic (and hard to type right in TypeScript)


2021-10-08
[23:59:25.0971] <Ashley Claymore>
Maybe the assumption is that the majority of getter/setter implementations would be based on the receiver? 

[00:03:23.0663] <Ashley Claymore>
There was some discussion here recently https://es.discourse.group/t/allow-arrow-functions-getters/930/4

[00:05:24.0902] <ljharb>
i mean, my personal opinion, and that of a number of styleguides, is that getters and setters are gross and should be avoided :-) that doesn't at all answer your question ofc, but it may be relevant if there were a proposal to make using getters easier.


2021-10-11
[06:57:33.0654] <nicolo-ribaudo>
Does anyone know why `BigInt.asIntN` is a static method? `BigInt.asIntN(8, 1234n)` and not `1234n.asIntN(8)`

[06:57:39.0541] <nicolo-ribaudo>
 * Does anyone know why `BigInt.asIntN` is a static method? `BigInt.asIntN(8, 1234n)` and not `1234n.asIntN(8)`


2021-10-13
[17:26:47.0172] <devsnek>
is there a transform for the current decorator proposal yet

[20:56:09.0729] <bakkot>
devsnek: https://javascriptdecorators.org/ exists, though I don't think it has perfect fidelity

[07:15:05.0323] <nicolo-ribaudo>
The Babel plugin will probably be released around the end of the year (we have a minor release every two months, and the transform is not ready yet for the next minor)

[07:15:13.0975] <nicolo-ribaudo>
> <@devsnek:matrix.org> is there a transform for the current decorator proposal yet

 * The Babel plugin will probably be released around the end of the year (we have a minor release every two months, and the transform is not ready yet for the next minor)

[08:00:40.0718] <devsnek>
honestly i don't think anyone would complain if decorating a function made it not hoist

[08:39:37.0752] <TabAtkins>
I would? Not hoisting is really annoying in non-trivial files, since it means the contents of your functions imposes an ordering on the functions themselves.

[08:40:13.0965] <TabAtkins>
It's why I almost never do the `const fn = x=>...;` thing that all the kids are doing these days.

[12:06:38.0839] <devsnek>
TabAtkins: a lot of people order stuff by use 

[12:06:48.0060] <devsnek>
i think the two most popular eslint configs enforce that

[12:07:05.0652] <devsnek>
and it would only happen if you decorated something

[12:09:10.0842] <devsnek>
also how often do you need the pre-evaluate hoisting? even if stuff is out of order without the hosting it generally works at runtime cuz its after all the definitions are evaluated

[12:28:38.0197] <TabAtkins>
const/let impose a lexical tdz tho, so things preceding them that make reference to the binding can't find them, right? or do they capture a lexical ref and only complain if it's actually executed before hitting the variable def?

[12:28:52.0977] <TabAtkins>
it's been a while since i've run into issues, I just remember having problems at some point.

[12:29:39.0898] <devsnek>
TabAtkins: this code works
```js
const a = () => b;
const b = 2;
a();
```

[12:30:25.0719] <TabAtkins>
okay, i don't remember the issues i've run into in the past, then

[12:30:50.0448] <devsnek>
the case that breaks is if you call `a()` before `const b = 2`

[12:30:54.0846] <devsnek>
which i think is 

[12:30:57.0632] <devsnek>
exceedingly rare code

[12:31:53.0739] <TabAtkins>
i suspect it might have been something like starting a rAF() loop by calling the function immediatley after defining it, and then it blowing up because it depended on functions defined later in the file with const

[12:32:12.0146] <devsnek>
ah that sounds like smth that could happen

[12:32:25.0810] <devsnek>
but if you did update your raf code to use a decorator you could always adjust the call order :P


2021-10-14
[17:49:11.0507] <pokute>
Hmm. I though about it a bit and making a transformer for decorated hoisted functions sounds a bit tricky. The transformer might need to put all the decorating code inside a hoisted function for it to work the same, and then might have to capture `arguments` and `this` for use in the decorated function body.

[20:00:37.0437] <devsnek>
my suggestion is to turn `@foo function bar() {}` into `var bar = foo(function bar() {}, { kind: 'function', name: 'bar' });`

[20:00:48.0806] <devsnek>
annex b.3.3 aside

[20:02:54.0273] <devsnek>
 * my suggestion is to turn `@foo function bar() {}` into `var bar = foo(function bar() {}, { kind: 'function', name: 'bar' });`

[02:45:25.0628] <nicolo-ribaudo>
Many spec algorithms seem to call a `Completion(...)` abstract operation (for example in https://tc39.es/ecma262/#sec-iteratorclose), but I cannot find where it is defined. Is it a type cast to convert a record into a completion record?

[03:03:24.0387] <nicolo-ribaudo>
> <@nicolo-ribaudo:matrix.org> Many spec algorithms seem to call a `Completion(...)` abstract operation (for example in https://tc39.es/ecma262/#sec-iteratorclose), but I cannot find where it is defined. Is it a type cast to convert a record into a completion record?

Oh it's defined at https://tc39.es/ecma262/#sec-implicit-completion-values - It looks like there is an auto-linking issue that links usages of the `Completion` AO to the `Completion` record definition rather than to the AO definition

[09:32:14.0240] <Michael Ficarra>
nicolo-ribaudo: linking should be fixed in this PR: https://github.com/tc39/ecma262/pull/2547/files#diff-181371b08d71216599b0acccbaabd03c306da6de142ea6275c2135810999805aR832

[10:33:30.0465] <annevk>
ooh, that sounds like a great PR

[10:38:11.0844] <Michael Ficarra>
annevk: unfortunately it's a TON of work, so it'll be at least another few weeks before it's done

[10:49:04.0306] <annevk>
I can only imagine

[10:49:53.0925] <annevk>
Might have some downstream implications too, but hopefully not too many

[10:52:08.0457] <bakkot>
probably a lot of stray `!`s in HTML to remove, mainly

[10:53:55.0856] <bakkot>
specifically, I think other specs don't tend to make use of the implicitness of completion records much (or at all?), so the relevant change is just that algorithms which were guaranteed to succeed no longer return completion records and hence no longer need to be unwrapped with `!`

[11:08:15.0966] <annevk>
bakkot: we do create a Completion record somewhere

[11:08:59.0584] <annevk>
Removing ! sounds amazing, has caused quite a bit of confusion over the years

[11:09:22.0672] <annevk>
Feels like every couple months there's someone asking why it's negating something

[11:12:22.0456] <bakkot>
there will still be some `!`s, for operations which normally can throw but which don't in this particular instance

[11:12:36.0630] <bakkot>
but I think a majority of them will be removed

[11:14:45.0649] <annevk>
I see, we do have some of those as well


2021-10-16
[07:14:03.0571] <jschoi>
If anyone has any grammar suggestions with regards to https://github.com/js-choi/proposal-bind-this/issues/14#issuecomment-944697033 (how we could loosen the bind-`this` operator such that
`a.b::c.d()` would unambiguously parse as
`(a.b)::((c.d)())` and not
`((a.b)::(c.d))()` or
`((a.b)::c).d)()`),
please let me know on the issue. I‚Äôm kind of stumped: for any recursive production I can think of that would cover `a.b::c.d`, that production would also cover `a.b::c`‚Ä¶

[07:14:36.0545] <jschoi>
 * If anyone has any grammar suggestions with regards to https://github.com/js-choi/proposal-bind-this/issues/14#issuecomment-944697033 (how we could loosen the bind-`this` operator such that
`a.b::c.d()` would unambiguously parse as
`(a.b)::((c.d)())` and not
`((a.b)::(c.d))()` or
`((a.b)::c).d)()`),
please let me know on the issue. I‚Äôm kind of stumped: for any recursive production I can think of that would cover `a.b::c.d`, that production would also cover `a.b::c`‚Ä¶

[07:49:10.0579] <TabAtkins>
I can see why the third parse isn't useful (tho I think it's what I would naively expect, treating :: as an alternative dot), but I'm not sure why you'd want the first parse over the second.

[07:49:45.0413] <TabAtkins>
It doesn't seem like it's what rbuckton is asking for in that issue, either

[08:31:49.0511] <jschoi>
 * If anyone has any grammar suggestions with regards to https://github.com/js-choi/proposal-bind-this/issues/14#issuecomment-944697033 (how we could loosen the bind-`this` operator such that
`a.b::c.d()` would unambiguously parse as
`((a.b)::(c.d))()` and not
`(a.b)::((c.d)())` or
`((a.b)::c).d)()`),
please let me know on the issue. I‚Äôm kind of stumped: for any recursive production I can think of that would cover `a.b::c.d`, that production would also cover `a.b::c`‚Ä¶

[08:33:31.0218] <jschoi>
TabAtkins: Yeah, sorry, I meant to make the goal grouping `((a.b)::(c.d))()` and not `(a.b)::((c.d)())`; I‚Äôve edited my message.
The problem is that I can‚Äôt figure out how I‚Äôd make a grammar that makes `‚Ä¶::‚Ä¶` looser than `‚Ä¶.‚Ä¶` while making `‚Ä¶::‚Ä¶` still as tight as `‚Ä¶(‚Ä¶)`.

[08:33:50.0651] <jschoi>
 * TabAtkins: Yeah, sorry, I meant to make the goal grouping `((a.b)::(c.d))()` and not `(a.b)::((c.d)())`; I‚Äôve edited my message.
The problem is that I can‚Äôt figure out how I‚Äôd make a grammar that makes `‚Ä¶::‚Ä¶` looser than `‚Ä¶.‚Ä¶` while making `‚Ä¶::‚Ä¶` still as tight as `‚Ä¶(‚Ä¶)`.

[08:35:28.0821] <ljharb>
fwiw while i think `a::Array.prototype.map` is nice, 100% of the actual use cases i have all involve caching the method beforehand, so `a::(Array.prototype.map)` doesn‚Äôt seem that bad, if you can‚Äôt figure out a solution.

[08:42:52.0325] <jschoi>
 * If anyone has any grammar suggestions with regards to https://github.com/js-choi/proposal-bind-this/issues/14#issuecomment-944697033, please let me know on the issue. 
That is, I‚Äôm stumped on how we could loosen the bind-`this` operator such that
`a.b::c.d()` would unambiguously parse as
`((a.b)::(c.d))()` (that issue‚Äôs goal) and not
`(a.b)::((c.d)())` (useless) or
`((a.b)::c).d)()` (the current behavior). 
For any recursive production I can think of that would cover `a.b::c.d`, that production would also cover `a.b::c`‚Ä¶

[08:44:06.0765] <jschoi>
 * If anyone has any grammar suggestions with regards to https://github.com/js-choi/proposal-bind-this/issues/14#issuecomment-944697033, please let me know on the issue.
That is, I‚Äôm stumped on how we could loosen the bind-`this` operator such that
`a.b::c.d()` would unambiguously parse as
`((a.b)::(c.d))()` (that issue‚Äôs goal) and not
`(a.b)::((c.d)())` (useless) or
`((a.b)::c).d)()` (the current behavior).
For any recursive RHS production I can think of that would cover `c.d`, that production would also cover `c` and/or `c.d()`‚Ä¶

[08:44:39.0484] <jschoi>
 * If anyone has any grammar suggestions with regards to https://github.com/js-choi/proposal-bind-this/issues/14#issuecomment-944697033, please let me know on the issue.
That is, I‚Äôm stumped on how we could loosen the bind-`this` operator such that
`a.b::c.d()` would unambiguously parse as
`((a.b)::(c.d))()` (that issue‚Äôs goal) and not
`(a.b)::((c.d)())` (useless) or
`((a.b)::c).d)()` (the current behavior).
For any recursive production I can think of that would cover `c.d`, that production would also cover `c` and/or `c.d()`‚Ä¶

[08:52:15.0731] <jschoi>
If we do end up figuring out how to make `a.b::c.d()` unambiguously group as `((a.b)::(c.d))()`, then I think that RHS chain-of-property-identifiers expression is similar enough to decorators‚Äô syntax that they should share a production, named something like SimpleMemberExpression.

[08:52:49.0896] <jschoi>
 * If we do end up figuring out how to make `a.b::c.d()` unambiguously group as `((a.b)::(c.d))()`, then I think that RHS chain-of-property-identifiers expression is similar enough to decorators‚Äô syntax that they should share a production, named something like SimpleMemberExpression.

[09:42:02.0713] <jmdyck>
Maybe change CoverCallExpressionAndAsyncArrowHead to be SomethingExpression Arguments, then define SomethingExpression to be `MemberExpression` or `MemberExpression :: MemberExpression`

[09:43:54.0740] <jmdyck>
 * Maybe change CoverCallExpressionAndAsyncArrowHead to be SomethingExpression Arguments, then define SomethingExpression to be `MemberExpression` or `MemberExpression :: MemberExpression`

[09:46:08.0881] <jmdyck>
 * Maybe change CoverCallExpressionAndAsyncArrowHead to be `SomethingExpression Arguments`, then define SomethingExpression to be `MemberExpression` or `MemberExpression :: MemberExpression`

[09:47:07.0563] <TabAtkins>
I think I'm with ljharb on this: if you're not caching the functions into an ident, you're really losing the semantic connection with foo.bar() syntax, and might as well just be writing the function to take the value as a first arg instead

[09:51:15.0847] <TabAtkins>
(I'm still not quite convinced :: pulls its weight, with `foo.bar~()` solving the auto-bind case and pipeline making it easy to linearize. All that's left is this "rip off methods and call them on something else" case, and honestly `const map = Array.prototype.map.call~(...)` solves that well enough imo.)

[09:55:35.0594] <ljharb>
That presumes PFA pulls its weight tho for non-bind use cases, which I‚Äôm not convinced on.

[10:46:04.0890] <TabAtkins>
Sure. But between the two, they cover a total of four major use-case categories (implicit binding, fluent importable methods, partial application, tear-off methods). PFA covers 1, 3, and does 4 reasonably well (with pipeline covering 2 and the rest of 4), while bind-op covers 1, 2 (if you import them as plain names, or we solve the parsing issues), and 4, with nothing else covering 3.

[10:47:53.0445] <TabAtkins>
Plus bind-op, by covering 2, overlaps with pipeline (and somewhat also in 4).

[10:48:20.0819] <TabAtkins>
So, looking at these just as lego blocks we want to jam together, I'm finding PFA+pipeline a wider, more efficient cover for the use-cases than bind-op.

[10:51:49.0436] <TabAtkins>
I also think PFA has a nicer "single story to tell" - it does one thing and does it well; all the use-cases it covers are obvious realizations of that one thing (binding arguments to a call ahead of time). Bind-op can be seen as doing one thing (binding the receiver for a function, which may or may not be immediately called), but in practice its uses are _thematically_ linked but _practically_ distinct - implicit binding and fluent/tear-off invocations are completely different usage patterns.

[10:51:52.0509] <TabAtkins>
 * (I also think PFA has a nicer "single story to tell" - it does one thing and does it well; all the use-cases it covers are obvious realizations of that one thing (binding arguments to a call ahead of time). Bind-op can be seen as doing one thing (binding the receiver for a function, which may or may not be immediately called), but in practice its uses are _thematically_ linked but _practically_ distinct - implicit binding and fluent/tear-off invocations are completely different usage patterns.)

[10:51:56.0735] <TabAtkins>
 * I also think PFA has a nicer "single story to tell" - it does one thing and does it well; all the use-cases it covers are obvious realizations of that one thing (binding arguments to a call ahead of time). Bind-op can be seen as doing one thing (binding the receiver for a function, which may or may not be immediately called), but in practice its uses are _thematically_ linked but _practically_ distinct - implicit binding and fluent/tear-off invocations are completely different usage patterns.

[10:56:20.0419] <TabAtkins>
 * Sure. But between the two, they cover a total of four major use-case categories (implicit binding, fluent importable methods, partial application, tear-off methods). PFA covers 1, 3, and can pretty easily convert 4 into 2 (with pipeline covering 2 and the rest of 4), while bind-op covers 1, 2 (if you import them as plain names, or we solve the parsing issues), and 4, with nothing else covering 3.

[13:11:47.0022] <jschoi>
Looking at the results of https://github.com/js-choi/proposal-bind-this/issues/12, I don‚Äôt think most current uses of `.call` (which is extremely common) would be improved with PFA syntax. 

[13:12:12.0123] <jschoi>
* Looking at the results of https://github.com/js-choi/proposal-bind-this/issues/12, I don‚Äôt think most current uses of `.call` (which is extremely common) would be improved with PFA syntax. 

[13:12:41.0240] <jschoi>
I will try to make this clear in the slides, although I don‚Äôt think that this concern should block Stage 1 anyway. 

[16:00:15.0970] <devsnek>
i think trying to figure out the right syntax is kind of a red herring here

[16:00:25.0048] <devsnek>
because you should definitely 100% use parens when writing that code


2021-10-17
[17:27:02.0473] <jschoi>
For what it‚Äôs worth, I did figure out a grammar that I think unambiguously loosens the operator to be looser than `‚Ä¶.‚Ä¶` and `new ‚Ä¶(‚Ä¶)` but tighter than `‚Ä¶[‚Ä¶]`, `‚Ä¶(‚Ä¶)`, `‚Ä¶?.‚Ä¶`, and `new ‚Ä¶`. (`new a::b()` would be a SyntaxError.)

[17:27:36.0040] <jschoi>
* For what it‚Äôs worth, I did figure out a grammar that I think unambiguously loosens the operator to be looser than `‚Ä¶.‚Ä¶` and `new ‚Ä¶(‚Ä¶)` but tighter than `‚Ä¶[‚Ä¶]`, `‚Ä¶(‚Ä¶)`, `‚Ä¶?.‚Ä¶`, and `new ‚Ä¶`. (`new a::b()` would be a SyntaxError.)

[17:30:24.0730] <jschoi>
Also: so much for the next plenary‚Äôs agenda being light. https://github.com/tc39/agendas/blob/master/2021/10.md

[17:30:35.0436] <jschoi>
* Also: so much for the next plenary‚Äôs agenda being light.

[17:34:56.0468] <jschoi>
 * Also: so much for the next plenary‚Äôs agenda being light. https://github.com/tc39/agendas/blob/master/2021/10.md


2021-10-18
[09:14:54.0153] <TabAtkins>
I think I'm leaning strong into the "not worth trying, just stick to an ident" camp, because :: is meant to be "like ., but the obj and function don't have to be previously related", and the more we move away from that the more confusing it'll get.

[09:15:33.0632] <TabAtkins>
Plus `a1.a2::a3.a4::a5.a6()` is ?????

[09:15:49.0041] <devsnek>
well formed üòÑ

[09:16:47.0667] <TabAtkins>
i recognize that it's purely a dot-call operator, and so one *can* argue that any expression that's *not* of the form `::foo()` is clearly doing something different, but I'm not sure about that.

[09:19:21.0199] <TabAtkins>
like what if `foo::bar`, without parens, invoked it like a getter setter

[09:19:59.0099] <TabAtkins>
...wait, what happens when you say `foo.bar.baz = 3` and both .bar and .baz are getter/setter pairs

[09:28:12.0027] <TabAtkins>
yeah it calls the .bar getter and the .baz setter, that's what i would expect

[09:40:18.0111] <TabAtkins>
okay raised https://github.com/js-choi/proposal-bind-this/issues/17 about it; realized while writing it that WeakMaps-as-ephemerons are the most obvious use-case.

[10:02:28.0585] <Ashley Claymore>
So there could be a way to do this:

`map::key ??= defaultValue`
that‚Äôs kinda interesting 

[10:08:55.0599] <devsnek>
üò±

[10:08:56.0805] <Ashley Claymore>
I think atm if someone wanted this they would do something that ends up looking like
`ref(map, key).v ??= defaultValue`


[10:10:59.0914] <nicolo-ribaudo>
> <@aclaymore:matrix.org> So there could be a way to do this:
> 
> `map::key ??= defaultValue`
> that‚Äôs kinda interesting

More like `key::map ??= defaultValue`, otherwise you have to write the implementation in `key` instead of in `map`

[10:20:47.0712] <Ashley Claymore>
The issue suggests that a :: get/set is treated differently from a call. So the get/set logic comes from the lhs using the rhs as a param 

[10:24:22.0441] <Ashley Claymore>
Hang on, I did get it wrong way round 

[10:26:32.0862] <TabAtkins>
Yes, wrong way round.

[10:27:07.0030] <TabAtkins>
We just don't have a way to *declare* that something is a "getter fn", so the RHS would have to, like, use a Symbol to declare it's usable as a bind-getter or bind-setter

[10:27:41.0253] <TabAtkins>
`class Ephemeron extends WeakMap { [Symbol.bindGet]() { ...} }`

[10:28:20.0767] <TabAtkins>
the point of weakmaps as ephemerons is letting you attach "properties" to objects in ways that the objects (or anyone else) can't observe on their own

[10:29:09.0228] <TabAtkins>
 * `class Ephemeron extends WeakMap { [Symbol.bindGet]() { ...} }`

[10:29:24.0359] <TabAtkins>
oh lol markdown links really intersect with symbol-keyed methods in a bad way if you don't wrap them in a code span ^_^

[10:37:12.0661] <Ashley Claymore>
So `a.b` is call [[get]] on deref(a) with toStringOrSymbol(deref(b)).
and
`a::b` is call Symbol.bindGet on deref(a) with the value of deref(b).

[10:37:49.0878] <Ashley Claymore>
* So `a.b` is call [[get]] on deref(a) with toStringOrSymbol(deref(b)).
and
`a::b` is call Symbol.bindGet on deref(a) with the value of deref(b).

[10:38:57.0313] <TabAtkins>
no

[10:38:57.0807] <Ashley Claymore>
and `a::b()` is call deref(b) with a as this

[10:39:52.0390] <TabAtkins>
or, well, i'm unclear on exactly the mechanics you're implying by that second one. i wrote up a possible code example in https://github.com/js-choi/proposal-bind-this/issues/17#issuecomment-946005508

[10:40:28.0778] <TabAtkins>
okay, reading more closely, yeah, you've still got it backwards

[10:40:44.0597] <TabAtkins>
the bindGet has to live on b, and be called with a

[10:41:07.0555] <TabAtkins>
same as the "bindCall" lives on b and is called with a in `a::b()`

[10:41:37.0969] <TabAtkins>
("bindCall" just being the unforgable version of `b.call()`)

[10:43:57.0582] <TabAtkins>
basically if, instead of thinking of `a::b()` as "call `b()` with `a` bound to its `this`)" you think of it as "call `b.call()` with `a` as its first argument", then `a::b` is exactly the same with `b[Symbol.bindGet]` and `b[Symbol.bindSet]`

[10:44:56.0109] <Ashley Claymore>
My mind has clicked into place now thanks!

[10:45:47.0824] <TabAtkins>
 * basically if, instead of thinking of `a::b()` as "call `b()` with `a` bound to its `this`)" you think of it as "call `b.call()` with `a` as its first argument", then `a::b` is exactly the same with `b[Symbol.bindGet]()` and `b[Symbol.bindSet]()`

[10:47:18.0384] <Ashley Claymore>
a::b() looks up [[call]] on b so can‚Äôt be intercepted. But get/set would be symbol based so more opportunity for meta-programming 

[10:48:25.0206] <Ashley Claymore>
* So `a.b` is call [[get]] on deref(a) with toStringOrSymbol(deref(b)).
and
~`a::b` is call Symbol.bindGet on deref(a) with the value of deref(b)~.

[10:48:39.0768] <Ashley Claymore>
* So `a.b` is call [[get]] on deref(a) with toStringOrSymbol(deref(b)).
and
~~`a::b` is call Symbol.bindGet on deref(a) with the value of deref(b)~~.

[10:49:04.0856] <Ashley Claymore>
* So `a.b` is call [[get]] on deref(a) with toStringOrSymbol(deref(b)).
and
~~a::b is call Symbol.bindGet on deref(a) with the value of deref(b)~~.

[10:50:08.0979] <TabAtkins>
Yeah, the metaprogramming aspect is incidental here, it's just required to get it to work since we have an *intrinsic* notion of an object being callable, but "invokable as a getter" is extrinsic in today's JS (based on how a function is attached to an object).

[10:57:58.0189] <Ashley Claymore>
I think I kept getting it the wrong way around as I was thinking of `a::b()` as a temporary method on a. So kept jumping to `a::b` being a temporary property of a. 
It‚Äôs been one of those Mondays 

[10:58:12.0676] <Ashley Claymore>
* I think I kept getting it the wrong way around as I was thinking of `a::b()` as a temporary method on a. So kept jumping to `a::b` being a temporary property of a. 
It‚Äôs been one of those Mondays 

[10:58:35.0700] <nicolo-ribaudo>
Wait, isn't `a::b()` a temporary method on `a`?

[10:58:40.0424] <TabAtkins>
it's not an unreasonable way to think about it, so that's understandable

[10:58:54.0834] <nicolo-ribaudo>
"temporary" = "not actually there"

[10:59:24.0073] <TabAtkins>
it's "a temporary method" *semantically*. Technically it's "unforgably call `b.call(a, ...)`", which has nothing to do with methods.

[12:34:29.0786] <jschoi>
Aha, I see, so it came from here. üòÑ

[12:35:42.0371] <jschoi>
I do like Ron‚Äôs idea in https://github.com/js-choi/proposal-bind-this/issues/17#issuecomment-946055779.

[12:55:18.0051] <bakkot>
You can already do that with a Proxy, right?

[12:56:07.0793] <bakkot>
No one uses Proxies for this because they are almost a slow path, but that would be just as a much a problem for this, I would think

[12:56:53.0024] <bakkot>
I guess you can't actually do this with a proxy because the key is ToPropertyKey'd before it hits the proxy, never mind

[13:30:14.0149] <ljharb>
without extracting it, you can't explicitly call a getter in JS right now at all, and that's not the problem `::` is trying to solve

[13:30:40.0948] <ljharb>
the engine will call the getter for you, but you're not using invocation parens or `new` to do it

[14:05:22.0281] <TabAtkins>
Proxies do the *other* direction, where `a<op>b` is controlled by `a` and lets them do something arbitrary based on `b`. The thing I and Ron are talking about is the reverse, where the `<op>` is controlled by `b` and can do something arbitrary based on `a`.

[14:06:15.0627] <TabAtkins>
(I already answered this in the issue, but I'm not talking about extracting or calling getters *at all*, so I'm not sure why ljharb is bringing it up again here.)

[14:07:16.0713] <ljharb>
because i'm still not sure why getters are being brought up at all in relation to this proposal

[14:07:23.0373] <TabAtkins>
aka, Proxies let you do a *Map* where `map[key]` works and turns into `map.get(key)`. What I and Ron are talking about is having a *WeakMap* where `obj::wm` or `obj[wm]` turns into `wm.get(obj)`

[14:07:37.0174] <ljharb>
the proposal is about syntactic call or bind, which requires there be an actual receiver-sensitive function present in scope first. whether that function came from a data property or a getter is irrelevant.

[14:08:43.0001] <ljharb>
 * the proposal is about syntactic call or bind, which requires there be an actual receiver-sensitive function present in scope first. whether that function came from a data property or a getter is irrelevant.

