2022-06-03
[07:54:09.0038] <Domenic>
What wording did TC39 end up with for "icky" features?

[08:24:59.0613] <bakkot>
> A conforming implementation of ECMAScript must implement Legacy subclauses, unless they are also marked as Normative Optional. All of the language features and behaviours specified within Legacy subclauses have one or more undesirable characteristics. However, their continued usage in existing applications prevents their removal from this specification. These features are not considered part of the core ECMAScript language. Programmers should not use or assume the existence of these features and behaviours when writing new ECMAScript code.

[08:25:12.0322] <bakkot>
 * Domenic: 
> A conforming implementation of ECMAScript must implement Legacy subclauses, unless they are also marked as Normative Optional. All of the language features and behaviours specified within Legacy subclauses have one or more undesirable characteristics. However, their continued usage in existing applications prevents their removal from this specification. These features are not considered part of the core ECMAScript language. Programmers should not use or assume the existence of these features and behaviours when writing new ECMAScript code.

[08:35:08.0294] <Richard Gibson>
> <@bakkot:matrix.org> Domenic: 
> > A conforming implementation of ECMAScript must implement Legacy subclauses, unless they are also marked as Normative Optional. All of the language features and behaviours specified within Legacy subclauses have one or more undesirable characteristics. However, their continued usage in existing applications prevents their removal from this specification. These features are not considered part of the core ECMAScript language. Programmers should not use or assume the existence of these features and behaviours when writing new ECMAScript code.

"legacy", as seen at https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.prototype.__proto__ and defined at the bottom of https://tc39.es/ecma262/multipage/conformance.html#sec-conformance


2022-06-11
[13:40:36.0027] <bakkot>
I have been writing lots of promises lately and keep getting annoyed by awkwardness of extracting the handlers from the promise constructor. kind of want to add a helper for this. thoughts?

```
Promise.create = () => {
  let resolve, reject;
  let promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { resolve, reject, promise };
};

let { resolve, reject, promise } = Promise.create();
resolve(42);
promise; // Promise {<fulfilled>: 42}
```

[13:41:10.0676] <bakkot>
I _could_ just copy that helper to every project but it comes up often enough for me that it seems maybe worth adding. don't know if this is something other people run into though.

[13:43:03.0636] <nicolo-ribaudo>
There is some popular prior art: jQuery's `$.deferred()` exposes the reject/resolve methods, and a `.promise()` method to get the internal promise.

[14:32:18.0206] <joepie91 🏳️‍🌈>
bakkot: the problem with deferreds like that is that, while there is a nonzero amount of cases where it's the correct solution (particularly queues), when people use it it is *almost* always because they are using promises wrong

[14:33:02.0923] <joepie91 🏳️‍🌈>
and aren't following the principle of "your `new Promise` should only contain the conversion logic necessary for a specific obsolete asynchronous API, nothing more, nothing less"

[14:33:10.0614] <joepie91 🏳️‍🌈>
and it often leads to race conditions and other reliability issues

[14:33:47.0009] <joepie91 🏳️‍🌈>
so I'd say that if you find yourself needing them in 'every project', that's probably a red flag, and it's also not something that should be too easy to do precisely because of its misuse potential :)

[14:34:15.0872] <joepie91 🏳️‍🌈>
(afaik this is basically *why* most modern Promise implementations ended up not implementing a deferred API)

[15:07:44.0097] <bakkot>
I certainly can believe that many people would use it wrong, and that's maybe a reason not to do this, though I don't agree that you should always be trying to shove your conversion logic inside of the call to the promise constructor

[15:07:59.0997] <bakkot>
also I guess I do write a lot of queues, which is probably unusual

[15:54:18.0456] <joepie91 🏳️‍🌈>
> <@bakkot:matrix.org> I certainly can believe that many people would use it wrong, and that's maybe a reason not to do this, though I don't agree that you should always be trying to shove your conversion logic inside of the call to the promise constructor

the primary reason for doing so, aside from the self-contained nature of the resulting promise, is that it will also capture synchronously thrown errors in the conversion code and propagate them as promise rejections

[15:54:42.0750] <joepie91 🏳️‍🌈>
otherwise you run the risk of ending up with a half-async-half-sync API

[15:55:40.0156] <joepie91 🏳️‍🌈>
(this doesn't apply for queues where this is generally not reasonably possible at all; I'm *just* talking about conversions from weird async-cb APIs to promises here)

[16:15:41.0706] <bakkot>
I don't usually want to capture synchronously thrown errors in the conversion code, personally, because that means that I messed up _registering_ the callback rather than that the thing I was registering it to threw

[16:16:16.0789] <bakkot>
like if I'm doing `thing.on('finished', resolve(val))`, but `thing` is accidentally null at that point, that's a synchronous error and I don't want it to be wrapped up in a promise

[16:16:34.0861] <bakkot>
this is what I mean about it not making sense to try to shove all of your conversion logic inside the call to the promise constructor

[16:17:31.0699] <bakkot>
I only want an error if `thing` _itself_ produced an error, rather than if my conversion code failed

[16:17:38.0048] <bakkot>
 * I only want an error if `thing` _itself_ produced an error, rather than if my conversion code failed


2022-06-12
[18:59:09.0849] <ljharb>
The spec used to have a proposed Promise.defer that did this, and Chrome shipped it for years until they finally caved and removed it. I think the potential for misuse and endorsement is far greater than the pain of writing that code/abstraction

[19:45:47.0861] <flonxxd>
 I'll help 10 individuals how to earn $20,000 in just 72 hours  from the crypto market. But you will pay me 10% commission when you receive your profit. if interested send me a direct message via WhatsApp by asking me HOW for more details on how to get started
> +1 (2297781881



[20:20:40.0144] <Jack Works>
Finally we got cryptocurrency spam on Matrix 

[20:21:22.0202] <Jack Works>
* Finally we got cryptocurrency spam on Matrix 

[20:58:53.0890] <flonxxd>
 I'll help 10 individuals how to earn $20,000 in just 72 hours  from the crypto market. But you will pay me 10% commission when you receive your profit. if interested send me a direct message via WhatsApp by asking me HOW for more details on how to get started
> +1 (2297781881



[11:17:34.0162] <littledan>
Bakkot, I agree that we should add a built-in Promise.defer function to do exactly that. It just keeps coming up for everyone.

[11:17:55.0295] <littledan>
(I actually removed exactly this function from V8 since it wasn’t in the standard)

[15:11:43.0782] <flonxxd>
 I'll help 10 individuals how to earn $20,000 in just 72 hours  from the crypto market. But you will pay me 10% commission when you receive your profit. if interested send me a direct message via WhatsApp by asking me HOW for more details on how to get started
> +1 (2297781881




2022-06-13
[18:10:20.0999] <Justin Ridgewell>
> <@joepie91:pixie.town> the primary reason for doing so, aside from the self-contained nature of the resulting promise, is that it will also capture synchronously thrown errors in the conversion code and propagate them as promise rejections

We already lost that battle when we added `Promise.resolve`.

[18:11:19.0766] <Justin Ridgewell>
I’ve hit the queueing usecase enough times that it seems like a deferred struct is a good addition.

[18:16:59.0828] <bakkot>
ljharb: I lack experience here; what does misuse look like?

[20:00:26.0113] <ljharb>
I’ve seen tons of people use the pattern when it’s not needed; the number of times those legit use cases come up are very rare ime

[20:15:03.0048] <littledan>
I’ve seen this pattern often be needed when adapting a callback-based API to promises

[20:15:53.0301] <littledan>
Otoh I think people overused it back when promises were just coming out, async await was not yet standard, and people didn’t really understand .then

[20:16:17.0408] <littledan>
I think now would probably be a good time to add Promise.defer given the improved environment and continued need

[20:17:04.0760] <littledan>
I don’t think the legit use case is rare. It is just that, before async await, everyone was very confused all the time 

[20:21:58.0494] <Kris Kowal>
> <@nicolo-ribaudo:matrix.org> There is some popular prior art: jQuery's `$.deferred()` exposes the reject/resolve methods, and a `.promise()` method to get the internal promise.

The chain of prior art continues. jQuery’s deferred() comes from the bad chain, because it conflated promise and resolver, allowing people to optionally separate them. jQuery took its cues from Python Twisted Deferred, which in turn took some of its cues from E promises. Whereas, Promise.defer() (from an early draft of the Promises proposal) takes its cues from Q.defer() is more like what @bakkot proposes, which in turn came from MarkM’s proposal for promises back in 2010, then from Tyler Close’s Waterken, which in turn took its cues from E.

[20:23:53.0913] <Kris Kowal>
That is to say, Promise.defer() => {promise, resolve, reject} is sound design (since by default promise and resolve should be held by different parties for POLA purposes), and while I named it “defer” originally as a nod to “Deferreds” in Python’s Twisted, it doesn’t suffer the same design error.

[20:24:11.0060] <littledan>
Yeah it is important that the callbacks returned close over the capability related to the individual promise (this was an issue in V8’s weird defer)

[20:25:23.0095] <littledan>
I was skeptical of defer at some point due to making all the callbacks but that was too much of a microoptimization I think 

[20:28:01.0594] <Kris Kowal>
I find myself using Promise.defer() for async queues too, but it’s stuffed in a library and only gets used that way once. But I also get a lot of use of Promise.defer() for 1. broadcasting a drain event 2. broadcasting a fast moving state change to a slow consumer (replace the deferred when the consumer observes the current state) 3. chaining mutual exclusion for stateful protocols or “baton passing”

[20:29:13.0191] <Kris Kowal>
Async queue https://github.com/endojs/endo/blob/master/packages/stream/index.js#L31-L50

[20:30:12.0397] <Kris Kowal>
(At Agoric, we’re calling Promise.defer() makePromiseKit() but Promise.defer() is definitely the right name.)

[20:34:40.0383] <Kris Kowal>
I think we ended up where we were because the Promise constructor needed to have *some* behavior and Promise.defer() was duplicative, so it could be punted indefinitely. It’s trivial to make a defer() from Promise(), so it was a disappointing concession but easy to recover from.

[20:36:11.0080] <bakkot>
yeah, it makes sense how we ended up here. it's not that it's hard to do the thing given the Promise constructor, just annoying.

[20:40:10.0860] <Kris Kowal>
I for one thing it would be worth the cost to add Promise.defer() => {promise, resolve, reject} to the language.

[20:40:31.0336] <Kris Kowal>
 * I for one thing it would be worth the cost to add Promise.defer() => {promise, resolve, reject} to the language.

[20:41:43.0145] <Kris Kowal>
Also noting that I’d also enjoy `Promise.defer() => {promise, resolve}` since `resolve(Promise.reject(error))` recovers the absent `reject`.

[23:24:10.0437] <Ashley Claymore>
> <@kriskowal:matrix.org> Also noting that I’d also enjoy `Promise.defer() => {promise, resolve}` since `resolve(Promise.reject(error))` recovers the absent `reject`.

seems like a _safe_ optimisation, Whenever I’ve used this pattern I’ve only ever needed to expose resolve

[23:48:42.0332] <bakkot>
i have definitely needed reject, and it seems odd to make you write `resolve(Promise.reject(error))` in that case

