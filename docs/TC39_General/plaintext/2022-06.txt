2022-06-03
[07:54:09.0038] <Domenic>
What wording did TC39 end up with for "icky" features?

[08:24:59.0613] <bakkot>
> A conforming implementation of ECMAScript must implement Legacy subclauses, unless they are also marked as Normative Optional. All of the language features and behaviours specified within Legacy subclauses have one or more undesirable characteristics. However, their continued usage in existing applications prevents their removal from this specification. These features are not considered part of the core ECMAScript language. Programmers should not use or assume the existence of these features and behaviours when writing new ECMAScript code.

[08:25:12.0322] <bakkot>
 * Domenic: 
> A conforming implementation of ECMAScript must implement Legacy subclauses, unless they are also marked as Normative Optional. All of the language features and behaviours specified within Legacy subclauses have one or more undesirable characteristics. However, their continued usage in existing applications prevents their removal from this specification. These features are not considered part of the core ECMAScript language. Programmers should not use or assume the existence of these features and behaviours when writing new ECMAScript code.

[08:35:08.0294] <Richard Gibson>
> <@bakkot:matrix.org> Domenic: 
> > A conforming implementation of ECMAScript must implement Legacy subclauses, unless they are also marked as Normative Optional. All of the language features and behaviours specified within Legacy subclauses have one or more undesirable characteristics. However, their continued usage in existing applications prevents their removal from this specification. These features are not considered part of the core ECMAScript language. Programmers should not use or assume the existence of these features and behaviours when writing new ECMAScript code.

"legacy", as seen at https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.prototype.__proto__ and defined at the bottom of https://tc39.es/ecma262/multipage/conformance.html#sec-conformance


2022-06-11
[13:40:36.0027] <bakkot>
I have been writing lots of promises lately and keep getting annoyed by awkwardness of extracting the handlers from the promise constructor. kind of want to add a helper for this. thoughts?

```
Promise.create = () => {
  let resolve, reject;
  let promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { resolve, reject, promise };
};

let { resolve, reject, promise } = Promise.create();
resolve(42);
promise; // Promise {<fulfilled>: 42}
```

[13:41:10.0676] <bakkot>
I _could_ just copy that helper to every project but it comes up often enough for me that it seems maybe worth adding. don't know if this is something other people run into though.

[13:43:03.0636] <nicolo-ribaudo>
There is some popular prior art: jQuery's `$.deferred()` exposes the reject/resolve methods, and a `.promise()` method to get the internal promise.

[14:32:18.0206] <joepie91 ðŸ³ï¸â€ðŸŒˆ>
bakkot: the problem with deferreds like that is that, while there is a nonzero amount of cases where it's the correct solution (particularly queues), when people use it it is *almost* always because they are using promises wrong

[14:33:02.0923] <joepie91 ðŸ³ï¸â€ðŸŒˆ>
and aren't following the principle of "your `new Promise` should only contain the conversion logic necessary for a specific obsolete asynchronous API, nothing more, nothing less"

[14:33:10.0614] <joepie91 ðŸ³ï¸â€ðŸŒˆ>
and it often leads to race conditions and other reliability issues

[14:33:47.0009] <joepie91 ðŸ³ï¸â€ðŸŒˆ>
so I'd say that if you find yourself needing them in 'every project', that's probably a red flag, and it's also not something that should be too easy to do precisely because of its misuse potential :)

[14:34:15.0872] <joepie91 ðŸ³ï¸â€ðŸŒˆ>
(afaik this is basically *why* most modern Promise implementations ended up not implementing a deferred API)

[15:07:44.0097] <bakkot>
I certainly can believe that many people would use it wrong, and that's maybe a reason not to do this, though I don't agree that you should always be trying to shove your conversion logic inside of the call to the promise constructor

[15:07:59.0997] <bakkot>
also I guess I do write a lot of queues, which is probably unusual

[15:54:18.0456] <joepie91 ðŸ³ï¸â€ðŸŒˆ>
> <@bakkot:matrix.org> I certainly can believe that many people would use it wrong, and that's maybe a reason not to do this, though I don't agree that you should always be trying to shove your conversion logic inside of the call to the promise constructor

the primary reason for doing so, aside from the self-contained nature of the resulting promise, is that it will also capture synchronously thrown errors in the conversion code and propagate them as promise rejections

[15:54:42.0750] <joepie91 ðŸ³ï¸â€ðŸŒˆ>
otherwise you run the risk of ending up with a half-async-half-sync API

[15:55:40.0156] <joepie91 ðŸ³ï¸â€ðŸŒˆ>
(this doesn't apply for queues where this is generally not reasonably possible at all; I'm *just* talking about conversions from weird async-cb APIs to promises here)

[16:15:41.0706] <bakkot>
I don't usually want to capture synchronously thrown errors in the conversion code, personally, because that means that I messed up _registering_ the callback rather than that the thing I was registering it to threw

[16:16:16.0789] <bakkot>
like if I'm doing `thing.on('finished', resolve(val))`, but `thing` is accidentally null at that point, that's a synchronous error and I don't want it to be wrapped up in a promise

[16:16:34.0861] <bakkot>
this is what I mean about it not making sense to try to shove all of your conversion logic inside the call to the promise constructor

[16:17:31.0699] <bakkot>
I only want an error if `thing` _itself_ produced an error, rather than if my conversion code failed

[16:17:38.0048] <bakkot>
 * I only want an error if `thing` _itself_ produced an error, rather than if my conversion code failed


2022-06-12
[18:59:09.0849] <ljharb>
The spec used to have a proposed Promise.defer that did this, and Chrome shipped it for years until they finally caved and removed it. I think the potential for misuse and endorsement is far greater than the pain of writing that code/abstraction

[19:45:47.0861] <flonxxd>
 I'll help 10 individuals how to earn $20,000 in just 72 hours  from the crypto market. But you will pay me 10% commission when you receive your profit. if interested send me a direct message via WhatsApp by asking me HOW for more details on how to get started
> +1 (2297781881



[20:20:40.0144] <Jack Works>
Finally we got cryptocurrency spam on Matrix 

[20:21:22.0202] <Jack Works>
* Finally we got cryptocurrency spam on Matrix 

