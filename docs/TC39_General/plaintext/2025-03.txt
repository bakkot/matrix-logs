2025-03-10
[06:30:44.0121] <snek>
i wish there was a promise method like finally except it didn't propagate the exception and didn't mark the promise as "handled"

[06:30:46.0952] <snek>
does anyone else wish this

[09:57:46.0398] <Ashley Claymore>
what would it return?

[10:01:38.0638] <Ashley Claymore>
(when the promise was rejected)

[15:24:19.0330] <snek>
> <@aclaymore:matrix.org> what would it return?

undefined

[15:25:34.0501] <snek>
basically add the argument as a fulfill and reject handler, but don't create a new promise or update [[PromiseIsHandled]]

[15:37:11.0883] <ljharb>
why?

[15:44:46.0073] <snek>
idk this is a thing i find myself wanting to do a lot when writing apis

[15:51:18.0249] <kriskowal>
When it comes to unhandled rejections, there are two reasonable design families and everything has somehow chosen the third. Every unhandled rejection is potentially eventually handled until post mortem finalization. From a debugging point of view, you either want silence (so real errors are not lost in noise errors) or interactivity. An interactive promise debugger shows you both “currently unhandled rejections” and “currently pending promises”, because both of these are ephemeral but at a moment in time might suggest a defect, either a forever-pending promise or never-handled-rejection.

[15:51:44.0153] <kriskowal>
But lint rules for no-dangling-promises are good.

[15:52:06.0509] <kriskowal>
Returning promises in callbacks that dangle the promise is bad.

[15:52:58.0323] <kriskowal>
Like, the convenience of `addEventListener('click', async() => {})` is undeniable, but still wrong. The promise should get sunk, or verified to be unrejectable statically.

[15:54:08.0864] <kriskowal>
I did have a version of Q instrumented for a prototype Chrome extension that could give you the traces for all still-pending and still-unhandled promises. I do hope that idea makes its way to a nearby devtools.

