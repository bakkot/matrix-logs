2021-11-03
[10:06:19.0791] <devsnek>
what if we added toml to the stdlib

[10:09:22.0318] <bakkot>
i feel like it does not have a good place in JS

[10:09:51.0259] <bakkot>
it's intended as a human-readable config language, which makes sense for server-side apps but not really for any other JS users

[13:40:29.0456] <bakkot>
https://github.com/kaist-plrg/jiset is neat

[13:40:50.0533] <bakkot>
(jmdyck I imagine you might be particularly interested)

[14:12:29.0026] <ljharb>
browser-side users need to configure things too

[14:39:49.0110] <jmdyck>
@bakkot: yeah, it looks like they're doing something similar to my ecmaspeak project

[14:53:34.0445] <jmdyck>
Except, when I look at their code, nothing seems familiar.

[15:15:36.0171] <jmdyck>
 * Except, when I look at their code, not much seems familiar.

[16:40:17.0055] <devsnek>
>  Before installation, please download JDK 8

[16:41:56.0687] <devsnek>
would be cool if one of these spec evaluators can replace engine262 one day

[16:42:45.0718] <devsnek>
it looks like jiset was for some sort of university study

[16:53:07.0973] <shu>
PSA here is the incubator call doodle for pattern matching: https://github.com/tc39/Reflector/issues/407 it wasn't clear if there were interested non-champion delegates. if you are, please sign up for a time *before Nov 9*!


2021-11-04
[17:45:19.0674] <TabAtkins>
okay so if we're champs no need to answer the doodle, or shoudl we do so to kick off time planning?

[19:11:44.0747] <jmdyck>
devsnek: I'm working on it, but progress is slow.

[04:00:11.0920] <nicolo-ribaudo>
Can anyone give me an example of an observable effect of what is explained in the second pagraph of the first note of https://tc39.es/ecma262/#sec-weakref-execution? I initially came up with this:
```
let obj = { x: 1 };
let ref = new WeakRef(obj);
await null; // I think we need to wait to allow WeakRefs to be emptied
console.log(ref.deref(), obj.x);
```

which I though might log `undefined, 1` because it doesn't observe the _identity_ of `obj`.

However, an _hypothetical WeakRef-oblivious execution_ (as defined in "9.10.2 - Liveness") might be `obj === obj`, which observes the identity of `obj` and thus makes it "live" and non-collectable, so `ref.deref()` must return `obj`.

[04:00:27.0444] <nicolo-ribaudo>
 * Can anyone give me an example of an observable effect of what is explained in the second pagraph of the first note of https://tc39.es/ecma262/#sec-weakref-execution? I initially came up with this:
```
let obj = { x: 1 };
let ref = new WeakRef(obj);
await null; // I think we need to wait to allow WeakRefs to be emptied
console.log(ref.deref(), obj.x);
```

which I though might log `undefined, 1` because it doesn't observe the _identity_ of `obj`.

However, an _hypothetical WeakRef-oblivious execution_ (as defined in "9.10.2 - Liveness") might be `obj === obj`, which observes the identity of `obj` and thus makes it "live" and non-collectable, so `ref.deref()` must return `obj`.

[04:02:25.0609] <nicolo-ribaudo>
Maybe my question is "is an _hypothetical WeakRef-oblivious execution_ any possible execution of any possible code, or just any possible execution flow in my code?"

[04:02:33.0343] <nicolo-ribaudo>
 * Maybe my question is "is an _hypothetical WeakRef-oblivious execution_ any possible execution of any possible code, or just any possible execution flow in my source code?"

[04:02:39.0246] <nicolo-ribaudo>
 * Maybe my question is "is an _hypothetical WeakRef-oblivious execution_ any possible execution of any possible code, or just any possible execution flow in my code?"

