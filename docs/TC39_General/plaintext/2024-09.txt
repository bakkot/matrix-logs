2024-09-03
[01:31:57.0087] <Michael Ficarra>
A Coq Mechanization of JavaScript Regular Expression Semantics: https://dl.acm.org/doi/10.1145/3674666

[06:58:48.0287] <jmdyck>
In 6.1, they acknowledge the distinction between main-body and annex B regexes, but don't explicitly say which they're mechanizing (as far as I could see). I'm pretty sure it's just main-body.

[13:10:29.0623] <nicolo-ribaudo>
Do the two modes have different _features_, or just different parsing rules?

[13:10:41.0004] <nicolo-ribaudo>
> These grammars do not agree on all inputs:
for instance, the standard grammar rejects ], whereas the legacy grammar allows it and treats it as
a valid regex matching the character ‘]’. Given this, we left parsing out of our mechanization.

[13:42:02.0343] <jmdyck>
It's mostly syntax, but it isn't *just* syntax, some of the pseudocode is different too, so it makes a difference (to the resulting mechanization) which you pick.

[13:43:15.0364] <Richard Gibson>
> <@nicolo-ribaudo:matrix.org> Do the two modes have different _features_, or just different parsing rules?

just different parsing rules AFAICT, but the interpretation of various `\c…` in various possible locations gets _really_ intricate

[13:44:02.0848] <jmdyck>
For research purposes, it makes sense for them to stick to the main-body, but I think it's at least worth saying so.

[13:51:28.0158] <snek>
i experimented a bit with an nfa vm for engine262 for verifying optimizations, cool to see this approach as well

[15:58:32.0950] <bakkot>
I kind of want to propose a `Math.argmax(it, fn)` which is like `(it, fn) => Iterator.from(it).reduce((a, b) => f(a) > f(b) ? a : b)`, but apparently Python's (rather numpy's) `argmax` gives you the index of the maximum item rather actually taking a function.

[15:59:26.0210] <bakkot>
possible alternatives:
- the `fn` arg is optional, and it just gives you the index if omitted (which is useless if the argument isn't indexable, but whatever)
- call it `maxBy`, which is a natural enough name (and also apparently already exists in lodash, neat)

[16:00:50.0428] <bakkot>
also, I want to suggest that both this and a hypothetical `sortBy` would allow the function to return any of { number, bigint, string }, and do the natural comparison within each type, but throw if the function ever returns two different types


2024-09-05
[12:37:43.0341] <snek>
what's up with the requirement that if the target is not extensible, proxy ownKeys can't return a different set of keys?

[12:38:14.0611] <snek>
like if i define the other traps to behave consistently, shouldn't it be fine

[12:45:30.0000] <nicolo-ribaudo>
I guess it's because otherwise there is no way to guarantee that it behaves as not extensible 

[12:53:43.0340] <bakkot>
how could it know that the other traps behave consistently without calling them?

[12:54:03.0691] <bakkot>
or remembering their results, I suppose

[12:56:15.0036] <bakkot>
you should understand the target as serving as a _witness_, a proof-by-example that the behavior you are representing is consistent with the essential invariants. and one of the behaviors is, if something is reported to be not-extensible, then it will never get new keys. the way this is enforced is, a proxy can only report being not-extensible if its target is not-extensible, and if the target is not-extensible then it must report having the same keys as the target. if either of these properties was not enforced then you could have behavior which is not consistent with the essential invariants.

[12:56:40.0213] <bakkot>
 * you should understand the target as serving as a _witness_, a proof-by-example that the behavior you are representing is consistent with the essential invariants (or at least, is as consistent as the underlying thing). and one of the behaviors is, if something is reported to be not-extensible, then it will never get new keys. the way this is enforced is, a proxy can only report being not-extensible if its target is not-extensible, and if the target is not-extensible then it must report having the same keys as the target. if either of these properties was not enforced then you could have behavior which is not consistent with the essential invariants.

[12:57:00.0970] <bakkot>
 * you should understand the target as serving as a _witness_, a proof-by-example that the behavior you are representing is consistent with the essential invariants (at least assuming that you don't already have something inconsistent to use as the target).

and one of the behaviors is, if something is reported to be not-extensible, then it will never get new keys. the way this is enforced is, a proxy can only report being not-extensible if its target is not-extensible, and if the target is not-extensible then it must report having the same keys as the target. if either of these properties was not enforced then you could have behavior which is not consistent with the essential invariants.

[12:57:15.0395] <bakkot>
 * you should understand the target as serving as a _witness_, a proof-by-example that the behavior you are representing is consistent with the essential invariants (at least assuming that you don't already have something inconsistent to use as the target).

and one of the invariants is, if something is reported to be not-extensible, then it will never get new keys. the way this is enforced is, a proxy can only report being not-extensible if its target is not-extensible, and if the target is not-extensible then it must report having the same keys as the target. if either of these properties was not enforced then you could have behavior which is not consistent with the essential invariants.

[13:02:21.0850] <snek>
currently it checks if it's consistent by calling the mop methods on the target. it could call them on itself for example.

[13:02:31.0539] <snek>
but oh well

[13:02:51.0874] <bakkot>
how could it check that the ownKeys trap is consistent over time?

[13:03:05.0988] <bakkot>
other than by remembering the results, which gets expensive

[13:03:49.0700] <snek>
imo if its not consistent you just have to enjoy the cthulhu you have unleashed

[13:04:07.0931] <snek>
but i guess folks specifying proxies felt differently

[13:04:11.0810] <bakkot>
personally I like being able to reason about programs

[13:04:29.0086] <bakkot>
and write code which is robust even if other people are doing weird stuff

[13:05:33.0285] <bakkot>
on a normal business webpage there's code from like 20 different vendors interoperating and having _some_ invariants actually enforced by the language is the only thing which makes that work at all

[13:07:58.0981] <bakkot>
(in fact I think proxies already make it far too hard to reason about code, and they should never have been added in the first place. but that ship has sailed.)

[13:09:44.0552] <kriskowal>
I saw Tom van Cutsem’s original Proxy presentation a long time ago. At lunch, Doug Crockford was behind me in line and asked “what do _you_ think of Proxy” and it was obviously a personality test.

[13:11:59.0383] <kriskowal>
I would like to think that I said something clever like, “It’s obviously sharp on both ends.”.

[13:13:11.0712] <kriskowal>
At the same meeting, Doug also said “You should pick either `import("specifier")` or `import "specifier"`. If you pick one or the other, half the room will hate it. If you pick neither, everyone will hate it.

[13:13:32.0249] <shu>
haha we did pick both

[13:13:36.0728] <kriskowal>
It hadn’t occurred to me yet that I should pick both.

[13:14:02.0387] <shu>
anyway i don't like to think

[13:14:19.0450] <shu>
the greatest disservice my college did me was to make me think i ought to enjoy thinking and strive to keep thinking

[13:16:35.0453] <kriskowal>
i’ve always assumed that people who can think get invited to better parties. but, i’ve also found that not going to parties is an effective work-around.

[13:17:11.0116] <shu>
agreed with you there

[13:40:15.0642] <Mathieu Hofman>
The only purpose of the Proxy target is to enforce invariants of the language. Proxies should not create a way to bypass these invariants, or as mentioned it makes it impossible to reason about the program (exotic behaviors already make it hard enough)

[13:52:35.0134] <shu>
i don't understand, proxies makes exotic behavior user-definable

[13:53:05.0321] <shu>
like sure, neither ordinary nor exotic behavior can violate the essential MOP invariants, but proxy's existence makes reasoning about the program much harder

