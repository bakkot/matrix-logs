2023-10-02
[15:16:19.0340] <TabAtkins>
Sorry, I don't want to test this if someone already has the knowledge off-hand: if you array-destructure an actual array, does it invoke the iterator protocol or just yoink from the numbered properties directly. and does this apply to array-likes as well?

[15:25:49.0473] <Richard Gibson>
> <@tabatkins:matrix.org> Sorry, I don't want to test this if someone already has the knowledge off-hand: if you array-destructure an actual array, does it invoke the iterator protocol or just yoink from the numbered properties directly. and does this apply to array-likes as well?

yes to both; array-destructuring is defined to depend upon the iterator protocol (which for most built-ins, particularly including `Array.prototype`, is mutable by ECMAScript code)
DestructuringAssignmentEvaluation

[15:26:01.0728] <Richard Gibson>
> <@tabatkins:matrix.org> Sorry, I don't want to test this if someone already has the knowledge off-hand: if you array-destructure an actual array, does it invoke the iterator protocol or just yoink from the numbered properties directly. and does this apply to array-likes as well?

 * yes to both; array-destructuring is defined to depend upon the iterator protocol (which for most built-ins, particularly including `Array.prototype`, is mutable by ECMAScript code)
[DestructuringAssignmentEvaluation](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-runtime-semantics-destructuringassignmentevaluation)

[15:27:05.0443] <TabAtkins>
k, cool

[15:27:30.0553] <TabAtkins>
that means i don't need to worry about making this more efficient in another proposal ^_^

[16:00:47.0833] <bakkot>
for this reason you will sometimes see people doing `let {0: x, 1: y} = array`, because it skips the iterator protocol

[16:13:53.0558] <Richard Gibson>
aw crud, it looks like every implementation diverges from the spec for `const [] = â€¦`
```
$ eshost -sx '
  "use strict"; 
  const arr = ["a", "b", "c"];
  Object.defineProperty(Array.prototype, Symbol.iterator, {
    get() {
      print("get Symbol.iterator", this);
      return function*() { 
        print("@@iterator", this, ...arguments);
        for (let i = 0; i < this.length; i++) { 
          const v = this[i];
          print("yield", v); 
          yield v; 
        } return; 
      }; 
    }, 
  }); 
  print("\n# read all"); const [...all] = arr; 
  print("\n# read one"); const [first] = arr; 
  print("\n# read none"); const [] = arr; 
  print("\n" + JSON.stringify({ first, all }));
'
#### ChakraCore, engine262, GraalJS, Hermes, JavaScriptCore, Moddable XS, QuickJS, SpiderMonkey, V8
# read all
get Symbol.iterator a,b,c
@@iterator a,b,c
yield a
yield b
yield c

# read one
get Symbol.iterator a,b,c
@@iterator a,b,c
yield a

# read none
get Symbol.iterator a,b,c

{"first":"a","all":["a","b","c"]}
```

(_all three should invoke `@@iterator` and get `next` in [GetIteratorFromMethod](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-getiteratorfrommethod) via [GetIterator](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-getiterator)_)

[16:34:11.0847] <bakkot>
I suspect that's due to implementing the spec as it was prior to https://github.com/tc39/ecma262/pull/1021, and then only doing the update necessary to make https://github.com/tc39/test262/pull/1248 pass

