2023-10-02
[15:16:19.0340] <TabAtkins>
Sorry, I don't want to test this if someone already has the knowledge off-hand: if you array-destructure an actual array, does it invoke the iterator protocol or just yoink from the numbered properties directly. and does this apply to array-likes as well?

[15:25:49.0473] <Richard Gibson>
> <@tabatkins:matrix.org> Sorry, I don't want to test this if someone already has the knowledge off-hand: if you array-destructure an actual array, does it invoke the iterator protocol or just yoink from the numbered properties directly. and does this apply to array-likes as well?

yes to both; array-destructuring is defined to depend upon the iterator protocol (which for most built-ins, particularly including `Array.prototype`, is mutable by ECMAScript code)
DestructuringAssignmentEvaluation

[15:26:01.0728] <Richard Gibson>
> <@tabatkins:matrix.org> Sorry, I don't want to test this if someone already has the knowledge off-hand: if you array-destructure an actual array, does it invoke the iterator protocol or just yoink from the numbered properties directly. and does this apply to array-likes as well?

 * yes to both; array-destructuring is defined to depend upon the iterator protocol (which for most built-ins, particularly including `Array.prototype`, is mutable by ECMAScript code)
[DestructuringAssignmentEvaluation](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-runtime-semantics-destructuringassignmentevaluation)

[15:27:05.0443] <TabAtkins>
k, cool

[15:27:30.0553] <TabAtkins>
that means i don't need to worry about making this more efficient in another proposal ^_^

[16:00:47.0833] <bakkot>
for this reason you will sometimes see people doing `let {0: x, 1: y} = array`, because it skips the iterator protocol

[16:13:53.0558] <Richard Gibson>
aw crud, it looks like every implementation diverges from the spec for `const [] = ‚Ä¶`
```
$ eshost -sx '
  "use strict"; 
  const arr = ["a", "b", "c"];
  Object.defineProperty(Array.prototype, Symbol.iterator, {
    get() {
      print("get Symbol.iterator", this);
      return function*() { 
        print("@@iterator", this, ...arguments);
        for (let i = 0; i < this.length; i++) { 
          const v = this[i];
          print("yield", v); 
          yield v; 
        } return; 
      }; 
    }, 
  }); 
  print("\n# read all"); const [...all] = arr; 
  print("\n# read one"); const [first] = arr; 
  print("\n# read none"); const [] = arr; 
  print("\n" + JSON.stringify({ first, all }));
'
#### ChakraCore, engine262, GraalJS, Hermes, JavaScriptCore, Moddable XS, QuickJS, SpiderMonkey, V8
# read all
get Symbol.iterator a,b,c
@@iterator a,b,c
yield a
yield b
yield c

# read one
get Symbol.iterator a,b,c
@@iterator a,b,c
yield a

# read none
get Symbol.iterator a,b,c

{"first":"a","all":["a","b","c"]}
```

(_all three should invoke `@@iterator` and get `next` in [GetIteratorFromMethod](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-getiteratorfrommethod) via [GetIterator](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-getiterator)_)

[16:34:11.0847] <bakkot>
I suspect that's due to implementing the spec as it was prior to https://github.com/tc39/ecma262/pull/1021, and then only doing the update necessary to make https://github.com/tc39/test262/pull/1248 pass

[16:40:47.0959] <bakkot>
wait, no

[16:40:53.0463] <bakkot>
Richard Gibson your test is just wrong

[16:40:56.0733] <bakkot>
generators don't do anything when invoked

[16:41:15.0727] <bakkot>
(except evaluate parameter defaults IIRC)

[16:41:18.0019] <bakkot>
they only do something when you first call `next`

[16:41:56.0160] <bakkot>
```
"use strict";
const arr = ["a", "b", "c"];
Object.defineProperty(Array.prototype, Symbol.iterator, {
  get() {
    print("get Symbol.iterator", this);
    let thiz = this;
    return function() {
      print("@@iterator", this, ...arguments);
      let i = 0;
      return {
        get next() {
          print("get next");
          return () => {
            return i >= thiz.length ? { done: true } : { done: false, value: thiz[i++] };
          };
        },
      };
    };
  },
});
print("\n# read all"); const [...all] = arr;
print("\n# read one"); const [first] = arr;
print("\n# read none"); const [] = arr;
print("\n" + JSON.stringify({ first, all }));
```
gives
```
# read none
get Symbol.iterator a,b,c
@@iterator a,b,c
get next
```
in all engines, just as it should

[16:44:46.0653] <Richard Gibson>
phew

[16:52:49.0360] <Richard Gibson>
well, not _all_ engines: https://github.com/Moddable-OpenSource/moddable/issues/1223

[16:58:00.0610] <bakkot>
ah yeah I don't have xs installed I guess


2023-10-03
[14:50:50.0455] <James M Snell>
Hello all. I've got a proposal that I'd like to surface for consideration. I put this together after speaking a bit with Matteo Collina and @ljharb... The fundamental idea is to introduce a mechanism for zero-copy concatenation of `ArrayBuffer` in a way that allows the result to still be an `ArrayBuffer` that can be wrapped with a `TypedArray`. The explainer is here: https://github.com/jasnell/proposal-zero-copy-arraybuffer-list/blob/main/README.md

For a quick example:

const ab1 = new ArrayBuffer(10);
const ab2 = new ArrayBuffer(20);
const combined = ArrayBuffer.of(ab1, ab2);

Here, `combined` is effectively a list of the component `ArrayBuffer` instances that is itself an `ArrayBuffer`.

The idea here is adapted from the very popular npm module `bl` which implements a similar idea around Node.js `Buffer` interface but in a way that still has a number of warts.

There is a more detailed example in the explainer. @littledan and ljharb have already graciously provided some extremely helpful feedback.

[14:51:29.0799] <James M Snell>
 * Hello all. I've got a proposal that I'd like to surface for consideration. I put this together after speaking a bit with Matteo Collina and @ljharb... The fundamental idea is to introduce a mechanism for zero-copy concatenation of `ArrayBuffer` in a way that allows the result to still be an `ArrayBuffer` that can be wrapped with a `TypedArray`. The explainer is here: https://github.com/jasnell/proposal-zero-copy-arraybuffer-list/blob/main/README.md

For a quick example:

const ab1 = new ArrayBuffer(10);
const ab2 = new ArrayBuffer(20);
const combined = ArrayBuffer.of(ab1, ab2);
const u8 = new Uint8Array(combined);

Here, `combined` is effectively a list of the component `ArrayBuffer` instances that is itself an `ArrayBuffer`.

The idea here is adapted from the very popular npm module `bl` which implements a similar idea around Node.js `Buffer` interface but in a way that still has a number of warts.

There is a more detailed example in the explainer. @littledan and ljharb have already graciously provided some extremely helpful feedback.

[14:54:50.0704] <bakkot>
cc shu ^ as the arraybuffer guy

[14:57:15.0874] <bakkot>
I know very little about engine internals, but from my own limited perspective, I can say that this seems useful but the cost of making ArrayBuffer fundamentals more complex is usually quite high, so it may not be worth it. It would mean a branch in every access of every TA, or a fair bit of optimization work to avoid that branch.

[15:00:26.0204] <James M Snell>
Indeed, I do not imagine and won't pretend that the implementation would be trivial. Just the fact, for instance, that v8's internal implementation of `v8::ArrayBuffer` is backed by a single `v8::BackingStore` that is expected to be a single contiguous block of memory presents a challenge. However, I think there's enough potential benefit here that it should warrant at least some consideration and if the ultimate answer is it's not worth it, then so be it :-)

[15:00:48.0427] <bakkot>
Also, nit, I am not totally clear on what the utility of `subarray` is supposed to be

[15:01:10.0713] <bakkot>
you can't work with ArrayBuffers directly anyway; you have to use a TA. and TAs are already potentially partial views of an underlying buffer

[15:07:02.0517] <James M Snell>
Suppose I have two `Uint8Arrays` and I want to concat those with zero-copy, taking the byteOffset and byteLength properly into account. subarray would allow for... `new Uint8Array(ArrayBuffer.of(u8a.buffer.subarray(u8a.byteOffset, u8a.byteLength), u8b.buffer.subarray(u8b.byteOffset, u8a.byteLength)))`

[15:07:49.0186] <James M Snell>
Using the existing `ArrayBuffer.prototype.slice(...)` here instead would copy

[15:08:08.0156] <bakkot>
Ah, makes sense

[15:09:24.0176] <bakkot>
Does mean the underlying implementation would need to get even more complicated, but I guess the additional delta isn't that large


2023-10-04
[01:38:40.0145] <rkirsling>
wait a sec

[01:39:16.0566] <rkirsling>
there actually is a surprising thing from that issue just now but it's not the part that the reporter was focused on

[01:39:27.0892] <rkirsling>
```
function foo() {
return
{ x: 1 };
}
```
is ASI, but

[01:39:45.0277] <rkirsling>
```
function foo() {
return
{ x: 1, y: 2 };
}
```
is a SyntaxError

[01:40:22.0826] <rkirsling>
oh oops right, that's true regardless of the `return`.

[01:40:55.0128] <rkirsling>
just an "object literal as expression statement" thing

[01:48:03.0242] <Ashley Claymore>
keyboards needed one more form of brackets so we could distinguish between blocks and objects 

[01:49:51.0405] <rkirsling>
need first-class „Äå„Äç üòé

[01:51:36.0123] <Andreu Botella>
```
function foo() {
return
‚èû
x: 1
‚èü 
}
```


2023-10-05
[17:43:40.0009] <Mathieu Hofman>
> <@jasnell:matrix.org> Hello all. I've got a proposal that I'd like to surface for consideration. I put this together after speaking a bit with Matteo Collina and @ljharb... The fundamental idea is to introduce a mechanism for zero-copy concatenation of `ArrayBuffer` in a way that allows the result to still be an `ArrayBuffer` that can be wrapped with a `TypedArray`. The explainer is here: https://github.com/jasnell/proposal-zero-copy-arraybuffer-list/blob/main/README.md
> 
> For a quick example:
> 
> const ab1 = new ArrayBuffer(10);
> const ab2 = new ArrayBuffer(20);
> const combined = ArrayBuffer.of(ab1, ab2);
> const u8 = new Uint8Array(combined);
> 
> Here, `combined` is effectively a list of the component `ArrayBuffer` instances that is itself an `ArrayBuffer`.
> 
> The idea here is adapted from the very popular npm module `bl` which implements a similar idea around Node.js `Buffer` interface but in a way that still has a number of warts.
> 
> There is a more detailed example in the explainer. @littledan and ljharb have already graciously provided some extremely helpful feedback.

Oh I've been wanting this for years. I think I wrote an issue somewhere!

[17:50:46.0701] <Mathieu Hofman>
I also still really want CoW ArrayBuffer slices. I still do not understand how it would introduce much more complexity than the existing detached checks already required.

[18:03:04.0312] <Mathieu Hofman>
Basically I want to be able to do 
```js
const chunks = [];
chunks.push(chunk1.slice(10));
chunks.push(chunk2);
chunks.push(chunk3.slice(0, 5));
return ArrayBuffer.of(...chunks);
```
Obviously each chunk is received in separate events / iterator yields

[18:04:02.0004] <Mathieu Hofman>
That said I do expect the new combined buffer to itself be a CoW

[18:04:14.0841] <Mathieu Hofman>
And not a passthrough to the underlying buffer

[18:06:07.0397] <James M Snell>
The proposal currently does not include CoW but I can't see a reason why it couldn't be. Will give that some thought

[18:09:04.0054] <Mathieu Hofman>
Btw, in that case it really become a `concat` and the fact that the buffer is in fact a list of smaller buffers is just an unobservable implementation detail

[18:10:31.0138] <James M Snell>
as long as we're able to preserve the zero-copy concat and zero-copy subarray, then I'm fine with that

[18:10:46.0769] <Mathieu Hofman>
Basically I'm really concerned about having multiple ArrayBuffer instances backed by the same underlying data. That's more in the realm of SharedArrayBuffer semantics

[18:12:54.0619] <James M Snell>
True, but to be fair host implementations already give us that ability

[18:13:12.0805] <James M Snell>
(obviously that doesn't mean we should make it easier :-) ...)

[18:16:45.0651] <Mathieu Hofman>
I don't believe any host APIs currently expose that ability, right? I know that JS APIs don't

[18:18:20.0942] <Mathieu Hofman>
Anyway, my motivation for CoW is that I believe it would increase the performance of a ton of existing applications without requiring any code changes

[18:18:39.0329] <Mathieu Hofman>
 * Anyway, my motivation for CoW is that I believe it would increase the performance of a ton of existing applications without requiring any code changes on their end

[18:19:02.0950] <Mathieu Hofman>
I think Luca Casonato shares that belief

[18:19:44.0721] <James M Snell>
With v8, it's fairly trivial to extract a `std::shared_ptr<v8::BackingStore>` and have it shared by multiple `v8::ArrayBuffer` instances

[18:19:56.0503] <James M Snell>
Not ideal, but trivial :-)

[18:25:25.0067] <Luca Casonato>
> <@mhofman:matrix.org> I think Luca Casonato shares that belief

Yes, a general purpose CoW optimization for AB.slice would enable many host APIs to become significantly faster

[18:27:14.0938] <Luca Casonato>
I don‚Äôt think we necessarily need a new API here (I view concat as a related, but separate API - it can make sense with or without the CoW optimization)

[18:27:52.0129] <Luca Casonato>
The nice thing about CoW is that it‚Äôs completely unobservable

[18:28:23.0829] <James M Snell>
Yeah, I'd view the proposal for `ArrayBuffer.of(...)` and CoW as orthogonal. Both nice to have but distinct

[18:29:33.0041] <James M Snell>
If we could get CoW slice, however, there would be no need at all for the `ArrayBuffer.prototype.subarray(...)` that I suggest in the proposal

[18:31:21.0945] <James M Snell>
Also if we had CoW, an argument could be absolutely made also that `ArrayBuffer.of(...)` should automatically slice(0, len) to ensure that the new `ArrayBuffer` is composed entirely of CoW slices

