2024-07-01
[10:49:38.0640] <Michael Ficarra>
will someone tell me why `structuredClone` is in HTML and not ECMAScript?

[10:49:46.0317] <Michael Ficarra>
this kinda thing is going to keep happening https://github.com/whatwg/html/issues/10425

[10:50:20.0862] <littledan>
ask Mark Miller, he has repeated his stance recently that structured clone is somehow bad and shouldn't be moved to ECMAScript. (I don't actually know the reason.)

[10:53:33.0275] <shu>
we got consensus to move it already

[10:53:43.0019] <littledan>
when was that?

[10:53:47.0252] <shu>
it keeps getting deprioritized for me though, probably need some help to work on it

[10:54:07.0599] <shu>
mark's hang up was about making proxies more transparent which i think was fine

[10:54:25.0448] <shu>
but that was planned to be sequenced after the behavior-preserving thing of moving the existing spec into ES

[10:54:27.0223] <shu>
let me dig up notes

[10:54:31.0960] <littledan>
ah OK perfect

[10:54:42.0257] <littledan>
I'm glad I'm wrong

[10:56:31.0084] <shu>
https://github.com/tc39/notes/blob/main/meetings/2022-01/jan-24.md#conclusionresolution-4

[10:56:46.0933] <shu>
would love to actually get started on this, but yeah, probably won't have cycles in the near future either

[11:03:39.0925] <littledan>
great, I'm glad Michael Ficarra is volunteering for this work!

[11:04:56.0208] <littledan>
speaking of relayering, here's a writeup of some of my thoughts about next steps for AbortSignal/AbortController: https://gist.github.com/littledan/47b4fe9cf9196abdcd53abee940e92df

[11:06:31.0248] <littledan>
I got plenty of feedback at the last TC39 meeting that we shouldn't have a separate parallel API, so this is moving in the direction of just slightly evolving the current one, as well as ensuring that it can be used from 262, without duplicating it

[11:08:26.0433] <littledan>
(if the implicit propagation section doesn't make sense because I didn't include usage examples yet, just ignore it)

[11:09:47.0505] <shu>
> <@littledan:matrix.org> great, I'm glad Michael Ficarra is volunteering for this work!

he is?

[11:09:55.0963] <Michael Ficarra>
> <@shuyuguo:matrix.org> he is?

no

[11:10:06.0570] <littledan>
aww, I thought that might work

[11:10:12.0307] <littledan>
was joking

[11:10:22.0750] <Michael Ficarra>
I know your tricks @littledan:matrix.org

[11:12:53.0537] <Andreu Botella>
I wonder if just calling a host hook if the value is an object, and then check the internal fields if it returns `EMPTY`, would just work well enough

[11:14:30.0099] <Andreu Botella>
IIUC, none of the internal slots the algorithm checks can be in a platform object other than [[ErrorData]] (for `DOMException`, and that is handled before the regular error handling)

[11:15:12.0948] <bakkot>
> <@littledan:matrix.org> speaking of relayering, here's a writeup of some of my thoughts about next steps for AbortSignal/AbortController: https://gist.github.com/littledan/47b4fe9cf9196abdcd53abee940e92df

> It is critical to use `addEventListener` rather than `abortSignal.onabort = abortAction` because the latter code would overwrite any other reaction registered on the same `AbortSignal`.

wait, really? I assumed it was a setter

[11:23:59.0500] <littledan>
definitely is a setter, but I may have misunderstood the semantics

[11:27:03.0463] <littledan>
https://html.spec.whatwg.org/multipage/webappapis.html#event-handler-idl-attributes

[11:37:18.0180] <littledan>
the value (single thing to be overwritten) vs listener list (for addEventListener) seems to be how this is specified. The setter sets the value, so it overwrites. A quick test script confirms that behavior is implemented.

[11:37:54.0241] <littledan>
anyway who knows if anyone makes the error in practice of setting .onabort rather than using addEventListener; presumably everyone knows that the setter strategy is deprecated, right?

[11:39:16.0348] <Ashley Claymore>
https://developer.mozilla.org/en-US/play?id=xlGpIW8PMTYxDhfmP5Bok40Q7Lh2gJ2EUfb8FUD5ABh3dk1JhEs7jssU4Enq2Rlwm0b7cRvhw2YJ4uLH

[11:42:06.0836] <littledan>
> <@abotella:igalia.com> I wonder if just calling a host hook if the value is an object, and then check the internal fields if it returns `EMPTY`, would just work well enough

for what?

[11:42:44.0750] <Andreu Botella>
> <@littledan:matrix.org> for what?

in terms of separating the web platform parts of the structured clone algorithm from the JS parts

[11:43:33.0930] <Andreu Botella>
looking at it some more, that could work, but it would need host hook requirements

[11:43:56.0945] <Andreu Botella>
things like, make sure to add an entry to `memory` before calling back into the 262 AO

[11:44:29.0218] <littledan>
yes, there definitely need to be host hooks for structured clone. Generally, I don't think test262 needs to have its hooks correspond to the spec hook structure, though, right?

[11:46:19.0067] <Andreu Botella>
right, I was kind of thinking out loud of a way to do that that would only require one host hook, since the current algorithm has a couple places where it goes from dealing with JS stuff to web platform stuff and back again


2024-07-03
[21:31:07.0465] <snek>
could WeakRef have something like an `is(obj) -> bool` api? i feel like that's safe since `obj` has to be held strongly and any other mismatch is false.

[21:31:15.0209] <snek>
 * could WeakRef have something like an `is(obj) -> bool` method? i feel like that's safe since `obj` has to be held strongly and any other mismatch is false.

[21:53:58.0403] <bakkot>
would that be different from `.deref() == obj`?

[21:54:22.0387] <bakkot>
if not it doesn't seem necessary, unless I'm missing something

[21:54:35.0718] <bakkot>
 * would that be different from `.deref() === obj`?

[00:07:45.0211] <Ashley Claymore>
Would it still `AddToKeptObjects`?

[00:45:46.0426] <Ashley Claymore>
I presume the idea is that it could skip that? But then I think that means this is possible:

```
ref.is(obj); // true
obj = null;
ref.deref(); // undefined, we observed sync GC
```

[09:48:45.0826] <nicolo-ribaudo>
Does the explicit resource management proposal have any tests? I see that there is a feature flag for it in test262, but I cannot find anywhere where it's used

[09:51:32.0761] <nicolo-ribaudo>
I'm trying to validate the Babel implementation

[09:52:30.0975] <littledan>
huh, I thought rbuckton said last meeting that he had some tests

[09:52:35.0301] <littledan>
but I can't find a PR for them

[09:53:47.0486] <rbuckton>
https://github.com/tc39/test262/pull/3866

[09:54:31.0214] <rbuckton>
Though I need to update the tests with some of the recent needs consensus changes. 


2024-07-04
[18:07:40.0320] <snek>
> <@aclaymore:matrix.org> I presume the idea is that it could skip that? But then I think that means this is possible:
> 
> ```
> ref.is(obj); // true
> obj = null;
> ref.deref(); // undefined, we observed sync GC
> ```

it could add `obj` to kept objects i guess. 

[18:07:55.0479] <snek>
the goal is to avoid adding the other thing it holds

[18:08:11.0434] <snek>
 * the goal is to avoid adding whatever it contains if its not `obj`

[19:48:03.0198] <Ashley Claymore>
That makes sense. Only add to kept objects if it returns true should solve the observable GC issue.

[23:11:06.0626] <Mathieu Hofman>
I'm curious about the use case tho. When does one need to test if a weakref contains a certain object. In my experience  if I have a weakref, it's because I don't hold the target. 

[23:13:22.0537] <Mathieu Hofman>
It sounds like one is trying to iterate a set or map of weakref, which is most likely the wrong thing to do in the first place, and sounds like weakmap and weakset should have been used

[15:04:18.0907] <snek>
i was just exploring some ways to implement async context stuff. i think you're right that it's probably not needed. you could give each variable a unique id and compare the ids instead of comparing the contents of the weakrefs


2024-07-05
[20:19:31.0064] <Jack Works>
> <@softwarechris:matrix.org> the longer answer is that in order to get some flavor of `sleep()`, you would have to add various other things in the language first in order to support it

well, we already have timers in the spec, in the Atomics.

[20:20:40.0816] <Jack Works>
> <@sirisian:matrix.org> Maybe I'm blanking since I forget proposals. Has anyone suggested an operator like f??.() that is equivalent to `typeof f === 'function' ? f() : f` ?

rather than this, I have a lot of code doing things like `expr ? f(expr) : undefined`

[20:27:00.0445] <Jack Works>
> <@littledan:matrix.org> Are there particular design mistakes we might make with scheduler?

since `.wait` is not available for now, I don't think `await scheduler.postTask(() => {}, { delay: time })` is better in any sense than `await new Promise(r => setTimeout(r, time))` in this use case. The old classic one is even shorter.

```js
await scheduler.postTask(() => {}, { delay: time })
await new Promise(r => setTimeout(r, time))
await scheduler.wait(time) // but it is not here yet!
```

[20:32:45.0813] <Jack Works>
> <@shaylew:matrix.org> I wonder how far just pattern matching gets you in that domain. (might be asking a lot from the type inference)

a lot, but we may not get all the features mentioned below (since the committee think it contains too much things)

```js
match (userData) {
    when { type: 'a', field: Number and > 0 and < 100 }: ...
    default: ...
}
```

[20:42:16.0426] <Jack Works>
> <@dalechyn:matrix.org> Hi folks! Great seeing TC39 being an open and collaborative space!
> I joined here to express the problems and possible solutions over JSON serialization when it comes to `BigInt` type.
> 
> I originally come from Web3 where we are dealing with `uint256` â€“ 32byte unsigned integer values and folks from Web3 space used to align on third party libraries to support numbers that big (https://github.com/GoogleChromeLabs/jsbi) until the official support for `BigInt`s came live in 2020!
> There have been many editions of ECMA-262 published since 1999, and to my belief it needs an upgrade to handle `BigInt` types.
> 
> I will be honest I did not spend that much time to research the efforts of handling such but I've seen many discussions evolving around somehow "smartly" detecting wether a number value should be parsed as a `BigInt` or `Number`. I don't believe that those are correct nor backwards compatible.
> 
> What if JSON as a whole could retrieve an upgrade to support BigInt literals ending with "n", as it does now in JS?
> 
> ```json
> {
>   "value": 1337n
> }
> ```
> 
> I'd like to hear your thoughts wether you think if this possible and if so, what kind of backwards incompatibility issues this might have!
> Regarding the latter I don't think this will introduce any issues as this addition doesn't change the serialization behavior of fields of other types â€“ but instead introduces a new one.
> I understand that making an addition like this is gonna introduce chain of changes of parsing JSON in different programming languages, but I believe this needs a review.
> 
> 

JSON numbers don't have a limit on numbers, you can already represent bigint numbers. you just need a special serializer.

```js
JSON.stringify({ x: 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999n }, (key, val) => typeof val === 'bigint' ? JSON.rawJSON(val) : val)
```

[20:58:15.0777] <Jack Works>
* JSON numbers don't have a limit on numbers, you can already represent bigint numbers. you just need a special serializer.

```js
JSON.stringify({ x: 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999n
 }, (key, val) => typeof val === 'bigint' ? JSON.rawJSON(val) : val)
```

[03:38:58.0757] <Danielle Church>
> <@jackworks:matrix.org> JSON numbers don't have a limit on numbers, you can already represent bigint numbers. you just need a special serializer.
> 
> ```js
> JSON.stringify({ x: 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999n
>  }, (key, val) => typeof val === 'bigint' ? JSON.rawJSON(val) : val)
> ```

you could establish a convention like serializing bigints with an `e-0` suffix, which is highly unlikely to occur in nature; most serializers probably wouldn't include a zero exponent at all, or else they'd use `e+0`. Not to mention, typical numeric formatters using the exponent output in scientific notation, which includes a decimal point and thus is syntactically distinguishable from `JSON.stringify(15n) === "15e-0"`.

[04:32:43.0085] <annevk>
Speaking of JSON, https://www.mlsec.org/docs/2024b-asiaccs.pdf might be of interest

[07:47:46.0139] <Michael Ficarra>
why are we getting so much spam on github lately?!


2024-07-07
[06:31:01.0857] <nullvoxpopuli>
If anyone is curious, the Signals proposal community call will be here on Tuesday at 11a ET: https://us02web.zoom.us/j/84763180621?pwd=bjVBT1B4dzdhdk80V3lQZG41eEVCZz09
Timezone converter: https://www.worldtimebuddy.com/?qm=1&lid=5128581,5368361,2643743,2950159,2147714,1850147&h=5128581&date=2024-7-9&sln=11-12&hf=1


2024-07-08
[17:27:21.0219] <snek>
is it reasonable for implementations to throw an error for `Array.prototype.sort.call({length: Infinity})`? currently jsc and quickjs get stuck in an infinite loop, spidermonkey and xs raise an error, and v8 and engine262 hard crash. i assume the two that get stuck in an infinite loop will eventually throw or crash either way.

[17:28:34.0836] <bakkot>
we currently underspecify resource limits in general; in practice most resource limits eventually hit a RangeError or something similar

[17:28:57.0035] <bakkot>
or a panic, in some cases

[17:29:07.0811] <bakkot>
so, yes, it's reasonable although not strictly allowed by the specification

[22:02:46.0165] <Michael Ficarra>
it would be nice if we stopped pretending implementations have infinite resources some day

[22:57:50.0804] <Meghan Denny>
i think its less about pretending limits dont exist and more about letting those limits be implementation defined

[22:58:55.0733] <Meghan Denny>
or host/environment defined

[23:25:03.0003] <Meghan Denny>
saying more about what happens when those limits are reached could still be useful tho, if thats what u mean

[23:25:07.0553] <Meghan Denny>
read it back again

[01:41:45.0887] <littledan>
I think we do currently let them be implementation-defined, and the main questions are:
- Do we want to define always throwing an exception, or always crashing, when they are reached? (I vote crash if it is web compatible)
- Do we want to define some of the limits? Wasm does, and it seems to work well for them. https://webassembly.github.io/spec/js-api/index.html#limits

[07:00:47.0983] <Richard Gibson>
related: https://github.com/tc39/ecma262/issues/2623

[07:23:08.0444] <snek>
> <@littledan:matrix.org> I think we do currently let them be implementation-defined, and the main questions are:
> - Do we want to define always throwing an exception, or always crashing, when they are reached? (I vote crash if it is web compatible)
> - Do we want to define some of the limits? Wasm does, and it seems to work well for them. https://webassembly.github.io/spec/js-api/index.html#limits

crashing is web compatible? lol

[07:23:34.0254] <snek>
* crashing can be web compatible? lol

[07:24:18.0382] <annevk>
Should have made `new ArrayBuffer(too-large)` crash rather than throw.

[07:25:15.0419] <snek>
are we using crash with a different meaning than I'm used to

[07:26:16.0377] <Meghan Denny>
i take crash to mean in a way that stops all js execution but not the whole page; like html would still be interactable

[07:27:02.0077] <snek>
intentional and controlled vm halt sounds ok

[07:27:45.0604] <snek>
I'm referring to like v8 just std::abort()ing somewhere in the heap allocator, which is not great

[07:30:33.0999] <annevk>
That's not how people are thinking about it as far as I know. The complete website would crash. It's all rather intermingled so it's not even clear to me you could split it that way.

[07:33:00.0512] <Bradford Smith>
The links to the notes docs for the last meeting on https://github.com/tc39/Reflector/issues/527 all point to empty documents. What happened here? I need to check the notes for the 3rd day, because I didn't attend that one.

[07:42:38.0891] <Michael Ficarra>
@bradfordcsmith:matrix.org The version history shows someone cleared them out on July 4th. We should probably revert back to the previous version. Ping the chairs about it on the Reflector thread.

[07:46:05.0054] <Bradford Smith>
> <@michaelficarra:matrix.org> @bradfordcsmith:matrix.org The version history shows someone cleared them out on July 4th. We should probably revert back to the previous version. Ping the chairs about it on the Reflector thread.

done

[08:05:13.0264] <littledan>
no it has to kernel panic or it doesn't count

[08:05:54.0160] <littledan>
it invokes the HCF instruction

[08:05:59.0532] <Andreu Botella>
bah, that's nothing, it has to actively fry the hardware

[10:03:29.0815] <Ashley Claymore>
the google doc being cleared is usually a sign that the text has been moved to another doc, usually just before the notes PR

[10:03:45.0749] <Ashley Claymore>
to avoid people making edits that will get ignored as it's too late to edit

[10:53:29.0489] <Richard Gibson>
 * related: https://github.com/tc39/ecma262/issues/2623 

[10:53:36.0869] <Richard Gibson>
 * related: https://github.com/tc39/ecma262/issues/2623

[10:53:42.0408] <Richard Gibson>
 * related: https://github.com/tc39/ecma262/issues/2623 

[10:53:48.0473] <Richard Gibson>
 * related: https://github.com/tc39/ecma262/issues/2623

[12:56:54.0351] <Bradford Smith>
> <@aclaymore:matrix.org> the google doc being cleared is usually a sign that the text has been moved to another doc, usually just before the notes PR

So, I guess it's just my bad luck that I need to read the notes in the time between the docs being wiped and the final notes being posted. Drat.

[12:59:33.0039] <Bradford Smith>
It's not a big deal, really. I'm scheduled to give a summary of the meeting to a group at work in a couple of hours. I'll just tell them about the parts I did attend.

[13:00:03.0632] <Bradford Smith>
At this point I don't have time to spend reading the notes even if they suddenly became available.

[13:24:54.0016] <Ashley Claymore>
Yeah. Unfortunate timing!

[13:43:02.0423] <Michael Ficarra>
it's not a perfect process, unfortunately ðŸ«¤

[13:59:45.0003] <Chris de Almeida>
> <@bradfordcsmith:matrix.org> So, I guess it's just my bad luck that I need to read the notes in the time between the docs being wiped and the final notes being posted. Drat.

you should always be able to get to the notes in one form or another, at any time.  let me know if you are still having trouble


2024-07-09
[00:50:47.0603] <littledan>
Yay, notes posted at https://github.com/tc39/notes/pull/330

[00:50:55.0562] <littledan>
Thanks Aki 


2024-07-16
[12:49:34.0340] <nicolo-ribaudo>
https://tc39.es/ecma262/multipage/additional-ecmascript-features-for-web-browsers.html#sec-web-compat-host-make-job-callback

Should we remove the restriction that only web browsers can pass custom data in HostMakeJobCallback? Both Node.js and Demo already violate that restriction anyway, by implementing AsyncLocalStorage

[13:01:01.0245] <nicolo-ribaudo>
* https://tc39.es/ecma262/multipage/additional-ecmascript-features-for-web-browsers.html#sec-web-compat-host-make-job-callback
Should we remove the restriction that only web browsers can pass custom data in HostMakeJobCallback? Both Node.js and Deno already violate that restriction anyway, by implementing AsyncLocalStorage


[13:12:25.0939] <Michael Ficarra>
> <@nicolo-ribaudo:matrix.org> https://tc39.es/ecma262/multipage/additional-ecmascript-features-for-web-browsers.html#sec-web-compat-host-make-job-callback
> Should we remove the restriction that only web browsers can pass custom data in HostMakeJobCallback? Both Node.js and Deno already violate that restriction anyway, by implementing AsyncLocalStorage
> 

do you have any information on why it was originally scoped to only web browsers?

[13:20:07.0989] <Meghan Denny>
i dont think it means only web browsers can implement it, moreso that you can not implement it and still be conforming and that web browsers are the most common use case that would need/implement those features

[13:23:25.0239] <Meghan Denny>
i see 9.5.2 says 'must'

[13:23:35.0823] <Meghan Denny>
 * oh, i see 9.5.2 says 'must'

[14:22:34.0928] <ljharb>
we often have allowed browsers to do something "icky" out of necessity but intended to require non-browsers to do the better thing

[14:38:55.0638] <Andreu Botella>
it seems like one half of what those host hooks do is keeping track of which is the "incumbent realm", which according to littledan could be refactored to be built on top of AsyncContext

[14:39:32.0306] <Andreu Botella>
the other half of what they do seems to be making it so the dynamic import in `Promise.resolve('import(`./example.mjs`)').then(eval);` resolves relative to the script active when the promise job is enqueued

[14:39:45.0448] <Andreu Botella>
and I wonder what Node.js does there, and whether we want to keep this behavior or not

[14:40:33.0475] <Andreu Botella>
 * the other half of what they do seems to be making it so the dynamic import in ``Promise.resolve('import(`./example.mjs`)').then(eval);`` resolves relative to the script active when the promise job is enqueued

[14:41:15.0492] <Andreu Botella>
 * and I wonder what Node.js does there, and whether we would want to keep this behavior or not if there were no web compat concerns

[14:45:22.0061] <shu>
> <@michaelficarra:matrix.org> do you have any information on why it was originally scoped to only web browsers?

because at the time, it was understood that the expressivity this hook enabled was 1) tantamount to dynamic scope, which Mark & co objected to philosophically, and 2) it described the reality of the incumbent settings object on the web

so the reconcile the two, the decision was to reflect reality by speccing it, but limit it to the only implementation that needed it

[14:45:46.0468] <shu>
since then, i suppose those objectors have gotten over the philosophical objection that it was tantamount to unacceptabel dynamic scope, given the enthusiasm about AsyncContext


2024-07-17
[20:16:37.0286] <ljharb>
that aspect may not have been made clear to those objectors tho; asynccontext is a tough proposal to grok imo

[21:00:56.0000] <kriskowal>
> <@shuyuguo:matrix.org> since then, i suppose those objectors have gotten over the philosophical objection that it was tantamount to unacceptabel dynamic scope, given the enthusiasm about AsyncContext

Mark did a rather rigorous analysis of AsyncContext last year to settle those objections preemptively. I was taking a walk with my neighbor Malte Ubl who mentioned Vercel had hired Justin and that he was excited to push AsyncContext. My first thought was that our friendship might not endure that tension, but I arranged for Mark and Justin to talk thru how the design addresses OCap concerns over four or so meetings and weâ€™re good now. 

[21:02:00.0989] <kriskowal>
Enthusiastic even, since we need such a thing for causal tracing. 

[21:11:44.0491] <kriskowal>
> <@abotella:igalia.com> the other half of what they do seems to be making it so the dynamic import in ``Promise.resolve('import(`./example.mjs`)').then(eval);`` resolves relative to the script active when the promise job is enqueued

I believe the dynamic import *should* be resolved in the context of the script associated with the environment record internal slot on the globalThis.eval in the lexical scope. Else, bug.

[21:12:05.0019] <kriskowal>
Also https://github.com/tc39/ecma262/issues/3160

