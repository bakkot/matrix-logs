2025-05-01
[11:57:26.0768] <jschoi>
I’m working on [#3581](https://github.com/tc39/ecma262/pull/3581) (Array.fromAsync).
 I’m figuring out the last two esmeta errors in [this job](https://github.com/tc39/ecma262/actions/runs/14781083646/job/41499977134?pr=3581). 

It looks like Array.from’s iteration machinery has changed a lot since I last checked. Now Array.from uses a new IteratorStepValue operation. 

There’s no analogous AsyncIteratorStepValue operation yet, is there?

[12:03:49.0924] <bakkot>
Correct

[12:03:55.0128] <jschoi>
Would it be worth for the Array.fromAsync pull request to define new AsyncIteratorStepValue, AsyncIteratorStep, and AsyncIteratorNext operations?

[12:04:07.0239] <bakkot>
No, probably not until there's more stuff which uses it

[12:04:09.0220] <jschoi>
* Would it be worth for the Array.fromAsync pull request to define new AsyncIteratorStepValue, AsyncIteratorStep, and AsyncIteratorNext operations, to match Array.from’s algorithm?

[12:05:53.0805] <bakkot>
You can use the underlying operations, though

[12:06:32.0107] <bakkot>
IteratorNext works fine on async iterators I think

[12:06:57.0067] <bakkot>
and then after awaiting the result you can use IteratorComplete and IteratorValue

[12:08:23.0861] <bakkot>
which I guess is pretty much what you're doing already, except manually calling .next instead of using IteratorNext, which is fine

[12:08:47.0583] <bakkot>
don't worry too much about esmeta errors; if they don't look like actual errors you can ignore them

[12:09:24.0650] <bakkot>
it isn't capable of handling everything in the spec and there's a file we can use to mark things as expected errors if we decide it's an esmeta bug

[12:10:28.0991] <bakkot>
in this specific case, yes, it looks like it's because of not recognizing the new IfAbruptCloseAsyncIterator macro, which makes sense; macros are hard to typecheck and we don't have any explicit marking for them

[12:29:07.0148] <jschoi>
Thank you very much for your great help.


2025-05-03
[10:22:42.0260] <Jack Works>
Is the content I added implicitly given somewhere? Or is it a mistake? (CompileAtom is not explicitly defined for production `Atom :: \ AtomEscape`, but is defined for `AtomEscape`)

[10:27:00.0937] <nicolo-ribaudo>
https://tc39.es/ecma262/#sec-algorithm-conventions-syntax-directed-operations

> Unless explicitly specified otherwise, all chain productions have an implicit definition for every operation that might be applied to that production's left-hand side nonterminal. The implicit definition simply reapplies the same operation with the same parameters, if any, to the chain production's sole right-hand side nonterminal and then returns the result.


2025-05-04
[08:37:09.0833] <Jack Works>
Is this correct? For RegExp: `/[\p{Hex}]/u`:

https://tc39.es/ecma262/#sec-compiletocharset

For production ` UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue`, `s` is `Hex`, in step 2 it calls `UnicodeMatchPropertyValue(General_Category, s)`

UnicodeMatchPropertyValue (https://tc39.es/ecma262/#sec-runtime-semantics-unicodematchpropertyvalue-p-v)
2. Assert: v (in this case, `Hex`) is a property value or property value alias for the Unicode property p (in this case, General_Category) listed in PropertyValueAliases.txt.

https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt

And in https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt, there is no entry starts with `gc ; Hex` so this assert should fail.

Did I miss something? Thanks!

[08:37:58.0270] <Jack Works>
* Is this correct? For RegExp: `/[\p{Hex}]/u`:

https://tc39.es/ecma262/#sec-compiletocharset

For production ` UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue`, `s` is `Hex`, in step 2 it calls `UnicodeMatchPropertyValue(General_Category, s)`

`UnicodeMatchPropertyValue` (https://tc39.es/ecma262/#sec-runtime-semantics-unicodematchpropertyvalue-p-v)
2. Assert: `v` (in this case, `Hex`) is a property value or property value alias for the Unicode property `p` (in this case, General_Category) listed in PropertyValueAliases.txt.

https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt

And in https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt , there is no entry starts with `gc ; Hex` so this assert should fail.

Did I miss something? Thanks!

[09:06:13.0933] <bakkot>
yeah that looks like a bug

[09:06:52.0918] <bakkot>
you should open an issue and cc `@mathiasbynens`

[09:28:51.0800] <Jack Works>
https://github.com/tc39/ecma262/issues/3586

[09:59:18.0932] <jmdyck>
Doesn't that fail the early error?

[10:00:21.0659] <jmdyck>
(The one that says it's a Syntax Error if that Assert would fail.)

[10:01:27.0408] <jmdyck>
Or am I missing the crux of the example?

[10:04:38.0803] <bakkot>
`/[\p{Hex}]/u` is intended to be legal, I am pretty sure

[10:04:42.0514] <bakkot>
certainly it is treated as such

[10:04:51.0935] <bakkot>
* certainly it is treated as such in actual implementations

[10:06:28.0618] <jmdyck>
oh, actually, that early error rule is okay, because "Hex" appears in Table 70.

[10:06:42.0586] <jmdyck>
* oh, actually, that early error rule passes, because "Hex" appears in Table 70.

[10:45:13.0214] <Richard Gibson>
PR to fix: https://github.com/tc39/ecma262/pull/3587


2025-05-05
[13:15:43.0660] <jschoi>
With regards to the Stage 4 criterion “pull request has been sent to tc39/ecma262 or tc39/ecma402, as appropriate, with the integrated spec text”, is Stage 4 for Array.fromAsync blocked by [#2942](https://github.com/tc39/ecma262/pull/2942) merging into main because its pull request ([#3581](https://github.com/tc39/ecma262/pull/3581)) is based on #2942?

This is assuming that the editors sign off on #3581, which is blocking both Stage 3 and Stage 4.

[13:20:33.0703] <bakkot>
No

[13:20:53.0503] <bakkot>
Or rather, to be precise, it is blocked from merging into main, but that's fine

[13:21:41.0097] <jschoi>
Excellent, thank you. It sounds like I can request Stage 4 for Array.fromAsync at this month’s plenary, assuming that #3581 gets editor sign-off.

[13:22:44.0437] <bakkot>
Yes, and also you should add it to the agenda when you're ready without first waiting for the editors; editors generally prioritize reviewing things which are on the agenda


2025-05-06
[21:23:44.0661] <Jack Works>
Is this an Annex B only test?

https://github.com/tc39/test262/blob/93d63969bccbf8b4471b7c7fadc875099b7668d3/test/language/literals/regexp/S7.8.5_A1.4_T2.js#L4

It constructed a RegExp like this:
`new RegExp('\\' + String.fromCodePoint(8204))`

It parsed as IdentityEscape. In the main spec it is `[~UnicodeMode] SourceCharacter but not UnicodeIDContinue`, (btw 8204 is a UnicodeIDContinue), but in annex B it is

`
[~NamedCaptureGroups] SourceCharacter but not c
[+NamedCaptureGroups] SourceCharacter but not one of c or k
`

[21:23:55.0723] <Jack Works>
* Is this an Annex B only test?

https://github.com/tc39/test262/blob/93d63969bccbf8b4471b7c7fadc875099b7668d3/test/language/literals/regexp/S7.8.5_A1.4_T2.js#L4

It constructed a RegExp like this:
`new RegExp('\\' + String.fromCodePoint(8204))`

It parsed as IdentityEscape. In the main spec it is `[~UnicodeMode] SourceCharacter but not UnicodeIDContinue`, (btw 8204 is a UnicodeIDContinue), but in annex B it is

```
[~NamedCaptureGroups] SourceCharacter but not c
[+NamedCaptureGroups] SourceCharacter but not one of c or k
````

[21:24:01.0073] <Jack Works>
* Is this an Annex B only test?

https://github.com/tc39/test262/blob/93d63969bccbf8b4471b7c7fadc875099b7668d3/test/language/literals/regexp/S7.8.5_A1.4_T2.js#L4

It constructed a RegExp like this:
`new RegExp('\\' + String.fromCodePoint(8204))`

It parsed as IdentityEscape. In the main spec it is `[~UnicodeMode] SourceCharacter but not UnicodeIDContinue`, (btw 8204 is a UnicodeIDContinue), but in annex B it is

```
[~NamedCaptureGroups] SourceCharacter but not c
[+NamedCaptureGroups] SourceCharacter but not one of c or k
````

[21:27:35.0494] <Jack Works>
(also for language/literals/regexp/S7.8.5_A2.4_T2.js)


2025-05-07
[02:02:30.0685] <Jack Works>
CharacterClassEscape[UnicodeMode] :: 
[+UnicodeMode] p{ UnicodePropertyValueExpression }
[+UnicodeMode] P{ UnicodePropertyValueExpression } 

Is it missing a [+UnicodeSetsMode] version of those 2 production? otherwise I cannot find a way to parse `/^\p{Basic_Emoji}+$/v`

[02:02:39.0627] <Jack Works>
* ```
CharacterClassEscape[UnicodeMode] :: 
[+UnicodeMode] p{ UnicodePropertyValueExpression }
[+UnicodeMode] P{ UnicodePropertyValueExpression } 
```

Is it missing a [+UnicodeSetsMode] version of those 2 production? otherwise I cannot find a way to parse `/^\p{Basic_Emoji}+$/v`

[03:26:20.0323] <jmdyck>
In the spec, `+UnicodeSetsMode` only occurs in conjunction with `+UnicodeMode`. (i.e., roughly, `USM` implies `+UM`, or `+USM` is a subset of `+UM`), so any RHS guarded by `[+UM]` 'succeeds' for all cases of `+USM`.

[03:26:51.0212] <jmdyck>
I think.

[03:28:19.0938] <jmdyck>
* In the spec, `+UnicodeSetsMode` only occurs in conjunction with `+UnicodeMode`. (i.e., roughly, `+USM` implies `+UM`, or `+USM` is a subset of `+UM`), so any RHS guarded by `[+UM]` 'succeeds' for all cases of `+USM`.

