2021-12-04
[17:44:17.0686] <jschoi>
sarahghp: I’m taking a look at your slides for the Decimal update. I’m a little confused by the “Standard Library” slide, as well as the subsequent “Downsides of Object-Based Operator Overloading” slide’s mentioning of Math.max. Could you clarify whether your current plan still to latch onto BigInt Math’s polymorphic Math extensions, or is it to add new methods to the Decimal global object? And what does Math.max have to do with operator overloading?

[17:44:35.0751] <jschoi>
https://drive.google.com/file/d/1qdieei11dZgDY_KnJhSBcFyHTMZOmCJr/view

[17:45:22.0509] <jschoi>
https://github.com/tc39/proposal-bigint-math/issues/14#issuecomment-952024624

[17:45:48.0431] <jschoi>
(I’m not planning to present an update on BigInt Math in the next plenary, until its chartered incubator meeting occurs.)


2021-12-05
[01:22:59.0290] <pokute>
I've been dogfooding my TypeScript support for pipeline operator at https://github.com/Pokute/AoC2021/blob/main/4.ts . It's starting to feel crucial for me. Lacking tacit function application (`|>>`) would be an inconvenience, but the other way around, I would have so many IIAFEs.

[12:28:14.0006] <bakkot>
A proposal: https://gist.github.com/bakkot/3d0f81233fc00b508ae5f247b1458823

tl;dr: adding syntax for defining a function which can be either sync or async, depending on how it's called:

```
async? function f(possiblyAsyncCallback) {
  let x = await? possiblyAsyncCallback();
  return something(x);
}

console.log(f.sync(syncCallback)) // a regular value

console.log(f.async(asyncCallback)) // a Promise
```


[12:28:39.0205] <bakkot>
looking for any feedback on whether this seems at all reasonable before I put together something to present to committee

[12:46:40.0787] <Justin Ridgewell>
> <@bakkot:matrix.org> A proposal: https://gist.github.com/bakkot/3d0f81233fc00b508ae5f247b1458823
> 
> tl;dr: adding syntax for defining a function which can be either sync or async, depending on how it's called:
> 
> ```
> async? function f(possiblyAsyncCallback) {
>   let x = await? possiblyAsyncCallback();
>   return something(x);
> }
> 
> console.log(f.sync(syncCallback)) // a regular value
> 
> console.log(f.async(asyncCallback)) // a Promise
> ```
> 

Have you seen [gensync](https://github.com/loganfsmyth/gensync) before?

[12:48:48.0223] <bakkot>
I had not!

[12:49:23.0938] <bakkot>
but that is basically exactly the same thing, neat

[12:55:25.0120] <loganfsmyth>
Let me know if you have suggestions for improvements, I think babel is the only thing really using it right now.

[13:08:22.0683] <bakkot>
main thing which looks to be missing to me is a way for the function to switch on whether it was called as sync or async

[13:08:36.0799] <bakkot>
so that it can e.g. call the appropriate sync or async version of some other API

[13:09:11.0512] <bakkot>
(my gist has a `function.async` meta-property for this; it would be a bit harder to do in a library)

[13:14:43.0048] <loganfsmyth>
Got it, should be pretty easy for you to make a helper to do that since you can make a function where the async version returns true and the sync version returns false and then do `if (yield* isAsync()) {`

[14:28:43.0592] <nicolo-ribaudo>
> <@loganfsmyth:mozilla.org> Got it, should be pretty easy for you to make a helper to do that since you can make a function where the async version returns true and the sync version returns false and then do `if (yield* isAsync()) {`

Yup, Babel already has it: https://github.com/babel/babel/blob/2a3b0b96012b86c558aec344dad34a60c51a71c9/packages/babel-core/src/gensync-utils/async.ts#L23

[14:31:24.0391] <loganfsmyth>
Hah I though it did but I was on mobile and couldn't be bothered to look

[14:32:17.0760] <loganfsmyth>
Certainly something we could move into gensync too

[14:34:24.0124] <nicolo-ribaudo>
Btw, something that would greatly benefit from moving this to the language (rather than as a library) are stack traces and step-by-step debugging; gensync makes it really hard (this is not a critique, just a limitation I don't think can be solved in a library).

[14:53:16.0547] <bakkot>
I think the main annoying thing with the library version is that you can't call regular async functions without wrapping them first (unless I'm missing something)

[14:53:40.0391] <bakkot>
not a huge hinderance but would be nicer not to need to worry about it

[14:54:10.0610] <bakkot>
anyway, this is really cool; I will play with it some

[14:55:35.0817] <nicolo-ribaudo>
Well, it's `await? (function.async ? asyncFn() : syncFn())` vs `yield* gensync({ sync: syncFn, async: asyngFn })()` (you need the check in both versions)

[14:55:49.0361] <nicolo-ribaudo>
> <@bakkot:matrix.org> I think the main annoying thing with the library version is that you can't call regular async functions without wrapping them first (unless I'm missing something)

 * Well, it's `await? (function.async ? asyncFn() : syncFn())` vs `yield* gensync({ sync: syncFn, async: asyngFn })()` (you need the check in both versions)

[14:55:54.0503] <nicolo-ribaudo>
But yes, you always need to wrap

[14:56:52.0183] <bakkot>
with the syntax you need to wrap if you're calling a function you figured out yourself, but not if you're calling a function the user provided

[14:57:27.0592] <bakkot>
i.e. you can just do `await? callback()` and if the user called you as `f.async` and passed an async callback, or if the user called you as `f.sync` and passed a sync callback, it will work the same

[14:57:37.0815] <bakkot>
and `callback` doesn't need to be wrapped

[14:58:31.0397] <nicolo-ribaudo>
Oh ok yes, we had to introduce a `maybeAsync` gensync helper in Babel for that

[14:58:45.0884] <nicolo-ribaudo>
(which also throws if `callback()` returns a promise when called in a sync context)

[14:58:51.0361] <nicolo-ribaudo>
 * (which also throws if `callback()` returns a promise when called in a sync context)

[14:59:31.0422] <bakkot>
yeah there's definitely some possibility of shooting yourself in the foot here, if you mess up what's async and what's sync

[15:00:08.0568] <bakkot>
this would be fun for typescript to figure out :P


2021-12-06
[08:08:56.0584] <ljharb>
that seems like precisely a proposal for releasing z̲̗̼͙̥͚͛͑̏a̦̟̳͋̄̅ͬ̌͒͟ļ̟̉͌ͪ͌̃̚g͔͇̯̜ͬ̒́o̢̹ͧͥͪͬ 

[08:09:22.0128] <ljharb>
it's been a pretty consistent design principle that a thing should always or never return a promise, which is why throwing in the default argument position in an async function produces a rejected Promise

[08:09:27.0280] <ljharb>
 * it's been a pretty consistent design principle that a thing should always or never return a promise, which is why throwing in the default argument position in an async function produces a rejected Promise

[08:10:23.0630] <nicolo-ribaudo>
I think with that proposal `fn.async()` would always return a promise, and `fn.sync()` would never return a promise

[08:57:22.0482] <ljharb>
oh maybe i misunderstood, it produces "not a function", but an object with two functions on it?

[10:33:38.0980] <bakkot>
yeah

[10:34:08.0472] <bakkot>
one which always returns a promise, one which never does (unless you go out of your way to return a promise explicitly, I guess)

[11:07:27.0631] <TabAtkins>
> <@pokute:matrix.org> I've been dogfooding my TypeScript support for pipeline operator at https://github.com/Pokute/AoC2021/blob/main/4.ts . It's starting to feel crucial for me. Lacking tacit function application (`|>>`) would be an inconvenience, but the other way around, I would have so many IIAFEs.

Could you elaborate, perhaps in the Pipeline Champions room?

[11:08:52.0317] <TabAtkins>
Oh I see, you're saying that the current proposal (Hack, not F#) is slightly inconvienent, but if we'd gone the other way (F#, not Hack) you'd have a ton of IIAFEs which would be even worse.

[13:41:57.0691] <pokute>
Exactly. I love how easy it's write `|>> func` instead of `|> func(#)`. If I had only hack-style then I would have to write a lot of stuff in completely different ways.

[13:44:32.0887] <pokute>
TabAtkins: Is the Pipeline Champions room public?

[13:44:47.0106] <TabAtkins>
yup

[13:46:59.0919] <pokute>
Can't find it, tried multiple different search terms.

[13:47:33.0591] <pokute>
 * Exactly. I love how easy it's write `|>> func` instead of `|> func(#)`. If I had only F#-style then I would have to write a lot of stuff in completely different ways.

[14:13:50.0954] <TabAtkins>
Ah it looks like one has to give their room a name for it be found by searching. @pokute does #tc39-pipeline:matrix.org work now?

[14:24:08.0995] <bakkot>
TabAtkins: if you intend it to be public you might also want to give it public history

[14:24:23.0470] <bakkot>
if you do that my logbot will pick it up

[14:26:49.0897] <TabAtkins>
done

[14:32:18.0375] <bakkot>
doesn't look done to me

[14:34:42.0547] <TabAtkins>
all history is public from here onward; i haven't turned on previous history. does your bot require that for some reason?

[14:51:37.0283] <bakkot>
no, history is public _to members_, also not as "not public"

[14:52:13.0039] <bakkot>
it's impossible to turn on previous history, afaik; putting it to "anyone" (at least according to the docs) will only make history visible from that point forward

[14:52:32.0058] <bakkot>
> Changes to who can read history will only apply to future messages in this room. The visibility of existing history will be unchanged.

[14:54:36.0577] <bakkot>
the bot only generates logs for rooms with history visibility set to "Anyone", since the effect of the bot is that it publishes public logs, which I only want to do if you sign up for making history public

[14:58:26.0500] <pokute>
> <@tabatkins:matrix.org> Ah it looks like one has to give their room a name for it be found by searching. @pokute does #tc39-pipeline:matrix.org work now?

That direct link works, but I still couldn't find it with search.

[14:58:59.0349] <TabAtkins>
well i have no idea how the search works, so i guess that'll have to be sufficient


2021-12-07
[10:47:24.0279] <shu>
Matrix experts: what am i doing wrong such that when i log into Matrix on multiple machines, some of my DM history is all error messages with "unable to decrypt"?

[10:56:50.0174] <graingert>
> <@shuyuguo:matrix.org> Matrix experts: what am i doing wrong such that when i log into Matrix on multiple machines, some of my DM history is all error messages with "unable to decrypt"?

probably you didn't add your new device?

[10:56:59.0707] <graingert>
you need to do the barcode thingy

[10:58:17.0238] <shu>
i don't recall that popping up at all, so that probably explains it

[12:19:27.0631] <TabAtkins>
bakkot: Ah, the fact that all the "Members Only" messages specify what history they have available made me assume that the "Public" option, with no such specification, would reveal past history. Changed now!

[12:41:13.0646] <bakkot>
TabAtkins: very understandable confusion. I'd submit a PR to their UI except I can't figure out where it's stored and their issue tracker has literally thousands of open issues

[12:41:20.0863] <bakkot>
anyway, logs are now available at https://matrixlogs.bakkot.com/Pipeline_Champions/

[13:11:52.0262] <TabAtkins>
Does the ${} thing in templates have a name for itself?

[13:29:15.0565] <rkirsling>
if I had to name it off the cuff, I might say "interpolator"

[13:33:53.0864] <TabAtkins>
yeah i'm going with "pattern-interpolation operator" for now (for talking about its use in pattern-matching)


2021-12-08
[16:58:37.0445] <jschoi>
Should it be called an operator? It’s not like it evaluates into an expression by itself—it’s kind of more like spread syntax, right?
“Interpolation syntax”, maybe…

[16:59:36.0630] <jschoi>
I’m just thinking about that sentence on the MDN chart of operators that says, “The spread operator is not in this list because it is not an operator,” and wondering if inconsistently saying “interpolation operator” might confuse learners.

[17:00:57.0593] <jschoi>
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table

[17:01:27.0806] <jschoi>
Interpolation whatever-we-call-it wouldn’t belong on this operator chart, either.

[17:02:49.0434] <jschoi>
(I do like and appreciate the word “interpolation” much more than “pin”, for what it’s worth.)

[17:03:17.0996] <joepie91 🏳️‍🌈>
"the spread operator is not an operator" seems like a dubious statement

[17:03:46.0591] <joepie91 🏳️‍🌈>
like, it may be true according to some strict technical definition, but I'm not sure it's true by anyone's *pragmatic* definition

[17:04:10.0977] <ljharb>
spread is definitely not an operator, because it doesn’t work anywhere in expression position 

[17:04:42.0489] <ljharb>
similarly yes, I’d call the ${} “placeholder syntax” (cc TabAtkins)

[17:05:17.0968] <ljharb>
or “interpolation placeholder syntax”, i suppose, to disambiguate from pipeline

[17:05:21.0139] <jschoi>
(I like “interpolation syntax” more than “placeholder syntax”, for what it’s worth. “Placeholder syntax” makes me think of the pipe operator and PFA syntax, haha.)

[17:05:24.0401] <jschoi>
Yes.

[17:08:10.0962] <ljharb>
i also prefer the name “interpoliterals” over template literals too, as long as we’re naming things :-p

[17:12:05.0357] <TabAtkins>
I don't think operators have to be usable in any context to be reasonably called that? My definition is relatively broad.

[17:12:34.0594] <TabAtkins>
Spread is def an operator, to me. ${} is as much as operator as () is

[17:12:39.0450] <joepie91 🏳️‍🌈>
yeah, that's pretty much what I was alluding to with "pragmatic definition"

[17:13:07.0857] <joepie91 🏳️‍🌈>
as far as people's mental models are concerned, how they reason about how the language works, it certainly seems to be an operator

[17:13:09.0528] <TabAtkins>
Yeah I agree with you

[17:13:26.0387] <joepie91 🏳️‍🌈>
even if it may not meet certain strict technical definitions of one, and may not be one implementation-wise

[17:16:45.0984] <bakkot>
that definitely does not match my mental model of how languages work

[17:16:51.0887] <bakkot>
operators are things which turn values into other values

[17:17:01.0026] <bakkot>
neither spread nor `${}` is an operator in that sense

[17:19:09.0421] <jschoi>
> <@tabatkins:matrix.org> I don't think operators have to be usable in any context to be reasonably called that? My definition is relatively broad.

We don’t have to be prescriptive on how people in general use the word, but since this is the official language explainer and “syntax” in this case is more precise than “operator”, then we might as well use the more precise word.

[17:20:56.0386] <jschoi>
* > <@tabatkins:matrix.org> I don't think operators have to be usable in any context to be reasonably called that? My definition is relatively broad.

We don’t have to be prescriptive on how people in general use the word, but since this is the official language explainer, and “syntax” in this case is more technically correct than “operator”, then we might as well use the more more technically correct term, while letting people in general call an operator if they want to.

[17:22:26.0404] <jschoi>
* > <@tabatkins:matrix.org> I don't think operators have to be usable in any context to be reasonably called that? My definition is relatively broad.

We don’t have to be prescriptive on how people in general use the word. But since this is the official language explainer, and “syntax” in this case is more technically correct than “operator”, then we might as well use the more more technically correct term, while letting people in general still call it an operator if they want to.

[17:23:26.0224] <jschoi>
* > <@tabatkins:matrix.org> I don't think operators have to be usable in any context to be reasonably called that? My definition is relatively broad.

We don’t have to be prescriptive on how people in general use the word. But since we’re talking about the official language explainer, and “syntax” in this case is more technically correct than “operator”, then we might as well use the more more technically correct term on the explainer, while letting people in general still call it an operator if they want to.

[17:28:54.0594] <joepie91 🏳️‍🌈>
strictly following technical correctness rather than leaving room for simplifications frequently results in worse explainers, though, from a didactic point of view

[17:29:11.0700] <joepie91 🏳️‍🌈>
technical accuracy certainly is an important factor to weigh, but not the *only* one

[17:29:54.0684] <joepie91 🏳️‍🌈>
(a lot of the complaints about MDN being 'difficult to understand' seem to relate to this)

[18:07:53.0666] <jschoi>
> <@joepie91:pixie.town> strictly following technical correctness rather than leaving room for simplifications frequently results in worse explainers, though, from a didactic point of view

That’s fair. At least in this case “syntax” is just about as clear as “operator” anyway.

[18:09:08.0240] <jschoi>
For what it’s worth, I do personally find value in distinguishing “things that combine expressions into expressions” (operators) from other syntaxes, and I suspect that this distinction may have teaching value too, but that’s my own intuition, and I am only one being of many, haha.

[18:09:22.0638] <jschoi>
* For what it’s worth, I do personally find value in distinguishing “things that combine expressions into expressions” (operators) from other syntaxes, and I suspect that this distinction may have teaching value too, but that’s my own intuition, and I am only one being of many, haha.

[18:09:27.0847] <jschoi>
* > <@joepie91:pixie.town> strictly following technical correctness rather than leaving room for simplifications frequently results in worse explainers, though, from a didactic point of view

That’s fair. At least in this case “syntax” is just about as clear as “operator” anyway.

[18:10:29.0093] <jschoi>
* For what it’s worth, I do personally find value in distinguishing “things that combine expressions into expressions” (operators) from “things that don’t result in an expression” (not operators)—and I suspect that this distinction may have teaching value to learners too—but that’s my own intuition, and I am only one being of many, haha.

[18:10:49.0443] <jschoi>
* > <@joepie91:pixie.town> strictly following technical correctness rather than leaving room for simplifications frequently results in worse explainers, though, from a didactic point of view

That’s fair. At least in this case “syntax” is just about as clear as “operator” anyway. They’re both pretty basic programming words.

[18:11:12.0518] <jschoi>
* For what it’s worth, I do personally find value in distinguishing “things that combine expressions into expressions” (operators) from “things that don’t result in expressions” (not operators)—and I suspect that this distinction may have teaching value to learners too—but that’s my own intuition, and I am only one being of many, haha.

[02:32:28.0356] <joepie91 🏳️‍🌈>
I do agree that it's valuable to teach that distinction actually (I also tend to put a lot of focus on expression vs. statement in what I teach, for example), I'm just not sure that an operator reference is the right place :D

[14:07:59.0773] <TabAtkins>
Question ended up being moot, fwiw; I went with "interpolation pattern" instead.


2021-12-09
[09:44:05.0225] <devsnek>
is there anyone security-minded from the v8 team i can dm real quick? shu maybe?

[10:04:54.0607] <shu>
i don't know if i'm security minded

[10:05:00.0066] <shu>
but sure, feel free to DM


2021-12-10
[14:54:27.0164] <jugglinmike>
shu: Did you see https://github.com/tc39/proposal-resizablearraybuffer/pull/72#issuecomment-967323881 ?

[15:04:34.0171] <shu>
yes, i am just terribly behind

[15:05:27.0751] <jugglinmike>
Then say no more :)


2021-12-12
[09:13:05.0616] <Andreu Botella (he/they)>
Hey. I was trying to understand the ShadowRealm proposal, and I noticed that the requirements for `HostResolveImportedModules` don't say anything about realms

[09:13:36.0119] <Andreu Botella (he/they)>
and IIUC the security properties of ShadowRealms need the realm to not share a module map with any other realms

[09:13:57.0865] <Andreu Botella (he/they)>
 * and IIUC the security properties of ShadowRealms need the realm to not share a module map with any other realms

[09:27:11.0442] <Andreu Botella (he/they)>
Also, the HTML spec's implementation of `HostResolveImportedModules` doesn't follow the requirements, since it always uses the current realm's module map, and if `referencingScriptOrModule` is `null`, that might result in different calls to that operation returning different module records

[09:27:30.0027] <Andreu Botella (he/they)>
I'd argue that's a bug with the TC39 spec

[12:20:58.0632] <Mathieu Hofman>
> <@andreubotella:mozilla.org> and IIUC the security properties of ShadowRealms need the realm to not share a module map with any other realms

That is not my understanding. What made you think this? My recollection is that the shadow realms would share a module map, but would be keyed by realm. Cc leobalter 

[12:24:27.0686] <Mathieu Hofman>
I believe this is the issue where it was discussed: https://github.com/tc39/proposal-shadowrealm/issues/261

[12:24:38.0722] <Mathieu Hofman>
I think there is a related whatwg issue

[12:27:14.0932] <Mathieu Hofman>
I believe this comment on the integration PR: https://github.com/whatwg/html/pull/5339#issuecomment-874588585

[12:28:18.0639] <Andreu Botella (he/they)>
Thanks for those links, I hadn't been following the conversations and was trying to figure out how things worked purely from the spec proposal and how it interacts with the HTML spec as it is currently

[12:28:57.0271] <Andreu Botella (he/they)>
But my understanding was that, if a module is first instantiated in the parent realm, and then imported from a ShadowRealm, you could access the parent realm's intrinsic objects that way

[12:29:04.0890] <Andreu Botella (he/they)>
I don't think there's anything to stop that currently

[12:36:34.0840] <Mathieu Hofman>
Ah no, you don't get the same module instance. It's keyed on the realm. But the resolution is shared per document

[12:37:25.0173] <Andreu Botella (he/they)>
oh, so the actual fetch for a module script only happens once per document, but you have different module records per realm?

[12:37:33.0145] <Mathieu Hofman>
So you can observe with timing if the parent has the module in it's map, but you never directly share any objects

[12:40:34.0704] <Andreu Botella (he/they)>
But in that case, `HostResolveImportedModules` would still need to say something about realms

[14:06:26.0017] <Andreu Botella (he/they)>
I filed https://github.com/tc39/proposal-shadowrealm/issues/342


2021-12-13
[09:24:34.0777] <leobalter>
Andreu Botella (he/they), Mathieu Hofman the understanding for the ES proposal and the HTML integration was to have the ShadowRealms reusing part of the modules resolution in the sense the loading and static parsing is done once for all Realms and runtime evaluation is done individually for each Realm (including ShadowRealms) when they "request" it. 

So calling the Module Map the same or different depends if you - like me - use a web dev practicioner point of view. It's the same map for the io and static parsing (syntax errors might be caught earlier), but runtime evaluation is where the map splits per each ShadowRealm.

[11:42:21.0255] <Andreu Botella (he/they)>
leobalter: When I posted that, I wasn't very clear on the details of how the HTML integration had to happen, so thanks for the clarification. But the issue I filed doesn't mention module maps, which are an HTML spec concept – it mentions module records, which are tied to a realm.

[11:43:50.0371] <Andreu Botella (he/they)>
The issue is about how the hook requirements are not only insufficient for the security properties, but conflict with them. Though I haven't checked out the HTML integration PR yet, my understanding is that it gets around that by violating the requirements.

[13:05:50.0551] <leobalter>
Would you mind forwarding this to the github issue? I’m on pto and the github thread might help with an async discussion. Thanks!

[13:45:09.0232] <Andreu Botella (he/they)>
> <@leobalter:matrix.org> Would you mind forwarding this to the github issue? I’m on pto and the github thread might help with an async discussion. Thanks!

I think the comments I've made on the github issue since then should be enough


2021-12-14
[11:16:12.0678] <jschoi>
A chair or administrator should change the log links in all of the channels to the appropriate pages in https://matrixlogs.bakkot.com/.


2021-12-15
[23:43:15.0826] <ryzokuken>
jschoi: done, though I'm neither a chair nor an admin. Now that we've finalized Matrix, should be scrub all the permissions? Let me check if I can step down myself.

[23:44:12.0923] <ryzokuken>
bakkot: is this channel not logged on purpose?

[23:51:22.0285] <bakkot>
ryzokuken: ? https://matrixlogs.bakkot.com/TC39_General/2021-12-15

[23:51:36.0405] <bakkot>
it only refreshes every five minutes or so

[23:52:22.0398] <ryzokuken>
oh no wrong channel sorry

[23:52:28.0532] <ryzokuken>
bakkot: I meant #temporaldeadzone:matrix.org 

[23:54:47.0788] <bakkot>
yeah, that's intentional

[09:42:23.0028] <ljharb>
ryzokuken: maybe delete that mention of it here, so it's less discoverable?

[09:42:53.0185] <ryzokuken>
removed, but it must've been logged

[09:43:22.0487] <ljharb>
yes, but we can kick the bot from TDZ and avoid mentioning it in public channels in the future :-)

[09:44:21.0514] <ryzokuken>
sure! I hope one day we spin up a TC39 homeserver and ban the bot from the entire server 😀 

[14:48:54.0756] <sideshowbarker>
comments or a PR on https://github.com/mdn/content/issues/11237 would be welcome


2021-12-16
[19:17:54.0110] <jschoi>
Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting `A`’s properties, when there are too many items, and when `mapfn` throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?

[19:18:01.0409] <jschoi>
 * Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting its result’s properties, if there are too many items, or if `mapfn` throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?

[19:18:56.0521] <jschoi>
 * Is there a particular reason why Array.from (https://tc39.es/ecma262/#sec-cma262/#sec-call) seems to call CloseIterator if an error occurs when setting `A`’s properties, when there are too many items, and when `mapfn` throws an error—but not when IteratorStep results in an abrupt completion nor when the iterator depletes its items?

[20:12:42.0311] <bakkot>
we don't close the iterator when an error occurs in the iterator itself, because the iterator is broken

[20:12:52.0044] <bakkot>
and we don't close iterators when they are depleted in general

[20:13:14.0185] <bakkot>
(the assumption is that it does its own cleanup before returning `{done: true}`)

[20:13:50.0399] <bakkot>
we only cause IteratorClose when we need to close an iterator because we can no longer consume it for reasons of our own

[20:17:00.0109] <bakkot>
 * we only call IteratorClose when we need to close an iterator because we can no longer consume it for reasons of our own

[21:19:50.0394] <jschoi>
I see https://github.com/tc39/rationale/issues/2; thank you.

[21:22:17.0328] <jschoi>
 * I see. I also see you’ve posted https://github.com/tc39/rationale/issues/2; thank you.

[21:22:25.0543] <jschoi>
 * I see. I also see you’ve posted https://github.com/tc39/rationale/issues/2. Thank you for both that and the explanation.

[22:13:37.0117] <jschoi>
https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541
As far as I can tell, there is no way to capture all possible rejections from a sync iterable’s yielded promises, while still maintaining `for await` semantics. This is correct, right?

[22:14:12.0873] <jschoi>
 * https://github.com/tc39/proposal-array-from-async/issues/16#issuecomment-995453541
As far as I can tell, there is no way to capture all possible rejections from a sync iterable’s yielded promises, while still maintaining `for await` semantics. This is correct, right?

[09:54:07.0102] <Mathieu Hofman>
What does `for await (const foo of iterableYieldingPromises)` do in this case?

[09:55:54.0479] <Mathieu Hofman>
If I was to implement this in a polyfill, I'd setup a dummy `.catch()` on the next promise to avoid the unhandled error, but still yield the original promise later

[09:56:47.0847] <Mathieu Hofman>
It's a pretty common occurrence when parallelizing async operations

