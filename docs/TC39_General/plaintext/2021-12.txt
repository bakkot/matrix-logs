2021-12-04
[17:44:17.0686] <jschoi>
sarahghp: I’m taking a look at your slides for the Decimal update. I’m a little confused by the “Standard Library” slide, as well as the subsequent “Downsides of Object-Based Operator Overloading” slide’s mentioning of Math.max. Could you clarify whether your current plan still to latch onto BigInt Math’s polymorphic Math extensions, or is it to add new methods to the Decimal global object? And what does Math.max have to do with operator overloading?

[17:44:35.0751] <jschoi>
https://drive.google.com/file/d/1qdieei11dZgDY_KnJhSBcFyHTMZOmCJr/view

[17:45:22.0509] <jschoi>
https://github.com/tc39/proposal-bigint-math/issues/14#issuecomment-952024624

[17:45:48.0431] <jschoi>
(I’m not planning to present an update on BigInt Math in the next plenary, until its chartered incubator meeting occurs.)


2021-12-05
[01:22:59.0290] <pokute>
I've been dogfooding my TypeScript support for pipeline operator at https://github.com/Pokute/AoC2021/blob/main/4.ts . It's starting to feel crucial for me. Lacking tacit function application (`|>>`) would be an inconvenience, but the other way around, I would have so many IIAFEs.

[12:28:14.0006] <bakkot>
A proposal: https://gist.github.com/bakkot/3d0f81233fc00b508ae5f247b1458823

tl;dr: adding syntax for defining a function which can be either sync or async, depending on how it's called:

```
async? function f(possiblyAsyncCallback) {
  let x = await? possiblyAsyncCallback();
  return something(x);
}

console.log(f.sync(syncCallback)) // a regular value

console.log(f.async(asyncCallback)) // a Promise
```


[12:28:39.0205] <bakkot>
looking for any feedback on whether this seems at all reasonable before I put together something to present to committee

[12:46:40.0787] <Justin Ridgewell>
> <@bakkot:matrix.org> A proposal: https://gist.github.com/bakkot/3d0f81233fc00b508ae5f247b1458823
> 
> tl;dr: adding syntax for defining a function which can be either sync or async, depending on how it's called:
> 
> ```
> async? function f(possiblyAsyncCallback) {
>   let x = await? possiblyAsyncCallback();
>   return something(x);
> }
> 
> console.log(f.sync(syncCallback)) // a regular value
> 
> console.log(f.async(asyncCallback)) // a Promise
> ```
> 

Have you seen [gensync](https://github.com/loganfsmyth/gensync) before?

[12:48:48.0223] <bakkot>
I had not!

[12:49:23.0938] <bakkot>
but that is basically exactly the same thing, neat

[12:55:25.0120] <loganfsmyth>
Let me know if you have suggestions for improvements, I think babel is the only thing really using it right now.

[13:08:22.0683] <bakkot>
main thing which looks to be missing to me is a way for the function to switch on whether it was called as sync or async

[13:08:36.0799] <bakkot>
so that it can e.g. call the appropriate sync or async version of some other API

[13:09:11.0512] <bakkot>
(my gist has a `function.async` meta-property for this; it would be a bit harder to do in a library)

[13:14:43.0048] <loganfsmyth>
Got it, should be pretty easy for you to make a helper to do that since you can make a function where the async version returns true and the sync version returns false and then do `if (yield* isAsync()) {`

[14:28:43.0592] <nicolo-ribaudo>
> <@loganfsmyth:mozilla.org> Got it, should be pretty easy for you to make a helper to do that since you can make a function where the async version returns true and the sync version returns false and then do `if (yield* isAsync()) {`

Yup, Babel already has it: https://github.com/babel/babel/blob/2a3b0b96012b86c558aec344dad34a60c51a71c9/packages/babel-core/src/gensync-utils/async.ts#L23

