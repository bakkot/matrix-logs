2021-12-04
[17:44:17.0686] <jschoi>
sarahghp: I’m taking a look at your slides for the Decimal update. I’m a little confused by the “Standard Library” slide, as well as the subsequent “Downsides of Object-Based Operator Overloading” slide’s mentioning of Math.max. Could you clarify whether your current plan still to latch onto BigInt Math’s polymorphic Math extensions, or is it to add new methods to the Decimal global object? And what does Math.max have to do with operator overloading?

[17:44:35.0751] <jschoi>
https://drive.google.com/file/d/1qdieei11dZgDY_KnJhSBcFyHTMZOmCJr/view

[17:45:22.0509] <jschoi>
https://github.com/tc39/proposal-bigint-math/issues/14#issuecomment-952024624

[17:45:48.0431] <jschoi>
(I’m not planning to present an update on BigInt Math in the next plenary, until its chartered incubator meeting occurs.)


2021-12-05
[01:22:59.0290] <pokute>
I've been dogfooding my TypeScript support for pipeline operator at https://github.com/Pokute/AoC2021/blob/main/4.ts . It's starting to feel crucial for me. Lacking tacit function application (`|>>`) would be an inconvenience, but the other way around, I would have so many IIAFEs.

[12:28:14.0006] <bakkot>
A proposal: https://gist.github.com/bakkot/3d0f81233fc00b508ae5f247b1458823

tl;dr: adding syntax for defining a function which can be either sync or async, depending on how it's called:

```
async? function f(possiblyAsyncCallback) {
  let x = await? possiblyAsyncCallback();
  return something(x);
}

console.log(f.sync(syncCallback)) // a regular value

console.log(f.async(asyncCallback)) // a Promise
```


[12:28:39.0205] <bakkot>
looking for any feedback on whether this seems at all reasonable before I put together something to present to committee

[12:46:40.0787] <Justin Ridgewell>
> <@bakkot:matrix.org> A proposal: https://gist.github.com/bakkot/3d0f81233fc00b508ae5f247b1458823
> 
> tl;dr: adding syntax for defining a function which can be either sync or async, depending on how it's called:
> 
> ```
> async? function f(possiblyAsyncCallback) {
>   let x = await? possiblyAsyncCallback();
>   return something(x);
> }
> 
> console.log(f.sync(syncCallback)) // a regular value
> 
> console.log(f.async(asyncCallback)) // a Promise
> ```
> 

Have you seen [gensync](https://github.com/loganfsmyth/gensync) before?

[12:48:48.0223] <bakkot>
I had not!

[12:49:23.0938] <bakkot>
but that is basically exactly the same thing, neat

[12:55:25.0120] <loganfsmyth>
Let me know if you have suggestions for improvements, I think babel is the only thing really using it right now.

[13:08:22.0683] <bakkot>
main thing which looks to be missing to me is a way for the function to switch on whether it was called as sync or async

[13:08:36.0799] <bakkot>
so that it can e.g. call the appropriate sync or async version of some other API

[13:09:11.0512] <bakkot>
(my gist has a `function.async` meta-property for this; it would be a bit harder to do in a library)

[13:14:43.0048] <loganfsmyth>
Got it, should be pretty easy for you to make a helper to do that since you can make a function where the async version returns true and the sync version returns false and then do `if (yield* isAsync()) {`

[14:28:43.0592] <nicolo-ribaudo>
> <@loganfsmyth:mozilla.org> Got it, should be pretty easy for you to make a helper to do that since you can make a function where the async version returns true and the sync version returns false and then do `if (yield* isAsync()) {`

Yup, Babel already has it: https://github.com/babel/babel/blob/2a3b0b96012b86c558aec344dad34a60c51a71c9/packages/babel-core/src/gensync-utils/async.ts#L23

[14:31:24.0391] <loganfsmyth>
Hah I though it did but I was on mobile and couldn't be bothered to look

[14:32:17.0760] <loganfsmyth>
Certainly something we could move into gensync too

[14:34:24.0124] <nicolo-ribaudo>
Btw, something that would greatly benefit from moving this to the language (rather than as a library) are stack traces and step-by-step debugging; gensync makes it really hard (this is not a critique, just a limitation I don't think can be solved in a library).

[14:53:16.0547] <bakkot>
I think the main annoying thing with the library version is that you can't call regular async functions without wrapping them first (unless I'm missing something)

[14:53:40.0391] <bakkot>
not a huge hinderance but would be nicer not to need to worry about it

[14:54:10.0610] <bakkot>
anyway, this is really cool; I will play with it some

[14:55:35.0817] <nicolo-ribaudo>
Well, it's `await? (function.async ? asyncFn() : syncFn())` vs `yield* gensync({ sync: syncFn, async: asyngFn })()` (you need the check in both versions)

[14:55:49.0361] <nicolo-ribaudo>
> <@bakkot:matrix.org> I think the main annoying thing with the library version is that you can't call regular async functions without wrapping them first (unless I'm missing something)

 * Well, it's `await? (function.async ? asyncFn() : syncFn())` vs `yield* gensync({ sync: syncFn, async: asyngFn })()` (you need the check in both versions)

[14:55:54.0503] <nicolo-ribaudo>
But yes, you always need to wrap

[14:56:52.0183] <bakkot>
with the syntax you need to wrap if you're calling a function you figured out yourself, but not if you're calling a function the user provided

[14:57:27.0592] <bakkot>
i.e. you can just do `await? callback()` and if the user called you as `f.async` and passed an async callback, or if the user called you as `f.sync` and passed a sync callback, it will work the same

[14:57:37.0815] <bakkot>
and `callback` doesn't need to be wrapped

[14:58:31.0397] <nicolo-ribaudo>
Oh ok yes, we had to introduce a `maybeAsync` gensync helper in Babel for that

[14:58:45.0884] <nicolo-ribaudo>
(which also throws if `callback()` returns a promise when called in a sync context)

[14:58:51.0361] <nicolo-ribaudo>
 * (which also throws if `callback()` returns a promise when called in a sync context)

[14:59:31.0422] <bakkot>
yeah there's definitely some possibility of shooting yourself in the foot here, if you mess up what's async and what's sync

[15:00:08.0568] <bakkot>
this would be fun for typescript to figure out :P

