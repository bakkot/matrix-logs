2023-01-02
[18:26:55.0326] <Mathieu Hofman>
> <@ljharb:matrix.org> Promise has the brand checks but no non-side-effect way to check it; and error sadly has no way to do the brand check, yes. Yet.

We did discuss this on matrix a [few months ago](https://matrixlogs.bakkot.com/TC39_General/2022-05-11#L9). The inability to brand check a promise without side effects (in particular triggering proxy traps) is a major pain for us, and I would very much would like to find a way to make this possible. But a lot of people expressed concerns with revealing such a power, mostly about users doing conditional work based on the result type (promise or not, aka releasing Zalgo)

[18:34:42.0565] <Kris Kowal>
Yes, and my recommendation is that our stance should be to enable and help people to avoid releasing Zalgo, not prevent people from releasing Zalgo. The latter is not possible. The former is possible while still revealing a brand check. It‚Äôs not the same magnitude of hazard as, say, an API to synchronously query the state of a promise.

[20:31:57.0810] <bakkot>
Since we're talking about this stuff, reminder that https://github.com/tc39/proposal-faster-promise-adoption exists

[08:13:44.0011] <voide>
Hello everyone. I've been trying to understand https://tc39.es/ecma262/#sec-functiondeclarationinstantiation.

Say I have the function:

```JavaScript
function f() {
      const x = 2;
      let y = 3;
      var z = 4;
  }
```

Is a single Lexical Environment created for x,y,z or is z stored on the first LE and x,y on another one with Outer Environment set to the first LE...or something else I didn't think of?

[08:14:19.0416] <voide>
 * Hello everyone. I've been trying to understand https://tc39.es/ecma262/#sec-functiondeclarationinstantiation.

Say I have the function:

```JavaScript
function f() {
      const x = 2;
      let y = 3;
      var z = 4;
  }
```

Is a single Lexical Environment created for x,y,z or is z stored on the first LE and x,y on another one with Outer Environment set to the first LE...or something else I didn't think of?

[08:19:34.0557] <voide>
 * Hello everyone. I've been trying to understand https://tc39.es/ecma262/#sec-functiondeclarationinstantiation.

Say I have the function:

```JavaScript
function f() {
      const x = 2;
      let y = 3;
      var z = 4;
  }
```

Is a single Lexical Environment created for x,y,z or is z stored on the first LE and x,y on another one with Outer Environment set to the first LE...or something else I didn't think of?

I'm excluding the VE because there's only 1 reference (20d) and it looks only related to either a strict function or a function with Parameter Expressions.

[08:20:08.0106] <voide>
 * Hello everyone. I've been trying to understand https://tc39.es/ecma262/#sec-functiondeclarationinstantiation.

Say I have the function:

```JavaScript
function f() {
      const x = 2;
      let y = 3;
      var z = 4;
  }
```

Is a single Lexical Environment created for x,y,z or is z stored on the first LE and x,y on another one with Outer Environment set to the first LE...or something else I didn't think of?

I'm excluding the VE because there's only 1 reference (20d) and it looks only related to either a strict function or a function with Parameter Expressions, but this function has no parameters at all.

[08:31:00.0977] <voide>
 * Hello everyone. I've been trying to understand [https://tc39.es/ecma262/#sec-functiondeclarationinstantiation]().

Say I have the function:

```JavaScript
function f() {
      const x = 2;
      let y = 3;
      var z = 4;
  }
```

Is a single Lexical Environment created for x,y,z or is z stored on the first LE and x,y on another one with Outer Environment set to the first LE...or something else I didn't think of?

I'm excluding the VE because there's only 1 reference (20d) and it looks only related to either a strict function or a function with Parameter Expressions, but this function has no parameters at all.

This is closely related to [a StackOverflow question](https://stackoverflow.com/questions/70279115/does-lexicalenvironment-s-outerenv-refer-to-the-variableenvironmentof-same) which unfortunately didn't get the answer needed.

[08:34:34.0704] <voide>
 * Hello everyone. I've been trying to understand [https://tc39.es/ecma262/#sec-functiondeclarationinstantiation](https://app.element.io/).

Say I have the function:

```JavaScript
function f() {
      const x = 2;
      let y = 3;
      var z = 4;
  }
```

Is a single Lexical Environment created for x,y,z or is z stored on the first LE and x,y on another one with Outer Environment set to the first LE...or something else I didn't think of?

I'm excluding the VE because there's only 1 reference (20d) and it looks only related to either a strict function or a function with Parameter Expressions, but this function has no parameters at all.

This is closely related to [a StackOverflow question](https://stackoverflow.com/questions/70279115/does-lexicalenvironment-s-outerenv-refer-to-the-variableenvironmentof-same) ([this comment](https://stackoverflow.com/questions/70279115/does-lexicalenvironment-s-outerenv-refer-to-the-variableenvironmentof-same#comment124269800_70297307) in particular) which unfortunately didn't get the answer needed.

[08:54:34.0937] <voide>
 * Hello everyone. I've been trying to understand [https://tc39.es/ecma262/#sec-functiondeclarationinstantiation](https://app.element.io/) as applied to functions without parameters.

Say I have the function:

```JavaScript
function f() {
      const x = 2;
      let y = 3;
      var z = 4;
  }
```

Is a single Lexical Environment created for x,y,z or is z stored on the first LE and x,y on another one with Outer Environment set to the first LE...or something else I didn't think of?

I'm excluding the VE because there's only 1 reference (20d) and it looks only related to either a strict function or a function with Parameter Expressions, but this function has no parameters at all.

This is closely related to [a StackOverflow question](https://stackoverflow.com/questions/70279115/does-lexicalenvironment-s-outerenv-refer-to-the-variableenvironmentof-same) ([this comment](https://stackoverflow.com/questions/70279115/does-lexicalenvironment-s-outerenv-refer-to-the-variableenvironmentof-same#comment124269800_70297307) in particular) which unfortunately didn't get the answer needed.

[09:10:32.0616] <bakkot>
voide: it depends on whether the function is in a strict context or not. in a non-strict context, "z stored on the first LE and x,y on another one with Outer Environment set to the first LE" is accurate - see step 30/31. 

[10:57:28.0733] <voide>
Thanks for confirming. Does this mean that:

> Set the LexicalEnvironment of calleeContext \[...\] (step 32)

refers to a new LE, _not_ the first one? I feel like this is the missing puzzle piece for me.

[10:58:00.0224] <voide>
 * Thanks for confirming. Does this mean that:

> Set the LexicalEnvironment of calleeContext \[...\] (step 32)

refers to a new LE, _not_ the first one? I feel like this is the missing puzzle piece for me.

[11:01:08.0497] <voide>
I suppose it's the _the_ article that throws me off.

[11:01:31.0109] <voide>
 * I suppose it's the _the_ article that throws me off.

[11:01:41.0616] <jmdyck>
Not sure if this'll help but: in spec terms, there isn't a thing that *is* a Lexical Environment. Rather, `LexicalEnvironment` is simply the name of a component of an execution context.

[11:02:47.0975] <jmdyck>
So the `Set` step is setting a component of `calleeContext`. It's like `calleeContext` is a Record, and `LexicalEnvironment` is simply the name of one of its fields.

[11:04:59.0243] <voide>
Yes, this is something I understand now and I know we're talking about abstractions. Thing is, by the time that step is being executed there's already a Lexical Environment with a **var** declaration and that part confuses me a little.

[11:05:00.0128] <jmdyck>
The value of that component/field is an Environment Record.

[11:06:19.0739] <voide>
This:

> So the Set step is setting a component of calleeContext

Is language that is clear to me because you said it's _a_ component instead of _the_ component.

[11:06:25.0552] <voide>
 * This:

> So the Set step is setting a component of calleeContext

Is language that is clear to me because you said it's _a_ component instead of _the_ component.

[11:07:28.0209] <jmdyck>
If I had a record `_foo_` with a field `[[Bar]]`, I could say `Set the [[Bar]] field of _foo_ to 0.`

[11:08:33.0109] <jmdyck>
It wouldn't be correct to say `Set a [[Bar]] field of _foo_ to 0.`

[11:11:13.0461] <bakkot>
voide: you might find it useful to look at https://github.com/engine262/engine262/blob/3248ccc6793a4de3ca6cab1d3a16a113ddc8d0c9/src/runtime-semantics/FunctionDeclarationInstantiation.mjs#L237, which is a JS implementation of this algorithm

[11:12:14.0579] <voide>
> <@jmdyck:matrix.org> If I had a record `_foo_` with a field `[[Bar]]`, I could say `Set the [[Bar]] field of _foo_ to 0.`

Yes, I understand what you say.

[11:12:32.0715] <voide>
> <@bakkot:matrix.org> voide: you might find it useful to look at https://github.com/engine262/engine262/blob/3248ccc6793a4de3ca6cab1d3a16a113ddc8d0c9/src/runtime-semantics/FunctionDeclarationInstantiation.mjs#L237, which is a JS implementation of this algorithm

This is appreciated, I will take a look at it.


2023-01-03
[23:53:40.0771] <annevk>
yulia | sick: littledan: I could make the Module Loading call tonight if that's helpful, please lmk

[06:48:24.0470] <littledan>
A lot of people seem to be out today; I think we should try to convene in two weeks for the module call

[08:02:33.0426] <Mathieu Hofman>
> <@bakkot:matrix.org> Since we're talking about this stuff, reminder that https://github.com/tc39/proposal-faster-promise-adoption exists

Yes I need to get back to that proposal. I have on my list of tasks to rewrite a user land promise implementation that side-steps some other issues we've found with promises (e.g. memory leaks), and has the ability to get insight into the adoption of unresolved promises. I'm hoping that could help me find ways to rewrite the promise steps in a way that is both mostly compatible with existing behavior, but also enshrines some beneficial behavior that is currently left out by most implementations, such as detection of cycles longer than 2 promises, or these extra ticks incurred by adoption.

[13:10:17.0300] <Justin Ridgewell>
I think we could pretty easily expose the is-not-a-proxy-and-doesn't-have-an-own-`.then` with that proposal (but we'd be getting further away from  faster promise adoption core)

[13:10:36.0800] <Justin Ridgewell>
At least, we could refactor the check in a way that it can be exposed later.


2023-01-09
[10:12:46.0639] <yulia>
does anyone have a proposal that they want HCI research done on?

[11:42:56.0111] <ptomato>
heads up that test262's [async helpers RFC](https://github.com/tc39/test262/pull/3724) has moved to final comment period until 2023-01-19. this is the first RFC according to our new RFC process so additionally if you have comments on the process they are welcome on the [draft process document](https://github.com/tc39/test262/pull/3525)


2023-01-11
[18:47:19.0201] <Jack Works>
I wonder about the use rate of new css features like new units, new color functions

[18:49:18.0983] <Jack Works>
Because css cannot be polyfilled

[21:14:19.0973] <sea-grass>
I would guess that the use rate of new css features would go up as autoprefixer/other css preprocessors add support for them, which is basically polyfilling

[22:56:40.0518] <Jack Works>
Many features cannot be polyfilled because they don't have an old equivalent version, for example different color functions do not represent the same color  space. Units are the same

[05:19:18.0939] <ryzokuken>
https://preset-env.cssdb.org/ atleast claims to get the job done


2023-01-12
[08:53:37.0858] <shu>
practitioners: do you expect/want `Error.prototype.stack` strings to chain together stacks from `.cause`? or do you only expect that chaining to happen in more "sophisticated" printing places like the DevTools console and console.log?

[08:54:17.0680] <shu>
i feel like it's weird to have the `.stack` string automatically chase `.cause` chains because then you have to parse the string to figure out which is a particular error object's stack

[08:55:26.0073] <Jack Works>
ü§î That's an interesting problem. I believe both have their use cases. Is it possible to make this feature configurable in the devtools? 

[08:55:58.0113] <shu>
i guess that's possible, but it doesn't feel right to have devtools configure the fundamental behavior of the `.stack` string

[08:56:50.0737] <shu>
for context: Firefox only chase `.cause` stacks in the more sophisticated printing places like console, afaict

[08:56:57.0344] <Kris Kowal>
I‚Äôd expect DevTools to help introspect both cause and aggregate error, and I expect neither to be reflected in the error.stack.

[08:57:08.0507] <shu>
that's my intuition, Kris Kowal 

[08:57:24.0807] <shu>
trying to decide what to do for chrome, that choice (which FF already made) seems like the right one

[08:57:25.0885] <Jack Works>
Yeah, firefox's behavior is good

[08:58:16.0116] <Jack Works>
Developers don't type err.stack (in the console), they type err

[08:58:27.0079] <Kris Kowal>
Meanwhile, inspecting a causal graph is close to what Miller Columns were invented for.

[08:58:32.0246] <shu>
i see

[08:58:38.0085] <Jack Works>
And that should track the causes so it shouldn't be reflected in the stack string

[08:58:45.0240] <shu>
programmatically it's pretty easy to just keep chasing `.cause` yourself anyway

[08:58:50.0771] <shu>
if you want to build up the stack string with all the cause chain

[09:00:21.0266] <Kris Kowal>
Domenic certainly will have opinions. He implemented Q‚Äôs ‚Äúlong traces‚Äù.

[09:23:46.0855] <snek>
> <@shuyuguo:matrix.org> practitioners: do you expect/want `Error.prototype.stack` strings to chain together stacks from `.cause`? or do you only expect that chaining to happen in more "sophisticated" printing places like the DevTools console and console.log?

i expect devtools to chase it

[09:24:15.0251] <snek>
each individual error's stack string should ideally remain as-is 

[10:18:04.0911] <ljharb>
I also agree that's the right behavior

[10:35:17.0563] <Justin Ridgewell>
Can we have a second getter called `fullStack`? üòÇ

[10:42:59.0206] <shu>
`.tellMeWhy`


2023-01-13
[18:01:09.0843] <rkirsling>
> <@shuyuguo:matrix.org> `.tellMeWhy`

returns `{ aintNothinButA: SyntaxError }`

[18:27:56.0782] <Rob Palmer>
ensures `assert.doesNotMatch(e.message, /ThatWay/)`

[18:31:54.0184] <Rob Palmer>
* ensures `assert.doesNotMatch(e.message, /ThatWay/)`

[01:29:44.0385] <annevk>
Has `collection.isEmpty()` ever been suggested?

[01:49:40.0119] <Ashley Claymore>
For `Array` too? To gloss over `length ` vs `size`?

[01:57:38.0511] <annevk>
Dunno, just curious if it came up in general for any kind of collection I suppose. There's some demand for it for `URLSearchParams`.

[10:28:47.0170] <ljharb>
`x.isEmpty()` vs `x.size === 0` doesn't seem hugely valuable

[10:29:50.0423] <littledan>
> <@annevk:matrix.org> Dunno, just curious if it came up in general for any kind of collection I suppose. There's some demand for it for `URLSearchParams`.

Do you have a reference on-hand to this demand?

[10:30:13.0167] <littledan>
(I guess I'm also a little surprised; I haven't seen this demand raised in a general JS context)


2023-01-14
[22:55:14.0940] <annevk>
littledan: https://github.com/whatwg/url/issues/163 (demand might be a strong word, it came up and seemed like a reasonable request)

[22:56:43.0096] <annevk>
But yeah, maybe as TabAtkins argued there we should just do `size`, part of the hesitancy has been JS not having a multimap

[15:13:56.0520] <snek>
i'm cool with an is empty

[15:14:34.0994] <snek>
all the various things in rust have is_empty and its nice


2023-01-15
[23:14:06.0443] <annevk>
Yeah, Infra "is empty" is relatively common in specs too

[06:45:34.0506] <littledan>
yeah, I'd be fine with something like that, but locally adding size seems right


2023-01-19
[04:35:15.0073] <Andreu Botella>
I'm looking into https://github.com/whatwg/streams/pull/1083, which allows creating a `ReadableStream` from a (sync or async) iterable

[04:35:20.0289] <Andreu Botella>
This PR wants to call `AsyncIteratorClose`, but that AO uses `Await()`

[04:35:34.0319] <Andreu Botella>
 * This PR wants to call `AsyncIteratorClose`, but that AO uses `Await()`

[04:36:45.0884] <Andreu Botella>
and given that `Await()` works by suspending and replacing execution contexts, it's not clear whether that is something a non-TC39 spec can use

[05:37:57.0335] <littledan>
I think there isn‚Äôt a binary switch that gets flipped between these layers, and that it‚Äôs OK to do some TC39-style at the boundaries as long as it doesn‚Äôt get too confusing. But this is really a question  for WHATWG folks.

[09:02:55.0102] <bakkot>
Andreu Botella: we will probably add proper support for built-in async functions soon, which will provide machinery for defining a promise-returning function where the body of the function can use `Await` without disruption - https://github.com/tc39/ecma262/pull/2942

[09:05:16.0712] <bakkot>
prior to that PR, you're right that things are not really set up for it. my suggestion in the mean time would be, you don't actually need to use `AsyncIteratorClose` directly; if you trace through all the machinery, all it's really doing is calling the `return` method and then calling `.then` on the result with a continuation for remainder of the current function, which you can probably figure out how to do manually


2023-01-20
[00:18:27.0418] <annevk>
littledan: I paged most of the scoping discussion we had out again, but I was wondering if https://github.com/whatwg/html/issues/8476 and https://github.com/fserb/canvas2D/blob/master/spec/layers.md are something it could help with. In particular giving you syntax for exiting the scope that would then result in `endLayer()` getting invoked. (As well as allow for nesting of scopes.)

[04:37:41.0496] <littledan>
Oh is this a potential place where the `using` declaration could help?

[04:41:09.0214] <Domenic>
Yeah I think so, although not sure about the nesting thing

[04:45:13.0192] <littledan>
Annevk: it would be great to have your thoughts in https://github.com/w3ctag/design-reviews/discussions/800 especially if it might feed back into any needed changes for the disposal API‚Äîit‚Äôd be ideal to work all that out before the whole set of proposals reaches Stage 3

[08:27:06.0831] <annevk>
I essentially put my earlier comment from here, there. Hope that's useful :-)

[09:43:57.0743] <Greg>
Hi, I asked  where I could post my objection to the pipe operator `|>`, and Chris de Almeida kindly pointed me here.

So here is my objection, copy/pasted from Github:

> JavaScript's syntax is already sufficiently complicated enough.
> 
> Have you people seen what happened to C -> C++? Is that your goal too?

[09:45:13.0009] <ljharb>
Greg: if it wasn't clear from my github comment, the tone of your objection is not in the spirit of our code of conduct

[09:45:47.0284] <ljharb>
is there something specific about the pipeline operator you think should be different? a generic "new things are complicated" isn't really productive

[09:46:34.0685] <Greg>
I think the pipe operator shouldn't exist, period. That is my objection. My reasoning is the disaster that is C++. Anyone familiar with C++ knows what I'm talking about, I think.

[09:47:20.0994] <Greg>
When a language adds more and more syntax, it makes the language more difficult to use

[09:47:32.0216] <ljharb>
that objection is basically useless, because lots of us think it should

[09:47:34.0051] <Greg>
This additional syntax represents a cognitive burden to the developer

[09:47:36.0272] <ljharb>
and i'm not sure how C++ is relevant

[09:47:43.0178] <ljharb>
yes, all additional features represent a cognitive burden

[09:47:46.0129] <ljharb>
should we all pack up and go home?

[09:47:56.0149] <ljharb>
that's not a useful argument

[09:48:02.0153] <Greg>
No, we should design good languages. I have a more longform blog post on this subject here: https://www.taoeffect.com/blog/2010/01/how-newlisp-took-my-breath-and-syntax-away/

[09:48:22.0513] <ljharb>
"good" is subjective, and "less syntax" is not an objectively good quality (nor is "more syntax" an objectively good one, ofc)

[09:48:23.0196] <Greg>
`|>` is unnecessary complexity

[09:48:29.0592] <ljharb>
unnecessary *for you*, perhaps

[09:48:33.0164] <ljharb>
clearly necessary for some

[09:48:37.0502] <Greg>
It's literally unnecessary

[09:48:52.0537] <Greg>
How is it necessary? The proposal shows how things can be written using the existing syntax in a shorter way

[09:48:54.0311] <ljharb>
it's necessary if you want to express a sequence of statements in a left-to-right order

[09:49:05.0440] <ljharb>
"shorter" isn't the important bit here - "left to right" is.

[09:49:23.0884] <ljharb>
clarity, not brevity, is what's important when writing code.

[09:49:41.0208] <Greg>
Then my proposal would be to change JavaScript so that this symbol can be used in a way that does not add new syntax

[09:49:42.0945] <ljharb>
sometimes those are the same, sometimes they're not

[09:49:58.0108] <ljharb>
it's not possible to do without new syntax.

[09:49:58.0983] <Greg>
For example, in LISPs the `|>` operator is trivial to add without adding new syntax to the language

[09:50:06.0009] <ljharb>
yes but JS isn't and never can be a LISP

[09:50:15.0193] <ljharb>
for example, you can't `await` in the middle of a pipeline unless it's syntax.

[09:50:48.0934] <ljharb>
i hear you that you're upset that JS doesn't work the same as a language you like (LISP, i assume?), but that's not the same thing as "it's possible to make JS into the language you like"

[09:51:32.0809] <ljharb>
btw i hope you realize that i'm truly trying to have a good-faith discussion with you here, despite your abrupt and confrontational entrance. you're not being ignored or brushed aside.

[09:53:09.0238] <Greg>
I appreciate that, and I realize that is exactly how I entered this discussion, and that it would probably have been better to do so with more diplomacy. I am however time pressured at the moment, and it was either that abrupt reply or saying nothing at all

[09:53:58.0582] <Greg>
Please consider the road this is putting JS down. How much more syntax can the language handle before it becomes a monstrosity to more people? It is already a monstrosity to many

[09:54:26.0615] <ljharb>
there are a number of folks on TC39 who share your general sentiment that "too much syntax" is something to avoid. the "tragedy of the common lisp" article has been cited dozens of times

[09:54:42.0447] <ljharb>
that's not an argument against any specific proposal though, and it doesn't have consensus as a ban on further syntax.

[09:55:07.0842] <ljharb>
so rest assured, if that's the extent of your pushback on this proposal, your viewpoint has long been strongly represented.

[09:55:32.0445] <Greg>
OK, thanks for hearing me out

[09:55:36.0844] <ljharb>
absolutely

[09:55:58.0375] <ljharb>
nobody wants JS to become a syntax soup that's hard for people to learn and understand - even those that are enthusiastic about specific syntax proposals

[09:57:46.0896] <Chris de Almeida>
Greg: also, FWIW, know that preventing unnecessary bloat in the language is an issue that is regularly raised in plenary, and proposals absolutely must pass that sniff test to go anywhere

[10:08:09.0210] <Greg>
I guess I would ask the people who are working on modifying JavaScript: when is enough enough (in terms of the syntax)? Does such a point exist? Or will the syntax be modified into perpetuity?

There are costs to this:

1. Cognitive burden to the developer.
2. Cost burden to companies to have to continually spend resources on upgrading their tooling.
3. Costs to browser vendors and people who are interested in building new operating systems that can browse the web - from scratch. Have a look at SerenityOS. Please consider Andreas Kling. Think of what you're doing to him and others like him.

So again. Is there a line that shouldn't be crossed, and what does that line look like? It would be nice if that question were decided upon, at some point.

[10:09:02.0751] <Jack Works>
https://erights.medium.com/the-tragedy-of-the-common-lisp-why-large-languages-explode-4e83096239b9

[10:09:09.0323] <Jack Works>
Maybe you're interested in this article

[10:13:41.0678] <Greg>
Thanks Jack Works, yes it's saying essentially the same thing, nice article

[10:16:07.0783] <Greg>
 * I guess I would ask the people who are working on modifying JavaScript: when is enough enough (in terms of the syntax)? Does such a point exist? Or will the syntax be modified into perpetuity?

There are costs to this:

1. Cognitive burden to the developer.
2. Cost burden to companies to have to continually spend resources on upgrading their tooling.
3. Costs to browser vendors and people who are interested in building new operating systems that can browse the web - from scratch. Have a look at SerenityOS. Please consider Andreas Kling. Think of what you're doing to him and others like him.
4. The percentage of the web that will become unbrowesable to various devices.

So again. Is there a line that shouldn't be crossed, and what does that line look like? It would be nice if that question were decided upon, at some point.

[10:16:33.0811] <Greg>
 * I guess I would ask the people who are working on modifying JavaScript: when is enough enough (in terms of the syntax)? Does such a point exist? Or will the syntax be modified into perpetuity?

There are costs to this:

1. Cognitive burden to the developer.
2. Cost burden to companies to have to continually spend resources on upgrading their tooling.
3. Costs to browser vendors and people who are interested in building new operating systems that can browse the web - from scratch. Have a look at SerenityOS. Please consider Andreas Kling. Think of what you're doing to him and others like him.
4. The percentage of the web that will become unbrowesable to various devices.
5. The increased centralization of browsers themselves.

So again. Is there a line that shouldn't be crossed, and what does that line look like? It would be nice if that question were decided upon, at some point.

[10:16:45.0541] <Greg>
Edited my comment above to add 2 more costs:

> 4. The percentage of the web that will become unbrowesable to various devices.
> 5. The increased centralization of browsers themselves.

[10:22:18.0808] <Greg>
 * I guess I would ask the people who are working on modifying JavaScript: when is enough enough (in terms of the syntax)? Does such a point exist? Or will the syntax be modified into perpetuity?

There are costs to this:

1. Cognitive burden to the developer.
2. Cost burden to companies to have to continually spend resources on upgrading their tooling.
3. Costs to browser vendors and people who are interested in building new operating systems that can browse the web - from scratch. Have a look at SerenityOS. Please consider Andreas Kling. Think of what you're doing to him and others like him.
4. The percentage of the web that will become unbrowseable to various devices.
5. The increased centralization of browsers themselves.

So again. Is there a line that shouldn't be crossed, and what does that line look like? It would be nice if that question were decided upon, at some point.

[10:25:04.0906] <Andreu Botella>
Little of that seems specific to syntax

[10:35:07.0720] <Greg>
Andreu Botella: how is it not specific to syntax?

[10:35:25.0907] <Greg>
 * Andreu Botella: how is it not specific to syntax?

[10:37:30.0908] <Andreu Botella>
Any change in the language will mean changes for users, tooling and engines

[10:40:04.0055] <Greg>
The standard of the language as it impacts browser developers is primarily the syntax, but sure, there might be other aspects of the language that could have these costs too

[10:54:43.0324] <Andreu Botella>
I don't think that's true

[10:55:13.0950] <Andreu Botella>
JS has a bunch of built-ins that are defined by the spec

[10:56:25.0391] <Greg>
I am agreeing with you, so I'm not sure what you're saying isn't true, if you could be more specific it'd be appreciated

[11:10:41.0499] <ryzokuken>
Greg: I see the basis of your argument but I think to some extent you're overestimating the effect of syntax additions of the language.

[11:20:29.0539] <Greg>
ryzokuken: Has the number of independent browsers supporting the latest features of JavaScript gone up or down over time?

[11:22:02.0584] <ryzokuken>
Irrespective of the answer, the point I'm trying to make is that syntax additions to JavaScript are far from the main cause of these things.

[11:27:11.0094] <ryzokuken>
I think a much better argument can be made on the grounds of ergonomics and language complexity 

[11:27:20.0643] <ryzokuken>
But even there, things aren't so black and white IMO

[11:28:00.0604] <ryzokuken>
Syntax additions to the language can actually make it more straightforward to code in many cases.

[11:35:55.0686] <ljharb>
generally in all cases, i'd hope

[15:00:44.0840] <James DiGioia (mAAdhaTTah on GH)>
> <@taoeffect:matrix.org> ryzokuken: Has the number of independent browsers supporting the latest features of JavaScript gone up or down over time?

¬†Also worth noting that while this may be true of _browsers_, it's not necessarily true of _runtimes_ more broadly. With Deno + Bun becoming more popular, plus more niche projects like Jerryscript, Clouflare Workers, edge, etc., it actually seems like the number of runtimes is _increasing_, despite the expanding complexity of the language. This is really an argument for adding nothing new to the web platform as a whole.

