2025-04-01
[17:53:45.0487] <kriskowal>
I believe citgm is the nearest to what youâ€™re looking for https://github.com/nodejs/citgm tagging ulises.gascon 

[17:54:41.0864] <kriskowal>
Iâ€™ve not seen it run on nightlies, but itâ€™s used to qualify v8 version bumps.

[19:50:14.0107] <ljharb>
there's a node nightly build, but it won't have an unmerged v8 in it

[20:09:23.0196] <shu>
kriskowal: thanks

[20:09:32.0286] <shu>
yeah i'm not looking for node nightly, but rather node with v8 nightly

[20:10:03.0009] <shu>
wait, doy, what am i saying, v8 ci has one...

[00:59:37.0264] <Mathieu Hofman>
I believe https://github.com/nodejs/node-v8 is what you're looking for

[01:01:45.0838] <Mathieu Hofman>
Well I guess technically that node nightly with v8 lkgr. Not sure if there is a node current + v8 lkgr

[01:03:23.0357] <Mathieu Hofman>
Also every now and then it gets stuck when something breaks, like now, it hasn't been updated since March 5th

[01:05:56.0771] <James M Snell>
Yeah that typically lags just a bit. And I'm not sure exactly how often the lkgr is updated there. It's the closest we have. V8's own testing with node might be closer but I'm not as familiar with that

[01:13:36.0685] <Jack Works>
NEWS:
engine262 came back to life after 1 or 2 years (counting editorial changes or not) inactive
and with a fresh new playground! Try at https://engine262.js.org/

[15:17:26.0082] <Meghan Denny>
https://tc39.es/ecma262/ :smile: nice one

[15:17:36.0764] <Meghan Denny>
* https://tc39.es/ecma262/ ðŸ˜„ nice one

[16:05:13.0288] <bakkot>
firefox is gonna unflag temporal, woo https://groups.google.com/a/mozilla.org/g/dev-platform/c/RtsRo93ygO4/m/2YzM42GUBwAJ


2025-04-03
[10:49:12.0550] <jmdyck>
The February TC39 meeting was 6 weeks ago. Shouldn't the notes be posted by now?

[10:49:58.0162] <Chris de Almeida>
there is a PR for it, with unresolved comments


2025-04-06
[14:20:25.0714] <akaster>
is there any motivation to pick back up this PR? <https://github.com/tc39/ecma262/pull/2193> ? It seems like it's pretty clear that a 'web reality' change is needed, especially given that it's a 0.08%-er on <https://chromestatus.com/metrics/feature/timeline/popularity/1764>. It looks like SpiderMonkey had some tests added that reflected the web reality, but they were reverted in test262?


2025-04-07
[19:28:59.0065] <littledan>
yes, this would definitely be good to do, IMO

[23:08:20.0533] <Aapo Alasuutari>
I noticed a probably-known implementation inconsistency with Float64Array sorting regarding NaNs: According to spec, any call to Float64Array should canonicalise all NaNs in the TA's viewed buffer since it copies data from the buffer into a list of Values (canonicalising all NaNs here), performs sorting on that list and then writes the sorted items back into the buffer.

On FF, a sort without a comparator seems to sort NaNs according to "absolute value" (uint64) while on Chrome they are left where they were. With a comparator (returning -1 or 1 randomly), on FF they NaNs become canonicalised while on Chrome they get sorted according to the comparator's wishes without canonicalisation.

The spec seems fairly clear to me on this whole issue; canonicalisation happens on every sort call, but the lived reality is different. Should this be accepted, or is this something to file a bug to implementors about (if not already existent)? Or should this be a case where the spec is loosened to allow for implementation defined behaviour?

[04:13:28.0937] <Michael Ficarra>
Aapo Alasuutari: Seems like you should file issues against the implementations. Have you checked the JSC behaviour?

[04:14:03.0830] <Aapo Alasuutari>
Nope, I don't happen to have JSC at my fingertips quite the same as I have FF and Chrome.

[04:20:25.0694] <Aapo Alasuutari>
Okay, non-buggy test code:
```js
b = BigUint64Array.of(9221120237041091055n, 9221120237041090774n);
console.log(b[0], b[1]);
a = new Float64Array(b.buffer);
a.sort();
console.log(b[0], b[1]);
a.sort(() => Math.random() ? -1 : 1);
console.log(b[0], b[1]);
```

[04:25:25.0050] <Aapo Alasuutari>
(I was wrong about FF ordering by "absolute value", that doesn't seem to happen. I must've accidentally sorted the BigUint64Array in one of my tests. Otherwise it all goes as I wrote.)

[04:26:01.0808] <nicolo-ribaudo>
in JSC it logs
```
9221120237041091055n 9221120237041090774n
9221120237041090560n 9221120237041090560n
9221120237041090560n 9221120237041090560n
```

[04:27:37.0141] <nicolo-ribaudo>
Which from your message above seems to be the spec-compliant behavior

[04:28:08.0213] <Aapo Alasuutari>
Yup, that's seems compliant. Ladybird also complies, according to a response I got in their Discord.

[04:28:19.0086] <Aapo Alasuutari>
* Yup, that's seems compliant. Ladybird also complies, based on a response I got in their Discord.

[04:40:32.0066] <Aapo Alasuutari>
https://issues.chromium.org/issues/408932085

[04:48:38.0378] <Aapo Alasuutari>
https://bugzilla.mozilla.org/show_bug.cgi?id=1958820

[08:06:33.0842] <shu>
where's the step that canonicalizes NaNs in sort?

[08:08:23.0856] <shu>
is it your reading that [[Get]] returns the ES NaN, then [[Set]] of that NaN should always produce the same bit pattern in typed arrays?

[08:12:24.0671] <shu>
anyway i think we should fix the spec to reflect reality, and clear up ambiguities in the reading

[08:13:00.0480] <shu>
i don't see a realistic path to get interoperable NaN canonicalization across engines, nor the benefits of doing so

[10:29:03.0409] <ljharb>
we had a whole day of discussion in 2015 about NaN canonicalization. my recollection was that the only time NaNs are canonicalized is when you see one *in JS* - not when a spec-internal operation gets or copies one

[10:30:03.0675] <littledan>
yeah not requiring canonicalization was a pretty explicit decision; I don't understand why we think this doesn't apply to sort

[10:45:31.0261] <annevk>
Not sure if this is what Aapo meant, but when I looked at https://tc39.es/ecma262/#sec-rawbytestonumeric earlier I could interpret that as normalizing NaN values. It checks if value is NaN and then it doesn't return value, but it returns (a canonical?) NaN.

[10:50:36.0540] <littledan>
The current text does imply certain guarantees that aren't actually met in all browsers: "An implementation must always choose the same encoding for each implementation distinguishable NaN value." I would prefer that we adopt Waldemar's proposed alternative semantics, that every time you write a float into a TypedArray, it may have arbitrary undefined NaN bits (which is the previous sentence: "If value is NaN, rawBytes may be set to any implementation chosen IEEE 754-2019 binary64 format NaN encoding. ") https://tc39.es/ecma262/#sec-numerictorawbytes

[10:51:34.0872] <littledan>
the committee was just a little over-optimistic that such regularity would fall out in engines like V8, but it doesn't

[10:51:58.0840] <littledan>
anyway I imagine sort hits this spec path, so it doesn't guarantee canonicalization

[10:53:45.0506] <littledan>
* When you write the JS NaN to a TypedArray, its byte pattern may be arbitrary: which is the previous sentence: "If value is NaN, rawBytes may be set to any implementation chosen IEEE 754-2019 binary64 format NaN encoding. " https://tc39.es/ecma262/#sec-numerictorawbytes

Actually, the text gives some guarantees that aren't actually met in all browsers: "An implementation must always choose the same encoding for each implementation distinguishable NaN value." I would prefer that we adopt Waldemar's proposed alternative, that we just delete that second sentence.

[10:54:04.0265] <littledan>
* When you write the JS NaN to a TypedArray, its byte pattern may be arbitrary: "If value is NaN, rawBytes may be set to any implementation chosen IEEE 754-2019 binary64 format NaN encoding. " https://tc39.es/ecma262/#sec-numerictorawbytes

Actually, the text gives some guarantees that aren't actually met in all browsers: "An implementation must always choose the same encoding for each implementation distinguishable NaN value." I would prefer that we adopt Waldemar's proposed alternative, that we just delete that second sentence.

[13:24:22.0214] <Aapo Alasuutari>
Yeah, I was thinking of [[Get]] and a misread of "The Number Type":
> NaN values of the IEEE Standard are represented in ECMAScript as a single special NaN value.
I had interpreted this to mean that all NaNs must be canonicalised to a single one. Though, the NumericToRawBytes also linked above does indeed say that writing NaN should always choose the same NaN, so I did end up getting it right despite getting it wrong :D

[13:24:29.0171] <Aapo Alasuutari>
* Yeah, I was thinking of \[\[Get\]\] and a misread of "The Number Type":

> NaN values of the IEEE Standard are represented in ECMAScript as a single special NaN value.

I had interpreted this to mean that all NaNs must be canonicalised to a single one. Though, the NumericToRawBytes also linked above does indeed say that writing NaN should always choose the same NaN, so I did end up getting it right despite getting it wrong :D

[13:25:27.0527] <Aapo Alasuutari>
* Yeah, I was thinking of \[\[Get\]\] / RawBytesToNumeric and a misread of "The Number Type":

> NaN values of the IEEE Standard are represented in ECMAScript as a single special NaN value.

I had interpreted this to mean that all NaNs must be canonicalised to a single one. Though, the NumericToRawBytes also linked above does indeed say that writing NaN should always choose the same NaN, so I did end up getting it right despite getting it wrong :D

[13:30:19.0829] <Aapo Alasuutari>
Since spec-wise, sort always performs a fully copy of the buffer data into a list of Values and back after sorting, it'll indeed always pass each entry in the TA through NumericToRawBytes.

[13:30:42.0493] <Aapo Alasuutari>
* Since spec-wise, sort always performs a fully copy of the buffer data into a list of Values and back after sorting, it'll indeed always pass each entry in the TA through RawBytesToNumeric and NumericToRawBytes.

[16:08:03.0267] <akaster>
what's the best way to get this change (PR 2193) on someone's radar? queue it up for an upcoming TC39 meeting? something less formal?

[16:35:37.0267] <bakkot>
that PR is not currently correct and also needs tests

[16:35:46.0448] <bakkot>
so you will need to find a champion willing to do that work

[16:35:50.0520] <bakkot>
thus far no one has stepped forward

[16:35:59.0250] <bakkot>
I personally do not currently have time


2025-04-08
[18:17:16.0380] <littledan>
This would be a great project for a new TC39 delegate to take up, if anyone's looking for something useful to champion

[20:01:25.0814] <rkirsling>
I think my comment in September was meant as a "do y'all want me to carry this over the finish line" but I can't find any context for it in Matrix history, say

[20:01:42.0086] <rkirsling>
and also nobody replied in-thread ðŸ˜…

