2022-01-01
[10:58:29.0767] <ljharb>
Symbols aren‚Äôt cross-realm

[10:58:44.0918] <ljharb>
well-known symbols are, and registry symbols are, but normal symbols aren‚Äôt


2022-01-03
[11:25:52.0401] <sideshowbarker>
looking at https://github.com/mdn/content/pull/11683

[11:26:40.0267] <sideshowbarker>
The existing statement _‚ÄúFunction expressions in JavaScript are not hoisted‚Äù_ in MDN is correct, right?

[11:46:23.0535] <Ashley Claymore>
correct.

```
console.log(foo) // ReferenceError
void function foo() {}
```

[11:48:20.0572] <nicolo-ribaudo>
Functions expressions do not need to be hosted because their binding is only visible inside their body, and no code can run before that binding initialization.

[11:48:57.0948] <nicolo-ribaudo>
I dislike @[Ashley Claymore]'s example, because swapping the two statements doesn't remove the error

[11:50:11.0612] <bakkot>
yeah it's more precise to say that 'hoisting' is not a thing which applies to expressions

[11:50:13.0512] <Ashley Claymore>
fair üôÇ I was going for a minimal way to write a function expression 

[11:51:08.0132] <Ashley Claymore>
üíØ agree that showing that there is no external binding at all is the more important core

[11:51:18.0208] <Ashley Claymore>
* üíØ agree that showing that there is no external binding at all is the more important core

[11:53:01.0202] <nicolo-ribaudo>
> <@sideshowbarker:mozilla.org> looking at https://github.com/mdn/content/pull/11683

Looking at this PR, it looks like the contributor confuses the function expression with the variable declaration. It's not that function expressions are hosited like var declarations: it's just the variable which is hoisted.

[11:54:53.0328] <Ashley Claymore>
Yeah, maybe it‚Äôs not clear to them that only the RHS is considered the function expression. Maybe an ast-explorer link would help 

[12:07:50.0120] <sideshowbarker>
nicolo-ribaudo: Ashley Claymore Thanks ‚Äî I added a comment at https://github.com/mdn/content/pull/11683#issuecomment-1004327053 that goes into a bit more detail.

[12:08:23.0909] <sideshowbarker>
I cited https://stackoverflow.com/questions/3887408/javascript-function-declaration-and-evaluation-order/3887590#3887590 ‚Äî which seems like a really good explanation in detail of what actually happens.

[12:12:29.0234] <sideshowbarker>
Thanks bakkot as well


2022-01-04
[17:03:48.0736] <sideshowbarker>
FYI/help-wanted https://github.com/mdn/content/issues/11665

[17:17:03.0290] <sideshowbarker>
in general, for anybody wanting to help out with the MDN JS docs, and looking for some low-hanging fruit, we have 4 issues labeled as needing 30 minutes or less to resolve https://github.com/mdn/content/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3A%22help+wanted%22+label%3AContent%3AJS+label%3A%22time%3A+-30mins%22+

[17:18:42.0278] <sideshowbarker>
‚Ä¶and overall we have just 34 issues for the JS docs that are labeled as ‚Äúhelp wanted‚Äù https://github.com/mdn/content/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3A%22help+wanted%22+label%3AContent%3AJS (out of 620 open MDN issues overall)

[05:02:35.0939] <Ashley Claymore>
> <@sideshowbarker:mozilla.org> FYI/help-wanted https://github.com/mdn/content/issues/11665

I can‚Äôt find an official source. But I thought one of the reasons for not offering iteration of Weak{Map,Set} was also to allow a variety of implementation approaches. e.g. storing the values on the object keys themselves.

[05:15:09.0886] <Ashley Claymore>
Did JSC implement them this way maybe?

[05:16:54.0709] <Ashley Claymore>
https://bugs.webkit.org/show_bug.cgi?id=142408#c4

[05:17:37.0772] <Ashley Claymore>
https://bugs.webkit.org/show_bug.cgi?id=179929#c0

[08:06:31.0306] <devsnek>
lack of enumeration also allowed weakmap/weakset to be polyfilled by storing the value on the key instead of in the map

[10:17:12.0848] <sideshowbarker>
Ashley Claymore: devsnek Thanks (and thanks bakkot for https://github.com/mdn/content/issues/11665#issuecomment-1004486740). If nobody else creates a PR for that in the meantime, I think I‚Äôll end up creating a PR that just adds the content of bakkot ‚Äôs comment (about avoiding to expose GC details) to that part of the article.

[10:20:19.0164] <sideshowbarker>
meanwhile, I‚Äôm confused by a sentence at https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.lastindexof in the spec:

> The optional second argument _fromIndex_ defaults to the array's length minus one (i.e. the whole array is searched). If it is greater than or equal to the length of the array, the whole array will be searched. If it is less than +0ùîΩ, it is used as the offset from the end of the array to compute _fromIndex_. If the computed index is less than +0ùîΩ, -1ùîΩ is returned.

[10:20:51.0831] <sideshowbarker>
 * meanwhile, I‚Äôm confused by a sentence at https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.lastindexof in the spec:

> The optional second argument _fromIndex_ defaults to the array's length minus one (i.e. the whole array is searched). If it is greater than or equal to the length of the array, the whole array will be searched. If it is less than +0ùîΩ, it is used as the offset from the end of the array to compute _fromIndex_. If the computed index is less than +0ùîΩ, -1ùîΩ is returned.

[10:21:33.0122] <sideshowbarker>
The sentence I‚Äôm confused by is ‚ÄúIf it is less than +0ùîΩ, it is used as the offset from the end of the array to compute _fromIndex_‚Äù

[10:23:39.0134] <sideshowbarker>
What confuses me is that _fromIndex_ is an explicitly-specified value ‚Äî specified as the second argument to `Array.prototype.lastIndexOf()` ‚Äî so why does the spec then change to talking about it being computed?

[10:24:24.0400] <bakkot>
"to compute fromIndex" is a weird way of saying it

[10:24:27.0811] <sideshowbarker>
or in other words, what‚Äôs *‚Äúit‚Äù* in that sentence ‚Äî¬†if not _fromIndex_?

[10:24:33.0492] <bakkot>
it should be "to compute the position from which to start searching"

[10:24:39.0584] <sideshowbarker>
aha

[10:24:47.0414] <sideshowbarker>
OK yeah, then that makes sense, yeah

[10:26:36.0760] <bakkot>
Also it's not actually "from the end of the array" in the case of `lastIndexOf`

[10:27:39.0325] <bakkot>
actually, no, I guess it is

[10:28:28.0533] <bakkot>
anyway yeah these notes are bad

[10:28:31.0929] <bakkot>
`indexOf` has the same problem

[10:34:37.0809] <sideshowbarker>
yeah the corresponding MDN articles also have similar problems‚Ä¶ Trying now to figure out how to re-word them

[10:38:03.0549] <bakkot>
should probably be more like (for `lastIndexOf`)

"The optional second argument fromIndex specifies the offset from which to begin the search. If it is non-negative, it is an offset from the beginning of the array; if negative, an offset from the end. If the resulting offset is greater than or equal to the length of the array, the whole array will be searched. If it is less than 0, -1 is returned, i.e. the array is not searched."

[10:41:01.0599] <bakkot>
 * should probably be more like (for `lastIndexOf`)

"The optional second argument fromIndex specifies the offset from which to begin the search. If it is non-negative, it is an offset from the beginning of the array; if negative, an offset from the end. If the resulting offset is greater than or equal to the length of the array, the whole array will be searched. If it is less than 0, -1 is returned, i.e. the array is not searched. If it is not provided, it defaults to the last index of the array."

[10:41:10.0276] <bakkot>
 * should probably be more like (for `lastIndexOf`)

"The optional second argument fromIndex specifies the offset from which to begin the search. If it is non-negative, it is an offset from the beginning of the array; if negative, an offset from the end. If the resulting offset is greater than or equal to the length of the array, the whole array will be searched. If it is less than 0, -1 is returned, i.e. the array is not searched. If fromIndex is not provided, it defaults to the last index of the array."

[12:04:14.0036] <sideshowbarker>
bakkot: if you‚Äôre still around and you have a few minutes to review a related, PR: https://github.com/mdn/content/pull/11731

[12:05:18.0644] <sideshowbarker>
https://pr11731.content.dev.mdn.mozit.cloud/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf#_flaws has the preview of the rendered article with the PR changes incorporated

[12:05:44.0316] <sideshowbarker>
(and/or if anybody else is around and has time to review that)


2022-01-05
[18:49:14.0640] <sideshowbarker>
now I‚Äôm confused by the statement *‚Äúyou can think of a `WeakSet` as a special case of `WeakMap` where all the values are booleans‚Äù* in https://v8.dev/features/weak-references

[18:49:34.0442] <sideshowbarker>
Mathieu Hofman: ‚¨ÜÔ∏è

[18:51:25.0108] <sideshowbarker>
I see nothing in the spec for `WeakSet` at https://tc39.es/ecma262/multipage/keyed-collections.html#sec-weakset-objects about the values being restricted to being booleans

[18:58:24.0893] <sideshowbarker>
or is that _‚Äúyou can think of a WeakSet as a special case of WeakMap where all the values are booleans‚Äù_ statement just an odd way of saying you can think of a set as a map that only has keys without values?

[18:58:38.0797] <sideshowbarker>
 * or is that _‚Äúyou can think of a WeakSet as a special case of WeakMap where all the values are booleans‚Äù_ statement just an odd way of saying you can think of a set as a map that only has keys without values?

[19:04:51.0478] <sideshowbarker>
‚Ä¶and so, further in https://v8.dev/features/weak-references, I‚Äôm confused by the statement *‚Äúadding an object as a key to a `WeakMap` or `WeakSet` doesn‚Äôt prevent it from being garbage-collected‚Äù* ‚Äî which makes sense for a `WeakMap` but does not seem to make sense for a `WeakSet`, since a `WeakSet` doesn‚Äôt have keys

[19:07:49.0656] <sideshowbarker>
And then there‚Äôs *A JavaScript `WeakMap` is not really weak: it actually refers strongly to its contents as long as the key is alive* ‚Äî¬†which also makes sense just fine but would not seem to make sense for a `WeakSet`

[19:08:34.0637] <Mathieu Hofman>
It's like if WeakSet only had keys, no values

[19:09:11.0361] <sideshowbarker>
ok

[19:11:18.0553] <sideshowbarker>
I guess I‚Äôll try writing up a concrete patch myself for the MDN `WeakMap` and `WeakSet` docs to make them accurate ‚Äî and then to add the clarification about why they are not enumerated

[19:22:56.0962] <Mathieu Hofman>
I think the important part is that `WeakMap` and `WeakRef` provide orthogonal features.

WeakMap allows associating data to objects in a way that doesn't prevent the object keys from being collected, even if the values in the weak map reference the keys. However, WeakMap doesn't allow observing the liveness of the keys, which is why it doesn't allow enumeration.

WeakRef, being a real weak reference, allows to directly observe the liveness of an object. However you cannot build a `WeakMap` from `WeakRef` and `Map`, as that would prevent collection of cycles.

You could combine WeakRef and WeakMap to build an IterableWeakMap which allows enumeration. See https://github.com/tc39/proposal-weakrefs/#iterable-weakmaps

[12:31:54.0112] <devsnek>
bakkot: have you seen deepgram api? i have no idea how good it is but it looks like its very intentionally designed for the kind of thing your note taking bot does

[12:36:45.0400] <bakkot>
I have not, but that does look good

[12:36:59.0249] <bakkot>
I'll try it out if I find myself with a free evening one of these days

[12:37:33.0078] <bakkot>
Claims lower latency than google's STT, which would be very nice

[13:24:06.0781] <devsnek>
whelp i couldn't get it to work with my discord transcription bot, with either the raw ws or the sdk. it seems like the websocket never gets to the open state. i'm probably doing something wrong though.


2022-01-06
[16:40:33.0421] <sachag>
hi everybody! I hope this is the right place, but I have a small request for help

[16:40:48.0103] <sachag>
I run the yearly State of JavaScript surveys (latest edition: https://2020.stateofjs.com/)

[16:41:55.0269] <sachag>
I am currently working on the questions for the next edition, and I would love to involve TC39 more. For example, maybe there are questions the survey could ask that would help provide useful data for TC39 members?

[16:42:09.0011] <sachag>
there's an open GitHub thread here: https://github.com/StateOfJS/Monorepo/issues/56

[16:42:17.0221] <sachag>
or you can just DM me with your feedback/questions

[22:51:51.0569] <Ashley Claymore>
> <@sachag:matrix.org> hi everybody! I hope this is the right place, but I have a small request for help

Welcome! üëãüèª

[22:52:18.0658] <Ashley Claymore>
* > <@sachag:matrix.org> hi everybody! I hope this is the right place, but I have a small request for help

Welcome! üëãüèª

[23:08:54.0533] <ryzokuken>
Hi sachag, this is awesome!

[23:11:01.0886] <ryzokuken>
I think the best people for this would be the folks involved in the monthly research calls we have. I see the next one is on the 27th.

[23:11:49.0382] <ryzokuken>
yulia: do you think it'd be a good idea to include this on the agenda for the next one?

[00:44:57.0903] <yulia>
sachag ryzokuken yes this sounds like a good idea -- it may also be great to have you stop by in our research call

[01:35:54.0016] <sachag>
> <@usharma:igalia.com> I think the best people for this would be the folks involved in the monthly research calls we have. I see the next one is on the 27th.

that'd be great! the survey will most likely go out before then (it's supposed to be the 2021 survey so it's already late as it is‚Ä¶) but the feedback can be useful for the next edition

[01:36:09.0367] <sachag>
I'd also be happy to give you access to early results if that's helpful

[05:29:07.0331] <yulia>
sachag: likely you already did all the work for this years survey, but we can get together and have a special call also with felienne

[05:29:24.0687] <yulia>
and prepare for next year regarding what questions would be interesting


2022-01-10
[18:59:30.0269] <bakkot>
emscripten is pretty good now it turns out

[19:01:21.0931] <bakkot>
spent the weekend hacking together wasm/typescript bindings for z3 (the smt solver) and once I figured out how to deal with threads properly it all just worked

[19:02:32.0893] <bakkot>
js could definitely do with better multithreading primitives though

[19:12:19.0094] <Jack Works>
Like the shared structs proposal? 

[19:16:23.0921] <bakkot>
yeah, and module blocks or whatever that proposal evolved into

[19:16:48.0247] <bakkot>
there is just not a good way to say "go do this work in another thread" right now

[10:33:30.0474] <Luca Casonato>
Do folks here have thoughts on JS's string split behaviour? It differs from essentially all other languages in that a string split with limited split count splits N+1 times, but returns N items, whereas most language standard libraries split N times and also return N items. This causes essentially all languages other than JS to return an N size array from an N size split, where the last item is the remainder string. In JS the last item is not the remainder, but the N'th item: everything after the N'th item is discarded.

[10:33:40.0680] <Luca Casonato>
This image illustrates the difference:

[11:09:05.0548] <shu>
seems like something we can't change at this point?

[11:09:30.0776] <shu>
if you have a new method, it has to contend with that the thing that people expect to behave the same as other languages is still named `split`

[11:10:26.0565] <Luca Casonato>
That is valid. Although the function that does what I expect is called `SplitN` in Go and `splitn` in Rust. So there is precedent for that behaviour having this name. 

[11:13:51.0520] <Justin Ridgewell>
I actually think the JS behavior is better...

[11:14:26.0247] <Justin Ridgewell>
Eg, for `'1.0.0'.split('.', 1)` to "parse" the major version

[11:14:53.0098] <Justin Ridgewell>
 * Eg, for `'1.0.0'.split('.', 1)` to "parse" the major version

[11:15:07.0630] <Luca Casonato>
The reason I like the non JS behaviour better, is that `v.split(s, n).join(s)` works always. And it makes stripping of prefixes really easy.

[11:16:20.0479] <Luca Casonato>
Proposal of how it could be fixed in a backwards compatible way (by either adding a new method, or an options bag to `String.prototype.split`: https://github.com/lucacasonato/proposal-proper-string-split

[11:17:23.0031] <Luca Casonato>
> <@jridgewell:matrix.org> Eg, for `'1.0.0'.split('.', 1)` to "parse" the major version

You could still do that with the other behaviour, by doing `'1.0.0'.splitn('.', 2)[0]`


2022-01-12
[20:41:44.0902] <bakkot>
this is I think a good overview of security and kinds of security bugs in modern browsers, if anyone feels like getting in to that: https://arxiv.org/pdf/2112.15561.pdf

[21:29:36.0928] <sachag>
I just opened this year's survey to respondents: https://stateofjs.com/

[21:30:15.0472] <sachag>
I'm not going to change it too much now that it's open to avoid messing up the data, but if you see any big mistake do let me know

[21:30:24.0708] <sachag>
and hopefully we can chat about it soon!

[15:08:22.0923] <jschoi>
> <@sachag:matrix.org> I'm not going to change it too much now that it's open to avoid messing up the data, but if you see any big mistake do let me know

The survey looks nice! FYI, Intl is technically a part of the JavaScript language, not a web browser API. 

[15:17:00.0971] <sachag>
oh, do you think I should move it to the Language section then?

[15:43:41.0092] <shu>
maybe "web browser" is somewhat incorrect. i'm of the opinion it's not really valuable to be super pedantic about what's technically part of JS due to the standards body org chart

[15:45:37.0485] <shu>
programmers probably mostly have the mental model of "language" meaning "core syntax and builtins" vs "supplemental APIs". some supplemental APIs are here in tc39, some are in w3c and whatwg

[15:46:51.0935] <shu>
 * programmers probably mostly have the mental model of "language" meaning "core syntax and builtins" vs "supplemental APIs". some supplemental APIs are here in tc39, some are in w3c and whatwg


2022-01-13
[18:29:23.0543] <sachag>
yeah it's not easy to know what's what‚Ä¶

[10:05:02.0884] <ljharb>
Intl is sort of in the middle, but it's in browsers and node, so it feels more language than web to me

[10:05:30.0018] <ljharb>
and i do actually think most devs end up with a mental model of "browser stuff", "node stuff", and "universal/isomorphic stuff", and are pretty aware of the difference

[10:05:42.0956] <ljharb>
 * and i do actually think most devs end up with a mental model of "browser stuff", "node stuff", and "universal/isomorphic stuff", and are pretty aware of the difference

[10:05:59.0879] <ljharb>
things like setTimeout, that are universal but not in the language spec, muddy the waters a bit, ofc

[10:08:32.0719] <bakkot>
and URL

[10:08:34.0442] <bakkot>
someday, fetch

[10:09:36.0826] <bakkot>
I think the distinction is mostly relevant for IO things

[10:09:48.0634] <bakkot>
like, `fs` is node-only, the DOM is browser-only

[10:10:24.0903] <bakkot>
that doesn't map that cleanly to "tc39 spec vs whatwg spec"

[10:11:08.0719] <ljharb>
URL true. fetch never, because a compliant fetch isn't possible outside a browser (i'd love a universal abstraction for "make an http request and get a promise", but fetch sadly isn't eligible to be it)

[10:11:22.0716] <ljharb>
very true tho, it's not a clean mental model around spec boundaries

[10:11:26.0692] <ljharb>
but it's pretty close

[10:11:54.0629] <ljharb>
 * URL true. fetch never, because a compliant fetch isn't possible outside a browser (i'd love a universal abstraction for "make an http request and get a promise", but fetch sadly isn't eligible to be it)

[10:13:11.0229] <bakkot>
aw I thought they were gonna do that

[10:13:17.0558] <bakkot>
what makes it not possible outside a browser?

[10:55:37.0323] <ptomato>
> <@ljharb:matrix.org> things like setTimeout, that are universal but not in the language spec, muddy the waters a bit, ofc

I don't know if it's TC39's place to provide this but it'd be great to have a signal about what things are "universal" - we don't have setTimeout in GNOME's JS environment, for example, because GNOME's platform libraries already provide equivalent functionality. but we are nonetheless planning to add it soon, just because more beginners are familiar with it. we've had a bunch of discussion about which WHATWG facilities are in scope and which only make sense in browsers

[10:56:41.0629] <ljharb>
bakkot: node doesn't have cookies, or a "current URL", and a bunch of other stuff

[10:56:53.0489] <ljharb>
node could ship a partial fetch but it's either 100% fetch or it's not fetch ¬Ø\\\_(„ÉÑ)_/¬Ø 

[10:56:57.0776] <ljharb>
 * node could ship a partial fetch but it's either 100% fetch or it's not fetch

[10:57:01.0010] <ljharb>
 * node could ship a partial fetch but it's either 100% fetch or it's not fetch ¬Ø\\\_(„ÉÑ)_/¬Ø 

[10:58:09.0369] <TabAtkins>
Just default "current URL" to "https://example.com", done

[11:05:54.0702] <ljharb>
then iirc node would have to factor in same-origin restrictions, CORS, local cookies, etc, none of which apply to node

[11:06:16.0588] <ljharb>
it's just a category error to try to use `fetch` outside a browser; it (like most web things) just wasn't designed for non-web use

[11:08:57.0857] <TabAtkins>
(My suggestion was shitposting.)

[11:10:13.0827] <bakkot>
ehhhhhhhhhh this sounds like one of those distinctions which is unlikely to matter to users in practice

[11:10:51.0664] <bakkot>
if node has a global named `fetch` that I can use the way I would use `fetch` I do not care if the lack of cookies means that in fact they do not "have fetch"

[11:18:31.0798] <Luca Casonato>
> <@bakkot:matrix.org> what makes it not possible outside a browser?

It is very possible. Both Cloudflare and Deno have demonstrated it is very possible to create a rather spec compliant server side `fetch` implementation. Deno only really leaves out two main specification features: cookie jars and CORS.

[11:42:49.0168] <ljharb>
something that you can use in the ways you would use `fetch`, but not in *all* the ways you would use `fetch`, will cause more harm than good. i'm aware of deno's implementation.

[11:43:23.0607] <ljharb>
it's the same harm caused by a noncompliant polyfill. if you want less than 100% compliance, then it's better to use something that isn't purporting to match a spec.

[11:43:39.0470] <Luca Casonato>
Let's chat about it some time. I don't think this is the right venue though :-)

[11:44:06.0040] <ljharb>
fair enough :-)

[12:24:53.0294] <bakkot>
if the conversation happens in public, ping me?


2022-01-15
[19:04:50.0114] <devsnek>
fwiw its sort of "planned" to have fetch in node, there's just a lot of stuff to do and not a lot of people willing to do it. (jasnell's work on streams, for example)

[19:50:27.0736] <sideshowbarker>
Can somebody please step in on https://github.com/mdn/content/issues/11743 with a comment to confirm what the argument order is for the replacer function for `String.prototype.replace()`?

[19:51:14.0392] <sideshowbarker>
Is it `(match, offset, string)` or is it instead `(match, string, offset)`?

[19:52:09.0209] <sideshowbarker>
see comments at https://github.com/mdn/content/issues/11743#issuecomment-1012831082 and https://github.com/mdn/content/pull/11770#pullrequestreview-845997341

[19:52:36.0276] <sideshowbarker>
 * Is it `(match, offset, string)` or is it instead `(match, string, offset)`?

[19:56:42.0215] <jmdyck>
looks like neither

[19:57:16.0564] <sideshowbarker>
oh‚Ä¶

[19:57:21.0496] <jmdyck>
replacer is called with only 2 arguments: ¬´ O, replaceValue ¬ª

[19:57:31.0596] <sideshowbarker>
aha

[19:57:57.0884] <sideshowbarker>
then I wonder why it doesn‚Äôt throw when called when called with 3 arguments‚Ä¶

[19:58:16.0625] <jmdyck>
extra args are always allowed and ignored.

[19:59:19.0040] <jmdyck>
no wait, you mean "why doesn't it throw when the actual replacer takes 3 args", right?

[19:59:31.0932] <sideshowbarker>
yeah

[19:59:35.0381] <sideshowbarker>
that

[19:59:48.0748] <jmdyck>
in that case, the 3rd arg should always be *undefined*

[19:59:54.0897] <sideshowbarker>
also, at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_function_as_a_parameter we have it documented as taking as many as 5 arguments

[20:00:02.0312] <jmdyck>
(unless the implementation is doing something special)

[20:00:59.0392] <sideshowbarker>
 * also, at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_function_as_a_parameter we have it documented as taking even more than just 3 arguments

[20:02:21.0910] <jmdyck>
ah, i think misunderstanding re "replacer function"

[20:03:52.0173] <sideshowbarker>
yeah looking at the spec, I see

> 12. If functionalReplace is true, then
>a. Let replacement be ? ToString(? Call(replaceValue, undefined, ¬´ searchString, ùîΩ(position), string ¬ª)).

[20:04:57.0713] <jmdyck>
`_replacer_` is the alias that the spec uses for the @@replace method extracted from the *first* arg to S.p.replace() 

[20:05:13.0139] <jmdyck>
but you're talking about the *second* arg

[20:08:50.0542] <jmdyck>
If the second arg is a function, it's called with args ¬´ searchString, ùîΩ(position), string ¬ª, which is roughly (needle, offset, haystack)

[20:13:39.0829] <jmdyck>
The MDN page's description of the second parameter looks non-standard to me.

[20:14:19.0766] <jmdyck>
(Though maybe all engines support it?)

[20:22:42.0276] <sideshowbarker>
> <@jmdyck:matrix.org> If the second arg is a function, it's called with args ¬´ searchString, ùîΩ(position), string ¬ª, which is roughly (needle, offset, haystack)

OK, will go with that

[20:23:12.0424] <sideshowbarker>
> <@jmdyck:matrix.org> The MDN page's description of the second parameter looks non-standard to me.

yeah, now I‚Äôm wondering where it came from to begin with

[20:57:09.0518] <sideshowbarker>
which part of the spec defines operator precedence?

[20:57:30.0479] <sideshowbarker>
looking for a reference to cite in https://github.com/mdn/content/issues/11926

[20:58:48.0139] <jmdyck>
Operator precedence is implicit in the grammar.

[21:00:47.0635] <sideshowbarker>
OK, but the statement _‚ÄúPrecedence of 'Postfix Increment/Decrement' is higher than 'Function Call'‚Äù_ is not correct, right?

[21:07:21.0386] <jmdyck>
right (given reasonable definitions)

[21:14:15.0279] <jmdyck>
It's unclear why the submitter thinks that the observed behavior implies "Precedence of 'Postfix Increment/Decrement' is higher than 'Function Call'"

[21:20:04.0471] <jmdyck>
for a postfix op to have a higher precedence than operator OP, you expect `X OP Y ++` to mean `X OP (Y++)` rather than `(X OP Y)++`, but the first option doesn't really make sense when OP is function-call.

[03:54:28.0638] <Ashley Claymore>
> <@sideshowbarker:mozilla.org> looking for a reference to cite in https://github.com/mdn/content/issues/11926

I think the confusion originated in this discussion: https://es.discourse.group/t/map-weakmap-etc-prototype-getref-key/884/8

[04:01:03.0171] <Ashley Claymore>
`(f())++` would be a ReferenceError, but `((0, f())++` is a SyntaxError


2022-01-17
[17:21:26.0772] <sideshowbarker>
looking at https://github.com/mdn/content/issues/12062, does the spec anywhere define negative zero?

[17:21:54.0960] <sideshowbarker>
maybe somewhere by reference to IEEE 754?

[17:23:21.0439] <bakkot>
sideshowbarker: https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-ecmascript-language-types-number-type

[17:24:06.0792] <bakkot>
it does mention negative zero, but the actual definition is just by reference to IEEE, yes

[17:24:09.0478] <sideshowbarker>
OK, so it just follows from that

[17:24:14.0272] <sideshowbarker>
OK yeah

[17:24:50.0214] <bakkot>
seems like a reasonable place to ref https://en.wikipedia.org/wiki/Signed_zero

[17:25:04.0784] <bakkot>
(on mdn, I mean, not the spec)

