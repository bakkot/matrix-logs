2022-01-01
[10:58:29.0767] <ljharb>
Symbols aren‚Äôt cross-realm

[10:58:44.0918] <ljharb>
well-known symbols are, and registry symbols are, but normal symbols aren‚Äôt


2022-01-03
[11:25:52.0401] <sideshowbarker>
looking at https://github.com/mdn/content/pull/11683

[11:26:40.0267] <sideshowbarker>
The existing statement _‚ÄúFunction expressions in JavaScript are not hoisted‚Äù_ in MDN is correct, right?

[11:46:23.0535] <Ashley Claymore>
correct.

```
console.log(foo) // ReferenceError
void function foo() {}
```

[11:48:20.0572] <nicolo-ribaudo>
Functions expressions do not need to be hosted because their binding is only visible inside their body, and no code can run before that binding initialization.

[11:48:57.0948] <nicolo-ribaudo>
I dislike @[Ashley Claymore]'s example, because swapping the two statements doesn't remove the error

[11:50:11.0612] <bakkot>
yeah it's more precise to say that 'hoisting' is not a thing which applies to expressions

[11:50:13.0512] <Ashley Claymore>
fair üôÇ I was going for a minimal way to write a function expression 

[11:51:08.0132] <Ashley Claymore>
üíØ agree that showing that there is no external binding at all is the more important core

[11:51:18.0208] <Ashley Claymore>
* üíØ agree that showing that there is no external binding at all is the more important core

[11:53:01.0202] <nicolo-ribaudo>
> <@sideshowbarker:mozilla.org> looking at https://github.com/mdn/content/pull/11683

Looking at this PR, it looks like the contributor confuses the function expression with the variable declaration. It's not that function expressions are hosited like var declarations: it's just the variable which is hoisted.

[11:54:53.0328] <Ashley Claymore>
Yeah, maybe it‚Äôs not clear to them that only the RHS is considered the function expression. Maybe an ast-explorer link would help 

[12:07:50.0120] <sideshowbarker>
nicolo-ribaudo: Ashley Claymore Thanks ‚Äî I added a comment at https://github.com/mdn/content/pull/11683#issuecomment-1004327053 that goes into a bit more detail.

[12:08:23.0909] <sideshowbarker>
I cited https://stackoverflow.com/questions/3887408/javascript-function-declaration-and-evaluation-order/3887590#3887590 ‚Äî which seems like a really good explanation in detail of what actually happens.

[12:12:29.0234] <sideshowbarker>
Thanks bakkot as well


2022-01-04
[17:03:48.0736] <sideshowbarker>
FYI/help-wanted https://github.com/mdn/content/issues/11665

[17:17:03.0290] <sideshowbarker>
in general, for anybody wanting to help out with the MDN JS docs, and looking for some low-hanging fruit, we have 4 issues labeled as needing 30 minutes or less to resolve https://github.com/mdn/content/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3A%22help+wanted%22+label%3AContent%3AJS+label%3A%22time%3A+-30mins%22+

[17:18:42.0278] <sideshowbarker>
‚Ä¶and overall we have just 34 issues for the JS docs that are labeled as ‚Äúhelp wanted‚Äù https://github.com/mdn/content/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3A%22help+wanted%22+label%3AContent%3AJS (out of 620 open MDN issues overall)

[05:02:35.0939] <Ashley Claymore>
> <@sideshowbarker:mozilla.org> FYI/help-wanted https://github.com/mdn/content/issues/11665

I can‚Äôt find an official source. But I thought one of the reasons for not offering iteration of Weak{Map,Set} was also to allow a variety of implementation approaches. e.g. storing the values on the object keys themselves.

[05:15:09.0886] <Ashley Claymore>
Did JSC implement them this way maybe?

[05:16:54.0709] <Ashley Claymore>
https://bugs.webkit.org/show_bug.cgi?id=142408#c4

[05:17:37.0772] <Ashley Claymore>
https://bugs.webkit.org/show_bug.cgi?id=179929#c0

[08:06:31.0306] <devsnek>
lack of enumeration also allowed weakmap/weakset to be polyfilled by storing the value on the key instead of in the map

[10:17:12.0848] <sideshowbarker>
Ashley Claymore: devsnek Thanks (and thanks bakkot for https://github.com/mdn/content/issues/11665#issuecomment-1004486740). If nobody else creates a PR for that in the meantime, I think I‚Äôll end up creating a PR that just adds the content of bakkot ‚Äôs comment (about avoiding to expose GC details) to that part of the article.

[10:20:19.0164] <sideshowbarker>
meanwhile, I‚Äôm confused by a sentence at https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.lastindexof in the spec:

> The optional second argument _fromIndex_ defaults to the array's length minus one (i.e. the whole array is searched). If it is greater than or equal to the length of the array, the whole array will be searched. If it is less than +0ùîΩ, it is used as the offset from the end of the array to compute _fromIndex_. If the computed index is less than +0ùîΩ, -1ùîΩ is returned.

[10:20:51.0831] <sideshowbarker>
 * meanwhile, I‚Äôm confused by a sentence at https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.lastindexof in the spec:

> The optional second argument _fromIndex_ defaults to the array's length minus one (i.e. the whole array is searched). If it is greater than or equal to the length of the array, the whole array will be searched. If it is less than +0ùîΩ, it is used as the offset from the end of the array to compute _fromIndex_. If the computed index is less than +0ùîΩ, -1ùîΩ is returned.

[10:21:33.0122] <sideshowbarker>
The sentence I‚Äôm confused by is ‚ÄúIf it is less than +0ùîΩ, it is used as the offset from the end of the array to compute _fromIndex_‚Äù

[10:23:39.0134] <sideshowbarker>
What confuses me is that _fromIndex_ is an explicitly-specified value ‚Äî specified as the second argument to `Array.prototype.lastIndexOf()` ‚Äî so why does the spec then change to talking about it being computed?

[10:24:24.0400] <bakkot>
"to compute fromIndex" is a weird way of saying it

[10:24:27.0811] <sideshowbarker>
or in other words, what‚Äôs *‚Äúit‚Äù* in that sentence ‚Äî¬†if not _fromIndex_?

[10:24:33.0492] <bakkot>
it should be "to compute the position from which to start searching"

[10:24:39.0584] <sideshowbarker>
aha

[10:24:47.0414] <sideshowbarker>
OK yeah, then that makes sense, yeah

[10:26:36.0760] <bakkot>
Also it's not actually "from the end of the array" in the case of `lastIndexOf`

[10:27:39.0325] <bakkot>
actually, no, I guess it is

[10:28:28.0533] <bakkot>
anyway yeah these notes are bad

[10:28:31.0929] <bakkot>
`indexOf` has the same problem

[10:34:37.0809] <sideshowbarker>
yeah the corresponding MDN articles also have similar problems‚Ä¶ Trying now to figure out how to re-word them

[10:38:03.0549] <bakkot>
should probably be more like (for `lastIndexOf`)

"The optional second argument fromIndex specifies the offset from which to begin the search. If it is non-negative, it is an offset from the beginning of the array; if negative, an offset from the end. If the resulting offset is greater than or equal to the length of the array, the whole array will be searched. If it is less than 0, -1 is returned, i.e. the array is not searched."

[10:41:01.0599] <bakkot>
 * should probably be more like (for `lastIndexOf`)

"The optional second argument fromIndex specifies the offset from which to begin the search. If it is non-negative, it is an offset from the beginning of the array; if negative, an offset from the end. If the resulting offset is greater than or equal to the length of the array, the whole array will be searched. If it is less than 0, -1 is returned, i.e. the array is not searched. If it is not provided, it defaults to the last index of the array."

[10:41:10.0276] <bakkot>
 * should probably be more like (for `lastIndexOf`)

"The optional second argument fromIndex specifies the offset from which to begin the search. If it is non-negative, it is an offset from the beginning of the array; if negative, an offset from the end. If the resulting offset is greater than or equal to the length of the array, the whole array will be searched. If it is less than 0, -1 is returned, i.e. the array is not searched. If fromIndex is not provided, it defaults to the last index of the array."

