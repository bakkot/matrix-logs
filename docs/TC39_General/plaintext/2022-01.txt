2022-01-01
[10:58:29.0767] <ljharb>
Symbols arenâ€™t cross-realm

[10:58:44.0918] <ljharb>
well-known symbols are, and registry symbols are, but normal symbols arenâ€™t


2022-01-03
[11:25:52.0401] <sideshowbarker>
looking at https://github.com/mdn/content/pull/11683

[11:26:40.0267] <sideshowbarker>
The existing statement _â€œFunction expressions in JavaScript are not hoistedâ€_ in MDN is correct, right?

[11:46:23.0535] <Ashley Claymore>
correct.

```
console.log(foo) // ReferenceError
void function foo() {}
```

[11:48:20.0572] <nicolo-ribaudo>
Functions expressions do not need to be hosted because their binding is only visible inside their body, and no code can run before that binding initialization.

[11:48:57.0948] <nicolo-ribaudo>
I dislike @[Ashley Claymore]'s example, because swapping the two statements doesn't remove the error

[11:50:11.0612] <bakkot>
yeah it's more precise to say that 'hoisting' is not a thing which applies to expressions

[11:50:13.0512] <Ashley Claymore>
fair ğŸ™‚ I was going for a minimal way to write a function expression 

[11:51:08.0132] <Ashley Claymore>
ğŸ’¯ agree that showing that there is no external binding at all is the more important core

[11:51:18.0208] <Ashley Claymore>
* ğŸ’¯ agree that showing that there is no external binding at all is the more important core

[11:53:01.0202] <nicolo-ribaudo>
> <@sideshowbarker:mozilla.org> looking at https://github.com/mdn/content/pull/11683

Looking at this PR, it looks like the contributor confuses the function expression with the variable declaration. It's not that function expressions are hosited like var declarations: it's just the variable which is hoisted.

[11:54:53.0328] <Ashley Claymore>
Yeah, maybe itâ€™s not clear to them that only the RHS is considered the function expression. Maybe an ast-explorer link would help 

[12:07:50.0120] <sideshowbarker>
nicolo-ribaudo: Ashley Claymore Thanks â€” I added a comment at https://github.com/mdn/content/pull/11683#issuecomment-1004327053 that goes into a bit more detail.

[12:08:23.0909] <sideshowbarker>
I cited https://stackoverflow.com/questions/3887408/javascript-function-declaration-and-evaluation-order/3887590#3887590 â€” which seems like a really good explanation in detail of what actually happens.

[12:12:29.0234] <sideshowbarker>
Thanks bakkot as well


2022-01-04
[17:03:48.0736] <sideshowbarker>
FYI/help-wanted https://github.com/mdn/content/issues/11665

[17:17:03.0290] <sideshowbarker>
in general, for anybody wanting to help out with the MDN JS docs, and looking for some low-hanging fruit, we have 4 issues labeled as needing 30 minutes or less to resolve https://github.com/mdn/content/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3A%22help+wanted%22+label%3AContent%3AJS+label%3A%22time%3A+-30mins%22+

[17:18:42.0278] <sideshowbarker>
â€¦and overall we have just 34 issues for the JS docs that are labeled as â€œhelp wantedâ€ https://github.com/mdn/content/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3A%22help+wanted%22+label%3AContent%3AJS (out of 620 open MDN issues overall)

[05:02:35.0939] <Ashley Claymore>
> <@sideshowbarker:mozilla.org> FYI/help-wanted https://github.com/mdn/content/issues/11665

I canâ€™t find an official source. But I thought one of the reasons for not offering iteration of Weak{Map,Set} was also to allow a variety of implementation approaches. e.g. storing the values on the object keys themselves.

[05:15:09.0886] <Ashley Claymore>
Did JSC implement them this way maybe?

[05:16:54.0709] <Ashley Claymore>
https://bugs.webkit.org/show_bug.cgi?id=142408#c4

[05:17:37.0772] <Ashley Claymore>
https://bugs.webkit.org/show_bug.cgi?id=179929#c0

[08:06:31.0306] <devsnek>
lack of enumeration also allowed weakmap/weakset to be polyfilled by storing the value on the key instead of in the map

[10:17:12.0848] <sideshowbarker>
Ashley Claymore: devsnek Thanks (and thanks bakkot for https://github.com/mdn/content/issues/11665#issuecomment-1004486740). If nobody else creates a PR for that in the meantime, I think Iâ€™ll end up creating a PR that just adds the content of bakkot â€™s comment (about avoiding to expose GC details) to that part of the article.

[10:20:19.0164] <sideshowbarker>
meanwhile, Iâ€™m confused by a sentence at https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.lastindexof in the spec:

> The optional second argument _fromIndex_ defaults to the array's length minus one (i.e. the whole array is searched). If it is greater than or equal to the length of the array, the whole array will be searched. If it is less than +0ğ”½, it is used as the offset from the end of the array to compute _fromIndex_. If the computed index is less than +0ğ”½, -1ğ”½ is returned.

[10:20:51.0831] <sideshowbarker>
 * meanwhile, Iâ€™m confused by a sentence at https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.lastindexof in the spec:

> The optional second argument _fromIndex_ defaults to the array's length minus one (i.e. the whole array is searched). If it is greater than or equal to the length of the array, the whole array will be searched. If it is less than +0ğ”½, it is used as the offset from the end of the array to compute _fromIndex_. If the computed index is less than +0ğ”½, -1ğ”½ is returned.

[10:21:33.0122] <sideshowbarker>
The sentence Iâ€™m confused by is â€œIf it is less than +0ğ”½, it is used as the offset from the end of the array to compute _fromIndex_â€

[10:23:39.0134] <sideshowbarker>
What confuses me is that _fromIndex_ is an explicitly-specified value â€” specified as the second argument to `Array.prototype.lastIndexOf()` â€” so why does the spec then change to talking about it being computed?

[10:24:24.0400] <bakkot>
"to compute fromIndex" is a weird way of saying it

[10:24:27.0811] <sideshowbarker>
or in other words, whatâ€™s *â€œitâ€* in that sentence â€”Â if not _fromIndex_?

[10:24:33.0492] <bakkot>
it should be "to compute the position from which to start searching"

[10:24:39.0584] <sideshowbarker>
aha

[10:24:47.0414] <sideshowbarker>
OK yeah, then that makes sense, yeah

[10:26:36.0760] <bakkot>
Also it's not actually "from the end of the array" in the case of `lastIndexOf`

[10:27:39.0325] <bakkot>
actually, no, I guess it is

[10:28:28.0533] <bakkot>
anyway yeah these notes are bad

[10:28:31.0929] <bakkot>
`indexOf` has the same problem

[10:34:37.0809] <sideshowbarker>
yeah the corresponding MDN articles also have similar problemsâ€¦ Trying now to figure out how to re-word them

