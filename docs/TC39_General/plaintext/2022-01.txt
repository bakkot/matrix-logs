2022-01-01
[10:58:29.0767] <ljharb>
Symbols aren‚Äôt cross-realm

[10:58:44.0918] <ljharb>
well-known symbols are, and registry symbols are, but normal symbols aren‚Äôt


2022-01-03
[11:25:52.0401] <sideshowbarker>
looking at https://github.com/mdn/content/pull/11683

[11:26:40.0267] <sideshowbarker>
The existing statement _‚ÄúFunction expressions in JavaScript are not hoisted‚Äù_ in MDN is correct, right?

[11:46:23.0535] <Ashley Claymore>
correct.

```
console.log(foo) // ReferenceError
void function foo() {}
```

[11:48:20.0572] <nicolo-ribaudo>
Functions expressions do not need to be hosted because their binding is only visible inside their body, and no code can run before that binding initialization.

[11:48:57.0948] <nicolo-ribaudo>
I dislike @[Ashley Claymore]'s example, because swapping the two statements doesn't remove the error

[11:50:11.0612] <bakkot>
yeah it's more precise to say that 'hoisting' is not a thing which applies to expressions

[11:50:13.0512] <Ashley Claymore>
fair üôÇ I was going for a minimal way to write a function expression 

[11:51:08.0132] <Ashley Claymore>
üíØ agree that showing that there is no external binding at all is the more important core

[11:51:18.0208] <Ashley Claymore>
* üíØ agree that showing that there is no external binding at all is the more important core

[11:53:01.0202] <nicolo-ribaudo>
> <@sideshowbarker:mozilla.org> looking at https://github.com/mdn/content/pull/11683

Looking at this PR, it looks like the contributor confuses the function expression with the variable declaration. It's not that function expressions are hosited like var declarations: it's just the variable which is hoisted.

[11:54:53.0328] <Ashley Claymore>
Yeah, maybe it‚Äôs not clear to them that only the RHS is considered the function expression. Maybe an ast-explorer link would help 

[12:07:50.0120] <sideshowbarker>
nicolo-ribaudo: Ashley Claymore Thanks ‚Äî I added a comment at https://github.com/mdn/content/pull/11683#issuecomment-1004327053 that goes into a bit more detail.

[12:08:23.0909] <sideshowbarker>
I cited https://stackoverflow.com/questions/3887408/javascript-function-declaration-and-evaluation-order/3887590#3887590 ‚Äî which seems like a really good explanation in detail of what actually happens.

[12:12:29.0234] <sideshowbarker>
Thanks bakkot as well


2022-01-04
[17:03:48.0736] <sideshowbarker>
FYI/help-wanted https://github.com/mdn/content/issues/11665

[17:17:03.0290] <sideshowbarker>
in general, for anybody wanting to help out with the MDN JS docs, and looking for some low-hanging fruit, we have 4 issues labeled as needing 30 minutes or less to resolve https://github.com/mdn/content/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3A%22help+wanted%22+label%3AContent%3AJS+label%3A%22time%3A+-30mins%22+

[17:18:42.0278] <sideshowbarker>
‚Ä¶and overall we have just 34 issues for the JS docs that are labeled as ‚Äúhelp wanted‚Äù https://github.com/mdn/content/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3A%22help+wanted%22+label%3AContent%3AJS (out of 620 open MDN issues overall)

[05:02:35.0939] <Ashley Claymore>
> <@sideshowbarker:mozilla.org> FYI/help-wanted https://github.com/mdn/content/issues/11665

I can‚Äôt find an official source. But I thought one of the reasons for not offering iteration of Weak{Map,Set} was also to allow a variety of implementation approaches. e.g. storing the values on the object keys themselves.

[05:15:09.0886] <Ashley Claymore>
Did JSC implement them this way maybe?

[05:16:54.0709] <Ashley Claymore>
https://bugs.webkit.org/show_bug.cgi?id=142408#c4

[05:17:37.0772] <Ashley Claymore>
https://bugs.webkit.org/show_bug.cgi?id=179929#c0

[08:06:31.0306] <devsnek>
lack of enumeration also allowed weakmap/weakset to be polyfilled by storing the value on the key instead of in the map

[10:17:12.0848] <sideshowbarker>
Ashley Claymore: devsnek Thanks (and thanks bakkot for https://github.com/mdn/content/issues/11665#issuecomment-1004486740). If nobody else creates a PR for that in the meantime, I think I‚Äôll end up creating a PR that just adds the content of bakkot ‚Äôs comment (about avoiding to expose GC details) to that part of the article.

[10:20:19.0164] <sideshowbarker>
meanwhile, I‚Äôm confused by a sentence at https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.lastindexof in the spec:

> The optional second argument _fromIndex_ defaults to the array's length minus one (i.e. the whole array is searched). If it is greater than or equal to the length of the array, the whole array will be searched. If it is less than +0ùîΩ, it is used as the offset from the end of the array to compute _fromIndex_. If the computed index is less than +0ùîΩ, -1ùîΩ is returned.

[10:20:51.0831] <sideshowbarker>
 * meanwhile, I‚Äôm confused by a sentence at https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.lastindexof in the spec:

> The optional second argument _fromIndex_ defaults to the array's length minus one (i.e. the whole array is searched). If it is greater than or equal to the length of the array, the whole array will be searched. If it is less than +0ùîΩ, it is used as the offset from the end of the array to compute _fromIndex_. If the computed index is less than +0ùîΩ, -1ùîΩ is returned.

[10:21:33.0122] <sideshowbarker>
The sentence I‚Äôm confused by is ‚ÄúIf it is less than +0ùîΩ, it is used as the offset from the end of the array to compute _fromIndex_‚Äù

[10:23:39.0134] <sideshowbarker>
What confuses me is that _fromIndex_ is an explicitly-specified value ‚Äî specified as the second argument to `Array.prototype.lastIndexOf()` ‚Äî so why does the spec then change to talking about it being computed?

[10:24:24.0400] <bakkot>
"to compute fromIndex" is a weird way of saying it

[10:24:27.0811] <sideshowbarker>
or in other words, what‚Äôs *‚Äúit‚Äù* in that sentence ‚Äî¬†if not _fromIndex_?

[10:24:33.0492] <bakkot>
it should be "to compute the position from which to start searching"

[10:24:39.0584] <sideshowbarker>
aha

[10:24:47.0414] <sideshowbarker>
OK yeah, then that makes sense, yeah

[10:26:36.0760] <bakkot>
Also it's not actually "from the end of the array" in the case of `lastIndexOf`

[10:27:39.0325] <bakkot>
actually, no, I guess it is

[10:28:28.0533] <bakkot>
anyway yeah these notes are bad

[10:28:31.0929] <bakkot>
`indexOf` has the same problem

[10:34:37.0809] <sideshowbarker>
yeah the corresponding MDN articles also have similar problems‚Ä¶ Trying now to figure out how to re-word them

[10:38:03.0549] <bakkot>
should probably be more like (for `lastIndexOf`)

"The optional second argument fromIndex specifies the offset from which to begin the search. If it is non-negative, it is an offset from the beginning of the array; if negative, an offset from the end. If the resulting offset is greater than or equal to the length of the array, the whole array will be searched. If it is less than 0, -1 is returned, i.e. the array is not searched."

[10:41:01.0599] <bakkot>
 * should probably be more like (for `lastIndexOf`)

"The optional second argument fromIndex specifies the offset from which to begin the search. If it is non-negative, it is an offset from the beginning of the array; if negative, an offset from the end. If the resulting offset is greater than or equal to the length of the array, the whole array will be searched. If it is less than 0, -1 is returned, i.e. the array is not searched. If it is not provided, it defaults to the last index of the array."

[10:41:10.0276] <bakkot>
 * should probably be more like (for `lastIndexOf`)

"The optional second argument fromIndex specifies the offset from which to begin the search. If it is non-negative, it is an offset from the beginning of the array; if negative, an offset from the end. If the resulting offset is greater than or equal to the length of the array, the whole array will be searched. If it is less than 0, -1 is returned, i.e. the array is not searched. If fromIndex is not provided, it defaults to the last index of the array."

[12:04:14.0036] <sideshowbarker>
bakkot: if you‚Äôre still around and you have a few minutes to review a related, PR: https://github.com/mdn/content/pull/11731

[12:05:18.0644] <sideshowbarker>
https://pr11731.content.dev.mdn.mozit.cloud/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf#_flaws has the preview of the rendered article with the PR changes incorporated

[12:05:44.0316] <sideshowbarker>
(and/or if anybody else is around and has time to review that)


2022-01-05
[18:49:14.0640] <sideshowbarker>
now I‚Äôm confused by the statement *‚Äúyou can think of a `WeakSet` as a special case of `WeakMap` where all the values are booleans‚Äù* in https://v8.dev/features/weak-references

[18:49:34.0442] <sideshowbarker>
Mathieu Hofman: ‚¨ÜÔ∏è

[18:51:25.0108] <sideshowbarker>
I see nothing in the spec for `WeakSet` at https://tc39.es/ecma262/multipage/keyed-collections.html#sec-weakset-objects about the values being restricted to being booleans

[18:58:24.0893] <sideshowbarker>
or is that _‚Äúyou can think of a WeakSet as a special case of WeakMap where all the values are booleans‚Äù_ statement just an odd way of saying you can think of a set as a map that only has keys without values?

[18:58:38.0797] <sideshowbarker>
 * or is that _‚Äúyou can think of a WeakSet as a special case of WeakMap where all the values are booleans‚Äù_ statement just an odd way of saying you can think of a set as a map that only has keys without values?

[19:04:51.0478] <sideshowbarker>
‚Ä¶and so, further in https://v8.dev/features/weak-references, I‚Äôm confused by the statement *‚Äúadding an object as a key to a `WeakMap` or `WeakSet` doesn‚Äôt prevent it from being garbage-collected‚Äù* ‚Äî which makes sense for a `WeakMap` but does not seem to make sense for a `WeakSet`, since a `WeakSet` doesn‚Äôt have keys

[19:07:49.0656] <sideshowbarker>
And then there‚Äôs *A JavaScript `WeakMap` is not really weak: it actually refers strongly to its contents as long as the key is alive* ‚Äî¬†which also makes sense just fine but would not seem to make sense for a `WeakSet`

[19:08:34.0637] <Mathieu Hofman>
It's like if WeakSet only had keys, no values

[19:09:11.0361] <sideshowbarker>
ok

[19:11:18.0553] <sideshowbarker>
I guess I‚Äôll try writing up a concrete patch myself for the MDN `WeakMap` and `WeakSet` docs to make them accurate ‚Äî and then to add the clarification about why they are not enumerated

[19:22:56.0962] <Mathieu Hofman>
I think the important part is that `WeakMap` and `WeakRef` provide orthogonal features.

WeakMap allows associating data to objects in a way that doesn't prevent the object keys from being collected, even if the values in the weak map reference the keys. However, WeakMap doesn't allow observing the liveness of the keys, which is why it doesn't allow enumeration.

WeakRef, being a real weak reference, allows to directly observe the liveness of an object. However you cannot build a `WeakMap` from `WeakRef` and `Map`, as that would prevent collection of cycles.

You could combine WeakRef and WeakMap to build an IterableWeakMap which allows enumeration. See https://github.com/tc39/proposal-weakrefs/#iterable-weakmaps

[12:31:54.0112] <devsnek>
bakkot: have you seen deepgram api? i have no idea how good it is but it looks like its very intentionally designed for the kind of thing your note taking bot does

[12:36:45.0400] <bakkot>
I have not, but that does look good

[12:36:59.0249] <bakkot>
I'll try it out if I find myself with a free evening one of these days

[12:37:33.0078] <bakkot>
Claims lower latency than google's STT, which would be very nice

[13:24:06.0781] <devsnek>
whelp i couldn't get it to work with my discord transcription bot, with either the raw ws or the sdk. it seems like the websocket never gets to the open state. i'm probably doing something wrong though.


2022-01-06
[16:40:33.0421] <sachag>
hi everybody! I hope this is the right place, but I have a small request for help

[16:40:48.0103] <sachag>
I run the yearly State of JavaScript surveys (latest edition: https://2020.stateofjs.com/)

[16:41:55.0269] <sachag>
I am currently working on the questions for the next edition, and I would love to involve TC39 more. For example, maybe there are questions the survey could ask that would help provide useful data for TC39 members?

[16:42:09.0011] <sachag>
there's an open GitHub thread here: https://github.com/StateOfJS/Monorepo/issues/56

[16:42:17.0221] <sachag>
or you can just DM me with your feedback/questions

[22:51:51.0569] <Ashley Claymore>
> <@sachag:matrix.org> hi everybody! I hope this is the right place, but I have a small request for help

Welcome! üëãüèª

[22:52:18.0658] <Ashley Claymore>
* > <@sachag:matrix.org> hi everybody! I hope this is the right place, but I have a small request for help

Welcome! üëãüèª

[23:08:54.0533] <ryzokuken>
Hi sachag, this is awesome!

[23:11:01.0886] <ryzokuken>
I think the best people for this would be the folks involved in the monthly research calls we have. I see the next one is on the 27th.

[23:11:49.0382] <ryzokuken>
yulia: do you think it'd be a good idea to include this on the agenda for the next one?

[00:44:57.0903] <yulia>
sachag ryzokuken yes this sounds like a good idea -- it may also be great to have you stop by in our research call

[01:35:54.0016] <sachag>
> <@usharma:igalia.com> I think the best people for this would be the folks involved in the monthly research calls we have. I see the next one is on the 27th.

that'd be great! the survey will most likely go out before then (it's supposed to be the 2021 survey so it's already late as it is‚Ä¶) but the feedback can be useful for the next edition

[01:36:09.0367] <sachag>
I'd also be happy to give you access to early results if that's helpful

[05:29:07.0331] <yulia>
sachag: likely you already did all the work for this years survey, but we can get together and have a special call also with felienne

[05:29:24.0687] <yulia>
and prepare for next year regarding what questions would be interesting


2022-01-10
[18:59:30.0269] <bakkot>
emscripten is pretty good now it turns out

[19:01:21.0931] <bakkot>
spent the weekend hacking together wasm/typescript bindings for z3 (the smt solver) and once I figured out how to deal with threads properly it all just worked

[19:02:32.0893] <bakkot>
js could definitely do with better multithreading primitives though

[19:12:19.0094] <Jack Works>
Like the shared structs proposal? 

