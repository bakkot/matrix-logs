2022-10-01
[21:11:49.0235] <ljharb>
i think the Array.of behavior is ideal - it’s always Array unless you’re subclassing or doing something unreasonable, including when destructured. Sticking to purity is how you get the Promise statics, which break when you do the idiomatic thing and destructure them.

[22:34:23.0097] <bakkot>
the Array behavior seems kind of odd because it's not actually helpful for a subclass - if the subclass is relying on `Subclass.of(x)` working, then it probably also expects `[x].map(Subclass.of)` to work, not to make a base Array

[22:34:30.0247] <bakkot>
so if you're subclassing you're gonna have to override anyway

[22:34:38.0067] <bakkot>
at which point, why bother looking at the receiver at all?

[22:34:50.0775] <bakkot>
 * the Array behavior seems kind of odd because it's not actually helpful for a subclass - if the subclass is relying on `Subclass.of(x)` working, then it probably also expects `[x].map(Subclass.of)` to work, not to make a base Array

[22:35:04.0558] <bakkot>
 * at which point, why bother having `of` look at the receiver at all?

[22:35:46.0805] <bakkot>
(specifically, the Array behavior seems kind of odd relative to the simpler option of just always making a base Array)


2022-10-02
[19:19:27.0277] <Jack Works>
> <@nicolo-ribaudo:matrix.org> Being able to use the method without a receiver is nice though, because I can do `const { of } = Array` and then directly use it (for the people that don't trust "other code" to not mess with built-ins)

I believe these people are minority. Most devs won't do that 

[14:21:27.0840] <ljharb>
in my experience, i think most devs will do that

[16:11:56.0895] <snek>
i've never seen anyone except tc39 delegates and nodejs contributors do that

[16:12:04.0227] <snek>
 * i've never seen anyone except tc39 delegates and nodejs contributors do that


2022-10-03
[22:19:43.0919] <littledan>
Maybe the version without the cute destructuring use is a little more popular?


2022-10-05
[09:34:47.0091] <ljharb>
i mean, the airbnb style code tends to recommend that, so i'm not sure why you'd not have seen it more broadly

[09:35:03.0762] <ljharb>
certainly nobody outside that group will do it for robustness reasons tho :-)

[13:10:04.0634] <ptomato>
jmdyck: do you have any follow up on https://github.com/tc39/ecma262/pull/2781#discussion_r981535579? I can join the editor call if it's needed today; just give me a bit of advance notice

[13:13:23.0591] <ptomato>
I will add the assertion there if it really has to be there, but I'd prefer that it be part of the task of specifying the web reality of code like `Date.UTC(NaN, NaN)` and I'd prefer not to block this PR on that

[14:29:43.0596] <jmdyck>
ptomato: I responded in the PR.


2022-10-11
[15:15:57.0649] <shu>
we might've accidentally made template literal arrays eternal again?

[15:16:44.0165] <shu>
we (chrome) recently discovered the note for [[TemplateMap]] in https://tc39.es/ecma262/#table-realm-record-fields is not true, because, well, WeakMaps and WeakRefs exist

[15:44:23.0294] <Ashley Claymore>
It seems to just not be true general. The array could still be reachable by anything live having a reference to it. The array can be passed around. Unless it means the literal accessing of the [[array]] field rather than the value?

[15:45:34.0544] <Ashley Claymore>
* It seems to just not be true in general. The array could still be reachable by anything live having a reference to it. The array can be passed around. Unless it means the literal accessing of the [[array]] field rather than the value?

[15:45:35.0790] <shu>
good point, i think that note is probably in general wrong

[15:46:04.0832] <shu>
but the original intention was assuming no live strong references to the template array, we _could_ collect it if the parse node was no longer reachable

[15:47:59.0188] <Ashley Claymore>
That seems OK? Even if the array is in a WeakRef. Or is there a risk to making that collection observable?

[15:48:07.0126] <shu>
but it is not in fact unobservable to collect them, because of weakrefs

[15:48:50.0782] <shu>
i think we should clarify that note because it's saying a collecting implementation strategy is allowed because of unobservability, which is false

[15:49:13.0749] <shu>
maybe we don't need to say anything more than "it's observable in weak collections and weakrefs and that's fine"

[15:50:43.0003] <shu>
it's also not very clear to me what a Parse Node becoming unreachable means

[15:51:01.0188] <shu>
now that we talk about liveness for other things in the spec, we should give these the same treatment

[15:51:01.0328] <Ashley Claymore>
When can parse nodes be collected? Eval and script tags?

[15:51:20.0206] <shu>
beats me!

[15:51:26.0084] <shu>
they're technically spec fiction

[15:51:51.0402] <shu>
oh no, maybe not, because functions hold on to them?

[16:05:08.0331] <bakkot>
yeah, functions hold on to them

[16:05:27.0142] <bakkot>
and that's how you'd normally re-manifest it: `` () => tag`foo` `` or whatever

[16:05:35.0105] <bakkot>
 * and that's how you'd normally re-manifest it: ``() => tag`foo``` or whatever

[16:05:47.0999] <bakkot>
 * and that's how you'd normally re-manifest it: `` () => tag`foo` `` or whatever

[16:10:18.0506] <shu>
but the only way we would collect them is if the toplevel Script or Module that has the root Parse Node itself becomes unreachable at some point

[16:10:27.0696] <shu>
and that i guess is currently up to the host

[16:41:06.0174] <bakkot>
the Script is not reachable from code, from the POV of the spec

[16:41:40.0156] <bakkot>
like if you just have `` tag`foo` `` in your program, not in a closure, then after the main body of the script runs you can collect the array for that template

[16:41:44.0004] <bakkot>
(ignoring WeakRefs, and assuming `tag` doesn't create a longer-lived reference)

[16:41:53.0421] <bakkot>
 * (ignoring WeakRefs, and assuming `tag` doesn't create a longer-lived reference)

[16:43:53.0851] <shu>
isn't the entry point to parse a script from the host though?

[16:45:32.0464] <shu>
anyway that part isn't so important

[16:46:31.0020] <shu>
we should say that the liveness of the template array literal is tied to the liveness of the Parse Node, which may be observed by weak collections and weak refs


2022-10-14
[20:12:57.0106] <Domenic>
rbuckton: I'm trying to figure out what's included and what's not included in proposal-explicit-resource-management with regards to async resources. There's still `@@disposeAsync`, but... no syntactic support for calling it?? Is that right?

[20:14:09.0693] <Domenic>
I very much appreciate the analysis of web platform & Node.js objects BTW

[02:39:12.0457] <nicolo-ribaudo>
Does ecmarkup support something like `break;`?

Or in order to do this:
```
1. Let _found_ be *null*.
2. For each Record _x_ of _y_, do
   1. If ..., then
      1. Set _found_ to _x_.
      2. Break.
```

Do I have to manually iterate over y?
```
1. Let _found_ be *null*.
2. Let _len_ be the length of _y_.
3. Let _i_ be 0.
4. Let _stop_ be *false*.
2. While _i_ < _len_ and _stop_ is *false*, do
   1. If ..., then
      1. Set _found_ to _x_.
      2. Set _stop_ to *true*.
   2. Set _i_ to _i_ + 1.
```


[03:00:57.0229] <Jack Works>
```
1. Let _wrapperList_ be a List of the same length with _y_ whose each element _O_ is ! OrdinaryObjectCreate(*null*, « [[WrappedSpecValue]] ») and _O_.[[WrappedSpecValue]] has been set to the coresponding value in _y_ in _y_'s order.
2. Let _finder_ be a new Abstract Closure with parameters (_currentValue_) that captures ... and performs the following steps when called:
    1. If ..., then
        1. Return *true*.
    2. Return *false*.
3. Let _finderF_ be CreateBuiltinFunction(_finder_, 1, "", « »).
4. Let _foundResult_ be ! Call(%Array.prototype.find%, ! CreateArrayFromList(_wrapperList_), « _finderF_ »).
5. If _foundResult_ is *undefined*, then
    1. ...
6. Let _matched_ be _foundResult_.[[WrappedSpecValue]].
```

Just a joke LOL

[05:18:52.0678] <sachag>
hi all! just a quick message to let you know that I've started work on the 2022 edition of the State of JS survey

[05:19:02.0357] <sachag>
there's an open GitHub thread to collect feedback here: https://github.com/Devographics/surveys/issues/47

[07:27:56.0360] <littledan>
Thanks for reaching out sachag!

[08:27:54.0312] <bakkot>
nicolo-ribaudo: it does not support `break`. easiest thing in your case is probably

```
1. Let _found_ be *null*.
1. For each Record _x_ of _y_, do
   1. If _found_ is *null* and ..., then
      1. Set _found_ to _x_.
```
or similar

[08:28:16.0901] <bakkot>
though you _can_ early exit AOs with `Return` so an alternative is to factor out an AO, if it makes sense to do so in your case

[08:40:07.0152] <annevk>
no KitKats for you

[14:58:56.0432] <rbuckton>
> <@domenicdenicola:matrix.org> rbuckton: I'm trying to figure out what's included and what's not included in proposal-explicit-resource-management with regards to async resources. There's still `@@disposeAsync`, but... no syntactic support for calling it?? Is that right?

For now, yes. Syntactic support is still planned, but it was suggested that we reduce the scope of the proposal in an effort to reach Stage 3. Syntactic async dispose is still under debate due to concerns about the implicit `await` that is introduced. See https://github.com/tc39/proposal-explicit-resource-management/issues/101 for the current status of that issue.


2022-10-15
[01:33:43.0439] <Domenic>
rbuckton: Got it. That's unfortunate. In that case, I think it'd be better to remove all async dispose stuff, as there's no incentive for at least the web platform to add a bunch of aliases/wrappers without syntax support.

[11:11:52.0127] <snek>
reading this really makes we had some way to make first class functions call locations. https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md

[11:12:01.0773] <snek>
currently you can only do that for tagged templates :(

[11:12:19.0893] <snek>
 * reading this really makes we had some way to make first class functions call locations. https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md


2022-10-16
[09:42:53.0108] <Jack Works>
> first class functions call locations

[09:42:54.0933] <Jack Works>
what is that?

[10:06:06.0391] <nicolo-ribaudo>
Maybe something like https://astexplorer.net/#/gist/08ef948999a34f5e37da8cf9ca9c38ff/46948e5f05780b6f56789736aa0822f841a51f79 (output in bottom right), even if I'm doing it for JSX and not for calls, where I'm passing an object stored in a top-level variable to every root JSX element, so that when it's rendered multiple times I know if it was generated by the same source code

[10:06:29.0767] <nicolo-ribaudo>
> <@jackworks:matrix.org> what is that?

 * Maybe something like https://astexplorer.net/#/gist/08ef948999a34f5e37da8cf9ca9c38ff/46948e5f05780b6f56789736aa0822f841a51f79 (output in bottom right), even if I'm doing it for JSX and not for calls, where I'm passing an object stored in a top-level variable to every root JSX element, so that when it's rendered multiple times I know if it was generated by the same source code

[10:20:24.0268] <Jack Works>
Interesting 🤔

[10:26:30.0908] <Luca Casonato>
I have sooo many use cases for stuff like this. But most of them are probably rather confusing because they rely on this implicit source location state which I think is very non obvious to beginners. Not sure how I feel about it yet

[10:26:46.0802] <Luca Casonato>
* I have sooo many use cases for stuff like this. But most of them are probably rather confusing because they rely on this implicit source location state which I think is very non obvious to beginners. Not sure how I feel about it yet

[10:31:35.0308] <nicolo-ribaudo>
`typeof arguments.callLocationToken === "symbol"` 😎

[10:31:57.0697] <nicolo-ribaudo>
 * `typeof arguments.callLocationSymbol === "symbol"` 😎

[10:32:13.0379] <nicolo-ribaudo>
 * `typeof arguments.callLocationToken === "symbol"` 😎

[10:42:08.0409] <Jack Works>
😂

[10:42:33.0183] <Jack Works>
arguments.caller

[10:42:52.0729] <Jack Works>
* argument.callee

[10:42:59.0619] <Jack Works>
* argument.caller

[10:43:09.0488] <Jack Works>
* arguments.caller


2022-10-17
[20:13:03.0157] <Justin Ridgewell>
I had a similar thought reading it. It seems like it make it possible to use any hooks in conditions codepaths. But, it’d only work if the component directly calls the hook, any indirection (like a custom hook) and we’d need to know the call locations if everything in the stack to differentiate.

[21:45:24.0270] <Ashley Claymore>
being able to useContext conditionally is a nice follow on, and makes sense that the context can serve as the tracking marker.  Not being able to use{State,Effect} conditionally still seems fine, as conditional state is a bit like having a class where the code `delete`s a field while its not using it instead of setting it to `undefined`

[21:46:30.0357] <Ashley Claymore>
the choice to mutate the promise object rather than require it to be memoized surprised me, considering react is usually all about immutability. 

[21:46:54.0466] <Ashley Claymore>
 * the choice to mutate the promise object rather than require it to be memoized surprised me, considering react is usually all about immutability. 

[06:50:32.0298] <littledan>
> <@domenicdenicola:matrix.org> rbuckton: Got it. That's unfortunate. In that case, I think it'd be better to remove all async dispose stuff, as there's no incentive for at least the web platform to add a bunch of aliases/wrappers without syntax support.

The rationale for the async dispose stuff in the web platform would be something like:
- This solves the confusion where you don't know whether a disposal is something you need to wait for, by sorting things into two different names which aren't conflated by default
- The AsyncDisposeStack library helps compose these, making this protocol directly useful

[06:50:46.0563] <littledan>
Domenic: I don't fully understand how important it is to correct the current conflation that the web platform does (where the same method name is used for both sync and async disposal). If we don't add add the async disposal protocol, we'd have to decide whether web platform objects which have a logically asynchronous disposal should implement Symbol.dispose anyway (at the risk that some usages of these disposals should wait for the "commit" to complete, but the syntax does not provide this). How do you think the web platform should answer this question?

[06:51:04.0095] <littledan>
(also a question for annevk :)

[07:10:08.0922] <annevk>
littledan: I'd need more context to be useful. I might have read something about this at some point, but I forgot :-)

[07:34:15.0149] <littledan>
You might start at https://github.com/tc39/proposal-explicit-resource-management#relation-to-dom-apis (and earlier in that doc) and https://github.com/tc39/proposal-explicit-resource-management/issues/91

[07:34:51.0516] <littledan>
IMO the protocol itself and web platform implementation of it is a huge thing about this proposal's value, and would be worth it to add even if we didn't have the syntax

[07:38:46.0367] <littledan>
in particular, I think composing disposables is a big thing, and it will be useful for frameworks to be able to tie into a common construct for this (probably this assertion should be validated with actual framework authors...)

[07:39:44.0406] <littledan>
I do think we need a strong web platform review and integration plan before this goes to Stage 3

[07:40:16.0681] <littledan>
 * I do think we need a strong web platform review and roughly agreed-on integration plan before this goes to Stage 3

[07:42:10.0400] <annevk>
Interesting, we did talk about this at some point. For addEventListener(), is there some way dispose could integrate with AbortSignal instead?

[07:42:39.0054] <annevk>
Perhaps it invokes AbortController's abort(). Which then does a bunch of cleanup.

[07:42:59.0681] <littledan>
yeah, I guess this is an addition I'd make to the integration plan above, that disposing an AbortController would abort it.

[07:43:30.0926] <littledan>
(my intuitions here are largely based on a conversation I had with wycats)

[07:46:21.0598] <annevk>
I guess in general I wonder how much of this can be done through signals instead. I've been kinda seeing that as our "cleanup API".

[07:46:44.0618] <littledan>
what do you mean by signals?

[07:47:06.0206] <annevk>
https://dom.spec.whatwg.org/#aborting-ongoing-activities

[07:47:19.0064] <littledan>
oh AbortSignals

[07:48:08.0579] <annevk>
I call them signals as they're somewhat more general-purpose these days (and that's how the dictionary member is called, well in the singular)

[07:48:27.0484] <annevk>
Though the documentation doesn't reflect that terribly well

[07:48:34.0504] <littledan>
makes sense, the term signal is just a bit overloaded in the ecosystem...

[07:49:39.0611] <littledan>
yeah I guess my intuition is that a signal is a more flexible thing in the same space and a bit less convenient, which is why I thought that Symbol.dispose would generalize the set of things that you can abort

[07:49:41.0556] <annevk>
As in, do we want Worker's terminate() to be pluggable in some way or should Worker just take a signal

[07:50:13.0055] <littledan>
it's sort of convenient to just call the method directly on the thing, rather than keeping around some other object

[07:50:18.0579] <littledan>
so... you might want both versions

[07:50:40.0803] <littledan>
(not extremely satisifying, the duplication)

[07:50:48.0191] <littledan>
 * (not extremely satisifying, the duplication)

[07:51:01.0294] <annevk>
Yeah maybe, exploring that seems worthwhile as part of stage 2-3

[07:51:48.0795] <littledan>
yeah we could really use more WHATWG/DOM input here. I'm glad that Ron got this started with a proposal but we need more conversation here.

