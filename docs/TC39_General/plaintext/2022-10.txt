2022-10-01
[21:11:49.0235] <ljharb>
i think the Array.of behavior is ideal - it’s always Array unless you’re subclassing or doing something unreasonable, including when destructured. Sticking to purity is how you get the Promise statics, which break when you do the idiomatic thing and destructure them.

[22:34:23.0097] <bakkot>
the Array behavior seems kind of odd because it's not actually helpful for a subclass - if the subclass is relying on `Subclass.of(x)` working, then it probably also expects `[x].map(Subclass.of)` to work, not to make a base Array

[22:34:30.0247] <bakkot>
so if you're subclassing you're gonna have to override anyway

[22:34:38.0067] <bakkot>
at which point, why bother looking at the receiver at all?

[22:34:50.0775] <bakkot>
 * the Array behavior seems kind of odd because it's not actually helpful for a subclass - if the subclass is relying on `Subclass.of(x)` working, then it probably also expects `[x].map(Subclass.of)` to work, not to make a base Array

[22:35:04.0558] <bakkot>
 * at which point, why bother having `of` look at the receiver at all?

[22:35:46.0805] <bakkot>
(specifically, the Array behavior seems kind of odd relative to the simpler option of just always making a base Array)


2022-10-02
[19:19:27.0277] <Jack Works>
> <@nicolo-ribaudo:matrix.org> Being able to use the method without a receiver is nice though, because I can do `const { of } = Array` and then directly use it (for the people that don't trust "other code" to not mess with built-ins)

I believe these people are minority. Most devs won't do that 

[14:21:27.0840] <ljharb>
in my experience, i think most devs will do that

[16:11:56.0895] <snek>
i've never seen anyone except tc39 delegates and nodejs contributors do that

[16:12:04.0227] <snek>
 * i've never seen anyone except tc39 delegates and nodejs contributors do that


2022-10-03
[22:19:43.0919] <littledan>
Maybe the version without the cute destructuring use is a little more popular?


2022-10-05
[09:34:47.0091] <ljharb>
i mean, the airbnb style code tends to recommend that, so i'm not sure why you'd not have seen it more broadly

[09:35:03.0762] <ljharb>
certainly nobody outside that group will do it for robustness reasons tho :-)

[13:10:04.0634] <ptomato>
jmdyck: do you have any follow up on https://github.com/tc39/ecma262/pull/2781#discussion_r981535579? I can join the editor call if it's needed today; just give me a bit of advance notice

[13:13:23.0591] <ptomato>
I will add the assertion there if it really has to be there, but I'd prefer that it be part of the task of specifying the web reality of code like `Date.UTC(NaN, NaN)` and I'd prefer not to block this PR on that

[14:29:43.0596] <jmdyck>
ptomato: I responded in the PR.


2022-10-11
[15:15:57.0649] <shu>
we might've accidentally made template literal arrays eternal again?

[15:16:44.0165] <shu>
we (chrome) recently discovered the note for [[TemplateMap]] in https://tc39.es/ecma262/#table-realm-record-fields is not true, because, well, WeakMaps and WeakRefs exist

[15:44:23.0294] <Ashley Claymore>
It seems to just not be true general. The array could still be reachable by anything live having a reference to it. The array can be passed around. Unless it means the literal accessing of the [[array]] field rather than the value?

[15:45:34.0544] <Ashley Claymore>
* It seems to just not be true in general. The array could still be reachable by anything live having a reference to it. The array can be passed around. Unless it means the literal accessing of the [[array]] field rather than the value?

[15:45:35.0790] <shu>
good point, i think that note is probably in general wrong

[15:46:04.0832] <shu>
but the original intention was assuming no live strong references to the template array, we _could_ collect it if the parse node was no longer reachable

[15:47:59.0188] <Ashley Claymore>
That seems OK? Even if the array is in a WeakRef. Or is there a risk to making that collection observable?

[15:48:07.0126] <shu>
but it is not in fact unobservable to collect them, because of weakrefs

[15:48:50.0782] <shu>
i think we should clarify that note because it's saying a collecting implementation strategy is allowed because of unobservability, which is false

[15:49:13.0749] <shu>
maybe we don't need to say anything more than "it's observable in weak collections and weakrefs and that's fine"

[15:50:43.0003] <shu>
it's also not very clear to me what a Parse Node becoming unreachable means

[15:51:01.0188] <shu>
now that we talk about liveness for other things in the spec, we should give these the same treatment

[15:51:01.0328] <Ashley Claymore>
When can parse nodes be collected? Eval and script tags?

[15:51:20.0206] <shu>
beats me!

[15:51:26.0084] <shu>
they're technically spec fiction

[15:51:51.0402] <shu>
oh no, maybe not, because functions hold on to them?

[16:05:08.0331] <bakkot>
yeah, functions hold on to them

[16:05:27.0142] <bakkot>
and that's how you'd normally re-manifest it: `` () => tag`foo` `` or whatever

[16:05:35.0105] <bakkot>
 * and that's how you'd normally re-manifest it: ``() => tag`foo``` or whatever

[16:05:47.0999] <bakkot>
 * and that's how you'd normally re-manifest it: `` () => tag`foo` `` or whatever

[16:10:18.0506] <shu>
but the only way we would collect them is if the toplevel Script or Module that has the root Parse Node itself becomes unreachable at some point

[16:10:27.0696] <shu>
and that i guess is currently up to the host

[16:41:06.0174] <bakkot>
the Script is not reachable from code, from the POV of the spec

[16:41:40.0156] <bakkot>
like if you just have `` tag`foo` `` in your program, not in a closure, then after the main body of the script runs you can collect the array for that template

[16:41:44.0004] <bakkot>
(ignoring WeakRefs, and assuming `tag` doesn't create a longer-lived reference)

[16:41:53.0421] <bakkot>
 * (ignoring WeakRefs, and assuming `tag` doesn't create a longer-lived reference)

[16:43:53.0851] <shu>
isn't the entry point to parse a script from the host though?

[16:45:32.0464] <shu>
anyway that part isn't so important

[16:46:31.0020] <shu>
we should say that the liveness of the template array literal is tied to the liveness of the Parse Node, which may be observed by weak collections and weak refs


2022-10-14
[20:12:57.0106] <Domenic>
rbuckton: I'm trying to figure out what's included and what's not included in proposal-explicit-resource-management with regards to async resources. There's still `@@disposeAsync`, but... no syntactic support for calling it?? Is that right?

[20:14:09.0693] <Domenic>
I very much appreciate the analysis of web platform & Node.js objects BTW

[02:39:12.0457] <nicolo-ribaudo>
Does ecmarkup support something like `break;`?

Or in order to do this:
```
1. Let _found_ be *null*.
2. For each Record _x_ of _y_, do
   1. If ..., then
      1. Set _found_ to _x_.
      2. Break.
```

Do I have to manually iterate over y?
```
1. Let _found_ be *null*.
2. Let _len_ be the length of _y_.
3. Let _i_ be 0.
4. Let _stop_ be *false*.
2. While _i_ < _len_ and _stop_ is *false*, do
   1. If ..., then
      1. Set _found_ to _x_.
      2. Set _stop_ to *true*.
   2. Set _i_ to _i_ + 1.
```


[03:00:57.0229] <Jack Works>
```
1. Let _wrapperList_ be a List of the same length with _y_ whose each element _O_ is ! OrdinaryObjectCreate(*null*, « [[WrappedSpecValue]] ») and _O_.[[WrappedSpecValue]] has been set to the coresponding value in _y_ in _y_'s order.
2. Let _finder_ be a new Abstract Closure with parameters (_currentValue_) that captures ... and performs the following steps when called:
    1. If ..., then
        1. Return *true*.
    2. Return *false*.
3. Let _finderF_ be CreateBuiltinFunction(_finder_, 1, "", « »).
4. Let _foundResult_ be ! Call(%Array.prototype.find%, ! CreateArrayFromList(_wrapperList_), « _finderF_ »).
5. If _foundResult_ is *undefined*, then
    1. ...
6. Let _matched_ be _foundResult_.[[WrappedSpecValue]].
```

Just a joke LOL

[05:18:52.0678] <sachag>
hi all! just a quick message to let you know that I've started work on the 2022 edition of the State of JS survey

[05:19:02.0357] <sachag>
there's an open GitHub thread to collect feedback here: https://github.com/Devographics/surveys/issues/47

[07:27:56.0360] <littledan>
Thanks for reaching out sachag!

[08:27:54.0312] <bakkot>
nicolo-ribaudo: it does not support `break`. easiest thing in your case is probably

```
1. Let _found_ be *null*.
1. For each Record _x_ of _y_, do
   1. If _found_ is *null* and ..., then
      1. Set _found_ to _x_.
```
or similar

[08:28:16.0901] <bakkot>
though you _can_ early exit AOs with `Return` so an alternative is to factor out an AO, if it makes sense to do so in your case

[08:40:07.0152] <annevk>
no KitKats for you

[14:58:56.0432] <rbuckton>
> <@domenicdenicola:matrix.org> rbuckton: I'm trying to figure out what's included and what's not included in proposal-explicit-resource-management with regards to async resources. There's still `@@disposeAsync`, but... no syntactic support for calling it?? Is that right?

For now, yes. Syntactic support is still planned, but it was suggested that we reduce the scope of the proposal in an effort to reach Stage 3. Syntactic async dispose is still under debate due to concerns about the implicit `await` that is introduced. See https://github.com/tc39/proposal-explicit-resource-management/issues/101 for the current status of that issue.


2022-10-15
[01:33:43.0439] <Domenic>
rbuckton: Got it. That's unfortunate. In that case, I think it'd be better to remove all async dispose stuff, as there's no incentive for at least the web platform to add a bunch of aliases/wrappers without syntax support.

[11:11:52.0127] <snek>
reading this really makes we had some way to make first class functions call locations. https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md

[11:12:01.0773] <snek>
currently you can only do that for tagged templates :(

[11:12:19.0893] <snek>
 * reading this really makes we had some way to make first class functions call locations. https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md


2022-10-16
[09:42:53.0108] <Jack Works>
> first class functions call locations

[09:42:54.0933] <Jack Works>
what is that?

[10:06:06.0391] <nicolo-ribaudo>
Maybe something like https://astexplorer.net/#/gist/08ef948999a34f5e37da8cf9ca9c38ff/46948e5f05780b6f56789736aa0822f841a51f79 (output in bottom right), even if I'm doing it for JSX and not for calls, where I'm passing an object stored in a top-level variable to every root JSX element, so that when it's rendered multiple times I know if it was generated by the same source code

[10:06:29.0767] <nicolo-ribaudo>
> <@jackworks:matrix.org> what is that?

 * Maybe something like https://astexplorer.net/#/gist/08ef948999a34f5e37da8cf9ca9c38ff/46948e5f05780b6f56789736aa0822f841a51f79 (output in bottom right), even if I'm doing it for JSX and not for calls, where I'm passing an object stored in a top-level variable to every root JSX element, so that when it's rendered multiple times I know if it was generated by the same source code

[10:20:24.0268] <Jack Works>
Interesting 🤔

