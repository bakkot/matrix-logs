2022-10-01
[21:11:49.0235] <ljharb>
i think the Array.of behavior is ideal - it’s always Array unless you’re subclassing or doing something unreasonable, including when destructured. Sticking to purity is how you get the Promise statics, which break when you do the idiomatic thing and destructure them.

[22:34:23.0097] <bakkot>
the Array behavior seems kind of odd because it's not actually helpful for a subclass - if the subclass is relying on `Subclass.of(x)` working, then it probably also expects `[x].map(Subclass.of)` to work, not to make a base Array

[22:34:30.0247] <bakkot>
so if you're subclassing you're gonna have to override anyway

[22:34:38.0067] <bakkot>
at which point, why bother looking at the receiver at all?

[22:34:50.0775] <bakkot>
 * the Array behavior seems kind of odd because it's not actually helpful for a subclass - if the subclass is relying on `Subclass.of(x)` working, then it probably also expects `[x].map(Subclass.of)` to work, not to make a base Array

[22:35:04.0558] <bakkot>
 * at which point, why bother having `of` look at the receiver at all?

[22:35:46.0805] <bakkot>
(specifically, the Array behavior seems kind of odd relative to the simpler option of just always making a base Array)


2022-10-02
[19:19:27.0277] <Jack Works>
> <@nicolo-ribaudo:matrix.org> Being able to use the method without a receiver is nice though, because I can do `const { of } = Array` and then directly use it (for the people that don't trust "other code" to not mess with built-ins)

I believe these people are minority. Most devs won't do that 

[14:21:27.0840] <ljharb>
in my experience, i think most devs will do that

[16:11:56.0895] <snek>
i've never seen anyone except tc39 delegates and nodejs contributors do that

[16:12:04.0227] <snek>
 * i've never seen anyone except tc39 delegates and nodejs contributors do that

