2022-10-01
[21:11:49.0235] <ljharb>
i think the Array.of behavior is ideal - it’s always Array unless you’re subclassing or doing something unreasonable, including when destructured. Sticking to purity is how you get the Promise statics, which break when you do the idiomatic thing and destructure them.

[22:34:23.0097] <bakkot>
the Array behavior seems kind of odd because it's not actually helpful for a subclass - if the subclass is relying on `Subclass.of(x)` working, then it probably also expects `[x].map(Subclass.of)` to work, not to make a base Array

[22:34:30.0247] <bakkot>
so if you're subclassing you're gonna have to override anyway

[22:34:38.0067] <bakkot>
at which point, why bother looking at the receiver at all?

[22:34:50.0775] <bakkot>
 * the Array behavior seems kind of odd because it's not actually helpful for a subclass - if the subclass is relying on `Subclass.of(x)` working, then it probably also expects `[x].map(Subclass.of)` to work, not to make a base Array

[22:35:04.0558] <bakkot>
 * at which point, why bother having `of` look at the receiver at all?

[22:35:46.0805] <bakkot>
(specifically, the Array behavior seems kind of odd relative to the simpler option of just always making a base Array)


2022-10-02
[19:19:27.0277] <Jack Works>
> <@nicolo-ribaudo:matrix.org> Being able to use the method without a receiver is nice though, because I can do `const { of } = Array` and then directly use it (for the people that don't trust "other code" to not mess with built-ins)

I believe these people are minority. Most devs won't do that 

[14:21:27.0840] <ljharb>
in my experience, i think most devs will do that

[16:11:56.0895] <snek>
i've never seen anyone except tc39 delegates and nodejs contributors do that

[16:12:04.0227] <snek>
 * i've never seen anyone except tc39 delegates and nodejs contributors do that


2022-10-03
[22:19:43.0919] <littledan>
Maybe the version without the cute destructuring use is a little more popular?


2022-10-05
[09:34:47.0091] <ljharb>
i mean, the airbnb style code tends to recommend that, so i'm not sure why you'd not have seen it more broadly

[09:35:03.0762] <ljharb>
certainly nobody outside that group will do it for robustness reasons tho :-)

[13:10:04.0634] <ptomato>
jmdyck: do you have any follow up on https://github.com/tc39/ecma262/pull/2781#discussion_r981535579? I can join the editor call if it's needed today; just give me a bit of advance notice

[13:13:23.0591] <ptomato>
I will add the assertion there if it really has to be there, but I'd prefer that it be part of the task of specifying the web reality of code like `Date.UTC(NaN, NaN)` and I'd prefer not to block this PR on that

[14:29:43.0596] <jmdyck>
ptomato: I responded in the PR.


2022-10-11
[15:15:57.0649] <shu>
we might've accidentally made template literal arrays eternal again?

[15:16:44.0165] <shu>
we (chrome) recently discovered the note for [[TemplateMap]] in https://tc39.es/ecma262/#table-realm-record-fields is not true, because, well, WeakMaps and WeakRefs exist

[15:44:23.0294] <Ashley Claymore>
It seems to just not be true general. The array could still be reachable by anything live having a reference to it. The array can be passed around. Unless it means the literal accessing of the [[array]] field rather than the value?

[15:45:34.0544] <Ashley Claymore>
* It seems to just not be true in general. The array could still be reachable by anything live having a reference to it. The array can be passed around. Unless it means the literal accessing of the [[array]] field rather than the value?

[15:45:35.0790] <shu>
good point, i think that note is probably in general wrong

[15:46:04.0832] <shu>
but the original intention was assuming no live strong references to the template array, we _could_ collect it if the parse node was no longer reachable

[15:47:59.0188] <Ashley Claymore>
That seems OK? Even if the array is in a WeakRef. Or is there a risk to making that collection observable?

[15:48:07.0126] <shu>
but it is not in fact unobservable to collect them, because of weakrefs

[15:48:50.0782] <shu>
i think we should clarify that note because it's saying a collecting implementation strategy is allowed because of unobservability, which is false

[15:49:13.0749] <shu>
maybe we don't need to say anything more than "it's observable in weak collections and weakrefs and that's fine"

[15:50:43.0003] <shu>
it's also not very clear to me what a Parse Node becoming unreachable means

[15:51:01.0188] <shu>
now that we talk about liveness for other things in the spec, we should give these the same treatment

[15:51:01.0328] <Ashley Claymore>
When can parse nodes be collected? Eval and script tags?

[15:51:20.0206] <shu>
beats me!

[15:51:26.0084] <shu>
they're technically spec fiction

[15:51:51.0402] <shu>
oh no, maybe not, because functions hold on to them?

[16:05:08.0331] <bakkot>
yeah, functions hold on to them

[16:05:27.0142] <bakkot>
and that's how you'd normally re-manifest it: `` () => tag`foo` `` or whatever

[16:05:35.0105] <bakkot>
 * and that's how you'd normally re-manifest it: ``() => tag`foo``` or whatever

[16:05:47.0999] <bakkot>
 * and that's how you'd normally re-manifest it: `` () => tag`foo` `` or whatever

[16:10:18.0506] <shu>
but the only way we would collect them is if the toplevel Script or Module that has the root Parse Node itself becomes unreachable at some point

[16:10:27.0696] <shu>
and that i guess is currently up to the host

[16:41:06.0174] <bakkot>
the Script is not reachable from code, from the POV of the spec

[16:41:40.0156] <bakkot>
like if you just have `` tag`foo` `` in your program, not in a closure, then after the main body of the script runs you can collect the array for that template

[16:41:44.0004] <bakkot>
(ignoring WeakRefs, and assuming `tag` doesn't create a longer-lived reference)

[16:41:53.0421] <bakkot>
 * (ignoring WeakRefs, and assuming `tag` doesn't create a longer-lived reference)

[16:43:53.0851] <shu>
isn't the entry point to parse a script from the host though?

