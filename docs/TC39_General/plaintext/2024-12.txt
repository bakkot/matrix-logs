2024-12-01
[17:39:23.0455] <nullvoxpopuli>
Anyone know how to update this site? https://tc39.es/proposal-decorators/ data seems behind

[19:52:36.0275] <bakkot>
nullvoxpopuli: all of the `tc39.es/proposal-whatever` sites are served from github pages from the corresponding github repo, in this case https://github.com/tc39/proposal-decorators

[19:52:39.0259] <bakkot>
so you could open an issue there

[19:53:33.0814] <bakkot>
or just send a PR to the gh-pages branch which replaces it with a meta redirect to the spec PR, I guess https://github.com/tc39/ecma262/pull/2417


2024-12-03
[21:01:57.0924] <David Alsh>
Hi all, new guy here! 

I'm entertaining the idea of opening a proposal but wanted to get a feeling on how the community feels about the concept before I commit a weekend to writing it out - haha. 

Generally, it's the concept of the incorporation of Rust-inspired callable macros

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe(push)]
  baz = undefined
}
```

While I know ECMAScript is not a compiled language, there are interesting use cases like;
- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular 
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:02:36.0297] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired callable macros

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe(push)]
  baz = undefined
}
```

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:03:55.0863] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired callable macros

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe(push)]
  baz = undefined
}
```

The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `@jsx()` or anything, I'm not opinionated here

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:05:02.0762] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired callable macros

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe(push)]
  baz = undefined
}
```

The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:07:05.0075] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired callable macros

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe]
  baz = undefined
}
```

The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:08:27.0765] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired callable macros. No macros would be shipped in ECMAScript, all macros would be defined by users as functions that take tokens and return valid ECMAScript.

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe]
  baz = undefined
}
```

The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:12:12.0696] <Ashley Claymore>
For the "create a getter/setter" example, that looks like it can be accomplished via a decorator https://github.com/tc39/proposal-decorators

[21:16:57.0299] <Ashley Claymore>
Hi and welcome btw üëãüèª 

[21:22:43.0841] <David Alsh>
Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;
- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc

```javascript
const vueComponent = {
  template: vue!(<div>Hello {data.world}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
```

[21:24:20.0592] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {data.world}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
```

[21:25:48.0976] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {data.world}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
```

[21:28:21.0106] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.

All macros would be defined by users as functions that take tokens and return valid ECMAScript.

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe]
  baz = undefined
}
```

The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:29:10.0070] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.

All macros would be defined by users, none defined in the language.

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe]
  baz = undefined
}
```

The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:31:51.0416] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {data.world}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
// Expands to
// const contents = { foo: 'bar' }
```

[21:34:16.0216] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {data.world}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
// Expands to
// const contents = { foo: 'bar' }
```
LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation

