2024-12-01
[17:39:23.0455] <nullvoxpopuli>
Anyone know how to update this site? https://tc39.es/proposal-decorators/ data seems behind

[19:52:36.0275] <bakkot>
nullvoxpopuli: all of the `tc39.es/proposal-whatever` sites are served from github pages from the corresponding github repo, in this case https://github.com/tc39/proposal-decorators

[19:52:39.0259] <bakkot>
so you could open an issue there

[19:53:33.0814] <bakkot>
or just send a PR to the gh-pages branch which replaces it with a meta redirect to the spec PR, I guess https://github.com/tc39/ecma262/pull/2417


2024-12-03
[21:01:57.0924] <David Alsh>
Hi all, new guy here! 

I'm entertaining the idea of opening a proposal but wanted to get a feeling on how the community feels about the concept before I commit a weekend to writing it out - haha. 

Generally, it's the concept of the incorporation of Rust-inspired callable macros

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe(push)]
  baz = undefined
}
```

While I know ECMAScript is not a compiled language, there are interesting use cases like;
- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular 
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:02:36.0297] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired callable macros

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe(push)]
  baz = undefined
}
```

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:03:55.0863] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired callable macros

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe(push)]
  baz = undefined
}
```

The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `@jsx()` or anything, I'm not opinionated here

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:05:02.0762] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired callable macros

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe(push)]
  baz = undefined
}
```

The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:07:05.0075] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired callable macros

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe]
  baz = undefined
}
```

The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:08:27.0765] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired callable macros. No macros would be shipped in ECMAScript, all macros would be defined by users as functions that take tokens and return valid ECMAScript.

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe]
  baz = undefined
}
```

The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:12:12.0696] <Ashley Claymore>
For the "create a getter/setter" example, that looks like it can be accomplished via a decorator https://github.com/tc39/proposal-decorators

[21:16:57.0299] <Ashley Claymore>
Hi and welcome btw üëãüèª 

[21:22:43.0841] <David Alsh>
Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;
- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc

```javascript
const vueComponent = {
  template: vue!(<div>Hello {data.world}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
```

[21:24:20.0592] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {data.world}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
```

[21:25:48.0976] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {data.world}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
```

[21:28:21.0106] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.

All macros would be defined by users as functions that take tokens and return valid ECMAScript.

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe]
  baz = undefined
}
```

The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:29:10.0070] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.

All macros would be defined by users, none defined in the language.

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe]
  baz = undefined
}
```

The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:31:51.0416] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {data.world}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
// Expands to
// const contents = { foo: 'bar' }
```

[21:34:16.0216] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {data.world}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
// Expands to
// const contents = { foo: 'bar' }
```
LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation

[21:36:23.0223] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {{data.world}}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
// Expands to
// const contents = { foo: 'bar' }
```

LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation

[21:41:15.0645] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {{data.world}}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
// Expands to
// const contents = { foo: 'bar' }
```

LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.

In the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:
- Web wasm frameworks [[1]](https://yew.rs/) [[2]](https://leptos.dev/)
- Native desktop frameworks [[1]](https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app) [[2]](https://iced.rs/)

[21:42:19.0644] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {{data.world}}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
// Expands to
// const contents = { foo: 'bar' }
```

LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.

In the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:

- Web wasm frameworks [\[1\]](https://yew.rs/) [\[2\]](https://leptos.dev/)
- Native desktop frameworks [\[1\]](https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app) [\[2\]](https://iced.rs/)

[21:57:55.0701] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc, probably v8) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {{data.world}}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
// Expands to
// const contents = { foo: 'bar' }
```

LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.

In the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:

- Web wasm frameworks [\[1\]](https://yew.rs/) [\[2\]](https://leptos.dev/)
- Native desktop frameworks [\[1\]](https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app) [\[2\]](https://iced.rs/)

[21:58:51.0375] <Ashley Claymore>
I am curious how things like auto-complete and refactoring work within Rust macros. These both sound easier for tooling to implement when the language extension is concrete, instead of being defined as a macro.

[22:21:11.0512] <David Alsh>
For autocomplete, the LSP expands the macro and uses the output
```javascript
const foo = add!(1, 1)
```
Would expand into
```javascript
const foo = 2
```
So consumers see it as a `number` rather than a macro. It simply replaces itself with the transformed result.

As for refactoring; when someone implements a macro, they parse "tokens" which they move around into the equivalent valid language syntax. 

The editor can unwind that to determine what to update - though there are some macros that are too complex and refactoring tools bail out.

Implementers can also throw during parsing, which bubbles up to the editor, showing errors in the correct place in the macro

[22:21:30.0686] <David Alsh>
 * For autocomplete, the LSP expands the macro and uses the output

```javascript
const foo = add!(1, 1)
```

Would expand into

```javascript
const foo = 2
```

So consumers see it as a `number` rather than a macro. It simply replaces itself with the transformed result.

As for refactoring; when someone implements a macro, they parse "tokens" which they move around into the equivalent valid language syntax.

The editor can unwind that to determine what to update - though there are some macros that are too complex and refactoring tools bail out.

Implementers can also throw during parsing, which bubbles up to the editor, showing errors in the correct place in the macro

[22:31:50.0199] <Ashley Claymore>
For auto-complete, when the macro is expanded, how is the IDE cursor position preserved?

[22:32:36.0884] <Ashley Claymore>
the position could expand to a much larger block of code 

[22:34:29.0276] <Ashley Claymore>
the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete 

[22:38:06.0853] <David Alsh>
> These both sound easier for tooling to implement when the language extension is concrete

Macros are more of a preprocessing step rather than dynamic functionality (like decorators) - but there's a chicken and egg problem. 

The best supported illustration of macros in tooling is the built-in transformation of jsx in TypeScript. There are many GitHub issues requesting to expand this to offer custom programmatic macros however it's has been deemed out of scope.

Attempts by other toolmakers to implement the functionality that macros offer have resulted in fragmented, brittle implementations (.vue files and .svelte files - custom tooling, editor plugins and poor support for test runners, linters, formatters, etc). 

Decorators also feel like an attempt at addressing the same problem albeit at runtime.

After spending some time in the Rust world, I personally feel that there is evidence that ES world shows a need for this type of functionality

[22:40:37.0041] <David Alsh>
> the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete 

It's likely that TypeScript would compile macros into TypeScript at compile time (and in the editor), where the emitted runtime code would be the static JavaScript equivalent 

[22:41:26.0548] <David Alsh>
 * > the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete

It's likely that TypeScript would compile macros into TypeScript at compile time (and in the editor), where the emitted runtime code would be the static JavaScript equivalent

That said, if they simply strip the types and leave macros to be evaluated at runtime, then perhaps type information would be an issue

[22:42:07.0899] <David Alsh>
 * > the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete

It's likely that TypeScript would compile macros into TypeScript at compile time (and in the editor, like they do with jsx), where the emitted runtime code would be the static JavaScript equivalent

That said, if they simply strip the types and leave macros to be evaluated at runtime, then perhaps type information would be an issue

[22:42:18.0701] <Ashley Claymore>
I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed

[22:43:03.0864] <Ashley Claymore>
Unlike with Rust macros where the compiler naturally understands how to execute Rust

[22:45:38.0773] <David Alsh>
> I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed

Haha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit. There are also options like [QuickJS](https://bellard.org/quickjs/) and [llrt](https://github.com/awslabs/llrt) for macros that don't use nodejs functionality

[22:46:41.0025] <David Alsh>
 * > I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed

Haha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit. There are also options like embedding Deno, [QuickJS](https://bellard.org/quickjs/) or [llrt](https://github.com/awslabs/llrt) for macros that don't use niche nodejs functionality 

[22:50:33.0217] <David Alsh>
 * > I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed

Haha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit (hundreds of millions of nodejs calls per second).
 
There are also options like embedding Deno, [QuickJS](https://bellard.org/quickjs/) or [llrt](https://github.com/awslabs/llrt) for macros that don't use niche nodejs functionality

[22:51:50.0383] <David Alsh>
Also, I really appreciate you entertaining this idea and asking such great questions üôÇ

[22:53:07.0967] <David Alsh>
> For auto-complete, when the macro is expanded, how is the IDE cursor position preserved?

If I get to the point where a proposal is actually on the cards, I will certainly dig deeper into how Rust does this to provide a clearer answer

[22:55:23.0177] <David Alsh>
 * > These both sound easier for tooling to implement when the language extension is concrete

Macros are more of a preprocessing step rather than dynamic functionality (like decorators) - but there's a chicken and egg problem.

The best supported illustration of macros in tooling is the built-in transformation of jsx in TypeScript. There are many GitHub issues requesting to expand this to offer custom programmatic macros however it's has been deemed out of scope.

Attempts by other toolmakers to implement the functionality that macros offer have resulted in fragmented, brittle implementations (.vue files and .svelte files - custom tooling, editor plugins and poor support for test runners, linters, formatters, etc).

Decorators also feel like an attempt at addressing the same problem albeit at runtime.

After spending some time in the Rust world, I personally feel that there is evidence that the ES world shows a need for this type of functionality

[23:06:37.0379] <David Alsh>
 * > I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed

Haha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit (hundreds of millions of nodejs calls per second).

There are also options like embedding Deno, [QuickJS](https://bellard.org/quickjs/) or [llrt](https://github.com/awslabs/llrt) for macros that don't use niche nodejs functionality

Alternatively, if macros are defined using a templating syntax (like callable macros in Rust) then an interpreter could be written (or taken directly from an existing JS engine) and run entirely in Rust [example](https://doc.rust-lang.org/book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming)

[23:08:52.0547] <David Alsh>
 * > I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed

Calling into Nodejs is not as fast as running Rust native code directly and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit (can do hundreds of millions of nodejs calls per second).

There are also options like embedding Deno, [QuickJS](https://bellard.org/quickjs/) or [llrt](https://github.com/awslabs/llrt) for macros that don't use niche nodejs functionality

If callable macros are defined using a templating syntax (like in Rust) then an interpreter could be written (or borrowed directly from an existing JS engine) and run entirely in Rust [example](https://doc.rust-lang.org/book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming)

[23:32:06.0686] <ljharb>
rust macros have some really unfortunate limitations tho - in particular, it seems they can't handle anywhere close to the level of expressiveness and dynamism i'd expect coming from JS

[08:58:28.0857] <ptomato>
there are two kinds of rust macros; for the cases where the normal macros aren't expressive enough, you can write a procedural macro to literally bypass the parser and operate on a stream of tokens from the lexer

[08:59:08.0856] <ptomato>
(and the JS equivalent of _that_ starts to sound like https://github.com/tc39/proposal-binary-ast)

[09:02:29.0670] <ljharb>
and even with that i still haven't been able to get what i want to do, done :-/ i'm sure it's a mix of lacking capability in both self and language

[09:03:22.0832] <snek>
what haven't you been able to do with proc macros?

[09:05:46.0664] <bakkot>
David Alsh: macros in the language mean moving complexity and build time from the developer's computer to the user's computer, which I think is very negative

[09:05:59.0577] <bakkot>
as a developer it's obviously appealing, but in terms of its effects on the world I think it would be very bad

[09:06:10.0720] <Luca Casonato>
Proc macros can generate arbitrary Rust code by executing arbitrary Rust code taking arbitrary lexer tokens as inputs. They are turing complete - there is nothing they can not do

[09:07:58.0443] <snek>
they can't properly attribute error locations :P

[09:08:08.0623] <Luca Casonato>
They can in nightly :D

[09:08:20.0627] <Michael Ficarra>
> <@lucacasonato:matrix.org> Proc macros can generate arbitrary Rust code by executing arbitrary Rust code taking arbitrary lexer tokens as inputs. They are turing complete - there is nothing they can not do

there's a ton of things that Turing machines cannot do

[09:09:12.0180] <Luca Casonato>
Sure. Then more accurately: they have all the same capabilities as any other Rust program (because they are a special kind of Rust program)

[09:09:56.0252] <ljharb>
then that probably means that rust's type system can't do what i want üôé‚Äç‚ôÇÔ∏è

[09:10:07.0062] <ljharb>
 * then that probably means that rust's type system can't do what i want :-p

[09:48:27.0292] <sirisian>
I started looking at code generation (like C#) before to see how it could function in JS and it has similar issues as it moves what might be build-time to the user's computer which as mentioned is contentious.

[13:01:03.0245] <James M Snell>
Hey all, just doing some sketching out on a proposal for a `Promise.lazy(fn)` API (https://github.com/jasnell/proposal-promise-lazy) ... the idea is to simplify a pattern that is currently possible to do with custom thenables with a fair amount of boilerplate. This is very early and not yet ready for in committee discussion but I'd like to invite folks to take a look at provide early feedback. I'll likely raise it for in-committee discussion for the next scheduled plenary

