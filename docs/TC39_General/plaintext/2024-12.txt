2024-12-01
[17:39:23.0455] <nullvoxpopuli>
Anyone know how to update this site? https://tc39.es/proposal-decorators/ data seems behind

[19:52:36.0275] <bakkot>
nullvoxpopuli: all of the `tc39.es/proposal-whatever` sites are served from github pages from the corresponding github repo, in this case https://github.com/tc39/proposal-decorators

[19:52:39.0259] <bakkot>
so you could open an issue there

[19:53:33.0814] <bakkot>
or just send a PR to the gh-pages branch which replaces it with a meta redirect to the spec PR, I guess https://github.com/tc39/ecma262/pull/2417


2024-12-03
[21:01:57.0924] <David Alsh>
Hi all, new guy here! 

I'm entertaining the idea of opening a proposal but wanted to get a feeling on how the community feels about the concept before I commit a weekend to writing it out - haha. 

Generally, it's the concept of the incorporation of Rust-inspired callable macros

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe(push)]
  baz = undefined
}
```

While I know ECMAScript is not a compiled language, there are interesting use cases like;
- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular 
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:02:36.0297] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired callable macros

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe(push)]
  baz = undefined
}
```

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:03:55.0863] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired callable macros

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe(push)]
  baz = undefined
}
```

The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `@jsx()` or anything, I'm not opinionated here

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:05:02.0762] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired callable macros

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe(push)]
  baz = undefined
}
```

The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:07:05.0075] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired callable macros

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe]
  baz = undefined
}
```

The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:08:27.0765] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired callable macros. No macros would be shipped in ECMAScript, all macros would be defined by users as functions that take tokens and return valid ECMAScript.

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe]
  baz = undefined
}
```

The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:12:12.0696] <Ashley Claymore>
For the "create a getter/setter" example, that looks like it can be accomplished via a decorator https://github.com/tc39/proposal-decorators

[21:16:57.0299] <Ashley Claymore>
Hi and welcome btw üëãüèª 

[21:22:43.0841] <David Alsh>
Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;
- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc

```javascript
const vueComponent = {
  template: vue!(<div>Hello {data.world}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
```

[21:24:20.0592] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {data.world}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
```

[21:25:48.0976] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {data.world}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
```

[21:28:21.0106] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.

All macros would be defined by users as functions that take tokens and return valid ECMAScript.

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe]
  baz = undefined
}
```

The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:29:10.0070] <David Alsh>
 * Hi all, new guy here!

I'm entertaining the idea of opening a proposal but wanted to get a sense on how the community feels about the concept before I commit a weekend to writing it out - haha.

Generally, it's the concept of the incorporation of Rust-inspired static macros. Macos are functions that take tokens and return static ECMAScript, similar to a template literal + eval however with LSP support and without the need for eval.

All macros would be defined by users, none defined in the language.

```javascript
// Parse tokens and generate React.createElement() calls
const Foo = () => jsx!(<div>Hello World</div>)

// Create a getter/setter for a property
class Bar {
  #[observe]
  baz = undefined
}
```

The syntax itself can be changed, I am just defaulting to Rust syntax for familiarity, but something like `jsx!()` could be `~jsx()` or anything (to avoid conflicts), I'm not opinionated here

While I know ECMAScript is not a compiled language, there are interesting use cases like;

- Enabling support for jsx/other templating languages without an external preprocessor/eval
- Macro annotations that facilitate more ergonomic mutation observability leading to more ergonomic syntax for frameworks like Vue/Angular
- A reduced need for custom compilers (ngc, .vue, .svelte)
- More ergonomic usage for tools like protobuf
- etc

This would also lead to support in preprocessors like TypeScript which _could_ statically compile macros - offering an interesting/novel hybrid macro system.

Any thoughts on the concept?

[21:31:51.0416] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {data.world}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
// Expands to
// const contents = { foo: 'bar' }
```

[21:34:16.0216] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {data.world}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
// Expands to
// const contents = { foo: 'bar' }
```
LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation

[21:36:23.0223] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {{data.world}}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
// Expands to
// const contents = { foo: 'bar' }
```

LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation

[21:41:15.0645] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {{data.world}}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
// Expands to
// const contents = { foo: 'bar' }
```

LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.

In the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:
- Web wasm frameworks [[1]](https://yew.rs/) [[2]](https://leptos.dev/)
- Native desktop frameworks [[1]](https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app) [[2]](https://iced.rs/)

[21:42:19.0644] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {{data.world}}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
// Expands to
// const contents = { foo: 'bar' }
```

LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.

In the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:

- Web wasm frameworks [\[1\]](https://yew.rs/) [\[2\]](https://leptos.dev/)
- Native desktop frameworks [\[1\]](https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app) [\[2\]](https://iced.rs/)

[21:57:55.0701] <David Alsh>
 * Yes, I do agree that this idea shares utility with decorators however, due to the static nature of macros (accept tokens, return ecmascript), it expands the concept in various ways, like;

- Opening a path for preprocessors (like TypeScript, swc, probably v8) to do AoT compilation leading to applications being faster at runtime
- Incorporating the annotatability of variable assignments as well as class properties
- Runtime (and potentially AoT) transformation of tokens which allows parsing (and LSP support) for jsx, templating languages and even data formats like yaml, xml, protobuf, etc
- Many more use cases

```javascript
const vueComponent = {
  template: vue!(<div>Hello {{data.world}}</div>),
  data: () => ({ world: 'World' })
}

const contents = yaml!(foo: 'bar')
// Expands to
// const contents = { foo: 'bar' }
```

LSPs would see the expanded form of macros and the macro implementation would define where errors occur in a transformation.

In the Rust world, this has been used to great effect to create GUI frameworks with vastly different approaches without preprocessors, some resembling React, others Vue:

- Web wasm frameworks [\[1\]](https://yew.rs/) [\[2\]](https://leptos.dev/)
- Native desktop frameworks [\[1\]](https://github.com/Relm4/Relm4?tab=readme-ov-file#a-simple-counter-app) [\[2\]](https://iced.rs/)

[21:58:51.0375] <Ashley Claymore>
I am curious how things like auto-complete and refactoring work within Rust macros. These both sound easier for tooling to implement when the language extension is concrete, instead of being defined as a macro.

[22:21:11.0512] <David Alsh>
For autocomplete, the LSP expands the macro and uses the output
```javascript
const foo = add!(1, 1)
```
Would expand into
```javascript
const foo = 2
```
So consumers see it as a `number` rather than a macro. It simply replaces itself with the transformed result.

As for refactoring; when someone implements a macro, they parse "tokens" which they move around into the equivalent valid language syntax. 

The editor can unwind that to determine what to update - though there are some macros that are too complex and refactoring tools bail out.

Implementers can also throw during parsing, which bubbles up to the editor, showing errors in the correct place in the macro

[22:21:30.0686] <David Alsh>
 * For autocomplete, the LSP expands the macro and uses the output

```javascript
const foo = add!(1, 1)
```

Would expand into

```javascript
const foo = 2
```

So consumers see it as a `number` rather than a macro. It simply replaces itself with the transformed result.

As for refactoring; when someone implements a macro, they parse "tokens" which they move around into the equivalent valid language syntax.

The editor can unwind that to determine what to update - though there are some macros that are too complex and refactoring tools bail out.

Implementers can also throw during parsing, which bubbles up to the editor, showing errors in the correct place in the macro

[22:31:50.0199] <Ashley Claymore>
For auto-complete, when the macro is expanded, how is the IDE cursor position preserved?

[22:32:36.0884] <Ashley Claymore>
the position could expand to a much larger block of code 

[22:34:29.0276] <Ashley Claymore>
the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete 

[22:38:06.0853] <David Alsh>
> These both sound easier for tooling to implement when the language extension is concrete

Macros are more of a preprocessing step rather than dynamic functionality (like decorators) - but there's a chicken and egg problem. 

The best supported illustration of macros in tooling is the built-in transformation of jsx in TypeScript. There are many GitHub issues requesting to expand this to offer custom programmatic macros however it's has been deemed out of scope.

Attempts by other toolmakers to implement the functionality that macros offer have resulted in fragmented, brittle implementations (.vue files and .svelte files - custom tooling, editor plugins and poor support for test runners, linters, formatters, etc). 

Decorators also feel like an attempt at addressing the same problem albeit at runtime.

After spending some time in the Rust world, I personally feel that there is evidence that ES world shows a need for this type of functionality

[22:40:37.0041] <David Alsh>
> the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete 

It's likely that TypeScript would compile macros into TypeScript at compile time (and in the editor), where the emitted runtime code would be the static JavaScript equivalent 

[22:41:26.0548] <David Alsh>
 * > the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete

It's likely that TypeScript would compile macros into TypeScript at compile time (and in the editor), where the emitted runtime code would be the static JavaScript equivalent

That said, if they simply strip the types and leave macros to be evaluated at runtime, then perhaps type information would be an issue

[22:42:07.0899] <David Alsh>
 * > the expanded code would also lack type annotations, meaning TypeScript would only be able to infer what might be a correct auto complete

It's likely that TypeScript would compile macros into TypeScript at compile time (and in the editor, like they do with jsx), where the emitted runtime code would be the static JavaScript equivalent

That said, if they simply strip the types and leave macros to be evaluated at runtime, then perhaps type information would be an issue

[22:42:18.0701] <Ashley Claymore>
I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed

[22:43:03.0864] <Ashley Claymore>
Unlike with Rust macros where the compiler naturally understands how to execute Rust

[22:45:38.0773] <David Alsh>
> I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed

Haha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit. There are also options like [QuickJS](https://bellard.org/quickjs/) and [llrt](https://github.com/awslabs/llrt) for macros that don't use nodejs functionality

[22:46:41.0025] <David Alsh>
 * > I'm also wondering for tools like swc, it wouldn't be able to execute the macros natively in Rust. It would need to delegate to JS adding overhead that negates the tools desire for speed

Haha, this is an area I've been working in quite a bit. swc can call into Nodejs to delegate evaluation - it's not as fast as rust native code and there is overhead in crossing from Rust to Nodejs, but it wouldn't be a substantial performance hit. There are also options like embedding Deno, [QuickJS](https://bellard.org/quickjs/) or [llrt](https://github.com/awslabs/llrt) for macros that don't use niche nodejs functionality 

