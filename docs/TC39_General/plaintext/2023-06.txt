2023-06-01
[07:32:52.0124] <annevk>
Is _Object Type_ supposed to be _Object type_?

[07:33:28.0859] <annevk>
Also, Undefined type and Null type are not in italics?

[08:22:42.0022] <bakkot>
annevk: the italics are because it's a definition

[08:23:17.0139] <bakkot>
the capital letter is probably a mistake; it was until yesterday in a header, where it was capitalized for that reason

[08:25:11.0531] <bakkot>
https://github.com/tc39/ecma262/pull/3086

[08:25:17.0162] <annevk>
bakkot: okay, so why are Undefined and Null type not defined?

[08:26:06.0681] <bakkot>
probably because we don't actually use them as terms

[08:26:15.0622] <bakkot>
but they could be

[08:27:46.0066] <annevk>
I don't have a need per se, just seemed inconsistent

[08:28:35.0750] <annevk>
Though maybe if we do more reconciliation across JS/Infra/IDL it could help, TBD

[08:50:44.0786] <jmdyck>
There are a few uses of Undefined and Null, generally where the context forces the use of a type name rather than just referring to `*undefined*` or `*null*`.

[09:06:08.0249] <Michael Ficarra>
since they're single-inhabitant types, there's no need for us to refer to the type when we can just list all the inhabitants, which our syntax for describing types in the spec makes trivial


2023-06-02
[07:31:07.0718] <voidhedron>
What is the reasoning behind both the original regex unicode properties proposal (https://github.com/tc39/proposal-regexp-unicode-property-escapes) and the recent one adding the unicode string properties (https://github.com/tc39/proposal-regexp-v-flag) both passively refusing to add non-binary unicode properties (minus the 3 exceptions already supported)? The syntax for them is already in place, and implementers already use ICU for all of the binary properties, so it doesn't save on dependencies or anything either, so why are all the remaining String and Enumerated properties being left out? I can't find any reasoning or justification for it whatsoever in the discussions of the proposals, except some unclear indirect references to them like explaining why `Name` specifically isn't supported.


2023-06-03
[08:37:12.0856] <Chris de Almeida>
has anyone successfully used the new eslint config system? (`eslint.config.js`) 

[13:08:44.0183] <ljharb>
flat config? no, not yet. shared configs and plugins tend to need updates for that


2023-06-04
[21:43:24.0385] <Jack Works>
yes. I have no problem while migrating.

[21:43:48.0201] <Jack Works>
> <@ljharb:matrix.org> flat config? no, not yet. shared configs and plugins tend to need updates for that

plugin's don't need to update

[23:04:24.0383] <ljharb>
they do if they export shared configs, which is basically all of them

[23:04:54.0073] <ljharb>
I maintain the 3 most used ones, and I‚Äôve only released one so far that‚Äôs compatible


2023-06-05
[05:04:21.0588] <canadahonk>
If anyone might find it useful, I just made https://test262.fyi which publishes results of test262 in most engines daily (like wpt.fyi or test262.report)
(please give feedback/wants, sorry if not for this room)

[05:06:09.0246] <canadahonk>
* If anyone might find it useful, I just made https://test262.fyi which publishes results of test262 in most engines daily (like wpt.fyi or test262.report but up to date with more engines)
(please give feedback/wants, sorry if not for this room)

[05:52:43.0407] <jmdyck>
@canadahonk: engine262 is checked in the repo's README, but doesn't appear on the website.

[06:51:23.0426] <canadahonk>
> <@jmdyck:matrix.org> @canadahonk: engine262 is checked in the repo's README, but doesn't appear on the website.

it's still running as I triggered a build not that long ago, it should show up in an hour or so

[06:51:57.0486] <canadahonk>
* it's still running as I triggered a build not that long ago, it should show up in an hour or so (no caching/past data yet)

[07:36:46.0950] <voidhedron>
> <@canada_goose:mozilla.org> If anyone might find it useful, I just made https://test262.fyi which publishes results of test262 in most engines daily (like wpt.fyi or test262.report but up to date with more engines)
> (please give feedback/wants, sorry if not for this room)

not very good UI atm, in some cases you cant even click some engines because the hover animations overlap and shift your hover into a different engine, but definitely interesting info to see

[07:38:06.0792] <canadahonk>
> <@voidhedron:matrix.org> not very good UI atm, in some cases you cant even click some engines because the hover animations overlap and shift your hover into a different engine, but definitely interesting info to see

I only began it 2 days ago so haha. If you have anything (else) specific to improve please say

[07:39:15.0547] <voidhedron>
yea im aware its new no worries, just giving feedback üëçÔ∏è

[07:39:52.0449] <canadahonk>
very welcome to it :)

[07:40:10.0429] <voidhedron>
its also pretty disorienting how if an engine fails a test it completely disappears from the bars list

[07:40:25.0467] <voidhedron>
well actually thats not really related to failing the test

[07:40:39.0308] <voidhedron>
in general how the engines shift each other around unless theyre all 100%

[07:41:11.0632] <canadahonk>
yeah I might change it so each one is in a container for 100%

[07:41:18.0059] <voidhedron>
it'd be cleaner if each engine's % bar column had a fixed start

[07:41:27.0477] <canadahonk>
yeah like that 

[07:42:45.0752] <canadahonk>
also if anyone has any (niche/obscure) engines missing I am very open to adding ;)

[07:42:58.0208] <canadahonk>
* also if anyone sees any (niche/obscure) engines missing I am very open to adding ;)

[07:44:28.0055] <canadahonk>
> <@jmdyck:matrix.org> @canadahonk: engine262 is checked in the repo's README, but doesn't appear on the website.

it's there now üéâ (fixing no cache now as well)

[07:44:28.0411] <voidhedron>
it could be interesting to add runs for the versions of engines currently used in the latest versions of backend runtimes

[07:45:03.0228] <canadahonk>
I had that idea too, like V8 nightly (now) and V8 stable (chrome/node/deno/etc)

[07:45:20.0029] <voidhedron>
ie the V8 version of Node LTS and Latest, Deno's current V8 version, Bun's current JSC version, etc, yeah

[07:45:35.0140] <canadahonk>
yeah planning that for sure

[07:45:50.0525] <canadahonk>
also going to do a graph like WPT showing "interop" between chosen maybe

[07:47:48.0601] <voidhedron>
something like compare engines A and B and show tests where they differ so you can see what to avoid/account for between the two could be useful

[07:49:08.0348] <canadahonk>
yeah going to do diffs for sure

[07:49:09.0356] <voidhedron>
a small UI detail too is you could have the test filenames actually link to the files themselves on the tc39/test262 repository (with the exact commit used for the test results on the side at the time of course)

[07:49:27.0346] <canadahonk>
good idea, didn't think of that

[07:49:31.0030] <nicolo-ribaudo>
canadahonk We currently use test262 to test Babel+core-js, running them in a very old version of Node.js (0.8 iirc). It's not really an engine, but would you be open to also adding that? üëÄ

[07:49:53.0446] <canadahonk>
for sure!

[07:50:03.0974] <nicolo-ribaudo>
Expect a PR at some point then :)

[07:50:22.0450] <canadahonk>
I'm also happy to do if you want btw

[07:50:38.0664] <canadahonk>
code is mostly bash scripts and forks of utils for testing

[07:50:48.0321] <canadahonk>
* code is mostly bash scripts and forks of utils for testing so a bit messy to add a new one

[07:51:10.0931] <nicolo-ribaudo>
I will open an issue to talk about it, so that I can at least give info regarding our current test262 infra

[07:51:23.0747] <canadahonk>
thanks!

[07:52:22.0550] <voidhedron>
should perhaps code in some way of having static engines that only get tested once and then never again unless manually, so that you can add older engines like that which are unlikely to have their test results change anytime soon but without the extra cost of rerunning them every hour or so

[07:53:23.0184] <voidhedron>
 * should perhaps code in some way of having static engines that only get tested once and then never again unless manually, so that you can add older engines like that which are unlikely to have their test results change anytime soon but without the extra cost of rerunning them every day or so

[07:53:24.0550] <canadahonk>
well test262 and Babel/core-js/etc would be updated but yeah I plan on main ones updating daily, some weekly

[07:53:41.0275] <canadahonk>
eg V8 stable weekly, V8 canary daily

[07:54:02.0498] <canadahonk>
(although there isn't that much cost as all engines are tested in parallel)

[07:54:31.0274] <nicolo-ribaudo>
Btw to save on running time ‚Äî Babel runs test262 on every commit and we generate tap output, maybe it makes sense to just use that instead of running the tests again

[07:54:50.0300] <canadahonk>
oh neat

[07:54:57.0384] <voidhedron>
pretty much what i was typing out yeah

[07:55:26.0272] <voidhedron>
it would actually be smarter to just listen for updates on engines and test262 to trigger re-runs

[07:56:34.0850] <canadahonk>
I want most engines to use their canary/nightly/CI/etc counterparts so

[07:56:41.0917] <voidhedron>
well some of the engines may not be released on a platform that can be subscribed to like a webhook and might need to be polled on an interval for updates still, but still a lot cheaper than blindly doing re-runs of the same version

[07:56:48.0883] <canadahonk>
(hermes took a lot of effort to get working lol)

[07:57:50.0591] <voidhedron>
> <@canada_goose:mozilla.org> I want most engines to use their canary/nightly/CI/etc counterparts so

yeah exactly, for the canary/nightly versions of engines you can just attach their updates to a github commit webhook

[07:58:37.0897] <voidhedron>
well for the engines on github at least

[07:58:50.0394] <voidhedron>
like v8

[08:00:11.0882] <canadahonk>
unfortunately you need ownership of the repo to make webhooks on other repos so won't be *that* easy probably

[08:01:32.0811] <canadahonk>
> <@nicolo-ribaudo:matrix.org> Btw to save on running time ‚Äî Babel runs test262 on every commit and we generate tap output, maybe it makes sense to just use that instead of running the tests again

your talk was super cool btw ;)


2023-06-06
[03:07:52.0204] <canadahonk>
if anyone is interested, I updated the site to show proposals (and fix some data/UI stuff)

[08:13:46.0430] <nicolo-ribaudo>
Is it valid to use "is" to compare different values of different types? i.e. `If _x_ is *""*`, where _x_ might be a string or something else

[08:13:56.0787] <nicolo-ribaudo>
 * Is it valid in spec-language to use "is" to compare different values of different types? i.e. `If _x_ is *""*`, where _x_ might be a string or something else

[08:14:08.0232] <nicolo-ribaudo>
 * Is it valid in spec-language to use "is" to compare different values of different types? e.g. `If _x_ is *""*`, where _x_ might be a string or something else

[08:20:42.0662] <littledan>
> <@nicolo-ribaudo:matrix.org> Is it valid in spec-language to use "is" to compare different values of different types? e.g. `If _x_ is *""*`, where _x_ might be a string or something else

IMO it is fine and means SameValue

[08:21:48.0805] <nicolo-ribaudo>
I'm specifically wondering if the first step of https://tc39.es/ecma262/#sec-number.isnan is necessary

[08:33:59.0982] <bakkot>
it is not

[09:58:27.0650] <Michael Ficarra>
littledan: nicolo-ribaudo: You can read more about how to compare values for equality in https://tc39.es/ecma262/#sec-identity

[09:58:39.0739] <Michael Ficarra>
we have very carefully defined the term "is"

[09:59:33.0873] <littledan>
Ah thanks for the correction

[10:01:00.0395] <littledan>
Sorry I don‚Äôt think I understand the definition. How does this differ from SameValue?

[10:01:37.0276] <littledan>
Because it also ranges over specification values?

[10:01:47.0304] <Michael Ficarra>
for one, "is" can be used with any spec value, but SameValue only works for language values

[10:02:32.0127] <littledan>
OK, so my answer was correct in that particular context, but insufficiently general

[10:04:56.0641] <Michael Ficarra>
yes, SameValue could be used there because we already know both operands are ES language values

[10:07:20.0371] <Michael Ficarra>
we haven't written down our editorial conventions yet, but I believe the rule we've decided on is that we don't use SameValue when the operands are known to not have identity

[10:09:00.0436] <Michael Ficarra>
writing down those editorial conventions is my next big task as editor, but the 262 PRs and stage 3 proposals keep coming in faster than I can get to them all

[10:22:50.0362] <bakkot>
also SameValue bottoms out in "is"

[10:22:55.0774] <bakkot>
so "is" can't bottom out in "SameValue"

[10:22:56.0110] <ptomato>
but there's something poetic about having the first step of a function whose name literally means "is not a number", be "If _number_ is not a Number, return false"

[10:51:09.0653] <Michael Ficarra>
ptomato: and this is the one with the semantics we actually LIKE!


2023-06-12
[13:56:46.0412] <Justin Ridgewell>
I lost so much time today due to an unhandled rejection from a `promise.finally()` call

[13:57:06.0080] <Justin Ridgewell>
The `promise` itself was handled, but the new one doesn't inherit that state.

[14:01:33.0008] <Kris Kowal>
Is this an isolated example of the problem you observed? `Promise.reject(new Error('Bad from the start')).finally(() => Promise.reject(new Error('Got worse')))`, where the unhandled rejection is `Got worse`?

[14:02:42.0679] <Kris Kowal>
And you lost time, I presume, because `Bad from the start` was the problem hiding behind the error?

[14:04:02.0497] <Kris Kowal>
If that‚Äôs the case, perhaps the mitigation is for `finally` to produce an `AggregateError`.

[14:22:07.0890] <Ashley Claymore>
Would be great if that was web compat

[14:23:44.0070] <Ashley Claymore>
Maybe there is a way to thread that finally rejection to the unhandled exception handler, while preserving the current finally semantics of .then 

[14:23:54.0663] <Ashley Claymore>
If want to be more compat 

[14:24:06.0598] <Kris Kowal>
Or‚Ä¶drumroll‚Ä¶ `promise.final√©()`

[14:24:39.0580] <Ashley Claymore>
or just `.fin` üé• 

[14:25:37.0936] <Kris Kowal>
Hah. Q predated Doug‚Äôs initiative to make keywords valid property names, so I did call it `fin` in the earliest versions, and it‚Äôs still there for back-compat.

[14:27:58.0601] <Kris Kowal>
Shunting the antecedent error out to unhandled rejection handler is a bandaid I can support, but that effectively means deprecating `finally`, since breaking the causal chain is bad in general.

[14:28:22.0377] <Kris Kowal>
There really needs to be a way for both errors to flow through the output promise.

[14:29:51.0431] <Kris Kowal>
And as long as we‚Äôre talking history, if I‚Äôd made Q _after_ Doug won keywordly-named properties, I would have been tempted to name `resolve` and `reject` as `return` and `throw`.

[14:30:02.0184] <bakkot>
wait Justin Ridgewell was the problem that `finally` swallowed the error from the original `promise`, or that you had an error thrown in your `finally` handler and you didn't handle that error, only errors on the original `promise`?

[14:30:28.0158] <Kris Kowal>
And then we‚Äôd be living in a world where it‚Äôs obvious that Promises are just a degenerate AsyncIterators.

[14:31:25.0872] <Justin Ridgewell>
```
const promise = Promise.reject();
promise.catch(() => { /* handled */ });
promise.finally(() => {}) // new promise is unhandled
```

[14:31:51.0892] <bakkot>
ah yeah

[14:31:54.0966] <bakkot>
that one is tricky

[14:32:58.0491] <Justin Ridgewell>
It's _not_ equivalent to
```
try {
  try { await promise }
  catch { /* handled */ } 
} finally {
}
```

[14:33:15.0555] <Justin Ridgewell>
Which is the behavior I wanted

[14:33:50.0080] <Kris Kowal>
So, `promise.catch().finally()` would have done the job.

[14:34:13.0382] <Justin Ridgewell>
Yup, but my catch and finally aren't in the same file

[14:35:52.0785] <Kris Kowal>
This is I think a case where promises are working as designed, but we need to promote a culture of not dropping promises, and linting for dropped promises. That‚Äôs a bit of a tall order at the moment, since you need something like the TypeScript compiler to find them.

[14:37:27.0238] <Kris Kowal>
We‚Äôve used an eslint rule for this at Agoric, but because it‚Äôs driven by eslint and not tsc, there‚Äôs a great deal of duplicative effort in return type inference, so it‚Äôs way too slow.

[14:44:44.0305] <bakkot>
TS doesn't currently have a "must use" annotation

[14:44:53.0313] <bakkot>
so even TS is not sufficient on its own

[14:45:11.0715] <bakkot>
also there's a fundamental problem where any promise handler can throw, and then you have to handle that also

[14:45:51.0026] <bakkot>
like just `asyncFn()` is a bug because you don't handle exceptions, but `asyncFn().catch()` might also be a bug because you don't handle exceptions in the `catch` handler, and so on unto infinity

[14:46:52.0585] <Kris Kowal>
TypeScript at least knows that `() => {}` will not throw.

[14:47:38.0538] <Kris Kowal>
But yes, no amount of rigor will eliminate the need for UnhandledRejection reports.

[14:48:14.0420] <Kris Kowal>
And even TypeScript can‚Äôt help you if your handler throws a `RangeError`.

[14:50:40.0116] <Kris Kowal>
> <@bakkot:matrix.org> TS doesn't currently have a "must use" annotation

To be clear, TypeScript + ESlint are able to check for dropped promises, but in this form, it‚Äôs just too slow. https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/no-floating-promises.md

[14:52:12.0615] <Kris Kowal>
And that is quite good at halting at a handler that has done everything in its power to ensure no exceptions go unhandled.


2023-06-13
[18:16:43.0827] <ljharb>
tbh i'd say that if the catch is in a separate file from the finally, then the finally file probably shouldn't be assuming the promise is handled

[18:17:01.0358] <ljharb>
 * tbh i'd say that if the catch is in a separate file from the finally, then the finally file probably shouldn't be assuming the promise is handled - iow, the author of one file shouldn't assume knowledge of the code in another one

[04:05:33.0149] <matlokam>
Hey! I have a random question: was the idea of `Array.prototype.clear()` ever struck down in TC39? I've had repeated experiences of `array.length = 0` not being trusted by developers, despite being the best way to do clear an array, so I was thinking if a `.clear()` proposal would have a future

[04:06:33.0169] <matlokam>
Just coming from Python, Java, C#, Rust, or almost any language, you expect `.clear()`

[04:07:12.0328] <nicolo-ribaudo>
Why would `.clear` be trusted more? Btw, you can also use `arr.splice(0, arr.length)`

[04:08:33.0163] <matlokam>
It _seems_ sketchy, despite being valid, which is just an odd developer experience

[04:11:06.0160] <matlokam>
It felt much more like regular JS in 2014, but JS has improved so much in terms of the developer experience since ES6, that now it just feels out of place :D

[04:14:28.0522] <matlokam>
For instance, of course `.indexOf() > -1` was and still is completely valid ‚Äì nonetheless `.includes()` is _the_ clear way of doing the same since it was added ES2016

[04:16:32.0960] <voidhedron>
Not to mention the edge-case where you have non-array-index extra properties in an array instance, which will not be cleared by `array.length = 0;`

[04:16:58.0001] <ptomato>
would those be cleared by a `.clear()` method though?

[04:17:11.0113] <voidhedron>
Imo they should

[04:17:22.0114] <ptomato>
I can think of arguments in either direction\

[04:17:25.0595] <ptomato>
 * I can think of arguments in either direction

[04:18:02.0058] <voidhedron>
Well argument in favor of it is, if you *don't* want the behavior of clearing non-indexes, you can just resort back to the original length method

[04:19:13.0440] <voidhedron>
Thinking about it further, we could also take this further and invert it

[04:20:13.0528] <Andreu Botella>
`Map.prototype.clear` doesn't clear properties on the map object -- is array different because the indices are actual properties in the object?

[04:20:19.0918] <Andreu Botella>
 * `Map.prototype.clear` doesn't remove properties on the map object -- is array different because the indices are actual properties in the object?

[04:20:21.0208] <voidhedron>
While to Array there is the distinction between indexes and properties, from an Object perspective, both are just properties, so what if instead clear() was added as an Object method?

[04:20:38.0826] <voidhedron>
and it would just generically work on arrays

[04:21:15.0440] <voidhedron>
> <@abotella:igalia.com> `Map.prototype.clear` doesn't remove properties on the map object -- is array different because the indices are actual properties in the object?

That was my thinking at first there yes

[04:26:18.0596] <matlokam>
Hmm, non-index properties on arrays seems like a niche use case outside of well-defined bounds of behavior

[04:26:57.0359] <matlokam>
I would stick to Map-like semantics of just emptying the collection

[04:28:02.0733] <matlokam>
That's up for further discussion though I suppose

[04:28:13.0664] <matlokam>
Well, do y'all know if the method sense as a proposal, or is there a reason why the idea is dead in the water?

[04:28:18.0434] <matlokam>
 * Well, do y'all know if the method makes sense as a proposal, or is there a reason why the idea is dead in the water?

[04:28:59.0960] <voidhedron>
My idea now is that, since arrays don't need a special method to access their internal values due to being just regular object properties, we should just make a generic *object* clear() method, which just works generically on arrays by extension

