2025-09-05
[08:02:46.0714] <Aapo Alasuutari>
Regarding https://tc39.es/ecma262/#sec-hostgrowsharedarraybuffer and equality definition of Data Blocks:

>  Two data blocks are equal only if the sets of the locations they contain are equal; otherwise, they are not equal and the intersection of the sets of locations they contain is empty.

What is the intention vis a vis empty DataBlocks? Their sets of locations are equal (no locations), and likewise the intersection of their sets of locations is empty. The first sentence quite clearly states that they should be equal to one another, while the second sentence kind of implies that maybe they should not be.

[08:04:59.0229] <Andreu Botella>
I suspect this means that two data blocks can either refer to the exact memory locations, or they must be disjoint

[08:05:15.0819] <Andreu Botella>
they shouldn't partially overlap

[08:25:42.0314] <Richard Gibson>
I agree. Note also that the immutable ArrayBuffer is already restricting that check to Shared Data Blocks: https://tc39.es/proposal-immutable-arraybuffer/

An empty Shared Data Block should not be equal to any other Shared Data Block, and given the basis for equality testing, would not even be equal to itself (which awkwardly breaks reflexivity but is not actually problematic AFAICT). I guess the text could be something like
> Two Shared Data Blocks that both contain any one location must contain exactly the same set of locations and are equal to each other. All other pairs of Shared Data Blocks must contain respectively disjoint locations and are not equal to each other. Note that an empty Shared Data Block is thus not even equal to itself.


2025-09-16
[02:57:13.0442] <Aapo Alasuutari>
In terms of the C++/Rust memory model, SharedArrayBuffer's UNORDERED ordering is just an ordinary read or write, right? (Assuming the platform doesn't need locks to write a value of that size in a single operation.) And not Relaxed.

[02:58:11.0684] <Andreu Botella>
my understanding is that in the C++/Rust memory model, "ordinary" reads and writes to a shared buffer, even if fine by the platform, can lead to compiler optimizations that might still mess things up

[02:58:33.0885] <Andreu Botella>
I think relaxed will do the right thing

[03:01:54.0706] <Andreu Botella>
or rather, "ordinary" reads and writes to the same memory across threads are a data race, with is UB in C++ and Rust

[03:02:02.0860] <Andreu Botella>
* or in other words, "ordinary" reads and writes to the same memory across threads are a data race, with is UB in C++ and Rust

[03:02:27.0243] <Andreu Botella>
* or in other words, "ordinary" reads and writes to the same memory across threads without any other kind of synchronization, are a data race, with is UB in C++ and Rust

[03:04:09.0689] <Andreu Botella>
relaxed is a stronger constraint than the spec requires

[03:05:17.0445] <Aapo Alasuutari>
Yeah, the spec just kindly asks devs to refrain from writing data races, so Relaxed seems to be the "right but wrong" thing.

[03:05:42.0570] <Aapo Alasuutari>
It's right by C++/Rust standards, but it's wrong by spec standards.

[03:06:33.0868] <Andreu Botella>
I'm pretty sure that the spec only defines minimum constraints, and relaxed is stronger than that minimum constraint, so it's fine

[03:06:43.0750] <Aapo Alasuutari>
But the P word!

[03:06:46.0473] <Andreu Botella>
but it's been a long time since I've looked at this

[03:09:40.0002] <Aapo Alasuutari>
https://rust-lang.zulipchat.com/#narrow/channel/213817-t-lang/topic/Writing.20a.20WebAssembly.20interpreter.20in.20Rust.20for.20wasm.20threads/with/488916330 for actually the exact same discussion (albeit from Wasm point of view, but it's the same point of view in the end)

[09:51:20.0648] <Michael Ficarra>
probably best to avoid installing any npm packages for a little while: https://www.reversinglabs.com/blog/shai-hulud-worm-npm

[10:56:05.0286] <kriskowal>
The best time to plug the postinstall scripts hole was yesterday, but today will do. Thereâ€™s a tool for limiting postinstall script execution to a list configured by the project and by default denied. https://www.npmjs.com/package/@lavamoat/allow-scripts And I see that it might not be protecting people using some versions of yarn https://github.com/LavaMoat/LavaMoat/pull/1218 Please let me know if you have information we can post to provide guidance on how to use our package managers safely going forward. This would be a good use of the #tc39-tg3-security:matrix.org channel if folks would meet me there.

[11:03:18.0720] <Michael Ficarra>
nothing has changed in the last decade: https://blog.npmjs.org/post/141702881055/package-install-scripts-vulnerability

[11:11:47.0319] <Michael Ficarra>
hopefully enough people with publishing rights for major packages have MFA enabled on publish that it'll slow the spread

[12:15:21.0062] <bakkot>
npm enforces 2FA for people with publish right to popular packages

[13:36:54.0849] <Aapo Alasuutari>
Thinking on this a bit more, I don't think there's a way to implement ECMAScript SharedArrayBuffer related operations without inline assembly in Rust and C++: not only can you race (UB but could be fixed by using bytewise Relaxed operations), you can also do mixed-size atomic operations like CompareAndExchange: that's forbidden by C++ atomics as far as I can gleam but now we absolutely cannot fix this by using bytewise Relaxed operations as it would destroy the atomicity of the operation.

So, it's ... problematic. At least until Rust decides to allow mixed-size atomics which it well might.

[13:45:32.0967] <Andreu Botella>
IIRC such atomic operations are always within an aligned 8-byte chunk

[13:47:13.0465] <Andreu Botella>
I think it's possible to implement the backing store as an `[AtomicU64]`

[13:49:02.0309] <Aapo Alasuutari>
Atomics can be used on any TypedArray backed by a SAB, so not limited to 8 bytes.

[13:50:07.0115] <Andreu Botella>
64 bits = 8 bytes

[13:50:43.0908] <Andreu Botella>
I don't think there's been proposals for a `Decimal128TypedArray` yet

[13:51:01.0735] <kriskowal>
There has not, but the possibility has been invoked.

[13:51:58.0228] <Aapo Alasuutari>
Ah sorry, I misunderstood your meaning. I thought you implied that the ECMAScript spec says that all atomic operations are secretly done in 8-byte chunks.

[13:53:10.0650] <Aapo Alasuutari>
But anyway, that leads to a possibly worse problem where all atomic operations less than 8 bytes, and all unordered operations, became CAS loops.

[13:55:06.0430] <Andreu Botella>
my understanding is that Rust's atomics do use CAS loops on a larger size sometimes

[13:55:18.0812] <Aapo Alasuutari>
Yes, but this would mean CAS loops on smaller types :)

[13:55:50.0446] <Aapo Alasuutari>
1 byte atomic write would need to CAS-loop on the whole 8 byte replacement to make sure it doesn't mangle the other 7 bytes.

[13:58:32.0492] <Aapo Alasuutari>
But I realise I'm actually talking silly things: there is a way to fix the problem of tearing appearing with atomic operations if the backing store is `[AtomicU8]`, and that is to just use a lock. Of course, ECMAScript spec says that at least 4 byte atomics should be lock free, so that's a little awkward.


2025-09-17
[19:20:54.0573] <Sacha Greif>
hi all! just wanted to let you know I've started working on this year's State of JS survey questions. 

If you'd like to preview them/leave feedback you can do so here: https://github.com/Devographics/surveys/issues/307

[23:18:18.0818] <Aapo Alasuutari>
* Yes, but this would mean CAS loops on smaller types :) (EDIT: oop, I misunderstood this; we're talking of the same thing)

