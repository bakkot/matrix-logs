2023-11-06
[20:55:18.0446] <snek>
is human display for durations a solved problem anywhere? especially normalizing the units... 

[20:55:50.0847] <snek>
the more i think about this the more complex it gets and the less i am sure that it could be generally solved

[20:56:02.0420] <snek>
 * the more i think about this the more complex it gets and the less sure i am that it could be generally solved

[07:05:02.0756] <ryzokuken>
snek welcome to my world 

[07:05:52.0921] <ryzokuken>
the current version of the DurationFormat proposal can represent durations in mostly all forms that applications need 

[07:38:46.0029] <snek>
> <@usharma:igalia.com> the current version of the DurationFormat proposal can represent durations in mostly all forms that applications need 

does it support normalizing units? like if I just have a large quantity of seconds can it turn that into hours or weeks or whatever 

[07:58:04.0892] <ryzokuken>
> <@devsnek:matrix.org> does it support normalizing units? like if I just have a large quantity of seconds can it turn that into hours or weeks or whatever

weeeeell

[07:58:24.0233] <ryzokuken>
it can do that for subsecond units because those could be expressed as a fraction

[07:58:45.0618] <ryzokuken>
it could in the future do it up to hours

[07:59:41.0285] <ryzokuken>
but since a day may not have a set number of hours, it couldn't do further without a point of reference 

[08:01:37.0129] <snek>
it has a point of reference!! it's intl api!!!

[08:01:54.0802] <snek>
or do you mean a timestamp 

[08:02:00.0152] <ryzokuken>
no I mean a...

[08:02:01.0017] <ryzokuken>
yeah

[08:02:35.0123] <ryzokuken>
a `ZonedDateTime` for setting up the context for the calculations

[08:04:08.0782] <snek>
I guess I'll have to keep using the passable moment duration formatter 

[08:04:24.0401] <snek>
it has some weird behavior though 

[08:05:33.0628] <Andreu Botella>
I assume that wouldn't take leap seconds into account, right?

[08:05:41.0447] <Andreu Botella>
since IIRC UTC ignores them

[08:05:53.0483] <ryzokuken>
https://github.com/formatjs/formatjs/tree/d95d21f1ea10a190f45968e909323e9af6992921/packages/intl-durationformat

[08:05:56.0895] <ryzokuken>
there's this

[08:07:08.0926] <snek>
but if it doesn't normalize units it's not really usable 

[08:07:15.0077] <snek>
I just have a unix timestamp

[08:07:22.0720] <ryzokuken>
ah right

[08:08:01.0443] <pipobscure>
You surely have a timestamp and some second timestamp to get a duration.

[08:08:05.0643] <snek>
I guess that is sort of a distinct operation

[08:08:19.0040] <pipobscure>
The difference is your duration and one of them is your reference

[08:08:28.0580] <snek>
I have a unix timestamp and I want to display the duration between it and the current time

[08:08:54.0296] <pipobscure>
Which means the duration is now-ts and the reference is now

[08:09:04.0853] <snek>
today I use moment but moment is kind of mid

[08:09:07.0054] <pipobscure>
Which is enough to let it normalize units

[08:09:19.0576] <snek>
yeah if something implemented that

[08:09:33.0478] <pipobscure>
It’s just tha if you have ONLY a duration of 2234234seconds you can’t normalise

[08:09:53.0319] <snek>
yeah that's the problem 

[08:10:24.0595] <snek>
I just have a bunch of seconds. I want the computer to figure out the nicest way to display it, based on the users locale, reference point, or whatever else

[08:11:35.0300] <pipobscure>
Temporal.Duration.prototype.round should do that IIRC

[08:12:00.0928] <pipobscure>
And you can then send the result to Intl.DurationFormat

[08:13:04.0440] <snek>
hmmm

[08:13:13.0242] <snek>
that wants me to choose the unit though 

[08:13:27.0729] <ryzokuken>
https://tc39.es/proposal-temporal/docs/balancing.html

[08:14:29.0514] <ryzokuken>
the largest one 

[08:14:41.0110] <ryzokuken>
you can always go for `largestUnit: "years"`

[08:14:48.0925] <ryzokuken>
 * you can always go for `largestUnit: "year"`

[08:14:58.0667] <pipobscure>
The smallestUnit is optional I think

[08:15:18.0308] <devsnek>
oh it's just putting bounds on it I see

[08:15:48.0188] <pipobscure>
So with that combination of APIs you should be able to do exactly what you want. I think

[08:16:34.0325] <devsnek>
yeah that makes sense

[08:16:45.0873] <devsnek>
how many more years until ietf moves forward

[08:16:55.0459] <devsnek>
can we express it with Temporal.Duration

[08:24:20.0999] <ryzokuken>
> <@devsnek:matrix.org> how many more years until ietf moves forward

it's moved forward actually!

[08:24:32.0718] <ryzokuken>
we're planning to make an announcement at the next plenary

[08:25:19.0825] <snek>
I thought it was in a comment period for like 5 more months 

[08:25:27.0036] <snek>
pleasant surprise 

[08:25:35.0932] <ryzokuken>
it has been finally approved by the IESG

[08:26:04.0466] <ryzokuken>
https://www.rfc-editor.org/current_queue.php#draft-ietf-sedate-datetime-extended


2023-11-07
[03:07:09.0615] <littledan>
So... good to unplug??

[03:07:14.0298] <littledan>
 * So... good to unflag??

[03:11:25.0923] <ryzokuken>
> <@littledan:matrix.org> So... good to unflag??

Yes

[03:11:54.0593] <ryzokuken>
atleast the IETF blocker is no longer going to hold anyone back


2023-11-08
[16:44:13.0127] <tewuzij>
What is that blocker for?

[17:03:15.0221] <Chris de Almeida>
> <@tewuzij:tzchat.org> What is that blocker for?

Temporal stage 4 has been blocked by the IETF RFC mentioned above

[17:15:50.0614] <shu>
that... is not the only thing blocking temporal stage 4

[05:29:21.0604] <ryzokuken>
> <@shuyuguo:matrix.org> that... is not the only thing blocking temporal stage 4

yes

[05:29:34.0094] <ryzokuken>
to be more specific, shipping temporal unflagged was blocked on IETF

[05:29:49.0268] <ryzokuken>
which in turn was one of the multiple blockers to temporal getting stage 4

[05:30:41.0353] <ryzokuken>
but now that this blocker is resolved, temporal may start shipping in implementations whenever it's done


2023-11-10
[11:28:05.0832] <snek>
temporal isn't unflagged anywhere right

[11:28:17.0121] <snek>
can we change the Duration constructor to be an object

[11:28:22.0076] <snek>
this is unusable lol

[11:30:04.0421] <snek>
hmm i guess Duration.from is usable

[11:30:19.0391] <shu>
temporal is not even completely implemented anywhere afaik

[11:33:50.0443] <snek>
hmm v8 reverted durationformat

[11:34:06.0516] <snek>
with no reason given on the commit :>

[11:34:31.0965] <shu>
which commit are you talking about?

[11:34:52.0365] <snek>
https://chromium-review.googlesource.com/c/v8/v8/+/3932693

[11:36:23.0377] <shu>
that's the cherry-pick

[11:36:26.0525] <shu>
the original revert has the reason: https://chromium-review.googlesource.com/c/v8/v8/+/3925703

[11:36:38.0056] <snek>
oh i see

[11:36:39.0699] <snek>
how'd you find that

[11:38:21.0283] <shu>
the line 'Merged 931dbda07d22c4331d8b26158be00ef6c521a734'

[11:38:37.0263] <shu>
"Merged:" is chromium-ese for "back merge"

[11:38:42.0003] <shu>
that sha is the original commit

[11:58:27.0171] <bakkot>
> <@devsnek:matrix.org> this is unusable lol

oh jeeze why did we decide to do that

[11:58:30.0176] <bakkot>
I guess that's how Date works?

[11:58:37.0898] <bakkot>
but that is awful

[11:59:58.0291] <snek>
it seems to me like from() is really what you should use


2023-11-11
[20:40:06.0882] <Ashley Claymore>
Yeah the constructors are almost like an implementation detail, the static methods are the real API

[20:48:22.0515] <Ashley Claymore>
From the Temporal docs:

> Like all Temporal constructors, this constructor is an advanced API used to create instances for a narrow set of use cases.

[21:07:45.0407] <rkirsling>
I never thought to object to that but like

[21:08:50.0693] <rkirsling>
is the argument that you wouldn't need to create an object as a prerequisite for instantiating a Temporal class?

[21:42:09.0723] <Ashley Claymore>
I can see the advantage of keeping the actual constructors as simple as possible yeah. no object allocation, no chance of getters  

[21:42:42.0914] <Ashley Claymore>
(Simple computationally)


2023-11-14
[08:28:38.0916] <Jack Works>
question: why terser prefer `,` than `;`

[08:28:53.0137] <Jack Works>
```js
export function x() {
    a()
    b()
    c()
}
```

[08:29:07.0249] <Jack Works>
why
```js
export function x(){a(),b(),c()}
```
not
```js
export function x(){a(),b(),c()}

[08:29:14.0111] <Jack Works>
 * why

```js
export function x(){a(),b(),c()}
```

not

```js
export function x(){a();b();c()}
```

[08:40:15.0603] <bakkot>
Jack Works: probably because it works better in other contexts:

```
if (foo) {
  a();
  b();
  c():
}
```
can be minimized to `if(foo)a(),b(),c()`

[08:41:05.0776] <bakkot>
so if you're writing a minimizer you just have a rule which says that sequences of expression statements get collapsed with `,`, and then after having applied that rule sometimes you can eliminate `{}`s, whereas there's no place where using `;` instead of `,` is a benefit

