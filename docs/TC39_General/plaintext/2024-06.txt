2024-06-01
[17:02:03.0584] <jmdyck>
In general, the parser should, at any point, know the set of terminal symbols (input elements) that could validly occur next, given everything to the left. On the basis of that set, it can tell the lexer which InputElementFoo nonterminal to use as the start symbol for the next input element.

[18:24:05.0343] <sirisian>
Thanks for all that information. That helps clarify things for me.

[04:50:56.0070] <jmdyck>
A different formulation would have the parser, at each point, tell the lexer all the terminal symbols that it's expecting, and ask for one of those. That would eliminate the InputElementFoo nonterminals and the rules about when each is appropriate, and a few other nonterminals like CommonToken. So simpler in some sense. But the current formulation minimizes the information that goes from the parser to the lexer, so simpler in a different sense.


2024-06-05
[15:55:17.0220] <whosy>
I wonder if there's any want for a `Promise.sleep( duration )`. I find myself writing one-liners for this in many a project.
e.g.
`const sleep = durationMs => new Promise( resolve => setTimeout( resolve, durationMs ) );`

[15:58:52.0861] <James M Snell>
> <@whosy:matrix.org> I wonder if there's any want for a `Promise.sleep( duration )`. I find myself writing one-liners for this in many a project.
> e.g.
> `const sleep = durationMs => new Promise( resolve => setTimeout( resolve, durationMs ) );`

There are already solutions for this. scheduler.wait is mostly this. Node.js has timers/promises, etc. Given that timers tend to be implementation specific, it's likely best left as a web platform API 

[16:02:47.0786] <whosy>
Might I ask what `schedular.wait` is?
 
And I really did mean as a simple shorthand for wrapping whatever native implementation of setTimeout is in a promise.

Though I guess that does leave a big question mark about what value is returned (if any). I am very green when it comes to actual implementations and the specification side of the language, by the way.

[16:04:55.0785] <James M Snell>
`scheduler.wait(...)` is defined https://github.com/WICG/scheduling-apis ... there's more to it but it essentially allows you to do `await scheduler.wait(duration)` 

[16:07:38.0109] <whosy>
Ah, I see. I couldn't find any reference to this when I tried a quick search for npm/JavaScript or the proposals listings.

It's an interesting read, and would definitely encompass this use-case.

[16:09:04.0518] <Chris de Almeida>
> <@whosy:matrix.org> I wonder if there's any want for a `Promise.sleep( duration )`. I find myself writing one-liners for this in many a project.
> e.g.
> `const sleep = durationMs => new Promise( resolve => setTimeout( resolve, durationMs ) );`

`setTimeout` is not part of JS

[16:12:06.0675] <Chris de Almeida>
the longer answer is that in order to get some flavor of `sleep()`, you would have to add various other things in the language first in order to support it

[16:12:32.0675] <whosy>
> <@softwarechris:matrix.org> `setTimeout` is not part of JS

Yes..that's something I only considered and realised after thinking about the differing return types across implementations. As I said in the thread now, I am very much not clued in on the language spec. I've mostly just used the language without considering its development until very recently.

But the lack of a spec-defined timing mechanism, I'm guessing is why the aforementioned Scheduler API is being developed?

[16:13:51.0441] <snek>
even if the core js language had timers, the web would still need a more complex scheduling api. you can read the details about that in the scheduling api readme

[16:15:43.0452] <Chris de Almeida>
I can't speak to the motivation of the folks that advanced Scheduler, but if you already have an environment where you have production-ready foundational components available, like timing, eventing, and cancellation, and that environment is the same one in which you want to have `sleep()`, then that seems like a faster path to that goal

[16:17:56.0442] <Chris de Almeida>
that doesn't mean it can't be pursued in the language, or that it's not still useful to add to the language

[16:20:50.0448] <bakkot>
I very much hope `scheduler.wait` does not become the way to do this, but it seems pretty likely unfortunately 

[16:21:25.0676] <bakkot>
we generally try to avoid duplicating things on the web platform, so if that ships it will not be in the language probably

[16:23:41.0732] <whosy>
> <@bakkot:matrix.org> we generally try to avoid duplicating things on the web platform, so if that ships it will not be in the language probably

That was my immediate concern as well. At this point the only way to avoid duplication is to adopt part of the spec into the language, or to try and rush through a proposal to the same effect faster than Scheduler.wait it can be adopted into major browsers.
Both of which have their own challenges and pitfalls..

[16:24:32.0596] <whosy>
Or I guess option 3, create a stage-0 proposal and just ask them very nicely to drop parts of their work which..I also don't see happening.

[16:29:12.0236] <whosy>
I am quite possibly the least qualified person to speak of what should or shouldn't be done here though, so I actually would love to hear the opinions of veterans on the matter.

[16:37:50.0855] <kriskowal>
> <@softwarechris:matrix.org> `setTimeout` is not part of JS

Me too, though I called it delay in Q, and the ocap folks (like me) would insist it go on a different namespace that the otherwise I/O free Promise since we prefer to be able to pass Promise into a compartment instead of an attenuated constructor

[16:43:10.0304] <bakkot>
personally I would just put it at the top level namespace, named `wait` or something

[16:43:16.0275] <bakkot>
`await wait(500)` etc

[16:50:53.0854] <sirisian>
Maybe I'm blanking since I forget proposals. Has anyone suggested an operator like f??.() that is equivalent to `typeof f === 'function' ? f() : f` ?

[16:56:55.0622] <sirisian>
bakkot: `await wait(Temporal.Duration.from({ milliseconds: 500 }))` heh

[16:57:29.0814] <bakkot>
> <@sirisian:matrix.org> Maybe I'm blanking since I forget proposals. Has anyone suggested an operator like f??.() that is equivalent to `typeof f === 'function' ? f() : f` ?

nnnnno I don't think so. that seems kind of niche


2024-06-06
[17:01:30.0797] <sirisian>
I only have 3 of them in my codebase. Very niche.

[17:02:43.0748] <whosy>
Speaking of niche.. I haven't come across a use-case for that specifically, but I have on occasion wished there was something like a `Symbol.self` for use when accessing an object's properties.
e.g. `x[Symbol.self] === x`

It's weird that my need for this has occurred more than a few times in the past year. (Easy to get around, but still)

[17:04:12.0041] <bakkot>
Also seems pretty niche? and since the only way for that to work would be to put it on Object.prototype I think we would not want that

[17:04:45.0076] <bakkot>
both because new things on Object.prototype are scary in several ways, and because it wouldn't work everywhere and it would be very annoying for `x[Symbol.self]` to just not work when `x` happens to have a null prototype

[22:13:44.0183] <littledan>
@bakkot My previous assumption was that we in TC39 would be uncomfortable adding wait because we don’t have a concept of an event loop. Also we would need host integration for stuff like banning it in worklets. But I guess at this point we have other features that get at each of those things (eg Atomics.waitAsync)

[22:15:49.0161] <littledan>
But at the same time I don’t see a huge disadvantage to using the scheduler namespace (that’s all it amounts to; it’s not like the scheduler object has state) given that we are trying to share APIs across web and non-web environments, WinterCG-style

[22:15:49.0784] <littledan>
Are there particular design mistakes we might make with scheduler?

[22:18:50.0440] <bakkot>
I have not thought about scheduler at all and trust the people working on it to do it reasonably well

[22:19:27.0799] <bakkot>
but "I want to wait for a period of time" is a much more primitive operation than the rest of that API so it seems a shame to require people to think about the much more complex thing in order to get access to the simple thing

[22:33:07.0811] <littledan>
So I am curious how you feel about the situation with getting random bytes with crypto, which seems like an analogous situation. In both cases, there is just a funny lowercase namespace, no state in the object, and it is possible to implement just that method on the object without the rest of the API if you are subsetting the web platform.

[23:03:34.0768] <bakkot>
it may be the security person in me but `crypto` feels like a very reasonable place to be reaching for a large quantity of random bytes

[23:04:36.0782] <bakkot>
my problem with `scheduler` is not that it's a namespace per se, just that the namespace is kind of a powertool which is likely to be confusing to people who don't need it, whereas `crypto` it's pretty obvious what it does and what it's for 

[05:39:42.0791] <littledan>
I'm not aware of any big arguments for why it must be in scheduler, maybe it just feels right to people working on it. In any case, if we want this in TC39, someone should bring a proposal to committee; I'm not sure how much active work there is on scheduler.wait, if any (not that it needs much work).

[06:21:23.0512] <Michael Ficarra>
does anyone know why `Math.sqrt` is implementation-approximated in JS?

[06:22:14.0508] <Michael Ficarra>
Dan Gohman (@sunfishcode) says that wasm has it fully-defined and implementations are actually compatible because they defer to a single hardware instruction on all of their supported architectures

[06:22:26.0813] <Michael Ficarra>
so why would we allow approximation?

[06:22:27.0938] <littledan>
that's just what we do for all of those functions, like sin/cos too. My understanding was that it's always been that way, or something.

[06:23:13.0304] <littledan>
A proposal to make these things more fully-defined sounds like a great idea to me, if implementations are up for it (historically V8 wanted to take shortcuts, not sure how they feel right now)

[06:26:25.0384] <Michael Ficarra>
well V8 is already doing fully determined sqrt in wasm

[06:26:40.0632] <littledan>
right I'm optimistic

[06:27:02.0314] <Michael Ficarra>
I haven't looked recently at whether implementations disagree on some results of sqrt, but I believe they used to

[06:27:03.0809] <littledan>
I think historical goals around not regressing Octane by making things more accurate have fallen away

[06:27:45.0211] <Michael Ficarra>
also maybe the hardware support just wasn't there 10 years ago

[08:51:50.0271] <Michael Ficarra>
I opened a needs-consensus PR: https://github.com/tc39/ecma262/pull/3345

[08:53:05.0623] <Michael Ficarra>
it'd be great if someone did the investigation to confirm that modern implementations do indeed already agree on all sqrt input/output pairs

[09:03:14.0830] <bakkot>
you'd need to ensure this was the case on all the hardware they each support also

[10:02:49.0538] <leftmostcat (UTC-7)>
It looks like the process for adding a time constraint to the agenda is just to commit directly and push it; is that the case, or should I PR it?

[10:03:35.0243] <Chris de Almeida>
please always PR

[10:03:48.0718] <Chris de Almeida>
even if you immediately merge it without review/approval

[10:05:18.0213] <leftmostcat (UTC-7)>
Alright, thanks. I just saw a couple that looked to have been added without PRs, hence the question.

