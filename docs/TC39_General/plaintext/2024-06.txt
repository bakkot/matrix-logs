2024-06-01
[17:02:03.0584] <jmdyck>
In general, the parser should, at any point, know the set of terminal symbols (input elements) that could validly occur next, given everything to the left. On the basis of that set, it can tell the lexer which InputElementFoo nonterminal to use as the start symbol for the next input element.

[18:24:05.0343] <sirisian>
Thanks for all that information. That helps clarify things for me.

[04:50:56.0070] <jmdyck>
A different formulation would have the parser, at each point, tell the lexer all the terminal symbols that it's expecting, and ask for one of those. That would eliminate the InputElementFoo nonterminals and the rules about when each is appropriate, and a few other nonterminals like CommonToken. So simpler in some sense. But the current formulation minimizes the information that goes from the parser to the lexer, so simpler in a different sense.


2024-06-05
[15:55:17.0220] <whosy>
I wonder if there's any want for a `Promise.sleep( duration )`. I find myself writing one-liners for this in many a project.
e.g.
`const sleep = durationMs => new Promise( resolve => setTimeout( resolve, durationMs ) );`

[15:58:52.0861] <James M Snell>
> <@whosy:matrix.org> I wonder if there's any want for a `Promise.sleep( duration )`. I find myself writing one-liners for this in many a project.
> e.g.
> `const sleep = durationMs => new Promise( resolve => setTimeout( resolve, durationMs ) );`

There are already solutions for this. scheduler.wait is mostly this. Node.js has timers/promises, etc. Given that timers tend to be implementation specific, it's likely best left as a web platform API 

[16:02:47.0786] <whosy>
Might I ask what `schedular.wait` is?
 
And I really did mean as a simple shorthand for wrapping whatever native implementation of setTimeout is in a promise.

Though I guess that does leave a big question mark about what value is returned (if any). I am very green when it comes to actual implementations and the specification side of the language, by the way.

[16:04:55.0785] <James M Snell>
`scheduler.wait(...)` is defined https://github.com/WICG/scheduling-apis ... there's more to it but it essentially allows you to do `await scheduler.wait(duration)` 

[16:07:38.0109] <whosy>
Ah, I see. I couldn't find any reference to this when I tried a quick search for npm/JavaScript or the proposals listings.

It's an interesting read, and would definitely encompass this use-case.

[16:09:04.0518] <Chris de Almeida>
> <@whosy:matrix.org> I wonder if there's any want for a `Promise.sleep( duration )`. I find myself writing one-liners for this in many a project.
> e.g.
> `const sleep = durationMs => new Promise( resolve => setTimeout( resolve, durationMs ) );`

`setTimeout` is not part of JS

[16:12:06.0675] <Chris de Almeida>
the longer answer is that in order to get some flavor of `sleep()`, you would have to add various other things in the language first in order to support it

[16:12:32.0675] <whosy>
> <@softwarechris:matrix.org> `setTimeout` is not part of JS

Yes..that's something I only considered and realised after thinking about the differing return types across implementations. As I said in the thread now, I am very much not clued in on the language spec. I've mostly just used the language without considering its development until very recently.

But the lack of a spec-defined timing mechanism, I'm guessing is why the aforementioned Scheduler API is being developed?

[16:13:51.0441] <snek>
even if the core js language had timers, the web would still need a more complex scheduling api. you can read the details about that in the scheduling api readme

[16:15:43.0452] <Chris de Almeida>
I can't speak to the motivation of the folks that advanced Scheduler, but if you already have an environment where you have production-ready foundational components available, like timing, eventing, and cancellation, and that environment is the same one in which you want to have `sleep()`, then that seems like a faster path to that goal

[16:17:56.0442] <Chris de Almeida>
that doesn't mean it can't be pursued in the language, or that it's not still useful to add to the language

[16:20:50.0448] <bakkot>
I very much hope `scheduler.wait` does not become the way to do this, but it seems pretty likely unfortunately 

[16:21:25.0676] <bakkot>
we generally try to avoid duplicating things on the web platform, so if that ships it will not be in the language probably

[16:23:41.0732] <whosy>
> <@bakkot:matrix.org> we generally try to avoid duplicating things on the web platform, so if that ships it will not be in the language probably

That was my immediate concern as well. At this point the only way to avoid duplication is to adopt part of the spec into the language, or to try and rush through a proposal to the same effect faster than Scheduler.wait it can be adopted into major browsers.
Both of which have their own challenges and pitfalls..

[16:24:32.0596] <whosy>
Or I guess option 3, create a stage-0 proposal and just ask them very nicely to drop parts of their work which..I also don't see happening.

[16:29:12.0236] <whosy>
I am quite possibly the least qualified person to speak of what should or shouldn't be done here though, so I actually would love to hear the opinions of veterans on the matter.

[16:37:50.0855] <kriskowal>
> <@softwarechris:matrix.org> `setTimeout` is not part of JS

Me too, though I called it delay in Q, and the ocap folks (like me) would insist it go on a different namespace that the otherwise I/O free Promise since we prefer to be able to pass Promise into a compartment instead of an attenuated constructor

[16:43:10.0304] <bakkot>
personally I would just put it at the top level namespace, named `wait` or something

[16:43:16.0275] <bakkot>
`await wait(500)` etc

[16:50:53.0854] <sirisian>
Maybe I'm blanking since I forget proposals. Has anyone suggested an operator like f??.() that is equivalent to `typeof f === 'function' ? f() : f` ?

[16:56:55.0622] <sirisian>
bakkot: `await wait(Temporal.Duration.from({ milliseconds: 500 }))` heh

[16:57:29.0814] <bakkot>
> <@sirisian:matrix.org> Maybe I'm blanking since I forget proposals. Has anyone suggested an operator like f??.() that is equivalent to `typeof f === 'function' ? f() : f` ?

nnnnno I don't think so. that seems kind of niche


2024-06-06
[17:01:30.0797] <sirisian>
I only have 3 of them in my codebase. Very niche.

[17:02:43.0748] <whosy>
Speaking of niche.. I haven't come across a use-case for that specifically, but I have on occasion wished there was something like a `Symbol.self` for use when accessing an object's properties.
e.g. `x[Symbol.self] === x`

It's weird that my need for this has occurred more than a few times in the past year. (Easy to get around, but still)

[17:04:12.0041] <bakkot>
Also seems pretty niche? and since the only way for that to work would be to put it on Object.prototype I think we would not want that

[17:04:45.0076] <bakkot>
both because new things on Object.prototype are scary in several ways, and because it wouldn't work everywhere and it would be very annoying for `x[Symbol.self]` to just not work when `x` happens to have a null prototype

[22:13:44.0183] <littledan>
@bakkot My previous assumption was that we in TC39 would be uncomfortable adding wait because we don’t have a concept of an event loop. Also we would need host integration for stuff like banning it in worklets. But I guess at this point we have other features that get at each of those things (eg Atomics.waitAsync)

[22:15:49.0161] <littledan>
But at the same time I don’t see a huge disadvantage to using the scheduler namespace (that’s all it amounts to; it’s not like the scheduler object has state) given that we are trying to share APIs across web and non-web environments, WinterCG-style

[22:15:49.0784] <littledan>
Are there particular design mistakes we might make with scheduler?

[22:18:50.0440] <bakkot>
I have not thought about scheduler at all and trust the people working on it to do it reasonably well

[22:19:27.0799] <bakkot>
but "I want to wait for a period of time" is a much more primitive operation than the rest of that API so it seems a shame to require people to think about the much more complex thing in order to get access to the simple thing

[22:33:07.0811] <littledan>
So I am curious how you feel about the situation with getting random bytes with crypto, which seems like an analogous situation. In both cases, there is just a funny lowercase namespace, no state in the object, and it is possible to implement just that method on the object without the rest of the API if you are subsetting the web platform.

[23:03:34.0768] <bakkot>
it may be the security person in me but `crypto` feels like a very reasonable place to be reaching for a large quantity of random bytes

[23:04:36.0782] <bakkot>
my problem with `scheduler` is not that it's a namespace per se, just that the namespace is kind of a powertool which is likely to be confusing to people who don't need it, whereas `crypto` it's pretty obvious what it does and what it's for 

[05:39:42.0791] <littledan>
I'm not aware of any big arguments for why it must be in scheduler, maybe it just feels right to people working on it. In any case, if we want this in TC39, someone should bring a proposal to committee; I'm not sure how much active work there is on scheduler.wait, if any (not that it needs much work).

[06:21:23.0512] <Michael Ficarra>
does anyone know why `Math.sqrt` is implementation-approximated in JS?

[06:22:14.0508] <Michael Ficarra>
Dan Gohman (@sunfishcode) says that wasm has it fully-defined and implementations are actually compatible because they defer to a single hardware instruction on all of their supported architectures

[06:22:26.0813] <Michael Ficarra>
so why would we allow approximation?

[06:22:27.0938] <littledan>
that's just what we do for all of those functions, like sin/cos too. My understanding was that it's always been that way, or something.

[06:23:13.0304] <littledan>
A proposal to make these things more fully-defined sounds like a great idea to me, if implementations are up for it (historically V8 wanted to take shortcuts, not sure how they feel right now)

[06:26:25.0384] <Michael Ficarra>
well V8 is already doing fully determined sqrt in wasm

[06:26:40.0632] <littledan>
right I'm optimistic

[06:27:02.0314] <Michael Ficarra>
I haven't looked recently at whether implementations disagree on some results of sqrt, but I believe they used to

[06:27:03.0809] <littledan>
I think historical goals around not regressing Octane by making things more accurate have fallen away

[06:27:45.0211] <Michael Ficarra>
also maybe the hardware support just wasn't there 10 years ago

[08:51:50.0271] <Michael Ficarra>
I opened a needs-consensus PR: https://github.com/tc39/ecma262/pull/3345

[08:53:05.0623] <Michael Ficarra>
it'd be great if someone did the investigation to confirm that modern implementations do indeed already agree on all sqrt input/output pairs

[09:03:14.0830] <bakkot>
you'd need to ensure this was the case on all the hardware they each support also

[10:02:49.0538] <leftmostcat (UTC-7)>
It looks like the process for adding a time constraint to the agenda is just to commit directly and push it; is that the case, or should I PR it?

[10:03:35.0243] <Chris de Almeida>
please always PR

[10:03:48.0718] <Chris de Almeida>
even if you immediately merge it without review/approval

[10:05:18.0213] <leftmostcat (UTC-7)>
Alright, thanks. I just saw a couple that looked to have been added without PRs, hence the question.

[10:17:09.0546] <Chris de Almeida>
yes, people do that, and it's acceptable, but not ideal 🙂

[11:09:19.0417] <shu>
what's the difference?

[11:21:19.0035] <Michael Ficarra>
@shuyuguo:matrix.org whether people watching the repo get pinged about it or not

[11:33:44.0025] <Michael Ficarra>
Dan Gohman brings up another good point: should we put some kind of lower bound on what we mean by "implementation-approximated"? Should a `Math.cos` that only returns `1` or `-1` be considered compliant?

[12:09:23.0031] <ljharb>
we definitely should, and we’ve talked about that in plenary multiple times - generally speaking everyone seemed positive on it, but nobody was confident about having the expertise required to do so correctly

[12:13:04.0754] <bakkot>
I frankly don't think it's worth spending time on

[12:13:09.0169] <bakkot>
it's not like we offer a certification

[12:21:27.0774] <shu>
oh man what a great idea

[12:21:35.0483] <shu>
i want one of those holographic gold stickers

[12:22:30.0488] <Chris de Almeida>
> We are pleased to announce that our JavaScript engine has been officially certified as compliant with the ECMAScript (ECMA-262) specification. This certification was achieved through rigorous testing using the comprehensive Test262 suite, the official conformance test suite for the ECMAScript Language Specification maintained by TC39, the technical committee responsible for the standardization of ECMAScript.

[12:27:39.0799] <Michael Ficarra>
apparently there was real web compat issues in the past when Chrome made significant compromises to their trig functions in the name of speed

[12:27:54.0730] <Michael Ficarra>
so there's probably *something* that should be said about accuracy

[12:29:07.0671] <ljharb>
i agree

[12:29:17.0092] <ljharb>
 * i agree (and remember those compat issues viscerally)

[12:29:38.0252] <Michael Ficarra>
@ljharb:matrix.org you got any links to issues?

[12:29:47.0069] <Michael Ficarra>
we should collect them in an ecma262 issue

[12:30:47.0075] <ljharb>
https://github.com/compat-table/compat-table/issues/392#issuecomment-70381406 i think?

[12:30:58.0133] <ljharb>
https://github.com/es-shims/es6-shim/commit/90c803f68390dd13fd5297b1e2d54d44f8dac94b is where i patched it in es6-shim

[12:37:54.0127] <Michael Ficarra>
started an issue: https://github.com/tc39/ecma262/issues/3347

[16:00:12.0581] <littledan>
> <@michaelficarra:matrix.org> apparently there was real web compat issues in the past when Chrome made significant compromises to their trig functions in the name of speed

The web had to adapt to the reality and learn to avoid those functions… this stuff often goes in multiple directions. If we can nail something down, I think it’s often helpful. Approximate rules are *sometimes* helpful if designed to achieve a particular goal; not sure what we would be going for in a case like this.

[16:06:49.0358] <Michael Ficarra>
littledan: what we'd be going for is guidance for how to build a web-compatible JavaScript engine. I think we can list certain constraints on many of the trigonometric functions such as symmetry, monotonicity, and bounds. We would only describe constraints that hold across engines today and that a reasonable person may expect to hold.


2024-06-07
[09:47:42.0521] <Chris de Almeida>
plenary: gentle reminder to please add any and all schedule constraints as soon as possible


2024-06-15
[19:36:20.0598] <jmdyck>
Anthony Bullard: The GNU project's coding standard for C recommends a space before the open-paren in a function call: https://www.gnu.org/prep/standards/standards.html#index-spaces-before-open_002dparen

[19:37:00.0641] <Anthony Bullard>
> <@jmdyck:matrix.org> Anthony Bullard: The GNU project's coding standard for C recommends a space before the open-paren in a function call: https://www.gnu.org/prep/standards/standards.html#index-spaces-before-open_002dparen

Yeah, GNU is Allman from what I remember or heavily influenced by it

[19:42:01.0223] <jmdyck>
My impression is that Allman style deals with indentation and brace-placement, not space-before-left-paren: https://en.wikipedia.org/wiki/Indentation_style#Allman_style

[08:21:16.0400] <Timo Tijhof>
It seems various ES specs have problems with their table of contents (there's an uncaught JS error in the console). At least ES8.0 and ES7.0 both don't seem to be able to expand sections in the TOC, and can't search either. https://262.ecma-international.org/8.0/

[08:21:59.0588] <Timo Tijhof>
Are these generated by something under TC39 on GitHub?

[08:22:20.0722] <Timo Tijhof>
 * It seems various ES specs have problems with their table of contents (there's an uncaught JS error in the console, using latest Firefox). At least ES8.0 and ES7.0 both don't seem to be able to expand sections in the TOC, and can't search either. https://262.ecma-international.org/8.0/

[10:56:11.0973] <bakkot>
Timo Tijhof: Looks like some of the asset links got broken. Those ones are handled by ECMA, not github; the ones on github are fine: https://tc39.es/ecma262/2016/

[10:57:19.0143] <bakkot>
cc littledan ljharb I don't know what the best way to report issues to ecma's webmaster is, but the stylesheets and scripts in https://262.ecma-international.org/8.0/ currently have the wrong sources

[10:57:51.0548] <bakkot>
 * Timo Tijhof: Looks like some of the asset links got broken. Those ones are handled by ECMA, not github; the ones on github are fine: https://tc39.es/ecma262/2017/

[11:01:09.0962] <ljharb>
i think I’ve reported that one before :-/ i usually just email Patrick and cc samina. Feel free to do so and cc me, or else i can do it later today 

[13:15:55.0092] <littledan>
Aki: ?

[13:24:47.0605] <Aki>
Y’all report like you normally world and I’ll look into it on my end. (I have zero access to all that but maybe I could)


2024-06-16
[16:07:21.0336] <littledan>
> <@akirose:matrix.org> Y’all report like you normally world and I’ll look into it on my end. (I have zero access to all that but maybe I could)

Sounds like it wouldn’t hurt to cc you in that email then


2024-06-17
[21:38:59.0164] <ljharb>
 * i think I’ve reported that one before :-/ i usually just email Patrick and cc samina. Feel free to do so and cc me, or else i can do it later today (or this weekend, or monday)

[14:33:59.0384] <Chris de Almeida>
anyone know where I can find the full changelog for Chrome 126 ?  the blog style changelog doesn't account for a regression I'm seeing 

[14:34:08.0701] <Chris de Almeida>
 * anyone know where I can find the full changelog for Chrome 126 ?  the blog-style changelog doesn't account for a regression I'm seeing 

[14:36:24.0178] <shu>
you want the list of commits?

[14:37:05.0009] <Chris de Almeida>
I'll take whatever I can get 🙂

[14:39:41.0359] <shu>
probably easier to say what your regression is

[14:42:13.0837] <shu>
otherwise this is the branch head for 126, good luck: https://chromium.googlesource.com/chromium/src.git/+log/refs/branch-heads/6478

[14:45:09.0972] <Chris de Almeida>
iframe load event not firing on bound listener

[14:49:42.0673] <Chris de Almeida>
our code has been stable for...  5 years at least?  and it's only started failing in Chrome 126, passes in FF.  we do a simple bind to `load` for an iframe, then set `src` and that load event tells us the page is loaded.  that has just started to fail intermittently, but consistently

[14:50:17.0990] <Chris de Almeida>
 * our code has been stable for...  5 years at least?  and it's only started failing in Chrome 126, passes in FF and in Chrome <126.  we do a simple bind to `load` for an iframe, then set `src` and that load event tells us the page is loaded.  that has just started to fail intermittently, but consistently

[14:51:38.0410] <Chris de Almeida>
 * our code has been stable for...  5 years at least?  and it's only started failing in Chrome 126, passes in FF and in Chrome \<126.  we do a simple bind to `load` for an iframe, then set `src` and that load event tells us the page/iframe is loaded.  that has just started to fail intermittently, but consistently

[14:52:05.0104] <Chris de Almeida>
the page _is_ loaded.  I can see it.. but the `load` event doesn't fire

[14:52:18.0046] <shu>
file an issue?

[14:52:30.0027] <shu>
someone hopefully triages and tries to repro, and if they can, then try to bisect

[14:52:46.0430] <Chris de Almeida>
sure.. I was hoping to track down any noticeable changes in the release first.  prefer not to throw stuff over the wall right away

[14:53:10.0031] <Chris de Almeida>
 * sure.. I was hoping to track down any noticeable (related) changes in the release first.  prefer not to throw stuff over the wall right away

[14:53:25.0051] <shu>
https://chromestatus.com/roadmap if it's at feature granularity and the feature owner remembers to update

