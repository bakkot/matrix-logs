2024-06-01
[17:02:03.0584] <jmdyck>
In general, the parser should, at any point, know the set of terminal symbols (input elements) that could validly occur next, given everything to the left. On the basis of that set, it can tell the lexer which InputElementFoo nonterminal to use as the start symbol for the next input element.

[18:24:05.0343] <sirisian>
Thanks for all that information. That helps clarify things for me.

[04:50:56.0070] <jmdyck>
A different formulation would have the parser, at each point, tell the lexer all the terminal symbols that it's expecting, and ask for one of those. That would eliminate the InputElementFoo nonterminals and the rules about when each is appropriate, and a few other nonterminals like CommonToken. So simpler in some sense. But the current formulation minimizes the information that goes from the parser to the lexer, so simpler in a different sense.


2024-06-05
[15:55:17.0220] <whosy>
I wonder if there's any want for a `Promise.sleep( duration )`. I find myself writing one-liners for this in many a project.
e.g.
`const sleep = durationMs => new Promise( resolve => setTimeout( resolve, durationMs ) );`

[15:58:52.0861] <James M Snell>
> <@whosy:matrix.org> I wonder if there's any want for a `Promise.sleep( duration )`. I find myself writing one-liners for this in many a project.
> e.g.
> `const sleep = durationMs => new Promise( resolve => setTimeout( resolve, durationMs ) );`

There are already solutions for this. scheduler.wait is mostly this. Node.js has timers/promises, etc. Given that timers tend to be implementation specific, it's likely best left as a web platform API 

