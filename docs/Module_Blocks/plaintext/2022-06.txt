2022-06-07
[06:15:25.0845] <Surma>
I feel like the biggest open question is whether module blocks are cached by source position or not. I think it might be most efficient to just have an incubator call about this. Anyone not okay with that? And how do I schedule one officially? ðŸ˜…

[06:15:26.0545] <Surma>
https://github.com/tc39/proposal-js-module-blocks/issues/45

[06:17:14.0183] <Jack Works>
Isn t my `unique` solution good enough? ðŸ˜‚

[06:17:50.0733] <Surma>
Well, Iâ€™m kinda changing my opinion that all module blocks should be cached by source position

[06:18:26.0233] <Surma>
so that would make that extra syntax moot ðŸ˜…

[06:18:44.0052] <Surma>
I hope we can avoid additional syntax

[08:09:15.0238] <ljharb>
an incubator call would be good. to have one, during plenary when incubator call chartering happens, we'd add module blocks. ping shu to give him a heads up

[09:23:33.0248] <Kris Kowal>
Surma: Youâ€™re also welcome at the SES Strategy meetings at 10am Pacific. https://docs.google.com/document/d/1FZ95-NZIQE9fw3A8Sgcz2BKep6MlC_Kng0dlf1ehabQ/edit#heading=h.f8mfwudm59mq

[09:24:35.0060] <Kris Kowal>
Weâ€™re stepping up spec work on Compartments and it would be good to get in sync.

[09:39:24.0251] <Jack Works>
> <@kriskowal:matrix.org> Surma: Youâ€™re also welcome at the SES Strategy meetings at 10am Pacific. https://docs.google.com/document/d/1FZ95-NZIQE9fw3A8Sgcz2BKep6MlC_Kng0dlf1ehabQ/edit#heading=h.f8mfwudm59mq

Is SES meeting still happen in the tc39 meetings week?

[09:41:10.0179] <Kris Kowal>
No SES meeting the week of plenary, ever. We also usually cancel the week after plenary to give folks a rest.


2022-06-22
[05:11:26.0953] <nicolo-ribaudo>
Surma I plan to review the proposal this week; do you still plan to include module function shorthands? Or should I ignore that part?

[05:19:58.0739] <Surma>
I don't think I'll include it in the mvp

[05:20:07.0828] <Surma>
Thanks for taking a look! Really appreciate it

[05:39:17.0173] <littledan>
We had a pretty extensive discussion about module blocks in the "loader" chat

[05:39:49.0898] <littledan>
ultimately it underscored for me the conclusion that we probably want to say, if you postMessage a module block multiple times, you get a different identity/module map entry each time

[05:40:05.0371] <littledan>
nicolo-ribaudo: Did you see this discussion? What did you think?

[05:42:14.0582] <nicolo-ribaudo>
I still haven't caught up with that discussion (it happened during the night for me), but I'll have an opinion by the end of the day

[05:42:39.0509] <littledan>
we can talk it over later today if you want; there was a lot of back-and-forth and it's not necessary that you read it all

[05:43:41.0521] <nicolo-ribaudo>
Oh btw Surma, it would probably be good for you to join the biweekly TC39 Module Loading call (the next one is on July 6th, you can check the TC39 calendar for the time in your local time zone)

[05:45:10.0273] <Surma>
> <@littledan:matrix.org> ultimately it underscored for me the conclusion that we probably want to say, if you postMessage a module block multiple times, you get a different identity/module map entry each time

I haven't caught up, but i agree with the conclusion :D

[05:45:29.0138] <Surma>
> <@nicolo-ribaudo:matrix.org> Oh btw Surma, it would probably be good for you to join the biweekly TC39 Module Loading call (the next one is on July 6th, you can check the TC39 calendar for the time in your local time zone)

I thought i was on the list?? I didn't know one already happened 

[05:45:37.0704] <littledan>
ah OK someone thought you were pushing the other direction

[05:46:53.0220] <Surma>
> <@littledan:matrix.org> ah OK someone thought you were pushing the other direction

No, but one thought experiment I had was what happens if I send a block to a worker, and the worker sends it straight back. Is it desirable that we restore identity? 

[05:48:25.0650] <nicolo-ribaudo>
> <@surma:matrix.org> I thought i was on the list?? I didn't know one already happened

You can find the notes at https://github.com/tc39/Reflector/issues/436#issuecomment-1154620771 (and some slides from Kris in the notes). Mostly Kris presented their vision of how all the proposals interact together by going through the slides, and how some can be re-explained in terms of the others.


2022-06-23
[23:12:39.0236] <Kris Kowal>
Just to register my personal preference regarding module blocks and idempotence: import(module {}) should be analogous to eval. The module should always be evaluated and should not be memoized, even by a gensym. That would provide a consistent experience even in the case where the module gets transported or returned. Also means that the loader doesnâ€™t retain the resulting graph of module instances, so some things could be collected earlier. That doesnâ€™t preclude user code memoizing the result, even using the identity of the block as a memo key. In short, I strongly prefer to avoid inconsistent behavior between local and remote versions of import(block).

[00:25:56.0671] <nicolo-ribaudo>
Kris Kowal On the other hand `import("data:text/javascript, ...")` is memoized, and it's the closest thing we have to module blocks 

[00:27:18.0420] <nicolo-ribaudo>
Even if being a primitive does not suffer from the structured clone problem 

[02:11:09.0321] <littledan>
> <@surma:matrix.org> No, but one thought experiment I had was what happens if I send a block to a worker, and the worker sends it straight back. Is it desirable that we restore identity?

My intuition is, it'd be cool if it did, but also I don't see why anyone should depend on that

[02:12:35.0235] <littledan>
> <@kriskowal:matrix.org> Just to register my personal preference regarding module blocks and idempotence: import(module {}) should be analogous to eval. The module should always be evaluated and should not be memoized, even by a gensym. That would provide a consistent experience even in the case where the module gets transported or returned. Also means that the loader doesnâ€™t retain the resulting graph of module instances, so some things could be collected earlier. That doesnâ€™t preclude user code memoizing the result, even using the identity of the block as a memo key. In short, I strongly prefer to avoid inconsistent behavior between local and remote versions of import(block).

This is a little hard for me to square with, if you use module fragments and have a little module subgraph with a diamond import pattern, you clearly don't expect cloning in that case, or do you?

[07:47:26.0561] <Kris Kowal>
I would expect one fresh instance of each module in the subgraph. The subgraph does not need to be memoized by the loader in order to achieve idempotence within the subgraph.

[07:49:37.0310] <Kris Kowal>
That is to say, I think we agree that importing a module fragment should not produce more than one instance of each of the transitively imported module fragments.

[07:50:21.0857] <Kris Kowal>
But I do think itâ€™s acceptable for each dynamic import of a module fragment to instantiate exactly one fresh copy of the module fragment subgraph.

[08:05:39.0580] <Kris Kowal>
One of the things that I learned from our last conversation, that I quite like, is that every module fragment has an equivalent source text, effectively a single static module record that can be cached on the identity of the fragment. That also implies that it is content addressable and can be cached as a document or in transit. So thereâ€™s a lot to recommend that as a feature of transportability.

[08:06:57.0223] <Kris Kowal>
But caching the content doesnâ€™t necessarily require memoization of the instances. Instantiating a module fragment essentially means instantiating a list of blocks. All of this is of course provisional, assuming that the idea of lexically named module blocks is popular here.

[08:08:47.0932] <Kris Kowal>
 * But caching the content doesnâ€™t necessarily require memoization of the instances. Instantiating a module fragment essentially means instantiating a list of blocks. All of this is of course provisional, assuming that the idea of lexically named module blocks is popular here.

[08:13:55.0898] <Kris Kowal>
But, Iâ€™ll concede this idea holds no water at all if thereâ€™s a hope that itâ€™ll eventually be possible for a module fragment to be imported or exported between modules. If thereâ€™s a hope that would be eventually possible, I think thatâ€™s a very different design world.

[08:15:37.0404] <Kris Kowal>
(In that world, I would hold the opposite opinion: that fragments should be memoized, but by virtue of being contained within another module that is memoized by full/referrer specifier, and that fragments would not be transportable without the entirety of the surrounding document.)

[08:41:53.0536] <littledan>
I think this would make module fragments unusable for the bundling case

[08:42:34.0208] <littledan>
for example, `module x { console.log("happened"); } module y { import x; } module z { import x; } module w { import y; import x; } import x;`

[08:42:40.0430] <littledan>
this should really print "happened" just once

[08:42:49.0605] <littledan>
otherwise we're doing something new and different from how modules work normally

[08:50:29.0553] <littledan>
as Guy pointed out, the internal representation need not mention gensyms, just a bunch of recursive data structures, which can be transported as such (some serializations may need to create a gensym/counter but this is just a local thing; it doesn't leak out)

[08:50:51.0450] <littledan>
HTML structured clone, for one, doesn't need gensyms and is fine with just having a recursive structure

[08:51:04.0246] <littledan>
(of course implementations don't actually work like that, just the spec formalism)

[10:10:51.0078] <Kris Kowal>
> <@littledan:matrix.org> this should really print "happened" just once

I agree and think that can be coherent with dynamic import printing "happened" once more each time.

[10:11:24.0785] <littledan>
Hmm, I also think the dynamic import behavior should match

[10:11:49.0953] <Kris Kowal>
I can sympathize with that.

[10:11:52.0070] <littledan>
This is also something which would inhibit bundlers from using module fragments as an output format

[10:12:08.0928] <Kris Kowal>
I do not think that follows.

[10:13:37.0986] <Kris Kowal>
Iâ€™ll mull on the tension between these motivations some more.

[10:14:05.0989] <nicolo-ribaudo>
The problem with bundlers that Dan is trying to show is that if you have this code:

```js
// main.js
await import("./dep.js");
await import("./dep.js");

// dep.js (different file)
console.log("Hi!");
```

you cannot (if `import()` re-evaluates module blocks) rewrite it to a single file like

```js
// bundle.js

import main;

module main {
  await import(dep);
  await import(dep);
}

module dep {
  console.log("Hi!");
}
```

[10:14:32.0154] <nicolo-ribaudo>
 * The problem with bundlers that Dan is trying to show is that if you have this code:

```js
// main.js
await import("./dep.js");
await import("./dep.js");

// dep.js (different file)
console.log("Hi!");
```

you cannot (if `import()` re-evaluates module blocks) rewrite it to a single file like

```js
// bundle.js

import main;

module main {
  await import(dep);
  await import(dep);
}

module dep {
  console.log("Hi!");
}
```

[10:15:35.0160] <Kris Kowal>
I see. So behind door A, we get an inconsistency in behavior between static and dynamic import, behind door B, we get an inconsistency between local and remote dynamic import.

[10:16:26.0201] <nicolo-ribaudo>
By "remote" do you mean "I pass a dynamic import to a worker, and that worker would re-evaluate it"?

[10:16:44.0609] <nicolo-ribaudo>
Or "I pass it to a worker, then the worker passes it back to me, and I will re-evaluate it"?

[10:17:13.0044] <nicolo-ribaudo>
worker = compartment, or realm, or something else

[10:19:36.0034] <nicolo-ribaudo>
I wonder if we could attach an "unique id" to every module block, similar to the shared registered symbols registry, so that when I receive it back `import()` can give me back the same module namespace

[10:20:12.0134] <nicolo-ribaudo>
 * I wonder if we could attach an "unique id" to every module block, similar to the shared registered symbols registry, so that when I receive it back `import()` can give me back the same module namespace. The "id to namespace" cache would be per-realm, but the id needs to be globally unique

[10:20:33.0801] <nicolo-ribaudo>
 * I wonder if we could attach an "unique numeric id" to every module block, similar to the shared registered symbols registry, so that when I receive it back `import()` can give me back the same module namespace. The "id to namespace" cache would be per-realm, but the id needs to be globally unique

[10:21:47.0666] <nicolo-ribaudo>
This would mean that module namespaces coming from module blocks cannot be garbage collected until the realm is collected, but that's already true for namespaces coming from "file modules"

[10:29:01.0693] <Kris Kowal>
I presume that if module fragments are idempotent within the lifecycle of a loader (where currently, loader === realm), then they are necessarily retained by the loader.

[10:30:21.0162] <nicolo-ribaudo>
Oh true you are right. I was thinkng about module blocks ("expressions") that coud otherwise be collected when they become unreachable

[10:35:28.0441] <ljharb>
"static and dynamic" seems like a much more important consistency to maintain imo

[10:52:33.0412] <Kris Kowal>
Iâ€™m leaning to agree, if thereâ€™s no way to have both.

[10:53:50.0371] <Kris Kowal>
> <@nicolo-ribaudo:matrix.org> I wonder if we could attach an "unique numeric id" to every module block, similar to the shared registered symbols registry, so that when I receive it back `import()` can give me back the same module namespace. The "id to namespace" cache would be per-realm, but the id needs to be globally unique

I believe integrating a fragment id into the module memo key is necessary if module blocks and fragments are memoized.

[10:55:30.0933] <Kris Kowal>
Thinking aloud, it also follows that the ModuleBlock is stable across evaluations of the same block. Theyâ€™re lexical but not lexical closures, so no need for a fresh identity.

[10:56:28.0533] <Kris Kowal>
So having a sequential index as an internal slot of ModuleBlock within a document would work fine.

[10:57:30.0829] <nicolo-ribaudo>
Note that there are two things: the identity of the object retunred by the `module {}` syntax, and the identity of the internal module:
```js
function getModule() { return module {} }

getModule() === getModule();
await import(getModule()) === await import(getModule());
```

are you talking about both, or only the second one?

[10:57:36.0747] <Kris Kowal>
Again, thinking aloud, unless they have shared mutable state, in which case a fresh instance closing over the same ID should also be fine.

[10:58:02.0275] <nicolo-ribaudo>
Ok, you were already answering ðŸ˜‚

[11:00:00.0605] <Kris Kowal>
Yeah, I was thinking through the former case. Regardless of whether theyâ€™re identical, they would have the same value for the module block sequential number internal slot.

[11:00:23.0582] <Kris Kowal>
In order for the answer for the latter case to be true.

[12:36:00.0035] <Kris Kowal>
Continuing to think aloud, with the approach of sequentially numbering blocks in order to preserve idempotence locally, to stretch that property to another loader (today, just realms), the wire representation of a block or fragment would have to capture the entirety of the originating document, or send each fragment individually with the content address of the surrounding document and the sequential id within the original document.

[12:38:25.0963] <Kris Kowal>
Daniel, Guy and I discussed a couple days ago an approach where every block could have its own static module record that captures just the subgraph of its transitive lexical fragments. That form would not be able to preserve idempotence if it were sent as a value to another realmâ€™s import function.

[12:44:56.0361] <Kris Kowal>
But, you *could* preserve idempotence if the arrangement is that the remote loader pulls in the original static module records of the surrounding document and the import(ModuleBlock) sends the referrer and sequential ID of the block/fragment. The arrangement presumes that the sender and receiver both have the same loader hooks.

[14:09:20.0451] <littledan>
I think it's OK if passing a value to the remote end makes a copy of it, and it's observable that there was one thing on the sender end and two things on the receiver end. This is how structured clone works for objects, after all

[14:09:42.0461] <littledan>
(maybe I'm missing something in the above discussion)

[14:59:12.0552] <Kris Kowal>
I donâ€™t disagree. Iâ€™m just suggesting the compromise is avoidable.

[15:36:16.0291] <Kris Kowal>
 * I donâ€™t disagree. Iâ€™m just thinking that the compromise might be avoidable.

[15:38:11.0220] <Kris Kowal>
 * I agree that the trade-off is acceptable for structured clone. Iâ€™m less convinced that modules are comparable. Iâ€™m just thinking that the compromise might be avoidable.


2022-06-24
[19:33:49.0620] <littledan>
Well, this is an interesting area to talk through but I am having trouble seeing what is wrong with the design I have been proposing 

[19:34:38.0151] <littledan>
Yes, other transport mechanisms may have other properties and as a result be simpler

