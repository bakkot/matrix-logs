2019-12-03
[23:23:56.0000] <devsnek>
I've been doing some experiments with radix trees for unicode name literals in strings

[23:24:24.0000] <devsnek>
it looks like a serialized map in memory would be around 800kb

[23:25:29.0000] <devsnek>
significantly less than the 4mb of a hashmap

[23:26:43.0000] <devsnek>
mathiasbynens: ^

[23:27:12.0000] <mathiasbynens>
devsnek: makes sense

[23:27:36.0000] <devsnek>
i don't remember the exact numbers you were talking about before, but does that sound more reasonable?

[23:27:57.0000] <mathiasbynens>
i mean, less is better

[23:28:05.0000] <mathiasbynens>
i didn't provide any specific numbers

[23:28:17.0000] <mathiasbynens>
but imho, even that 800 kb doesn't pay for itself

[23:28:55.0000] <mathiasbynens>
this would be a feature that minifiers "undo" anyhow

[23:29:48.0000] <Bakkot>
yeah, that's not a trivial cost to users, relative to the benefit they'd get

[23:29:54.0000] <Bakkot>
still want to make a babel plugin for it tho

[23:29:58.0000] <Bakkot>
or, ideally, have someone else do that

[23:30:09.0000] <Bakkot>
(

[23:30:23.0000] <Bakkot>
"users" meaning end users, i.e. people who open websites, not people who design them

[23:30:24.0000] <Bakkot>
)

[23:30:46.0000] <devsnek>
yeah i don't think it improves much for websites

[23:31:13.0000] <devsnek>
but it pops up enough for me that i have revisited the idea once or twice :P

[23:31:20.0000] <Bakkot>
make the plugin!

[23:31:28.0000] <devsnek>
i looked at that a few months ago actually

[23:31:56.0000] <devsnek>
i couldn't figure out how to test it or develop it

[23:32:10.0000] <Bakkot>
should ask in the babel slack; they were pretty responsive, last I checked

[23:32:25.0000] <devsnek>
perhaps i'll take a look later

[23:32:47.0000] <devsnek>
i think the main problem is that i wouldn't bother with it if it was a babel plugin

[23:32:52.0000] <devsnek>
since i rarely ever use build tooling at all

[23:32:53.0000] <Bakkot>
adding new syntax is a bit tricky; in some cases you can just extend the parser, but usually you'd have to actually add it to the parser and then the plugin just enables or disables the option

[23:32:59.0000] <Bakkot>
mm, yeah

[23:35:08.0000] <devsnek>
i bet variable length encoding the codepoints could make the blob smaller, but that would make parsing take longer

[23:58:32.0000] <Bakkot>
you could just start using build tooling

[00:02:54.0000] <devsnek>
hmm using finite state trees i get the map down to 200kb

[00:03:29.0000] <devsnek>
the data isn't searchable in place though

[00:03:40.0000] <devsnek>
at least not with the lib i'm testing

[00:04:06.0000] <devsnek>
and it assumes all the values are 64 bits, instead of 32 bits

[00:04:42.0000] <devsnek>
i'd imagine specializing for the data and keys we have it could be 200kb and also support lookups in place

[13:34:03.0000] <JemYoung>
Hello! Can someone add me as a delegate so I can access the queue?

[13:34:19.0000] <Bakkot>
cc akirose

[13:35:40.0000] <akirose>
https://github.com/tc39/Admin-and-Business/issues/12 üòù

[13:35:42.0000] <akirose>
on it

[13:37:29.0000] <JemYoung>
Reopened issue with proper names :)

[13:37:55.0000] <akirose>
JemYoung: done

[13:38:03.0000] <JemYoung>
Thanks!


2019-12-04
[10:50:11.0000] <tantek>
/me hello! I think I should be joined properly now.

[10:51:06.0000] <ljharb>
tantek: you're here in the public channel :-) ping bterlson for an invite to the private one

[10:51:22.0000] <tantek>
/me thanks ljharb!

[12:41:45.0000] <zuojian>
Hi everyone, I am new comer from UC Browser, Alibaba. Also new to the IRC tool.

[12:47:27.0000] <bnb>
We‚Äôre (myself, Yulia, Shelley) stuck downstairs. Could anyone find someone to help us come up?

[13:03:38.0000] <ljharb>
bnb: wrong channel, but someone's on the way

[13:03:40.0000] <ljharb>
zuojian: welcome!

[13:04:02.0000] <bnb>
Thank you - I was told to post it in all the channels üòÖ

[13:04:33.0000] <ljharb>
lol then o7

[13:05:36.0000] <michaelficarra>
haxjs: are you in the call?

[13:22:10.0000] <metanomial>
I had an idea for a possible class enum block syntax. Looking for a second opinion on this approach to enumerations. https://gist.github.com/metanomial/5cda898056970287b8b85424934bbddf?ts=4

[13:23:10.0000] <ljharb>
metanomial: i replied to your discourse with links to two enum proposals; have you reviewed those?

[13:23:23.0000] <metanomial>
I did

[13:23:43.0000] <ljharb>
and how does your proposal differ from those?

[13:44:40.0000] <metanomial>
Both of those proposals are syntactic sugar to declare objects of constants. The second proposal was a little more flexible, allow enumerators to be passed to constructor functions before definition. The idea I linked above is syntactic sugar for quickly constructing static fields/instances in a class. I have updated my gist to show static

[13:44:40.0000] <metanomial>
instances in the current class syntax.

[13:46:04.0000] <ljharb>
metanomial: ok so it seems like yours is restricted to when you want your enums to be instances of the same class, which imo doesn't match many use cases for enums

[13:46:27.0000] <ljharb>
metanomial: iow to me, it doesn't seem like "sugar for static properties that are always instances of the class" is worth syntax

[13:58:34.0000] <TabAtkins>
I think I agree - that takes almost exactly as many characters to do in today's syntax, with `Color.RED = new Color(0xff0000);`/etc immediately following the class definition.

[13:59:13.0000] <TabAtkins>
And I agree that's not what many (/most?) of the calls for "enums" are asking for.

[13:59:22.0000] <ljharb>
and with class fields you can do `static RED = new Color(0xff0000)`

[14:41:16.0000] <metanomial>
Fair points. Here is a second example showing demo usage. https://gist.github.com/metanomial/5cda898056970287b8b85424934bbddf?ts=4#file-example2-js

[14:49:09.0000] <TabAtkins>
metanomial: So that looks like you're implementing a lot of useful enum functionality in userland; the enum itself is providing almost no additional benefit here besides moving the instance declarations around in the file.

[14:49:44.0000] <TabAtkins>
If we're doing enums, a lot of this stuff should be provided automatically, imo.

[14:54:49.0000] <metanomial>
Another fair point. I'll think on it a bit. Thank you for the feedback


2019-12-05
[16:56:26.0000] <jwalden>
is there a specification anywhere for //# sourceURL=... ?

[16:56:52.0000] <ljharb>
jwalden: source maps might be in html, but def aren't in JS

[16:56:52.0000] <michaelficarra>
jwalden: it's a google doc

[16:57:05.0000] <michaelficarra>
do you still want it?

[16:57:13.0000] <jwalden>
michaelficarra: yeah, I could use it

[16:57:42.0000] <michaelficarra>
jwalden: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit

[16:57:44.0000] <jwalden>
michaelficarra: it looks like Firefox just is not going to enforce *at all* //# sourceURL=... if it appears inside a function body, unless that function body is "use asm" or some other very obscure edge cases

[16:57:58.0000] <jwalden>
presumably most people just do it top-level and are fine, but

[16:58:22.0000] <devsnek>
inside eval

[16:58:27.0000] <michaelficarra>
jwalden: find "Linking generated code to source maps" in that doc

[16:59:53.0000] <jwalden>
devsnek: inside eval you have just a regular Script, so e.g. eval("function f() {\n//# sourceURL=https://example.com/foo.js\n}\nalert(new Error().stack);") would trigger what I'm talking about

[17:00:11.0000] <devsnek>
oh wow

[17:04:06.0000] <jwalden>
michaelficarra: what's supposed to happen if I have more than one //# sourceURL=... comment in a script?

[17:04:19.0000] <jwalden>
michaelficarra: does the last one apply, or the first one, or what?

[17:04:37.0000] <michaelficarra>
jwalden: I know *of* the spec, I am not an expert or the author

[17:04:46.0000] <jwalden>
bah :-)

[17:05:03.0000] <michaelficarra>
also, it's hard to call it a spec

[17:05:19.0000] <michaelficarra>
it's a loosely-written design doc

[17:05:50.0000] <jwalden>
yeah :-|

[17:06:00.0000] <jwalden>
SpiderMonkey appears to just apply the last one observed

[17:09:46.0000] <michaelficarra>
jwalden: if you know nick fitzgerald, you may be able to learn more

[17:10:04.0000] <jwalden>
:-) I could poke him for sure

[17:11:05.0000] <michaelficarra>
good luck

[17:11:15.0000] <jwalden>
this is of course not how specifications are supposed to work!

[17:11:19.0000] <jwalden>
/me cantankers

[17:12:59.0000] <michaelficarra>
jswalden: I've been trying to get the Sentry folks to adopt that doc and add some rigour

[17:13:11.0000] <michaelficarra>
they are heavy users of source maps and it would be in their interest that they work well

[17:13:34.0000] <Bakkot>
CSP is an _actual_ spec and has similar problems

[17:13:37.0000] <michaelficarra>
if you learn of such an effort, let me know, I'm interested

[17:14:11.0000] <michaelficarra>
CSP doesn't count

[17:14:28.0000] <Bakkot>
why not it should

[17:23:00.0000] <jwalden>
sadly, my suspicion is I ought not let myself get nerd-sniped by this, given I was looking into very different issues


2019-12-06
[13:24:12.0000] <rickbutton>
anyone know the historical reason for this? in 14.3.1 Static Semantics: Early Errors: "It is a Syntax Error if ContainsUseStrict of FunctionBody is true and IsSimpleParameterList of UniqueFormalParameters is false." (https://tc39.es/ecma262/#sec-method-definitions-static-semantics-early-errors)

[13:24:12.0000] <rickbutton>
i.e. why (function() { return { method(...foo) { "use strict"; } } })() isn't valid

[13:26:53.0000] <ljharb>
rickbutton: parsing difficulties

[13:27:21.0000] <rickbutton>
ah, gotcha, thx

[13:27:33.0000] <ljharb>
rickbutton: because otherwise the engine has to parse the entire arg list - which might include default args, which might themselves create functions that may or may not be in strict mode - before getting to the body's strict pragma, which then might mean it needs to interpret all that arg stuff differently

[13:27:38.0000] <ljharb>
that's my understanding, at least

[13:28:08.0000] <rickbutton>
right, that makes sense

[13:34:36.0000] <devsnek>
Bakkot: btw that bug in chrome, it looks to be evaluating it without the side effect detection ebaled

[13:34:39.0000] <devsnek>
enabled*


2019-12-07
[18:38:16.0000] <Bakkot>
devsnek: huh. I wonder why

[18:38:53.0000] <devsnek>
Bakkot: weird devtools logic

[18:39:06.0000] <devsnek>
it looks like it doesn't enable it if it's just a member expression

[18:39:11.0000] <devsnek>
which is very odd

[18:39:37.0000] <devsnek>
and why I couldn't repro in my node thing


2019-12-09
[22:20:45.0000] <mathiasbynens>
devsnek, Bakkot: what's the Chrome DevTools bug? please file it if you haven't already, thanks

[00:21:52.0000] <devsnek>
mathiasbynens: reported already https://bugs.chromium.org/p/chromium/issues/detail?id=1031243

[00:24:40.0000] <devsnek>
mathiasbynens: devtools seems to be doing a local parse of the input and using that to decide if it has side effects

[00:25:14.0000] <devsnek>
which seems counter intuitive to the existence of v8's side effect detection

[01:34:45.0000] <mathiasbynens>
devsnek: agreed... we should just rely on V8 here instead of trying to "guess" with broken heuristics

[01:35:34.0000] <mathiasbynens>
we're fixing it! thanks for pointing that out

[11:37:40.0000] <avp>
Can someone explain https://www.ecma-international.org/ecma-262/10.0/#sec-block-level-function-declarations-web-legacy-compatibility-semantics to me, please? In particular, I've got the following code: https://pastebin.com/Zx0VNUaj and I want to know where its behavior is specified

[11:38:50.0000] <avp>
it seems like it'd have to do with (3.) in that list, but it does say that "No other declaration of f that is not a var declaration occurs within the function code of g" - there is a `let bar = 3` which fails that condition

[11:40:02.0000] <Bakkot>
avp the notes at the beginning of the section are just of historical interest - they're documenting cases where browsers agreed before this was specified in ES2015

[11:40:08.0000] <Bakkot>
the actual changes are in B.3.3.1

[11:40:21.0000] <Bakkot>
sidebar: you should use the living spec at https://tc39.es/ecma262/#sec-block-level-function-declarations-web-legacy-compatibility-semantics

[11:41:06.0000] <avp>
Bakkot: thanks, i'll try and use that section to reconcile my mental model

[11:42:10.0000] <rkirsling>
B.3.3 is notoriously the most cursed section of the spec though

[11:42:20.0000] <rkirsling>
so don't feel bad for being confused :p

[11:43:34.0000] <Bakkot>
the basic semantics are: when you have `function f(){ x() }` within a block, and you could replace that with a `var f` without getting a syntax error, then the semantics of the function are 1) you add a `var f;` to the top of the _containing_ function, 2) you add a `let f = function(){ x() }` at the top of the containing _block_ and 2) when control reaches the actual function declaration within the block, you read from the `let f` and

[11:43:35.0000] <Bakkot>
 write to the `var f`

[11:43:43.0000] <Bakkot>
ugh, that second 2) should be a 3) obviously

[11:44:46.0000] <avp>
Bakkot: that helps a lot - deciphering the intent of B.3.3.1 was daunting

[11:57:20.0000] <Bakkot>
avp also you should use strict mode so this doesn't happen :P

[12:01:55.0000] <rkirsling>
JSC has bugs for B.3.3 early errors that I've been too scared to fix

[12:04:02.0000] <Bakkot>
everyone does

[12:04:04.0000] <Bakkot>
the spec does

[12:04:25.0000] <Bakkot>
https://github.com/tc39/ecma262/issues/913 etc

[12:19:12.0000] <devsnek>
it's functions all the way down

[13:13:46.0000] <rkirsling>
> dysfunction all the way down

[13:13:46.0000] <rkirsling>
FTFY

[13:38:59.0000] <bradleymeck>
Object.assign(Object.prototype,{get:()=>{}, set:(v)=>{}, value:undefined}); wrecks so much

[13:39:22.0000] <bradleymeck>
it kinda seems like you have to use null prototypes to guard against it

[13:45:47.0000] <ljharb>
bradleymeck: ? what key are you trying to defineProperty there?

[13:49:01.0000] <bradleymeck>
none, just if Object.prototype has all 3 of those keys Object.defineProperty stops working unless you use null prototypes like Object.defineProperty(obj, 'propname', {__proto__:null, value: 'value'})

[13:49:20.0000] <bradleymeck>
since it sees stuff up the proto chain and says it can't be both an accessor and data prop

[13:49:40.0000] <bradleymeck>
was staring at my node pr and noticed we don't guard this currently

[13:49:43.0000] <ljharb>
ohhhhh wow i just realized what you mean

[13:50:02.0000] <ljharb>
i wonder if it'd be web compatible to change that somehow

[13:50:29.0000] <bradleymeck>
well idk but running that little script on all my open tabs killed all of them except some static sites

[13:50:51.0000] <bradleymeck>
likely we can't change it though

[13:51:59.0000] <ljharb>
we can't make it be own properties i'm sure, but i wonder if we could effectively make it be "Get" but stop before Object.prototype

[13:52:16.0000] <bradleymeck>
that seems pretty weird too

[13:52:18.0000] <devsnek>
better question

[13:52:24.0000] <devsnek>
who is doing Object.assign(Object.prototype,{get:()=>{}, set:(v)=>{}, value:undefined})

[13:52:52.0000] <bradleymeck>
me, checking to see if we survive it in node (we don't)

[13:53:15.0000] <bradleymeck>
once you get implicit set hooks things look pretty dicey about data exfiltration across modules

[13:53:32.0000] <bradleymeck>
but ü§∑ this is more just locking down stuff to survive craziness

[13:53:57.0000] <bradleymeck>
we had a couple of people snooping internals and doing bad things in the long past and we started to move to primordials in part because of that

[13:54:56.0000] <devsnek>
i remember symbol polyfills were able to patch node

[13:55:08.0000] <devsnek>
so that util.inspect and stuff worked with them

[13:55:52.0000] <bradleymeck>
causing it to always error by filling out both get/set always or value is probably good enough honestly

[13:56:39.0000] <bradleymeck>
ideally we would use some null proto shenanigans but slowdown on benchmarks is pretty bad

[13:57:47.0000] <devsnek>
i just don't see why its worth guarding against

[13:57:53.0000] <ljharb>
bradleymeck: another alternative is that the error for "no get/set + value" could be made to only throw when get/set is not undefined, instead of just present

[13:58:13.0000] <ljharb>
bradleymeck: that way you'd always be able to locally override the shenanigans with `get: undefined, set: undefined` for data properties

[13:58:25.0000] <ljharb>
altho i guess that wouldn't protect you for accessors

[13:58:46.0000] <bradleymeck>
devsnek: same thing as why any other part of the runtime is worth being robust

[13:59:12.0000] <devsnek>
i don't really get the overall goal tbh

[14:00:18.0000] <ljharb>
user code shouldn't be able to break the platform?

[14:00:57.0000] <bradleymeck>
mostly its to get reliable behavior when things go wrong, node has access to things like shell execution and often people send authorization strings to node in various ways, you don't want people snooping on strings and you don't want shell execution to happen. it gets hard to understand what a user can accidently load (see all those malicious packages people install) and have it undermine the default platform APIs

[14:01:40.0000] <devsnek>
malicious code can just `require('inspector')` and read every value of every variable in the entire codebase

[14:01:49.0000] <bradleymeck>
so, make it just ignore anything strange and/or make it survive anything strange to avoid leaking data or allow accidental execution. accidental execution is hard to avoid in JS

[14:02:07.0000] <bradleymeck>
devsnek: not if you use a policy that doesn't allow it

[14:02:17.0000] <bradleymeck>
which is why we have started making efforts to use em

[14:02:51.0000] <devsnek>
assuming the code you've explicitly pulled in is malicious is like

[14:03:11.0000] <devsnek>
you've already lost

[14:03:21.0000] <devsnek>
you either need full isolation

[14:03:25.0000] <bradleymeck>
devsnek: we work with developers who install 3rd party code all the time. you build up layers of defenses like anything else

[14:03:25.0000] <devsnek>
or you need to trust the code somehow

[14:03:43.0000] <bradleymeck>
even with full isolation you can get confusion problems that make the isolated payload malicious

[14:04:08.0000] <devsnek>
seems like an inherently losing battle tbh

[14:04:42.0000] <ljharb>
devsnek: the entire concept of SES is winning that battle, isn't it?

[14:04:46.0000] <ljharb>
or attempting to

[14:05:00.0000] <devsnek>
ü§∑üèª

[14:05:08.0000] <bradleymeck>
i think security always will be a race of sorts yea. though i don't think we are really trying to prevent everything, but instead make auditing feasible

[14:05:20.0000] <devsnek>
i think SES solves a symptom of the problem

[14:05:22.0000] <devsnek>
not the problem

[14:05:48.0000] <bradleymeck>
even reading code line by line myself i'm not fully confident in it not having some odd effect (i had one with a sticky regexp today!)

[14:06:09.0000] <ljharb>
bradleymeck: wait you had a real use case for the sticky flag??

[14:06:22.0000] <bradleymeck>
ljharb: i saw it being used and i removed it

[14:06:30.0000] <bradleymeck>
cause lastIndex was being weird with .search

[14:06:55.0000] <bradleymeck>
anyways, i do want to use shell commands so it isn't like i can ever really trust anything

[14:08:19.0000] <ljharb>
aha

[14:08:55.0000] <bradleymeck>
ljharb: the idea was to match the last " in a quoted string but it wasn't working right

[14:09:23.0000] <devsnek>
misplaced sticky flags won't exfiltrate your tokens

[14:10:16.0000] <bradleymeck>
devsnek: no, but it did change a parser and we got bad data that bypassed some checks!

[14:15:30.0000] <devsnek>
you can always keep structured data structured... bugs exist of course but these systems aren't inherently fallible

[14:20:01.0000] <Bakkot>
devsnek: not all data is provided to you in a structured format; you can't get away from parsing untrusted input sometimes

[14:20:36.0000] <bradleymeck>
even if it is structured it can be bad to intake naively ("__proto__" from json payloads)

[14:20:54.0000] <devsnek>
I mean the output of the parser

[14:21:15.0000] <devsnek>
it's still the output of the parser, and you can know it may be unsafe


2019-12-11
[23:52:19.0000] <devsnek>
if we get tuples in js, advent of code will become a lot easier, because a lot of their challenges use maps of (x, y)

[07:12:49.0000] <bradleymeck>
devsnek: why not use literals for those?

[07:13:16.0000] <bradleymeck>
new Map([[x,y],[a,b]]) is often forgotten too :(

[09:45:47.0000] <Bakkot>
It is pretty easy to write an n-key map class

[09:57:46.0000] <bradleymeck>
Bakkot: it could be easier

[09:57:57.0000] <Bakkot>
sure but you do it once and then it is done

[09:58:53.0000] <bradleymeck>
depends on if the base class adds apis

[09:59:00.0000] <bradleymeck>
if it adds apis you do it again

[09:59:30.0000] <Bakkot>
if it adds APIs your map will not automatically update to have those APIs, yes

[09:59:39.0000] <Bakkot>
(depending on how they are implemented...)

[09:59:40.0000] <Bakkot>
but no existing applications will break

[09:59:48.0000] <bradleymeck>
yup

[10:00:25.0000] <bradleymeck>
even if they are implemented through delegating to existing interfaces it might be odd

[10:00:37.0000] <Bakkot>
Potentially yes

[10:00:50.0000] <bradleymeck>
like .has could be false but .get could return a value if we add default values that are not undefined

[10:00:50.0000] <Bakkot>
also when I've done this in the past I haven't actually done `extends Map`

[10:00:57.0000] <bradleymeck>
interesting

[10:01:14.0000] <Bakkot>
(since it doesn't really keep the interface for map)

[12:22:01.0000] <devsnek>
bradleymeck: you need identity of the x and y

[12:22:22.0000] <devsnek>
(x, y) === (x, y)

[12:22:24.0000] <bradleymeck>
Symbol.compositeKey would be nice~

[12:22:29.0000] <devsnek>
yeah

[12:22:38.0000] <devsnek>
I guess there's also that frozen proposal

[12:22:41.0000] <bradleymeck>
that probably won't go anywhere fast though :(

[12:22:48.0000] <bradleymeck>
mine/compositeKey

[12:22:59.0000] <bradleymeck>
value types seem to have some momentum

[12:25:07.0000] <devsnek>
I just hope they allow all types inside

[12:34:38.0000] <bradleymeck>
i'd not be ok with that unless they change intent of the proposal a bit

[12:34:47.0000] <bradleymeck>
though if they do change stated intent seems doable

[12:37:22.0000] <devsnek>
it seems kinda useless if it can't hold objects tbh

[12:37:50.0000] <devsnek>
like private fields, I'd use them every once in a blue moon but not as a generalized pattern

[12:39:08.0000] <bradleymeck>
if serializable and stateless is the critical use case holding objects would be problematic. if immutable but allowing state is the critical use case holding refs seems fine.

[12:39:35.0000] <devsnek>
you can have them without objects inside them even if objects are allowed

[12:39:54.0000] <devsnek>
and even then, think of JSON.serialize on an object with a function property

[12:40:03.0000] <devsnek>
er

[12:40:07.0000] <devsnek>
JSON.stringify

[12:40:27.0000] <bradleymeck>
?

[12:42:22.0000] <devsnek>
I don't get why one person wanting to restrict it means another person can't also use it more liberally

[12:43:09.0000] <bradleymeck>
depends, but if the more liberal use makes it hard to assert the more constrained use holds true in various cases thats usually a reason

[12:43:41.0000] <devsnek>
I mean it's a trade off either way

[12:43:55.0000] <devsnek>
the more constrained case literally makes it impossible for the more liberal use case

[12:44:09.0000] <bradleymeck>
yea, like you said its a trade off

[12:46:10.0000] <devsnek>
I feel like the obvious balance would be choosing the difficult case over the impossible case

[12:46:23.0000] <devsnek>
but people consistently go the other way so ü§∑

[12:47:31.0000] <bradleymeck>
difficult enough to be impossible pretty much is just impossible

[12:50:26.0000] <devsnek>
if it's an invariant of serialisation you can throw when you hit an object

[12:50:34.0000] <devsnek>
it doesn't seem too hard imo

[12:56:58.0000] <Bakkot>
devsnek: the reason to disallow objects is that many people are going to look at these things and assume they can treat all of them as immutable and be bitten when that turns out to not be the case

[12:57:37.0000] <devsnek>
I didn't have that assumption

[12:57:59.0000] <Bakkot>
many other people will

[12:58:53.0000] <devsnek>
a lot of people also assume const makes the object it holds immutable

[12:59:06.0000] <devsnek>
like probably at least one a week in ##javascript

[12:59:25.0000] <devsnek>
should const have not been allowed to point to objects?

[13:00:04.0000] <Bakkot>
I am not entirely clear on why const exists at all, in honesty

[13:01:17.0000] <devsnek>
variables that can't change

[13:01:51.0000] <Bakkot>
that is a description of the thing, not an explanation of why it exists

[13:02:00.0000] <ljharb>
const is great, but it is definitely a confusing name

[13:02:15.0000] <devsnek>
I mean I use it as that enough to justify it as the sole reason for it's existence

[13:02:22.0000] <devsnek>
I dunno if others do

[13:02:37.0000] <ljharb>
(i like it because it conveys developer intent to not reassign a variable, which is not sufficiently conveyed by "it doesn't happen to be reassigned at the moment")

[13:03:17.0000] <devsnek>
in any case my larger point was that no matter what, there will be people who don't understand features because they assume their behaviour instead of actually learning what they do

[13:03:52.0000] <Bakkot>
of course, and that's something we always have to weigh

[13:04:01.0000] <Bakkot>
here I think most people will assume it is deeply immutable

[13:05:18.0000] <devsnek>
maybe we can make a poll or something

[13:07:58.0000] <rkirsling>
the name itself is definitely bad, but I don't understand folks not taking the time to get used to it

[13:08:37.0000] <devsnek>
we could just remove the immutability part from them

[13:08:43.0000] <devsnek>
:P

[13:10:00.0000] <rkirsling>
like, it seems that there are folks that advocate for using `let` and not `const` because `let` itself might've been a better name for what `const` does, but

[13:10:49.0000] <rkirsling>
that's really upsetting to me since at the end of the day, `const`'s behavior is exactly the desirable thing, and the name can be gotten used to...

[13:10:50.0000] <devsnek>
var was already taken though

[13:10:56.0000] <rkirsling>
yeah that's the thing

[13:11:07.0000] <rkirsling>
I love Scala's `val` / `var`

[13:11:18.0000] <ljharb>
yeah val's not bad

[13:13:24.0000] <rkirsling>
something I'm a little unclear of the timeline on is the existence of a `const` keyword in browsers

[13:13:45.0000] <rkirsling>
I feel like it existed non-functionally prior to ES6?

[13:14:09.0000] <rkirsling>
but maybe that's some headcanon of mine that developed due to the long implementation window of ES6

[13:14:24.0000] <ljharb>
rkirsling: old spidermonkey had its own const and let for awhile

[13:14:29.0000] <ljharb>
that had different semantics from ES2015's

[13:14:34.0000] <ljharb>
eventually they fixed it

[13:14:36.0000] <rkirsling>
that must be it

[13:14:49.0000] <ljharb>
in their "JavaScript 1.7" thing, or whichever version

[13:14:56.0000] <rkirsling>
ahh

[13:15:15.0000] <devsnek>
old V8 also had it's own let and const

[13:15:15.0000] <devsnek>
with weird semantics

[13:15:15.0000] <devsnek>
they weren't allowed in strict mode

[13:16:08.0000] <ljharb>
ah right that too

[13:16:21.0000] <ljharb>
i think v8's tho were early ES6 versions

[13:16:36.0000] <ljharb>
altho maybe SM's were even earlier ones, i dunno

[13:17:13.0000] <devsnek>
I'm glad node doesn't use harmony flags anymore

[13:17:15.0000] <devsnek>
lots of breakage

[14:00:04.0000] <bradleymeck>
do we have a strong assertion about run to completion semantics in JS written out anywhere/what to do if a host implements a co-routine like Job Scheduler?

[14:09:14.0000] <bradleymeck>
e.g. if a host is allowed to have `Promise.resolve().then(()=>{...;bar();...}); foo();` execute `bar()` before `foo()`

[14:10:47.0000] <ljharb>
if that isn't explicitly forbidden than ES6 has a massive gap

[14:11:11.0000] <ljharb>
i'm pretty sure it was a quite intentional part of promises that nothing that happens in a then callback can *ever* happen synchronously

[14:11:45.0000] <ljharb>
TLA changes that slightly, in that if you `await` that promise before calling `foo()`, then bar can happen before foo

[14:13:40.0000] <bradleymeck>
ljharb: i'm staring at https://github.com/nodejs/node/pull/30891

[14:14:24.0000] <ljharb>
bradleymeck: i mean, `require()` can already "sleep" if the module wants it too

[14:14:27.0000] <ljharb>
bradleymeck: via node addons

[14:14:49.0000] <bradleymeck>
ljharb: thats different though. that PR lets you unwind promises

[14:14:55.0000] <ljharb>
oh right true

[14:14:59.0000] <bradleymeck>
sleep/atomics is fine

[14:15:29.0000] <bradleymeck>
even execSync is probably fine since it isn't using exposed machinery even though it does nest JS

[14:17:37.0000] <ljharb>
but JS that can't share an env

[14:22:49.0000] <bradleymeck>
it kind of does due to the streams impl

[14:22:56.0000] <bradleymeck>
but not from the process

[14:23:10.0000] <bradleymeck>
it just inlines an event loop to resolve streams events

[14:23:21.0000] <bradleymeck>
which aren't under the promise-like invariants

[14:24:55.0000] <bradleymeck>
that isn't really exposing that stuff to userland though so ü§∑

[14:53:55.0000] <devsnek>
bradleymeck: it could never execute the inner bit first

[14:54:14.0000] <devsnek>
the only thing possible is if foo pumped the event loop, it would happen *during*

[14:54:19.0000] <devsnek>
but never *before*

[14:54:45.0000] <devsnek>
actually

[14:54:53.0000] <devsnek>
I don't know if foo pumping the event loop is allowed

[14:54:56.0000] <devsnek>
I hope it isn't

[14:55:00.0000] <bradleymeck>
i'm not clear on that, if you require out of the inner loop and grab the outer promise and await it

[14:55:12.0000] <bradleymeck>
it looks like it would resolve

[14:55:38.0000] <bradleymeck>
/me thinks this is esoteric

[14:56:26.0000] <devsnek>
I think it's safe to assume nothing will ever do that

[14:57:44.0000] <bradleymeck>
i never thought modules would delete themselves from require.cache at one point, but they do

[14:58:11.0000] <bradleymeck>
i can imagine finding an easier way to do this kind of forced resolve being possible but not obvious


2019-12-12
[20:31:02.0000] <devsnek>
ljharb: is `ChainEvaluation` supposed to link to the runtime semantic?

[20:31:42.0000] <ljharb>
devsnek: um, i'm not sure. which PR was this in and can you link me to the rendered spec?

[20:31:52.0000] <ljharb>
devsnek: linking generally is handled by ecmarkup

[20:31:58.0000] <devsnek>
https://tc39.es/ecma262/#sec-optional-chaining-evaluation

[20:32:07.0000] <devsnek>
`Return the result of performing ChainEvaluation of ...`

[20:32:12.0000] <devsnek>
ChainEvaluation there doesn't link

[20:32:41.0000] <ljharb>
i don't think any grammar things link there

[20:32:48.0000] <ljharb>
see https://tc39.es/ecma262/#sec-runtime-semantics-arrayaccumulation for example

[20:33:31.0000] <ljharb>
(by "link there", i mean, i don't think that category of thing is autolinked in general terms)

[20:33:39.0000] <devsnek>
ic

[20:33:40.0000] <devsnek>
unfortunate

[20:33:49.0000] <devsnek>
also in ChainEvaluation

[20:34:05.0000] <ljharb>
please file an ecmarkup bug if you think they should autolink tho :-)

[20:34:07.0000] <devsnek>
there are productions like `OptionalChain : OptionalChain arguments`

[20:34:14.0000] <devsnek>
and then it says "evaluate OptionalChain"

[20:34:33.0000] <devsnek>
like i know it is referring to the second one

[20:34:38.0000] <devsnek>
but it isn't immediately obvious

[20:35:31.0000] <ljharb>
an editorial PR would be helpful :-D

[20:35:51.0000] <ljharb>
not trying to pass the buck every time, just about to head out and can't track it myself rn

[20:36:25.0000] <devsnek>
np

[20:40:04.0000] <rkirsling>
I think those are ecmarkup concerns

[20:41:24.0000] <rkirsling>
cause in particular ChainEvaluation(...) was changed to ChainEvaluation of ... to align with current editorial practices but that incurred a loss of linkability

[20:42:22.0000] <rkirsling>
er sorry the latter is separate

[20:43:24.0000] <rkirsling>
that we had to fix because there's a very specific was the spec differentiates parent nonterminal Foo from child nonterminal Foo

[20:44:08.0000] <rkirsling>
it is meant to be as intuitive as one could reasonably hope for but if you can think of a way to describe it in a Notations section that might be cool

[20:44:51.0000] <devsnek>
optional chaining and nullish coalescing unflagged in engine262 üéâ

[20:44:52.0000] <rkirsling>
*...very specific way...

[20:45:14.0000] <rkirsling>
üéâ

[20:45:17.0000] <devsnek>
this one is my favourite though https://github.com/engine262/engine262/commit/7e7692de0050c5149f0dfd553c67bdb565b1174c

[20:45:53.0000] <rkirsling>
nice

[20:46:02.0000] <devsnek>
would be nice if we had like `OptionalChain_a` and `OptionalChain_b`

[20:46:39.0000] <rkirsling>
reminds me of https://trac.webkit.org/changeset/240686/webkit

[20:46:57.0000] <devsnek>
lol

[20:47:41.0000] <rkirsling>
Yeah _a and _b could be reasonable

[20:48:01.0000] <jmdyck>
In general, a syntax-directed operation will be defined in many clauses, so what would you auto-link to?

[20:48:18.0000] <devsnek>
the general heading

[20:48:31.0000] <devsnek>
https://tc39.es/ecma262/#sec-optional-chaining-chain-evaluation

[20:48:53.0000] <jmdyck>
yes, for that case there's only one clause, but in general there might be several.

[20:51:24.0000] <devsnek>
wdym there are like six there

[20:51:52.0000] <jmdyck>
"clause" = section, say

[20:52:53.0000] <jmdyck>
the spec doesn't really have a word for the construct that there's six of, but I'd call them 'definitions'

[20:58:45.0000] <jmdyck>
or emu-grammar+emu-alg pair, if I need to be explicit

[23:05:18.0000] <bathos>
I think sometimes eval rules paired with parse nodes / productions are referred to as reducers (not in the spec, just seen it elsewhere)

[23:14:01.0000] <bathos>
does anyone know what production accepts the strings '\8' and '\9' in sloppy mode? Chrome and FF both allow them (treated as identity escapes), but I‚Äôm having trouble finding an avenue that explains it. possibly this is a spec/web reality divergence, but I feel like I‚Äôm just missing something since it‚Äôs easy to get confused when looking at annex b modifications.

[23:31:09.0000] <bathos>
Oh, they allow \8 and \9 in strict mode too o:

[23:38:59.0000] <bathos>
here‚Äôs my notes from trying to figure this out as a gh gist to avoid making too much noise in here: https://gist.github.com/bathos/09171830ee14d3d7a0d9393eb07f64ca

[06:18:21.0000] <jmdyck>
looks like test262 only has \8 in regex literals.

[06:19:21.0000] <jmdyck>
but test262-parser-tests has 2 occurrences, and they're both under fail/

[07:10:30.0000] <jmdyck>
(bathos ^)

[07:31:59.0000] <bathos>
thanks ‚Äî I take it that confirms the interpretation that \8 and \9 being permitted as identity escapes in Chrome/FF is off-spec

[10:59:57.0000] <Bakkot>
it's possible test262-parser-tests is wrong; I tried to be accurate with all of them but I do not have access to any way of formally verifying their correctness

[11:04:03.0000] <bathos>
ah. well, we came to the same conclusion, anyway, which seems like a data point.

[11:04:10.0000] <Bakkot>
though this came up a while ago and I think the logic in this comment is still correct: https://github.com/jquery/esprima/issues/1502#issuecomment-230672053

[11:06:47.0000] <bathos>
yeah, that‚Äôs pretty much 1:1 with what I wrote in the gist link when trying to find all the paths

[11:13:49.0000] <Bakkot>
should probably open an ecma262 issue if there isn't one already

[11:14:30.0000] <Bakkot>
I think this was lost in the move from the old bug tracker: https://web.archive.org/web/20141214073322/https://bugs.ecmascript.org/show_bug.cgi?id=1553#c2

[11:14:35.0000] <Bakkot>
also https://mail.mozilla.org/pipermail/es-discuss/2013-March/029403.html

[11:15:03.0000] <Bakkot>
https://github.com/whatwg/javascript/issues/12

[11:15:07.0000] <Bakkot>
etc

[11:23:21.0000] <devsnek>
does anyone know if js shift is going to track 2019 and 2020 updates

[11:32:05.0000] <Bakkot>
yes, once we have time

[11:32:17.0000] <Bakkot>
assuming you mean https://shift-ast.org/index.html

[11:33:04.0000] <Bakkot>
ast spec for 2019 is done; ast spec for 2020 will get made once es2020 is done

[11:57:15.0000] <devsnek>
I'm looking for parsers to vendor into engine262

[11:57:30.0000] <devsnek>
shift looks the best so far but not updated since 2018

[11:57:41.0000] <devsnek>
I could probably help out with updating it

[12:00:23.0000] <jmdyck>
what does "vendor" mean when used as a verb?

[12:00:37.0000] <devsnek>
jmdyck: copy into my repo

[12:00:49.0000] <jmdyck>
tx

[12:01:29.0000] <devsnek>
I'm really not enjoying the "extend acorn" approach I currently use

[13:09:40.0000] <Bakkot>
devsnek: it should be pretty easy to update; there were very few syntax changes in 2019

[13:09:57.0000] <Bakkot>
happy to help with that if you actually want to try


2019-12-13
[10:40:38.0000] <jorendorff>
https://tc39.es/ecma262/#sec-numberbitwiseop seems a bit circular

[10:40:42.0000] <jorendorff>
step 3, i mean

[10:42:16.0000] <jorendorff>
& is specified in terms of Number::bitwiseAND which is specified in terms of &

[10:42:59.0000] <ljharb>
"applying the bitwise operator op" tho isn't the same as how `&` is specified, is it?

[10:43:16.0000] <jorendorff>
What does that phrase mean?

[10:43:49.0000] <ljharb>
perhaps we're missing an explicit definition for it - but the intention i think is to do math

[10:44:17.0000] <jorendorff>
yeah, i think that has to be the intention,

[10:45:02.0000] <ljharb>
ie if the op is &, it should do what previous editions did here: http://www.ecma-international.org/ecma-262/#sec-unsigned-right-shift-operator

[10:45:13.0000] <ljharb>
where it just says "compute rnum & 0x1F"

[10:45:44.0000] <ljharb>
so maybe that detailed info for each op that's in steps 7 and 8 of the last edition needs to be restored somehow?

[10:46:31.0000] <jorendorff>
wow, here's what the previous edition says about bitwise AND: http://www.ecma-international.org/ecma-262/#sec-binary-bitwise-operators-runtime-semantics-evaluation

[10:47:11.0000] <ljharb>
right, that's probably where the bigint proposal got the prose from

[10:47:13.0000] <jorendorff>
basically the same thing only instead of "op" it's called "@"

[10:47:15.0000] <jorendorff>
love it

[10:47:33.0000] <ljharb>
sounds to me like not a new bug, if it's a bug :-)

[10:47:46.0000] <jorendorff>
no indeed :)

[10:47:54.0000] <ljharb>
but if you want to make a PR that makes that clearer that'd be fine with me

[10:48:21.0000] <ljharb>
right shift has a clearer definition in old editions than && does

[10:48:23.0000] <ljharb>
* &

[10:49:04.0000] <jorendorff>
hmm. BigInt::bitwiseAND is specified in more detail. Although ... too much detail for my brain

[10:49:25.0000] <jorendorff>
I don't think I should work on this, it probably isn't bothering anyone else

[10:49:40.0000] <ljharb>
lol k

[10:49:45.0000] <ljharb>
thanks for bringing it up!

[13:21:12.0000] <bradleymeck>
https://tc39.es/ecma262/#sec-jobs-and-job-queues states that Jobs can be interleaved, but it does not clarify if that also includes preemption

[13:21:15.0000] <bradleymeck>
mmmm

[13:22:19.0000] <devsnek>
jobs must be dispatched in the correct order

[13:22:37.0000] <devsnek>
i guess it depends on your definition of "dispatched"

[13:22:58.0000] <bradleymeck>
yea, but in RunJobs the host can determine the order

[13:23:08.0000] <bradleymeck>
i don't see anything that implies a job can be paused entirely

[13:23:21.0000] <bradleymeck>
but that word is "interleaved"... oddly placed

[13:23:52.0000] <devsnek>
hmm

[13:23:53.0000] <devsnek>
`No other Job may be initiated until the currently running Job completes`

[13:24:35.0000] <devsnek>
that answers my question at least

[13:24:39.0000] <bradleymeck>
yes, "completes" i assume means all the spec work / eval runs to completion as in end of source text

[13:25:50.0000] <devsnek>
at the very least, this means the require(esm) thing is against the rules

[13:26:17.0000] <bradleymeck>
yea, reading the other things like await they never affect jobs, only the execution context stack

[13:26:55.0000] <bradleymeck>
maybe we should explicitly state preemption of the entire job is not allowed

[13:27:06.0000] <bradleymeck>
interleaved makes it a bit confusing

[13:30:59.0000] <bradleymeck>
PerformEval is a trip

[13:32:29.0000] <devsnek>
step 18 of PerformEval annoys me

[13:32:31.0000] <devsnek>
i should open a pr

[13:38:45.0000] <devsnek>
why does RunJobs offset execution cleanup

[13:38:58.0000] <devsnek>
execution contexts are cleaned up in the next iteration

[13:39:25.0000] <devsnek>
is this just for compat with InitializeHostDefinedRealm

[13:40:09.0000] <bradleymeck>
devsnek: isn't the Function null for `var`?

[13:40:21.0000] <devsnek>
hmm?

[13:40:30.0000] <bradleymeck>
> step 18 of PerformEval annoys me

[13:40:40.0000] <devsnek>
oh

[13:40:53.0000] <bradleymeck>
18. Set evalContext's Function to null.

[13:40:56.0000] <devsnek>
uhhh

[13:41:08.0000] <devsnek>
for one of the two eval call types, eval's frame is missing that eval was called

[13:41:24.0000] <devsnek>
it doesn't matter that much except for when building up stack traces

[13:42:39.0000] <devsnek>
i think its for direct calls

[13:43:31.0000] <devsnek>
yeah it is

[14:05:02.0000] <metanomial>
In my limited use of `BigInt` in Chrome and Firefox, I've found myself repeatedly writing Math.abs, Math.min, and Math.max equivalents. Is there any proposal to add something like BigInt.abs, BigInt.max, etc?

[14:05:30.0000] <devsnek>
one of the things on my todo list is changing those math methods to accept bigints

[14:07:46.0000] <metanomial>
If, say, Math.max were changed to accept BigInt values, what happens if you mix Number and BigInt arguments?

[14:07:55.0000] <devsnek>
it would throw

[14:08:08.0000] <devsnek>
actually

[14:08:18.0000] <devsnek>
relational comparison works on numbers and bigints

[14:08:36.0000] <metanomial>
But what should the return type be then?

[14:08:36.0000] <devsnek>
Math.max and Math.min could work on inputs containing both

[14:08:44.0000] <devsnek>
Number|BigInt

[14:09:02.0000] <devsnek>
well really

[14:09:09.0000] <devsnek>
a union based on the types you pass in

[14:09:28.0000] <metanomial>
So `Math.max(3, 5n)` would return `5n`, but `Math.max(5, 3n)` would return `5`?

[14:09:33.0000] <metanomial>
That seems like it could cause problems

[14:09:35.0000] <devsnek>
ü§∑üèª

[14:09:42.0000] <devsnek>
it doesn't exist yet

[14:09:45.0000] <devsnek>
lots of discussions to be had

[14:09:51.0000] <ljharb>
making math methods work with bigint is something on my list

[14:09:51.0000] <ljharb>
i might actually draw something up for february

[14:10:12.0000] <devsnek>
i'd be happy to work with you on that

[14:10:22.0000] <ljharb>
cool, i'll ping you in the next few weeks

[14:10:25.0000] <devsnek>
üéâ

[14:11:16.0000] <TabAtkins>
I think they should throw if types are mixed; yes, relational ops work on mixed inputs, but their return type isn't numeric; all the ops with numeric return types throw on mixing partially to avoid answering this question.

[14:11:36.0000] <rkirsling>
^ that does seem to be the precedent, I agree

[14:12:20.0000] <ljharb>
i think there's a few cases where we can hit a more useful bar than that - but yes, that is the precedent

[14:12:42.0000] <ljharb>
in general, anything where you'd lose information when using a Number above MAX_SAFE_INT is something that throws - not just mixing types

[14:12:57.0000] <ljharb>
relational comparison isn't a place like that, so it doesn't throw

[14:13:57.0000] <metanomial>
Wouldn't it be less error-prone and more readable to just add `BigInt.abs`, `BigInt.max`, etc. static methods?

[14:14:16.0000] <devsnek>
maybe(tm)

[14:14:22.0000] <devsnek>
i'd rather use the existing methods

[14:14:25.0000] <devsnek>
it's cleaner imo

[14:14:30.0000] <devsnek>
there's a lot of bikeshedding to be done though

[14:14:53.0000] <metanomial>
Moving away from the static methods entirely, here is an alternative idea for BigInt absolute value: https://gist.github.com/metanomial/18695b95517d0b78bb882ffe78ce16dd?ts=4

[14:15:37.0000] <devsnek>
if math didn't already exist i'd be all over that

[14:16:30.0000] <metanomial>
Why not just leave Math to Number types?

[14:16:51.0000] <ljharb>
metanomial: that's something we'll have to consider, but it's much nicer to have "math" methods be able to do *math* with all the number types :-)

[14:16:59.0000] <ljharb>
because math isn't about number, math is a pure thing

[14:17:26.0000] <devsnek>
well it was pure until -0 came around

[14:17:56.0000] <Bakkot>
A bunch of the math stuff doesn't make sense for bigints

[14:17:59.0000] <Bakkot>
cos, etc

[14:18:32.0000] <ljharb>
also true

[14:18:33.0000] <Bakkot>
(or at least acos)

[14:18:34.0000] <metanomial>
Math as a general purpose set of methods would probably be more useful if there were well known symbols for describing "number" types and operator overloading

[14:18:37.0000] <ljharb>
and those would continue to throw

[14:19:26.0000] <devsnek>
the entire definition of math rn is pretty scary

[14:19:32.0000] <ljharb>
but yeah basically the options are something like 1) make some of the math methods support bigints where it's intuitive, 2) keep Math for Number, and add BigInt static methods, setting a precedent for BigDecimal as well, 3) add bigint and number prototype methods and effectively deprecate the math methods (seems weird to me), 4) do nothing

[14:19:51.0000] <devsnek>
`Each of the following Math object functions applies the ToNumber abstract operation to each of its arguments (in left-to-right order if there is more than one). If ToNumber returns an abrupt completion, that Completion Record is immediately returned.`

[14:19:58.0000] <devsnek>
fun prose

[14:20:15.0000] <metanomial>
Opt 4 is a terrible option. I'm going to be writing BigInt utilities to the end of time

[14:20:27.0000] <ljharb>
lol

[14:20:33.0000] <ljharb>
metanomial: i agree

[14:20:37.0000] <devsnek>
whatever the case

[14:20:51.0000] <devsnek>
we should definitely support clz32

[14:20:53.0000] <devsnek>
:D

[14:24:25.0000] <rkirsling>
I think 2 may be the most reasonable given the lack of "integer math" ops to this point (like Bakkot was saying)

[14:24:40.0000] <rkirsling>
1 would probably be fine with ample throw cases though.

[14:25:13.0000] <ljharb>
rkirsling: right, i think 1 or 2 are the two options to suggest, once the committee agrees on the problem :-)

[14:25:13.0000] <ljharb>
rkirsling: i have a preference for 1, because it just doesn't make any sense to me that "Math" doesn't work on bigints

[14:25:29.0000] <ljharb>
rkirsling: but maybe after i audit all the math methods and come up with a table, i'll change my mind, i dunno

[14:25:41.0000] <devsnek>
i'm also a fan of 1

[14:25:48.0000] <rkirsling>
yeah I'm not opposed

[14:26:09.0000] <rkirsling>
we definitely need some solution

[14:26:40.0000] <rkirsling>
and something that allows a path for bigdec would be good (whatever that means)

[14:26:51.0000] <devsnek>
Math.clz32(1f)

[14:26:59.0000] <devsnek>
or is that 1d

[14:27:52.0000] <rkirsling>
wow I did not realize that already existed

[14:28:05.0000] <ljharb>
rkirsling: right, potential conflicts with BigDecimal would be unacceptable

[14:32:34.0000] <metanomial>
I feel like opt 1 could lead to obscure bugs. You could have an instance where a collection of `{Number|BigInt}` has been getting passed to Math.xyz successfully for a while, because the collection by serendipity was all of one type. But then after an unrelated code change, the collection suddenly starts holding mixed types and `Math.xyz` throws

[14:32:35.0000] <metanomial>
errors about it.

[14:33:34.0000] <ljharb>
metanomial: the collection changing type unexpectedly would break every option

[14:35:44.0000] <metanomial>
But it wouldn't *change* type. The developer could have documented that the collection was `{Number|BigInt}`, and have been unsafely passing the collection through `Math.xyz`. Then at a later time, a distance change in code causes the bug to come to a head.

[14:36:07.0000] <ljharb>
metanomial: right but that's just a bug

[14:36:23.0000] <ljharb>
metanomial: it could be documented as just Number and still suddenly start receiving a bigint

[14:37:41.0000] <metanomial>
My point is that it could become difficult to debug. `Math.xyz` would accept `{Number|BigInt}`, and the collection would be of type `{Number|BigInt}`, and yet it would be throwing an error.

[14:38:20.0000] <devsnek>
i'm confused about what this bug is

[14:38:30.0000] <devsnek>
but this doesn't sound like the fault of Math.xyz's accepted types

[14:38:32.0000] <rkirsling>
given the precedent for mixing to throw, I don't think it'd be very easy to have such a collection without a lot of conscious guarding

[14:38:48.0000] <ljharb>
i'm not clear on why it's difficult to debug

[14:39:24.0000] <metanomial>
I'll write up a quick example

[14:39:26.0000] <ljharb>
you'd get an exception that you mixed a bigint and a number, and you'd trace it back to where some caller was assuming it wouldn't be mixed

[14:40:54.0000] <ljharb>
thanks!


2019-12-14
[18:22:04.0000] <metanomial>
ljharb: My hesitancy about opt 1 was probably unfounded. I messed around with mixed-types-throws a bit, and superficially it seems like it is always easy enough to debug.

[19:37:09.0000] <ljharb>
metanomial: that's good to hear, thanks for testing it out

[19:38:37.0000] <metanomial>
That being said, I still personally favor Opt 2, just for clarity. But it's not hard to get used to Opt 1

[19:53:18.0000] <metanomial>
`Math.symbol.<method>`? https://gist.github.com/metanomial/76189a1d82602f6624837641e438d6be?ts=4

[20:02:05.0000] <ljharb>
a new protocol seems pretty overkill to me

[20:02:14.0000] <ljharb>
let alone a dozen

[20:02:55.0000] <ljharb>
it's too early to focus on the solution tho, that's a stage 1 thing. this isn't any stage yet :-)

[23:08:51.0000] <devsnek>
is there any difference between  `obj?.a?.b` and `(obj?.a)?.b`

[23:13:52.0000] <devsnek>
i don't think there is

[23:30:36.0000] <ljharb>
devsnek: not in that case, but `obj?.a.b` and `(obj?.a).b` are different

[23:30:44.0000] <devsnek>
yes

[23:31:59.0000] <devsnek>
i really need to stop using estree in engine262 üòû

[10:16:07.0000] <metanomial>
I often see multiple `Object.definePropert(y|ies)` in groups, and it just makes for ugly code. Would a definition operator shorthand be useful?

[10:17:21.0000] <metanomial>
`a = "foo"; // [[Set]]`

[10:17:21.0000] <metanomial>
`a := { value: "foo" }; // [[Define]]`

[10:41:35.0000] <bathos>
convenient for some folks (self included), sure. worth the confusion for everybody else ... seems unlikely?

[10:45:26.0000] <metanomial>
It would make for much cleaner code inside of classes if you could define fields outside of the constructor.

[10:50:59.0000] <bathos>
Is that not addressed by the instance fields proposal?

[10:51:17.0000] <bathos>
(https://github.com/tc39/proposal-class-fields)

[10:53:56.0000] <bathos>
(InitializeInstanceFields -> DefineField -> CreateDataPropertyOrThrow -> CreateDataProperty -> [[DefineOwnProperty]])

[10:55:00.0000] <bathos>
No room for setting configurability, etc there, so maybe that doesn‚Äôt help for your case.

[11:07:17.0000] <metanomial>
Class fields already use [[Define]] semantics. `:=` would just allow additional properties beyond `value` when defining fields

[11:13:15.0000] <metanomial>
https://gist.github.com/metanomial/e0c56861af0c3cfaf0268c6aa30bdb82?ts=4

[12:46:42.0000] <ljharb>
adding that syntax was suggested as part of class fields, to make = be Set and := be Define.

[12:46:47.0000] <ljharb>
i doubt it would be possible now.


2019-12-17
[10:03:35.0000] <jmdyck>
Anyone out there have permission to add Labels to ecmarkup PRs? https://github.com/bterlson/ecmarkup/pull/165 should be labelled Bug.

[10:27:05.0000] <bterlson>
jmdyck: I can. I'm also transferring to tc39/ecmarkup soon hopefully

[10:27:42.0000] <jmdyck>
will it be Someone Else's Problem then?

[10:28:12.0000] <bterlson>
Presumably ljharb's since he asked! üòÇ

[10:28:20.0000] <ljharb>
:-p

[10:28:28.0000] <rkirsling>
:ohyou:

[10:32:02.0000] <jmdyck>
tx for the label, bterlson


2019-12-18
[07:04:12.0000] <bradleymeck>
didn't object iteration order have a clarification in the past year or so?

[08:49:55.0000] <ljharb>
bradleymeck: for-in order hit stage 4 last meeting

[10:05:47.0000] <bradleymeck>
ljharb: perhaps that "exports" PR in node should specify OrdinaryOwnKeys ordering?

[10:06:00.0000] <bradleymeck>
since that doesn't seem to have changed anytime

[14:10:43.0000] <ljharb>
bradleymeck: it should specify `Reflect.ownKeys` ordering yes, not `for-in` ordering

[14:11:06.0000] <bradleymeck>
so own keys doesn't actually specify insertion ordering since it goes to a slot

[14:11:42.0000] <ljharb>
no? i was under the impression there were only two orderings; for-in (and things that obey it) and whatever ownKeys calls into

[14:11:54.0000] <ljharb>
but i thought both were insertion order

[15:02:06.0000] <bradleymeck>
ljharb: unfortunately not, Reflect.ownKeys is a runtime trap / exotic objects and Proxies (and Modules) don't guarantee insertion order

[15:02:16.0000] <ljharb>
ah that's true

[15:02:23.0000] <ljharb>
but for non-proxies and non-exotics?

[15:02:31.0000] <ljharb>
(which is what package.json would be)


2019-12-19
[16:57:41.0000] <bradleymeck>
i believe that is defined, but that is what OrdinaryOwnKeys is

[20:08:50.0000] <ljharb>
gotcha

[09:20:20.0000] <bradleymeck>
ystartsev:

[09:20:23.0000] <bradleymeck>
woops

[14:43:15.0000] <devsnek>
is the spec for GetSuperBase wrong or something

[14:43:59.0000] <devsnek>
i'm so confused

[14:44:41.0000] <devsnek>
`super.x` returns a reference whose base is the prototype of whatever the superclass is

[14:45:32.0000] <devsnek>
so if you did `super.x()`

[14:45:45.0000] <devsnek>
it would call x with a this value of `Object.getPrototypeOf(superclass)`

[14:45:53.0000] <devsnek>
er

[14:46:10.0000] <devsnek>
i'm so confused lol

[14:52:44.0000] <devsnek>
oh ok this was a fun bug

[14:53:23.0000] <devsnek>
https://gc.gy/44500989.png


2019-12-20
[16:15:13.0000] <bathos>
it‚Äôs Object.getPrototypeOf(homeObject), rather than superClass, where homeObject is the original obj where the method was declared, regardless of current call site

[16:18:58.0000] <bathos>
https://gist.github.com/bathos/edc8d240c4ebc94ec1909ce73f953953

[16:19:53.0000] <bathos>
the _this_ value is always the same as what it would have been

[16:20:16.0000] <bathos>
the super ref base is about property lookup. the receiver is not the super ref base

[16:23:05.0000] <bathos>
- bv / baseValue - where to start property lookup from

[16:23:07.0000] <bathos>
- thisValue - receiver value to use when invoking [[Get]] and [[Set]]

[08:44:07.0000] <mpcsh>
üëã noob question here - what does it mean for an object to be `frozen`? I don't see a definition in the terminology doc

[08:55:42.0000] <rkirsling>
mpcsh: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze

[09:17:49.0000] <mpcsh>
rkirsling: thank you!

[09:32:23.0000] <rkirsling>
sure!

[11:41:52.0000] <devsnek>
leobalte-: is the test262 ci supposed to list out which tests it runs? it looks like none of the engines are running any tests

[11:42:26.0000] <devsnek>
ci_test.sh i mean

[11:49:51.0000] <ljharb>
mpcsh: there's also `Object.isFrozen`

[13:52:14.0000] <rkirsling>
devsnek: the report has been stale for one month as of today, I meant to ask about it

[13:52:29.0000] <rkirsling>
oops I lied

[13:52:36.0000] <rkirsling>
it is literally back today

[13:52:49.0000] <devsnek>
i just noticed when i had that bug with engine262 yesterday

[13:52:53.0000] <devsnek>
it didn't fail on the test262 ci

[13:53:01.0000] <devsnek>
and all the engines have been green lately

[13:53:06.0000] <devsnek>
even on prs for super experimental stuff

[15:51:14.0000] <devsnek>
ok so something pretty cool, coverage reports for engine262 help reveal what stuff is missing in test262

[15:51:48.0000] <devsnek>
for example calling %TypedArray%.from with no arguments

[15:52:04.0000] <devsnek>
https://gc.gy/44590917.png

[15:55:33.0000] <rkirsling>
awesome


2019-12-21
[16:42:08.0000] <metanomial>
In conjunction with the proposal for a partial application syntax, has a related variation of the `switch` block been proposed?

[16:42:53.0000] <ljharb>
metanomial: do you mean https://github.com/tc39/proposal-pattern-matching ?

[16:42:58.0000] <ljharb>
metanomial: the two proposals aren't related tho

[16:44:53.0000] <metanomial>
Similar, but I was thinking for currying functions

[16:46:23.0000] <ljharb>
using switch?

[16:59:36.0000] <metanomial>
Yeah, I was thinking something like https://gist.github.com/metanomial/53873157ab73efa7bd8ffeb070c1ab54?ts=4

[16:59:59.0000] <devsnek>
you can switch on true

[17:00:14.0000] <devsnek>
switch (true) { case name.match(/^d/): ... }

[17:01:08.0000] <metanomial>
I use this all the time, but it's verbose in a lot of situations

[17:19:11.0000] <metanomial>
Consider situations with `switch(true) { case value instanceof X: }` or `switch(true) { case Object.hasOwnProperty(target, 'foo') }`, where there is a long list of conditions.

[17:19:57.0000] <metanomial>
It would be very clean to just do `switch apply(value instanceof ?) { case X: }` and `switch apply(Object.hasOwnProperty(target, ?)) { case 'foo': }`

[17:20:25.0000] <metanomial>
I don't know if a switch block makes semantic sense here, though

[17:21:46.0000] <metanomial>
Also I don't know if the partial application syntax would extend to the `instanceof` operator

[17:26:39.0000] <metanomial>
*edit: `target.hasOwnProperty(?)`

[18:19:24.0000] <bathos>
it‚Äôs a bit fuzzy what it would mean, given `instanceof` is an observable operation that can have side effects. do you imagine a special path where the prototype chain is only unfurled once, then membership is tested against what has been reported? or is each case a distinct application of instanceof?

[18:21:17.0000] <bathos>
(not to mention @@hasInstance ... I‚Äôm guessing it would have to be the latter on account of that)

[18:22:26.0000] <bathos>
given each expression would be ‚Äòdoing work‚Äô, to me it seems `if`/`else` tells a clearer story about what‚Äôs happening than switch would.

[19:59:52.0000] <metanomial>
I meant each case being a distinct evaluation of an expression, sequentially. Using the `switch` keyword would definitely lead to confusion, but I think the base pattern is still useful

[20:05:14.0000] <metanomial>
`let command; apply(command.match(?)) { case /^help\s+(\w+)/: sendHelpMessage(command[1]); }`

[20:05:45.0000] <metanomial>
I messed that up. Meant:

[20:06:04.0000] <metanomial>
`let command; apply(command = input.match(?)) { case /^help\s+(\w+)/: sendHelpMessage(command[1]); }`

[15:26:23.0000] <bathos>
If the hashbang proposal, (private) instance fields proposal, and the smart pipeline proposal all ended up reaching stage four, would this imply ... nine different lexical goal symbols?

[15:26:29.0000] <bathos>
InputElementDiv, InputElementHashbangOrRegExp, InputElementRegExp, InputElementRegExpOrTemplateTail, InputElementRegExpOrTemplateTailOrTopic, InputElementRegExpOrTopic, InputElementTemplateTail, InputElementTemplateTailOrTopic, InputElementTopic

[15:30:25.0000] <bathos>
Maybe it wouldn‚Äôt. Consume-longest-possible would be enough for private ident vs topic and for hashbang vs topic I guess.

[15:31:10.0000] <jmdyck>
We could somewhat reduce the complexity by having one InputElement nonterminal with parameters.

[15:33:59.0000] <rkirsling>
tangential but even as it stands it's a bit odd that the paragraph says `a TemplateMiddle or a TemplateTail` three times when there's a single TemplateSubstitutionTail to subsume them

[15:34:15.0000] <rkirsling>
(makes me wonder if TemplateSubstitutionTail was added later)

[15:37:20.0000] <bathos>
My understanding was that TemplateMiddle and TemplateTail are tokens, and that TemplateSubstitutionTail isn‚Äôt, so the syntactic grammar can‚Äôt refer to it.

[15:38:18.0000] <bathos>
(I‚Äôm not sure if this is made entirely explicit but it‚Äôs at least implied pretty strongly.)

[15:38:44.0000] <rkirsling>
hmm, that would be surprising because it's only the paragraph text that's doing this

[15:40:06.0000] <bathos>
Ah. Yeah, I don‚Äôt know for sure. But in https://tc39.es/ecma262/#sec-tokens it does say ‚Äú[...] TemplateSubstitutionTail [derives] additional tokens‚Äù

[15:40:57.0000] <bathos>
OTOH, it makes it sound like Template (NoSubstitutionTemplate and TemplateHead) is a token, and it‚Äôs really NoSubstitutionTemplate and TemplateHead which are.

[15:41:05.0000] <rkirsling>
that's fair, but the other ones listed in that note are behaving as expected in https://tc39.es/ecma262/#sec-ecmascript-language-lexical-grammar

[15:42:51.0000] <rkirsling>
'cause we have InputElementTemplateTail :: TemplateSubstitutionTail, and even TemplateMiddle and TemplateTail are ultimately multitoken lexical "components" so I don't think there's any intentionality

[15:43:40.0000] <bathos>
hm, not sure I follow. TemplateMiddle and TemplateTail are atomic from the syntactic grammar‚Äôs POV.

[15:44:05.0000] <bathos>
The derivation of the tv and trv is part of the lexical grammar.

[15:45:38.0000] <bathos>
(This would be more clear if references to terminals by name in the syntactic grammar weren‚Äôt styled the same as references to nonterminals.)

[15:48:42.0000] <rkirsling>
it's quite possible that I'm misunderstanding that notion of atomicity but in the sentence `The InputElementRegExpOrTemplateTail goal is used in syntactic grammar contexts where a RegularExpressionLiteral, a TemplateMiddle, or a TemplateTail is permitted.` I'm not following why there'd be any issue to s/TemplateMiddle, or a TemplateTail/TemplateSubstitutionTail/ to match what the productions actually say

[15:49:58.0000] <bathos>
by atomicity I meant they‚Äôre terminals; they are single symbols, not compused by multiple tokens/terminals.

[15:50:05.0000] <bathos>
composed*

[15:51:10.0000] <rkirsling>
but TemplateTail itself refers to TemplateCharacters which is recursive and refers to TemplateCharacter

[15:51:27.0000] <bathos>
yes ‚Äî that‚Äôs a lexical production

[15:51:41.0000] <bathos>
the terminals of the lexical grammar are SourceCharacters

[15:51:53.0000] <rkirsling>
right

[15:52:02.0000] <bathos>
the terminals of the syntactic grammar are tokens, a subset of input elements that the lexical grammar produces

[15:52:39.0000] <rkirsling>
but looking at https://tc39.es/ecma262/#sec-template-literal-lexical-components it seems impossible that TemplateSubstitutionTail can have a different status than TemplateMiddle

[15:52:50.0000] <bathos>
The input element that the lexical grammar can produce are WhiteSpace, LineTerminator, Comment, IdentifierName, Punctuator, NumericLiteral, StringLiteral, NoSubstitutionTemplate, TemplateHead, TemplateMiddle, TemplateTail, RegularExpressionLiteral, RightBracePunctuator, and DivPunctuator. But that is largely left implicit.

[15:52:56.0000] <bathos>
elements*

[15:53:06.0000] <bathos>
of those, all but the first three are tokens

[15:54:06.0000] <rkirsling>
but then you'd be saying that https://tc39.es/ecma262/#prod-InputElementTemplateTail is a typo for not listing TemplateMiddle and TemplateTail separately, right?

[15:54:25.0000] <rkirsling>
I just want the description and the implementation to line up...

[15:54:32.0000] <bathos>
No

[15:54:38.0000] <bathos>
because that‚Äôs a lexical production

[15:54:43.0000] <bathos>
two colons

[15:54:54.0000] <bathos>
The sentence you‚Äôre looking at (‚Äòis used in contexts where...‚Äô) is listing tokens, not lexical productions.

[15:55:56.0000] <bathos>
It just happens that it‚Äôs never made fully explicit which lexical productions are tokens ‚Äî it‚Äôs implicit in that those are the ones referenced as terminals in the syntactic grammar.

[15:56:28.0000] <rkirsling>
but then RegularExpressionLiteral in the same sentence isn't a token either, right...? it's in the very same note you called out about "deriv[ing] additional tokens that are not included in the CommonToken production"

[15:56:36.0000] <bathos>
There‚Äôs no requirement that the lexical grammar‚Äôs topmost symbol‚Äôs alternatives produce specifically a token of one type.

[15:57:08.0000] <bathos>
Why would RegularExpressionLiteral not be a token?

[15:57:52.0000] <rkirsling>
because of the note

[15:57:57.0000] <bathos>
the token it derives which is not in CommonToken is RegularExpressionLiteral

[15:58:03.0000] <rkirsling>
right

[15:58:04.0000] <rkirsling>
but

[15:59:38.0000] <bathos>
https://tc39.es/ecma262/#sec-primary-expression

[15:59:53.0000] <bathos>
RegularExpressionLiteral is referenced here, in the syntactic grammar. That makes it a terminal.


2019-12-22
[16:00:26.0000] <bathos>
I would def agree that it is confusing for this to be left implicit, especially since it currently ‚Äúhalf explains‚Äù the concept of tokens in play.

[16:03:49.0000] <bathos>
If we go to https://tc39.es/ecma262/#prod-TemplateLiteral you‚Äôll see NoSubstitutionTemplate, TemplateHead, TemplateMiddle, and TemplateTail are all terminals of the syntactic grammar, but not TemplateSubstitutionTail, which is just a production of the lexical grammar that acts to group two alternatives that occur together more than once. It‚Äôs ‚Äògone‚Äô at this stage ‚Äî the productions of the lexical grammar aren‚Äôt

[16:03:49.0000] <bathos>
parse nodes.

[16:06:24.0000] <rkirsling>
I certainly see that it isn't used there but I don't understand non-post-hoc-ly what blesses the ones that are used

[16:06:55.0000] <bathos>
Well, how could it not be?

[16:07:29.0000] <bathos>
Is there any way the syntactic grammar could employ TemplateSubstitutionTail as a terminal?

[16:07:55.0000] <rkirsling>
it seems like the only difference between TemplateSubstitutionHead and TemplateMiddle / TemplateTail is that because the latter include raw tokens in their definition, there's no shorter way to refer to them

[16:08:42.0000] <rkirsling>
er "shorter" is a terrible word

[16:08:46.0000] <rkirsling>
more specific I mean

[16:09:42.0000] <bathos>
by TemplateSubstititionHead to you mean TemplateSubstitutionTail or Template?

[16:09:46.0000] <bathos>
do*

[16:09:59.0000] <rkirsling>
oops yeah

[16:10:04.0000] <rkirsling>
TemplateSubstitutionTail

[16:10:25.0000] <rkirsling>
but also Template in the same way

[16:11:10.0000] <bathos>
I may be misunderstanding the thing you see as being off-kilter

[16:13:46.0000] <bathos>
But I could say that the ‚Äòblessing‚Äô stems directly from necessity ‚Äî it‚Äôs not arbitrary at least as far as ‚Äòthis specific thingie has a unique identity as a terminal symbol within the syntactic grammar‚Äô. A TemplateMiddle and a TemplateTail aren‚Äôt syntactically interchangeable.

[16:14:33.0000] <rkirsling>
completely don't understand how two productions in 11.8.6 can be said to have a different status from one another if both are further dependent on other productions; you seem to be suggesting a meaningful distinction between NoSubstitutionTemplate / TemplateHead / TemplateMiddle / TemplateTail which "build" something and TemplateSubstitutionTail / Template which simply list alternatives

[16:15:02.0000] <rkirsling>
but I don't know how to see this distinction manifest anywhere

[16:16:12.0000] <rkirsling>
right, a TemplateMiddle and a TemplateTail aren't interchangeable and so the syntactic grammar has had no reason to treat them the same for any purpose, but it seems like all you'd need is such a purpose, and voila

[16:16:46.0000] <bathos>
I think that‚Äôs a pretty accurate description of what I‚Äôm saying, yes. What makes this confusing is that ‚Äòlexical production‚Äô and ‚Äòtoken‚Äô are two different things, and yet a subset of lexical productions shares names with tokens, and the distinction is not made clear.

[16:18:03.0000] <rkirsling>
okay

[16:18:06.0000] <bathos>
The distinction can only be seen implicitly by actually analyzing which productions of the lexical grammar are referenced in the syntactic grammar. This alone is sufficient to make them terminals of that grammar.

[16:19:22.0000] <bathos>
(Like, in an abstract definitional grammar-y sense, not in spec terms specifically.)

[16:19:48.0000] <rkirsling>
but there is something 'unblessed' about using TemplateSubstitutionTail in the syntactic grammar right now, even if one could come up with a sensible purpose for doing so?

[16:20:31.0000] <bathos>
well, it would be unprecedented in this grammar to consider a single terminal to have two symbolic identities

[16:21:27.0000] <rkirsling>
okay fair enough

[16:24:17.0000] <bathos>
It‚Äôs confusing in ES because the lexical grammar is wound up with the syntactic grammar ‚Äî the multiple goals are like a trick to keep pretending the lexical grammar is a ‚Äònormal‚Äô context-free, regular lexical grammar.

[16:24:39.0000] <rkirsling>
yeah

[16:24:40.0000] <bathos>
But if you imagine a more typical case, it‚Äôs usually possible to lex/tokenize independently from parsing.

[16:25:15.0000] <bathos>
And each token is just ‚Äòone symbol‚Äô and I think that‚Äôs what‚Äôs being aimed for here. But what you‚Äôre describing seems conceptually valid to me, just not something I‚Äôve seen before in practice I think.

[16:25:15.0000] <rkirsling>
this is my first time thinking about goals at all, and evidently up 'til this point I've not really had to dwell on what makes the lexical grammar unique

[16:26:20.0000] <rkirsling>
gotcha

[16:26:38.0000] <bathos>
I am kind of obsessed with grammars/lexing/parsing so I‚Äôve spent a lot of time on this subject within ES but I am by no means an expert so you should prob take my assessment with a few grains of salt.

[16:26:54.0000] <rkirsling>
haha

[16:28:35.0000] <rkirsling>
I am very much enjoying working on that domain within JSC's implementation but spec text still throws me curveballs sometimes

[16:29:33.0000] <rkirsling>
(not wrt to using it for impl, wrt to understanding whether something is "written in the way that it's meant to be" like this)

[16:30:16.0000] <rkirsling>
but also, having a background in linguistics, maybe it's better if I mentally rebucket the lexical grammar as "morphology that happens to be specified in a way that looks almost just like syntax"

[16:30:55.0000] <rkirsling>
(lol s/wrt to/wrt/ x2)

[16:31:08.0000] <jschoi>
bathos (‚ÄúIf the hashbang proposal, (private) instance fields proposal, and the smart pipeline proposal all ended up reaching stage four, would this imply ... nine different lexical goal symbols?‚Äù): For what it‚Äôs worth, a hope of the smart-pipe proposal is to consolidate several other alternative proposals, like partial application and binding, each of which proposes its own additional lexical symbol(s).

[16:31:28.0000] <bathos>
Understandably. On one hand I think the way the grammars are described in the spec is pretty elegant, on the other ... sometimes elegance isn‚Äôt the same as ‚Äúoptimized for accessible reading‚Äù ... it def took me a long time to figure out a lot of parts of the puzzle. I don‚Äôt know any other grammar that‚Äôs so parameterized (both explicitly and implicitly, e.g. ‚Äòdoes annex b apply‚Äô, ‚Äòis the goal symbol

[16:31:28.0000] <bathos>
module‚Äô, etc).

[16:32:16.0000] <jmdyck>
(dang, was afk for this conversation)

[16:32:29.0000] <rkirsling>
jmdyck: you're not too late lol

[16:34:00.0000] <jmdyck>
except now i have to go elsewhere

[16:34:11.0000] <jmdyck>
anyhow, the 'interface

[16:34:29.0000] <jmdyck>
'interface' between the syntactic and lexical grammars is ... interesting

[16:34:56.0000] <bathos>
@jschoi Cool, it would def be nice if partial application / topic were aligned. Partial application is a feature I think I would get a lot of use from personally.

[16:35:32.0000] <rkirsling>
shu: come share in my grad-school flashbacks about the morphosyntactic interface rn

[16:40:20.0000] <jschoi>
It‚Äôs certainly pretty true that there are a lot of tokens in the JavaScript language now.

[16:46:33.0000] <bathos>
@rkirsling my personal fave mindfuck in the lexical grammar is https://tc39.es/ecma262/#sec-html-like-comments. It took me two days to reverse engineer the reasoning behind why it is defined the way it is and what it is saying ... it does make sense, but it really felt like solving a puzzle.

[16:47:36.0000] <rkirsling>
:ohno:

[16:47:47.0000] <rkirsling>
do I dare

[16:48:48.0000] <bathos>
haha, maybe you‚Äôll get it faster than I did. It involves an explicit way of writing [yes LineTerminator here].

[16:51:21.0000] <bathos>
or in prose ‚Äò--> begins a single line comment only if an input element preceding it was a LineTerminator or a comment including a LineTerminator or was a non-token input element which itself satisfies that same requirement‚Äô

[16:56:40.0000] <rkirsling>
I was always too afraid to know how HTML comments in JS actually worked but

[16:56:45.0000] <rkirsling>
I think I'm following

[16:57:34.0000] <rkirsling>
I'm amazed that <!-- and --> don't function _as_ a multiline comment?

[16:58:52.0000] <bathos>
And that `--> foo`, where legal, is all a comment ‚Äî foo is not an identifier there!

[16:59:25.0000] <rkirsling>
üò≠ @ that

[16:59:51.0000] <bathos>
I believe this dates back to oldskool practices related to putting the content of <script> and <style> inside <!-- --> but I no longer even remember why people did that.

[17:00:29.0000] <bathos>
I guess to avoid entity references and things-that-look-like-closing-tags being interpreted as they normally would be.

[17:00:51.0000] <bathos>
Probably something related to Netscape Navigator or IE 3...

[17:00:54.0000] <rkirsling>
but I think we're saying that:

[17:00:54.0000] <rkirsling>
(1) <!-- can function like //

[17:00:54.0000] <rkirsling>
(2) --> can function like // after a line terminator and optionally a whitespace-separated sequence of partial-line /* */ comments

[17:00:54.0000] <rkirsling>
(3) --> can function like // after an (actual) multiline /* */ comment

[17:01:27.0000] <rkirsling>
yeah

[17:01:45.0000] <rkirsling>
it's hard to imagine those days accurately now that they're long-gore

[17:01:51.0000] <rkirsling>
*long-gone

[17:02:00.0000] <bathos>
yeah ‚Äî any number of whitespace/comments/lineterminator as long as at least one included a line terminator and --> starts a comment

[17:02:11.0000] <rkirsling>
(but I guess you could call Annex B "long gore" lolol)

[19:28:47.0000] <devsnek>
if you use modules

[19:28:50.0000] <devsnek>
none of it matters

[19:28:50.0000] <devsnek>
:P

[19:29:28.0000] <devsnek>
rkirsling: i found an interesting bug in jsc, it doesn't throw when Object.preventExtensions fails

[19:33:02.0000] <rkirsling>
sounds like we need some coverage :D https://test262.report/browse/built-ins/Object/preventExtensions

[19:33:28.0000] <devsnek>
last commit to test262 adds coverage for it :D

[19:33:49.0000] <devsnek>
last commit to test262 honestly has a lot of shenanigans

[19:34:59.0000] <rkirsling>
cool

[22:02:28.0000] <jmdyck>
rkirsling: in the phrase "syntactic grammar contexts where a TemplateMiddle or a TemplateTail is permitted", you can't replace that with "... a TemplateSubstitutionTail is permitted", because there is no syntactic context where a TemplateSubstitutionTail is permitted. That is, using only syntactic productions, you can never derive (a sentence containing) TemplateSubstitutionTail.

[22:03:20.0000] <rkirsling>
ah

[22:03:23.0000] <jmdyck>
(whereas you certainly *can* derive TemplateMiddle and TemplateTail)

[22:03:58.0000] <rkirsling>
that is a satisfying explanation, thanks

[22:04:07.0000] <jmdyck>
ah good, yw.

[22:09:28.0000] <jmdyck>
And it looks like TemplateSubstitutionTail was added at the same time (in the same ES6 draft) as TemplateMiddle and TemplateTail (though they were originally named "Quasi" instead of "Template").

[22:10:24.0000] <devsnek>
templates are quite a weird bit of syntax

[22:15:48.0000] <rkirsling>
quasi, heh

[22:20:06.0000] <jmdyck>
bathos: In my opinion, the spec is a bit vague/inconsistent on what "token" means, so it's hard to say definitively whether an instance of TemplateSubstitutionTail qualifies as a token. My guess is, you're probably better off if you don't think of it as a token.

[22:22:57.0000] <jmdyck>
On second thought, i take that back. I'm not sure which way you're better off.

[22:25:48.0000] <jmdyck>
In the end, I don't think it matters.

[01:14:39.0000] <bathos>
I agree it‚Äôs poorly described, but it‚Äôs still unambiguous at least as far as ‚Äòit means what it means anywhere: the terminals of the syntactic grammar‚Äô + the note in 11.5 makes it apparent that that‚Äôs what token is referring to. I‚Äôd be comfortable saying TemplateSubstitutionTail is ‚Äòdefinitively not a token,‚Äô but it‚Äôs true that it‚Äôs hard to point to a single bit of text that establishes that.

[01:16:08.0000] <bathos>
what makes tokens interesting in ES is that unlike in most langs w/ a lexical and syntactic grammar, the lexical grammar of ES produces things that aren‚Äôt tokens

[01:16:36.0000] <bathos>
like, produces in the sense of things the syntactic grammar needs to ‚Äòsee‚Äô

[01:17:39.0000] <bathos>
because of that, I‚Äôd expect it to be given a more concrete def

[01:17:58.0000] <bathos>
rather than being all read-between-the-linesy

[05:46:26.0000] <jmdyck>
For me, what's interesting about the syntactic/lexical boundary in ES...

[05:47:58.0000] <jmdyck>
(1) There's a lexical goal symbol at all. (Typically, a lexical 'grammar' will just be a bunch of rules that define the lexical form of the syntactic grammar's terminals.)

[05:48:43.0000] <jmdyck>
(2) There's actually 4 lexical goal symbols, and which one to use is determined by syntactic context.

[05:52:00.0000] <jmdyck>
(3) Once you've used the lexical grammar to parse the next input element, and have (at least theoretically) a lexical parse tree rooted at InputElement, the thing that the syntactic grammar/parser is interested in (the 'token', if you like) is not at a fixed depth below the root.

[05:57:09.0000] <jmdyck>
(E.g., a RegularExpressionLiteral is a child of the InputElement, but a TemplateHead is a child of a Template, which is a child of a CommonToken, which is a child of the InputElement.)

[08:04:23.0000] <bathos>
es makes the lexical goals explicit because it has more than one. when a lexical grammar doesn‚Äôt list one, it‚Äôs shorthand for ‚Äòthe goal symbol of this grammar has the following alternatives‚Äô

[08:05:52.0000] <bathos>
it is unusual to not have each token in that top disjunction, though the usefulness of other grouping stems from the multiple goals thing. with a single goal, there‚Äôd be no advantage

[08:08:17.0000] <bathos>
(i‚Äôm sure you already get that ‚Äî just trying to articulate the reason for it. your points make sense, all of those things are unusual)

[08:09:08.0000] <bathos>
I‚Äôd add (4) line terminator twilight zone non token tokens

[12:51:54.0000] <devsnek>
would it be breaking to change block comments to be able to nest

[12:52:31.0000] <devsnek>
i think any code that would have changed behaviour would be syntactically invalid, just having a dangling `*/`

[12:54:20.0000] <despreston>
Hi, I'm looking for some help regarding a new proposal. I'm hoping for feedback on what additional information should be included in my initial README.

[12:54:23.0000] <despreston>
https://github.com/despreston/proposal-zip

[12:57:42.0000] <devsnek>
despreston: you might wanna say why it's preferable to something like Iterator.from(names).zip(scores)

[12:58:08.0000] <devsnek>
not that that exists right now, but it probably will soon

[12:58:10.0000] <despreston>
Thanks @devsnek -- that's a good idea.

[12:58:25.0000] <despreston>
has there been any work or discussion on Iterator.from(names).zip ?

[12:59:55.0000] <devsnek>
despreston: it was brought up on the iterator methods proposal

[13:00:02.0000] <devsnek>
i didn't include it because there are already 22 new methods

[13:00:07.0000] <devsnek>
but a future proposal will probably add it

[13:03:26.0000] <ljharb>
devsnek: `3 \n */a/`?

[13:04:05.0000] <devsnek>
ljharb: how would that interfere with the block nesting though

[13:04:32.0000] <ljharb>
i'm probably not clear on what you're suggesting

[13:04:34.0000] <devsnek>
like

[13:04:40.0000] <devsnek>
`/* /* */ */`

[13:04:43.0000] <devsnek>
is one block comment

[13:04:51.0000] <devsnek>
instead of `/* /* */` and then `*/`

[13:05:11.0000] <devsnek>
its super annoying to block comment out something that already has a block comment somewhere within it

[13:05:18.0000] <devsnek>
in rust it keeps track of block comment depth

[13:05:21.0000] <devsnek>
so you can nest them

[13:05:23.0000] <devsnek>
and it's great

[13:06:24.0000] <despreston>
Thanks again, devsnek. I'll check those out.

[13:06:46.0000] <ljharb>
ok but so let's say i had `var g = 2; 3 \n /* /* */ \n */4/g` which produces NaN

[13:09:02.0000] <devsnek>
terrifying

[13:09:12.0000] <devsnek>
but yeah i guess that would break

[13:09:22.0000] <ljharb>
hopefully nobody has written code like that ofc

[13:10:05.0000] <devsnek>
but you couldn't do that in expression position

[13:10:20.0000] <devsnek>
so maybe we're safe?

[13:10:44.0000] <devsnek>
i dunno

[13:42:41.0000] <bathos>
weird as ‚Äòmultiply by regexp‚Äô is, it‚Äôd plausibly be generated by a minifier inlining initializers. the code would have a bug (barring increasingly unlikely things) but it wouldn‚Äôt be a syntax error and could make it to prod out there somewhere

[13:45:11.0000] <bathos>
correct me if I‚Äôm wrong but I‚Äôm pretty sure even if found web-safe, anything that previously was syntactic valid having its interpretation *change* is subject to very high scrutiny (if ever permitted?) cause of the security implications of code that evals as two different things (as opposed to eval-vs-static-syntax-error) depending on es version implemented by agent

[13:45:23.0000] <bathos>
syntactically*

[13:46:36.0000] <bathos>
(I do think it would be a useful thing though, if it is considered possible)

[14:11:32.0000] <rkirsling>
yeah "surely people wouldn't do that" tends to be a tough sell wrt breaking the web

[14:18:42.0000] <bathos>
oh, there‚Äôs also a much more likely thing: // */

[14:19:12.0000] <bathos>
`/* /**/ console.log('hello'); // */`

[14:19:50.0000] <rkirsling>
nice

[14:20:16.0000] <rkirsling>
yeah `// */` is basically guaranteed to exist, I'd say

[14:22:38.0000] <bathos>
there‚Äôs also the reverse thing ‚Äî comments like /* /* */ probably aren‚Äôt uncommon, and with that change, the code that follows them would become part of the comment

[14:23:53.0000] <bathos>
e.g. picture an accidentally nested jsdoc comment, or decorative comment borders like /* /* /* /* /*...

[14:25:16.0000] <bathos>
in fact, forget accidental partial nesting ‚Äî some people do multiline bordering on the left where every line starts with /*

[14:25:24.0000] <rkirsling>
or people that were temporarily commenting out code and didn't actually remove it from the commit

[14:27:27.0000] <rkirsling>
but yeah I think that would be the guaranteed problem -- suddenly everybody's got block comments running 'til the end of the file

[14:28:16.0000] <bathos>
or the next comment, yeah


2019-12-23
[16:36:39.0000] <devsnek>
i have a ton of code with `/* ... /* ... * / ... */`

[16:36:48.0000] <devsnek>
note the space there

[16:37:10.0000] <devsnek>
changing to nested would think that code is still commented

[09:27:38.0000] <shu>
rkirsling: was traveling. missed out on some good flashbacks?

[09:31:19.0000] <rkirsling>
lol I was half-joking but we were talking about what makes the ES lexical grammar special

[09:32:56.0000] <rkirsling>
and I was mentally rebucketing it as morphology that happens to be specified in a syntax-like way

[09:35:37.0000] <shu>
ah yes

[09:35:46.0000] <shu>
morphology and syntax basically same thing

[10:36:45.0000] <bathos>
any tips for resources to check out which could help me understand ‚Äòmorphology‚Äô as used above?

[10:44:20.0000] <rkirsling>
well, there's https://en.wikipedia.org/wiki/Morphology_(linguistics) at least

[10:44:57.0000] <rkirsling>
it's just "how lexemes are built up from morphemes" in natural language

[10:45:11.0000] <rkirsling>
("word" isn't a technical term fwiw)

[10:48:02.0000] <rkirsling>
(I mean it's inevitably used for convenience, I just mean "word" is not a word with a rigorous definition in linguistics)

[10:50:11.0000] <rkirsling>
but yeah, in a single image: https://en.wikipedia.org/wiki/Morphology_(linguistics)#/media/File:Independently_morphology_tree.png

[10:53:59.0000] <rkirsling>
this corresponds nicely because "independently" would itself just be a terminal in a syntax tree

[12:17:44.0000] <bathos>
ah, thanks. that gives me the gist at least


2019-12-24
[11:31:33.0000] <devsnek>
we don't have any history of ecma262 builds do we?

[14:01:47.0000] <ljharb>
devsnek: no, it wipes the gh-pages branch every time. if we had a script that updated instead of recreated the gh-pages branch, i'd be happy to write a script that recreates a gh-pages build for every sha on master

[14:02:32.0000] <devsnek>
might look into that

[14:02:54.0000] <devsnek>
in the meantime i made https://snek.dev/ecma262-a09c766/

[14:03:58.0000] <ljharb>
devsnek: manually? or automatically for any sha

[14:04:04.0000] <devsnek>
manually

[14:04:06.0000] <devsnek>
for that one commit

[14:04:07.0000] <ljharb>
ah k

[14:04:29.0000] <devsnek>
i need a built version of that commit for a presentation

[14:04:37.0000] <devsnek>
talking about a bug in ecma262

[14:05:21.0000] <devsnek>
well the presentation isn't about a bug in ecma262, but its relevant to the presentation lol

[14:26:48.0000] <rkirsling>
where you presentin'

[14:29:06.0000] <devsnek>
rkirsling: tc39, some time in the future

[14:31:42.0000] <rkirsling>
shweet


2019-12-25
[16:51:58.0000] <jmdyck>
devsnek: so what *is* the presentation about?

[16:52:08.0000] <devsnek>
jmdyck: engine262

[16:52:46.0000] <jmdyck>
makes sense


2019-12-27
[12:09:07.0000] <devsnek>
anyone got opinions on this? https://github.com/devsnek/ecma262/commit/6ec13372835f80d877652f9c0a13a1650537f038

[12:15:01.0000] <ljharb>
devsnek: that seems like a lot of change; what's the reason?

[12:15:19.0000] <ljharb>
also have you checked 402 and HTML to see if they're using any of the abstract ops you're removing?

[12:15:55.0000] <devsnek>
they aren't

[12:16:01.0000] <devsnek>
and its really just moving spec steps around

[12:17:18.0000] <ljharb>
what's the goal? churn for churn's sake is generally something we try to avoid

[12:17:54.0000] <devsnek>
goal one was to get rid of the hanging evaluation contexts

[12:18:05.0000] <devsnek>
goal two was to simplify realm creation

[12:18:18.0000] <devsnek>
goal three was to turn "do x in an implementation defined manner" into host hooks

[12:22:52.0000] <ljharb>
can those goals be achieved in 3 commits/PRs instead of 1? it might be easier for me to grok that way

[12:23:22.0000] <devsnek>
perhaps

[12:23:35.0000] <devsnek>
once RunJobs is removed this will become a lot simpler i think

[13:17:58.0000] <jmdyck>
how would the removal of RunJobs simplify it?

[14:17:00.0000] <bathos>
@devsnek It looks like those changes would address https://github.com/tc39/ecma262/issues/1792 (or at least make it moot). I was gonna open a PR for that narrower change after the holiday week but maybe I shouldn‚Äôt if it‚Äôs gonna change more extensively anyway?

[14:17:42.0000] <ljharb>
bathos: narrow changes are good and land more quickly


2019-12-28
[22:13:26.0000] <bathos>
Does anyone know if ‚ÄúThe SourceCharacter immediately following a NumericLiteral must not be an IdentifierStart or DecimalDigit.‚Äù (which appears to be normative text of the lexical grammar) has any formally observable effect? That is, would it ever impact something other than perhaps the specific error message of the SyntaxError produced, which is not specified anyway?

[22:14:01.0000] <bathos>
(Also it‚Äôs a bit confusing because IdentifierStart is not "a SourceCharacter")

[22:15:36.0000] <bathos>
(i.e. it‚Äôs unclear if it includes "\", since the SourceCharacter "\" can start IdentifierStart, but it cannot _be_ IdentifierStart)

[22:24:42.0000] <bathos>
It appears this sentence and its accompanying note dates from ES3, though even at that time IdentifierStart includes `\ UnicodeEscapeSequence`.

[22:27:25.0000] <bathos>
Oh, it is observable that this must be enforced lexically ‚Äî answered my own question by googling :x https://github.com/microsoft/TypeScript/issues/4702


2019-12-29
[02:01:49.0000] <bathos>
Are definitions for BoundNames of the second and third alternatives of NamedImports missing, or is there some rule elsewhere that takes care of it? https://tc39.es/ecma262/#sec-imports-static-semantics-boundnames

[02:03:21.0000] <bathos>
(It‚Äôs clear that it would proxy the BoundNames of ImportsList, I‚Äôm just not sure where that gets specified)

[02:06:55.0000] <bathos>
nm, found it, fourth paragraph here https://tc39.es/ecma262/#sec-algorithm-conventions-syntax-directed-operations

[02:07:19.0000] <bathos>
(I found it by searching for "implicit" haha)


2019-12-30
[15:03:41.0000] <rkirsling>
the wasm spec is purty

[15:05:34.0000] <rkirsling>
er rather, the mostly-black-text-on-white-background-ness is quite austere, but

[15:05:38.0000] <rkirsling>
https://webassembly.github.io/spec/core/exec/instructions.html#parametric-instructions

[15:06:13.0000] <rkirsling>
each page is stylized quite nicely, is what I mean

[15:08:31.0000] <devsnek>
i like it

[15:12:45.0000] <rkirsling>
as for takeaways: I guess (1) we're getting along fine with MathJax and (2) the desire to split up the single-page spec is already known, but (3) I'd love to see us improve the style of notes to have a light-colored background instead of a grey bar on the left

[15:13:06.0000] <rkirsling>
(WHATWG does that part nicely too...)

[15:14:00.0000] <rkirsling>
*without MathJax

[15:14:43.0000] <rkirsling>
(even if we wanted to use MathJax, the rendering time would make it a non-starter on a single-page spec, heheh)

[15:16:50.0000] <rkirsling>
I don't think I've ever asked before just how set in stone stylistic matters in ecmarkup are

[15:17:18.0000] <rkirsling>
like I'd expect a light ecma orange background for notes to work nicely


2019-12-31
[20:40:55.0000] <jmdyck>
I just realized I'm not sure: is the desire for a multi-file *source* or a multi-page *rendering*?

[20:43:14.0000] <devsnek>
jmdyck: both

[21:19:18.0000] <rkirsling>
jmdyck: even the former alone would be nice but the latter would be pretty awesome

[21:21:46.0000] <jmdyck>
a multi-page rendering would presumably be fairly uncontroversial, because it could be in addition to the single-page rendering.

[21:22:57.0000] <rkirsling>
oh hm, I hadn't thought of it that way.

[21:23:51.0000] <rkirsling>
yeah, a new format could have "experimental status" as we explore options

[21:27:03.0000] <jmdyck>
But you can't really support both a single-file source and a multi-file source. You can have both, but one would have to be the true source and the other be generated (and not terribly useful?)

[21:29:22.0000] <devsnek>
why do we need both

[21:31:36.0000] <jmdyck>
we don't: I'm saying that "both" works for rendering but not source.

[21:32:31.0000] <jmdyck>
so you could pick the rendering you like, but you can't pick the source you like.

[21:35:28.0000] <devsnek>
is there a human somewhere that prefers a single file?

[21:35:36.0000] <jmdyck>
me for one

[21:35:45.0000] <devsnek>
i don't get that at all lol

[21:36:06.0000] <devsnek>
it feels very claustraphobic

[21:36:16.0000] <devsnek>
and it breaks reviews

[21:36:39.0000] <jmdyck>
you mean github's problem with large diffs?

[21:37:09.0000] <devsnek>
that is one of them, yes

[21:37:23.0000] <devsnek>
it also often freaks out when changes are far apart

[21:37:27.0000] <devsnek>
even if they're small

[21:37:32.0000] <jmdyck>
note that you can get large diffs in a multi-file spec too.

[21:38:46.0000] <devsnek>
sort of

[21:38:56.0000] <devsnek>
github bases it on the size of the diff in each file

[21:39:11.0000] <devsnek>
a 1500 line diff might be judged as "too much"

[21:39:20.0000] <devsnek>
but if those 1500 lines are split across single files, they'll show up

[21:39:25.0000] <devsnek>
multiple files*

[21:42:00.0000] <jmdyck>
it depends whether, in a large-diff commit, the diffs are spread out, or concentrated within one would-be file.

[21:42:55.0000] <devsnek>
i don't know all the rules

[21:43:04.0000] <devsnek>
but with single files you don't have to worry about it

[21:43:58.0000] <jmdyck>
i'm not saying that github's behavior depends on that, I'm saying that whether multi-file fixes the problem (in any particular case) depends on that

[21:44:15.0000] <devsnek>
i'm not sure what you mean

[21:44:29.0000] <jmdyck>
why do you think "with single files you don't have to worry about it"?

[21:48:08.0000] <jmdyck>
I suppose if you make the single files so small that even if the whole file is replaced it doesn't cross the "diff too big" threshold, then you don't have to worry about it.

[21:48:42.0000] <rkirsling>
I find blaming from the command line to be very challenging...

[21:49:55.0000] <devsnek>
jmdyck: i envision each section would be a separate file

[21:49:56.0000] <jmdyck>
I either grep the output or send it to a file and then search. But I'd do that if the file was anything more than a couple screenfuls.

[21:50:08.0000] <devsnek>
like nothing would be more than around 400-500 lines

[21:50:29.0000] <jmdyck>
devsnek: ah, every single emu-clause would be its own file?

[21:50:43.0000] <devsnek>
i think most functions would be their own file

[21:50:47.0000] <devsnek>
some stuff could probably be shared

[21:50:51.0000] <devsnek>
like all those Math.xyz definitions

[21:51:15.0000] <rkirsling>
hmm, the granularity would probably require discussion

[21:51:23.0000] <rkirsling>
I'd be happy with what 402 is doing

[21:51:34.0000] <jmdyck>
there's about 2100 emu-clause/annex elements

[21:51:40.0000] <rkirsling>
https://github.com/tc39/ecma402/tree/master/spec

[21:52:21.0000] <rkirsling>
so just like Intl.RelativeTimeFormat gets a file, I would expect Math itself to get a file, but not more granular than that

[21:52:46.0000] <rkirsling>
er wrong one that's still not in there

[21:53:05.0000] <rkirsling>
Intl.DateTimeFormat there

[21:53:16.0000] <rkirsling>
*then

[21:55:01.0000] <devsnek>
i mean like

[21:55:04.0000] <devsnek>
Array.from is pretty big

[21:55:08.0000] <devsnek>
i'd put that in its own file

[21:55:45.0000] <devsnek>
i'd put Promise.all and PerformPromiseAll in a single file

[22:33:19.0000] <ljharb>
We‚Äôd always want both; never just multi. But it‚Äôd be trivial to produce both forever.

[22:34:22.0000] <ljharb>
the challenge with a single raw spec is where to split; the challenge with a multi raw spec is how do you not annihilate git history.

[10:59:09.0000] <shu>
i prefer both a single file source and a single page rendering

[12:22:25.0000] <rkirsling>
shu: how come a single-file source?

