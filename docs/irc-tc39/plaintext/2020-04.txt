2020-04-01
[17:02:06.0000] <jackworks>
ljharb:

[17:02:31.0000] <jackworks>
I'm interesting join to help pattern matching, how can I help? ü§î

[17:02:41.0000] <devsnek>
ljharb: ^

[17:02:54.0000] <ljharb>
jackworks: thanks, i'll tag you on the issue i file

[17:02:56.0000] <ljharb>
devsnek: you too?

[17:03:15.0000] <devsnek>
i'll happily discuss it

[17:03:22.0000] <devsnek>
not sure about championing

[17:03:42.0000] <ljharb>
kk

[17:04:14.0000] <devsnek>
ljharb: to be clear i really love pattern matching and i want it in the language

[17:04:26.0000] <ljharb>
noted :-)

[17:05:02.0000] <jackworks>
+1 love pattern matching and waiting it for years

[08:05:48.0000] <renatoalencar>
hi

[08:05:53.0000] <renatoalencar>
anyone here?

[08:07:18.0000] <jmdyck>
I'm here.

[08:09:54.0000] <renatoalencar>
I was mapping Sequelize models to object like { attribute: type }, in order to create a serializer or something. So I was doing this: Object.fromEntries(Object.entries(model).map(([key, value]) => [key, value.type])) in order to achieve this.

[08:11:19.0000] <renatoalencar>
The question is: since I'm already using method chaining to get and map entries from attributes, I guess we could use some synthatic sugar in order to map this to Object.fromEntries intead of having an external function call. Like, we could enjoy the clean view of method chaining.

[08:12:09.0000] <renatoalencar>
I was thinking about creating proposal to a new Object method: Object.prototype.self.

[08:12:47.0000] <renatoalencar>
So instead of having something like this

[08:13:05.0000] <renatoalencar>
 Object.fromEntries(Object.entries(model).map(([key,

[08:13:05.0000] <renatoalencar>
                      value]) => [key, value.type]))

[08:13:18.0000] <renatoalencar>
* sorry *

[08:13:23.0000] <renatoalencar>
I would have something like this

[08:13:49.0000] <devsnek>
we don't add things to Object.prototype anymore

[08:13:49.0000] <renatoalencar>
Object.entries(model).map(([key, value]) => [key, value.type]).self(Object.fromEntries)

[08:15:38.0000] <renatoalencar>
Which is much cleaner

[08:15:52.0000] <devsnek>
but then you have this `self` property on every single object

[08:18:55.0000] <renatoalencar>
That's really an issue, I didn't think about it.

[08:30:02.0000] <bradleymeck>
Seems like pipeline operator could also help

[08:33:43.0000] <renatoalencar>
bradleymeck: That's great, it solves my problem.

[09:01:58.0000] <jridgewell>
Wasn‚Äôt there an `Object.map` proposal presented recently?

[09:09:01.0000] <rickbutton>
was it the one that got transformed into "object iteration"?

[09:09:02.0000] <rickbutton>
https://github.com/tc39/proposal-object-iteration

[09:17:23.0000] <Bakkot>
with object iteration and a slight extension of the iterator helpers proposal ("collect"), you'd write `Object.iterate(model).map(...).collect(Object.fromEntries)`

[09:41:13.0000] <renatoalencar>
`collect` is very interesting

[09:47:11.0000] <renatoalencar>
And `collect` sounds a lot more semantically correct than `self`

[10:15:24.0000] <Bakkot>
mathiasbynens ping

[10:17:10.0000] <mathiasbynens>
Bakkot: pong

[10:22:36.0000] <Bakkot>
mathiasbynens actually I guess I didn't have anything further to say

[10:23:15.0000] <mathiasbynens>
Bakkot: fair enough

[10:23:18.0000] <Bakkot>
just was trying to move the discussion here

[10:23:22.0000] <Bakkot>
but then I didn't have more discussion

[10:23:36.0000] <mathiasbynens>
there's this thing where if people walk through a doorway they tend to forget what they were doing before

[10:23:48.0000] <mathiasbynens>
i posit this applies to irc channels as well

[10:25:32.0000] <Bakkot>
I added a new slides listing possible goals: https://docs.google.com/presentation/d/1COuuP_0fxK_s8-H8AScDMjMzKSEiAlAnOi4snP-OiHY/edit#slide=id.g82bd3e5bae_15_10

[10:26:51.0000] <Bakkot>
my intention is to say that I regard the first two goals here as violated only for users who actually try to write unicode escapes for non-BMP characters , who I think are rare enough (and the harm in that case is sufficiently slight) that the other cost to the other goals should outweigh them

[10:29:38.0000] <mathiasbynens>
"The only reasons to ban these are that it hurts symmetry or exposes users to a concept we want to shield them from. But the number of users affected will be vanishingly small." not the only reasons; this aligns perfectly with ES2015 `u`

[10:29:52.0000] <Bakkot>
how is that not "hurts symmetry"?

[10:30:05.0000] <mathiasbynens>
resulting in 0 changes to the mental model

[10:30:16.0000] <Bakkot>
again, how is that not "hurts symmetry"?

[10:30:45.0000] <mathiasbynens>
it's completely orthogonal to that

[10:30:53.0000] <Bakkot>
I guess I don't know what you mean then.

[10:31:15.0000] <mathiasbynens>
you already know what i mean by symmetry

[10:31:35.0000] <Bakkot>
I thought what you meant was, you want this thing to be like that other thing, so that the mental model is simpler

[10:31:41.0000] <Bakkot>
but now I am no longer sure

[10:31:54.0000] <mathiasbynens>
ok let me try again

[10:32:09.0000] <mathiasbynens>
sorry i'm not being clear, i swear it all makes sense in my head

[10:32:48.0000] <mathiasbynens>
by symmetry, I mean the thing where you can copy-paste the sourcetext that makes up any valid group name from within the regexp pattern to `match.groups.<HERE>` without ending up with invalid code

[10:33:01.0000] <mathiasbynens>
does that make sense?

[10:33:25.0000] <Bakkot>
Sure, got it

[10:33:40.0000] <mathiasbynens>
proposal 3 has this property

[10:34:16.0000] <Bakkot>
agreed

[10:34:33.0000] <mathiasbynens>
but it gets there by aligning with ES2015 `u`, as in: `u` makes astral symbols work in `u` regexps, and this becomes another example of that

[10:35:03.0000] <mathiasbynens>
resulting in the simplest possible mental model

[10:35:21.0000] <Bakkot>
OK

[10:35:26.0000] <mathiasbynens>
proposal 4 (allowing \u\u even in identifiers) also has the symmetry property, but at the cost of a much more difficult mental model

[10:35:34.0000] <Bakkot>
when I said "symmetry" in that slide, I meant to refer to both of those things

[10:36:08.0000] <mathiasbynens>
i understand. i'm trying to explain why i see them as two separate things (and why i listed them separately in my proposal)

[10:36:13.0000] <Bakkot>
yeah

[10:36:22.0000] <Bakkot>
there are two different concrete properties, agreed

[10:36:34.0000] <Bakkot>
but they are both examples of, I want this thing to be like this other thing to simplify how many things the user has to know to know everything

[10:37:08.0000] <Bakkot>
and my position is, with the allow-all-escapes proposal, users will only be exposed to the asymmetry if they try to write (not just read) unicode escapes for non-astral characters

[10:37:22.0000] <Bakkot>
sorry, that is, users will only be exposed to _ether of those_ asymmetries

[10:45:46.0000] <mathiasbynens>
so do you want to add "simpler mental model" to your slide?

[10:45:56.0000] <mathiasbynens>
or "smaller mental model delta" or w/e

[10:46:24.0000] <Bakkot>
My intention was that that would be covered by "symmetry"

[10:46:31.0000] <Bakkot>
since that is why we care about symmetry

[10:55:03.0000] <mathiasbynens>
heh, i thought we just agreed they were distinct properties

[10:55:42.0000] <Bakkot>
I agreed that there are two concrete properties which are distinct: having symmetry between the group name in the regex and in the code, and having symmetry with the rest of how u and non-u regexes work

[10:55:45.0000] <Bakkot>
but these are both symmetry

[10:55:57.0000] <Bakkot>
and the reason we care about symmetry is, it keeps the mental model simple

[10:56:53.0000] <mathiasbynens>
not in the case of proposal 4

[10:57:22.0000] <mathiasbynens>
"An astral code point can always be represented as \uùòèùòåùòàùòã\uùòõùòàùòêùòì, and additionally as the more convenient \u{‚Ä¶} except in old-style non-u regular expressions." is quite a mouthful

[10:58:00.0000] <Bakkot>
yes, there is yet another kind of symmetry possible, which is symmetry between how the group name works and the rest of the regex works

[10:58:10.0000] <Bakkot>
(that's the one gibson042 has expressed the most interest in, for example)

[10:59:16.0000] <gibson042>
allowing \u{ to name capture groups in non-Unicode regexes does not simplify that

[10:59:26.0000] <Bakkot>
yes

[10:59:32.0000] <Bakkot>
I agree with that

[10:59:54.0000] <Bakkot>
I am proposing to make it slightly more complicated - to break that particular symmetry - in service of other goals

[11:00:02.0000] <gibson042>
understood

[11:04:09.0000] <mathiasbynens>
Bakkot: yes, proposal 3 gets at that kind of symmetry as well: either astral symbols are supported (`u`), or they aren't (non-`u`)

[11:04:34.0000] <Bakkot>
yup, I agree that proposal 3 has the most symmetry

[11:04:44.0000] <Bakkot>
I am proposing to break that symmetry in service of other goals

[11:08:57.0000] <Bakkot>
mathiasbynens gibson042: concretely, if you were given a choice ONLY between making /(?<\u{1d49c}>.)/ legal or illegal, with all of /(?<\ud835\udc9c.)/  /(?<\ud835\udc9c.)/u /(?<\u{1d49c}>.)/u being definitely legal, which is your preference?

[11:09:40.0000] <mathiasbynens>
Bakkot: illegal. astral support requires `u` flag. matches implementations too

[11:09:57.0000] <Bakkot>
mathiasbynens in this hypothetical, /(?<\ud835\udc9c.)/ is legal.

[11:10:07.0000] <Bakkot>
sorry, /(?<\ud835\udc9c>.)/, rather

[11:10:31.0000] <Bakkot>
so in this hypothetical, "astral support requires `u` flag." is false

[11:10:37.0000] <Bakkot>
given that, is that still your preference?

[11:10:59.0000] <mathiasbynens>
hmmm, not sure. where does the hypothetical come from?

[11:11:01.0000] <Bakkot>
OK also I guess I should extend my hypothetical to say that /(?<ùíú>.)/ is also definitely legal

[11:11:09.0000] <mathiasbynens>
oh no

[11:11:15.0000] <Bakkot>
this hypothetical comes from, I am going to propose exactly one of these two things

[11:12:02.0000] <Bakkot>
of these six regexes, five of them I am definitely going to propose should be legal. the sixth, /(?<\u{1d49c}>.)/, I think we could go either way.

[11:12:19.0000] <mathiasbynens>
i think you should present all the options that were discussed, and then pick your favorite, not provide the committee with just 2 options pretending there's no other way

[11:12:31.0000] <Bakkot>
I'm not going to present to the commitee just these two options

[11:12:43.0000] <Bakkot>
I am going to present exactly one of these options as the thing I am going for, and discuss many other options

[11:12:56.0000] <Bakkot>
but I am trying to decide which of two options I present as my favorite

[11:13:03.0000] <Bakkot>
based on which I think is most likely to get consensus

[11:13:15.0000] <Bakkot>
which I am hoping to base on which, of those two, you and gibson042 prefer

[11:13:37.0000] <mathiasbynens>
Bakkot: i prefer keeping `\u{...}` non-special in non-`u` regexps

[11:13:54.0000] <mathiasbynens>
like, that's one of the reasons we added the `u` flag

[11:14:15.0000] <mathiasbynens>
i get that we _could_ special-case this one thing if we really wanted to, but imho we shouldn't

[11:14:16.0000] <Bakkot>
even if \u\u and ùíú work?

[11:15:03.0000] <mathiasbynens>
yes

[11:15:06.0000] <Bakkot>
ok cool

[11:15:11.0000] <mathiasbynens>
(although i do think this proposal doesn't make sense)

[11:15:59.0000] <mathiasbynens>
not too long ago you said "I'm happy either way" https://github.com/tc39/ecma262/pull/1869#issuecomment-583982299 :')

[11:16:25.0000] <Bakkot>
yeah, that was before waldemar pointed out the tooling concern, which had not occurred to me but which I regard as having nontrivial weight

[11:17:13.0000] <Bakkot>
I was previously unconcerned because I regarded this as only affecting users who tried to write unicode escapes in group names, which I expect to be a tiny population and so the decision was unimportant

[11:17:52.0000] <Bakkot>
but waldemar correctly points out that it also affects tooling, which has significantly larger impact, so now I think it does matter

[11:19:14.0000] <mathiasbynens>
fair

[11:19:25.0000] <mathiasbynens>
prop 3 addressed all that

[11:19:38.0000] <mathiasbynens>
but yeah, the requirements keep coming

[11:19:49.0000] <mathiasbynens>
maybe we shouldn't block es2020 on this

[11:19:58.0000] <mathiasbynens>
there's really no rush

[11:20:01.0000] <Bakkot>
I would love to not block es2020 on this

[11:20:10.0000] <mathiasbynens>
let's do it

[11:20:18.0000] <Bakkot>
but, unfortunately, making that decision requires convincing waldemar that we should

[11:20:31.0000] <Bakkot>
which several people tried to do for like an hour after the meeting last night, to no avail

[11:20:38.0000] <Bakkot>
so I am hoping to route around forcing that issue

[11:20:45.0000] <mathiasbynens>
if it makes people feel better, include a note in the spec saying that there is an inconsistency that is being addressed with a link to the github issue or something

[11:20:52.0000] <mathiasbynens>
oh ok :/

[11:21:24.0000] <mathiasbynens>
maybe it helps to not point these things out in future editor updates

[11:21:28.0000] <Bakkot>
yeah I guess

[11:21:29.0000] <Bakkot>
well

[11:21:31.0000] <mathiasbynens>
"last known bug in the spec"

[11:21:34.0000] <mathiasbynens>
it really doesn't matter

[11:21:34.0000] <Bakkot>
it wasn't really an editor update thing

[11:21:35.0000] <gibson042>
Bakkot: my preference would be to disallow `/(?<\u{1d49c}>.)/`, but I won't block consensus if there's broad support for it

[11:29:24.0000] <bradleymeck>
shu: https://github.com/hax/proposal-function-this/issues/2

[11:30:56.0000] <mathiasbynens>
Bakkot: it's also worth noting that a smaller change doesn't preclude us from making bigger changes later. otoh if we make the big change first, we likely won't be able to go back

[11:31:19.0000] <Bakkot>
no one will ever want to revisit this

[11:31:31.0000] <Bakkot>
I am not going to present something which says we might come back to it

[11:31:58.0000] <mathiasbynens>
Bakkot: you're asking for a pretty big change, and there is pressure with the whole ES2020 thing

[11:32:11.0000] <Bakkot>
I do not regard this as a big change.

[11:33:39.0000] <Bakkot>
I regard the details of which escape sequences are allowed as being a very small detail which will affect only tooling authors and perhaps a dozen humans writing code. (which non-escape characters are allowed affects far more people, of course.)

[11:35:50.0000] <Bakkot>
(sorry, specifically, which escape sequences are allowed _in named capture group names_. which are allowed in identifiers would be a larger change but I am not asking for a change there.)

[11:43:06.0000] <mathiasbynens>
I'm talking about supporting astral symbols in non-`u` RegExps in this case (in escaped form or not)

[11:44:12.0000] <Bakkot>
The spec explicitly permits non-escaped astral symbols in non-u regexes in capture group names; there is no possible ambiguity there.

[11:44:21.0000] <Bakkot>
We have consensus on that decision.

[11:51:19.0000] <mathiasbynens>
ack

[12:17:36.0000] <jackworks>
/me sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/yvvzqpdTpoHfygyQXbrYRQHB >

[12:23:13.0000] <bradleymeck>
jackworks: not to my knowledge

[12:23:41.0000] <Bakkot>
it came up on es-discuss some time back, I think

[13:46:13.0000] <TabAtkins>
Yeah, there's been discussion for it.

[13:46:33.0000] <TabAtkins>
(It's a great idea imo, tho I'd like a slightly different syntax.)

[13:46:50.0000] <TabAtkins>
(Line/indent-based syntax is a no-go for JS.)

[13:48:07.0000] <TabAtkins>
repurpose `with()` block imo

[13:49:37.0000] <rkirsling>
fwiw it doesn't require newlines in Dart

[13:49:38.0000] <devsnek>
it was blocked by nothing in the jsstdlib being usable with it

[13:49:48.0000] <devsnek>
well not "blocked"

[13:49:50.0000] <devsnek>
but demotivated

[13:52:21.0000] <jackworks>
imo we just need to change another symbol for it (`..` maybe not good with JS). and the dart style doesn't seems to related with indent.

[13:54:58.0000] <ljharb>
i'm a bit confused how it works

[13:55:07.0000] <ljharb>
is it a chain of expressions?

[13:55:18.0000] <ljharb>
how do asi/semis fit in

[13:55:27.0000] <devsnek>
it's a chain of member expressions

[13:55:37.0000] <devsnek>
same rules as one dot instead of two

[13:56:04.0000] <devsnek>
except the base of each one becomes the first item

[13:56:04.0000] <ljharb>
the assignment isn't that

[13:56:21.0000] <devsnek>
hm i didn't know you could do assignment in that

[13:56:28.0000] <ljharb>
also `..classes.add(‚Ä¶)` isn't a member expression

[13:56:31.0000] <ljharb>
it

[13:56:35.0000] <ljharb>
* it's a full expression

[13:57:04.0000] <devsnek>
that's a member expression

[13:57:05.0000] <rkirsling>
well it's an access and call chain

[13:57:16.0000] <rkirsling>
you can't use operators there, say

[13:57:27.0000] <ljharb>
devsnek: ok so the `..` chain is a chain of member expressions?

[13:57:33.0000] <devsnek>
that's what i expected anyway

[13:57:37.0000] <devsnek>
the assignment is weird

[13:57:40.0000] <ljharb>
how would optional chains fit in

[13:57:41.0000] <rkirsling>
it's called a "cascade" btw, just for helpful verbiage's sake

[13:57:42.0000] <devsnek>
but seems reasonable i guess???

[13:58:11.0000] <ljharb>
like how is this better than just a list of statements, repeating the object

[13:58:11.0000] <rkirsling>
Dart has `?.` too so you can see

[13:59:02.0000] <devsnek>
someone quick go implement cascade in engine262

[13:59:10.0000] <rkirsling>
err wait

[13:59:14.0000] <rkirsling>
that assignment _is_ weird

[13:59:23.0000] <rkirsling>
I didn't realize Dart even allowed that

[13:59:28.0000] <rkirsling>
we wouldn't have to

[13:59:36.0000] <devsnek>
yeah but modulo that

[13:59:43.0000] <rkirsling>
I don't think I support that part of it

[14:00:08.0000] <rkirsling>
but otherwise, "calling a bunch of things in succession on a single receiver object" is nice

[14:00:11.0000] <jackworks>
/me sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/qKaRPpWHbkFwQcUApJzlYFBe >

[14:00:31.0000] <ljharb>
jackworks: heads up that matrix turns your long messages into a link i have to click instead of showing text inline

[14:00:35.0000] <rkirsling>
^

[14:00:37.0000] <devsnek>
jackworks: btw your messages are appearing as "jackworks sent a long message <url>"

[14:00:46.0000] <devsnek>
and we have to click out to matrix.org to read your messages

[14:00:49.0000] <ljharb>
jackworks: yeah i do think that it's an asi problem

[14:00:56.0000] <Bakkot>
ljharb wait what's the ASI problem

[14:00:57.0000] <ryzokuken>
matrix yay :P

[14:01:04.0000] <devsnek>
i don't see an asi problem

[14:01:06.0000] <ljharb>
Bakkot: well i mean, conceptually, i'm sure the grammar can work

[14:01:14.0000] <Bakkot>
what's the conceptual problem

[14:01:24.0000] <ljharb>
because it looks like a bunch of statements, where `..` is the value of the last statement before all the double dot statements

[14:01:36.0000] <ljharb>
or a bunch of expressions

[14:01:46.0000] <Bakkot>
you can do `.method()` on a new line; being able to do `..method()` on a new line is... pretty much exactly the same thing, no?

[14:01:47.0000] <ljharb>
but with a multiline chain item, i think it'll be very confusing

[14:01:50.0000] <ljharb>
oh sure

[14:02:00.0000] <rkirsling>
yes

[14:02:01.0000] <devsnek>
ljharb: can you give an example

[14:02:03.0000] <ljharb>
but `.method` is "get method off of the thing it's dotted onto"

[14:02:04.0000] <devsnek>
i don't get what the confusion is

[14:02:27.0000] <ljharb>
let's ignore that confusion for now, i'll make an example if this idea gets more written out :-)

[14:02:40.0000] <jackworks>
oh I'm sorry, it only 296 words why matrix think it's long (maybe cause there are 2 code blocks in the msg)

[14:03:15.0000] <devsnek>
jackworks: i'm guessing its the newlines

[14:04:11.0000] <rkirsling>
again for the record, I think it's a great idea for access and call chains; the `=` part makes me frown

[14:04:50.0000] <Bakkot>
fwiw I don't think this feature is worth it

[14:05:15.0000] <Bakkot>
syntax which is aimed at not having to declare and refer to variables almost never seem worth it to me

[14:05:35.0000] <devsnek>
it's neat

[14:05:41.0000] <Bakkot>
agreed

[14:06:14.0000] <devsnek>
that's about all i can say about it

[14:06:15.0000] <rkirsling>
it is very useful for certain patterns that aren't necessarily common in JS, like StringBuilder

[14:06:29.0000] <devsnek>
i'm not sure its a good pattern for builders

[14:06:38.0000] <devsnek>
taking into account stuff like luxon

[14:06:42.0000] <devsnek>
where each method returns a new instance

[14:06:54.0000] <Bakkot>
rkirsling builders usually just return the instance from each method and it's not a problem

[14:07:15.0000] <rkirsling>
er yeah that's fair

[14:07:36.0000] <rkirsling>
but the DOM element example that jackworks gave is quite relevant

[14:08:00.0000] <rkirsling>
I was just giving the one example I could demonstrate with the Dart code that I've personally written üòì

[14:08:08.0000] <Bakkot>
the dom example requires appendTo existing, which it doesn't :P

[14:08:15.0000] <jackworks>
`console.log(date.withCalendar("japanese").era); // "reiwa"` shouldn't it return "‰ª§Âíå" instead of "reiwa"?

[14:08:20.0000] <rkirsling>
here's a thing that generates AST node classes from a YAML file: https://github.com/rkirsling/dlox/blob/master/tool/generate_ast.dart

[14:08:26.0000] <Bakkot>
in actual fact you'd still have to put it in a variable and then do parent.append(variable)

[14:09:00.0000] <rkirsling>
jackworks: yeah that's what michaelficarra asked too

[14:09:10.0000] <rkirsling>
probably the two-in-one character though

[14:09:32.0000] <rkirsling>
„ãø

[14:10:09.0000] <michaelficarra>
yeah it specifically should be the square era name

[14:12:06.0000] <jackworks>
lol

[14:29:43.0000] <mpcsh>
can we add "reify" to https://github.com/tc39/how-we-work/blob/master/terminology.md ?

[14:32:32.0000] <jridgewell>
Are you looking for a definition?

[14:32:38.0000] <jridgewell>
Yes, we should add it.

[14:32:39.0000] <ljharb>
mpcsh: be the change you want to see in the world

[14:33:16.0000] <mpcsh>
(I don't know what the term means, which is why I was asking here)

[14:33:42.0000] <jridgewell>
Currently `this.#foo` exists only as syntax

[14:33:43.0000] <Bakkot>
we should indeed add it. the meaning is, to give a language-level value to, which could be inspected and passed around as any other value could

[14:33:51.0000] <jridgewell>
`#foo` isn‚Äôt actually a property key

[14:33:56.0000] <ljharb>
mpcsh: ah ok fair

[14:34:02.0000] <jridgewell>
And doesn‚Äôt have a ECMAScript value

[14:34:09.0000] <jridgewell>
So you can‚Äôt type `console.log(#foo)`

[14:34:14.0000] <jridgewell>
Because it‚Äôs not a value

[14:34:26.0000] <jridgewell>
Reify means creating a value for it

[14:34:45.0000] <rkirsling>
it means "make concrete"

[14:35:14.0000] <rkirsling>
it's a really opaque term though if you're not used to it

[14:36:36.0000] <rkirsling>
"first-class representation" was a nice synonym just now

[14:37:07.0000] <rkirsling>
I've used "instantiable" instead of "reified" before but that doesn't apply in all occasions

[14:37:24.0000] <devsnek>
if we don't reify these as first class values i'm gonna cry

[14:37:34.0000] <bradleymeck>
are we talking about lexical referencing or straight 1st class reification as a value? i'm confused as i'd be wary of passing around the value

[14:37:53.0000] <devsnek>
i would kill to be able to pass around the value

[14:38:15.0000] <devsnek>
we could stop using non-enumerable symbols in node core

[14:39:51.0000] <devsnek>
really we just need private symbols

[14:40:20.0000] <jridgewell>
Can‚Äôt Node use V8 internals?

[14:40:31.0000] <jridgewell>
Meaning, can‚Äôt you just use V8‚Äôs internal Private Symbols?

[14:40:48.0000] <devsnek>
someone was against that

[14:40:54.0000] <devsnek>
but regardless

[14:40:58.0000] <devsnek>
it would be a shame to keep that fun to v8

[14:41:02.0000] <devsnek>
its such a useful feature

[14:41:12.0000] <jridgewell>
I really like Private Symbols...

[14:41:14.0000] <devsnek>
it fulfills all the use cases in such a natural way :(

[14:42:07.0000] <devsnek>
jridgewell: btw in node you can use https://npmjs.org/@snek/private

[14:42:48.0000] <jridgewell>
Link to source code?

[14:43:04.0000] <devsnek>
oh apparently i forgot to push lol

[14:43:05.0000] <devsnek>
https://github.com/devsnek/private

[14:43:12.0000] <jridgewell>
404

[14:44:34.0000] <devsnek>
jridgewell: https://github.com/devsnek/private-symbol/blob/master/private.cc

[14:47:46.0000] <jridgewell>
THanks

[14:48:07.0000] <jridgewell>
I was curious how you did it. Makes sense that it‚Äôs a native module

[14:48:20.0000] <devsnek>
yes :(

[14:48:35.0000] <devsnek>
i want to give this amazing api to all of js

[14:49:33.0000] <jridgewell>
If you run first, you could patch the `Object.keys` (and friends) to ignore regular regular symbols

[14:49:34.0000] <mpcsh>
jridgewell Bakkot ljharb rkirsling: https://github.com/tc39/how-we-work/issues/80

[14:49:50.0000] <devsnek>
jridgewell: can't patch for-in

[14:49:59.0000] <jridgewell>
for-in can‚Äôt return a Symbol

[14:50:01.0000] <devsnek>
oh neat

[14:50:21.0000] <jridgewell>
The only way to expose a Symbol is through the methods

[14:50:39.0000] <devsnek>
neat idea

[14:50:49.0000] <devsnek>
oh wait proxies

[14:50:55.0000] <ljharb>
Object.assign, object spread, Object.getOwnPropertySymbols, Reflect.ownKeys, proxies

[14:50:58.0000] <devsnek>
jridgewell: need the modifications for proxies

[14:51:02.0000] <jridgewell>
Yah, Proxy invariants will be super wonky

[14:51:02.0000] <ljharb>
those all interact with sym,bols

[14:51:09.0000] <Bakkot>
proxies were a mistake

[14:51:16.0000] <Bakkot>
the original sin of ES6

[14:51:26.0000] <jridgewell>
ljharb: That‚Äôs why I said ‚Äú(and friends)"

[14:51:32.0000] <jridgewell>
There are quite a few methods that need to be patched

[14:51:35.0000] <ljharb>
yeah

[14:51:38.0000] <jridgewell>
But it _could_ be done

[14:52:03.0000] <jridgewell>
I think Proxies are the only really hard part

[14:52:12.0000] <jridgewell>
Because of their internal invariant checks

[14:52:15.0000] <devsnek>
https://github.com/tc39/ecma262/compare/master...devsnek:feature/private-symbols?expand=1

[14:52:40.0000] <devsnek>
fairly small change in the spec at least

[14:52:54.0000] <devsnek>
the entire diff is +60-12

[14:53:15.0000] <jridgewell>
It‚Äôs much large, unfortunately

[14:53:20.0000] <Bakkot>
jridgewell this would also require discipline in never using a property a user-controlled object, because it might be a proxy with a `get` trap

[14:54:00.0000] <devsnek>
in my diff you have to tell the proxy which private symbols it can trap

[14:54:00.0000] <jridgewell>
https://docs.google.com/presentation/d/1HWM_pREmpz7QN9VrNeFt5T-x6CfKBL06pXhiQcxgfgU/edit

[14:54:11.0000] <devsnek>
so you're able to trap ones you can reach

[14:54:15.0000] <devsnek>
but the other ones can't be

[14:54:36.0000] <jridgewell>
That was my design as well!

[14:54:38.0000] <ljharb>
+1 to that

[14:54:48.0000] <ljharb>
you can only trap the ones you've proven you can already access

[14:54:59.0000] <jridgewell>
Bakkot: You have to wrap Proxy, too

[14:55:11.0000] <devsnek>
the entire proxy global

[14:55:14.0000] <jridgewell>
You have to ensure the handlers don‚Äôt receive a private symbol

[14:55:18.0000] <Bakkot>
ah and then proxy the proxy, fun

[14:55:20.0000] <Bakkot>
but yeah doable

[14:55:27.0000] <Bakkot>
s/proxy the proxy/proxy the handler/

[14:55:36.0000] <jridgewell>
I actually have an implementation of that.

[14:55:53.0000] <devsnek>
if we just figure out how private fields map to this

[14:56:00.0000] <devsnek>
we can propose it and retire

[14:56:19.0000] <Bakkot>
it was proposed and rejected

[14:56:22.0000] <jridgewell>
We can reify private fields to symbols, iff we keep the brand semantics

[14:56:33.0000] <devsnek>
you can say the throwing is part of the # syntax

[14:57:13.0000] <jridgewell>
My proposal got rejected due to using normal propery lookup semantics

[14:57:28.0000] <devsnek>
because heaven forbid they're just properties :(

[14:57:29.0000] <jridgewell>
It must throw, else there‚Äôll be many objections

[14:57:40.0000] <devsnek>
we have the throwing version

[14:57:44.0000] <devsnek>
objection handled

[14:57:58.0000] <Bakkot>
that does not in fact handle the objection

[14:58:05.0000] <devsnek>
then why is it in the language

[14:58:13.0000] <devsnek>
well stage 3

[14:58:20.0000] <Bakkot>
years and years of consensus-building

[14:58:24.0000] <Bakkot>
decades, even

[14:58:47.0000] <jridgewell>
Which part are you talking about?

[14:59:18.0000] <jridgewell>
Reification is its own discussion, but private symbols with brand semantics would be possible

[14:59:34.0000] <jridgewell>
My proposal was several changes, and there were objections to basically each

[14:59:48.0000] <jridgewell>
But that doesn‚Äôt change the symbol reification is possible

[15:02:17.0000] <TabAtkins>
Jumping back for a moment: the point of the cascade operator is that it allows you to do chaining on APIs that *don't* support chaining explicitly. (Such as a *lot* of legacy DOM APIs.) If an API is, say, already using the chained-builder pattern, then it's not necessary, as normal method chaining works there.

[15:04:25.0000] <jackworks>
property assignment doesn't support chaining. I have to add a `enableSomeFeature()` that return `this` to prevent the awkward break of chaining

[15:04:27.0000] <rkirsling>
TabAtkins: +1, sorry for the misspeak

[15:06:23.0000] <TabAtkins>
What confuses me about Dart's syntax is that it appears to bless the receiver of the first cascade operator in an expression, such that all subsequent cascades in the same expression use the same receiver? That feels weird as heck to me.

[15:07:25.0000] <ljharb>
same

[15:08:35.0000] <TabAtkins>
That all said, hmmmm, does pipeline+comma give us this ability natively? `document.createElement('div') |> #.className = 'abc', #.onclick = ()=>{}, #.appendTo(document.body), #`

[15:08:58.0000] <ljharb>
oof

[15:09:11.0000] <ljharb>
(i don't think it does currently, the position of the placeholder is pretty constrained atm)

[15:09:17.0000] <TabAtkins>
Okay one sec, lemme make it multiline ^_^

[15:09:43.0000] <TabAtkins>
(I'm specifically using the hack-syntax pipelines; all other pipelines syntaxes are dead to me for their inherent weaknesses)

[15:10:39.0000] <TabAtkins>
```

[15:10:39.0000] <TabAtkins>
document.createElement('div') |>

[15:10:39.0000] <TabAtkins>
    #.className = 'abc',

[15:10:39.0000] <TabAtkins>
    #.onclick = ()=>{},

[15:10:39.0000] <TabAtkins>
    #.appendTo(document.body),

[15:10:40.0000] <TabAtkins>
    #

[15:10:40.0000] <TabAtkins>
```

[15:10:48.0000] <devsnek>
uhoh

[15:11:13.0000] <ljharb>
yeah i got what you meant, but the current proposal grammar doesn't allow that

[15:11:24.0000] <TabAtkins>
Which "current proposal"?

[15:11:25.0000] <ljharb>
(afaik)

[15:11:51.0000] <ljharb>
the current pipeline proposal is down to F# and "smart", iirc, and both of those have semantics largely written down

[15:11:57.0000] <ljharb>
no idea which one is hack

[15:12:00.0000] <TabAtkins>
Smart allows this.

[15:12:02.0000] <ljharb>
k

[15:12:09.0000] <TabAtkins>
Hack is just "always require the #"

[15:12:14.0000] <Bakkot>
oh god

[15:12:14.0000] <TabAtkins>
So smart without the smarts.

[15:14:03.0000] <ljharb>
that kills point-free style?

[15:14:19.0000] <TabAtkins>
Note that this allows slightly wider sets of syntaxes than cascade, even: `el.appendTo(newParent)` isn't even valid syntax, but cascade requires it to exist. In DOM it's instead `newParent.appendChild(el)`, which you'd write as `document.body.appendChild(#)` in the above example

[15:14:24.0000] <jschoi>
The Hack doesn‚Äôt allow tacit style, yeah. It doesn‚Äôt have a formal proposal.

[15:14:31.0000] <devsnek>
what if you just wrote what the computer should do in prose

[15:14:37.0000] <devsnek>
the most smart

[15:14:42.0000] <jschoi>
The DWIM operator.

[15:14:50.0000] <TabAtkins>
(I'm not implying that I ignore smart; smart is good and pure; I was just saying that point-free is dead to me.)

[15:15:25.0000] <jschoi>
What‚Äôs this pipeline-comma operator, though?

[15:15:50.0000] <Bakkot>
it's just pipeline plus the existing horror that is the comma operator, as I understand it

[15:15:58.0000] <TabAtkins>
yup

[15:16:05.0000] <TabAtkins>
just ordinary, everyday horrifying comma

[15:16:33.0000] <devsnek>
can we fit entire programs into pipelines

[15:16:44.0000] <jschoi>
I‚Ä¶think comma behinds less tightly than the pipe operator, but it‚Äôs been a while since I‚Äôve been able to look at my own proposal, haha.

[15:18:10.0000] <TabAtkins>
i'm pretty sure that assignment is looser than pipe as well, so actually nm

[15:18:23.0000] <TabAtkins>
you'd need parens

[15:18:57.0000] <jschoi>
document.createElement('div') |> (#.className = 'abc', #.onclick = () => {}, #.appendTo(document.body));

[15:18:58.0000] <TabAtkins>
and at that point you might as well just `(x=>{...})(document.createElement('div'))`, honestly.

[15:18:58.0000] <rkirsling>
it should be, yeah

[15:19:08.0000] <rkirsling>
ternary, then assignment, then everything else

[15:19:20.0000] <jschoi>
Or maybe eventually:

[15:19:24.0000] <TabAtkins>
wait you can do assignment in a ternary?

[15:19:24.0000] <jschoi>
document.createElement('div') |> {

[15:19:24.0000] <jschoi>
  #.className = 'abc',

[15:19:24.0000] <jschoi>
  #.onclick = () => {},

[15:19:24.0000] <jschoi>
  #.appendTo(document.body);

[15:19:24.0000] <jschoi>
}

[15:19:38.0000] <jschoi>
Er, those should be semicolons in that block.

[15:19:44.0000] <TabAtkins>
yes

[15:19:48.0000] <TabAtkins>
i'm for it

[15:19:50.0000] <jschoi>
I haven‚Äôt kept up; I don‚Äôt know how do-expressions have been doing.

[15:19:54.0000] <TabAtkins>
still bad

[15:20:04.0000] <rkirsling>
er oops I misspoke again

[15:20:15.0000] <rkirsling>
ü§¶

[15:20:28.0000] <jschoi>
Bad = those problems with loop control?

[15:20:33.0000] <rkirsling>
comma, assignment, ternary, ...

[15:20:39.0000] <TabAtkins>
wait: `((x=document.createElement('div'))=>{x.classList = 'abc'; ... })()`, there, now it has the starting value up front

[15:20:56.0000] <TabAtkins>
too many parens, but oh well

[15:21:01.0000] <Bakkot>
bad = we have not revisted it mostly, I think

[15:21:14.0000] <TabAtkins>
yeah, nobody's touched it i meant

[15:21:49.0000] <jschoi>
Gotcha.

[15:21:50.0000] <ljharb>
so many proposals, current and future, would be obsoleted or made simpler with do expressions :-(

[15:21:54.0000] <rkirsling>
did Dave disappear now too? üòì

[15:21:55.0000] <TabAtkins>
YUP

[15:22:45.0000] <jschoi>
What has had most of TC39‚Äôs attention lately? I need to read the latest minutes‚Ä¶

[15:22:50.0000] <TabAtkins>
So pipeline + do-expr would give you the arrow-function above, but with a lot less parens to worry about.

[15:23:09.0000] <TabAtkins>
aka the standard benefit of pipeline, so yay

[15:23:59.0000] <Bakkot>
jschoi empirically, what has most of our attention is "which kind of unicode escape sequences should be usable in named capture group names for non-BMP unicode characters"

[15:24:15.0000] <jschoi>
Aw yeah.

[15:24:17.0000] <devsnek>
do expressions are on my proposal list https://snek.dev/proposal-list

[15:24:51.0000] <TabAtkins>
I mean the answer is always "whatever topics are interesting to people attending the meetings", and nobody at the meetings is currently interested in moving do-exprs.

[15:25:08.0000] <TabAtkins>
devsnek: Ooh, and it's the next one up, nice

[15:25:18.0000] <devsnek>
TabAtkins: not ordered

[15:25:24.0000] <devsnek>
sorry ‚ù§Ô∏è

[15:25:26.0000] <TabAtkins>
I choose not to believe you!

[15:25:28.0000] <devsnek>
lol

[15:26:06.0000] <jackworks>
so is "implicit do expression" making every statement (that can be wrapped in a explicit do expr) a valid expression in JavaScript?

[15:26:38.0000] <Bakkot>
jackworks where did you see that phrase?

[15:26:51.0000] <Bakkot>
answer depends on where you saw it

[15:26:53.0000] <Bakkot>
(but probably yes)

[15:27:45.0000] <jackworks>
oh i like it

[15:28:12.0000] <jschoi>
I love it too. It would make one of smart pipe‚Äôs subproposals obsolete.

[15:28:12.0000] <devsnek>
some don't make sense

[15:28:14.0000] <devsnek>
but others do

[15:28:30.0000] <devsnek>
if expressions and throw expressions would be nice

[15:29:48.0000] <Bakkot>
it'd be weird to have both those and do expressions though

[15:30:02.0000] <devsnek>
it wouldn't

[15:30:12.0000] <Bakkot>
it wouldn't be weird?

[15:30:18.0000] <devsnek>
i don't think it would

[15:30:37.0000] <devsnek>
i use block expressions in rust all the time

[15:31:13.0000] <Bakkot>
rust is a different language

[15:32:58.0000] <devsnek>
Bakkot: for the same reasons i would use them in js

[15:33:41.0000] <Bakkot>
devsnek sure, and do expressions might make sense; the point is that it would be would be weird to have three different ways to write a conditional in expression position

[15:33:47.0000] <jridgewell>
devsnek: Why `function.sent`?

[15:34:08.0000] <devsnek>
Bakkot: oh we don't have to have if expressions

[15:34:17.0000] <devsnek>
jridgewell: why not

[15:34:21.0000] <jridgewell>
If we could just get do expressions, I think that's an argument for not having if expressions.

[15:34:22.0000] <devsnek>
its useful

[15:34:33.0000] <jridgewell>
But it's soo hard to get do expressions, why not if statements now.

[15:34:42.0000] <Bakkot>
we have if statements :P

[15:34:44.0000] <devsnek>
is it that hard

[15:34:50.0000] <jridgewell>
Do you have an example?

[15:34:53.0000] <devsnek>
is the objection still about implicit return semanticss

[15:34:58.0000] <jridgewell>
Yah

[15:35:01.0000] <TabAtkins>
we should remove if statements, to encourage do-exprs.

[15:35:06.0000] <devsnek>
we have eval

[15:35:18.0000] <Bakkot>
devsnek yes but we shouldn't, everyone agrees we shouldn't except like mark

[15:35:20.0000] <Bakkot>
eval is terrible

[15:35:36.0000] <devsnek>
what was the problem with implicit returns again

[15:35:37.0000] <jridgewell>
Whatever that OCP (I don't remember the acronym) closure requirements were.

[15:35:40.0000] <Bakkot>
the big points of contention are 1) whether you can put break / return in expressions and 2) completion values are weird

[15:35:53.0000] <Bakkot>
TCP

[15:35:58.0000] <Bakkot>
tenant's correspondence principle

[15:35:59.0000] <Bakkot>
or something like that

[15:36:02.0000] <devsnek>
if we don't have break and return there's no reason to have do expressions

[15:36:03.0000] <michaelficarra>
Tennet

[15:36:04.0000] <jschoi>
Yeah, that was the big problem.

[15:36:10.0000] <devsnek>
you can polyfill them with eval without tcp

[15:36:29.0000] <devsnek>
a big reason i want them is the return

[15:36:36.0000] <TabAtkins>
"you can polyfill them with eval" is... not a valid argument for "we don't need X" imo ^_^

[15:36:44.0000] <Bakkot>
+1

[15:37:02.0000] <devsnek>
i would add it to the private field list of sad things

[15:37:13.0000] <devsnek>
along with records

[15:37:31.0000] <jridgewell>
I really wish `eval('foo')` didn't hit CSP.

[15:37:46.0000] <devsnek>
i really wish trusted types didn't exist

[15:37:48.0000] <jridgewell>
If that were the case, we'd already have do expressions.

[15:40:07.0000] <TabAtkins>
That all said, I'm def still in the camp that we should just exactly match the eval() return semantics (even if they're nasty in some cases like loops) for simplicity (no more discussions needed!) and also I just plain don't understand what the return/break problems are

[15:43:44.0000] <Bakkot>
so glad eval hits CSP

[15:43:45.0000] <Bakkot>
so glad

[15:44:01.0000] <Bakkot>
devsnek they don't exist yet!

[15:44:05.0000] <Bakkot>
but they probably will

[15:44:27.0000] <Bakkot>
I also didn't like them originally, still think they're ugly but will probably make actual users actually safer, so I am willing to accept them

[15:44:32.0000] <Bakkot>
users of websites, that is

[15:44:42.0000] <Bakkot>
who are the most numerous and highest (to me) priority group

[15:45:34.0000] <devsnek>
I'm not convinced but ü§∑

[15:45:37.0000] <devsnek>
I don't do web spec

[15:45:45.0000] <jridgewell>
`eval(foo)` should certainly hit CSP

[15:45:48.0000] <Bakkot>
my day job involves talking to engineers at banks

[15:45:55.0000] <Bakkot>
which informs my perspective here

[15:46:11.0000] <jridgewell>
But why should `eval('foo')`?

[15:46:14.0000] <devsnek>
do they ask for decimals

[15:46:17.0000] <Bakkot>
jridgewell ahhh

[15:46:25.0000] <Bakkot>
devsnek not the web devs, who are the ones I talk to

[15:46:32.0000] <Bakkot>
but they don't ask for anything when I am talking to them

[16:14:04.0000] <jmdyck>
not Tenant or Tennet, but Tennent. E.g.: https://fanf.livejournal.com/118421.html

[16:15:11.0000] <ljharb>
tenant vs tenet vs Tennant (doctor who) vs Tennent (TCP)

[16:23:00.0000] <mpcsh>
Bakkot: with regards to symmetry with Identifier, is there appetite for refactoring Identifier?

[16:23:20.0000] <Bakkot>
mpcsh there's nonzero appetite but also some strong opposition

[16:23:33.0000] <gibson042>
in what way? to allow surrogate pairs?

[16:23:56.0000] <mpcsh>
probably? I was just curious if people had Thoughts on this

[16:24:47.0000] <rkirsling>
I would assume there would be stronger Unicode-hat opposition to that move

[16:25:11.0000] <ljharb>
mathiasbynens in particular has expressed a strong preference to avoid exposing surrogate pairs in more places

[16:25:42.0000] <mpcsh>
very fair. is there appetite for banning surrogate pairs entirely anywhere in the language?

[16:26:00.0000] <ljharb>
web compat precludes that anywhere

[16:26:09.0000] <gibson042>
I am personally in favor for the author simplicity of "\u escapes work except for the special case of non-Unicode regular expressions", but there is definitely strong opposition on the committee

[16:26:40.0000] <gibson042>
"\u escapes of both flavors"


2020-04-02
[17:09:08.0000] <jschoi>
Many SMP code points (surrogate pairs) are already valid in identifiers and strings. Are you talking about lone surrogate code points?

[17:15:04.0000] <Bakkot>
jschoi `\uLEAD\uTRAIL` is never legal in an identifier

[17:15:45.0000] <Bakkot>
the grammar allows it but an early error rule forbids it (specifically https://tc39.es/ecma262/#sec-identifier-names-static-semantics-early-errors )

[17:22:13.0000] <jschoi>
Isn‚Äôt \uLEAD illegal because LEAD isn‚Äôt a hexadecimal code?

[17:22:26.0000] <jschoi>
Though I need to reread the spec.

[17:24:12.0000] <Bakkot>
sorry, that's a shorthand

[17:24:45.0000] <Bakkot>
I mean to say that, for example, `\ud835\udc9c` is never legal in an identifier

[17:25:06.0000] <Bakkot>
even though directly using the code point represented by that pair of surrogates, ùíú, is

[17:31:38.0000] <michaelficarra>
and we should change that because it's ridiculous

[17:35:40.0000] <rkirsling>
I mean somebody could propose it, and then if it gets blocked as predicted we'd have it on the record :P

[17:37:28.0000] <michaelficarra>
there's no reason to allow only BMP characters to be escaped in identifiers, who is going to argue for that?

[17:38:13.0000] <Bakkot>
you can use `\u{}` to put any code point in an identifier

[17:38:22.0000] <Bakkot>
well, any ID_part

[17:38:45.0000] <Bakkot>
so this would just be adding another way to do it

[17:38:54.0000] <Bakkot>
and this way involves surrogate pairs

[17:39:03.0000] <Bakkot>
which many people want to not put in new places

[17:41:47.0000] <devsnek>
i'd be against surrogate pairs in more places

[17:41:58.0000] <devsnek>
our language doesn't have to be utf16

[17:42:02.0000] <devsnek>
:(

[17:42:12.0000] <michaelficarra>
so with this mental model \uXXXX is just shorthand for BMP \u{...}

[17:42:23.0000] <Bakkot>
I wish our language was utf16, but it's not even that

[17:42:25.0000] <michaelficarra>
devsnek: you're in luck, it's not

[17:42:35.0000] <devsnek>
utf16ish

[17:42:54.0000] <devsnek>
i always do the {} when i do that

[17:43:58.0000] <michaelficarra>
you use escape sequences in your identifiers?

[17:44:27.0000] <devsnek>
in strings sometimes

[17:44:31.0000] <devsnek>
never in identifiers

[17:44:56.0000] <michaelficarra>
we're just talking about identifiers

[17:45:16.0000] <devsnek>
if i did them in identifiers i'd use {} too

[17:46:08.0000] <jschoi>
If \u{} is already legal, then \u with surrogate pairs should be legal; I think the Unicode Standard is clear about that always being the case, regardless of the particular UTF encoding‚Ä¶

[17:46:31.0000] <michaelficarra>
jschoi: can you point me to any relevant documentation?

[17:46:37.0000] <jschoi>
Yeah, I need to check again.

[17:46:41.0000] <jschoi>
I‚Äôll let you know if I do.

[17:46:48.0000] <michaelficarra>
cool

[17:46:55.0000] <jschoi>
That is, I think the Standard says surrogate pairs must always be equivalent to their respective SMP points.

[17:47:06.0000] <jschoi>
But I‚Äôll try to find a citation later.

[17:48:02.0000] <michaelficarra>
it may not directly apply to our use of escape sequences, but it will at least be a relevant recommendation

[17:49:04.0000] <devsnek>
surrogate pairs aren't legal in this context

[17:49:12.0000] <devsnek>
they aren't decoded incorrectly

[17:50:00.0000] <michaelficarra>
they're not treated equivalently to the code point itself or the escape sequence for the code point either

[17:50:17.0000] <devsnek>
i guess

[17:50:23.0000] <michaelficarra>
if Unicode has a recommendation that they're not to be treated differently, I think it'd be relevant

[17:50:30.0000] <rkirsling>
don't get me wrong, I support the consistency

[17:51:00.0000] <devsnek>
i don't think any humans at unicode would want there to be pairs in more places at least

[17:51:04.0000] <rkirsling>
it's just that (Unicode-hat) sffc and mathiasbynens expressed opposition to having surrogate pairs valid in more contexts

[17:51:24.0000] <rkirsling>
(whether that's an objection or not)

[18:01:48.0000] <devsnek>
what happens if you remove an item from an array while doing forEach

[18:02:09.0000] <devsnek>
i think you end up skipping the next element

[18:02:48.0000] <devsnek>
yeah that seems right

[18:02:52.0000] <Bakkot>
truth comes out of her well to shame you

[18:02:53.0000] <jridgewell>
Do you mean via `splice`?

[18:03:09.0000] <jridgewell>
Bakkot: uhhhh...

[18:03:40.0000] <devsnek>
splice yes

[18:03:42.0000] <Bakkot>
nsfw-ish https://en.wikipedia.org/wiki/Truth_Coming_Out_of_Her_Well

[18:04:05.0000] <devsnek>
i need to do "for each item of cells if cell is x then remove cell"

[18:04:16.0000] <devsnek>
maybe filter

[18:04:27.0000] <devsnek>
filter wouldn't be too crazy but

[18:04:28.0000] <Bakkot>
that sounds like what filter is for

[18:04:30.0000] <devsnek>
hmm

[18:04:43.0000] <devsnek>
actually no i can't do it in a callback sigh

[18:05:43.0000] <devsnek>
https://gc.gy/53494539.png

[18:07:36.0000] <Bakkot>
what's wrong with a filter?

[18:07:39.0000] <Bakkot>
is Q a macro?

[18:07:43.0000] <devsnek>
yeah

[18:07:45.0000] <Bakkot>
I guess it must be

[18:07:48.0000] <Bakkot>
makes sense

[18:07:51.0000] <devsnek>
it expands to a return

[18:07:57.0000] <devsnek>
if the value is abrupt

[18:08:02.0000] <devsnek>
yay for macros

[18:18:35.0000] <devsnek>
mhofman: would marking the values of weakmaps fix the problem here?

[18:18:55.0000] <devsnek>
i feel like that should work but it seems too easy

[18:19:09.0000] <devsnek>
(assuming that the key and the value aren't the same object)

[18:19:28.0000] <mhofman>
then you'd miss a lot of cases where the keys are only accessible through the values

[18:21:09.0000] <mhofman>
aka obj1 references obj2, which references obj1, and both are mapping each other in the WeakMap

[18:21:35.0000] <mhofman>
cycles are fun :)

[18:22:19.0000] <devsnek>
that would leak though, not be collected too soon

[18:22:25.0000] <mhofman>
correct

[18:24:22.0000] <devsnek>
i'm having a hard time thinking of an optimal solution

[18:26:05.0000] <mhofman>
WeakMap are hard. I think the approach taken by polyfills is acceptable, even though they also leak, it's less critical

[18:26:35.0000] <devsnek>
i can't associate them directly in the way the polyfills do

[18:26:53.0000] <devsnek>
i don't think...

[18:27:27.0000] <devsnek>
i still need to have the spec's mapping where the weakmap holds the values

[18:29:07.0000] <devsnek>
i could just go full ephemeron i guess

[18:34:01.0000] <mhofman>
I'm way not familiar with all this, but couldn't you have each ObjectValue keep a Map of WeakMap instances where it's a key to the value it's associated with in those WeakMap?

[18:34:18.0000] <devsnek>
oh i just pinged you on the issue with a possible fix lol

[18:34:33.0000] <devsnek>
after marking just go through the weakmaps again and check their keys and values

[18:34:59.0000] <mhofman>
that's basically going ephemeron ;)

[18:35:05.0000] <devsnek>
yep

[18:37:19.0000] <mhofman>
from what I remember there is some recursion needed when you deal with ephemerons. I believe you may find more WeakMap keys that need be marked

[18:38:23.0000] <devsnek>
hmmmmm

[18:41:49.0000] <mhofman>
I believe the way it could be done is to add the entries of weakmaps to a Map, and everytime you mark a key, you remove the entry and mark the value

[18:42:21.0000] <mhofman>
s/Map/queue/

[18:45:21.0000] <devsnek>
yeah that makes sense

[19:02:32.0000] <jschoi>
michaelficarra: I was mistaken. The Unicode Standard has no normative requirement that surrogate pairs be always interpreted as their respective SMP points regardless of UTF encoding‚Äînor does it seem to normatively prohibit them in non-UTF-16 encodings. It merely says in Definitions 74 and 75 that surrogate pairs are designed for use in UTF-16.

[19:04:21.0000] <michaelficarra>
aww that's too bad jschoi

[19:04:54.0000] <michaelficarra>
I probably won't bring forward a proposal to change identifier then, if it's going to get pushback

[20:17:01.0000] <devsnek>
ljharb: very exciting that es2017 was finally released :P

[20:18:35.0000] <ljharb>
lol

[20:18:48.0000] <ljharb>
there's no way to make a release silently ¬Ø\_(„ÉÑ)_/¬Ø

[21:05:30.0000] <jmdyck>
hm looks like 1892 needs some fixes.

[21:05:39.0000] <jmdyck>
sorry, 1869.

[21:05:59.0000] <ljharb>
jmdyck: tldr?

[21:06:13.0000] <ljharb>
i'm cutting the spec as we speak, so time's a factor :-)

[21:06:35.0000] <jmdyck>
I'll see what I can do.

[21:06:56.0000] <ljharb>
thanks

[21:09:49.0000] <Bakkot>
oh, I missed the [U] flags on the LHSes in the early error rules

[21:09:55.0000] <Bakkot>
I never remember to look for the flags there

[21:10:00.0000] <Bakkot>
the RHSes too I guess

[21:10:01.0000] <Bakkot>
bah

[21:10:07.0000] <Bakkot>
that's what I get for writing spec when tired

[21:11:44.0000] <jmdyck>
and not just early error rules

[21:11:59.0000] <ljharb>
k well hopefully the PR gets up and gets a review or two tonight, and i'll cut a spec in the morning

[21:13:07.0000] <Bakkot>
the other SDOs too, yeah

[21:15:13.0000] <Bakkot>
someday we will have a linter which will stop me from shooting myself in the foot

[21:15:14.0000] <Bakkot>
someday

[21:15:18.0000] <Bakkot>
jmdyck is it just the stray flags?

[21:15:25.0000] <Bakkot>
I can make a PR for that right now if you're busy

[21:15:41.0000] <jmdyck>
that's all i've found so far, but i'm not finished.

[21:15:57.0000] <jmdyck>
(flags = gram parameters)

[21:17:25.0000] <Bakkot>
indeed

[21:25:46.0000] <devsnek>
oh that's very soon

[21:25:48.0000] <devsnek>
shu: littledan: would be nice to get this figured out https://github.com/tc39/ecma262/commit/c59502090e2c250cd7e457b5506b92db6b21d153#diff-3540caefa502006d8a33cb1385720803R7599

[21:29:44.0000] <jmdyck>
ok, finished analysis, starting pr

[21:36:40.0000] <jmdyck>
https://github.com/tc39/ecma262/pull/1929

[21:40:46.0000] <Bakkot>
jmdyck thanks!

[21:40:53.0000] <jmdyck>
yw

[22:31:34.0000] <devsnek>
can someone archive the import.meta repo

[04:24:57.0000] <littledan>
devsnek: I believe the PR that was merged preserves the invariants that were there before. If you want to add additional invariants, that seems like a good topic for a separate PR.

[06:19:51.0000] <devsnek>
littledan: job records had realm and scriptormodule which was used when creating the context in RunJobs

[06:31:37.0000] <littledan>
devsnek: OK, do you think there were any invariants attached to those record fields that we've removed?

[06:31:57.0000] <littledan>
I think the record fields were removed because they were unused, so I don't really understand the issue

[06:32:14.0000] <devsnek>
littledan: they were used to set the correct realm and scriptormodule

[06:33:49.0000] <devsnek>
in EnqueueJob it would grab them from the current execution context

[06:34:17.0000] <devsnek>
and operations in the spec fail if those slots aren't correctly set

[06:34:24.0000] <littledan>
yes, they were recorded there. Are you taking the descriptions in table 25 as normative?

[06:34:41.0000] <littledan>
I thought it ended up being more up to the embedder to use them

[06:35:31.0000] <devsnek>
I'm not aware of anything that made RunJobs non normative

[06:36:12.0000] <devsnek>
wasn't the whole problem that RunJobs was normative but no one implemented the RunJobs loop

[06:37:28.0000] <littledan>
right, RunJobs was "dead spec" in HTML, unfortunately

[06:38:14.0000] <littledan>
so, the version of the patch that I produced preserved the job records, based on my understanding of TC39 consensus. The editor group decided that it would be OK to remove the job record. I'd follow up with them here.

[06:38:34.0000] <devsnek>
but regardless of how people treated that section it correctly described how to set up the context and now we don't have that

[06:38:53.0000] <devsnek>
I'll open an issue or something I guess

[06:42:59.0000] <littledan>
yes, so I proposed that we preserve that setup

[06:43:11.0000] <littledan>
an issue sounds like a good place to follow up

[08:13:09.0000] <shu>
i'm not understanding what makes that normative

[08:13:44.0000] <devsnek>
shu: what

[08:14:11.0000] <shu>
devsnek: the contextorrealm stuff for job records

[08:14:33.0000] <devsnek>
it was normative because it was in the spec and it wasn't normative optional

[08:14:44.0000] <devsnek>
actually even normative optional stuff is normative

[08:15:05.0000] <devsnek>
if you wanted to queue a promise job the spec defined how to queue and run them using RunJobs

[08:35:39.0000] <shu>
it wasn't normative in practice?

[08:36:15.0000] <shu>
not only was it not used by upstream specs, it was willfully violated by html, as dan said

[08:36:20.0000] <devsnek>
the loop wasn't but how to run an individual job definitely was

[08:37:35.0000] <devsnek>
my point is just that we went from the spec correctly saying how to run a job to the spec not correctly saying how to run a job

[09:09:56.0000] <shu>
what are we saying incorrectly now?

[09:10:17.0000] <shu>
i mean the realms that were used for promises were in fact not correct before, for html

[09:11:56.0000] <devsnek>
shu: all engines implemented context setup correctly as RunJobs specified

[09:11:59.0000] <devsnek>
and still do

[09:12:26.0000] <shu>
RunJobs wasn't used?

[09:12:28.0000] <shu>
i'm confused

[09:12:41.0000] <shu>
what does it mean to implement dead code correctly

[09:12:51.0000] <devsnek>
the logic within run jobs

[09:13:04.0000] <devsnek>
the active realm when a promise job is queued

[09:13:12.0000] <shu>
that's up to the host

[09:13:13.0000] <devsnek>
needs to be the active realm when the job is run

[09:13:27.0000] <devsnek>
and all the implementations do that correctly

[09:13:30.0000] <devsnek>
as far as i know

[09:13:41.0000] <devsnek>
but we don't specify it

[09:14:50.0000] <shu>
i'd be happy to look at a PR

[09:15:09.0000] <shu>
hard for me to understand what exactly is incorrect in deleted dead code

[09:17:02.0000] <devsnek>
the deleted dead code was correct

[09:17:08.0000] <devsnek>
aside from the loop

[09:17:16.0000] <devsnek>
i can make a pr i suppose

[09:18:29.0000] <shu>
correctness of dead code is just not a well-formed thing, i really don't understand what that means

[09:19:25.0000] <devsnek>
implementations that weren't browsers

[09:19:31.0000] <devsnek>
and didn't ignore runjobs

[09:19:43.0000] <devsnek>
at least didn't ignore it as much as html did

[09:19:54.0000] <devsnek>
would get a correct implementation of ecmascript by using the steps within the run jobs loop

[09:20:16.0000] <devsnek>
they will not get a correct implementation of ecmascript by using the description currently in the spec

[09:20:41.0000] <shu>
the current description requires the implementation to implement HostEnqueuePromiseJob

[09:21:03.0000] <devsnek>
yes

[09:21:10.0000] <shu>
and implementations withouts specs are more than welcome to keep the historical invariants in there

[09:21:53.0000] <devsnek>
i mean the spec literally doesn't function

[09:21:55.0000] <devsnek>
if the realm isn't set

[09:22:04.0000] <devsnek>
you will fail an assertion in CreateBuiltinFunction

[09:23:20.0000] <shu>
if the host hook doesn't set the execution context with script that it's trying to run?

[09:23:41.0000] <devsnek>
the host hook doesn't have an execution context

[09:24:09.0000] <shu>
in 8.4, there is a list of invariants describing what host AOs for scheduling jobs must adhere to

[09:24:15.0000] <shu>
the first bullet point is "Push an execution context onto the execution context stack."

[09:24:22.0000] <shu>
perhaps you're asking for that list of invariants to be tighter?

[09:24:41.0000] <devsnek>
yes that's what i keep saying

[09:25:05.0000] <devsnek>
we need to specify the realm (and maybe scriptormodule) that that execution context uses

[09:27:35.0000] <shu>
the realm is a per-kind-of-job thing i imagine

[09:28:03.0000] <devsnek>
perhaps

[09:28:25.0000] <shu>
for HostEnqueuePromiseJob itself, since we pull out the right realm on our side

[09:28:39.0000] <devsnek>
i'm not sure what that means

[09:28:52.0000] <shu>
sorry, i didn't finish the sentence

[09:29:51.0000] <devsnek>
https://www.irccloud.com/pastebin/BN8eZ53s/maybe_fixed.html

[09:29:58.0000] <devsnek>
i'm saying we need to do something more like this

[09:32:09.0000] <devsnek>
and then we just have to specify what _realm_ is for HostEnqueuePromiseJob

[09:32:56.0000] <shu>
the logic in html is more complicated than that afaiu

[09:33:22.0000] <devsnek>
the host is kind of a moot point here

[09:33:47.0000] <devsnek>
the context needs to fulfill invariants of ecmascript itself

[09:36:39.0000] <devsnek>
in html `set script execution context to a new JavaScript execution context, with its Function field set to null, its Realm field set to active script's settings object's Realm, and its ScriptOrModule set to active script's record.`

[09:37:17.0000] <shu>
only if the active script is not null

[09:37:38.0000] <shu>
usually it's the active script's context

[09:37:42.0000] <devsnek>
in ecmascript that's "the realm of the current execution context"

[09:38:28.0000] <devsnek>
it never reuses the same context

[09:38:57.0000] <devsnek>
actually in html it looks like it might run a job with no execution context at all

[09:38:59.0000] <shu>
it may never make an execution context

[09:39:00.0000] <devsnek>
that breaks even more stuff lol

[09:40:46.0000] <devsnek>
and doesn't fulfill ecmascript either ("the implementation must: 1. Push an execution context onto the execution context stack.")

[09:43:56.0000] <shu>
yeah i don't even know when the active script is null and this host hook would be called

[09:44:37.0000] <devsnek>
so basically i think we need to give all jobs a ScriptOrModule and a Realm, and set the execution context fields correctly

[09:44:44.0000] <shu>
tightening up sounds good, could you make a PR? i'd still need to think about it more carefully i have time

[09:44:57.0000] <devsnek>
where the ScriptOrModule and Realm come from is up to the thing that is queuing at least

[09:45:01.0000] <shu>
there're two timings for the hooks: enqueue time, and job-running time

[09:45:06.0000] <devsnek>
i can try to put something together

[09:46:41.0000] <shu>
execution context creation might not be observable, but since it depends on the active script, which is an observable thing, seems like we need to separate during what time does context creation happen

[10:00:24.0000] <devsnek>
shu: https://github.com/tc39/ecma262/pull/1934

[10:03:08.0000] <shu>
devsnek: thanks, i'll try to get to reviewing it next week. i'm not fully grokking the html part yet

[10:03:19.0000] <devsnek>
üëçüèª

[10:05:02.0000] <shu>
devsnek: something is off there in that we don't always create a new execution context

[10:05:27.0000] <devsnek>
probably just needs to be "assert that there is an active script" instead of branching

[10:05:40.0000] <shu>
no, there can definitely be no active script

[10:05:42.0000] <shu>
that i confirmed

[10:05:51.0000] <shu>
there is an example below in the spec, with a button onclick

[10:06:02.0000] <devsnek>
oh ok

[10:06:07.0000] <shu>
editorially, Job Records were cleaned up for ease of layering

[10:06:38.0000] <devsnek>
yeah i just thought it would be the easiest way to store the three items together

[10:06:42.0000] <devsnek>
i'm open to other things

[10:06:54.0000] <shu>
the invariants might need to be tightened up but i need to think through whether we should say anything more than ensure that stuff can run instead of a particular realm

[10:07:30.0000] <devsnek>
well i think they need to be tighter than "any random realm" because we are creating observable js objects using that realm

[10:07:38.0000] <devsnek>
like the promise resolve functions and stuff

[13:34:39.0000] <jmdyck>
wah, github has internal server error.

[13:35:22.0000] <ljharb>
https://www.githubstatus.com/

[13:37:01.0000] <jmdyck>
guess my upload will have to wait

[13:48:22.0000] <Bakkot>
because github is down?

[13:48:26.0000] <Bakkot>
it's off-and-on for me


2020-04-03
[07:19:38.0000] <bradleymeck>
seriously considering proposing `from "" import {...};` , just to see if it is possible to get through committee

[07:49:25.0000] <bradleymeck>
why not https://github.com/bmeck/proposal-from-import

[07:55:10.0000] <devsnek>
bradleymeck: plsno

[07:56:03.0000] <bradleymeck>
devsnek: i put up proposals to get final words on if we are willing to do things. even if we fail to agree, it means we can at least point to actual conclusions rather than social debate

[07:56:18.0000] <bradleymeck>
i think its fine to add, but certainly kind of :( to add duplicate forms

[07:56:28.0000] <bradleymeck>
import code completion does suck currently

[07:56:33.0000] <devsnek>
I don't understand the asi problem

[07:56:47.0000] <devsnek>
the from in an import declaration can only be part of that import declaration

[07:57:18.0000] <bradleymeck>
`from\n"x"\nimport\nx\n`

[07:57:42.0000] <devsnek>
where's the asi problem in that

[07:58:02.0000] <bradleymeck>
from "x" could be identifier, string

[07:58:23.0000] <devsnek>
we can tell asi not to put semicolons there

[07:58:38.0000] <bradleymeck>
devsnek: we cannot change ASI, thats been talked about quite a bit

[07:58:46.0000] <bradleymeck>
you can change where newlines are allowed

[07:59:44.0000] <devsnek>
we have consensus that disallowing asi in unambiguous productions is a bad thing?

[08:00:03.0000] <bradleymeck>
i don't know what that means

[08:00:09.0000] <devsnek>
like

[08:00:15.0000] <bradleymeck>
but we have strong anti-consensus on changing ASI

[08:00:24.0000] <devsnek>
you can't confuse that block of code for anything except what it is

[08:00:39.0000] <devsnek>
asi wouldn't even produce valid code would it

[08:00:48.0000] <bradleymeck>
but you don't know that until you read the full syntax production?

[08:00:52.0000] <devsnek>
actually isn't that one of the requirements

[08:01:03.0000] <devsnek>
adding the semicolon can't cause a syntax error

[08:02:51.0000] <bradleymeck>
correct, but from;"x"; is valid

[08:03:19.0000] <devsnek>
from isn't reserved?

[08:04:00.0000] <bradleymeck>
nope

[08:04:19.0000] <devsnek>
:(

[08:19:17.0000] <bradleymeck>
we could always add \ as a "DONT ASI ME MY FRIEND" before newlines I believe, which is equally sad

[09:05:36.0000] <jmdyck>
devsnek: "adding a semicolon can't cause a syntax error" is not an ASI requirement

[09:07:45.0000] <devsnek>
asi is a bug

[09:08:55.0000] <Bakkot>
devsnek unfortunately https://www.hyrumslaw.com/

[09:09:13.0000] <devsnek>
lol


2020-04-06
[13:11:14.0000] <devsnek>
directives are evaluated right

[13:11:19.0000] <devsnek>
not that they have any side effects

[13:17:38.0000] <jmdyck>
looks like it.

[13:18:11.0000] <jmdyck>
For them not to be evaluated, ExpressionStatement would need some kind of exception for directives.

[13:19:56.0000] <bradleymeck>
devsnek: yep

[13:20:03.0000] <devsnek>
neat

[13:20:07.0000] <bradleymeck>
only really matters if you get a completion value

[13:20:16.0000] <devsnek>
why are for loops so complex :(

[13:20:42.0000] <devsnek>
there are like nine different variants

[13:21:46.0000] <bradleymeck>
because we didn't have iterators / wanted to match other langs in syntax

[13:22:30.0000] <bradleymeck>
i'd be cool with a very stripped down JS spec which I think is what mark was partially asking about with engine262 dogfood coverage

[13:27:41.0000] <devsnek>
if you run engine262 through babel you can get it pretty low

[13:29:21.0000] <bradleymeck>
/me replaces for loops with Array.from({length}, why)

[13:29:41.0000] <devsnek>
engine262 uses a lot of iteration ngl

[13:31:16.0000] <ljharb>
bradleymeck: +1 to that

[13:31:47.0000] <bradleymeck>
Pls no

[13:32:07.0000] <ljharb>
:-p

[13:32:21.0000] <ljharb>
srsly tho

[13:32:24.0000] <devsnek>
reminds me of something i found in babel-parser today

[13:33:15.0000] <devsnek>
https://gc.gy/53910196.png

[13:33:26.0000] <devsnek>
`undefinedPrivateNames` is a Map

[13:33:45.0000] <ljharb>
lol

[14:06:04.0000] <devsnek>
slowly laying out for loop parsing https://gc.gy/53912157.png

[14:07:00.0000] <Bakkot>
devsnek don't forget `for (let = 0; let < 10; ++let)` is legal

[14:07:21.0000] <ljharb>
yo dawg

[14:07:23.0000] <devsnek>
that's one of the ones at the bottom

[14:07:33.0000] <devsnek>
still uncategorized

[14:09:16.0000] <rkirsling>
C-style for loop is totally in my top three most hated programming constructs

[14:09:38.0000] <devsnek>
i hate how you can't run test262 until you can parse for loops

[14:10:07.0000] <rkirsling>
I mean it's not altogether unreasonable to expect control flow to work XD

[14:10:40.0000] <devsnek>
if your control flow has 12 different productions it might be

[14:12:07.0000] <Bakkot>
you don't need all of them to run test262

[14:12:28.0000] <devsnek>
i suppose i could search through the harness for all the ones that are used

[14:12:46.0000] <devsnek>
but i'll have to write this sooner or later anyway

[14:13:07.0000] <Bakkot>
you don't even need most of the harness files most of the time

[14:13:13.0000] <Bakkot>
assert.js doesn't have any I think

[14:13:19.0000] <Bakkot>
my guess would be the array equality ones

[14:14:22.0000] <shu>
c-style for loops are very fast which is why they are very good

[14:14:50.0000] <devsnek>
üî•

[14:15:19.0000] <ljharb>
goodness should be made fast tho, not fastness implying goodness

[14:15:34.0000] <Bakkot>
prs welcome :P

[14:15:37.0000] <shu>
ya good luck

[14:15:41.0000] <rkirsling>
shu: I'm not objecting to bounded iteration :p

[14:16:15.0000] <ljharb>
lol well v8 did it for iteration methods :-p

[14:19:42.0000] <shu>
wait till you hear my position on raw pointers and how fast they are

[14:20:00.0000] <rkirsling>
do tell

[14:21:32.0000] <shu>
raw pointers are not as fast as they could be because you need to dereference at least once, so they're only mostly good

[14:30:08.0000] <devsnek>
does anyone here really love writing for statement parsers

[14:30:54.0000] <Bakkot>
@devsnek yes: https://github.com/shapesecurity/shift-parser-js/blob/6776a563274992579c01dbb53789b1f032c7deed/src/parser.js#L690-L821

[14:31:08.0000] <devsnek>
i was just reading that

[14:33:40.0000] <devsnek>
Bakkot: are for statements locationless in the shift parser

[14:33:49.0000] <Bakkot>
what does "locationless" mean

[14:34:10.0000] <devsnek>
it doesn't register a location anywhere

[14:34:15.0000] <Bakkot>
ah, that happens in parseStatement

[14:34:21.0000] <Bakkot>
https://github.com/shapesecurity/shift-parser-js/blob/6776a563274992579c01dbb53789b1f032c7deed/src/parser.js#L546-L548

[14:34:42.0000] <devsnek>
recursively?

[14:34:51.0000] <devsnek>
oh i see nvm

[14:34:58.0000] <Bakkot>
it's a recursive descent parser, so... yeah I guess recursively?

[14:35:27.0000] <devsnek>
i forgot that Statement isn't a concrete node type

[14:35:39.0000] <devsnek>
that's a nice simplification

[14:39:57.0000] <Bakkot>
yeah the types in our AST avoid empty wrappers, mostly, with the exception of ExpressionStatement and VariableDeclarationStatement (IIRC) which need wrappers because the thing they're wrapping can appear in other contexts

[14:40:42.0000] <devsnek>
yeah i don't think anyone has a Statement node (hopefully)

[14:41:31.0000] <Bakkot>
jsexplain might


2020-04-07
[20:01:03.0000] <devsnek>
should we remove the last sentence from this? https://tc39.es/ecma262/#sec-ecmascript-language-types-number-type

[20:01:11.0000] <devsnek>
you can observe different NaN values using pure ecmascript

[20:03:14.0000] <Bakkot>
devsnek that would probably require getting into https://github.com/tc39/ecma262/pull/758 again

[20:03:19.0000] <Bakkot>
which no one has expressed much appetite for

[20:03:41.0000] <devsnek>
i'm not suggesting we change anything normativ

[20:03:44.0000] <devsnek>
ely

[20:03:45.0000] <Bakkot>
or, maybe we will get back to it actually

[20:04:09.0000] <devsnek>
but like factually, you can observe nan bit patterns using arraybuffer views

[20:04:16.0000] <devsnek>
that sentence is from like es1 or something

[20:04:32.0000] <Bakkot>
it is implementation-dependent whether or not that is the case

[20:04:35.0000] <Bakkot>
is the problem

[20:05:05.0000] <devsnek>
i'm saying we should remove the thing that says you can't, not that we should add something that says you can

[20:07:53.0000] <shu>
there's a note about observing bit patterns via AB/SAB

[20:08:10.0000] <shu>
there's a bit of a conceit there about "NaN as a Number value" and "NaN as a bit pattern after storing in a buffer"

[20:08:26.0000] <shu>
the last sentence seems to be about the former

[20:10:07.0000] <devsnek>
i can see the path of logic there

[20:10:16.0000] <devsnek>
i don't necessarily agree with it

[20:13:22.0000] <shu>
in general, i think a sentence calling of "this thing is indistinguishable except with these enumerated APIs + extra-language utilities" is valuable and would rather keep it in

[20:13:48.0000] <shu>
though i agree that it might need to be tightened up to actually reflect reality

[20:13:56.0000] <shu>
s/calling of/calling out

[20:16:03.0000] <devsnek>
future proposal: nan literals and nan reflection

[20:20:07.0000] <shu>
BigInt.fromAnyAsUintptr

[20:20:31.0000] <shu>
it's one of the things i've always wanted

[20:21:07.0000] <shu>
now that we have bigint we can even make it future proof for 64+ bit archs

[20:21:54.0000] <rkirsling>
anybody have experience with figuring out what in a given ICU/CLDR release is changing observed behavior?

[20:23:07.0000] <rkirsling>
seems like `Intl.NumberFormat('es').format(1234.567)` changed from `1.234,567` to `1234,567` in ICU 64 (or CLDR 35) but the resolvedOptions are the same either way

[07:25:47.0000] <bradleymeck>
I feel like we should go back to proposing compositeKey

[07:26:04.0000] <bradleymeck>
i've let it stall due to normalization, but thats now dead due to bikeshed


2020-04-08
[16:04:18.0000] <rkirsling>
never thought to try this before, but apparently parseFloat doesn't have a radix arg ü§î

[16:08:34.0000] <rkirsling>
(though I guess 0b1.111 isn't a thing either. but then it's also interesting that parseInt recognizes 0x but not 0b or 0o)


2020-04-09
[17:54:35.0000] <TimothyGu>
rkirsling: (1.875).toString(2) is a thing though

[17:55:17.0000] <rkirsling>
yeah, totally

[17:55:33.0000] <rkirsling>
these seem like nice little things that could be proposed

[08:51:27.0000] <bradleymeck>
reading https://tc39.es/ecma262/#sec-promise.race , it doesn't seem like things should be holding onto all arguments if it resolves , I think this should be explicit that an engine is expected to not tie the lifetimes of the arguments together given potential things like weakrefs observing this

[08:53:05.0000] <bradleymeck>
not sure how to phrase things

[08:53:05.0000] <devsnek>
bradleymeck: nothing is holding onto the arguments even if nothing resolves

[08:53:24.0000] <bradleymeck>
in the spec, sure

[08:53:35.0000] <devsnek>
and therefore implementations aren't required to do so either

[08:54:56.0000] <devsnek>
this spec text is about as close as you can get to `return new Promise((resolve, reject) => { for (const promise of iterable) { promise.then(resolve, reject); } })``

[08:56:15.0000] <bradleymeck>
but they do

[08:57:02.0000] <Bakkot>
bradleymeck there's a _lot_ of places where the spec holds onto things but engines don't need to

[08:57:12.0000] <devsnek>
sounds like engines need to be updated

[08:58:13.0000] <Bakkot>
(WeakMaps are my favorite example; the spec for WeakMaps does not actually delete things from the internal data list when they get GC'd, but since it does not expose the internal list it doesn't matter)

[08:58:17.0000] <devsnek>
bradleymeck: was promise.race in V8 having this problem? I can take a look at it later today if so

[08:59:07.0000] <bradleymeck>
Bakkot: yep

[08:59:50.0000] <devsnek>
Bakkot: the spec for weakrefs adds explicit cleanup steps

[09:00:01.0000] <devsnek>
to weak collections

[09:00:06.0000] <Bakkot>
aww

[09:00:12.0000] <devsnek>
lol

[09:17:21.0000] <shu>
Bakkot: even the current spec says that

[09:17:29.0000] <shu>
Bakkot: it just does it in prose

[09:17:51.0000] <shu>
"If an object that is being used as the key of a WeakMap key/value pair is only reachable by following a chain of references that start within that WeakMap, then that key/value pair is inaccessible and is automatically removed from the WeakMap. WeakMap implementations must detect and remove such key/value pairs and any associated resources."

[09:18:01.0000] <shu>
whatever "remove such key/value pairs and any associated resources" means

[09:18:20.0000] <Bakkot>
oh, fun

[09:18:39.0000] <Bakkot>
but it doesn't... actually remove it

[09:19:00.0000] <Bakkot>
"is automatically removed from the WeakMap" is a statement, not a normative requirement, and it appears to be false

[09:19:08.0000] <shu>
what does actually remove it mean, like call delete?

[09:19:26.0000] <shu>
the reachability part is also wrong given optimizations but ehh

[09:19:35.0000] <Bakkot>
remove or replace its entry in map.[[WeakMapData]]

[09:19:56.0000] <shu>
yeah there're no operational steps to actually remove it

[09:20:07.0000] <shu>
however you interpret "must detect and remove", i guess

[09:20:12.0000] <devsnek>
weakrefs adds the actual step of setting the entry to ~empty~

[09:20:34.0000] <devsnek>
I think

[09:21:51.0000] <bradleymeck>
devsnek: i can't minimally repro asking @jasnell who was pointing this out since he works with diagnostic tooling he should be better prepared to show an example

[09:22:08.0000] <bradleymeck>
repro. *

[09:43:13.0000] <devsnek>
bradleymeck: looks like it shouldn't have a problem, reading the source

[09:43:24.0000] <devsnek>
maybe the rewrite to torque fixed it but node doesn't have that yet?

[13:35:33.0000] <Bakkot>
devsnek: re https://github.com/engine262/engine262/blob/e4c6798e1f3f89505f4c23eecc9e5d647af6b00e/src/parse.mjs#L84-L192, it looks like you've made the chaining left-associative, which is weird

[13:35:37.0000] <Bakkot>
specifically, the third example

[13:35:49.0000] <Bakkot>
I would expect the outermost node to correspond to the first `?.`, not the second

[13:35:59.0000] <devsnek>
Bakkot: i tried to make it match the spec

[13:36:11.0000] <devsnek>
is it not doing that?

[13:36:21.0000] <Bakkot>
hm, let me look

[13:36:26.0000] <Bakkot>
I would guess no though

[13:39:07.0000] <Bakkot>
(actually I guess my expectation is not as strong as I thought; either representation works. but let me see what the spec's parse tree is.)

[13:41:41.0000] <Bakkot>
devsnek ah, you're right, you do match the spec

[13:41:54.0000] <devsnek>
glad to hear it üòÖ

[13:42:58.0000] <Bakkot>
this is not how I'd've spec'd it, intuitively, but maybe there is a reason the way I'd intuitively do it doesn't work

[13:43:16.0000] <Bakkot>
it shouldn't make a difference semantically I think

[13:43:45.0000] <devsnek>
works nicely for ast evaluation

[13:43:51.0000] <devsnek>
which is basically what the spec does

[13:44:26.0000] <Bakkot>
the way I'd've done it would basically have made `?.` have the other associativity, which also works just the same for AST evaluation

[13:44:32.0000] <Bakkot>
and also matches my mental model of how to evaluate

[13:45:08.0000] <Bakkot>
basically, the way `a?.b?.c` evaluates is, you evaluate `a?.b` and then if that was non-null you evaluate `.c`

[13:45:38.0000] <Bakkot>
and the way I'd've done it, because it matches the way that I think about it, is that you evaluate `a` and then if that was non-null you evaluate `.b?.c`

[13:45:41.0000] <shu>
wait, is that not how it evaluates today?

[13:45:55.0000] <Bakkot>
shu which of the two things that I wrote?

[13:46:02.0000] <Bakkot>
the first thing I wrote is the way evaluation happens today

[13:46:03.0000] <shu>
the second one

[13:46:11.0000] <Bakkot>
nope, it's the first one

[13:46:16.0000] <Bakkot>
they are semantically equivalent though

[13:46:20.0000] <shu>
but... they commnute

[13:46:22.0000] <shu>
commute

[13:46:22.0000] <shu>
ok

[13:46:35.0000] <devsnek>
feel free to change it

[13:46:41.0000] <shu>
well, unless there's an expression stepper, i guess

[13:46:57.0000] <devsnek>
what is an expression stepper

[13:47:10.0000] <shu>
something that single-steps through expression evaluation

[13:47:14.0000] <devsnek>
oh

[13:47:29.0000] <Bakkot>
my guess is that the grammar for my preferred parse is harder to write

[13:47:33.0000] <Bakkot>
maybe I will think about it a little

[13:47:39.0000] <devsnek>
i have a stepper for engine262

[13:47:42.0000] <shu>
just introduce another cover grammar, ez

[13:48:32.0000] <Bakkot>
:|

[13:49:04.0000] <shu>
MyEquivalentButEasierToReadOptionalChainCover

[13:49:10.0000] <rkirsling>
yeah the spec there is NOT a impl recommendation

[13:49:12.0000] <rkirsling>
heh

[13:49:45.0000] <devsnek>
hm my stepper died

[13:49:56.0000] <devsnek>
https://gc.gy/54170393.png

[13:50:16.0000] <Bakkot>
sounds like it's time for a new test!

[13:50:34.0000] <devsnek>
implying i have tests for this thing

[13:51:00.0000] <Bakkot>
it can be time for a new test even if you have zero tests

[13:51:10.0000] <Bakkot>
in fact that is the most frequent reason for it to be time for a new test

[13:51:42.0000] <shu>
well, if there's no precedent for tests, why start one now

[13:51:48.0000] <shu>
why rock the boat

[13:52:41.0000] <devsnek>
i wonder if i could capture the result of evaluation calls and print them with the stepper

[13:54:27.0000] <devsnek>
shu: does v8 not want js apis to have c++ apis anymore or is it just an area that needs work

[13:54:44.0000] <shu>
devsnek: what's the context?

[13:54:50.0000] <devsnek>
like how there's no v8::WeakMap

[13:56:02.0000] <shu>
there's no central guidance like that afaik, but there's also no effort to expose new JS features to V8 API without a need, such as for integration with the embedder

[13:56:16.0000] <shu>
in general, the smaller the API surface the better

[13:56:26.0000] <devsnek>
we do have one place in node where i would like to use v8::WeakMap::New but its not a huge deal

[13:56:31.0000] <devsnek>
makes sense

[13:56:59.0000] <shu>
namely, you don't want to look up the WeakMap property, you want to make a weakmap directly

[13:57:40.0000] <devsnek>
yeah there's just one area where we have to create the weakmap by traversing through the global instead of calling something directly

[14:01:32.0000] <shu>
i think exposing WeakMap is probably reasonable

[14:02:43.0000] <shu>
there isn't too much "product direction" for the API right now. may be useful to sit down with the team to decide what JS objects are reasonable to reflect in API

[14:05:00.0000] <bradleymeck>
v8::Context::GetIntrinsic XD, reduce all the APIs to that! (pls no)

[14:07:39.0000] <devsnek>
bradleymeck: if it was a const fn that might actually be okay

[14:45:56.0000] <rkirsling>
hey jridgewell I think this test is wrong

[14:45:57.0000] <rkirsling>
https://github.com/tc39/test262/blob/master/test/language/expressions/logical-assignment/lgcl-and-assignment-operator-non-simple-lhs.js

[14:46:10.0000] <rkirsling>
that's not an early error for +=

[14:46:42.0000] <devsnek>
call expressions are not valid assignment targets

[14:46:59.0000] <devsnek>
idk why the test explicitly defines a function it isn't needed

[14:47:23.0000] <drousso_>
rkirsling it was actually rwaldron who wrote it :)

[14:47:27.0000] <devsnek>
wait are call expressions valid assignment targets

[14:47:39.0000] <devsnek>
is this that ie backwards compat thing

[14:47:47.0000] <rkirsling>
they're valid at parse time, yes

[14:48:10.0000] <Bakkot>
rkirsling it's an early error

[14:48:20.0000] <Bakkot>
but browsers all agree it should not be, for back-compat reasons

[14:48:26.0000] <rkirsling>
ohh

[14:48:30.0000] <Bakkot>
it is on my todo list to fix this discrepency

[14:48:33.0000] <rkirsling>
funky

[14:48:41.0000] <devsnek>
https://gc.gy/54173912.png

[14:48:46.0000] <rkirsling>
fix as in "make the spec match reality", I assume?

[14:48:51.0000] <Bakkot>
rkirsling yup

[14:48:54.0000] <rkirsling>
cool

[14:49:03.0000] <Bakkot>
devsnek try `false && (a() = b)`

[14:49:10.0000] <rkirsling>
I guess the test is valid then, we'll just intentionally fail it for now lol

[14:49:17.0000] <drousso_>
lol

[14:49:27.0000] <devsnek>
Bakkot: its the ones that throw reference errors

[14:49:47.0000] <Bakkot>
ah, that's something which changed kind of recently

[14:49:54.0000] <Bakkot>
was changed by rkirsling actually, IIRC

[14:49:57.0000] <rkirsling>
also yeah now that we're having this discussion I do remember the IE compatibility thing

[14:50:28.0000] <rkirsling>
Bakkot: yup!

[14:50:43.0000] <Bakkot>
https://github.com/tc39/ecma262/pull/1527

[14:51:44.0000] <rkirsling>
is there an issue open for the web reality concern?

[14:52:01.0000] <Bakkot>
looking...

[14:52:06.0000] <devsnek>
are there any counters for assigning to a call expression

[14:52:38.0000] <Bakkot>
devsnek yes I added some to V8 ages ago

[14:52:45.0000] <Bakkot>
probably they are still there

[14:53:07.0000] <rkirsling>
yeah I'm actually surprised at myself for forgetting this whole discussion

[14:53:19.0000] <devsnek>
Bakkot: hm i don't see it

[14:53:27.0000] <Bakkot>
`lhsiscallinsloppy` or something

[14:53:27.0000] <devsnek>
unless it doesn't show up on https://www.chromestatus.com/metrics/feature/popularity

[14:53:34.0000] <devsnek>
oh nvm

[14:53:40.0000] <devsnek>
it just doesn't contain the word "assign"

[14:53:47.0000] <devsnek>
0.06336%

[14:54:09.0000] <devsnek>
https://www.chromestatus.com/metrics/feature/timeline/popularity/1764

[14:54:45.0000] <ljharb>
that seems high

[14:55:07.0000] <ljharb>
but 904 sites listed seems evangelizable, if someone wants to do the work :-)

[14:55:28.0000] <devsnek>
apparently people really like assigning to call expressions

[14:56:03.0000] <ljharb>
my guess is that 99% of the occurrences are a single library

[14:56:06.0000] <ljharb>
possibly 100%

[14:56:20.0000] <Bakkot>
ugh, I could swear there was an issue for this, but I can't find it

[14:56:55.0000] <ljharb>
for example, altho i can't craft a counter to prove it, i'm convinced 100% of the "non-regex objects with Symbol.match" occurrences are a core-js feature detection

[14:57:20.0000] <rkirsling>
oh here

[14:57:21.0000] <rkirsling>
https://github.com/tc39/ecma262/issues/257

[14:57:38.0000] <rkirsling>
the title is wrong

[14:57:42.0000] <rkirsling>
but scroll to the bottom

[14:59:00.0000] <Bakkot>
ah fascinating

[15:01:42.0000] <Bakkot>
I wish I had permissions to read https://bugs.chromium.org/p/chromium/issues/detail?id=358346

[15:01:59.0000] <Bakkot>
I can't see why it would not be public

[15:02:12.0000] <Bakkot>
anyone on chrome able to fix that ^? shu?

[15:02:26.0000] <Bakkot>
(this is the bug for https://codereview.chromium.org/217823003 )

[15:16:42.0000] <shu>
Bakkot: that CL must be linking to the wrong bug

[15:17:30.0000] <shu>
Bakkot: that issue has nothing to do with JS

[15:17:47.0000] <Bakkot>
shu dang :(

[15:18:34.0000] <shu>
i tried some one-off combinations of the id and didn't land on anything useful either

[15:19:43.0000] <shu>
Bakkot: ah i had to read fairly down the comments to see, but that is the right bug

[15:19:46.0000] <shu>
i don't think i can open it however...

[15:20:02.0000] <Bakkot>
aw that's even worse

[15:20:30.0000] <Bakkot>
I need to make a note for myself that if I ever go work for google again I gotta go read that issue

[15:21:13.0000] <shu>
i'm pretty sure i can tell you the interesting bit though

[15:21:26.0000] <shu>
at the time, there was a site that broke because it had this snippet:

[15:21:27.0000] <shu>
  x.f() += y

[15:22:14.0000] <devsnek>
:(

[15:22:19.0000] <ljharb>
any tips on who we have to email to fix that snippet?

[15:22:49.0000] <devsnek>
sundar‚äôgc

[15:22:59.0000] <shu>
that i'm unsure so i'd need to check up my chain about this kind of disclosure

[15:23:03.0000] <shu>
also it is from 2014

[15:23:17.0000] <shu>
i didn't read backlog, what's the context?

[15:24:02.0000] <Bakkot>
context is that `f() = y` continues to be a runtime error per browsers and a parsetime error per spec, which is bad

[15:24:19.0000] <shu>
ah, okay, welp

[15:24:22.0000] <Bakkot>
was doing archeology to see if I could find a concrete instance of why browsers need this

[15:25:04.0000] <shu>
it's unfortunate but i'd need to be better convinced to try this change again

[15:26:02.0000] <Bakkot>
I think at this point we are unlikely to get browsers to change; my intent is to make the spec match browsers

[15:26:16.0000] <shu>
ah

[15:26:25.0000] <Bakkot>
or rather, specifically, to make `f() = y` a runtime error in sloppy mode and an early error in strict mode, which matches firefox and JSC

[15:26:26.0000] <shu>
sgtm?

[15:26:36.0000] <shu>
well, in this instance it was compound assignment

[15:26:45.0000] <Bakkot>
yeah, compound or simple I guess

[15:26:48.0000] <shu>
is = standin there for all assignment operators?

[15:26:48.0000] <shu>
ok

[15:26:58.0000] <Bakkot>
there's use counters: https://github.com/tc39/ecma262/issues/257#issuecomment-502878708

[15:33:05.0000] <shu>
hm those are pretty low

[15:35:57.0000] <shu>
strict mode seems fairly not risky

[15:46:42.0000] <shu>
Bakkot: i opened the issue

[15:48:05.0000] <Bakkot>
shu: sweet, thanks!

[15:50:45.0000] <shu>
(it's also a good showcase for the amount of work backward incompats cause, and why browsers often don't have any appetite for trying anything)


2020-04-10
[18:42:51.0000] <jmdyck>
Bakkot: What's the next step after #1914?

[19:11:21.0000] <devsnek>
shu: what is the equiv of #node-dev for v8

[19:11:27.0000] <devsnek>
v8-dev mailing list?

[19:28:31.0000] <shu>
devsnek: yeah

[19:33:07.0000] <devsnek>
would be nice if V8 had some sync chat setup üò¢

[19:38:27.0000] <Bakkot>
jmdyck: next step is to make abstract operations which do not need to return completions actually not return completions, and note which type each abstract operation returns

[19:39:04.0000] <Bakkot>
and then make sure that consumers of abstract operations treat their return values as completions or not as completions, as appropriate

[19:39:43.0000] <Bakkot>
also to add more type annotations to the arguments for abstract operations; currently there's some but there could be more - possibly just all of them

[19:40:16.0000] <Bakkot>
but those two things are sort of orthogonal; the motivation for 1914 was so that I could have a consistent place to note the return types, not so much the argument types (that is just a bonus)

[19:41:59.0000] <jmdyck>
But if you have two PRs, they're going to collide a lot, unless one goes first and gets merged before starting the second, no?

[19:42:16.0000] <Bakkot>
yup, that's a true thing

[19:44:14.0000] <jmdyck>
So the return value one goes first?

[19:46:00.0000] <Bakkot>
The return value one is a higher priority for me, so if I'm doing the work, yes, that's the one I'm planning on doing first. If you (or anyone else) felt inclined to do either of them I'd happily review in whatever order and rebase my work on top of that.

[19:46:49.0000] <jmdyck>
ok, thx

[19:49:18.0000] <Bakkot>
I expect it to be a minimum of a week before I have time to start doing this myself, incidentally, though I might end up bored some weekend and knock it out

[20:42:41.0000] <jmdyck>
Bakkot: I notice that 1914 didn't normalize the preambles of BigInt::* ops

[20:42:50.0000] <jmdyck>
why's that?

[20:43:50.0000] <Bakkot>
the namespaced ones are kind of weird in general

[20:44:25.0000] <Bakkot>
(it also didn't do the Number ones)

[20:50:40.0000] <Bakkot>
Looking through this again, I guess the wording I ended up with would work fine for these; maybe it is worth adding them too.

[20:51:36.0000] <Bakkot>
it ends up being significantly less informative since they almost all take and return the same types, but whatever.

[20:54:42.0000] <jmdyck>
You could argue that https://tc39.es/ecma262/#table-numeric-type-ops (and the preceding paragraph) obviate the preambles.

[20:55:20.0000] <jmdyck>
(mostly)

[20:57:49.0000] <Bakkot>
Yeah, though in that case we should remove e.g. the "The abstract operation BigInt::signedRightShift with arguments x and y of type BigInt performs the following steps:" bits

[20:58:48.0000] <jmdyck>
You'd be in favor of such removals?

[20:59:00.0000] <Bakkot>
well, either that or putting them all in after all

[20:59:15.0000] <jmdyck>
ok

[20:59:28.0000] <Bakkot>
I am leaning towards putting them all in given how #1914 ended up - I originally removed the totally redundant ones but we ended up putting those back, and adding new totally redundant ones where they were previously missing

[20:59:34.0000] <Bakkot>
might as well go all the way, I guess.

[21:01:43.0000] <ljharb>
sgtm

[10:32:26.0000] <chicoxyzzy>
devsnek: what are the differences between https://github.com/devsnek/esvu and jsvu?

[10:36:33.0000] <devsnek>
chicoxyzzy: jsvu does native binaries and esvu does anything with a consistent download location

[10:37:11.0000] <rkirsling>
JSC is still behaving okay via esvu, right?

[10:37:27.0000] <chicoxyzzy>
devsnek: thanks for the explanation!

[10:37:33.0000] <rkirsling>
i.e. test262 infra is doing something weird on top of it?

[10:37:59.0000] <devsnek>
I haven't explicitly checked but it's the same binary either way

[10:38:14.0000] <rkirsling>
yeah

[10:59:29.0000] <jridgewell>
https://www.irccloud.com/pastebin/vY8trIjf/eshost-assign-to-call

[10:59:32.0000] <jridgewell>
Weird

[11:00:51.0000] <devsnek>
the spec says its a syntax error

[11:00:56.0000] <devsnek>
web browsers don't for compat reasons

[11:39:31.0000] <devsnek>
wow graaljs is actually really fast

[11:53:43.0000] <Bakkot>
yeah it's rad

[11:53:52.0000] <Bakkot>
I talk to them at the llvm dev meeting whenever I go and remember to do that

[11:54:59.0000] <Bakkot>
I suspect it has a lot of cases where it would have terrible performance for real web code, just on the basis that all engines which have not been optimized for a large corpus of web code have this problem


2020-04-11
[17:32:19.0000] <devsnek>
could we merge function expression and named evaluation together such that

[17:32:47.0000] <devsnek>
if you pass name that is a string it adds the extra scope and if you pass name undefined it doesn't add the extra scope and sets the name to ''

[17:32:54.0000] <devsnek>
lots of duplication atm

[17:33:15.0000] <devsnek>
and named evaluation is kind of doing the opposite of what its called

[17:45:43.0000] <Bakkot>
I think I prefer the duplication over combining those two things

[11:41:01.0000] <devsnek>
VariableDeclarationList and BindingList are identical grammars right?

[11:46:03.0000] <Bakkot>
devsnek: at a glance, yes

[11:46:21.0000] <Bakkot>
though it could still make sense for both to exist if they have different syntax-directed operations

[11:46:57.0000] <devsnek>
yeah i realized i don't want to combine them to keep the difference between VariableDeclaration and LexicalBinding

[14:21:11.0000] <devsnek>
ok i got sidetracked on making errors look nice but... https://gc.gy/54345050.png

[14:29:09.0000] <Bakkot>
devsnek: sweet

[14:29:24.0000] <Bakkot>
good errors are great, especially for an expository tool like engine262

[14:30:28.0000] <devsnek>
indeed

[14:30:35.0000] <devsnek>
still need to finish the actual parsing though https://gc.gy/54345625.png


2020-04-12
[07:55:08.0000] <devsnek>
this is definitely not confusing https://gc.gy/54408295.png

[09:33:45.0000] <gibson042>
O_O

[09:42:52.0000] <gibson042>
I don't see an easy refactoring, though

[10:03:57.0000] <devsnek>
gibson042: we should letter duplicate productions

[10:04:05.0000] <devsnek>
Statement_a and Statement_b

[10:04:25.0000] <devsnek>
I was thinking of diving into ecmarkup at some point to do that

[10:42:09.0000] <jmdyck>
like https://github.com/tc39/ecma262/issues/1768 ?

[10:50:36.0000] <devsnek>
yep

[10:51:29.0000] <devsnek>
anyone know a way i can make it so whenever someone pushes to ecma262 it opens an issue in another repo

[11:55:08.0000] <devsnek>
engine262 has its own regexp parser and engine now üéâ

[14:40:46.0000] <devsnek>
does this bother anyone else "If the code matching the syntactic production that is being evaluated is contained in strict mode code, let strict be true; else let strict be false."

[14:40:50.0000] <devsnek>
in ResolveBinding

[14:42:55.0000] <jmdyck>
Yeah, "the syntactic production that is being evaluated" isn't well-defined.

[14:44:03.0000] <jmdyck>
There presumably could be multiple (nested) nodes that are in the process of being evaluated.

[14:44:14.0000] <jmdyck>
Also, you don't evaluate a production.

[14:45:14.0000] <jmdyck>
Also, the phrasing of "is contained in strict mode code" is odd. Why not just say "is strict mode code"?

[14:46:14.0000] <jmdyck>
(I've got some WIP somewhere about the last, I think.)

[14:49:49.0000] <devsnek>
ResolveBinding needs to take a strict parameter


2020-04-13
[19:11:39.0000] <jackworks>
alert() = 1 // hey that's illegal

[19:12:10.0000] <jackworks>
Chrome will open an alert window then ReferenceError

[20:00:11.0000] <Bakkot>
yeah, they compile it to something like `alert()[function(){throw new ReferenceError}() = 1`

[20:00:16.0000] <Bakkot>
like, in the parser

[20:00:25.0000] <Bakkot>
I do not expect anyone is relying on the function actually getting invoked

[20:00:29.0000] <Bakkot>
but who knows.

[13:28:44.0000] <devsnek>
is the best way to handle IterationStatement just to make a bunch of helper ast node types like "WhileStatement"

[13:43:43.0000] <Bakkot>
devsnek: as in, when designing your AST?

[13:43:50.0000] <Bakkot>
that is the usual thing to do, yes

[13:43:50.0000] <devsnek>
yeah

[14:25:27.0000] <devsnek>
> TopLevelVarDeclaredNames

[14:25:45.0000] <bradleymeck>
ah, the evils of delete

[14:25:51.0000] <devsnek>
> If Statement is Statement : LabelledStatement, return TopLevelVarDeclaredNames of Statement.

[14:26:00.0000] <devsnek>
isn't this circular

[14:26:10.0000] <devsnek>
or

[14:26:12.0000] <devsnek>
idk

[14:26:21.0000] <devsnek>
this is a very confusing part of the spec

[14:27:33.0000] <bradleymeck>
that looks like it shouldn't happen? *off to reread*

[14:28:29.0000] <bradleymeck>
it makes sense, but it doesn't specify that it needs to use the labelledstatement form of TopLevelVarDeclaredNames

[14:29:22.0000] <bradleymeck>
bug it looks like

[14:31:46.0000] <jmdyck>
It doesn't have to specify that it needs to use the labelledstatement form of TopLevelVarDeclaredNames: that'll happen automatically via the chain rule

[14:34:07.0000] <Bakkot>
I wonder how many new rules we would have to add to get rid of the chain rule

[14:34:12.0000] <Bakkot>
probably enough to make it not worth it

[14:34:25.0000] <bradleymeck>
jmdyck: but the chain rule isn't being applied when you get the the StatementItem: Statement form, i don't see how it would propagate here, the definition of the chain rule doesn't seem to state this would work if it is in an algorithm?

[14:34:50.0000] <devsnek>
there some issue in my implementation of the var scoped declarations/names stuff :(

[14:36:05.0000] <devsnek>
if anyone here feels confidant in their understanding of how those work my new implementations are in this folder https://github.com/engine262/engine262/tree/parser/src/static-semantics

[14:36:44.0000] <bradleymeck>
i just think this needs to be clarified somewhere (idc where) that it uses the LabelledStatement form. Right now it does appear to be cyclic even with me rereading https://tc39.es/ecma262/#sec-algorithm-conventions-syntax-directed-operations

[14:37:18.0000] <Bakkot>
devsnek: your implementation doesn't handle labeled statements?

[14:37:24.0000] <jmdyck>
bradleymeck: the chain rule doesn't need to 'propagate here'.  It 'starts' when you need to execute "TopLevelVarDeclaredNames of |Statement|"

[14:37:28.0000] <devsnek>
i haven't got that far yet

[14:38:15.0000] <devsnek>
rn i'm stuck on var declarations not being found in VarScopedDeclarations

[14:39:37.0000] <bradleymeck>
jmdyck: i see

[14:39:50.0000] <jmdyck>
... there isn't an explicit TopLevelVarDeclaredNames rules for `Statement : LabelledStatement`, but the latter is a chain production, so the chain rule kicks in

[14:40:21.0000] <bradleymeck>
jmdyck: confusing, but i understand


2020-04-14
[19:46:22.0000] <devsnek>
CreateDynamicFunction says stuff like

[19:46:40.0000] <devsnek>
"if kind is generator, let parameterGoal be FormalParameters[+Yield, ~Await]"

[19:47:11.0000] <devsnek>
but then later down it says "throw a syntax error if kind is generator and FormalParameters contains YieldExpression"

[19:47:25.0000] <devsnek>
why not just set parameterGoal to [~Yield, ~Await]

[19:53:25.0000] <devsnek>
i wonder if this entire thing could be shortened by cutting out all this manual parsing and just specifying it to evaluate sourceString that is defined way at the bottom

[20:15:35.0000] <jmdyck>
using [~Yield] would have allowed 'yield' as an identifier, which would be confusing.

[20:16:40.0000] <devsnek>
interesting

[20:16:56.0000] <devsnek>
ok on a separate topic

[20:17:48.0000] <devsnek>
is it fair to imagine that UTF16EncodeString and UTF16DecodeString convert between some abstract host string form and js string values

[20:21:58.0000] <jmdyck>
I don't think so.

[20:22:42.0000] <devsnek>
hmm

[20:23:07.0000] <devsnek>
they generally seem to be used when passing strings back and forth between host parsing and js

[20:23:12.0000] <jmdyck>
The spec assumes that the host understands ES String values.

[20:23:49.0000] <devsnek>
well yeah but like

[20:23:57.0000] <devsnek>
"let x be the result of ! UTF16Decode(string)"

[20:23:59.0000] <devsnek>
er

[20:24:00.0000] <jmdyck>
if the host has an abstract string form, conversion between that and ES String values is completely hidden from spec-land.

[20:24:11.0000] <devsnek>
"let x be the result of parsing ! UTF16Decode(string)"

[20:25:11.0000] <jmdyck>
Yup, those ao's are mostly used for converting between *source text* and ES Strings.

[22:55:03.0000] <Bakkot>
devsnek: UTF16Encode UTF16DecodeString should be thought of as converting between _Unicode_ strings (more precisely, sequences of codepoints) and ES strings

[22:56:07.0000] <devsnek>
i'm just trying to figure out if i really need to store source text on functions as an array of code point records

[22:56:09.0000] <Bakkot>
"Unicode strings" and "host strings" are not typically the same, especially given how shoddy unicode support is in most languages

[22:56:24.0000] <Bakkot>
ah: no

[22:56:35.0000] <devsnek>
i mean i know technically i don't have to

[22:56:41.0000] <devsnek>
but the spec seems to want me to

[22:57:16.0000] <Bakkot>
that's just because it's a nice formalism, not implementation advice

[22:57:49.0000] <Bakkot>
here, this is why: https://github.com/tc39/ecma262/pull/1547#issuecomment-581005549

[22:58:57.0000] <devsnek>
i see

[07:43:52.0000] <srl295>
devsnek: it should still be a string.. Bakkot  : not sure what you mean about host strings, are you talking about non-unicode host encodings?

[07:44:48.0000] <devsnek>
srl295: it's a List

[07:48:02.0000] <srl295>
devsnek: even in implementation?

[07:48:23.0000] <devsnek>
not in implementation

[07:48:27.0000] <devsnek>
hopefully

[07:48:31.0000] <devsnek>
but in spec

[08:00:15.0000] <srl295>
^ OK, thx

[08:58:36.0000] <gibson042>
[[SourceText]] is a sequence of code points to match lexical source text, but String values can represent those per https://tc39.es/ecma262/#sec-ecmascript-language-types-string-type . There's an edge case of "leading surrogate code _point_ followed by trailing surrogate code _point_" (which would be interpreted as a surrogate pair for a single code unit), but I don't see a way to ever encounter that because it cannot be represented i

[09:00:16.0000] <gibson042>
s/surrogate pair for a single code unit/surrogate pair for a single code point/

[09:24:41.0000] <devsnek>
it would be kinda cool if `{ ...x, y }` binding created x as a copy of whatever was being matched

[09:25:22.0000] <devsnek>
sort of the reverse of a `{ ...x, y }` expression

[09:29:49.0000] <Bakkot>
devsnek: ... doesn't it?

[09:29:52.0000] <devsnek>
no

[09:29:55.0000] <devsnek>
it's not valid syntax

[09:30:07.0000] <devsnek>
rest binding element is only valid at the end

[09:30:16.0000] <Bakkot>
ah, sorry, yes

[09:30:49.0000] <devsnek>
at some point maybe i'll go check if it was left as future work or explicitly not wanted

[09:32:31.0000] <Bakkot>
there have been proposals that `[ ...x, y] = [1, 2, 3]` give you `x = [1, 2]; y = [3]`

[09:32:42.0000] <Bakkot>
which seems like a different thing than what you're proposing

[09:33:17.0000] <devsnek>
i wouldn't want to get into array bindings

[09:34:09.0000] <devsnek>
array bindings are tricky because the order of the bindings has to match up with meaningful behaviour about the order of the elements

[09:34:16.0000] <devsnek>
don't have to worry about that with object bindings

[09:52:47.0000] <devsnek>
i think the spec is missing the definition for the evaluation of AsyncGeneratorDeclaration

[09:56:04.0000] <devsnek>
oh nvm its grouped in as HoistableDeclaration

[09:57:01.0000] <annevk>
ljharb: FWIW, https://github.com/tc39/ecma262/issues/1524#issuecomment-613554699 the plan is not particularly detailed and shu suggested it did not include changing all existing occurrences of host in a #whatwg discussion

[09:59:05.0000] <ljharb>
annevk: ah k, what we'd discussed was changing all prose instances of host to implementation; i don't recall for sure, but we probably also discussed not changing hook names with "Host", to avoid churn

[10:01:33.0000] <annevk>
ljharb: again, not what shu told me in https://freenode.logbot.info/whatwg/20200409#c3606032

[10:02:48.0000] <shu>
the context for host->implementation per the last plan was particularly for the phrase "host-defined" vs "implementation-defined" and "implementation-dependent"

[10:02:54.0000] <shu>
not the bare word "host" vs "implementation"

[10:02:56.0000] <ljharb>
ah k

[10:02:59.0000] <ljharb>
ty for clarifying

[10:03:06.0000] <shu>
but there was enough unhappiness around that plan that i plan to bring it up again in the editor call anyway

[10:04:53.0000] <Bakkot>
annevk: re https://github.com/tc39/ecma262/issues/1524#issuecomment-613269942: would you also be OK with providing overridable abstract operations only for those things for which we are aware of some host which wants to specify the behavior?

[10:05:25.0000] <Bakkot>
because specifying a bunch of host ops which no one has any interest in using is a fair bit of work for no obvious benefit

[10:05:33.0000] <annevk>
Bakkot: at that point your are making a distinction some people think there is not

[10:05:40.0000] <annevk>
Bakkot: and I'd argue you're being inconsistent

[10:06:05.0000] <annevk>
Bakkot: if you don't want to acknowledge hosts and live in your vacuum, then don't acknowledge them (while still making things)

[10:06:08.0000] <annevk>
work*

[10:07:05.0000] <annevk>
if you want to be pragmatic, embrace all the text that acknowledges hosts

[10:07:10.0000] <Bakkot>
I agree it is mildly inconsistent, but the inconsistency does not particularly bother me. we're defining an API; only putting the things for which there is some consumer into the API is fine.

[10:07:58.0000] <annevk>
it bothers me because people keep saying a Host hook is equivalent to NaN stuff

[10:08:01.0000] <srl295>
Bakkot: for my understanding, what's the 'host' situation you are referring to?

[10:08:29.0000] <Bakkot>
srl295 context is mostly in https://github.com/tc39/ecma262/issues/1524

[10:08:53.0000] <Bakkot>
annevk: I don't understand what you mean by that; say more?

[10:10:10.0000] <annevk>
Bakkot: I think if you want to say that implementation and host are the same, you ought to actually remove the distinction and not only offer it to those who can read between the lines

[10:11:47.0000] <srl295>
Bakkot: Right, but you referred specifically to Unicode support on the host, which seems to be AWB's footnote 1, is that what you mean?

[10:12:03.0000] <Bakkot>
srl295 the Unicode conversation was totally unrelated to this conversation

[10:13:45.0000] <Bakkot>
annevk how is "change everything to say implementation defined, keep hooks in place for places where they are useful" not that?

[10:13:58.0000] <Bakkot>
annevk I guess mostly I fundamentally do not udnerstand what distinction you think there is

[10:14:08.0000] <srl295>
Bakkot: OK. carry on then‚Ä¶¬†

[10:14:31.0000] <Bakkot>
if the distinction is "suggest to implementors that there's another place to look for restrictions on something ECMA-262 does not specify", it seems like that proposal accomplishes it perfectly

[10:14:48.0000] <Bakkot>
if the distinction in your mind is something other than that, then I don't know what it is

[10:17:07.0000] <annevk>
What I'm saying is that implementation-defined with hook = host hook and implementation-defined without hook is implementation-defined, except now you made it more opaque.

[10:17:55.0000] <annevk>
So at that I'd rather have everything be a hook and let the host^Wimplementation decide who defines what

[10:17:58.0000] <Bakkot>
made it more opaque than... what? that's the current state of the specification.

[10:18:13.0000] <annevk>
Bakkot: the current specification talks about hosts a bunch

[10:20:07.0000] <Bakkot>
annevk in host hooks, yes. outside of host hooks, not really?

[10:20:42.0000] <Bakkot>
not in anything normative, that I can see, except for properties of the global object and "the host environment's current locale"

[10:29:11.0000] <annevk>
Bakkot: I'm including the non-normative material, that's somewhat relevant for this discussion I think

[10:30:52.0000] <Bakkot>
of the 166 usages of "host" in the spec, the only ones which are not describing host hooks, locale, or the global object (or values otherwise made available) are:

[10:30:56.0000] <Bakkot>
1. the [[HostDefined]] slot on realm, script, and module records

[10:31:01.0000] <Bakkot>
2. the Note about enumerate object properties not requiring a specific algorithm (which should definitely be changed to "host")

[10:31:08.0000] <Bakkot>
3. the `hostDefined` argument to ParseScript (which populates [[HostDefined]], and which is basically a host hook just in the other direction)

[10:31:54.0000] <Bakkot>
4. the prose in the example of cyclic module record graphs, which is about hosts calling ES abstract methods - again basically a host hook in the other direction

[10:32:33.0000] <Bakkot>
5. locale

[10:32:50.0000] <annevk>
"ECMAScript is an object-oriented programming language for performing computations and manipulating computational objects within a host environment."

[10:33:08.0000] <Bakkot>
6. "host-defined exceptions that can occur anywhere such as out-of-memory", which could be changed to "implementation"

[10:33:34.0000] <Bakkot>
7. host-synchronizes-with, which is basically a host hook

[10:33:54.0000] <Bakkot>
8. annex b's "when the ECMAScript host is a web browser"

[10:33:55.0000] <Bakkot>
that's the list.

[10:34:41.0000] <annevk>
It's a list for sure :-)

[10:34:44.0000] <Bakkot>
annevk that paragraph is very clearly (to me) about providing the global object or values otherwise made available and integration with host hooks, and nothing else.

[10:35:14.0000] <Bakkot>
I agree that 2 and 6 should change "host" to "implementation"

[10:35:52.0000] <Bakkot>
but other than that, how does this... not already give you what you want?

[10:36:24.0000] <Bakkot>
with the exception of 2 and 6, we use "implementation-defined" only for things which HTML and other hosts do not specify, to my knowledge

[10:36:36.0000] <Bakkot>
so what distinction do you want drawn that is not currently drawn?

[10:37:07.0000] <Bakkot>
specifically, that is not currently drawn by the dichotomy between things which are specified as host hooks and things which are specified to be implementation-defined?

[10:37:41.0000] <annevk>
Bakkot: it sounds like you might not have followed the issue where there's a bunch of talk about removing all instances of "host" as if it's a bad word

[10:37:50.0000] <Bakkot>
annevk I have read and commented on that issue

[10:37:57.0000] <annevk>
Then I'm not sure what to tell you

[10:38:03.0000] <Bakkot>
annevk _you opened that issue_

[10:38:16.0000] <Bakkot>
annevk I am trying to figure out _what you want_

[10:38:33.0000] <Bakkot>
I do not particularly care about AWB's theoretical purity concerns

[10:38:35.0000] <annevk>
I want the draft to go further in what it already does

[10:38:40.0000] <Bakkot>
in what way?

[10:38:53.0000] <Bakkot>
what change to the list above, or to the usages of "implementation-defined", are you looking for?

[10:39:02.0000] <annevk>
Distinguishing hosts and implementations, we might well agree üôÇ

[10:39:21.0000] <Bakkot>
What distinction other than the one already there are you looking for?

[10:40:42.0000] <Bakkot>
Do you just want it to say "a host is the name for the thing which provides additional ambiently available values and defines the host hooks, an implementation the name for the thing which does everything else"?

[10:41:09.0000] <Bakkot>
or are you actually looking for some changes to our existing usages of "implementation" and "host"? and, if so, what changes?

[10:42:23.0000] <annevk>
Bakkot: I think the second paragraph in https://github.com/tc39/ecma262/issues/1524#issuecomment-600816056 is what would be ideal

[10:43:35.0000] <annevk>
Bakkot: provide host hooks and expectations around it and also provide a default host implementation (perhaps that can leave everything implementation-defined, but I'm not sure that would quite work since you have to setup agent clusters, agents, and realms in a certain order for things to make sense)

[10:43:36.0000] <ljharb>
I'm still not clear on why the "not html spec" should be distinguishing between "things individual html spec implementations can do" and "things only the html spec can do"

[10:44:07.0000] <ljharb>
the place to understand what all browsers, versus individual browsers, must do is the html spec. what am i missing about what you want to be in 262?

[10:44:16.0000] <Bakkot>
annevk two things: 1.) now that I've actually read through every usage of "host" and "implementation" in the spec, I don't actually think the two things are not distinguished

[10:44:46.0000] <annevk>
Bakkot: I agree with you on the status quo

[10:45:00.0000] <Bakkot>
specifically, they are distinguished by, we use host hooks + the global object for things HTML is expected to specify, and "implementation-defined" for everything else

[10:45:27.0000] <Bakkot>
and 2.) in what way does the "put links to the HTML spec where things are specified by the HTML spec" proposal not satisfy that goal?

[10:45:49.0000] <annevk>
Bakkot: well no, e.g. InitializeHostDefinedRealm says implementation-defined a bunch of times which is false

[10:45:57.0000] <annevk>
Bakkot: it's also a very bad hook

[10:46:01.0000] <annevk>
for any reasonable host

[10:46:18.0000] <annevk>
which ECMA-262 would realize if it tried to define a host pretty quickly

[10:46:46.0000] <ljharb>
do you think `InitializeHostDefinedRealm` should be more constrained?

[10:47:29.0000] <Bakkot>
annevk I am happy to change "implementation-defined" to "host-defined" in that abstract operation.

[10:47:37.0000] <Bakkot>
annevk are there other changes you would like to see?

[10:47:48.0000] <annevk>
ljharb: possibly, it should probably take parameters of sorts, it's very much unclear how to hold it

[10:48:27.0000] <annevk>
I think a good exercise would be for ECMA-262 editors to define a minimal host with the same rigor as ECMA-262 is defined and see where it breaks down

[10:48:56.0000] <annevk>
Aside from the obvious fail points such as agents there are others

[10:53:33.0000] <Bakkot>
annevk sure, I am willing to believe there are places things are underspecified or lack arguments. but other than "fix your bugs", which, sure, we are doing our best", I still do not know what actual changes you would like to see as a result of 1524

[10:54:05.0000] <Bakkot>
except I guess changing `InitializeHostDefinedRealm` to use `host-defined` instead of `implementation-defined`?

[10:54:31.0000] <Bakkot>
(or adding explicit host hooks to it instead of saying implementation-defined, or whatever)

[10:59:26.0000] <shu>
annevk: concretely there *are* things we disagree about for what's an implementation's purview vs what's a host's purview

[10:59:47.0000] <shu>
NaN is (i hope) uncontroversial, but we didn't see reason to preclude exponentiation from constrained by an upstream spec, for instance

[11:00:29.0000] <Bakkot>
yeah if some upstream spec asks for it I would happily add a host hook which says how exponentiation works more precisely

[11:04:22.0000] <devsnek>
PerformEval calls GetThisEnvironment

[11:04:42.0000] <devsnek>
if it was a direct eval, the running execution context was created by the builtin function [[Call]] method

[11:04:59.0000] <devsnek>
such an execution context has no LexicalEnvironment

[11:05:27.0000] <devsnek>
and then step 2.a fails

[11:05:35.0000] <devsnek>
2.a of GetThisEnvironment

[11:05:37.0000] <devsnek>
does that sound right

[11:08:52.0000] <shu>
there's a special case for direct eval in 12.3.6.1, step 6

[11:09:05.0000] <shu>
don't think it goes through the built-in function [[Call]]

[11:09:50.0000] <shu>
but maybe you still found a bug for indirect eval? not sure without digging deeper right now

[11:10:14.0000] <devsnek>
oh maybe i meant indirect

[11:10:29.0000] <devsnek>
the one where it actually calls %eval%

[11:11:31.0000] <devsnek>
i guess that's indirect

[11:18:24.0000] <Bakkot>
yeah, looks like that should be changed so that it's only performed for direct evals

[11:19:11.0000] <devsnek>
well it needs to be performed in either case right

[11:19:19.0000] <Bakkot>
no

[11:19:24.0000] <Bakkot>
the GetThisEnvironment call is just there to see if you get to do super calls or whatever

[11:19:28.0000] <Bakkot>
which you never get to do for indirect evals

[11:19:39.0000] <devsnek>
where does it say you can't

[11:19:48.0000] <Bakkot>
well, in principle, here

[11:19:56.0000] <Bakkot>
but it's bugged

[11:20:02.0000] <Bakkot>
but, like, try it and see

[11:20:20.0000] <devsnek>
oh you mean implementations don't allow it

[11:20:23.0000] <Bakkot>
yeah

[11:20:26.0000] <Bakkot>
and are not supposed to

[11:20:29.0000] <devsnek>
got it

[11:21:09.0000] <Bakkot>
(but the "not supposed to" is meant to be specified in PerformEval, and it's buggy, as you observe)

[11:21:47.0000] <devsnek>
https://gc.gy/54593505.png

[11:22:14.0000] <devsnek>
is the empty step implicit

[11:23:51.0000] <shu>
might be editorially clearer to reorder most of those steps

[11:24:06.0000] <shu>
unconditionally initialize in{Function,Method,DerivedConstructor} to false

[11:24:23.0000] <shu>
then subsume the current steps 5 and 6 under "if direct"

[11:24:30.0000] <devsnek>
seems legit

[11:27:40.0000] <devsnek>
https://github.com/tc39/ecma262/pull/1949

[11:55:59.0000] <Bakkot>
re: "is the empty step implicit": I would say no

[12:16:26.0000] <jridgewell>
Back to devsnek's `{ ...x, y }` syntax

[12:16:33.0000] <devsnek>
üëÄ

[12:16:52.0000] <jridgewell>
We could add that, and it wouldn't be conflicting with the `[ ...x, y ]` syntax

[12:17:24.0000] <jridgewell>
Because `{ y, ...x }` already does what `[ ...x, y ]` is intending to do.

[12:17:34.0000] <jridgewell>
The patterns are like reverses of each other.

[12:18:41.0000] <jridgewell>
`x` would contain everything except the `y` in both cases

[12:19:12.0000] <jridgewell>
`[ ...x, y ]` would be different than ` { ...x, y }`

[12:20:01.0000] <jridgewell>
But if we tried to make the object rest match the array rest, then `{ ...x, y }` would be equivalent to `{ y, ...x }`

[12:31:17.0000] <ljharb>
what syntax do you mean?

[12:32:58.0000] <devsnek>
ljharb: <+devsnek> it would be kinda cool if `{ ...x, y }` binding created x as a copy of whatever was being matched

[12:33:37.0000] <ljharb>
in pattern matching?

[12:33:40.0000] <ljharb>
or like in general

[12:33:42.0000] <devsnek>
yeah

[12:33:46.0000] <devsnek>
in bindings

[12:33:55.0000] <ljharb>
isn't that https://github.com/zkat/proposal-as-patterns ?

[12:34:06.0000] <devsnek>
no it would just be an extension of current binding syntax

[12:34:16.0000] <devsnek>
oh is that what that is

[12:34:23.0000] <ljharb>
`{ ...x, y }` tho would be super confusing if it wasn't the same as `{ y, ...x }`

[12:34:25.0000] <ljharb>
yes

[12:34:28.0000] <devsnek>
neat

[12:34:58.0000] <devsnek>
`{ y, ...x }` and `{ ...x, y }` aren't the same as object literals

[12:35:13.0000] <devsnek>
dunno why bindings would have to be

[12:36:26.0000] <ljharb>
that's because the latter is an error

[12:36:30.0000] <ljharb>
if a non-error, i'd expect them to be the same

[12:36:38.0000] <ljharb>
oh in object literals

[12:36:42.0000] <devsnek>
neither of those are errors in object literals

[12:36:43.0000] <ljharb>
they're the same if `x` doesn't have `y` :-p

[12:36:57.0000] <devsnek>
ok but

[12:36:59.0000] <devsnek>
they aren't the same

[12:37:04.0000] <devsnek>
the order matters

[12:37:17.0000] <Bakkot>
yeah but that is very rarely a difference which matters

[12:37:30.0000] <Bakkot>
(and is also obviously the difference, from the syntax)

[12:37:30.0000] <ljharb>
and conceptually they're doing the same kinds of things

[12:37:33.0000] <Bakkot>
which properties there are matters a lot more

[12:38:04.0000] <devsnek>
its the same with bindings

[12:38:31.0000] <devsnek>
`{ y, ...x }` obj without y `{ ...x, y }` obj with y

[12:40:15.0000] <Bakkot>
I don't think that is obvious

[12:40:27.0000] <ljharb>
it's not obvious to me at all

[12:40:33.0000] <Bakkot>
also it would be really confusing if we had the `let [...x, y]` syntax mean the thing people have asked for it to mean

[12:40:41.0000] <devsnek>
i don't see how its any more or less obvious than the object literal

[12:42:18.0000] <ljharb>
because in the curly braces, the three dots syntax with x either means "grab everything into x except the other things mentioned" or "pull everything from x into this new object". having it mean "grab everything, even the other things mentioned" would be wildly confusing to me

[12:42:39.0000] <ljharb>
like `const { ‚Ä¶x } = obj; const { y } = obj` seems *way* clearer to me than your suggestion

[12:43:21.0000] <devsnek>
why is it confusing for bindings to be unordered but for literals to be ordered

[12:43:26.0000] <devsnek>
er

[12:43:38.0000] <devsnek>
why is it confusing for bindings to be ordered when it isn't for literals

[12:43:56.0000] <ljharb>
in bindings, it's pulling things out of the object. in literals, it's smooshing things into it

[12:44:09.0000] <devsnek>
right

[12:44:16.0000] <ljharb>
when pulling things out, it's confusing for "y" to be pulled twice if it's only mentioned once

[12:44:39.0000] <ljharb>
iow, object destructuring currently only pulls each value once ever, or zero times

[12:44:41.0000] <devsnek>
when smooshing things in its confusing for y to be smooshed in twice if its only mentioned once?

[12:44:56.0000] <ljharb>
(unless you repeat it, actually, now that i think of it)

[12:45:09.0000] <ljharb>
i mean, `y` itself would only go in once

[12:45:16.0000] <ljharb>
a spreaded object's `y` would also go in, sure

[12:45:25.0000] <devsnek>
expression goes from 2y to 1y

[12:45:29.0000] <devsnek>
binding goes from 1y to 2y

[12:45:31.0000] <devsnek>
it's a symmetry

[12:46:04.0000] <ljharb>
not sure i get what you mean

[12:46:22.0000] <ljharb>
`const obj = { ‚Ä¶x, y }` only has one `y` on `obj`

[12:46:38.0000] <ljharb>
`const { y, ‚Ä¶x } = obj` only has one `y` binding

[12:47:02.0000] <devsnek>
`({ ...x, y } = { ...x, y })`

[12:47:02.0000] <ljharb>
i do see how in the former example, `x.y` and `y` might both exist but would still get smooshed into one `y`

[12:47:04.0000] <devsnek>
this symmetry

[12:47:16.0000] <ljharb>
right but that wouldn't be symmetrical

[12:47:26.0000] <ljharb>
because the original `x.y` value would be lost

[12:47:39.0000] <devsnek>
the shape

[12:47:46.0000] <devsnek>
not the identity of the values

[12:47:56.0000] <ljharb>
`x` would have the same shape as the RHS, sure

[12:48:08.0000] <ljharb>
but the point of destructuring is to take apart the shape

[12:48:11.0000] <ljharb>
to de structure it

[12:48:28.0000] <devsnek>
sort of?

[12:48:40.0000] <devsnek>
people use it for cloning too

[12:49:19.0000] <ljharb>
sure but that's not the point of the feature

[12:49:28.0000] <ljharb>
people use JSON for cloning, doesn't mean "cloning" is relevant to json

[12:49:41.0000] <devsnek>
i mean people use it to perform the operation it performs

[12:50:00.0000] <devsnek>
how that operation was meant to be used is kind of irrelevant

[12:50:11.0000] <ljharb>
i don't agree with that

[12:50:13.0000] <Bakkot>
devsnek: `[...x, y] = [...a, b]` is not syntax which currently exists, bu to me it has one obvious meaning: `x` gets `a`, `y` gets `b`.

[12:50:19.0000] <ljharb>
^ me too

[12:50:42.0000] <Bakkot>
devsnek: the same intuition tells me that `{...x, y} = {...a, b}` has the meaning `x` gets `a`, `y` gets `b`.

[12:51:00.0000] <devsnek>
right array literals have an coupling between the order of elements and the order of bindings

[12:51:28.0000] <devsnek>
you mean `{...x, b}`?

[12:51:52.0000] <Bakkot>
ah, sorry, yes

[12:51:58.0000] <Bakkot>
should've named the properties instead of using shorthand

[12:52:16.0000] <Bakkot>
`{...x, p: y} = {...a, p: b}` has the meaning `x` gets `a`, `y` gets `b`

[12:53:02.0000] <devsnek>
maybe its better if we leave it as a syntax error

[12:53:06.0000] <devsnek>
because i don't agree with that

[12:56:01.0000] <Bakkot>
the way I would put it is, `...` on the LHS means to me "every other thing", not "every other thing to the left of `...`", even though these are currently equivalent

[13:03:25.0000] <rkirsling>
+1

[15:38:05.0000] <devsnek>
jridgewell: why are the logical assignment operators in their own LogicalAssignmentOperator production

[15:42:26.0000] <rkirsling>
just for proposal readability

[15:42:44.0000] <rkirsling>
(see the note at the very top)

[15:43:08.0000] <rkirsling>
oh you mean operator

[15:43:34.0000] <devsnek>
hm

[15:43:37.0000] <devsnek>
i guess for the same reason

[15:44:13.0000] <rkirsling>
we mentioned needing to rename that to ShortCircuitOperator prior to merge but I thought that part was needed to avoid some AssignmentOperator implications

[15:44:15.0000] <rkirsling>
lemme check

[15:44:42.0000] <rkirsling>
*ShortCircuitAssignmentOperator, I mean

[15:45:22.0000] <rkirsling>
er yeah that's exactly it

[15:45:38.0000] <rkirsling>
there's only one RS for AssignmentExpression:LeftHandSideExpressionAssignmentOperatorAssignmentExpression

[15:45:53.0000] <rkirsling>
grr AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression even

[15:45:55.0000] <ljharb>
altho jridgewell, with the newest ecmarkup/grammarkdown, you might no longer need to mention it as a separate productiopn

[15:46:06.0000] <ljharb>
like, the inline `<ins>` might Just Work

[15:46:16.0000] <rkirsling>
but each short circuit assignment op has its own RS case

[15:47:03.0000] <devsnek>
so its going to be its own production

[15:47:10.0000] <devsnek>
not an AssignmentExpression

[15:47:46.0000] <rkirsling>
I mean it has to not be an AssignmentExpression at the very least

[15:48:00.0000] <rkirsling>
er

[15:48:01.0000] <rkirsling>
dammit

[15:48:05.0000] <rkirsling>
AssignmentOperator

[15:48:15.0000] <devsnek>
why

[15:48:20.0000] <rkirsling>
it *is* an AssignmentExpression

[16:18:44.0000] <devsnek>
can we rename NameSpaceImport to NamespaceImport

[16:19:08.0000] <ljharb>
yes please

[16:19:14.0000] <rkirsling>
lol that is a really irritating capitalization

[16:19:30.0000] <Bakkot>
import { mars } from space;

[16:19:30.0000] <rkirsling>
welcome to the Name Space

[16:20:54.0000] <devsnek>
:notlikethis:

[16:22:37.0000] <rkirsling>
it'd make sense in the sentence "`foo = 0` and `fox = {...}` are close in name space but not in value space"

[16:48:23.0000] <shu>
not as annoying as NamespaceImPort

[16:49:03.0000] <rkirsling>
ow

[16:49:24.0000] <rkirsling>
it hurts

[16:51:05.0000] <ljharb>
it's a good port

[16:54:04.0000] <rkirsling>
I mean if it's German then I'm okay with it

[16:54:09.0000] <rkirsling>
Namespace in dem Port


2020-04-15
[17:54:33.0000] <devsnek>
what is one supposed to do when the spec says "If R contains any GroupName" or "ith capture of R"

[17:55:15.0000] <devsnek>
implicitly reparse the [[OriginalSource]] of R?

[17:57:31.0000] <Bakkot>
the spec doesn't really tell you how you should implement things, just what their observable behavior should be

[17:58:08.0000] <Bakkot>
reparsing would work; in practice I am pretty sure everyone just stores things on the internal representation of the regex

[18:00:30.0000] <devsnek>
i mean that it's not really defined what "r contains any groupname means"

[18:00:47.0000] <devsnek>
move the last quote over one word :(

[18:03:36.0000] <shu>
that's just the static semantics for Contains, no?

[18:03:55.0000] <Bakkot>
shu: the problem here is that R is a RegExp instance, not a parse node

[18:04:02.0000] <shu>
ah

[18:06:10.0000] <shu>
but the original source is kept around in the spec machinery i imagine

[18:06:18.0000] <shu>
through enough unwrappings of [[OriginalSource]]

[18:54:10.0000] <devsnek>
shu: that's a source text though, not a parse node

[08:48:11.0000] <jmdyck>
devsnek: my guess is, that was written without thinking about what it meant in terms of the spec's model.

[08:51:49.0000] <jmdyck>
RegExp instance maybe needs a [[PatternContainsAGroupName]] slot

[14:07:47.0000] <rkirsling>
wow, does eshost do some sort of weird script-wrapping?

[14:08:16.0000] <rkirsling>
`print('x:', 'y');` collapses for just JSC, but `'x', 'y';` collapses for everyone

[14:10:36.0000] <rkirsling>
(of course both of those are totally fine without eshost)

[14:23:14.0000] <devsnek>
rkirsling: it tries to parse errors using regex

[14:23:38.0000] <devsnek>
the regex for jsc and quickjs are apparently lax enough to just match `x: y`

[14:23:45.0000] <devsnek>
https://gc.gy/54690676.png

[14:25:22.0000] <rkirsling>
QuickJS is one thing but it seems like it's trying to have JSC resolve `y`?

[14:25:40.0000] <devsnek>
wdym

[14:25:57.0000] <rkirsling>
dunno why else it would say `y: undefined`

[14:26:09.0000] <devsnek>
the group its trying to access is undefined

[14:26:10.0000] <devsnek>
on the regex

[14:26:16.0000] <rkirsling>
oh hm

[14:26:41.0000] <rkirsling>
are you talking about a regex inside JSC or something for JSC that eshost has?

[14:26:49.0000] <devsnek>
eshost has it

[14:26:54.0000] <devsnek>
i don't really know why it does

[14:27:10.0000] <devsnek>
maybe a long time ago the shells exited 0 even if they failed

[14:27:43.0000] <devsnek>
this reminds me again that i was going to try to modernize eshost

[14:28:53.0000] <rkirsling>
this is causing at least one bogus test262 result :(

[14:29:07.0000] <rkirsling>
I mean we're failing that test anyway but it prevents us from even trying

[14:30:58.0000] <devsnek>
https://github.com/bterlson/eshost/blob/master/lib/agents/jsc.js

[14:31:03.0000] <devsnek>
`x: y\n` matches this regex

[14:35:32.0000] <rkirsling>
wow

[14:35:35.0000] <rkirsling>
that is horrible

[14:35:48.0000] <rkirsling>
so yeah `print('x: ', 'y')` is even okay

[14:36:07.0000] <rkirsling>
I don't understand what needs to be done there

[14:38:11.0000] <devsnek>
i don't really know why any error parsing is needed

[14:38:26.0000] <devsnek>
i would just make stderr red and call it a day

[14:40:39.0000] <Bakkot>
I think JSC did previously exit with 0 on error

[14:43:16.0000] <devsnek>
all the engines have it

[14:43:46.0000] <devsnek>
maybe its so it turns red for test262 printing out Test262Errors

[14:50:17.0000] <rkirsling>
https://github.com/bterlson/eshost/issues/106

[15:23:11.0000] <devsnek>
rkirsling: what happens if you just remove it and run test262

[15:23:31.0000] <devsnek>
like does anything thats supposed to be detected as failure accidentally succeed

[15:24:15.0000] <rkirsling>
could try in a bit

[15:36:49.0000] <Bakkot>
request for feedback on a possible editorial change: https://github.com/tc39/ecma262/issues/1950

[15:38:53.0000] <devsnek>
i've spent so much time over the past week ctrl+f'ing around the document while trying to implement various operations for engine262

[15:39:00.0000] <devsnek>
this would be so nice


2020-04-16
[19:15:22.0000] <devsnek>
is there an equiv of indexOf that scans towards the beginning of the array

[20:04:27.0000] <Bakkot>
devsnek: lastIndexOf?

[20:05:02.0000] <devsnek>
oooo

[20:05:13.0000] <devsnek>
thank you

[20:05:32.0000] <devsnek>
can get rid of this https://gc.gy/54711327.png

[10:03:08.0000] <devsnek>
bradleymeck: i added hashbang to the new engine262 parser üéâ

[10:36:16.0000] <bradleymeck>
yay!

[11:23:21.0000] <devsnek>
rkirsling: more test262-harness weirdness https://gc.gy/54766391.png


2020-04-18
[17:46:47.0000] <rkirsling>
wow, weeding through CLDR discrepancies is the worst

[17:47:19.0000] <rkirsling>
I really hate that we have so many version-dependent tests

[17:48:23.0000] <rkirsling>
"make sure this JS construct initialized with en-US locale absolutely does this thing that didn't work until ICU 65"

[17:51:57.0000] <rkirsling>
(we as in test262, for clarity)

[08:43:34.0000] <spenguin>
ljharb: I have an extremely dumb question, but I keep getting confused by reading https://github.com/tc39/proposal-private-fields-in-in. If you can't refer to a private field outside of that class, wouldn't an instanceof check suffice to tell you if the private field existed?

[08:44:08.0000] <spenguin>
or can private fields (and/or methods) be created dynamically?

[08:44:50.0000] <spenguin>
(I thought that they had to be included in the class body)

[08:52:36.0000] <spenguin>
can you access a private field on an instance of another class if that class has a private field with the same name as one of yours?

[09:16:10.0000] <devsnek>
spenguin: instanceof is not strong enough

[09:16:47.0000] <devsnek>
Object.create(X.prototype) is an instanceof X but it doesn't have X's private fields

[09:23:53.0000] <spenguin>
oh! duh. Thanks!

[09:27:36.0000] <spenguin>
that clears up all of my confusion.


2020-04-19
[20:34:15.0000] <ljharb>
spenguin: in general, `instanceof` has always been unreliable due to [[Prototype]] hijinx with __proto__, and in ES6, Symbol.hasInstance was added, so now it's entirely unreliable

[20:34:30.0000] <ljharb>
(or at least, the question it answers is almost never what people are asking)

[06:03:52.0000] <spenguin>
ljharb: oh wow I didn't know about Symbol.hasInstance


2020-04-20
[06:10:26.0000] <annevk>
What's the likelyhood of SharedArrayBuffer gaining the isView static? Asking because of https://github.com/web-platform-tests/wpt/issues/23111

[06:10:47.0000] <annevk>
shu: ^^

[12:16:29.0000] <rkirsling>
jridgewell: just a status update? üò±

[13:08:11.0000] <shu>
annevk: ArrayBuffer.isView is supposed to also work for SAB-backed TypedArrays, is that insufficient for WPT?

[13:08:27.0000] <shu>
annevk: that is, WPT wants a narrow SAB.isView that only returns true for SAB-backed views?


2020-04-21
[21:22:51.0000] <annevk>
shu: you might wanna look at the PR first, it's using isView to distinguish AB and SAB

[21:41:42.0000] <shu>
annevk: oh i see, interesting

[21:44:31.0000] <shu>
it seems like an unfortunate way to test SABness but i don‚Äôt think there‚Äôre any plans to add isView to SAB

[21:45:45.0000] <annevk>
shu: this is all fallout from that hiding you all proposed that I'm dealing with...

[21:46:42.0000] <annevk>
oh my bad, shu, I meant to link https://github.com/web-platform-tests/wpt/pull/23112

[22:36:56.0000] <shu>
annevk: well, i‚Äôm not particularly happy about the price we pay for spectre either, but i‚Äôm willing to live with some oddness in wpt. in this case cross realm brand checks is a general JS issue though, how does it deal with other constructors where e.g. no Array.isArray is available?

[22:43:57.0000] <annevk>
shu: this isn't about cross-realm

[22:47:12.0000] <shu>
annevk: ah, i'm sorry i misunderstood, it's because SAB isn't available for the equality check?

[22:48:05.0000] <annevk>
shu: yeah, it wants to check that what Wasm returns is actually a SAB

[22:48:15.0000] <annevk>
well the Wasm.Memory API

[22:48:22.0000] <annevk>
WebAssembly.Memory, sigh

[22:49:39.0000] <shu>
annevk: i'd think checking @@toStringTag is a more direct check

[22:50:48.0000] <Bakkot>
or `.constructor.name` or whatever

[22:51:48.0000] <shu>
will catch up tomorrow morning, sleep time now

[23:00:29.0000] <rkirsling>
wow, what a healthy bedtime

[23:01:42.0000] <devsnek>
üõèÔ∏è

[23:11:29.0000] <ljharb>
why would toStringTag or the mutable contructor property's mutable name property be a more direct check?

[23:11:49.0000] <ljharb>
if you want it to *claim* to be an SAB, sure, but not if you want it to actually be one - that requires checking for the presence of internal slots.

[23:15:28.0000] <Bakkot>
generally platform tests exist to help cooperating implementations, not maximize the chances of tripping up an adversarial one

[23:42:26.0000] <ljharb>
ah, fair, i suppose it's not important in tests


2020-04-23
[01:14:03.0000] <annevk>
shu: https://bugzilla.mozilla.org/show_bug.cgi?id=1624266#c44 and also my comment further down as a FYI

[08:34:43.0000] <shu>
annevk: thanks, i'll respond in there

[14:24:21.0000] <devsnek>
yo inline tables look really slick

[14:24:26.0000] <devsnek>
we should use them more often

[14:24:35.0000] <devsnek>
https://gc.gy/55382074.png

[14:28:37.0000] <jmdyck>
The source is a pain though. Would be nice if ecmarkdown added notation to make the source compact.

[16:46:18.0000] <devsnek>
rip lexical environment 2011-2020

[16:50:33.0000] <devsnek>
jmdyck: there are some stray references to "lexical environment" in notes and stuff

[16:51:18.0000] <jmdyck>
yeah, i think all the ones i left are okay.

[16:52:01.0000] <devsnek>
i think all of them are used in ways that aren't clear

[16:52:46.0000] <jmdyck>
i'll take another look.


2020-04-24
[17:44:04.0000] <Bakkot>
devsnek none of them seem particularly unclear to me?

[17:44:09.0000] <Bakkot>
do you have a concrete example?

[17:46:13.0000] <devsnek>
Bakkot: the ones with the with statement seem okay now that I read them again since they explicitly mention the execution context

[17:46:27.0000] <devsnek>
the other two occurances seem kind of undefined though

[17:48:23.0000] <Bakkot>
hm

[17:49:05.0000] <Bakkot>
the one in the definition of ECMAScript Function Objects is using it to talk about the concept, not a concrete thing in the specification

[17:49:19.0000] <Bakkot>
like, that's what a closure is: it is some code closed over a lexical environment

[17:50:01.0000] <devsnek>
ü§∑

[17:50:33.0000] <Bakkot>
the one which is "NOTE: Only a single lexical environment is needed for the parameters and top-level vars." seems pretty clear to me: if you go down that branch you end up with one LexicalEnvironment, by contrast to the other branch, where you end up with two

[12:31:01.0000] <ljharb>
is there any reason why RegExp.prototype is `/(?:)/` rather than `/|/`? both seem like they're equivalent

[12:35:58.0000] <bradleymeck>
| would require an actual alternation inside of it right?

[12:47:21.0000] <rkirsling>
it is an alternation but it's a needless one

[12:48:10.0000] <rkirsling>
`/|/` is shorter to type but equivalent to `/(?:)|(?:)/` so it'd be redundant in that sense

[13:04:45.0000] <ljharb>
right

[13:04:54.0000] <ljharb>
but since it's shorter :-p

[13:51:45.0000] <Bakkot>
I don't think shorter is the goal, necessarily

[13:51:59.0000] <devsnek>
technically you could just have `//`

[13:53:45.0000] <ljharb>
devsnek: that's a comment

[13:54:17.0000] <devsnek>
or an empty regex

[13:58:01.0000] <Bakkot>
not in JS! :P

[13:58:12.0000] <Bakkot>
new RegExp("").toString() === '/(?:)/'

[14:15:29.0000] <rkirsling>
"undeniable" is a weird word

[14:15:44.0000] <rkirsling>
(I mean our meaning, not the word in general)


2020-04-25
[17:10:53.0000] <bradleymeck>
rkirsling: is there a better short phrase?

[17:16:01.0000] <rkirsling>
bradleymeck: oh it just made me wonder what would be "denying"

[17:16:30.0000] <bradleymeck>
the ability to make a new reference to the value in question without being passed it

[17:16:54.0000] <bradleymeck>
basically you can't prevent someone from being able to get a reference =? it cannot be denied access

[17:17:26.0000] <bradleymeck>
term comes from the ocap focused members within tc39 so it kind of makes sense to be so terse

[17:18:40.0000] <rkirsling>
hmm I see

[18:23:05.0000] <jmdyck>
why not just "accessible"?

[18:24:18.0000] <bradleymeck>
jmdyck: things are accessible even if you can deny them by deleting globally accessible references. undeniable is a subset of accessible

[18:25:29.0000] <jmdyck>
the implementation can delete, or some other ES code can delete?

[18:25:35.0000] <bradleymeck>
there is just a lot of undocumented murkiness here, but the import part is about if something is deniable, not if it can be accessed

[18:26:01.0000] <bradleymeck>
jmdyck: that is also murky (see things where __proto__ are being deleted these days by runtimes)

[18:26:09.0000] <ljharb>
jmdyck: if first-run code can prevent you from getting to it, it's deniable

[18:26:15.0000] <ljharb>
that's the definition

[18:26:35.0000] <ljharb>
(because the only security model that exists in JS is "being first-run code")

[18:26:46.0000] <bradleymeck>
pretty much

[18:27:00.0000] <bradleymeck>
you have to apply other things ontop of running first to get other guarantees

[18:27:09.0000] <jmdyck>
hm, so now I'm wondering how anything is undeniable

[18:32:04.0000] <bradleymeck>
jmdyck: usually via prototypes being stuck on things, even if you don't have a ref to String.prototype, '' leaks it as its own prototype , https://github.com/Agoric/SES-shim/blob/05582658d61c4551472329a59ddca1455f256d23/packages/harden/src/anonIntrinsics.js#L78-L85

[18:45:44.0000] <rkirsling>
I guess if it were unobstructable / unobscurable then it would be straightforward but "undeniable" is colloquially a synonym "legitimate" hehe

[18:45:53.0000] <rkirsling>
*synonym for

[18:46:42.0000] <rkirsling>
(or well "unequivocal" would be more accurate than legitimate but whatever)

[18:47:56.0000] <rkirsling>
or more succinctly, "deny X" != "deny access to X"

[18:48:17.0000] <rkirsling>
but I realize this is wasted effort on my part lol

[21:04:08.0000] <ljharb>
jmdyck: anything accessible from syntax is generally undeniable

[10:58:10.0000] <jmdyck>
For single-word clarity, I like rkirsling's "unobstructable" / "unobscurable".

[13:13:12.0000] <devsnek>
why does pattern syntax use [empty] instead of _opt

[13:18:15.0000] <ljharb>
what's pattern synta

[13:18:16.0000] <ljharb>
x

[13:18:27.0000] <rkirsling>
is there anywhere that has the entire expansion be opt-marked?

[13:18:34.0000] <rkirsling>
I think that's why.

[13:22:37.0000] <devsnek>
like why `( GroupSpecifier Disjunction )`

[13:22:39.0000] <ljharb>
devsnek: destructuring? pattern matching?

[13:22:44.0000] <devsnek>
where `GroupSpecifier : [empty]` is a thing

[13:22:47.0000] <devsnek>
instead of just doing

[13:22:53.0000] <devsnek>
`( GroupSpecifier_opt Disjunction )`

[13:22:58.0000] <devsnek>
ljharb: regex

[13:24:35.0000] <ljharb>
ah k

[13:25:41.0000] <rkirsling>
ah that does seem weird

[13:27:26.0000] <rkirsling>
if you did that you could probably update the static semantics bits to talk about GroupName instead

[13:28:24.0000] <rkirsling>
ClassRanges too is weird like that

[13:28:42.0000] <rkirsling>
seems like an editorial opportunity to me

[13:29:59.0000] <devsnek>
also kind of weird because it allows like

[13:30:04.0000] <devsnek>
`/a|/`

[13:30:08.0000] <devsnek>
empty alternatives

[13:32:36.0000] <rkirsling>
I mean `Alternative: [empty]` could still be desirable

[13:32:44.0000] <rkirsling>
err ::

[13:33:32.0000] <rkirsling>
not sure off the top of my head how you'd get rid of it

[13:36:20.0000] <devsnek>
what do you call `?=` and `?!` and `?<=` and `?<!` in groups

[13:36:38.0000] <devsnek>
well i know ?<= is lookbehind

[13:37:36.0000] <rkirsling>
"lookaround", I believe

[13:37:58.0000] <rkirsling>
oh

[13:38:54.0000] <rkirsling>
s/oh//

[13:39:07.0000] <devsnek>
aha https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Assertions

[13:39:24.0000] <devsnek>
lookahead, negative lookahead, lookbehind, and negative lookbehind

[13:39:37.0000] <rkirsling>
oh, I thought you want a single name for all four

[13:39:41.0000] <rkirsling>
*wanted

[13:39:47.0000] <devsnek>
laoops

[13:39:49.0000] <devsnek>
oops*

[13:40:01.0000] <devsnek>
i'm trying to design a usable AST

[16:04:41.0000] <devsnek>
> If the file CaseFolding.txt of the Unicode Character Database provides a simple or common case folding mapping for ch, return the result of applying that mapping to ch.

[16:04:52.0000] <devsnek>
i nominate this as the most jank algorithm step


2020-04-26
[20:53:44.0000] <Bakkot>
devsnek: my personal Most Jank Algorithm Step is still

[20:53:46.0000] <Bakkot>
> If replacing the FunctionDeclaration f with a VariableStatement that has F as a BindingIdentifier would not produce any Early Errors for func and F is not an element of parameterNames, then

[20:54:45.0000] <devsnek>
i found another step that just says "for each character c"

[20:55:26.0000] <devsnek>
as in all of the unicode characters

[20:56:13.0000] <Bakkot>
... solid

[20:56:32.0000] <Bakkot>
I guess that's probably clearer than expecting readers to know what "preimage" means

[20:56:45.0000] <devsnek>
lol

[20:56:46.0000] <Bakkot>
(for other people, the step is "For each character c not in set A where Canonicalize(c) is in A, add c to U.")

[20:57:26.0000] <devsnek>
and that step is hit twice for every occurrence of a \b or \B

[20:57:42.0000] <devsnek>
gotta be careful not to implement as written

[20:59:05.0000] <rkirsling>
Bakkot: preimage seems fair game if a definition is provided :)

[20:59:32.0000] <Bakkot>
rkirsling yeah but if you are going to define a word and then use it exactly once you should just not define that word, as a rule

[20:59:42.0000] <rkirsling>
touch√©

[20:59:45.0000] <devsnek>
on the plus side

[20:59:49.0000] <devsnek>
regex is mostly working now

[21:00:43.0000] <devsnek>
and i'm seriously considering making a big editorial pr to refactor regex

[21:02:13.0000] <Bakkot>
don't forget about annex B

[21:02:21.0000] <devsnek>
:(

[21:02:21.0000] <Bakkot>
i.e. the place regexes are actually defined

[21:05:47.0000] <devsnek>
it doesn't exist if i don't think about it


2020-04-27
[21:05:08.0000] <devsnek>
is Completion() as a call defined anywhere

[21:13:31.0000] <jmdyck>
https://tc39.es/ecma262/#sec-implicit-completion-values

[21:13:57.0000] <jmdyck>
The abstract operation Completion(completionRecord) ...

[21:17:00.0000] <devsnek>
maybe we could move that up to where Completion links to

[21:22:56.0000] <jmdyck>
problem when an abstract op has the same name as a type

[21:25:27.0000] <jmdyck>
but yeah it's weird that we give notational conventions for Completion Records well before we define Completion Records


2020-04-28
[17:49:46.0000] <Sirisian>
Random question. Whatever happened to making getters and setters async compatible?

[17:57:47.0000] <bradleymeck>
Sirisian: lack of real need, just return a Promise?

[17:58:16.0000] <bradleymeck>
adding them gets a bit confusing, even doing class init async is pretty wonky but still being looked at

[17:59:13.0000] <bradleymeck>
also, always returning a new Promise is probably undesirable usually, and async functions always make a new promise

[18:04:25.0000] <Sirisian>
I had a friend writing an API wrapper. He kind of wanted to write await foo.value = 10; but instead just made the operation synchronous which locked up his main thread. (He was fine with this). I had an old project that did something similar with network calls but did .set('value', 10) type stuff.

[18:25:11.0000] <Bakkot>
using async `setValue` methods seems better than trying to have async setters


2020-04-29
[21:22:38.0000] <devsnek>
jsvu and esvu are dead on node 14 because the extract-zip depends on yauzl depends on fd-slicer which doesn't work on node 14

[21:23:27.0000] <devsnek>
and of course, yauzl is the only zip library that can actually correctly unzip things, the others mess up the file modes or skip files and whatnot

[21:32:19.0000] <devsnek>
hm it might be fixed in 14.1.0

[21:32:26.0000] <devsnek>
though 14.1.0 isn't out yet

[21:34:30.0000] <devsnek>
https://github.com/nodejs/node/blob/master/test/parallel/test-stream-finished.js#L388-L398

[21:34:44.0000] <Bakkot>
yeah https://github.com/nodejs/node/pull/33058 claims to fix it

[21:38:13.0000] <devsnek>
i added a state check on esvu exit so it won't fail silently if this kind of thing happens in the future

[21:39:45.0000] <devsnek>
https://gc.gy/55840184.png

[15:59:36.0000] <devsnek>
what if function and class expressions could have computed names

[15:59:57.0000] <bakkot>
they can, just use `eval`


2020-04-30
[18:14:05.0000] <devsnek>
i'm wondering if there might be a way to specify a method for sync and async iterator prototypes at the same time

[18:14:41.0000] <devsnek>
sort of got this thing going https://gc.gy/55914273.png

[22:14:56.0000] <devsnek>
ljharb: is there some issue with netlify?

[22:16:08.0000] <ljharb>
devsnek: yep, they won't give us a free account without compulsory advertising, and they'll shut us down after today

[22:16:21.0000] <devsnek>
oh that's unfortunate

[22:16:28.0000] <ljharb>
devsnek: and any service that forces "free" accounts to advertise isn't free, and isn't something i'll be recommending to anyone ever again

[22:16:34.0000] <ljharb>
otherwise it worked great tho

[22:17:07.0000] <devsnek>
yeah that's kind of a shame

[22:24:26.0000] <bakkot>
it is free in the sense students care about, just not so much in the sense engineers trying to avoid an expense report care about

[22:25:44.0000] <ljharb>
also not free in the sense that the ecosystem they're hoping to lure, open source, cares about.

[22:26:09.0000] <bakkot>
I dunno, that's definitely the sense I cared about when I was publishing open source stuff in college

[13:35:10.0000] <devsnek>
has anyone ever come across js code that didn't evaluate to what they expected in when entered in a repl

[13:35:44.0000] <devsnek>
like how `while (true) { 5; break; }` evaluates to 5

[13:35:58.0000] <devsnek>
although that one doesn't seem too surprising

[13:40:18.0000] <bakkot>
devsnek: https://github.com/tc39/proposal-do-expressions/issues/21

[13:40:40.0000] <devsnek>
well yes i was thinking about do expressions

[13:41:07.0000] <devsnek>
i don't think people are generally very surprised by the results in repl

[13:41:10.0000] <devsnek>
at least that is my theory

[13:42:01.0000] <rkirsling>
wait whoa

[13:42:28.0000] <rkirsling>
oh maybe this did come up in the context of do exprs and I let it go past me but

[13:43:07.0000] <rkirsling>
I didn't know `eval('while (true) { 5; break; }')` would not return undefined

[13:43:16.0000] <devsnek>
lol

[13:43:44.0000] <devsnek>
yeah break and continue completions have an ~empty~ [[Value]]

[13:43:54.0000] <devsnek>
so it gets replaced by the value of the last item in the statement list

[13:44:17.0000] <rkirsling>
mind blown

[13:44:30.0000] <rkirsling>
I thought completion values were purely spec-internal up 'til now

[13:44:45.0000] <devsnek>
i mean they kind of are

[13:44:59.0000] <devsnek>
in terms of implementation you have a stack or accumulator

[13:45:06.0000] <devsnek>
and the last thing that modified the stack/accumulator is the `5`

[13:45:23.0000] <rkirsling>
(which is kind of silly because I've definitely looked at the thread bakkot linked; clearly something failed to click before...)

[13:46:07.0000] <rkirsling>
isn't that specific to SM and V8 respectively though

[13:46:39.0000] <devsnek>
wdym

[13:47:14.0000] <rkirsling>
SM bytecode and V8 bytecode are centered around stack and accumulator respectively but this isn't so for JSC

[13:47:30.0000] <devsnek>
oh i see

[13:47:38.0000] <devsnek>
registers too

[13:47:40.0000] <rkirsling>
yeah

[13:47:52.0000] <devsnek>
i just meant

[13:48:02.0000] <devsnek>
you have some place where you're expecting a value

[13:48:05.0000] <devsnek>
and break doesn't touch it

[13:49:04.0000] <devsnek>
it is a shame that if statements return undefined instead of empty though

[13:49:25.0000] <bakkot>
that was changed in ES6 actually

[13:49:29.0000] <devsnek>
yeah i know

[13:49:56.0000] <devsnek>
well anyway i was just thinking

[13:49:57.0000] <TabAtkins>
devsnek: {}+[] was the triadtional answer, but repls might have fixed that now

[13:50:04.0000] <ljharb>
i assume we could get browsers on board with changing a number of these things as part of the do expressions proposal, if we all agreed the change was good

[13:50:19.0000] <TabAtkins>
nope, still there

[13:50:23.0000] <TabAtkins>
in chrome, at least

[13:50:24.0000] <bakkot>
I think that completion values no longer have any cases where something either is or is not empty depending on runtime values

[13:50:27.0000] <bakkot>
which I am happy about

[13:50:36.0000] <devsnek>
TabAtkins: in the repl proposal, lookahead = { is parsed as an object literal

[13:51:10.0000] <devsnek>
but anyway my idea was that people generally don't seem bamboozled by how the repl behaves (block vs object literal aside)

[13:52:19.0000] <devsnek>
TabAtkins: interestingly in the node repl it eagerly tries to wrap the input in (), so it parses as object literal

[13:52:32.0000] <TabAtkins>
Yeah, that's the behavior I'd naively expect.

[13:52:41.0000] <TabAtkins>
RAther than {}+[] being a block followed by +[]

[13:53:00.0000] <TabAtkins>
But yeah, that's literally the only thing I've been confused about

[13:53:03.0000] <devsnek>
we should've used {||} for blocks /s

[13:54:27.0000] <bakkot>
should've used `<>`

[13:54:28.0000] <bakkot>
and had the token between key and value be `=`

[13:54:29.0000] <bakkot>
so it would look like HTML

[13:54:32.0000] <devsnek>
lol

[13:55:55.0000] <devsnek>
interestingly the completion reform makes js more like rust

[13:56:13.0000] <devsnek>
you have to do `if (a) { b } else { c }` instead of `c; if (a) { b }`

[13:57:25.0000] <ljharb>
or `a ? b : c`?

[13:57:46.0000] <ljharb>
or are b and c standins for a statement list

[13:57:50.0000] <devsnek>
yea

[13:58:04.0000] <ljharb>
i'd still probably do that with two do expressions on both sides of the ternary :-p

[13:58:16.0000] <devsnek>
and that is okay

[13:58:29.0000] <ljharb>
ty for validating me <3

[13:58:31.0000] <devsnek>
so do expressions for stage 4, any objections?

[13:58:42.0000] <ljharb>
ship it, it makes pattern matching infinitely easier

[14:01:07.0000] <devsnek>
oh btw i was trying to work out how to make iterators specified in a less weird way

[14:01:11.0000] <devsnek>
came up with this so far

[14:01:24.0000] <devsnek>
https://gc.gy/55985455.png https://gc.gy/55985482.png

[14:02:20.0000] <devsnek>
those wrapped iterator things are macros which call the appropriate sync or async methods and handle awaiting

[14:02:46.0000] <ljharb>
devsnek: i think the throw and return methods need `Await` in the async version

[14:03:02.0000] <devsnek>
oh yeah those need lots of changes

[14:03:07.0000] <ljharb>
ie, the same thing shu had to do in Atomics.wait vs Atomics.waitAsync to share an abstract op between them

[14:03:14.0000] <devsnek>
`[[Iterator]].return` certainly is not valid

[14:03:41.0000] <devsnek>
also since there is an explicit next function

[14:03:49.0000] <devsnek>
it is possible to tell whether the argument was passed

[14:04:02.0000] <devsnek>
although i hate that we carry that

[14:06:11.0000] <shu>
i ultimately didn't really like that abstract op

[14:06:15.0000] <shu>
too many branches

[14:06:49.0000] <devsnek>
i abstracted the branches out into those two macros

[14:06:57.0000] <devsnek>
rn i just say `If Async`

[14:07:14.0000] <devsnek>
i don't want to have to explicitly pass `async` and `sync` to the macros

[14:16:05.0000] <shu>
ultimately i wanna serve the reader

[14:16:22.0000] <shu>
refactorings tend to help spec maintainers, but i don't think readers read the spec like they do their own codebase

[14:16:29.0000] <shu>
duplication probably isn't a big deal

[14:17:09.0000] <shu>
it's more work for us as spec maintainers to check for copy/paste errors, but sometimes i feel like it's easier to read

[14:17:53.0000] <devsnek>
i just really don't want there to end up being differences and issues

[14:18:19.0000] <devsnek>
rn this drops 24 new methods into the spec

[14:20:22.0000] <ljharb>
shu: imo totally fine to split it back up if that's clearer

