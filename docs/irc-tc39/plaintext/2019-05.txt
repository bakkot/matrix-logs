2019-05-02
[10:28:05.0000] <rkirsling>
Wonder what the best way to proceed on this "let's try to abolish early ReferenceError" idea is... https://github.com/tc39/ecma262/issues/691#issuecomment-471251881

[10:28:36.0000] <rkirsling>
attempt a PR? have a meeting discussion?

[10:31:08.0000] <Bakkot>
rkirsling: I think make a PR and bring it to committee

[10:31:30.0000] <Bakkot>
I suggest making the PR first in this case just because it's gonna be a pretty small change

[10:32:05.0000] <rkirsling>
Bakkot: right, the spec change is rather minor, just a question of who might get upset üòÖ

[10:37:15.0000] <Bakkot>
committee is the place to find that out!

[10:38:23.0000] <rkirsling>
üëç

[10:52:26.0000] <Bakkot>
ljharb / zenparsing: a coworker tripped over https://github.com/tc39/ecma262/issues/1343 yesterday

[10:52:49.0000] <Bakkot>
we got it fixed eventually, but still, would appreciate https://github.com/tc39/ecma262/pull/1464 getting merged at some point

[10:53:06.0000] <Bakkot>
let me know if there's anything you want fixed up about it

[10:57:52.0000] <ljharb>
Bakkot: tbh we're mostly waiting for waldemar to review it - if not before, someone asking him to review it in person in june would be helpful

[10:58:40.0000] <Bakkot>
cool, sounds good

[13:30:12.0000] <devsnek>
if we get rid of early reference errors engine262 will pass more tests :P

[13:36:56.0000] <rkirsling>
devsnek: :high-five:

[13:37:04.0000] <devsnek>
lol


2019-05-03
[21:53:09.0000] <srl295>
mathiasbynens: what's this, an ECMA-402 topic on the UTC agenda tomorrow?

[21:53:30.0000] <srl295>
+1

[09:35:54.0000] <srl295>
mathiasbynens: I don't have a specific opinion on http://www.unicode.org/L2/L2019/19168-regex-string-prop.pdf but +1 ‚Ä¶¬†+2 ‚Ä¶¬†on moving this forward

[11:43:55.0000] <mathiasbynens>
srl295: thanks :) hoping we can figure this stuff out together!

[11:44:08.0000] <srl295>
mathiasbynens: yup!

[13:46:54.0000] <srl295>
mathiasbynens: we heard you hang up

[13:58:23.0000] <mathiasbynens>
srl295: sorry, i got kicked out of my meeting room üòÖ

[13:58:59.0000] <srl295>
mathiasbynens: no sympathy !  anyway we are on to other topics

[13:59:28.0000] <srl295>
(I mean, no sympathy from those kicking you out‚Ä¶¬†plenty from me!)


2019-05-05
[12:37:30.0000] <devsnek>
littledan: are the wasm esm semantics far enough along that it's wise/safe for node to have a `--experimental-wasm-modules`

[12:37:55.0000] <devsnek>
someone wants to land this and I'm not sure that it's s good idea to do so before TLA happens

[14:07:17.0000] <littledan>
I think the Wasm/ESM semantics are stable. We have discussed them several times in the Wasm CG meeting, and they are at a state just awaiting implementations

[14:08:33.0000] <littledan>
A non-TLA implementation would be fine, just putting the compilation work on the main thread. Technically a spec violation, but I don't think most applications will notice. It's the kind of thing very likely to be ecosystem-compatible to upgrade later

[14:08:46.0000] <littledan>
I haven't reviewed the implementation yet; it's on my to-do list

[14:29:58.0000] <devsnek>
littledan: when does the start function run

[14:30:24.0000] <littledan>
During the evaluate phase

[14:30:39.0000] <devsnek>
i assumed as much

[14:30:43.0000] <littledan>
as if it were JS code at the top level of your module

[14:30:51.0000] <devsnek>
that means we can't really implement this with the js wasm api


2019-05-07
[09:10:09.0000] <Domenic>
devsnek: what does .enumerate() do

[09:10:41.0000] <devsnek>
Domenic: goes from an iterator of [V1, V2, V3] to [[0, V1], [1, V2], [2, V3]]

[09:10:58.0000] <devsnek>
from my experience with iteration in rust and python its a very useful function

[09:11:15.0000] <Domenic>
Huh. Maybe not the best name.

[09:11:21.0000] <Domenic>
I can see it though

[09:11:33.0000] <Domenic>
I've often had to keep a counter when iterating maps/sets

[09:11:56.0000] <devsnek>
there's an argument that map can replace enumerate

[09:12:02.0000] <devsnek>
but i think having both is okay

[09:12:53.0000] <devsnek>
you'd have to add an index to map

[09:13:01.0000] <devsnek>
and i'm not a fan of map on iterators having an index

[09:13:11.0000] <Domenic>
Yeah, I tend to agree

[09:13:51.0000] <devsnek>
i really need to write all these methods for the async prototype

[09:15:02.0000] <devsnek>
maybe we can just bring up "specifying async generators" at the june meeting

[09:16:07.0000] <ljharb>
if map shouldn‚Äôt have an index then why have enumerate? map having an index seems appropriate, even if we don‚Äôt call it index

[09:16:37.0000] <devsnek>
iterators don't have well defined starts and ends

[09:16:41.0000] <devsnek>
in a generic sense

[09:16:48.0000] <devsnek>
enumerate explicitly adds a counter

[09:17:02.0000] <devsnek>
but map is just going from value to value, there's no explicit sense of counting there

[09:17:33.0000] <ljharb>
right but i can use enumerate and ignore the counter, so why would i need map

[09:17:48.0000] <devsnek>
enumerate and ignore the counter?

[09:17:58.0000] <devsnek>
enumerate doesn't take a mapfn

[09:18:26.0000] <devsnek>
it just introduces a counter into your iterator chain

[09:18:44.0000] <ljharb>
oh, hm

[09:19:06.0000] <ljharb>
I‚Äôd rename it then but i think i get what it‚Äôd be for

[09:19:45.0000] <devsnek>
well its called enum or enumerate in other langs

[09:19:54.0000] <devsnek>
i don't want js to be the special kid

[09:22:53.0000] <ljharb>
enumerate in ruby is what it makes me think of

[09:23:26.0000] <ljharb>
other langs have a method called ‚Äúenumerate‚Äù that inject an index into a new lazy iterator?

[09:23:41.0000] <devsnek>
at least python, c#, and rust

[09:24:14.0000] <devsnek>
actually c# has it twice, because such is the way with c#

[09:24:19.0000] <devsnek>
Select and Enumerate

[09:24:54.0000] <devsnek>
ruby apparently calls this `each_with_index`

[09:25:11.0000] <ljharb>
that sounds like a clearer name to me, modulo snake case

[09:25:31.0000] <ljharb>
or just ‚ÄúwithIndex()‚Äù taking no arguments

[09:25:59.0000] <devsnek>
perhaps

[09:42:07.0000] <rkirsling>
Ruby's probably not the best go-to for standard namings of things, hehe

[09:49:00.0000] <ljharb>
perhaps, but ‚Äúenumerate‚Äù already has a meaning in js and ‚Äúadd an index‚Äù isn‚Äôt it

[09:49:29.0000] <devsnek>
everything has seven meanings

[09:50:00.0000] <rkirsling>
ljharb: yeah I suppose that's fair

[09:50:19.0000] <ljharb>
devsnek: xkcd standards dot jpg

[09:58:06.0000] <rkirsling>
I think the conception is less about "adding an index" and more about "counting off the list items" (i.e. enumerating them), but it's tricky when you've got an `enumerable` property so fundamental to the language that indicates not ability to *be* an enumeration but rather ability to be *included* in an enumeration

[09:59:12.0000] <devsnek>
oh yeah that thing

[10:02:34.0000] <rkirsling>
never thought about how unfortunate that name choice is until now

[10:04:37.0000] <ljharb>
but also, "enumerate" is a verb that describes what `.forEach` and friends does.

[10:04:53.0000] <ljharb>
the index is already there, it's not added by the verb

[10:06:01.0000] <rkirsling>
yeah but that's not in conflict

[10:06:24.0000] <rkirsling>
if your collection has a `.forEach` method then there's nothing further to do, right?

[10:10:32.0000] <rkirsling>
though that is admittedly different from the other languages mentioned given the dynamicness of "hey there's a second param here if you want it"

[10:11:47.0000] <rkirsling>
in the others, iterating over a list would just give you the items and you'd need to explicit request to get tuples instead

[10:14:03.0000] <ljharb>
what would happen with `['a', 'b', 'c'].entries().withIndex().withIndex()`? would it just keep nesting deeper entries each time?

[10:19:08.0000] <rkirsling>
ha, hadn't thought to try that before, but yeah, Python and Rust give `[(0, (0, 'a')), (1, (1, 'b')), (2, (2, 'c'))]`

[10:19:30.0000] <rkirsling>
(if you make a list out of it again that is)

[10:58:25.0000] <gibson042>
is the idea here something like `%IteratorPrototype%.withIndex = function*(){ let i=0; for(let v of this) yield [i++, v] }`?

[10:58:26.0000] <gibson042>
or maybe `%IteratorPrototype%.map = (call => function*(callbackfn, thisarg){ let i=0; for(let v of this) yield call(callbackfn, thisarg, v, i++, this) })(Function.prototype.call.bind(Function.prototype.call))`?

[10:59:34.0000] <ljharb>
gibson042: for withIndex, yes

[10:59:45.0000] <ljharb>
harder for me to parse that latter one

[11:03:40.0000] <gibson042>
the latter is analogous to Array.prototype.map; it would be used like e.g. `str[Symbol.iterator]().map((codePoint, cpIndex) => ‚Ä¶)`

[11:05:33.0000] <gibson042>
or perhaps more appropriately, `.map((element, index) => [index, element])` (which is identical to withIndex)

[11:05:39.0000] <ljharb>
gotcha

[11:14:22.0000] <Domenic>
I think there's a larger discussion as to whether we think generic iterators have indices or not

[11:15:07.0000] <Domenic>
If we said they have indices then lots of operations become more applicable, e.g. findIndex, indexOf, ...

[11:30:14.0000] <rkirsling>
I really think "index" might be the wrong word in that case (Rust and Python docs just say "(iteration) count", say) -- 'cause the output from a generator, say, can be counted but that doesn't mean it's an indexed collection

[11:53:11.0000] <ljharb>
i mean sure, but it's basically just a zero-based counter

[11:53:27.0000] <ljharb>
`.withEventualIndexWhenSpreadIntoAnArray`

[11:54:05.0000] <Domenic>
I don't think making a distinction between indices and iteration count is useful

[11:55:40.0000] <ljharb>
i agree, but i don't think `.withIndex` would need to imply that generic iterators have indices either

[11:55:48.0000] <Bakkot>
Domenic: +1 to larger discussion about whether iterators have indices

[11:56:27.0000] <Domenic>
+1 ljharb. But if we changed iterator.map(el => ...) to iterator.map((el, index) => ...) then I think we're in the larger-discussion territory.

[11:56:52.0000] <ljharb>
fair point, agreed!

[11:57:11.0000] <ljharb>
`.withIndex().map` is simple enough, assuming the methods are lazy

[11:57:19.0000] <Bakkot>
I tend to think iterators do have indices, but that is maybe my math background leaking in ("has an iterator" means "enumerable" means "has a bijection with N" means "has indices")

[11:57:42.0000] <Domenic>
I tend to think so too, but people get really upset when I suggest sets have indices

[11:57:53.0000] <Bakkot>
bah

[11:57:59.0000] <ljharb>
some people get upset when i remind them that JS Sets have an explicit ordering too

[11:58:05.0000] <Bakkot>
abstract sets don't, but JS's Sets do

[11:58:08.0000] <ljharb>
right

[11:58:25.0000] <Bakkot>
(aside: that reminds me I gotta get on specing for-in order for this meeting)

[11:59:27.0000] <Domenic>
While we're all here, anyone have any suggested fun examples for JSON modules? Along the lines of https://html.spec.whatwg.org/multipage/scripting.html#script-type-module-example-2

[11:59:39.0000] <Domenic>
Otherwise I'm just gonna import a config file

[12:01:01.0000] <ljharb>
Domenic: we use a JSON file for translation phrases in airbnb, so we effectively have `import Polyglot from 'node-polyglot'; import phrases from './phrases.json'; const p = new Polyglot(); p.extend(phrases);` altho i suppose that's also a config file

[12:01:09.0000] <Bakkot>
Domenic: https://catalog.data.gov/dataset?res_format=JSON

[12:01:22.0000] <Domenic>
Oooh these are both nice.

[12:02:12.0000] <Domenic>
What is a fun open data set... i.e. not vehicle crash deaths...

[12:02:57.0000] <Domenic>
https://github.com/jdorfman/awesome-json-datasets

[12:03:26.0000] <Domenic>
I think I'll go with people in space right now http://api.open-notify.org/astros.json

[12:03:53.0000] <Bakkot>
spaaaace

[12:03:56.0000] <Bakkot>
if you want to be meta, https://github.com/mdn/browser-compat-data/tree/master/javascript

[12:04:08.0000] <Domenic>
Oh wow that's tempting hrm

[12:04:17.0000] <Domenic>
But without rawgit there are no headers

[12:04:44.0000] <ljharb>
i found raw.githack.com that can replace it

[12:05:16.0000] <Domenic>
Nice find. Probably not good to put in the HTML spec, but I'll still use it.

[12:06:00.0000] <bradleymeck>
Domenic: JSON translations are also used at GoDaddy similarly

[12:06:49.0000] <bradleymeck>
we do have configs per env as well but that would combine import() as well which idk if is desired

[12:46:31.0000] <rkirsling>
Bakkot: your math explanation makes a lot of sense -- I think for me it's that the act of iteration is imperative / temporal and so such an "index" would have to be a time, whereas an index in a collection is a location. it's convenient that math and FP can just step outside of time and view those as the same, but yeah üòÖ

[12:48:40.0000] <rkirsling>
(anyway I'm not really objecting to `withIndex`, it's just the implication that `indexOf` would follow that felt like "whoa hang on a sec")

[13:38:57.0000] <Bakkot>
`indexOf` is super weird for iterators, because they represented ephemeral streams

[13:39:09.0000] <Bakkot>
getting an index into an ephemeral stream is not generally a useful thing to do

[13:43:57.0000] <rkirsling>
right! ephemeral is the perfect word

[14:04:24.0000] <devsnek>
i'm not a fan of map having an index

[14:04:39.0000] <devsnek>
i think you should be explicit to introduce a counter

[14:06:26.0000] <devsnek>
Bakkot: i agree that an iterator over X where X has indices would mean that the items of that iterator also technically have indices

[14:06:50.0000] <Bakkot>
devsnek: that's not really the case I was talking about

[14:06:56.0000] <Bakkot>
was talking about arbitrary iterators

[14:07:29.0000] <devsnek>
you could also say "this is the fifth item this map iterator has seen"

[14:07:33.0000] <devsnek>
but it seems rather arbitrary to me

[14:07:39.0000] <devsnek>
and other languages seem to agree

[14:07:59.0000] <devsnek>
map iterator being iterator.map() not Map.p.values()


2019-05-08
[07:27:52.0000] <joesepi>
I have a colleague that wants to join me at the Berlin meetings. How can I make that happen? Does he need to be added to places? Is the first rule of tc39 to not talk about tc39? :)

[07:34:28.0000] <annevk>
joesepi: I‚Äôd ping the chairs


2019-05-09
[07:27:15.0000] <annevk>
littledan: the other day we discussed the difference between after all microtasks and after a task, right?

[07:27:34.0000] <littledan>
annevk: Yes?

[07:28:19.0000] <annevk>
littledan: a weird edge case here is UI input events from the user, those are a single task, but multiple microtask checkpoints (one after each JS callback, since we have a checkpoint whenever the "JS engine stack" is 0)

[07:28:38.0000] <littledan>
interesting, didn't know about that

[07:28:44.0000] <annevk>
littledan: so it would in fact be quite observable which strategy you take here and I'm not sure why Domenic suggested otherwise (perhaps he forgot)

[07:28:58.0000] <littledan>
it's very possible that I misunderstood Domenic

[07:29:13.0000] <annevk>
littledan: do you remember the relevant issue? I forgot most of the context

[07:29:19.0000] <littledan>
sounds like we should take some time in the June 2019  TC39 meeting to poll implementers to see what strategy they would really use

[07:29:52.0000] <littledan>
IMO microtask checkpoint timing just makes more sense here, but I imagine others have opposing intuitions

[07:30:30.0000] <Domenic>
I would urge you to coordinate with IndexedDB implementers, not just JS engine implementers, in this regard. Maybe a more broad web platform question too.

[07:30:57.0000] <Domenic>
It's early for me, but on first glance I think annevk is right and there is an observable difference in that case which I forgot.

[07:31:30.0000] <Domenic>
Although I guess you could sweep that all under "oh, the browser just didn't GC this microtask"

[07:32:00.0000] <annevk>
only if they actually don't though

[07:32:15.0000] <littledan>
 I kind of doubt that browsers would actually queue a task to clear this list.

[07:32:16.0000] <annevk>
because at least from till it sounded like our impl strategy was after microtasks

[07:32:27.0000] <annevk>
right

[07:32:53.0000] <littledan>
(at some point I quoted my memory of what Till had said; if you heard it from me, we should probably check back with him)

[07:33:40.0000] <littledan>
at a high level, I think it'd be OK to tweak the exact semantics of the scope of holding these objects alive *after* Stage 3, as we get implementation feedback

[07:34:03.0000] <annevk>
we're in the same office and discussed it at lunch recentish

[07:34:13.0000] <littledan>
oh you're in Berlin these days?

[07:34:23.0000] <annevk>
yeah

[07:34:25.0000] <littledan>
I'm visiting right now

[07:34:34.0000] <littledan>
(but for vacation)

[07:34:37.0000] <littledan>
(sorry, off-topic)

[07:35:32.0000] <annevk>
oh, enjoy, I think you're all here soonish for a meeting too

[07:36:18.0000] <littledan>
that's right

[07:36:43.0000] <Domenic>
annevk: will you at JSConf EU and/or TC39?

[07:37:22.0000] <annevk>
Domenic: yes/maybe/attending training ystartsev is organizing

[07:37:29.0000] <Domenic>
Nice

[07:38:21.0000] <littledan>
Yeah, it'll be good to see everyone

[07:38:45.0000] <annevk>
indeed

[07:44:27.0000] <annevk>
commented on https://github.com/tc39/proposal-weakrefs/issues/39#issuecomment-490934435

[10:52:46.0000] <srl295>
ecma402 reminder: CLDR bug tracker is readonly right now. moving to jira soon

[12:55:04.0000] <srl295>
Unicode, where irony is served fresh daily.  CLDR's bug database being converted, requires Node 8 due to unresolved native sqlite issues. So using a package instead of DurationFormat in progress metrics. https://github.com/unicode-org/icu-trac2jira/commit/003254474fc2e4c99fda2d7d4df05d2d81061b88#diff-b9cfc7f2cdf78a7f4b91a753d10865a2R16   ‚Ä¶¬†i guess i should have looked for the  Intl duration polyfill

[13:19:40.0000] <Domenic>
Explain to me why Date.now() does not violate run to completion

[13:24:33.0000] <cloudshu>
wat

[13:26:39.0000] <cloudshu>
Domenic: is there a deeper meaning to run-to-completion other than "uninterrupted"

[13:27:28.0000] <Domenic>
I've heard it phrased as "cannot observe changes from other code"

[13:27:52.0000] <Domenic>
Which is connected, i.e. no other code ran concurrently and modified state you can see

[13:28:43.0000] <Domenic>
https://w3ctag.github.io/design-principles/#js-rtc is where I am coming from

[13:28:45.0000] <cloudshu>
then we can never re-enable SABs?

[13:28:48.0000] <devsnek>
Domenic: pretty sure Math.random and Date's ability to grab the current are both considered mistakes on that front

[13:29:03.0000] <Domenic>
devsnek: no, that's separate, that's ocap stuff.

[13:29:08.0000] <Domenic>
cloudshu: Well SABs are definitely RTC violations

[13:29:48.0000] <Domenic>
I'm wondering if Date.now() is similar to them. It seems different, but I'm unsure of what definition would differentiate them.

[13:29:59.0000] <cloudshu>
Domenic: hm, interesting

[13:30:35.0000] <devsnek>
Date.now can preempt running code?

[13:31:02.0000] <cloudshu>
if run-to-completion actually strictly means concurrently running code cannot affect your view of the world, then all timers violate RTC

[13:31:49.0000] <devsnek>
like through a suspend point?

[13:32:04.0000] <devsnek>
I'm confused what the angle is here

[13:32:19.0000] <cloudshu>
well, no, i mean, time is always a side channel that you can use to infer the state of the world that you aren't supposed to be privy to

[13:32:31.0000] <cloudshu>
like, how the browser chose to schedule you vs other code

[13:32:35.0000] <cloudshu>
how the OS does that

[13:32:37.0000] <cloudshu>
was the other code slow, etc

[13:33:00.0000] <devsnek>
well that's sorta what I meant earlier

[13:33:03.0000] <cloudshu>
Domenic: i feel like that's not the layman's understanding of the spirit of RTC anyways

[13:33:14.0000] <cloudshu>
it must admit time as a side channel

[13:33:38.0000] <Domenic>
Yeah, I guess a starting point would be to find a more authoritative/academic definition of RTC

[13:34:10.0000] <Domenic>
So OK, the tricky question is, is isInputPending more like Date.now() or more like SABs. https://github.com/WICG/is-input-pending/issues/12

[13:34:10.0000] <devsnek>
RTC allows yielding to a scheduler

[13:34:19.0000] <Domenic>
devsnek: it does not

[13:34:46.0000] <Domenic>
devsnek: well OK an OS-level scheduler. But not a scheduler in the browser that can run other JS that might affect you.

[13:35:23.0000] <devsnek>
are you saying like

[13:35:48.0000] <devsnek>
there should be no observable difference to your code if the VM decides to wait 10 minutes between two lines of code

[13:37:50.0000] <cloudshu>
Domenic: interesting, at least one qualitative difference is the observable state programmatically mutable

[13:38:35.0000] <cloudshu>
Domenic: like, if there were a Date.superUnsafeSetEpoch then Date.now would more straightforwardly violate RTC in my mind

[13:38:38.0000] <Domenic>
cloudshu: I don't think it is; it's based on the user's finger movements

[13:38:48.0000] <cloudshu>
oh boy

[13:39:17.0000] <cloudshu>
this "input handling code" you refer to in the issue is... browser code?

[13:39:39.0000] <Domenic>
Yeah

[13:40:12.0000] <cloudshu>
i see, hrm, then i guess it comes down to having more rigorous understanding of what side channels HTML wants to admit and what HTML doesn't

[13:41:07.0000] <cloudshu>
i don't think tdresser's argument is compelling though

[13:41:43.0000] <cloudshu>
it doesn't follow from that we have a timing channel that we throw in the towel for more easily prohibited side channels

[13:43:54.0000] <devsnek>
what's the context of all this

[13:44:12.0000] <cloudshu>
> So OK, the tricky question is, is isInputPending more like Date.now() or more like SABs. https://github.com/WICG/is-input-pending/issues/12

[13:47:51.0000] <devsnek>
hmmmm

[13:48:35.0000] <annevk>
cloudshu: agreed, SAB existing does not mean we should necessarily add a bunch of higher-level APIs relying on it

[13:49:32.0000] <annevk>
Domenic: time always seemed weird to me too, FWIW

[13:49:38.0000] <devsnek>
what good things do we get from this rtc guarantee as written in the w3c document

[13:50:12.0000] <cloudshu>
all of this v philosophical

[13:50:19.0000] <devsnek>
yeah

[13:50:23.0000] <devsnek>
I'm just curious like

[13:50:31.0000] <devsnek>
isInputPending and SAB seem like good things in general

[13:50:51.0000] <cloudshu>
devsnek: well, think about languages without strong-ish RTC requirements

[13:51:08.0000] <devsnek>
well we can contain data races to SAB

[13:51:13.0000] <cloudshu>
devsnek: c++ is pretty hard to reason about if your entire memory value might change

[13:51:20.0000] <devsnek>
yeah I agree

[13:51:42.0000] <cloudshu>
devsnek: right, having well-scoped escapes to RTC is valuable, but RTC as a strong default for the rest of the language execution is the good thing we get

[13:56:08.0000] <devsnek>
are touch events visible to web workers

[13:56:16.0000] <devsnek>
input events*

[13:56:44.0000] <devsnek>
i'd probably benchmark this on "can it be implemented with a web worker and SAB"

[13:59:24.0000] <oliverdunk>
What's SAB? I'm being nosy and it's the one keyword I couldn't follow.

[14:00:17.0000] <cloudshu>
SharedArrayBuffers

[14:02:00.0000] <Bakkot>
devsnek: from the (very short) thread: "If we don't implement this, I anticipate once off thread input is supported, folks will build this themselves this via off thread input and SAB"

[14:02:11.0000] <devsnek>
yep

[14:04:18.0000] <Domenic>
devsnek: they are not yet but there are proposals to make them so

[14:05:33.0000] <devsnek>
if such a thing happens, it seems like a fairly conclusive end point

[14:13:31.0000] <Bakkot>
devsnek: disagree; constraining values which can change during your code's turn without you touching them to Date.now(), Math.random(), and SABs seems valuable

[14:14:03.0000] <devsnek>
i just mean

[14:14:10.0000] <devsnek>
if something can be done with the base language

[14:14:12.0000] <cloudshu>
strong agree, small surface area = more analyzable

[14:14:24.0000] <cloudshu>
even if a higher level thing is reducible to some lower level thing

[14:14:36.0000] <devsnek>
ü§∑

[14:15:07.0000] <Bakkot>
(for similar reasons, I am opposed to Temporal having access to the current time without a user explicitly passing it in)

[14:17:02.0000] <cloudshu>
wait till i propose Atomics.rdtsc

[14:17:40.0000] <cloudshu>
or perhaps... Date.rdtsc

[14:24:59.0000] <Bakkot>
global.rdtsc

[14:25:06.0000] <Bakkot>
as a non-configurable property :D

[14:25:23.0000] <Bakkot>
s/property/getter/ even

[14:27:08.0000] <cloudshu>
yeaaaah

[14:27:10.0000] <not-an-aardvark>
at that point, maybe just add a "rdtsc" keyword

[14:27:30.0000] <cloudshu>
statement contexts only

[14:36:36.0000] <rkirsling>
is this the beginning of a `std:x86` proposal

[14:37:06.0000] <cloudshu>
wait wait i got one better

[14:37:13.0000] <cloudshu>
Math.fldcw

[14:37:39.0000] <Bakkot>
the threat model went out the window with spectre anyway, so, you know, why not

[14:38:18.0000] <Bakkot>
also all of these: https://twitter.com/x86instructions

[14:38:40.0000] <cloudshu>
that is one of my favorite twitters

[14:39:27.0000] <cloudshu>
https://twitter.com/x86instructions/status/1103399520329596928 so good

[14:40:57.0000] <oliverdunk>
Found in the replies: https://twitter.com/drathier/status/1103614895055081474

[14:41:54.0000] <Bakkot>
(I am as we speak in the process of adding a rediculously specific instruction to the custom JS-in-JS vm I maintain for work, so this is all extra funny to me)

[14:42:09.0000] <Bakkot>
s/rediculously/ridiculously/, argh

[14:42:43.0000] <devsnek>
merge all the x86 instructions into wasm, merge wasm into js

[14:43:17.0000] <cloudshu>
Bakkot: a big running joke back in the day for spidermonkey was JSOP_SUNSPIDER

[14:43:26.0000] <Bakkot>
haa

[14:46:38.0000] <rkirsling>
oliverdunk: it gets better if you dig into the repo too -- https://github.com/xoreaxeaxeax/movfuscator/tree/master/validation/doom

[14:47:05.0000] <oliverdunk>
Oh no

[14:47:08.0000] <devsnek>
god i love that repo

[14:48:28.0000] <cloudshu>
there is no faster code than straightline code

[14:48:35.0000] <devsnek>
x to doubt

[14:51:19.0000] <devsnek>
the real question is if we can get turbofan to only emit mov instructions :P

[14:56:06.0000] <oliverdunk>
We could then say that the number of instructions needed has reduced by ~99.92%! (1278/1279)


2019-05-10
[19:45:58.0000] <Domenic>
Sanity check: are all the !s in https://whatpr.org/infra/249.html#parse-json-into-infra-values correct? I think OwnPropertyKeys/Get() cannot fail on JSON-derived objects and arrays but you never know what someone devious could do...

[20:01:35.0000] <devsnek>
Domenic: looks correct to me

[03:05:30.0000] <oliverdunk>
Does anyone know if there's been progress on a bestFit option for Intl.RelativeTimeFormat? There's an open issue discussing the format it might take, but that hasn't been touched in a while.


2019-05-11
[21:06:01.0000] <srl295>
^ ok ecma402 folks, have fun ‚Ä¶¬†https://twitter.com/alolita/status/1127027357779316736


2019-05-14
[09:12:08.0000] <devsnek>
was it ever suggested that return with an operand could be disallowed in generators

[10:06:00.0000] <jwalden>
vaguely idle question, given a variable |code| that is a string, is there any shorter/clearer way to count the number of code points in it than |[...code[Symbol.iterator]()].length|?

[10:07:16.0000] <jwalden>
I guess the iterator-call already happens for a spread, so |[...code].length| would work too

[10:45:44.0000] <annevk>
jwalden: the latter is shortest I suspect

[11:12:43.0000] <ljharb>
jwalden: i'd love to see an accessor that returned that length without the intermediate array

[11:13:29.0000] <jwalden>
static function to do the same seems maybe preferable to me, if I were concerned about API and not just writing some goofball test code right now

[11:13:49.0000] <ljharb>
sure, i suppose that's fine, but it seems weird since `.length` is an instance property

[11:14:19.0000] <jwalden>
given code point length is O(n), an accessor that hides the perf issue seems unideal

[11:14:38.0000] <jwalden>
or at least O(n) without a bunch of work to maintain a value that is currently never accessed

[11:14:46.0000] <ljharb>
why would it need to be O(n) inside the engine

[11:14:49.0000] <jwalden>
and would presumably be relatively rarely accessed were one introduced

[11:15:12.0000] <jwalden>
gotta run through all the code units to count the number of code points in them, no?

[11:15:17.0000] <ljharb>
or rather, how is `.length` not O(n) too?

[11:15:44.0000] <jwalden>
.length is a count of code units, and that is maintained in the string to know how much memory the characters use

[11:16:07.0000] <jwalden>
or if the string is begin/end pointer denominated, you just subtract and divide by character size

[11:19:23.0000] <ljharb>
sure, but that's determined at string creation time by counting the code units

[11:19:38.0000] <ljharb>
while doing that count, couldn't the number of code points be counted at the same time, and stored alongside it?

[11:20:54.0000] <jwalden>
it /could/, but it's not accessed enough to justify four bytes' storage per string

[11:21:40.0000] <ljharb>
i'd be interested to know how often people do count code points, but also i suspect it's not accessed that much *because* it's not easy

[11:21:41.0000] <jwalden>
I suppose you can imagine custom-arena tricks or so to encode "this has multiple-unit code points in it" to avoid the cost for most things, but we're building up a lot of complexity for a thing that is not often used now

[11:21:56.0000] <ljharb>
it's usually the thing people actually want instead of length anyways

[11:22:04.0000] <ljharb>
(actually grapheme count is what people want, but that's a separate discussion)

[11:22:50.0000] <jwalden>
a number that's usable as an index is most often what people really want, if they're manipulating strings, and a count of code units plays much better with indexes as counts of code units

[11:23:06.0000] <ljharb>
hm, i'm not sure that's true

[11:23:23.0000] <ljharb>
manipulating strings by code units is often inherently broken, since code points exist

[11:23:40.0000] <ljharb>
but yeah a way to index by code point, like the `.at()` proposal, would make sense in concert

[11:23:41.0000] <jwalden>
well, if you have an index as a count of code points, of what use is it?  you have to iterate from start to find out the meaning of that index

[11:23:51.0000] <ljharb>
it's the number of things i will see on screen

[11:24:01.0000] <ljharb>
i don't care about the index

[11:30:29.0000] <Domenic>
No, that's grapheme clusters

[11:30:41.0000] <Domenic>
Code points are a not-so-useful in between, IME

[11:31:01.0000] <annevk>
Or font stuff, with ligatures

[11:36:06.0000] <ljharb>
Domenic: yeah that's fair that graphemes are what i really want

[11:45:29.0000] <jwalden>
https://paste.rs/GNo.js is roughly what I'm working on/doing right now

[11:46:17.0000] <jwalden>
basically I'm changing a bunch of coordinate stuff inside SpiderMonkey from code units to code points -- a necessary change to be able to tokenize/parse UTF-8 without inflating to UTF-16 -- and I get to think in both coordinate spaces to some degree right now

[11:46:45.0000] <ljharb>
that's quite a gasp matrix

[11:49:28.0000] <jwalden>
it seemed appropriate for the subject matter

[11:49:47.0000] <rkirsling>
TIL (as a demonstration of the definition of grapheme cluster not being dependent on glyph rendering) ·ÑÄ·ÑÄ·ÑÄÍ∞Å·Ü®·Ü® is a single grapheme cluster üëÄ

[11:50:16.0000] <jwalden>
I'm doing work on computing column numbers in code, and so I need some code with a bunch of non-BMP stuff in it, at intervals such that dicing up a line by code unit will end up splitting some code points in half

[11:50:54.0000] <jwalden>
the dicing interval I'm using is 128, but in principle it could be any number that's at least 2 for UTF-16, or 4 for UTF-8

[11:51:13.0000] <ljharb>
rkirsling: lol so i guess what i really want is a way to iterate on glyphs, and get glyph count

[11:51:32.0000] <jwalden>
and I expect to run with 128 at the end of the day, so something that hits a couple few chunks of that size is desirable

[12:07:58.0000] <annevk>
ljharb: do you want ff or ffi as a single unit depending on the font though?

[12:08:31.0000] <ljharb>
annevk: lol i just want to know if i squint, how many chunks of ink will i see

[12:08:53.0000] <ljharb>
but yeah i'd expect a ligature to be counted as 1

[12:28:19.0000] <jwalden>
bringing font metrics into core JS sounds good

[12:28:47.0000] <jwalden>
my working assumption is code editors generally are going to denominate column numbers as counts of code points, so I'm trying to make things consistent with that

[12:29:14.0000] <jwalden>
but given UTF-8 making a major hash of code unit counts, there is zero chance counts of code units are what editors will typically display

[14:52:05.0000] <gibson042>
jwalden There's a proposal for that: https://github.com/tc39/proposal-intl-segmenter includes `new Intl.Segmenter(locale, {granularity: "grapheme"})`

[14:53:40.0000] <jwalden>
gibson042: I could be wrong, but I don't think grapheme is the same as code point

[14:54:07.0000] <jwalden>
and a count of code points is definitely not a locale-sensitive thing

[14:54:16.0000] <jwalden>
(on a given string, that is)


2019-05-15
[20:16:34.0000] <gibson042>
Right, iterating over code points is already possible. Intl.Segmenter will allow for iterating over grapheme clusters.

[03:07:37.0000] <oliverdunk>
jwalden: I was reading https://mathiasbynens.be/notes/javascript-unicode last night and thought of you, have you seen it? There's a whole section on finding a string's length.

[07:56:25.0000] <devsnek>
littledan: in the wasm esm system, how does a function imported by a wasm module access the memory of that wasm module

[07:56:40.0000] <devsnek>
as far as i can tell its not possible, which seems like a bit of an oversight

[07:57:23.0000] <littledan>
well, each function sort of closes over the single memory that was used when instantiating that module (whether the module makes it itself, or imports it)

[07:57:53.0000] <littledan>
I agree that there's potential to make this more flexible. I hope either the GC proposal or a multiple memories proposal (or both?) will help here

[07:59:06.0000] <devsnek>
maybe like being able to pass memory as a function param

[08:00:47.0000] <devsnek>
littledan: do you think it's reasonable to open an issue about this on the spec

[08:06:33.0000] <rkirsling>
oliverdunk: nice, I should've expected that mathiasbynens would have such a nice write-up :D

[09:02:18.0000] <littledan>
devsnek: I think this would make sense to raise in the GC proposal. It is a fraction of the capabilities of that proposal. An issue explaining why this is important to you could be very helpful to push the proposal forward


2019-05-17
[11:10:38.0000] <laughinghan>
hey folks, I had a question mostly out of curiosity, which is how the names "spread/rest" were chosen for the syntax called "splat" in Ruby and Perl?

[11:11:17.0000] <ljharb>
no idea the history, but "splat" isn't a great name - it describes what an asterisk looks like, instead of what it doe

[11:11:18.0000] <ljharb>
*does

[11:12:21.0000] <laughinghan>
Python apparently doesn't have an "official" name but pack/unpack is probably most common (along with "star-args" which obviously wouldn't be applicable to JS, and parameter expansion which is a mouthful. Gather and scatter also occur but rarely)

[11:12:59.0000] <laughinghan>
ljharb: huh, I literally never thought of "splat" as referring to what an asterisk looks like. I thought it was a fun description of what was happening

[11:13:11.0000] <laughinghan>
which is "flattening" the argument list

[11:15:10.0000] <laughinghan>
I found this but bugs.ecmascript.org appears to be dead, and the specific ticket wasn't in archive.org https://esdiscuss.org/topic/foo-args-was-super-apply-this-arguments

[11:15:56.0000] <laughinghan>
I also tried searching github.com/tc39/archives but the results were...hard to read and none was clearly the ticket linked-to by es-discuss

[11:17:07.0000] <ljharb>
i think there might be a mirror somewhere of bugs.ecmascript.org

[13:38:48.0000] <jmdyck>
ljharb: bugs.ecmascript.org 'mirrored' at https://tc39.github.io/archives/bugzilla/

[14:38:41.0000] <TabAtkins>
"rest args" is an old term that predates JS; Common Lisp, for example, used `&rest foo` to indicate you should gather additional arguments into `foo` as a list.


2019-05-19
[02:26:11.0000] <itamarok>
Hi friends - just curious if any spec has ever been suggested for shorthand assigning multiple keys with same value to object.

[02:26:22.0000] <itamarok>
Like this https://twitter.com/itamarok/status/1127933423631441920


2019-05-20
[04:41:20.0000] <littledan>
I dunno, I use the word "splat" when describing spread/rest to people

[10:26:19.0000] <devsnek>
but it doesn't look like a splat in js

[10:45:12.0000] <rkirsling>
I consider "rest" to be self-evident given `function f(first, ...rest) {}` or `const [first, ...rest] = arr;` but to me "spread" and "splat" both seem fairly equal in requiring explanation if one's not encountered them before

[10:45:12.0000] <rkirsling>
MDN says that "spread 'expands' ... while rest ... 'condenses'", which is nice verbiage (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#Rest_syntax_(parameters))

[10:46:45.0000] <rkirsling>
the only potentially-self-evident alternative I can come up with for "spread" would be "argify" :P

[12:27:44.0000] <Bakkot>
relevant to the standard library discussion: http://pyfound.blogspot.com/2019/05/amber-brown-batteries-included-but.html

[12:30:57.0000] <devsnek>
i think the relevant question is "how many major revisions has library x that we think should be in js had"

[12:31:04.0000] <devsnek>
and then if its more than 0...

[12:32:57.0000] <Bakkot>
... we definitely are not considering including Library X for any X, are we?

[12:33:57.0000] <Bakkot>
like, people were saying "just include lodash" but I am pretty sure that was a joke

[12:34:15.0000] <Bakkot>
at least when said by delegates rather than misc people on twitter

[12:34:22.0000] <cloudshu>
i think many delegates will have real issue with the "for any x" part

[12:34:46.0000] <devsnek>
stuff like uuids, various types of compression and encryption, etc

[12:34:56.0000] <Bakkot>
cloudshu: sorry, to rephrase: there is no X such that we are considering including Library X, is there?

[12:35:19.0000] <devsnek>
i18n

[12:35:26.0000] <cloudshu>
Bakkot: ah

[12:35:27.0000] <devsnek>
cldr

[12:36:22.0000] <devsnek>
react's diffing algorithm /s


2019-05-21
[13:17:57.0000] <Domenic>
I thought at some point we were going to add a PromiseReject() abstract op? ljharb do you remember this? Maybe I was dreaming.

[13:18:33.0000] <ljharb>
I added PromiseResolve but there wasn‚Äôt a need for a PromiseReject one - happy to add it tho, i like abstract ops :-)

[13:19:08.0000] <Domenic>
We might want it in Web IDL eventually, but I guess better to wait until we have spec text that would use it.

[13:19:35.0000] <ljharb>
certainly agreed it should probably wait for a second use case

[13:19:44.0000] <ljharb>
whether that‚Äôs idl or a proposal


2019-05-23
[22:06:14.0000] <rkirsling>
TIL that, e.g. `018` isn't a syntax error and therefore `022 === 018`

[22:06:16.0000] <rkirsling>
oof

[22:49:37.0000] <ljharb>
rkirsling: in strict mode, it is

[22:50:21.0000] <rkirsling>
yeah but so is `022` -- definitely didn't see a decimal fallback comin' there

[23:18:05.0000] <TimothyGu>
rkirsling: `018` is technically only in Annex B

[23:18:47.0000] <TimothyGu>
wait jk ignore hat

[23:21:47.0000] <rkirsling>
wait is it not?

[23:22:04.0000] <TimothyGu>
yeah it is, but the whole legacy octal thing is

[23:22:15.0000] <rkirsling>
it does seem like that's the case, and that is certainly easier to swallow

[09:08:05.0000] <devsnek>
did you know in c, 0 itself is actually octal 0

[09:12:08.0000] <ljharb>
how do you know it‚Äôs not base 42 zero

[09:19:33.0000] <TabAtkins>
ljharb: because of the leading zero

[09:57:11.0000] <rkirsling>
and yet chmod is surely the only time I've ever (consciously) used octal

[10:02:30.0000] <ljharb>
TabAtkins: ah, just like the 0 is optional in `3.`, it‚Äôs optional in `00`, got it :-p	00`

[11:09:56.0000] <TabAtkins>
ljharb: yeah you got it


2019-05-24
[09:48:49.0000] <devsnek>
events looks pretty interesting

[09:50:48.0000] <devsnek>
seems to collide with iterator methods a bit

[09:55:43.0000] <Domenic>
I talked with the champion yesterday about that

[09:56:04.0000] <Domenic>
I think it needs to focus on push, i.e., being observables v2. Iterator methods is pull. They should use similar names, but at the core they are different.

[10:17:34.0000] <devsnek>
Domenic: why does it have run() if it's push

[10:17:44.0000] <devsnek>
and it has that next api

[10:17:54.0000] <Domenic>
devsnek: I mean, I think the current API is probably not aligned with my feedback yet.

[10:18:14.0000] <devsnek>
ah ok

[10:19:50.0000] <devsnek>
the idea of a generalized push interface is cool, although I always thought thats what observables were

[10:27:46.0000] <Domenic>
Yeah, I think this is (or at least should be) very similar to observables. But I think the champion has taken the promises integration more seriously from the start, whereas with observables, we kind of tacked it on at the end.

[11:38:01.0000] <cloudshu>
i do want to emphasize that pedram is the main champion for emitters!

[12:53:25.0000] <ljharb>
why comma first in that explainer tho ‡ºº;¬¥‡ºé‡∫∂ €ù ‡ºé‡∫∂‡ºΩ

[14:22:19.0000] <rkirsling>
ljharb: I suppose to emphasize that it's dot-chain-like behavior in a varargs API

[14:23:05.0000] <devsnek>
well it looks like the api is gonna be changed anyway to make it push instead of pull

[14:24:30.0000] <rkirsling>
oh hey it's basically identical to this callbag thing

[14:24:30.0000] <rkirsling>
https://github.com/staltz/callbag-basics/#reactive-programming-examples

[14:25:36.0000] <devsnek>
they compare it to callbag in the readme

[14:26:14.0000] <devsnek>
i don't really quite get what the primitive of this emitter api is though

[14:26:26.0000] <devsnek>
callback is over iterators

[14:27:31.0000] <rkirsling>
well they listed six libs that were used for inspiration but I didn't know it would be so identical to one in particular, is all


2019-05-28
[11:50:38.0000] <TimothyGu>
rwaldron: you could probably add to https://gist.github.com/rwaldron/11186883 OCaml's List.init https://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html#VALinit

[12:00:36.0000] <ljharb>
^ aka http://array.build


2019-05-29
[21:47:46.0000] <jmdyck>
Is there a website that will run eshost on sample code, show the results?

[22:05:36.0000] <ljharb>
jmdyck: not that i know of; can you not run it locally tho?

[09:43:07.0000] <jmdyck>
ljharb: not currently, no

[10:18:33.0000] <ljharb>
jmdyck: fwiw i didn‚Äôt install it for awhile but once i did, it was super easy to set up

[11:28:51.0000] <Domenic>
Puzzle me this: could something have a [[ErrorData]] internal slot, but a non-default [[GetPrototypeOf]]()?

[11:39:07.0000] <ljharb>
Domenic: `class extends Error { constructor() { return nonDefaultGetPrototypeOfObject; } }`?

[11:39:19.0000] <ljharb>
oh right, with a super in there somewhere

[11:39:27.0000] <ljharb>
something like that

[11:46:42.0000] <Bakkot>
ljharb: that wouldn't have an [[ErrorData]] slot, I don't think

[11:46:46.0000] <Domenic>
I don't think the super() will have an effect then

[11:47:45.0000] <Bakkot>
the super return trick lets you install your private fields onto someone else's object, but it can't be used to install someone else's slots on your thing

[11:48:25.0000] <ljharb>
oh right

[11:48:26.0000] <ljharb>
hmm

[11:48:53.0000] <ljharb>
seems like no then?

[11:48:55.0000] <Bakkot>
and you can't change the [[GetPrototypeOf]] slot of an object after construction

[11:49:16.0000] <Bakkot>
so yeah, I agree that there is no mechanism in the language which would allow you to do it

[11:49:32.0000] <Bakkot>
nothing forbids a host from creating such an object, though

[11:51:48.0000] <Domenic>
Thanks all :). The context was https://github.com/whatwg/html/pull/4665#discussion_r288714951 (error structured cloning)


2019-05-30
[12:26:19.0000] <caitp>
so v8 has some tests that say `class C { x = new.target }` is legal, and asserts that it evaluates to class C (in the case of `new C`) --- but the spec says the initializer is a function, is called via Call() (in DefineField), so shouldn't `new.target` always evaluate to undefined in a class field initializer?

[12:28:58.0000] <caitp>
you know what, ignore all that, the test asserts that it evaluates to undefined

[13:12:10.0000] <devsnek>
seems like an awkward interaction

[13:12:32.0000] <devsnek>
isn't it being a function more of an implementation detail

[13:12:57.0000] <devsnek>
linclark: what's that framework you use for your slides?

[13:33:46.0000] <Bakkot>
devsnek: not exactly; we decided the easiest way to think about the scope the initializers run in was that the thing they are most similar to is a method

[13:33:51.0000] <Bakkot>
e.g. `this` is the instance

[13:34:06.0000] <Bakkot>
(there's no good interpretation for `arguments` so it is syntactically prohibited)

[13:34:39.0000] <Bakkot>
but new.target and super, as the other remaining function-body things, work like they do in methods

[13:37:29.0000] <devsnek>
it surprised me at least that new.target is undefined

[16:43:12.0000] <Bakkot>
TabAtkins (or anyone else): do you know the right place to ask questions about the CSS spec?

[16:43:56.0000] <TabAtkins>
W3C irc server, #css room. Or just open an issue on our GitHub

[16:43:57.0000] <ljharb>
so you're saying that currently, visibility: hidden?

[16:44:07.0000] <Bakkot>
thanks!

[16:48:35.0000] <Bakkot>
join message fo irc.w3c.org says "This server is generally restricted to use by W3C staff and collaborators". Guess I'll go with github.

[16:59:28.0000] <Bakkot>
... lol, definitely meant CSP, not CSS

[16:59:32.0000] <Bakkot>
too many acronyms


2019-05-31
[17:10:08.0000] <TabAtkins>
lol, pinging me specifically with a question about css seemed extremely appropriate!

[17:10:30.0000] <TabAtkins>
But yeah, for CSP, github is the way to go, they don't have a specific irc room

[17:13:14.0000] <Bakkot>
I mean by the time I was pinging you I was saying the words "CSS" in my head, and was like "who knows that..."

[04:41:34.0000] <caitp>
> <devsnek>	isn't it being a function more of an implementation detail << well it may or may not actually be implemented as a function, but it is specified as one

[04:43:21.0000] <linclark>
devsnek: I use Spectacle ‚Äî¬†https://github.com/FormidableLabs/spectacle

