2020-10-01
[19:20:17.0000] <devsnek>
have we suffered enough to allow a `has` syntax or smth yet

[19:42:16.0000] <ljharb>
devsnek: not yet, i fear. but i'd immediately champion such a proposal if it seemed like it had a chance of proceeding

[23:21:43.0000] <howdoi>
in spec.emu, If I need to add a new section under an existing section, how do I go about it?

[23:26:45.0000] <Bakkot>
just... add a section?

[23:26:56.0000] <Bakkot>
I maybe do not understand the question

[23:27:41.0000] <Bakkot>
you just add `<emu-clause> [your stuff] </emu-clause>` wherever it's supposed to go

[01:13:52.0000] <howdoi>
Bakkot: thanks, was lost in the nesting.

[11:37:03.0000] <devsnek>
i'm sobbing https://bugzilla.mozilla.org/show_bug.cgi?id=1668342

[11:37:12.0000] <devsnek>
proposal to add [[IsHTMLDDA]] to .item methods

[11:42:09.0000] <ljharb>
lol yeah

[11:42:23.0000] <ljharb>
since that's paid-for code, hopefully that can be fixed

[11:42:46.0000] <devsnek>
[[IsHTMLDDAOrItemMethod]]

[11:42:59.0000] <devsnek>
i hope those sites can be updated lol

[11:43:26.0000] <devsnek>
even if magic360 patches their library, sites might be disconnected from that

[11:45:35.0000] <Bakkot>
I do not have much hope of it

[11:47:44.0000] <devsnek>
1. The production `E.length && E.item` must evaluate to *false* when `E` is an Array exotic object.

[11:49:23.0000] <rkirsling>
oh no

[12:24:27.0000] <gibson042>
/me cries softly in webcompat

[12:25:37.0000] <rkirsling>
but like, given that this proposal was motivated by layering, I thought it was understood that there would be "upward effects" no matter what?

[12:26:02.0000] <rkirsling>
still, that line is worrying

[12:30:44.0000] <Bakkot>
the hope was that things wouldn't break

[12:34:57.0000] <rkirsling>
very true :(

[12:35:18.0000] <devsnek>
maybe that's *your* hope

[12:35:24.0000] <devsnek>
you gotta enjoy the chaos

[12:40:36.0000] <Bakkot>
I do not have to enjoy the chaos

[12:40:42.0000] <Bakkot>
I have had quite my fill of chaos this year

[12:41:05.0000] <Bakkot>
though I gotta admit I am a little less invested in the proposal's success when it has String.prototype.item riding with t

[12:42:11.0000] <rkirsling>
I just am hoping not to have to revert it

[12:45:24.0000] <ljharb>
with this particular problem, i think string item is the only survivor

[12:45:30.0000] <ljharb>
ironically enough

[12:45:33.0000] <rkirsling>
devsnek: where is that line from? I can't google it

[12:45:44.0000] <devsnek>
ljharb: strings have length though

[12:45:48.0000] <devsnek>
rkirsling: my head? idk

[12:46:11.0000] <rkirsling>
oh what?! I thought that was in a WHATWG spec

[12:46:21.0000] <devsnek>
"you gotta enjoy the chaos"?

[12:46:30.0000] <rkirsling>
no no the spec line

[12:46:41.0000] <devsnek>
oh lmao

[12:46:46.0000] <rkirsling>
😅

[12:46:53.0000] <rkirsling>
sorry, I was unclear

[12:46:56.0000] <rkirsling>
`E.length && E.item`

[12:47:03.0000] <devsnek>
`E.length && E.item` is the line of code that is in that magic360 spinner thing

[12:48:11.0000] <rkirsling>
right. but you weren't saying that that's an invariant of some spec?

[12:49:26.0000] <devsnek>
rkirsling: i was jokingly saying we should add it to ecma262

[12:49:33.0000] <rkirsling>
ohh phew

[12:49:50.0000] <rkirsling>
you got me hook line and sinker

[12:53:35.0000] <ljharb>
devsnek: sure but the implication is that code is only checking objects. i certainly haven't dug into it

[12:57:52.0000] <devsnek>
i have so many places i want to use `.item(-1)`

[12:58:12.0000] <ljharb>
samesies

[13:10:56.0000] <devsnek>
does anyone have opinions about this https://github.com/tc39/ecma262/pull/2125#discussion_r497861480

[13:16:10.0000] <Bakkot>
I would prefer we not do that approach

[13:16:32.0000] <Bakkot>
the "a |Script| which is being evaluated for JSON.parse" prose is much, much clearer

[13:17:17.0000] <devsnek>
feels too magical for my tastes

[13:17:47.0000] <Bakkot>
open to other approaches, but clarity is a much higher priority for me than lack of magic

[13:17:58.0000] <Bakkot>
this is a document for humans, not a computer program

[13:19:48.0000] <devsnek>
hmm we need coverage for `JSON.parse('{ "__proto__": x, "__proto__": y }')`

[13:32:05.0000] <gibson042>
is this a <NodeList>? 🦋 `#{ length: 0, item: true }`

[13:32:30.0000] <devsnek>
gibson042: no

[13:32:40.0000] <devsnek>
but `#{ length: 1, item: true }` is

[13:33:05.0000] <rkirsling>
oh man, please meme-ify and tweet that :D

[13:34:45.0000] <Bakkot>
I think it's probably poor form for committee members to tweet memes making fun of code from random web devs

[13:36:23.0000] <rkirsling>
oops

[13:36:37.0000] <rkirsling>
that's true 😓

[15:52:35.0000] <shu>
yes let’s please not disparage the magic 360 library. both firefox and chrome have reached out, let’s see how it goes

[15:54:24.0000] <rkirsling>
apologies

[15:54:31.0000] <rkirsling>
I hope the communication goes well

[15:58:43.0000] <shu>
i mean it’s fine to vent, but we shouldn’t insult them as a way to get them to update

[15:59:04.0000] <rkirsling>
agreed


2020-10-02
[17:35:17.0000] <jackworks>
If the magic 360 library is a paid library, does it possible to contact the team? Because users have to pay to use the library so the team must have a list of their clients

[18:29:32.0000] <devsnek>
jackworks: Mozilla and Google have reached out

[18:45:34.0000] <jackworks>
Cool

[21:44:28.0000] <devsnek>
rickbutton: btw the current logic in the spec text considers `#[0]` and `#[-0]` equal but not `#[#[0]]` and `#[#[-0]]`

[22:05:07.0000] <rickbutton>
are you sure?

[22:05:07.0000] <rickbutton>
SameValueZero -> TupleSameValueZero

[22:05:07.0000] <rickbutton>
for each element:

[22:05:07.0000] <rickbutton>
  SameValueZero -> TupleSameValueZero

[22:05:18.0000] <rickbutton>
reads as correct to me, but also it is late

[22:06:15.0000] <devsnek>
rickbutton: nvm there was a typo :P sorry

[22:06:25.0000] <rickbutton>
u good :)

[22:06:43.0000] <devsnek>
 is the Tuple(len) override for compat with Array(len)?

[22:06:53.0000] <devsnek>
it seems like something worth getting rid of

[22:10:20.0000] <rickbutton>
yeah it was originally for symmetry, we have a PR to get rid of it: https://github.com/tc39/proposal-record-tuple/pull/173

[22:10:20.0000] <rickbutton>
we haven't made a final decision but I don't think anyone on the champion group has a strong opinion either way

[22:12:23.0000] <Bakkot>
the Array ctor overload s generally considered to have been a mistake

[22:12:30.0000] <Bakkot>
I am in favor of not repeating it

[22:12:37.0000] <ljharb>
slightly more of a mistake than computers themselves

[22:13:13.0000] <Bakkot>
alternatively, do not allow it to be invoked at all, and instead only allow .of and .from

[22:13:17.0000] <Bakkot>
(this is probably a bad idea)

[22:13:49.0000] <ljharb>
this has made the very sparse wall of Things I Lack an Opinion On

[22:14:00.0000] <devsnek>
i don't mind very much what Tuple(x) does

[22:14:12.0000] <devsnek>
as long as it doesn't magically create a tuple of [x] or len x based on the type of x

[22:46:36.0000] <rkirsling>
how come https://tc39.es/ecma262/#sec-array.prototype-@@unscopables includes, e.g., flatMap but not map?

[22:47:01.0000] <Bakkot>
rkirsling because `map` already existed when unscopables was introduced

[22:47:12.0000] <rkirsling>
hm

[22:47:15.0000] <Bakkot>
so someone using `with (arr)` presumably had already accounted for `map`

[22:47:17.0000] <ljharb>
pretty sure only ES6+ things are unscopables

[22:47:39.0000] <Bakkot>
but presumably had not accounted for `flatMap`, since it didn't exist

[22:47:50.0000] <rkirsling>
my real question: are we supposed to add `item` then?

[22:47:53.0000] <ljharb>
yes

[22:47:55.0000] <Bakkot>
yes

[22:47:57.0000] <rkirsling>
k

[22:48:08.0000] <Bakkot>
any new string-named array prototype property

[22:48:23.0000] <Bakkot>
like it says in the note: The own property names of this object are property names that were not included as standard properties of Array.prototype prior to the ECMAScript 2015 specification

[22:48:30.0000] <ljharb>
should TypedArray.prototype have it tho?

[22:48:41.0000] <Bakkot>
TA should not have unscopables

[22:48:42.0000] <Bakkot>
does it?

[22:48:51.0000] <rkirsling>
just Array currently

[22:48:56.0000] <Bakkot>
good good

[22:49:20.0000] <Bakkot>
(TA should, and does, get `.item`, if that was the question)

[22:49:44.0000] <ljharb>
it doesn't have it

[22:49:46.0000] <ljharb>
i'm wondering why it doesn't

[22:50:01.0000] <Bakkot>
TA didn't exist prior to ES2015

[22:50:06.0000] <Bakkot>
there was no back compat to worry about

[22:50:21.0000] <Bakkot>
unscopables is purely a back compat thing, since new code should not have `with`

[22:51:04.0000] <ljharb>
with considers non-enumerables and non-owns too tho, so why doesn't RegExp, Date, etc have unscopables?

[22:51:36.0000] <Bakkot>
presumably there was not a concern that anyone was writing `with (regex)`

[22:51:46.0000] <Bakkot>
or `with (date)`, etc

[22:52:04.0000] <Bakkot>
actually I don't know if Date or RegEx got any new string-keyed methods

[22:52:15.0000] <devsnek>
i don't think they did

[22:52:15.0000] <ljharb>
RegExp got a ton of new prototype accessors

[22:52:21.0000] <ljharb>
but i suppose they were owns before

[22:52:29.0000] <ljharb>
so, .flags, .unicode, .sticky

[22:52:40.0000] <ljharb>
String got .matchAll, .includes

[22:52:53.0000] <Bakkot>
ah, yeah

[22:53:08.0000] <Bakkot>
so yeah, presumably there was not concern that people were `with`-ing such things

[22:53:09.0000] <ljharb>
also wouldn't we want to actively prevent someone from doing something bad with `with (promise)` or `with (map)` etc?

[22:53:15.0000] <Bakkot>
certainly that would be an odd thing to do

[22:53:18.0000] <ljharb>
right but like, what's the added cost then to including all the unscopables

[22:53:32.0000] <devsnek>
its assumed that code doing `with (array) {}` exists

[22:53:32.0000] <Bakkot>
a bunch of overhead in engines?

[22:53:41.0000] <ljharb>
it would only slow down code that did the odd things that nobody thinks will ever happen

[22:53:48.0000] <devsnek>
and adding new methods shouldn't add new variables into those scopes

[22:53:57.0000] <Bakkot>
no, it adds to the amount of stuff you need to load into memory when you load the page

[22:54:02.0000] <Bakkot>
it's not free

[22:54:22.0000] <devsnek>
don't modern engines put everything in .ro_data anyway

[22:54:39.0000] <devsnek>
until it gets messed with anyway

[22:54:40.0000] <ljharb>
Bakkot: i mean, it could be lazy-loaded only when accessed or used with `with`, and if that never happened then, free?

[22:54:57.0000] <Bakkot>
re: "wouldn't we want to actively prevent someone from doing something bad with `with (promise)` or `with (map)` etc" - no? we already have a sensible thing, which is, strict mode prevents you from doing `with`; I don't think we really care to round off sharp edges for people who do that

[22:55:10.0000] <Bakkot>
I don't think lazy-loading was nearly as common a technique when es2015 was introduced

[22:55:15.0000] <ljharb>
how is array prototype unscopables not rounding off ♯ edges

[22:55:21.0000] <Bakkot>
back compat

[22:55:31.0000] <devsnek>
i think array prototype ones is about not breaking code

[22:55:34.0000] <Bakkot>
it's not "you might doo something bad", it's "we might break the web"

[22:55:37.0000] <Bakkot>
very different issue

[22:55:37.0000] <ljharb>
ah k

[22:55:53.0000] <devsnek>
`with (array) { flatMap(array, x) }`

[22:56:02.0000] <ljharb>
so, we could add them to all the others, and it'd be a cleaner system, and it wouldn't break anyone, but nobody cares because nobody does that?

[22:56:18.0000] <Bakkot>
sounds right to me

[22:56:27.0000] <devsnek>
i dunno if i would say cleaner

[22:56:39.0000] <Bakkot>
well, yeah, "cleaner" is disputable

[22:56:47.0000] <devsnek>
already crazy enough that unscopables is an object

[22:57:19.0000] <ljharb>
sure, fair

[22:57:45.0000] <ljharb>
yeah it's super weird it wasn't just a Set

[22:58:51.0000] <Bakkot>
eh, object is a reasonable enough choice if you only want string keys

[22:59:32.0000] <Bakkot>
sets get weird - like, does it reach into the slot directly, making Set contents unforgeable? does it invoke the iteration protocol, with all the complexity that entails?

[22:59:48.0000] <ljharb>
hm, true

[23:00:53.0000] <Bakkot>
I use Object.create(null) objects rather than sets or maps in some of my performance-sensitive code for that reason, when they suffice

[23:00:54.0000] <devsnek>
should just be array#includes

[23:01:18.0000] <Bakkot>
includes performs observable property accesses

[23:01:26.0000] <devsnek>
indeed

[23:01:30.0000] <Bakkot>
oof

[23:01:38.0000] <devsnek>
i guess back in 2015 engines didn't really have the optimization layout for making that ok

[23:01:41.0000] <devsnek>
but today they do

[23:03:31.0000] <Bakkot>
making use of that here sounds like it would add an extremely nasty code path to an already extremely nasty part of engines

[23:04:42.0000] <devsnek>
should've just disabled with in strict and sloppy

[23:04:53.0000] <devsnek>
sure the realms polyfill couldn't exist, but i see that as a bonus

[23:07:40.0000] <Bakkot>
and `eval` while they were at it, presumably

[23:08:11.0000] <Bakkot>
I used eval in anger this week; it was fun

[23:08:23.0000] <Bakkot>
makes prototyping a code generator a lot easier

[23:08:47.0000] <devsnek>
lol

[23:08:52.0000] <Bakkot>
just mash some strings together and eval it; don't even need to write to disk

[23:09:15.0000] <devsnek>
i use the vm to get rid of the guilt

[23:09:17.0000] <Bakkot>
gonna switch to constructing and realizing ASTs at some point

[23:09:19.0000] <devsnek>
vm api*

[23:09:34.0000] <Bakkot>
probably around the time I switch to doing the code generation in Java

[23:09:40.0000] <devsnek>
ohno

[23:09:49.0000] <Bakkot>
(the week before that I wrote eval for java! good times, good times.)

[23:10:18.0000] <Bakkot>
(don't worry, it's only used in tests)

[23:10:24.0000] <devsnek>
O.o

[23:11:09.0000] <rkirsling>
would not want to work on/in Java

[23:11:16.0000] <Bakkot>
it's actually pretty nice!

[23:11:35.0000] <ljharb>
must be subjective

[23:11:56.0000] <ljharb>
i've written java professionally for a few months total, and i doubt anyone would pay me enough to do it again

[23:11:58.0000] <Bakkot>
has some painful bits, but version 8 and subsequent introduced a lot of nicer parts

[23:12:00.0000] <devsnek>
we used java in my cs classes

[23:12:11.0000] <devsnek>
never going back

[23:12:54.0000] <Bakkot>
I think java-as-taught-in-cs-class is probably a much worse dialect of the language

[23:13:33.0000] <devsnek>
at least i skipped the class where java itself was the subject

[23:14:58.0000] <devsnek>
probably the worst thing was failing an assignment because the homework checker didn't support `var`

[23:15:44.0000] <devsnek>
heh https://gc.gy/69324339.png

[23:16:12.0000] <Bakkot>
java has lambdas!

[23:16:25.0000] <devsnek>
ya but you have to declare an interface

[23:16:39.0000] <Bakkot>
that type is normally spelled `Predicate<Integer>`

[23:16:57.0000] <Bakkot>
I believe it's built in

[23:17:00.0000] <Bakkot>
shouldn't need to declare it

[23:17:01.0000] <devsnek>
neat

[23:17:18.0000] <Bakkot>
https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html

[23:17:20.0000] <devsnek>
i'll remember that if i ever write java ever again :P

[23:17:37.0000] <Bakkot>
heh


2020-10-03
[00:04:57.0000] <howdoi>
`${Number.prototype}` => '0', but why?

[00:05:15.0000] <ljharb>
howdoi: historically, all the builtin prototypes were exotic, and an instance of themselves

[00:05:32.0000] <ljharb>
howdoi: in ES6, many of them were changed to be ordinary, but some couldn't be for web compat. number, function, regex, date, and a few others probably

[00:07:57.0000] <howdoi>
ljharb: ha, so there are few checks for internal slots instead of the primitive directly, for the same reason?

[00:14:02.0000] <ljharb>
howdoi: not sure what you're asking

[00:19:01.0000] <howdoi>
ljharb: https://tc39.es/ecma262/#sec-properties-of-the-number-prototype-object 2.a

[00:19:28.0000] <devsnek>
howdoi: those are boxed primitives

[00:19:32.0000] <devsnek>
check ToObject()

[00:22:00.0000] <ljharb>
howdoi: right, every `thisNumberValue` either returns the number or unwraps the boxed number, or throws.

[00:23:30.0000] <bendtherules>
I guess the question is - does the spec have a easy way to check instanceOf within its steps? If yes, then why is it (sort of) duck-type checking about Number instances (using type object and [[NumberDatta]] slot) ?

[00:24:13.0000] <bendtherules>
Is it for some particular case? Or just the easiest way to check instanceOf Number?

[00:24:20.0000] <howdoi>
devsnek: nods

[00:25:00.0000] <devsnek>
bendtherules: `thisNumberValue` works no matter what realm

[00:25:16.0000] <devsnek>
instanceof is limited to checks within a realm

[00:25:39.0000] <bendtherules>
makes sense

[00:25:50.0000] <howdoi>
If Type(value) is Object and value has a [[NumberData]] internal slot, then there is a check for value.[[NumberData]]

[00:26:51.0000] <howdoi>
like ljharb said, Assert: Type(n) is Number, throw if not.

[00:30:42.0000] <howdoi>
/me Number {value,type,object} hmm...

[00:33:41.0000] <howdoi>
thanks ljharb && devsnek

[00:34:25.0000] <ljharb>
bendtherules: slots tell you what the thing is. instanceof is checking something else, something that’s often useless.

[00:36:02.0000] <bendtherules>
Ok, so how does spec check if something is a array?

[00:36:29.0000] <devsnek>
IsArray

[00:36:51.0000] <devsnek>
probably the single most cursed operation in the spec lol

[00:37:28.0000] <howdoi>
lol

[01:31:05.0000] <Bakkot>
JSC, SM, V8, and also babel, acorn, esprima all accept `(async () => await 1 ** 1)()`

[01:31:16.0000] <Bakkot>
but that's not actually legal, right?

[01:32:22.0000] <Bakkot>
also engine262

[01:32:37.0000] <Bakkot>
and shift

[01:32:48.0000] <Bakkot>
not xs or chakracore though!

[01:37:40.0000] <devsnek>
Bakkot: did we all forget that await expressions are unary expressions?

[01:37:47.0000] <Bakkot>
apparently!

[01:37:52.0000] <Bakkot>
everyone except typescript

[01:38:05.0000] <Bakkot>
(came up in https://github.com/microsoft/TypeScript/issues/40916 )

[01:38:30.0000] <devsnek>
where even is the early error for **

[01:38:32.0000] <devsnek>
i can't find it

[01:38:38.0000] <Bakkot>
still possible there isn't one

[01:38:44.0000] <Bakkot>
it simply doesn't match the grammar

[01:38:56.0000] <Bakkot>
er, sorry, "still possible" was the start of a different sentece

[01:39:04.0000] <Bakkot>
there is no early error, it simply doesn't match the grammar

[01:39:24.0000] <Bakkot>
and, separately, it's still possible I'm misreading the spec and `await 1 ** 1` is legal

[01:39:28.0000] <devsnek>
hm i have it as an explicit check in parsing a unary expression

[01:39:59.0000] <devsnek>
hmm

[01:40:01.0000] <devsnek>
oh i see

[01:40:07.0000] <devsnek>
very interesting

[01:40:31.0000] <devsnek>
ExponentiationExpression : UnaryExpression

[01:40:34.0000] <devsnek>
we need to put a big note on that

[01:40:51.0000] <devsnek>
i think everyone scans over that assuming everything there is just straight precedence climbing

[01:41:53.0000] <Bakkot>
well, people get the -1**1 bit right

[01:42:03.0000] <Bakkot>
presumably there's coverage though

[01:42:08.0000] <Bakkot>
and also it's well known

[01:43:35.0000] <devsnek>
is there any reason AwaitExpression is separated into its own production

[01:43:44.0000] <devsnek>
could just be `[+Await] await UnaryExpression` couldn't it?

[01:44:15.0000] <devsnek>
hm i guess it makes `contains AwaitExpression` cleaner

[01:44:19.0000] <Bakkot>
yeah, that

[01:46:01.0000] <devsnek>
i can submit a fix to v8 i suppose

[01:46:09.0000] <devsnek>
i hope this isn't web reality now

[01:47:26.0000] <Bakkot>
it might well be

[01:47:40.0000] <Bakkot>
`await x ** 2` is a reasonable thing to write

[01:48:44.0000] <devsnek>
all the keyword ones are reasonable

[01:48:56.0000] <devsnek>
delete/void/typeof/await

[01:49:01.0000] <rkirsling>
urgh, I hate that that is how it's spec'ed :(

[01:49:19.0000] <Bakkot>
those are not reasonable

[01:49:37.0000] <Bakkot>
you would not want to exponentiate the result of delete or void or typeoof

[01:49:52.0000] <devsnek>
as reasonable as `await x ** 2` anyway

[01:50:49.0000] <Bakkot>
`await x` can reasonably result in a number, which is a thing you might want to square

[01:51:00.0000] <Bakkot>
it really is different from the others here

[01:51:59.0000] <devsnek>
but no one would read it as `(await x) ** 2`

[01:52:48.0000] <Bakkot>
ehhh, depends on how familiar with the rules you are

[01:52:59.0000] <devsnek>
i mean that argument flies for `-1 ** 1`

[01:53:28.0000] <Bakkot>
well, right, the point of the `-1 ** 1` thing is that both interpretations were plausible

[01:54:00.0000] <Bakkot>
my claim is not that the `(await x) ** 2` interpretation is obviously right, just that it's plausible enough that people might have written it in real code

[01:54:15.0000] <devsnek>
ah i see

[02:05:07.0000] <rkirsling>
`await x ** 2` seems way more harmful than `-1 ** 1` to my eyes which did not expect to encounter this

[02:05:22.0000] <Bakkot>
filed https://github.com/tc39/ecma262/issues/2197

[02:05:44.0000] <rkirsling>
/me hopes there is web reality

[02:05:46.0000] <Bakkot>
rkirsling: fwiw `await a + b` is definitely legal

[02:05:56.0000] <rkirsling>
oh

[02:06:01.0000] <rkirsling>
hm

[02:06:04.0000] <rkirsling>
fair enough

[02:06:21.0000] <rkirsling>
and everybody does the right thing, I assume?

[02:06:32.0000] <Bakkot>
haven't checked

[02:06:34.0000] <Bakkot>
presumably

[02:06:53.0000] <rkirsling>
if so then I rescind my whining

[02:07:32.0000] <Bakkot>
this is one of those places prettier will insert parentheses for you

[02:07:58.0000] <Bakkot>
(it does for `await a ** b` as well, funnily enough)

[02:09:37.0000] <rkirsling>
yeah with a linter there's nothing to worry about it

[02:09:44.0000] <rkirsling>
er formatter

[09:20:45.0000] <Bakkot>
https://www.python.org/dev/peps/pep-0638/

[09:21:10.0000] <devsnek>
bold of a PEP to contain the phrase "compile-time"

[09:22:03.0000] <devsnek>
i could live with js never having macros

[09:22:08.0000] <devsnek>
its dynamic enough to not need them

[09:23:01.0000] <Bakkot>
js has macros; they'

[09:23:06.0000] <Bakkot>
re called "babel"

[09:24:06.0000] <devsnek>
lol

[09:24:25.0000] <devsnek>
mfw engine262 uses babel for macros

[09:33:22.0000] <devsnek>
> Currently, all AST nodes are allocated using an arena allocator. Changing to use the standard allocator might slow compilation down a little, but has advantages in terms of maintenance, as much code can be deleted.

[09:33:37.0000] <devsnek>
oh to be a cpython dev


2020-10-04
[13:21:07.0000] <devsnek>
https://twitter.com/jennschiffer/status/1312825920454041608

[13:21:19.0000] <devsnek>
people want a larger standard library and types

[13:21:44.0000] <devsnek>
and one guy wants more consistency between pass by value and pass by reference

[13:39:23.0000] <ljharb>
devsnek: just replied to that last guy, JS is only and always pass by value :-)

[13:39:36.0000] <devsnek>
lol

[14:24:59.0000] <Bakkot>
those terms are not super useful

[14:26:42.0000] <ljharb>
that's also true

[14:27:25.0000] <Bakkot>
not quite as bad a "strongly typed" and "weakly typed", but kinda in the neighborhood

[14:35:44.0000] <devsnek>
pass by handle


2020-10-05
[20:12:28.0000] <devsnek>
anyone know how to hit step 8.c of AsyncGeneratorYield?

[20:12:41.0000] <devsnek>
i thought it would be like `it.return(Promise.reject())` but that doesn't seem to do it

[21:46:06.0000] <ljharb>
devsnek: make a Get of `constructor` on an awaited promise throw?

[21:46:20.0000] <devsnek>
huh

[21:46:58.0000] <devsnek>
like `return({ get constructor() { throw new Error() } })`?

[21:48:24.0000] <ljharb>
yeah maybe? not sure

[21:48:34.0000] <ljharb>
the only operation that has a ? in AsyncGeneratorYield is PromiseResolve

[21:49:07.0000] <ljharb>
which has a ? on `Get(x, "constructor")` and also on constructing the constructor

[08:10:20.0000] <shu>
i remain surprised that people are just _so_ opinionated about programming languages

[08:10:35.0000] <shu>
(re: jenn schiffer's tweet)

[08:10:46.0000] <devsnek>
shu: is that sarcasm

[08:11:01.0000] <shu>
no

[08:11:29.0000] <devsnek>
people in tc39 are pretty opinionated

[08:11:48.0000] <shu>
out of things in computing to devote opinion budget to, i wouldn't put PLs so high personally

[08:45:47.0000] <gibson042>
interesting thoughts at https://twitter.com/HarryB/status/1312860441639444480

[08:47:45.0000] <devsnek>
i'm down with everything being expressions

[08:47:47.0000] <devsnek>
aside from declarations

[08:50:46.0000] <shu>
i'm not sure how versioning solves the problem of catering to a common denominator

[09:05:24.0000] <annevk>
versioning is like regexps, now you have n problems

[09:17:21.0000] <devsnek>
O(2^n) problems

[09:18:16.0000] <annevk>
yeah, after I hit enter I was like, it's definitely more than n

[09:44:19.0000] <gibson042>
that's why I asked for clarification... it may be that e.g. 80% of versioning pain can be addressed with simple solutions like straightforward capability detection and/or conditional loading

[13:06:17.0000] <TabAtkins>
I'm p sure the "versioning" thing is "I want to serve script X to this browser, but script Y to other browser"

[13:21:24.0000] <ljharb>
it was actually super awesome when we had IE conditional comments, but the landscape is way more complex than that now

[13:58:07.0000] <TabAtkins>
Sigh, yeah, those were great.

[15:19:38.0000] <rkirsling>
can somebody explain how this test corresponds to the spec? https://test262.report/browse/built-ins/TypedArrayConstructors/from/set-value-abrupt-completion.js

[15:19:50.0000] <rkirsling>
because 6.a @ https://tc39.es/ecma262/#sec-%typedarray%.from calls IterableToList

[15:20:01.0000] <rkirsling>
and then we use the produced list

[15:21:54.0000] <rkirsling>
so that should imply that even if you get an element that throws from `valueOf`, you've still finished iteration of the source

[15:21:55.0000] <rkirsling>
(i.e. it's specifically `assert.sameValue(lastValue, obj, "interrupted source iteration");` that isn't making sense to me)

[15:25:34.0000] <ljharb>
rkirsling: hm, the only thing i remember around that is https://gist.github.com/ljharb/896ad592accdbd783d5ec1d44e978b76 that i presented in july 2019

[15:25:48.0000] <ljharb>
i didn't look at interrupted iteration at all

[15:28:43.0000] <rkirsling>
hmm, there isn't a corresponding test for Array.from but then the Array constructor doesn't require a size param

[15:28:55.0000] <devsnek>
are there any blog posts about how jsc regex is so fast

[15:32:48.0000] <rkirsling>
there is a section of one, in here: https://webkit.org/blog/8685/introducing-the-jetstream-2-benchmark-suite/

[15:33:44.0000] <rkirsling>
wonder if I should make a GH issue for my question

[15:40:10.0000] <rkirsling>
oh wait I get it

[15:41:27.0000] <rkirsling>
it's not a question of last-iterated, it's a question of last-mapped

[16:10:51.0000] <rkirsling>
ljharb: this was what threw me, in case you were curious: https://bugs.webkit.org/show_bug.cgi?id=217349


2020-10-06
[18:23:06.0000] <jmdyck>
ljharb: I can squash 2176 overloaded-functions when/if the time comes.


2020-10-07
[18:26:27.0000] <ingen0s>
Greetings

[09:37:04.0000] <devsnek>
who is in charge of landing test262 changes?

[09:37:16.0000] <devsnek>
rick?

[10:09:06.0000] <jmdyck>
he's done all the merges since Sept 9, so it seems like a good bet.

[12:19:18.0000] <ljharb>
oof https://github.com/tc39/proposal-item-method/issues/31

[12:33:10.0000] <rkirsling>
oof indeed

[12:35:48.0000] <Bakkot>
obvious solution: stop having `String.prototype.item`

[12:35:52.0000] <Bakkot>
it is bad anyway

[12:35:54.0000] <Bakkot>
:D

[12:37:40.0000] <ljharb>
there's the other one anyways that might block Array.prototype.item

[12:38:19.0000] <Bakkot>
yeah I am more sad about the actually good one being web-incompat

[12:38:23.0000] <rkirsling>
I mean thankfully the two are separate but

[12:38:35.0000] <rkirsling>
I really hope we can resolve the Array one

[12:39:27.0000] <rkirsling>
also GH's reaction set is not "right-sized". I don't want to react with 😕 I want to react with :sob

[12:39:31.0000] <rkirsling>
😭 even


2020-10-08
[19:45:58.0000] <shu>
yeah i am swayed by that to remove String#item

[19:46:15.0000] <shu>
i have also reached out to Magic 360 again since they have yet to respond

[19:47:28.0000] <shu>
it is my wish that when i do bring this up again

[19:47:43.0000] <shu>
that we refrain from talking more about code units

[19:47:54.0000] <shu>
and let the web compat argument stand alone and leave it at that

[19:49:07.0000] <rkirsling>
couldn't agree more

[20:03:07.0000] <Bakkot>
I will avoid bringing it up

[20:18:01.0000] <Bakkot>
some thoughts about growing C++'s stdlib, many of which apply to us as well: https://cor3ntin.github.io/posts/std/

[22:38:53.0000] <ljharb>
shu: if magic360 and their customers can't be updated, what happens?

[22:39:44.0000] <rkirsling>
weeping and gnashing of teeth

[22:40:13.0000] <ljharb>
like, i assume that the original motivation is gone, but that there's still a value in having the semantics somehow

[22:41:36.0000] <rkirsling>
it's hard to say; the champions said they would abandon the proposal if `item` were unviable

[07:43:09.0000] <shu>
ljharb: what do you mean the original motivation is gone?

[07:46:50.0000] <rwaldron->
shu good morning! Do you have a moment to weigh in on this: https://github.com/tc39/test262/pull/2833#discussion_r500652041 ?

[07:47:48.0000] <shu>
rwaldron-: sure, ross's understanding there matches mine and he did confirm with me yesterday on irc

[07:49:00.0000] <rwaldron->
shu great, then I believe these tests are ready, in support of the spec change.

[07:50:34.0000] <shu>
great, thank you

[07:52:24.0000] <rwaldron->
Oh, I'm sorry: I didn't even see that rkirsling had edited his last comment.

[09:18:34.0000] <shu>
gotta say the YUI thing doesn't look great

[09:19:32.0000] <ljharb>
shu: i meant that wasn’t the motivation to make everything match observablearray?

[09:19:52.0000] <ljharb>
ie, item or nothing?

[09:21:10.0000] <jackworks>
So what's the next step? Give up the item proposal?

[09:21:14.0000] <shu>
ljharb: that was the motivation to make it named `item`

[09:21:25.0000] <shu>
ljharb: the semantics already doesn't match IDL's current semantics

[09:21:28.0000] <ljharb>
shu: ah ok cool, so it’s still a thing with a different name?

[09:21:33.0000] <ljharb>
if only we had a language-level brand checking mechanism the web could adopt, people would stop ducktyping builtins :-/

[09:22:32.0000] <shu>
that'd only work for newer things

[09:23:10.0000] <Bakkot>
also people would not stop ducktying builtins

[09:23:10.0000] <jackworks>
I don't think we need "item" it cannot resolve the DOM observable array.

[09:23:11.0000] <ljharb>
newer code, sure, but older code might migrate over time

[09:23:13.0000] <shu>
jackworks: good question. i'm not sure right now. Magic 360 got back to me that they did update and will encourage their users to update

[09:23:23.0000] <Bakkot>
there's plenty of other ways to brand check

[09:23:28.0000] <jackworks>
I mean "If it cannot"

[09:23:34.0000] <shu>
ljharb: if "older code might migrate over time" was our hope, we'd operate a lot differently

[09:23:35.0000] <ljharb>
Bakkot: not elements or node lists

[09:23:45.0000] <shu>
there is, you can do `.constructor.name` at leat

[09:23:46.0000] <shu>
least

[09:23:49.0000] <ljharb>
shu: yeah fair. Encouraging news from magic360

[09:24:00.0000] <ljharb>
that’s pretty unreliable

[09:24:07.0000] <shu>
how so?

[09:24:10.0000] <Bakkot>
no less reliable than absence of `.item`

[09:24:10.0000] <ljharb>
lots of frameworks have an Element and similar

[09:24:13.0000] <shu>
who's messing with constructors?

[09:24:22.0000] <ljharb>
Bakkot agreed there

[09:24:30.0000] <jackworks>
But how to fix the yui breaks

[09:24:45.0000] <Bakkot>
no one is looking at `.item` because they need specifically a very reliable brand check mechanism

[09:24:49.0000] <ljharb>
shu: being forgeable is a problem even if nobody’s breaking the builtins

[09:25:05.0000] <Bakkot>
forgeability has nothing at all to do with this issue

[09:25:07.0000] <ljharb>
Bakkot: i agree they don’t usually need the robustness that offers

[09:25:17.0000] <Bakkot>
because these authors are clearly not concerned about forgeability

[09:25:20.0000] <ljharb>
but they were surely looking for a way to ask “is this an element”

[09:25:42.0000] <ljharb>
providing any form of that, explicitly, encourages its use instead of less reliable or explicit means

[09:26:04.0000] <Bakkot>
`instanceof Element` is the built-in, obvious way of asking that question

[09:26:49.0000] <ljharb>
fair, but instanceof doesn’t work cross-realm, and people do run into that with iframes occasionally

[09:27:02.0000] <jackworks>
Do they check this with "if 'item' in x"? Is it possible to let it return false but existing?

[09:27:03.0000] <Bakkot>
I would be very surprised to learn that was the concern here

[09:27:13.0000] <shu>
jackworks: YUI checks this with '.item'

[09:27:19.0000] <Bakkot>
jackworks they check with truthiness of `.item`

[09:27:30.0000] <jackworks>
Oops

[09:28:05.0000] <Bakkot>
ljharb if you know enough to be concerned about the cross-frame issue, you likely know enough to use `.constructor.name`

[09:28:16.0000] <jackworks>
🤣🤣🤣do you want to have more IsHTMLDDA

[09:29:27.0000] <ljharb>
Bakkot: i agree, I’m not claiming that’s the issue here. I’m saying that something builtin that was cross realm and unforgeable would end up being the natural choice for everyone even if folks didn’t need all it provides, just like happened with Array.isArray.

[09:30:00.0000] <ljharb>
like, it objectively already happened, the bulk of the community doesn’t use instanceof Array

[09:34:43.0000] <Bakkot>
in new code, sure; old code hasn't changed though

[09:38:39.0000] <shu>
right now i don't think this warrants the [[IsHTMLDDA] hammer

[09:39:08.0000] <jackworks>
🤣

[09:39:21.0000] <ljharb>
lol hopefully nothing ever warrants that

[09:39:55.0000] <jackworks>
Yeah

[09:40:48.0000] <jackworks>
If so, many mambrane library will have one more CVE to fix

[09:40:50.0000] <Bakkot>
I feel like flickr is disproportionately likely to be the site that breaks when we ship new stuff

[09:40:59.0000] <shu>
indeed, it's come up many times before

[09:41:00.0000] <Bakkot>
wonder if it's just yui

[09:41:11.0000] <Bakkot>
or if there's something else going on there

[09:41:19.0000] <shu>
i think it's just that it's 10 years old?

[09:41:47.0000] <shu>
and duck typing on `item` is surprisingly robust, rather than typing `instanceof` for all array-likes, of which there are many

[09:43:24.0000] <shu>
my gut reaction here is relative indexing still seems useful, but it's no longer urgent and doesn't block any web stuff we want to to do, so we can bikeshed the name and String inclusion at our leisure

[09:44:06.0000] <shu>
as for `ObservableArray` itself, it probably needs to do the gross thing of magically materializing `item` as an own-property method

[09:44:31.0000] <jackworks>
Oh it's support negative index as index from end? If so it's somewhat useful for me

[09:44:37.0000] <shu>
i suppose it can also insert a prototype just below Array.prototype that gives you .item or something, but not sure if that works or has other problems

[09:45:10.0000] <shu>
jackworks: yes, there were two motivations: relative indexing and to aid `ObservableArray` as a replacement for DOM array-likes

[09:45:32.0000] <jackworks>
🤔👍

[09:45:34.0000] <shu>
jackworks: the second requirement was only about why it's important to be named `item`

[10:02:41.0000] <ljharb>
shu: another prototype in the chain seems simplest

[10:03:08.0000] <shu>
ljharb: yeah, i'll leave that for the folks who want to use this to decide and hash out

[10:03:36.0000] <shu>
the desire was to have ObservableArrays be API-compat with Arrays

[10:04:26.0000] <ljharb>
right

[10:04:36.0000] <shu>
i think if it has to add extra stuff so they're not just like Arrays API-wise, maybe we'll just scuttle the plan to unify legacy types with a new type that emulates legacy behavior

[10:05:21.0000] <shu>
and leave the new ObservableArray type for new APIs only that does not have API compat with older types (i.e. doesn't have .item())

[10:06:11.0000] <shu>
but i don't really have a horse in the race here

[11:56:23.0000] <rkirsling>
nooooooo not flickr

[11:56:31.0000] <rkirsling>
</slowpoke>

[12:05:41.0000] <shu>
wait, Flickr is no longer owned by verizon

[12:05:48.0000] <shu>
it was apparently bought by SmugMug in 2018

[12:05:59.0000] <shu>
i wonder how SmugMug engineering feels about flickr...

[12:46:11.0000] <shu>
what names do people like instead of `item`?

[12:46:52.0000] <shu>
`atem`

[12:50:00.0000] <ljharb>
then we also have to add `gotem` to Sets and Maps

[12:51:00.0000] <ljharb>
shu: tbh `.get` would be good if it didn't collide with collections; `.at` works (there's already a stage 0 String.prototype.at proposal, in fact), `.index()` would work but would conflict with `.index` on match objects

[12:52:52.0000] <shu>
yeah i was thinking `at`

[12:53:05.0000] <shu>
index sounds weird, since we're not getting an index

[12:53:11.0000] <shu>
get is a possibility, i wonder if that conflicts with anything

[12:53:20.0000] <shu>
outside of the other collections

[12:53:40.0000] <ljharb>
based on our previous experiences i'm sure somebody's doing code like `if (obj.get) { /* is a Map or a Set */ }`

[12:55:19.0000] <rkirsling>
`gottem` lol I love it

[12:55:36.0000] <shu>
accepts *only* negative indices

[12:55:45.0000] <rkirsling>
well like that's the thing

[12:55:47.0000] <ljharb>
`.negatem`

[12:56:05.0000] <rkirsling>
if that is the feature, instead of the layering matter

[12:56:07.0000] <drousso>
`.gimmie`?

[12:56:11.0000] <ljharb>
or wait, `.item` for positives and `.meti` for negatives

[12:56:15.0000] <rkirsling>
then honestly we could just have `.last(n)`

[12:56:31.0000] <rkirsling>
or whatever

[12:56:32.0000] <shu>
rkirsling: no, i think it's still valuable to accept both negative and positive indices in a single method

[12:56:41.0000] <ljharb>
rkirsling: that'd have to be an array, i think

[12:56:44.0000] <rkirsling>
alright

[12:56:45.0000] <shu>
else you're just going to write wrappers that do the dispatch yourself

[12:56:46.0000] <ljharb>
rkirsling: `.last(2)` implies you get both

[12:57:25.0000] <rkirsling>
ljharb: uh yeah I see your point but that's a naming problem on my part

[12:57:39.0000] <rkirsling>
I guess if we want the same behavior then `at` sounds good

[12:57:49.0000] <rkirsling>
but I fear that too will have compat issues

[12:58:25.0000] <shu>
and also, while we can no longer align JS Arrays with legacy DOM collections, whatever we design here will still be part of *new* DOM collections because ObservableArray still remains the desirable thing to use for new web API proposals

[12:58:54.0000] <rkirsling>
fair enough

[13:03:49.0000] <Bakkot>
`.at` sgtm

[14:26:54.0000] <rwaldron->
+1 to ".at"

[14:32:03.0000] <devsnek>
we could even use the @ symbol to prevent collisions

[14:32:35.0000] <devsnek>
rwaldron-: is there anything that the __proto__ tests still need?

[14:44:01.0000] <leobalter>
`.pickItemFromIndex(n)`

[14:44:23.0000] <leobalter>
But .at is almost as good

[14:58:21.0000] <rwaldron->
devsnek nothing now!

[14:58:36.0000] <rwaldron->
I think I was originally waiting for "needs consensus"

[15:05:08.0000] <rwaldron->
All set.

[15:23:46.0000] <devsnek>
rwaldron-: btw https://github.com/tc39/test262/pull/2796#issuecomment-700775008

[15:24:26.0000] <devsnek>
i think the fix is just changing it to be `assert(!f.hasOwnProperty('arguments'))` and `assert(!f.hasOwnProperty('caller'))`?

[16:37:33.0000] <rwaldron->
devsnek got it


2020-10-09
[18:53:41.0000] <jackworks>
Array.prototype.ください()

[18:53:45.0000] <jackworks>
No collision at all

[08:10:56.0000] <bradleymeck>
haha, yessss


2020-10-10
[08:04:29.0000] <DerekNonGeneric>
does anyone know if there is something like a proposal boilerplate? Perhaps a repo or a single document to use as a template would be great

[08:42:26.0000] <DerekNonGeneric>
nevermind, I seem to have found it @ https://github.com/tc39/template-for-proposals


2020-10-13
[20:26:26.0000] <Bakkot>
jmdyck: if you get a moment, could you run ecmaspeak on 2007 one last time?

[20:26:41.0000] <Bakkot>
I just finished rebasing it and addressing review comments, and am hoping to land it on Wednesday

[20:28:28.0000] <jmdyck>
ok

[20:40:59.0000] <jmdyck>
(have to rebase the 2007-specific ecmaspeak branch to master)

[20:47:15.0000] <jmdyck>
ok, got some parse errors.

[20:48:22.0000] <jmdyck>
"Let _S_ be the String value whose code units are, in order, the elements in CodePointToUTF16CodeUnits(_V_)."

[20:48:41.0000] <jmdyck>
error on "in order"

[20:49:54.0000] <jmdyck>
(Bakkot)

[20:51:02.0000] <jmdyck>
hiccup in merge of 2142?

[20:54:51.0000] <Bakkot>
ah, yup, rebase ssue

[20:56:31.0000] <Bakkot>
pushed

[20:57:17.0000] <jmdyck>
Rest of the parse errors might be just legitimate changes in wording for which I need to change grammar

[20:57:35.0000] <jmdyck>
will take me a ew minutes to work through

[20:58:22.0000] <jmdyck>
s/ew/few/

[21:02:28.0000] <jmdyck>
no, here's one: "such that j &lt; _searchLen_" s/j/_j_/

[21:02:51.0000] <jmdyck>
two hits for that

[21:04:30.0000] <Bakkot>
pushed

[21:13:40.0000] <jmdyck>
since you replaced wording like "is greater than or equal to" with symbols, you might be interested in removing 2 remaining:

[21:14:01.0000] <jmdyck>
"If the length of _S_ is at least 2"

[21:15:09.0000] <jmdyck>
"integral Number value that is not greater than _n_" (well, subordinate clause might be tough)

[21:15:28.0000] <jmdyck>
"such that _k_ + _searchLen_ is not greater than _len_"

[21:17:50.0000] <Bakkot>
first two are nicer as prose, I think, since one side is prose rather than a math-y expression

[21:18:02.0000] <Bakkot>
pushed the third one (as `&le;`)

[21:18:11.0000] <jmdyck>
k

[21:25:57.0000] <jmdyck>
Bakkot: ok that's it for syntax stuff. That leaves the type analysis, but it's getting late here.

[21:26:04.0000] <Bakkot>
thanks!

[21:26:57.0000] <Bakkot>
won't be ready to merge until Wednesday afternoon at the earliest anyway

[21:27:11.0000] <Bakkot>
(that is, ~42 hours from now)

[07:29:50.0000] <jmdyck>
Bakkot: in %TypedArray%.prototype.set( _typedArray_ [ , _offset_ ] ), in "If _target_.[[ContentType]] is not equal to _typedArray_.[[ContentType]]", 2007 changes "is not equal to" to "&ne;". But I'm thinking "&ne;" should be reserved for comparing numeric values, whereas this is comparing two types. Maybe change to "is not the same as" (for which there's some precedent).

[07:30:38.0000] <jmdyck>
Similarly in `_TypedArray_ ( _typedArray_ )`

[07:31:03.0000] <jmdyck>
and `TypedArraySpeciesCreate`

[07:38:58.0000] <jmdyck>
[actually, not two types, but two spec values that represent/refer to types]

[08:03:33.0000] <jmdyck>
Also with &ne;, is it okay for one of the operands to be NaN? If not, here's a couple places:

[08:04:51.0000] <jmdyck>
ArraySetLength: `_newLen_ &ne; _numberLen_` (_numberLen_ might be NaN)

[08:06:26.0000] <jmdyck>
Array(_len_): `_intLen_ &ne; _len_` (_len_ might be NaN)

[08:19:55.0000] <jmdyck>
...

[08:23:14.0000] <jmdyck>
Function.prototype.bind: if _targetLenAsInt_ can be infinite, then `_targetLenAsInt_ - _argCount_` is dubious

[08:32:35.0000] <jmdyck>
FlattenIntoArray: _depth_ can be +infin, yet `_depth_ - 1`

[08:44:07.0000] <jmdyck>
Bakkot: given https://github.com/tc39/ecma262/issues/2178#issuecomment-701676969, do you want to be alerted to Set-on-parameter or Set-that-changes-type?

[08:46:29.0000] <jmdyck>
(or defer that to a later PR?)

[09:44:01.0000] <jmdyck>
In MakeDate, at step 2, we know that _day_ is finite and _time_ is finite (and msPerDay is certainly finite), so step 3 `If _tv_ is not finite` is to catch the possibility that _day_ and/or _time_ is almost-infinity, so the result of the Number-arithmetic is +/- infinity?

[10:00:44.0000] <jmdyck>
Should the preamble for Day specify *finite* time value? Otherwise you could be dividing NaN by msPerDay.

[10:01:36.0000] <jmdyck>
and similarly for other ops. Or is that a different PR?

[10:39:12.0000] <Bakkot>
jmdyck > I'm thinking "&ne;" should be reserved for comparing numeric values

[10:39:39.0000] <Bakkot>
I'm fine with using it for arbitrary values, but for types (or values which represent types) "is not the same as" probably reads better; will change those

[10:39:47.0000] <Bakkot>
> Also with &ne;, is it okay for one of the operands to be NaN?

[10:43:42.0000] <Bakkot>
hmm. I think it's OK because this is mathematical equality, but maybe it would be better to use prose to avoid the ambiguity. I'll run it by the other editors

[10:43:50.0000] <Bakkot>
> Should the preamble for Day specify *finite* time value? Otherwise you could be dividing NaN by msPerDay

[10:45:05.0000] <Bakkot>
that's another PR; some of those changes imply normative changes to setHours (etc), and I added the topic too late at the last meeting to get consensus.

[10:45:19.0000] <jmdyck>
(not just a matter of changing the preamble, but also ensuring that calls respect the finiteness)

[10:45:24.0000] <Bakkot>
right

[10:45:39.0000] <Bakkot>
some of the calls don't, and the decision about how to guard them is normative

[10:45:45.0000] <Bakkot>
and that's the bit I didn't get consensus for

[10:45:50.0000] <jmdyck>
k

[10:45:57.0000] <Bakkot>
so we're going to leave it incoherent for now

[10:50:56.0000] <Bakkot>
will change `=` and `&ne;` to "is the same value as" and "is not the same value as" when one operand might be NaN

[10:51:15.0000] <Bakkot>
jmdyck is the above list of places that happens complete? if not, do you have a list of such places on hand?

[11:10:24.0000] <jmdyck>
ArraySetLength and Array(_len_) are the only valid cases it currently finds.

[11:10:48.0000] <jmdyck>
(It also finds some false positives, because it's not that smart.)

[11:11:50.0000] <Bakkot>
if the false positives are places which are comparing Numbers but they're definitely not NaN, I'd take those too

[11:12:06.0000] <Bakkot>
probably better to change all of them, rather than requiring the reader to understand the NaN distinction

[11:12:51.0000] <jmdyck>
change all places where comparing Numbers?

[11:14:09.0000] <Bakkot>
comparing using `=` or `&ne;`, yes

[11:15:22.0000] <jmdyck>
ah, hm.

[11:16:25.0000] <Bakkot>
doesn't matter much, so don't bother if it's a bunch of work; we'll sort it out eventually

[11:19:20.0000] <jmdyck>
Looks like those were the only two cases of `Number &ne; Number` or `Number = Number`

[11:20:12.0000] <jmdyck>
I wouldn't have guessed there'd be so few, so I maybe don't trust the code.

[11:22:07.0000] <jmdyck>
(The false positives for comparison-involving-NaN were using &lt;)

[11:24:55.0000] <Bakkot>
it's plausible to me; we try to keep comparisons in the realm of reals where practical

[11:25:41.0000] <Bakkot>
pushed

[11:25:47.0000] <Bakkot>
two commits; other one fixing the finiteness checks

[11:27:27.0000] <jmdyck>
(yay, I made 2 of the false positives go away)

[11:40:08.0000] <jmdyck>
There's ~40 comparisons between Numbers that don't use = or &ne;.

[11:41:43.0000] <Bakkot>
because they're `>` or `<` or `≥` or `≤` instead?

[11:43:20.0000] <Bakkot>
also, re: `[[ContentType]]`, since they're spec enums I'm content to use `=` rather than "same value"

[11:46:06.0000] <jmdyck>
got some syntax errors, stand by.

[11:46:35.0000] <jmdyck>
(yes re other comparators)

[11:49:12.0000] <jmdyck>
ah, you're saying "not the same value as", whereas existing syntax is "not the same as"

[11:50:52.0000] <Bakkot>
hmmmm

[11:51:09.0000] <Bakkot>
I think I like "same as" for comparing types or environments but "same value as" for comparing numbers

[11:51:15.0000] <Bakkot>
which I think is what it is

[11:51:29.0000] <jmdyck>
could be.

[11:52:27.0000] <Bakkot>
ok, managed to get stamps from the other editors a day early

[11:52:31.0000] <Bakkot>
gonna land it

[11:52:41.0000] <jmdyck>
Function.prototype.bind has "Else, if", but we don't put a comma there

[11:52:47.0000] <Bakkot>
oh whoops, thanks

[11:53:09.0000] <Bakkot>
could've sworn I linted for that

[11:53:10.0000] <Bakkot>
guess not

[11:53:22.0000] <jmdyck>
Let me see if anything else comes up.

[11:54:22.0000] <Bakkot>
kk

[11:55:45.0000] <jmdyck>
(syntax passes)

[11:58:43.0000] <Bakkot>
sweet

[12:00:53.0000] <jmdyck>
ok, so the "comparison involving NaN" are gone, and also "Number comparisons involving = or &ne;"

[12:03:34.0000] <jmdyck>
also the arithmetic-on-infinity in bind and FlattenIntoArray

[12:06:11.0000] <jmdyck>
so looks good

[12:07:35.0000] <Bakkot>
"so"?

[12:07:47.0000] <jmdyck>
so, it looks good.

[12:08:00.0000] <Bakkot>
ah, great

[12:08:04.0000] <Bakkot>
gonna land it!

[12:08:10.0000] <jmdyck>
whee

[12:08:18.0000] <Bakkot>
many many thanks for your checks

[12:08:34.0000] <jmdyck>
you're welcome. glad to be of service.

[12:29:30.0000] <Bakkot>
landed

[12:29:32.0000] <Bakkot>
phew

[14:22:58.0000] <jmdyck>
Bakkot: was it decided that losing the id 'sec-isnonnegativeinteger' was acceptable?

[14:24:55.0000] <Bakkot>
yup

[14:25:01.0000] <jmdyck>
ok

[14:27:19.0000] <Bakkot>
jmdyck: btw https://github.com/tc39/ecma262/pull/2176 now (of course) needs a rebase; I am happy to take care of it if you'd like. I think it can land as soon as that's done.

[14:28:00.0000] <Bakkot>
feel free to squash it down to a single commit before rebasing if that's easier; the separate commits were helpful for review but it's now reviewed

[14:28:12.0000] <jmdyck>
right, will do.

[14:31:16.0000] <jmdyck>
y


2020-10-14
[09:07:48.0000] <shu>
can someone check my understanding of https://github.com/tc39/test262/blob/main/test/language/statements/class/elements/arrow-body-indirect-eval-err-contains-arguments.js? this test seems wrong

[09:08:37.0000] <shu>
since https://tc39.es/proposal-class-fields/#sec-performeval-rules-in-initializer explicitly calls out direct eval

[09:11:01.0000] <Bakkot>
shu agreed, also the comment on the file itself says that

[09:11:26.0000] <shu>
yeah

[09:11:34.0000] <Bakkot>
it's a procedurally generated test so probably the "direct" part was just missed

[09:11:50.0000] <Bakkot>
although, wait, hang on

[09:12:11.0000] <Bakkot>
it's a reference error anyway because `arguments` is not defined in the global scope

[09:12:21.0000] <Bakkot>
or

[09:12:26.0000] <Bakkot>
yeah

[09:12:54.0000] <Bakkot>
you should get a reference error because of `arguments` being unbound, I think

[09:13:38.0000] <shu>
ah hm, it's just the comments then? let's see

[09:14:52.0000] <Bakkot>
yeah I think it is accidentally right

[09:15:17.0000] <shu>
yeah that seems right, it's testing class's strictness with indirect eval

[09:16:56.0000] <shu>
thanks

[09:17:32.0000] <Bakkot>
no

[09:17:36.0000] <Bakkot>
strictness isn't relevant

[09:17:55.0000] <Bakkot>
a reference (not assignment) too an unbound variable is always a referenceerror

[09:18:39.0000] <Bakkot>
and strictness does not propagate to indirect eval

[09:18:58.0000] <shu>
yes, amazingly everything i said was wrong

[09:20:12.0000] <rwaldron->
shu or Bakkot is there something missing from that test?

[09:20:46.0000] <shu>
rwaldron-: it's not testing what the comment says it's testing

[09:21:11.0000] <shu>
the comment says it's testing an early error special case for "arguments" inside direct eval, while the test has an indirect eval

[09:21:35.0000] <rwaldron->
AH! Let me go fix rhat

[09:21:41.0000] <shu>
it ends up testing access to an unbound reference at the global scope to "arguments"

[09:21:53.0000] <rwaldron->
The generated file name and test body is all correct,

[09:22:00.0000] <shu>
(context is this was failing on V8, but that's because the V8 shell by defaults includes "arguments" on the global, and i need to turn that off for the test262 runner...)

[09:22:18.0000] <shu>
rwaldron-: well it's all incidentally correct, but it's very misleading

[09:22:31.0000] <shu>
it's not testing anything to do with field initializers or eval

[09:23:41.0000] <rwaldron->
shu, yes I recall. In Andre's original tests, V8 was failing for reasons that I determined were erroneous: it's not a "forbidden extension" to have an arguments object in the global scope.

[09:24:09.0000] <rwaldron->
I will revisit this today and get info: ... sorted out.

[09:24:22.0000] <shu>
yeah, but it's also fine for test262 to say it requires that its runner environment doesn't have "arguments"

[09:24:49.0000] <rwaldron->
shu I'd like for that to be not the case ^^

[09:25:34.0000] <shu>
rwaldron-: ah, okay, also fine with me

[09:25:41.0000] <shu>
rwaldron-: do you plan on removing these tests then?

[09:26:13.0000] <rwaldron->
shu likely for now, yes

[09:26:30.0000] <shu>
sgtm

[09:26:58.0000] <rwaldron->
shu I'm trying to recall if I gave you a "heads up notice" for these failures.

[09:26:59.0000] <rwaldron->
Not sure if you see those

[09:27:04.0000] <rwaldron->
I'm certain that I did.

[09:27:20.0000] <shu>
i do see them, yes, though there's a variable lag on when i act on them :)

[09:27:30.0000] <rwaldron->
Ah, ok. No problem.

[09:27:52.0000] <shu>
today is that go-through-failures-since-last-update day

[09:31:59.0000] <Bakkot>
an easy fix is too define `arguments` in the test and then assert that this reads from that variable

[09:32:01.0000] <rwaldron->
Oh, great! I'm here all for that.

[09:32:04.0000] <rwaldron->
shu ^

[09:32:58.0000] <rwaldron->
Bakkot ...read my mind.

[09:32:58.0000] <rwaldron->
;)

[09:33:36.0000] <shu>
wfm, but removal still seems easier

[09:34:18.0000] <shu>
while that's an easy fix for the test part of it, it's still misleading given its file name, where it is in the test directory hierarchy

[10:44:58.0000] <shu>
Bakkot: rwaldron-: devsnek: i recall you discussing this earlier. i didn't find a PR to change the spec so i opened one: https://github.com/tc39/ecma262/pull/2205

[10:45:49.0000] <rwaldron->
shu awww man. I think jugglinmike wanted to work on that.

[10:46:02.0000] <rwaldron->
No worries, I'll have him take a look at it

[10:47:53.0000] <shu>
oh even better, i'm happy to let him take the lead there

[10:49:10.0000] <rwaldron->
I'm not sure when he planned on getting to it, but I'll have him take a look at what you've written so far and see if he has anything more to add to the conversation.

[11:05:34.0000] <rwaldron->
shu I was mistaken, that's not the spec bug Mike wanted to work on

[11:09:53.0000] <shu>
ah ok

[11:13:12.0000] <rwaldron->
shu I've reworked the indirect eval test cases so that they: a) have valid info/description, b) test something that doesn't penalize V8 for having a valid extension (the arguments object)

[11:14:03.0000] <shu>
rwaldron-: excellent, thanks for the quick action here

[11:14:08.0000] <rwaldron->
np

[11:34:12.0000] <rwaldron->
What's the status of "Item Method"? I wrote tests when it reached Stage 3, but that seems to be in jeopardy. Has there been any discussion or agreement on a renaming yet? I can get the tests updated quickly once I have that info

[11:34:51.0000] <shu>
rwaldron-: i plan to present at the next meeting to rename to `at`, open to bikeshedding

[11:35:11.0000] <rwaldron->
Oh, nice! "at" was my favorite of the new options.

[11:35:12.0000] <shu>
rwaldron-: the YUI3 breakage is the nail in the coffin for the `item` name. i'll make a thread about it now, i haven't done that yet...

[11:35:22.0000] <rwaldron->
Yeah, def agree with that.

[11:35:49.0000] <rwaldron->
When should the tests be updated? After next meeting, if there is agreement to the rename?

[11:36:40.0000] <rwaldron->
for now folks can skiplist them easily, by ignoring test/built-ins/*/prototype/item

[11:37:45.0000] <leobalter>
heh it's a breaking change for a presentation I gave and used the steps from Array#item as the example

[11:37:56.0000] <leobalter>
well, .at() seems pretty good too

[11:44:21.0000] <shu>
rwaldron-: definitely don't rename until after the meeting, yeah


2020-10-15
[18:37:25.0000] <jmdyck>
Bakkot: okay, 2176 is resolved and squashed.

[18:38:18.0000] <jmdyck>
resolving the merge conflicts was quite a pain

[18:39:04.0000] <jmdyck>
because 2176 moved so much code around, so the auto-merging was fairly unhelpful

[18:44:15.0000] <jmdyck>
wait

[18:45:24.0000] <jmdyck>
ok there.

[20:27:08.0000] <Bakkot>
yeah, sorry about that :(

[20:27:18.0000] <Bakkot>
gonna be a lot of that for a whilee

[20:27:49.0000] <Bakkot>
I am happy to take care of it if you like

[20:27:54.0000] <Bakkot>
for any future PRs

[20:30:08.0000] <jmdyck>
save your "sorry" for 1950 :)

[20:31:34.0000] <jmdyck>
I just wish git's auto-merge was somewhat smarter.

[20:37:02.0000] <jmdyck>
Back in May, you said #2007 almost certainly needs to land before 1950. So now that it has, is 1950 the next big thing?

[20:40:24.0000] <Bakkot>
yup!

[20:40:50.0000] <Bakkot>
gonna spend tomorrow trying to get a few of the existing open PRs which we expect to conflict wiith 1950 in

[20:41:08.0000] <Bakkot>
and then we'll work on 1950

[20:42:24.0000] <jmdyck>
cool

[20:46:42.0000] <Bakkot>
incidentally if you have any candidates to add to that list I can make a note

[21:14:56.0000] <jmdyck>
Well,  2018 (SV/TV/TRV return String) certainly deals with SDOs.

[21:18:15.0000] <jmdyck>
1651 + 1867 (moving Annex B stuff to main body) deal with SDOs, though that whole thing seems to be in a holding pattern.

[21:21:25.0000] <Bakkot>
yeah, we need to revisit in committee before we can get the remaining Annex B stuff in, unfortunately

[21:21:39.0000] <jmdyck>
1554 touches some SDOs, but not much.

[21:21:51.0000] <Bakkot>
list of things we are currently planning to look at tomorrow is #2018, #2176, #2164, #2084, #2013, #1554

[21:22:07.0000] <Bakkot>
not all of them are strictly SDO-related, just things we want to get in soon

[21:22:59.0000] <jmdyck>
oo, 4 of mine on the list.

[21:25:46.0000] <jmdyck>
3 of which have merge conflicts. Normally I'm more on top of that, but I've been focusing elsewhere

[21:31:37.0000] <jmdyck>
Are you thinking 1950's PR will land before the next committee meeting?

[21:32:26.0000] <Bakkot>
seems unlikely, on the basis that I doubt we'll have enough time between now and then to get it all worked out

[21:35:55.0000] <Bakkot>
we will probably address the merge conflicts ourselves tomorrow, unless you object

[21:36:04.0000] <Bakkot>
those we feel up to / have time for, anyway

[21:44:06.0000] <jmdyck>
well, i generally prefer to resolve merge conflicts myself.

[21:46:53.0000] <Bakkot>
k, we'll leave them alone then

[21:47:35.0000] <Bakkot>
might mean they don't get in before 1950 and need more rebasing, is all

[21:49:14.0000] <jmdyck>
Depends on how early I get up tomorrow.

[21:51:34.0000] <jmdyck>
But I'm confused: you say 1950 likely won't land in the next month, and yet you're talking like tomorrow is the last chance to get merged before 1950 lands.

[21:57:15.0000] <Bakkot>
ah, so, to be clear: tomorrow we plan on spending some time trying to get the above PRs in, after which we'll start spending time on 1950

[21:58:17.0000] <Bakkot>
I expect other stuff to land in the next month, I'm just not going to hold up 1950 on any of it, if 1950 is ready

[21:59:22.0000] <Bakkot>
if you get something ready in two weeks and 1950 is not (likely), it can land then

[22:11:07.0000] <Bakkot>
basically we have some time to spend on before-1950 stuff tomorrow so stuff which is ready then will probably land sooner then stuff which is not, is all

[14:19:58.0000] <Bakkot>
jmdyck did you see https://github.com/tc39/ecma262/pull/2013#discussion_r505846113 ?

[14:20:20.0000] <Bakkot>
you were probably rebasing while I wrote that; just don't want it to get lost

[14:20:24.0000] <jmdyck>
yup, just researching before i reply

[16:00:40.0000] <rkirsling>
ah crap, think I found one problem in the TA EIM tests

[16:03:29.0000] <rkirsling>
it's checking that `ta[0] = 1` returns `false`

[16:03:48.0000] <rkirsling>
when the buffer is detached.

[16:03:59.0000] <rkirsling>
but it's just [[Set]] itself that returns `false`

[16:08:02.0000] <rkirsling>
(https://github.com/tc39/test262/pull/2833#issuecomment-709635850)


2020-10-16
[10:57:01.0000] <rkirsling>
okay, I believe this is the full list of issues in this PR now: https://github.com/tc39/test262/pull/2833#issuecomment-709635850

[10:57:11.0000] <rkirsling>
^ fyi shu

[11:21:37.0000] <shu>
rkirsling: ty

[11:33:49.0000] <rwaldron->
rkirsling thanks for those notes

[11:33:58.0000] <rwaldron->
shu I'll be working on these immediately.

[11:34:07.0000] <rkirsling>
rwaldron-: thank you <3

[11:34:16.0000] <rkirsling>
was going to ask whether you had the bandwidth

[12:40:03.0000] <shu>
possibly stupid question: it's possible to construct a string literal with lone surrogates *without* escapes, right?

[12:40:36.0000] <shu>
you can just, like, put the bit pattern for a lone surrogate between quotes?

[12:40:51.0000] <devsnek>
i believe you can

[12:41:25.0000] <devsnek>
yeah you can

[12:41:26.0000] <Bakkot>
shu yes

[12:41:32.0000] <shu>
thanks

[12:41:53.0000] <Bakkot>
but the actual answer depends on your file's encoding and stuff

[12:42:46.0000] <Bakkot>
according to ecma262 source text is a sequence of 16-bit integers, so you can put the lone surrogate bit pattern in just fine, but your file system or file server may disagree

[12:43:20.0000] <shu>
my actual question was "can i skip the need to check for lone surrogates in ModuleExportName if i didn't see any escapes during lexing", and the answer to that seems like a definitive no

[12:44:02.0000] <devsnek>
how are y'all dealing with dot variable collisions

[12:45:24.0000] <shu>
what are dot variables?

[12:45:40.0000] <shu>
like those synthesized unutterable names used for codegen?

[12:48:35.0000] <devsnek>
shu: like this: https://github.com/v8/v8/blob/master/src/ast/ast-value-factory.h#L225

[12:49:18.0000] <devsnek>
v8 stores variables all over the place with names like that

[12:50:24.0000] <devsnek>
actually i guess this is the one you'd be worried about https://github.com/v8/v8/blob/master/src/parsing/parser.cc#L1408-L1411

[12:50:37.0000] <shu>
yeah, those internal names

[12:51:06.0000] <devsnek>
i was going to work on that proposal for v8 but i didn't have the energy to figure out a way to avoid collisions

[12:52:41.0000] <shu>
i haven't really thought about it yet, but i imagine that desugaring would need to change

[12:53:19.0000] <rkirsling>
shu: Bakkot: methods like TA.p.every don't give alg steps but say that one "must take into account the possibility that calls to callbackfn may cause the this value to become detached" -- is one to assume this means "check whether we need to throw after every iteration"?

[12:54:35.0000] <shu>
devsnek: actually isn't that desugaring fine?

[12:54:51.0000] <shu>
devsnek: the .x there is used in the binding position, not in the ModuleExportName position

[12:54:51.0000] <rkirsling>
it's complicated because the thing we're doing on each iteration is an IntegerIndexedElementGet which no longer throws... :(

[12:55:21.0000] <devsnek>
hmmmmm

[12:55:28.0000] <devsnek>
you might be right

[12:55:55.0000] <shu>
devsnek: ah wait, no, you were right, the second part of the desugaring `.x as x` is what can conflict

[12:58:09.0000] <rkirsling>
oh wait TA.p.filter is spelled out and it doesn't throw on each iteration

[12:58:28.0000] <Bakkot>
rkirsling those methods are dumb and we should fix them

[12:58:39.0000] <rkirsling>
yeah :(

[12:58:41.0000] <Bakkot>
we just did that with the math methods, and there's an open PR doing it for Number

[12:58:50.0000] <rkirsling>
ah cool

[12:59:11.0000] <shu>
devsnek: ah, i think it might still be okay. the ModuleExportName `as` ModuleExportName case shouldn't be looking up any variables in the local scope

[12:59:23.0000] <shu>
so even if the string contents are the same, they shouldn't conflict since it's not a binding

[12:59:39.0000] <shu>
rkirsling: reading

[12:59:54.0000] <rkirsling>
thanks, sorry for the interleaved discussion

[13:00:51.0000] <shu>
yeah https://tc39.es/ecma262/#sec-%typedarray%.prototype.every is a bad piece of spec text and we should be ashamed

[13:01:48.0000] <shu>
rkirsling: i think the *intention* was to throw. let's see what impls do

[13:03:40.0000] <rkirsling>
the issue is that like, if you look at https://tc39.es/ecma262/#sec-%typedarray%.prototype.map which is clear and simple

[13:04:08.0000] <rkirsling>
we were letting IntegerIndexedElementSet throw if calling the callback detached the buffer

[13:04:21.0000] <rkirsling>
but now that doesn't throw, so there's a ripple effect

[13:04:31.0000] <rkirsling>
which seems fine there

[13:04:48.0000] <rkirsling>
but it makes the lack of clarity for every/some even worse

[13:07:05.0000] <shu>
yeah, the ripple effects, hm

[13:16:26.0000] <ljharb>
i believe Records and Tuples are currently using the same technique as typed array filter in a bunch of places

[13:16:36.0000] <ljharb>
ie, "this is the same as X except for these changes"

[13:21:57.0000] <Bakkot>
seems fine while iterating in stage 2, but I'll require that fixed before it landss

[13:24:27.0000] <ljharb>
it might be good to file an issue on the repo with that feedback then

[14:49:05.0000] <rkirsling>
oh that's another interesting path

[14:52:32.0000] <rkirsling>
`Object.defineProperty(ta, '0', badDescriptor)` usually throws, but when the buffer is detached, we run into trouble checking the typed array length before dealing with the descriptor

[14:55:24.0000] <rkirsling>
...which seems like we might just return undefined, except that there is one confusing thing

[14:56:44.0000] <rkirsling>
and that's that detaching the underlying buffer doesn't seem to change [[ArrayLength]] on the typed array? 🤔

[14:57:45.0000] <rkirsling>
which means we probably should still throw

[14:59:00.0000] <rkirsling>
issue is at https://tc39.es/ecma262/#sec-integer-indexed-exotic-objects-defineownproperty-p-desc step 3.b.i if anyone is interested in checking my work

[14:59:17.0000] <rkirsling>
s/issue/the line in question/

[14:59:41.0000] <rwaldron->
shu I have to sign off, I will wrap up the necessary updates to detach buffer tests next week. For now, if there is any issue, I recommend skiplisting the feature: "align-detached-buffer-semantics-with-web-reality

[14:59:41.0000] <rwaldron->
"

[14:59:45.0000] <rwaldron->
Whoops

[15:01:00.0000] <rkirsling>
seems like elsewhere we always check IsDetachedBuffer immediately before checking IsValidIntegerIndex so maybe this is an editorial bug

[15:01:45.0000] <rkirsling>
yeah, I feel like that makes the most sense.

[15:21:57.0000] <rkirsling>
shu: evidently there are tests to check that `every` and kin throw

[15:23:05.0000] <shu>
rkirsling: yeah?

[15:23:36.0000] <rkirsling>
hmm although they cite the Get

[15:23:36.0000] <rkirsling>
https://github.com/tc39/test262/blob/main/test/built-ins/TypedArray/prototype/map/callbackfn-detachbuffer.js

[15:24:49.0000] <rkirsling>
^ this one at the very least is wrong

[15:25:02.0000] <rkirsling>
so I think it would be reasonable to call them all in need of update

[15:25:40.0000] <rkirsling>
"all" meaning, all the ones that take a callback function that might detach the buffer before the next Get or Set

[15:26:06.0000] <shu>
that test you just linked expects that it doesn't throw, but that iteration stops after detaching?

[15:29:00.0000] <rkirsling>
umm currently even iteration wouldn't stop: https://tc39.es/ecma262/#sec-%typedarray%.prototype.map

[15:29:19.0000] <rkirsling>
unless we view this as an overlooked ripple effect that should be corrected immediately

[15:56:47.0000] <shu>
what do implementations do?

[16:00:01.0000] <rkirsling>
oh right [[Get]] and [[Set]] were already allowed outside of JSC

[16:00:04.0000] <rkirsling>
hmm

[16:00:12.0000] <rkirsling>
pretty sure everybody passes these

[16:03:49.0000] <rkirsling>
oh!!

[16:03:50.0000] <rkirsling>
https://test262.report/browse/built-ins/TypedArray/prototype/map/callbackfn-detachbuffer.js

[16:03:52.0000] <rkirsling>
nope

[16:04:43.0000] <rkirsling>
and everyone drew the same conclusion for the implicit ones:

[16:04:44.0000] <rkirsling>
https://test262.report/browse/built-ins/TypedArray/prototype/every/callbackfn-detachbuffer.js

[16:05:18.0000] <rkirsling>
s/implicit ones/ones lacking alg steps/ I mean

[16:07:58.0000] <rkirsling>
V8 and SM disagree on whether to stop iterating

[16:08:09.0000] <rkirsling>
but already agree on not throwing

[16:09:50.0000] <rkirsling>
V8's choice to stop iterating is a little odd though

[16:11:01.0000] <rkirsling>
V8 and SM both allow [[Get]] and [[Set]] but you'd expect them both to follow the spec otherwise

[16:22:56.0000] <shu>
hm

[16:23:14.0000] <shu>
i'm not sure right now we should do here

[16:23:34.0000] <shu>
i'm gonna try to finish up implementing the arbitrary module export name thing for today, let's come back to this next week

[16:26:17.0000] <rkirsling>
okay

[16:38:20.0000] <rwaldron->
rkirsling shu we should summon leobalter to look at the older detach buffer tests, since he was one of the primary authors of those tests back in 2016

[16:49:41.0000] <rkirsling>
that would be great

[16:50:21.0000] <rkirsling>
it's quite a doozy but I at least feel like I've got a handle on it now that I've worked the whole way through JSC's impl


2020-10-17
[17:29:26.0000] <rwaldron->
shu https://github.com/tc39/test262/pull/2869

[17:30:09.0000] <rwaldron->
Also, nice additions!

[17:30:30.0000] <rwaldron->
I will fix the $DONOTEVALUATE() calls ;)

[08:59:04.0000] <leobalter>
rwaldron- Shu rkirsling I can take a look on Monday. Should it be a full review on the existing detach buffer tests?

[14:56:38.0000] <rkirsling>
leobalter: Rick's been working on the list of adjustments that I found here https://github.com/tc39/test262/pull/2833#issuecomment-709635850 ; the trickiest part is the ripple effects on tests that *aren't* overtly about detached buffers

[15:45:38.0000] <rkirsling>
Bakkot: ljharb: does this make sense? https://github.com/tc39/ecma262/pull/2207

[15:46:48.0000] <Bakkot>
will look once it renders

[15:48:40.0000] <rkirsling>
thanks

[15:50:50.0000] <Bakkot>
yeah, seems reasonable

[15:51:06.0000] <rkirsling>
cool

[15:52:44.0000] <Bakkot>
q: should [[OwnPropertyKeys]] also return the empty list for TAs backed by detached buffers?

[15:52:46.0000] <Bakkot>
'cause it doesn't

[15:54:39.0000] <rkirsling>
damn. that's a good question

[15:54:47.0000] <rkirsling>
this sure is a thorny subject

[15:56:19.0000] <Bakkot>
I think yes

[15:56:29.0000] <Bakkot>
the other methods all pretend those indices don't exist

[15:56:39.0000] <Bakkot>
should check impl. reality I guess

[16:01:07.0000] <devsnek>
am i correct that this test is wrong now? https://gc.gy/70680667.png

[16:01:24.0000] <Bakkot>
rkirsling also you should've pinged shu as well probably; he's the editor who has the most experience with TA stuff

[16:02:05.0000] <devsnek>
oh nvm

[16:02:11.0000] <devsnek>
rkirsling: thanks for compiling that list of test issues

[16:02:38.0000] <rkirsling>
Bakkot: agreed but I thought he might not want to be pinged on a Saturday 😅

[16:02:39.0000] <Bakkot>
devsnek: snarky answer is that it is impossible to tell because `%TypedArray%.prototype.findIndex` is specified with hand-wavy prose instead of an actual algorithm

[16:03:00.0000] <rkirsling>
devsnek: you're welcome

[16:03:11.0000] <devsnek>
Bakkot: it's not specific to findIndex

[16:03:24.0000] <devsnek>
point 5 in rkirsling's comment

[16:03:25.0000] <Bakkot>
rkirsling not sure what that says about me :P

[16:03:50.0000] <rkirsling>
Bakkot: lol sorry. you're right anyway

[16:04:28.0000] <rkirsling>
tbf we need to make sure that everyone's happy with the "don't throw or even stop iterating" interpretation on Monday-ish

[16:04:38.0000] <rkirsling>
because that's SM's behavior already

[16:04:43.0000] <Bakkot>
hmm

[16:04:45.0000] <rkirsling>
but V8 stops iterating

[16:04:50.0000] <Bakkot>
ideally should've done that before landing I guess

[16:05:18.0000] <rkirsling>
which is sensible _without_ looking at the spec but weird in that (considering the spec before my PR) they were *doubly* breaking spec

[16:06:42.0000] <rkirsling>
Bakkot: yeah I think I underestimated how piecemeal-addressable this matter would be

[16:07:07.0000] <rkirsling>
I don't regret it, it's just requiring a lot of post-consensus reality-checking

[16:15:40.0000] <Bakkot>
rkirsling https://github.com/tc39/ecma262/pull/2164#issuecomment-711092235

[16:16:58.0000] <rkirsling>
agreed

[16:17:19.0000] <rkirsling>
an alternate solution would be to have [[ArrayLength]] actually get cleared

[16:17:29.0000] <rkirsling>
but that would be a larger changed

[16:17:31.0000] <rkirsling>
-d

[16:18:07.0000] <Bakkot>
I think that would be editorial after the change I suggest there

[16:18:19.0000] <rkirsling>
right

[16:18:23.0000] <Bakkot>
(I noticed it by auditing access of `[[ArrayLength]]`)

[16:18:28.0000] <rkirsling>
yeah

[16:20:04.0000] <rkirsling>
I could add it to the fix PR if I make it "IsDetachedBuffer should be checked before accessing [[ArrayLength]]"

[16:21:21.0000] <Bakkot>
/shrug

[16:22:49.0000] <rkirsling>
I feel like we don't need to regain consensus for things that "should have been addressed before merge" but not sure if controversial

[16:26:21.0000] <Bakkot>
yeah it's always tricky

[16:27:41.0000] <Bakkot>
I think since you specifically phrased the PR as trying to match web reality in this space it's probably fine to assume things which are web reality have consensus

[16:27:55.0000] <Bakkot>
but otoh it's not like there's much harm in waiting and asking

[16:28:20.0000] <Bakkot>
we can see how other editors feel

[16:28:39.0000] <rkirsling>
I'll just add it to the fix PR and we can discuss in one bucket

[16:33:41.0000] <devsnek>
for once i have no opinions

[16:41:44.0000] <rkirsling>
what is the preferred spec style for what would be defining a variable with a ternary

[16:42:09.0000] <Bakkot>
`1. if foo, let _x_ be whatever. 1. else, let _x_ be whatever`

[16:42:33.0000] <rkirsling>
cool. figured it was either that or "let > if > set"

[16:43:27.0000] <rkirsling>
oh wait we have a one-line version in the optional chaining stuff

[16:43:31.0000] <rkirsling>
`If the code matched by this OptionalChain is strict mode code, let strict be true; else let strict be false.`

[16:43:36.0000] <rkirsling>
interesting

[16:44:54.0000] <Bakkot>
yeah, we do sometimes have single-line if-else

[16:45:02.0000] <Bakkot>
in sufficiently simple cases

[16:50:30.0000] <rkirsling>
updated

[16:52:10.0000] <Bakkot>
rkirsling it seems a little weird to have the `if` set the upper bound for the loop to 0 instead of just guarding the loop entirely

[16:52:23.0000] <rkirsling>
oops

[16:52:28.0000] <rkirsling>
fair point

[16:57:02.0000] <rkirsling>
repushed


2020-10-18
[06:20:17.0000] <jmdyck>
bc

[16:30:36.0000] <devsnek>
we need the equiv of custom sections for js


2020-10-19
[17:37:01.0000] <jmdyck>
custom sections as in Slack?

[17:38:48.0000] <jmdyck>
or maybe https://www.dassmetal.com/products/custom-sections/

[17:40:04.0000] <jmdyck>
https://webassembly.github.io/spec/core/appendix/custom.html ?

[17:44:43.0000] <devsnek>
jmdyck: wasm

[17:45:17.0000] <devsnek>
then we wouldn't need the import assertion proposal

[13:16:03.0000] <rkirsling>
shu: Bakkot: seems we have another issue that AlexeyS noticed

[13:17:19.0000] <rkirsling>
integer-indexed [[Set]] early outs with `false` but this would throw in strict mode, whereas V8 and SM currently just fail silently (when setting to a detached buffer or OOB index)

[13:19:29.0000] <Bakkot>
oh, I assumed that was intentional

[13:21:45.0000] <rkirsling>
the spec part?

[13:21:51.0000] <Bakkot>
the change to throw

[13:21:53.0000] <rkirsling>
yeah

[13:22:05.0000] <Bakkot>
I guess the PR says it was supposed to not do that, though

[13:22:25.0000] <rkirsling>
I was being short-sighted and not thinking sufficiently about strict mode :(

[13:22:56.0000] <rkirsling>
I think it's entirely justifiable to keep things as they are right now in the spec, as that flag is called `succeeded` and we clearly didn't succeed

[13:23:45.0000] <rkirsling>
there's no compat issue since JSC was always different but the current behavior of V8 and SM made me second-guess myself

[13:48:48.0000] <shu>
rkirsling: working on some backlogged stuff, but i plan to look at the detach stuff today or tomorrow. we should chat about a plan, but first need to get up to date...

[13:48:57.0000] <rkirsling>
aye-aye

[14:21:38.0000] <shu>
rwaldron-: ping, around?

[14:21:55.0000] <rwaldron->
shu yes

[14:24:27.0000] <shu>
rwaldron-: looks like https://github.com/tc39/test262/issues/2866 still has an outstanding issue; also would appreciate https://github.com/tc39/test262/pull/2873 (i'm rolling a new test262 right now into v8)

[14:24:40.0000] <rwaldron->
Sure thing

[14:24:44.0000] <shu>
tyty

[14:25:19.0000] <rwaldron->
Those missing includes tests are odd... I don't see why atomicsHelper is needed for those tests...?

[14:25:25.0000] <rwaldron->
OMG.

[14:25:34.0000] <rwaldron->
:🤦🏼‍♂️🤦🏼‍♀️:

[14:25:48.0000] <shu>
it's the $262.agent.setTimeout

[14:25:54.0000] <rwaldron->
YEP

[14:26:05.0000] <rwaldron->
My local eshost is on a branch where I'm working on implementing that in all of the agents

[14:26:11.0000] <rwaldron->
What an absolute dummy.

[14:26:14.0000] <shu>
ah ha, i see

[14:26:21.0000] <rwaldron->
Sorry about that.

[14:26:31.0000] <shu>
np

[14:26:37.0000] <shu>
what's the plan for implementing them in all agents?

[14:26:52.0000] <shu>
i think it might be worth test262's time to just manually define setTimeout with its current polyfill

[14:27:23.0000] <shu>
d8's setTimeout doesn't actually do any wall-clock time counting

[14:31:15.0000] <rwaldron->
Ah, good to know. I had planned to do a campaign similar to monotonicNow, but that seems reasonable.

[14:32:11.0000] <rwaldron->
When I say "campaign", I mean that I would go around and implement it in V8, JSC, and SM, or ask for an implementer to help out)

[14:32:31.0000] <rwaldron->
But yeah, there is usually a fallback in place, which in this case I will take your suggestion.

[14:39:58.0000] <rwaldron->
shu also: https://github.com/tc39/test262/pull/2875/files

[14:47:35.0000] <rwaldron->
I have to head out now, have a good night.

[14:48:57.0000] <rwaldron->
I'll check back in a few hours (after the kiddo is in bed), just to make sure you get that test262 roll done

[14:51:24.0000] <shu>
rwaldron-: awesome, thanks

[15:09:52.0000] <rkirsling>
rwaldron-: thanks for the test work! not sure if you caught the discussion above this one ^ but it looks like we'll need to make sure that when [[Set]] returns false that we throw in strict mode

[15:10:30.0000] <rkirsling>
(this is counter to what V8/SM have done but I believe it's necessary)

[16:41:20.0000] <shu>
rwaldron-: current tip of test262 tree lgtm


2020-10-20
[17:30:04.0000] <shu>
rkirsling: hi, do you have ~10 mins now to talk about next steps for the detach stuff?

[17:30:13.0000] <rkirsling>
sure!

[17:31:49.0000] <shu>
rkirsling: what are the open questions right now?

[17:32:13.0000] <shu>
1) strict assignment throwing is neither SM nor V8 reality, but is JSC reality?

[17:32:38.0000] <rkirsling>
um, so I believe this stuff is uncontroversial:

[17:32:39.0000] <rkirsling>
https://github.com/tc39/ecma262/pull/2207

[17:33:16.0000] <rkirsling>
then yeah, strict assignment -- remember that JSC was throwing on Get/Set in general so we can technically do whatever

[17:35:35.0000] <shu>
i think it's reasonable for V8 to try to make the strict case throw and see if any bugs arise

[17:35:43.0000] <rkirsling>
and the last thing is about callback-taking methods on %TypedArray%: V8/SM already don't throw so I think that part's uncontroversial, but V8 stops iterating which was a unique sort of double-spec-violation

[17:35:46.0000] <rkirsling>
cool

[17:36:22.0000] <shu>
i'll come back to #2207 last, though from a quick reading that also looks like it encodes the "do not stop iterating" behavior, is that right?

[17:37:54.0000] <rkirsling>
oh 2207 is actually separate; it's sort of "pseudo-editorial" because the spec has a silly situation where it doesn't always guard checks of [[ArrayLength]] even though this is untouched upon buffer detachment

[17:38:26.0000] <rkirsling>
"saying what we mean" there would allow a better editorial refactor to follow

[17:38:28.0000] <shu>
okay, then let's return to that last

[17:38:39.0000] <rkirsling>
but the "don't stop iterating" is already merged

[17:38:39.0000] <shu>
the whether we should continue iterate question seems related to this comment: https://github.com/tc39/ecma262/pull/1908#issuecomment-648277813

[17:39:30.0000] <rkirsling>
oh hmm

[17:40:18.0000] <rkirsling>
well so the thing is that https://tc39.es/ecma262/#sec-%typedarray%.prototype.map has explicit steps

[17:40:32.0000] <rkirsling>
and it was implicitly throwing on Get/Set but now it won't throw at all

[17:40:40.0000] <rkirsling>
but it only grabs the length once

[17:40:55.0000] <rkirsling>
so if the callback causes detachment, then we'll keep iterating for the original length

[17:40:58.0000] <rkirsling>
is what I mean

[17:41:03.0000] <shu>
okay, that sounds fine then

[17:41:05.0000] <rkirsling>
and that is the existing behavior in SM

[17:41:21.0000] <rkirsling>
cool

[17:41:24.0000] <shu>
and doesn't violate the invariant anba is talking about there, since it's cached

[17:41:27.0000] <rkirsling>
right

[17:41:58.0000] <shu>
i think the incompat risk for both the strict assignment and the iteration changes for v8 should be low, but the strict assignment throwing is higher

[17:42:10.0000] <rkirsling>
right

[17:42:24.0000] <rkirsling>
the worry with the existing behavior boils down to

[17:42:48.0000] <rkirsling>
it's really weird to say that [[Set]] "succeeded" in the early out case

[17:43:13.0000] <rkirsling>
and the overarching semantics for assignment are "throw if not succeeded in strict mode"

[17:43:40.0000] <shu>
agreed, it would be needlessly more exotic than it needs to be, so i'm for changing it if we can get away with it

[17:44:21.0000] <rkirsling>
wonderful

[17:45:12.0000] <shu>
okay, let me read #2207 now...

[17:47:43.0000] <shu>
rkirsling: the [[DefineOwnProperty]] addition looks a bug, calling it editorial lgtm

[17:47:57.0000] <rkirsling>
cool

[17:48:00.0000] <shu>
rkirsling: for [[OwnPropertyKeys]], do you happen to know if that's the implementation behavior as well?

[17:48:32.0000] <rkirsling>
yeah if you see Bakkot's comment (https://github.com/tc39/ecma262/pull/2164#issuecomment-711092235) it is in fact web reality

[17:48:42.0000] <rkirsling>
and in the spirit of what we got consensus on

[17:49:34.0000] <shu>
ah cool, missed it cause it was in the other PR

[17:49:41.0000] <shu>
then #2207 looks great to me, ship it

[17:50:22.0000] <shu>
so to recap:

[17:50:40.0000] <shu>
- JSC is changing its behavior to match what's merged, including #2207

[17:50:56.0000] <shu>
- V8 needs to throw on strict assignment and continue iteration in TA built-ins

[17:51:04.0000] <shu>
- SM doesn't need to do anything

[17:51:44.0000] <rkirsling>
I think that's correct? it's possible that there's *some* tweak for SM that I'm forgetting but at least within the context of all we've discussed here, yes

[17:52:18.0000] <shu>
while we're here we should add a note somewhere that [[ArrayLength]] mustn't be accessed on detached stuff

[17:52:22.0000] <shu>
even though it's "fine"

[17:52:37.0000] <shu>
thanks for doing all this work rkirsling, appreciate it

[17:52:57.0000] <rkirsling>
my pleasure, I appreciate you backing me up

[17:53:49.0000] <rkirsling>
and yeah I think there should be a subsequent editorial for [[ArrayLength]] (doesn't have to be subsequent but in the interest of separating "fixing the imminent problems" from "making it readable and maintainable")

[17:55:14.0000] <rkirsling>
shu: oh shoot there's one little potential compat concern

[17:55:20.0000] <rkirsling>
which I overlooked

[17:56:03.0000] <rkirsling>
I was thinking that JSC always threw on [[Get]]/[[Set]], which is true for the detached buffer state but *not* true for OOB

[17:56:37.0000] <rkirsling>
it's still worth a shot if we can get away with it but...hmm

[17:58:19.0000] <shu>
what's worth the shot, that we throw for OOB?

[17:58:23.0000] <shu>
wait, have we thrown for OOB?

[17:58:30.0000] <shu>
err, have we specced throwing for OOB?

[17:59:26.0000] <rkirsling>
so what I mean is https://tc39.es/ecma262/#sec-integerindexedelementset step 6

[18:00:30.0000] <rkirsling>
that was not changed in my PR

[18:01:32.0000] <shu>
ah, you mean also in strict mode

[18:01:48.0000] <rkirsling>
yes, sorry

[18:02:18.0000] <rkirsling>
Alexey's gonna make an issue just to track the concern formally

[18:02:21.0000] <shu>
hm yeah nobody throws

[18:02:36.0000] <shu>
that makes me more worried, oob can happen accidentally much more easily than detachment

[18:02:41.0000] <rkirsling>
exactly

[18:02:56.0000] <rkirsling>
and it feels bad to have detachment not do the same thing as OOB

[18:03:29.0000] <shu>
hmm

[18:04:02.0000] <shu>
i'm 50-50 on that

[18:04:46.0000] <shu>
even after your heroic efforts here we are still straddling the line between the "detachment is like reducing the length to 0" mental model and "detachment is a fundamental state change" mental model

[18:04:58.0000] <shu>
i can squint and see maybe it's fine to have detachment throw for strict assignment but not OOB

[18:05:25.0000] <shu>
but it does make me less enthusiastic about trying throwing behavior for strict assignment on detached

[18:06:29.0000] <shu>
i think it makes me lean towards _not_ changing existing behavior to throwing

[18:06:37.0000] <rkirsling>
agreed

[18:07:14.0000] <rkirsling>
at which point I think we also would need a note or something to explain why we're setting a flag called `succeeded` to true?

[18:08:15.0000] <shu>
also, changing it throwing might have more compat risk than i initially thought due to those weird TAs-on-the-prototype use cases

[18:09:11.0000] <shu>
i'm going to punt on changing the v8 strict assignment behavior for now, we need to think more carefully about this i think

[18:09:50.0000] <shu>
since we already _cannot_ have our cake of having detachment be signaled via an exception in all cases, how much do we really wanna fight here?

[18:10:06.0000] <rkirsling>
:nod:

[18:12:44.0000] <rkirsling>
and I mean, on that note, anba seemed to be hoping for us to go further toward consistency, but we just punted since it's web-compatible to remove more errors later

[18:12:52.0000] <rkirsling>
but I kind of assumed we would eventually

[18:13:21.0000] <rkirsling>
that said, I was only thinking about method calls and not about strict assignment

[18:13:40.0000] <rkirsling>
kind of embarrassed by all the things I failed to consider here lol

[18:13:45.0000] <shu>
oh hm

[18:13:55.0000] <shu>
there is also a surprisingly huge number of sites that detach ABs: https://chromestatus.com/metrics/feature/timeline/popularity/3257

[18:15:31.0000] <shu>
there're some URLs there to safari at and see if anything seems amiss

[18:19:24.0000] <rkirsling>
shu: wow.

[18:20:36.0000] <rkirsling>
that first one is a Wix site so it might be framework-level

[18:22:19.0000] <rkirsling>
I think the sixth one is too

[18:22:42.0000] <shu>
yeah, i reckon it's a library

[18:22:49.0000] <shu>
i wonder what it's doing, no time left today to dig in

[18:23:09.0000] <rkirsling>
and the fourth

[18:23:11.0000] <shu>
but given Safar is the odd one out i'd be interested to hear if there's anything odd happening right now

[18:23:16.0000] <shu>
Safari*

[18:23:42.0000] <rkirsling>
I'm not seeing any uncaught errors for detached buffers in the console, is the thing

[18:24:34.0000] <shu>
i wonder if there's a way to get a more exact URL for what triggered the use counter

[18:24:46.0000] <shu>
there might be in HTTP Archive

[18:25:04.0000] <rkirsling>
this tawk.to live chat service might be a second culprit

[18:26:28.0000] <rkirsling>
I think all of these pretty much involve one of those two

[18:26:57.0000] <shu>
interesting

[18:27:54.0000] <rkirsling>
okay not the 10th one but maybe that one requires a more specific path to hit

[18:28:04.0000] <shu>
lmk if you find anything more, gotta run for now

[18:28:08.0000] <rkirsling>
sure

[18:28:19.0000] <shu>
or if you come up with a HTTP Archive query

[18:28:23.0000] <shu>
(remember don't run it!! let me run it)

[18:29:44.0000] <rkirsling>
hahaha indeed

[08:16:12.0000] <bradleymeck>
is there some way to access a partially initialized object literal? { get y() {return 1;},/* access .y ,*/z:0 }

[08:57:05.0000] <bradleymeck>
threw up an invariant https://github.com/codehag/documenting-invariants/issues

[08:57:22.0000] <bradleymeck>
this came up slightly t beginning of decorators calls

[09:19:59.0000] <Bakkot>
bradleymeck there is not

[09:20:10.0000] <bradleymeck>
Bakkot: I hoped so

[09:20:14.0000] <bradleymeck>
for classes you can

[09:20:26.0000] <bradleymeck>
class fields*

[09:25:38.0000] <ljharb>
bradleymeck: how so?

[09:26:01.0000] <ljharb>
fields don’t run until the instance is initialized

[09:26:05.0000] <bradleymeck>
https://twitter.com/bradleymeck/status/1318580963711029252 shows partial init of an object

[09:27:04.0000] <ljharb>
The fields aren’t part of the initialization, in my mind

[09:27:12.0000] <ljharb>
just like constructor assignment after super wouldn’t be

[09:28:21.0000] <bradleymeck>
w/e you want to call it, the object doesn't have its full expected shape as described by the class' code

[09:29:23.0000] <ljharb>
sure, that’s observable with any stored code. the class body defines the class constructor, not the instances

[09:29:40.0000] <ljharb>
can you use static fields to get a partial view of the constructor?

[09:30:37.0000] <bradleymeck>
what does that mean, you mean before all the static fields are defined? yes

[09:32:36.0000] <bradleymeck>
both allow referencing the target prior to all of them being applied

[09:53:50.0000] <rwaldron->
rkirsling I've found something in  %TypedArray%.prototype.find that makes it behave differently than how I think you expected all of the methods in the list you gave me to work from

[09:54:07.0000] <rwaldron->
rkirsling https://github.com/tc39/test262/pull/2833#issuecomment-709635850

[09:55:13.0000] <rwaldron->
Actually, just kidding, false alarm. Nothing to see here.

[09:55:17.0000] <rwaldron->
;)

[09:55:24.0000] <rwaldron->
These will be updated shortly

[09:55:44.0000] <rwaldron->
(There was a typo in the test lol)

[11:32:58.0000] <rkirsling>
hurray for false alarms

[12:06:41.0000] <bradleymeck>
rickbutton: lmk if you need any followup or links to things

[12:08:08.0000] <rickbutton>
bradleymeck: will do ty

[16:31:01.0000] <rkirsling>
shu: aaaaugh this [[Set]] thing is somewhat mind-bending

[16:31:26.0000] <rkirsling>
what we have to do seems adequately clear but how to justify it is breaking my brain

[16:32:27.0000] <shu>
rkirsling: i'm happy to talk through it

[16:32:31.0000] <shu>
wanna do a call?

[16:32:40.0000] <rkirsling>
oh sure, that works

[16:34:49.0000] <rkirsling>
shu: what platform?

[16:36:29.0000] <shu>
rkirsling: i'll send a link, sec

[16:36:50.0000] <rkirsling>
obrigado


2020-10-21
[13:43:10.0000] <rkirsling>
Bakkot: I agree with your note for IntegerIndexedElementSet but I'm not sure that returning undefined instead of true is clearer; if the note is saying that IntegerIndexedElementSet then it seems like it *should* be the thing to always return true

[13:43:28.0000] <Bakkot>
wfm

[13:43:40.0000] <rkirsling>
alrighty

[13:43:51.0000] <Bakkot>
it just means the callsites look like they might return false, which is not so

[13:44:20.0000] <rkirsling>
I have a commit I can push for discussion's sake but yeah

[13:45:37.0000] <rkirsling>
yeah I'll still push it for now, concreteness is good


2020-10-22
[07:29:28.0000] <jorendorff>
sigh, my biggest comment on the Iterator Helpers proposal is I don't understand why we're passing values to .next() at all, for any of these.

[07:29:51.0000] <jorendorff>
something something, "transparency": but is there a use case?

[07:30:04.0000] <jorendorff>
the downside is (1) this creates a ton of picayune design decisions for the spec, where there is no real reason for there to be any;

[07:31:03.0000] <jorendorff>
(2)" transparency" is not a well-defined concept, and there's nothing else to go on. so it's not always clear how these design decisions should go

[09:26:59.0000] <shu>
my only comment right now is i love the use of picayune

[09:52:35.0000] <TabAtkins>
https://github.com/w3c/csswg-drafts/commit/588ce6183bc25e62b61ec723f700b2c356d8a89a#diff-8974d243f99b24bfbefbf89dee6dc5d4a06890610cb205535e0d8d279db1d587

[09:52:39.0000] <TabAtkins>
sorry, wrong room

[09:54:13.0000] <TabAtkins>
unless y'all are real interesting in the details of css's forced-colors mode


2020-10-24
[09:13:24.0000] <jmdyck>
There isn't a punctuator for `?.`, so the optional chain operator is lexed as a `?` punctuator followed by a `.` punctuator? So whitespace (etc) is allowed between the two?

[09:15:46.0000] <jmdyck>
never mind, it's a special punctuator


2020-10-25
[07:00:33.0000] <jmdyck>
If you want to talk about for-loops that aren't for-in or for-of, how do you refer to them?

[11:45:36.0000] <shu>
i say c-style

[11:47:30.0000] <jmdyck>
tx


2020-10-26
[10:56:07.0000] <bradleymeck>
ljharb: I'd rather like a general fix to spreading an array w/ syntax rather than special tricks or one offs

[10:57:17.0000] <ljharb>
that's why i was thinking, "if IsArray() and its constructor is %Array%" would work

[10:57:38.0000] <ljharb>
because then spreading still does iteration for everything else, but for the common case we're worried about, a normal array in any realm, it'd be safe

[10:57:39.0000] <bradleymeck>
so kind of like the Promise#then exception

[10:57:53.0000] <ljharb>
which?

[10:57:54.0000] <bradleymeck>
when using await

[10:58:02.0000] <ljharb>
ah, yes

[10:58:36.0000] <ljharb>
there's a use case for subclasses, but there's no use case where we want people to change how Promise.prototype.then or Array.prototype[Symbol.iterator] works

[11:03:03.0000] <devsnek>
you want spreading an array to not use Symbol.iterator?

[11:04:41.0000] <bradleymeck>
i just want a safe spread op that doesn't delegate to a mutable thing

[11:04:48.0000] <bradleymeck>
idc personally if it is an array

[11:05:35.0000] <bradleymeck>
https://github.com/tc39/ecma262/issues/2212

[11:13:43.0000] <ljharb>
devsnek: yes, there's no value in it doing so

[11:35:26.0000] <devsnek>
ljharb: i dislike random specialization

[11:36:01.0000] <ljharb>
that's fair

[11:36:22.0000] <ljharb>
altho i'm not sure how random it is; we have lots of things in the language that have a protocol but still have fallback behavior for builtins

[11:36:33.0000] <devsnek>
reading the linked issue, not using iterators to read arguments seems like a better line of discussion

[11:36:38.0000] <ljharb>
i suppose this one would be a bit different, with really only `await`

[11:36:56.0000] <ljharb>
devsnek: the issue is on `super(...args)`, not the `...args` in the signature

[11:37:05.0000] <devsnek>
yeah

[11:37:08.0000] <ljharb>
(as i understand it)

[11:37:11.0000] <devsnek>
ArgumentBindingInitialization or whatever right?

[11:41:05.0000] <bradleymeck>
idc how it is solved, just introducing a syntax to use @@iterator directly would be enough

[11:43:06.0000] <devsnek>
that seems incredibly niche

[11:43:10.0000] <bradleymeck>
though i think some people wanted that to be virtualizable? /me stares

[11:43:23.0000] <bradleymeck>
@@ for all the builtin Symbols would be more sane as a whole to me

[11:43:57.0000] <devsnek>
you could just make a function which wraps things

[11:44:11.0000] <bradleymeck>
?

[11:44:16.0000] <devsnek>
`const [a, b, c] = iter([1, 2, 3])`

[11:44:30.0000] <bradleymeck>
sure, but the problem is that the constructor is self contained

[11:44:37.0000] <bradleymeck>
so we don't want to delegate out

[11:44:46.0000] <devsnek>
tell people not to override Array.prototype[@@iterator]

[11:45:02.0000] <bradleymeck>
right now it delegates out to Array@@iterator which is probably saner than telling users to write a custom iterator

[11:45:10.0000] <bradleymeck>
devsnek: we don't control that

[11:45:29.0000] <bradleymeck>
we can tell people to use semicolons and they aren't forced to do so either

[11:46:11.0000] <devsnek>
right but like

[11:46:20.0000] <devsnek>
if they delete or break array[@@iterator]

[11:46:25.0000] <devsnek>
their app will stop working

[11:46:31.0000] <devsnek>
and they will put it back

[11:46:36.0000] <ljharb>
or the app they're trying to maliciously interfere with will

[11:46:58.0000] <bradleymeck>
the point is to make the code more robust, not to get them to fix things manually

[11:47:21.0000] <bradleymeck>
as long as robust code can sanely be written it seems fine to take any direction

[11:47:30.0000] <bradleymeck>
right now super(...args) isn't able to be robust

[11:47:44.0000] <devsnek>
i really dislike the "execute code you don't trust" model

[11:48:04.0000] <bradleymeck>
thats generally the life of software big and small

[11:48:16.0000] <bradleymeck>
you don't audit every line of code and even if you do, that doesn't make it safe

[11:48:43.0000] <devsnek>
so put it on a vm somewhere instead of inviting it into your heap

[11:48:47.0000] <bradleymeck>
it isn't about "we can make things trustworthy" since that is... not reasonable

[11:48:59.0000] <bradleymeck>
devsnek: even in a different heap you can infect things

[11:49:07.0000] <bradleymeck>
heap doesn't stop delegation issues

[11:49:13.0000] <devsnek>
ya like i said, vm somwhere

[11:49:24.0000] <bradleymeck>
you pass in/out data

[11:49:27.0000] <bradleymeck>
vm won't help

[11:49:41.0000] <bradleymeck>
thats the whole injection attack vectors that are big in OWASP

[11:49:57.0000] <bradleymeck>
you can solve *some* problems on all different levels

[11:50:04.0000] <bradleymeck>
this is just solving one problem on one level

[11:50:13.0000] <bradleymeck>
keep solving problems on all levels

[11:51:06.0000] <devsnek>
idk it just seems like if the security of your system hinges on the mutability of Array.prototype, you do not have a secure system

[11:51:22.0000] <devsnek>
regardless of whether or not super(...args) uses @@iterator

[11:51:30.0000] <bradleymeck>
every system relies on some level of assurance

[11:51:49.0000] <bradleymeck>
i don't see how being able to rely on code you write is a sign of things being bad

[11:52:05.0000] <bradleymeck>
minimizing how much of the code is suspect is valuable

[11:52:27.0000] <devsnek>
cuz it implies you're actively working against people patching the code around you

[11:52:33.0000] <devsnek>
which seems like the thing you should be addressing instead

[11:52:48.0000] <bradleymeck>
devsnek: in all my 10+ years of working on JS, pretty much every system has patched the globals

[11:53:16.0000] <bradleymeck>
google's ad scripts were patching Symbol a year or 2 back and broke parts of us

[11:53:31.0000] <devsnek>
lol

[11:53:36.0000] <bradleymeck>
it isn't like this is... uncommon

[11:54:00.0000] <bradleymeck>
so, instead of acting like it doesn't happen when it is very common, we can address issues

[11:54:18.0000] <devsnek>
i'm sure people patch globals all the time

[11:54:25.0000] <devsnek>
but i don't try to fight them

[11:54:34.0000] <devsnek>
if they break my stuff i would just remove them

[11:54:36.0000] <bradleymeck>
i'm not fighting them?

[11:54:44.0000] <bradleymeck>
i'm just making my code work regardless

[11:55:02.0000] <bradleymeck>
i don't see how that is bad

[11:56:45.0000] <devsnek>
i think it makes more sense to just avoid loading scripts that break things

[11:57:13.0000] <bradleymeck>
i can't reasonably ascertain if they do, and i don't control all the scripts

[11:57:24.0000] <bradleymeck>
devsnek: if you can write up a system that does that, I'd love it

[11:57:41.0000] <bradleymeck>
but I do not think it is possible w/ static analysis + human audit

[11:57:44.0000] <devsnek>
i think someone made a startup for this

[11:57:49.0000] <devsnek>
managing injected scripts

[11:57:54.0000] <bradleymeck>
there are many

[11:58:30.0000] <bradleymeck>
but the fact that not everyone is using such things is telling to me

[11:58:49.0000] <bradleymeck>
and you can't bail at runtime, because your site needs to keep working even if it does violate things temporarily

[11:59:17.0000] <bradleymeck>
so, we load things that we don't fully understand. that is simply the truth

[12:00:40.0000] <devsnek>
i still think its inherently useful to be able to patch things around

[12:00:54.0000] <devsnek>
even native programs can swap stuff out using ld_preload and such

[12:04:00.0000] <bradleymeck>
ld_preload can't patch everything

[12:04:25.0000] <bradleymeck>
i'm not trying to prevent people from patching stuff, just trying to write code that won't misbehave if they do patch things

[12:09:56.0000] <ljharb>
you’re also assuming that “break things” is trivially detectable, even in the majority of cases

[12:10:14.0000] <ljharb>
even if it’s not malicious, it could be just a mistake that’s hard to notice until damage is done

[12:11:52.0000] <bradleymeck>
^ what happened to us via google mutating Symbol

[12:12:09.0000] <bradleymeck>
why did it mutate it, idk / fallback behavior?

[12:20:29.0000] <ljharb>
google maps also had a Map/Set shim that broke a bunch of sites that were using es6-shim

[12:20:37.0000] <ljharb>
(they fixed it pretty quickly, luckily)

[16:50:57.0000] <shu>
do we technically allow non-callable constructors? they'd have to be exotic, and it seems like a bad idea to me, but i can't find a place where we disallow them

[16:57:18.0000] <ljharb>
to me it seems like a bad idea to make things that are never actually callable have [[Call]] :-/ but i believe `typeof` will only return `function` if it has a [[Call]]


2020-10-27
[17:08:16.0000] <shu>
well, are there [[Construct]]-only things?

[17:53:54.0000] <devsnek>
shu: I believe that is prohibited

[17:54:02.0000] <devsnek>
by one of those prose sections about functions

[17:54:21.0000] <shu>
let's see...

[17:54:47.0000] <shu>
ah indeed, thanks, it is in prose

[17:55:22.0000] <devsnek>
👍

[17:55:29.0000] <shu>
should put that in the list of invariants

[17:56:11.0000] <shu>
but i guess strictly speaking that list is a list of invariants of the methods, while this invariant is an invariant of all objects

[17:56:29.0000] <shu>
still seems useful

[17:59:31.0000] <devsnek>
we should highlight the important stuff

[17:59:43.0000] <devsnek>
but then that brings the question of what isn't important :P

[10:59:58.0000] <devsnek>
looking forward to some website breaking because we change default constructors to be spec text

[12:38:16.0000] <devsnek>
bradleymeck: would you prefer to present on https://github.com/tc39/ecma262/pull/2216?

[12:38:18.0000] <devsnek>
if not i will

[12:38:48.0000] <bradleymeck>
i have no desire to

[12:38:55.0000] <devsnek>
👍🏻

[12:47:02.0000] <rkirsling>
if [[SetData]] is a List and Set.prototype.add appends to it and %SetIteratorPrototype%.next traverses it in order, does that mean Set iteration has a guaranteed order?

[12:47:14.0000] <devsnek>
yes

[12:47:18.0000] <rkirsling>
I was really expecting us not to guarantee that

[12:47:21.0000] <rkirsling>
weird

[12:47:21.0000] <devsnek>
map iteration has a guaranteed order as well

[12:47:27.0000] <devsnek>
they are both ordered collections

[12:48:36.0000] <rkirsling>
what's the reasoning behind that decision? I wonder

[12:50:58.0000] <Bakkot>
nondeterminism is bad

[12:51:25.0000] <Bakkot>
also if it is unspecified it is likely to be implementation-dependent and then people depend on one implementation and then other implementations have to ship that

[12:51:27.0000] <Bakkot>
which is also bad

[12:51:49.0000] <rkirsling>
that part is fair...

[12:51:54.0000] <Bakkot>
we have been trying hard to avoid leaving things like that unspecified, with the glaring exception of weakrefs

[12:52:06.0000] <ljharb>
basically either we risk that ^, or we risk people thinking that they should conceptually rely on the insertion order. it seems pretty clear to me at least that the former would be worse

[12:52:09.0000] <Bakkot>
(and atomics I guess)

[12:52:42.0000] <rkirsling>
just thinking of std::unordered_set and std::unordered_map and how the abstract data structures have no notion of order

[12:53:12.0000] <devsnek>
i wish we had a System.hash(v) -> n

[12:53:20.0000] <devsnek>
so we could make our own collections

[12:54:14.0000] <devsnek>
right now you would have to make a WeakMap of objects to numbers or smth

[12:54:17.0000] <Bakkot>
rkirsling whenever I think of those I think about how many times I've had bugs which were not reproducible because they were only triggered in a specific case of iterating over an unordered collection

[12:54:48.0000] <Bakkot>
and am grateful that we did not make that mistake

[12:55:15.0000] <rkirsling>
that's fair

[13:49:52.0000] <gsathya>
rkirsling, https://wiki.mozilla.org/User:Jorend/Deterministic_hash_tables

[13:51:25.0000] <rkirsling>
oh thanks!

[13:54:18.0000] <rkirsling>
> if we don't specify an iteration order I think the web will just go and specify it for us, as it has for object property iteration order

[13:54:29.0000] <rkirsling>
yeah that's a very good point

[14:59:21.0000] <Bakkot>
 devsnek: shift is going to have an even more different AST for optional chaining

[14:59:30.0000] <Bakkot>
it's very exciting

[14:59:34.0000] <Bakkot>
we're getting rid of regular member access

[14:59:59.0000] <devsnek>
🤔

[15:00:16.0000] <bradleymeck>
Bakkot: YESSSSS

[15:00:19.0000] <bradleymeck>
YESSSSS

[15:00:50.0000] <bradleymeck>
References and Lookups?

[15:02:06.0000] <Bakkot>
bradleymeck https://gist.github.com/bakkot/bc3702ebf05b6960caefff8d47e2905c

[15:02:20.0000] <Bakkot>
not sure what "references and lookups" means

[15:02:28.0000] <Bakkot>
if you have a different idea, I would love to hear it!

[15:02:31.0000] <Bakkot>
we aren't set on this design

[15:03:04.0000] <bradleymeck>
`delete x.y` is a nightmare right now since it isn't a lookup and you have to crawl up to `delete` to deal w/ its reference nature rather than access nature

[15:03:57.0000] <Bakkot>
ah, that would be a change to `delete` rather than a change to MemberAccess

[15:04:16.0000] <bradleymeck>
call has a weirdness to it that i'm trying to figure out if it is fixed by this

[15:05:02.0000] <bradleymeck>
i'd have to dig this up but i remember i had to defer processing on it too somewhere

[15:05:05.0000] <Bakkot>
call is also not fixed by this probably

[15:05:07.0000] <bradleymeck>
not going to do that right now

[15:05:34.0000] <bradleymeck>
I really just want the locations to state if they are a reference vs an eager Get()

[15:06:24.0000] <Bakkot>
yeah, this doesn't help that at all, unfortunately :(

[15:06:47.0000] <bradleymeck>
ah that was it, i had to propagate the receiver until i knew if it was a ref vs get

[15:08:12.0000] <Bakkot>
if you have a bunch of code looking for member access, this change would require you to rewrite that code

[15:08:16.0000] <Bakkot>
which is an argument against doing this change

[15:08:17.0000] <bradleymeck>
i don't understand Call in that gist

[15:09:09.0000] <bradleymeck>
i think breaking changes are fine here? this doesn't look to utterly change things like splitting Reference from Lookup

[15:09:28.0000] <Bakkot>
`f()` would be represented as `{ type: 'MemberAccessOrCall', optional: false, base: Identifier('f'), first: { type: 'Call', args: [] }, rest: [] }`

[15:09:43.0000] <Bakkot>
`f?.()` would be just the same except with `optional: true`

[15:10:19.0000] <bradleymeck>
ah

[15:10:22.0000] <Bakkot>
`a.b()` would be `{ type: 'MemberAccessOrCall', optional: false, base: Identifier('a'), first: { type: 'StaticPropertyAccess', name: 'b' }, rest: [{ type: 'Call', args: [] }] }`

[15:12:06.0000] <Bakkot>
so, yeah, this would actually make it harder to figure out if you were doing a member call, I think

[15:12:52.0000] <Bakkot>
I guess from the `StaticPropertyAccess` it's just a matter of looking to see if the next part is a Call node

[15:13:05.0000] <Bakkot>
(or a tagged template node? do tagged template calls set `this`?)

[15:13:32.0000] <Bakkot>
(answer: yes)

[15:18:47.0000] <devsnek>
Bakkot: seems complex

[15:20:46.0000] <rkirsling>
is your AST concerned with ease of short-circuiting? or just surface appearance?

[15:21:03.0000] <rkirsling>
'cause those lead to very different ways of handling ?.

[15:21:30.0000] <Bakkot>
devsnek it's almost identical to yours, just folding in regular member access

[15:22:03.0000] <Bakkot>
and using an actual list of parts instead of an ADT-list, I guess

[15:22:47.0000] <Bakkot>
rkirsling the goal for the AST is that it's relatively easy too analyze

[15:22:59.0000] <rkirsling>
yeah

[15:23:16.0000] <Bakkot>
so, yes, it needs to represent short-circuiting, not just stick an "optional" property on member access

[15:24:05.0000] <rkirsling>
right

[15:24:37.0000] <rkirsling>
not sure if I showed this before but JSC does this: https://usercontent.irccloud-cdn.com/file/L4KWhjS9/jsc-optional-chaining-ast

[15:27:41.0000] <rkirsling>
JSC also has this wild menagerie of function call nodes, which V8 does not, but

[15:28:35.0000] <Bakkot>
yeah, for codegen I think it doesn't matter much

[15:28:59.0000] <rkirsling>
this structure made it easy to generate the appropriate bytecode even in wacky nested cases

[15:29:00.0000] <Bakkot>
a thing we care about is, there should as much as possible be a 1-1 relationship between well-typed ASTs and actual programs

[15:30:00.0000] <Bakkot>
what does your AST for `a?.b.c` look like?

[15:31:37.0000] <rkirsling>
same as above except for the right branch, I think

[15:35:35.0000] <devsnek>
I just added an optional field to member expressions in v8

[15:36:03.0000] <devsnek>
and a root optional chain node for the jump location


2020-10-28
[08:45:03.0000] <gibson042>
bradleymeck: the best I can come up for safe `super` delegation is *mostly* syntax, but still requires privileged access to some intrinsics: super(...(%Object.defineProperties%)( (function*(i=0){ while(i<args.length) yield args[i++] })(), {[%Symbol.iterator%]:{value(){return this}}, next:{value:%GeneratorPrototype.next%}} ))

[08:45:33.0000] <bradleymeck>
gibson042: yea, i simply think spread isn't sane to try and lock down given how it is specified currently

[08:45:50.0000] <bradleymeck>
none of the default iterators are robust

[08:46:20.0000] <bradleymeck>
so, spec text seems fine

[08:49:30.0000] <rwaldron->
rkirsling ptal https://github.com/tc39/test262/pull/2880

[08:54:20.0000] <gibson042>
I'm thinking about even authoring robust code

[08:57:40.0000] <gibson042>
spread sucks, but you can't do super.apply(this, args)

[09:01:45.0000] <gibson042>
it would be really cool to either reify `super` or make `...arguments` safe

[09:24:49.0000] <ljharb>
i really like making it safe for arrays specifically.

[09:24:53.0000] <Bakkot>
it is super weird that `...arguments` delegates to A.p.values

[09:24:58.0000] <ljharb>
+1

[09:25:31.0000] <Bakkot>
though I guess at least it delegates to the intrinsic one rather than looking it up?

[09:25:53.0000] <Bakkot>
oh, yeah, I think `...arguments` is actually safe

[09:26:00.0000] <Bakkot>
why did we think it is not safe?

[09:26:07.0000] <ljharb>
Bakkot: the `next` method is looked up, i think

[09:26:11.0000] <Bakkot>
ahhh

[09:26:15.0000] <ljharb>
like, it's safe til it gets the iterator, but not after

[09:26:21.0000] <Bakkot>
gotcha

[09:27:37.0000] <gibson042>
which affects arrays, strings, arguments, generators... ALL THE THINGS

[09:27:46.0000] <Bakkot>
wonder if anyone is actually patching ArrayIteratorPrototype.next

[10:38:50.0000] <ljharb>
fwiw, es6-shim doesn't (it only provides its own ArrayIterator when needed)

[10:39:00.0000] <ljharb>
core-js might tho

[15:27:25.0000] <Bakkot>
rkirsling: are you planning to add https://github.com/tc39/ecma262/pull/2210 to the November agenda?

[15:28:58.0000] <rkirsling>
I was hoping it fell under "things overlooked in the merge of #2164"

[15:30:14.0000] <Bakkot>
that one wasn't overlooked, though, right? my impression was that we explicitly got consensus for the currently spec'd behavior, rather than failing to consider it as with 2207

[15:30:49.0000] <rkirsling>
I mean it is tied to web reality for the detached case

[15:31:34.0000] <rkirsling>
it's just that the non-detached OOB path is separate (if we decided that detached and OOB don't have to behave identically, though that would be unprecedented)

[15:33:45.0000] <rkirsling>
er s/decided/consider/

[15:36:25.0000] <Bakkot>
was consensus on specing web reality or on the specific PR?

[15:39:01.0000] <rkirsling>
that is the question; my understanding was "let's make TA EIMs stop violating web reality"

[15:39:30.0000] <rkirsling>
though it's true that I gave a specific list of the entailed changes in the PR description

[15:39:51.0000] <rkirsling>
but it's a thorny area and it doesn't come as a huge surprise that there were ripple effects

[15:41:07.0000] <rkirsling>
hence I feel like it boils down to whether each ripple effect forces our hand in a particular way or raises a question with two valid answers

[15:41:48.0000] <rkirsling>
it would only seem necessary to me to ask for further consensus in a scenario clearly falling into the latter bucket

[15:57:58.0000] <rkirsling>
(also if we *do* need to ask for consensus I might need to beg for assistance; in addition to timezone worries, this meeting falls right into our "all hands on deck" period for PS5 launch)

[16:04:57.0000] <Bakkot>
we've generally asked for consensus even for changes necessary for web reality

[16:05:03.0000] <Bakkot>
I am happy to present it though

[16:05:25.0000] <Bakkot>
I don't have super strong feelings either way, just a general sense that this is normative-enough to want consensus

[16:05:38.0000] <rkirsling>
that's fair

[16:05:39.0000] <Bakkot>
shu, thoughts?

[16:06:16.0000] <shu>
reading backlog, sec

[16:07:24.0000] <shu>
my take is the consensus was tantamount to "align the spec with implementation reality for the obvious cases"

[16:10:26.0000] <shu>
in #2210's case, i agree with rkirsling in that the point is our hands are kinda tied with OOB not throwing

[16:12:57.0000] <shu>
delaying merging it doesn't hurt anything or reflects reality. i don't think it needs consensus mainly because i don't think it's a good use of our time to discuss it in depth

[16:13:04.0000] <shu>
in plenary, that is

[16:13:47.0000] <shu>
s/reflects/affects

[16:14:04.0000] <Bakkot>
we rarely end up discussing this sort of thing in depth

[16:14:23.0000] <shu>
so i think i'd lump it in the editor update as another thing that's normative, but doesn't seem like there's any real design needed here, please read the PR if you care about TAs

[16:14:34.0000] <shu>
and if there're no concerns at the end of the plenary, we'll consider it having consensus

[16:15:00.0000] <Bakkot>
wfm

[16:15:07.0000] <Bakkot>
though, actuall

[16:15:08.0000] <Bakkot>
y

[16:15:16.0000] <Bakkot>
I would prefer to call it out as its own agenda item

[16:15:27.0000] <shu>
sure, that sgtm

[16:15:31.0000] <Bakkot>
since multiple people have raised concerns about not being able to review things which weren't called out on the agenda

[16:15:37.0000] <shu>
yeah, good call

[16:17:17.0000] <rkirsling>
🙇‍♂️ regardless

[16:17:38.0000] <shu>
you're working on behalf of millions of people's mental health for ps5

[16:17:42.0000] <shu>
though i never put in a preorder

[16:17:43.0000] <rkirsling>
<3

[16:17:51.0000] <rkirsling>
my own included lol

[16:20:03.0000] <rkirsling>
wrt https://github.com/tc39/ecma262/pull/2207#issuecomment-718243712 I'm technically on PTO but I could take care of it a bit later

[16:22:42.0000] <shu>
nah, don't work during pto, it's not very urgent imo

[16:24:11.0000] <rkirsling>
thanks

[16:24:32.0000] <rkirsling>
the fact that I'm terrible at taking breaks is the reason I'm on PTO in the first place...


2020-10-29
[19:55:21.0000] <Bakkot>
shu: did you plan to add https://github.com/tc39/ecma262/pull/2205 to the agenda for november?

[20:01:05.0000] <shu>
Bakkot: yes, i have other items as well planned and was gonna do them all at once

[20:01:13.0000] <Bakkot>
kk

[09:34:01.0000] <devsnek>
rkirsling: https://gc.gy/71694236.png

[09:34:05.0000] <devsnek>
shouldn't this be 1?

[09:34:25.0000] <devsnek>
since once the buffer is detached, it doesn't have an own `1` property anymore? so no callback will be triggered

[09:36:10.0000] <devsnek>
oops meant rwaldron-: ^

[09:44:33.0000] <devsnek>
shouldn't this be 42? https://gc.gy/71694864.png


2020-10-30
[10:02:59.0000] <jmdyck>
If ArrowFormalParameters is only ever 'invoked' with [~Yield, +Await], why does it bother taking parameters?

[10:12:56.0000] <Bakkot>
jmdyck it is invoked with other combinations as well, because of the cover grammar

[10:13:05.0000] <Bakkot>
see Supplemental Syntax under https://tc39.es/ecma262/#sec-arrow-function-definitions

[10:15:29.0000] <Bakkot>
though I don't think we ever spell out how flags interact with cover grammars, which is a failing

[10:15:38.0000] <jmdyck>
so ArrowFormalParameters is 'invoked' with the same settings as ArrowParameters

[10:16:17.0000] <Bakkot>
that is what I understand the intent to be, yes

[10:16:41.0000] <jmdyck>
tx

[16:16:24.0000] <devsnek>
i keep finding myself needing the bind operator

[16:20:17.0000] <jackworks>
https://github.com/surma/proposal-js-module-blocks

[16:20:27.0000] <jackworks>
I love this!

[16:21:48.0000] <jackworks>
devsnek: extension proposal will be presented in the next meeting, it can have the same function of bind op, have you checked that? 😆

[16:22:45.0000] <devsnek>
jackworks: the link is 404

[16:23:44.0000] <jackworks>
Oh wait, I'll tell the author to fix that

[16:24:05.0000] <devsnek>
haxjs: ^

