2019-06-02
[17:46:41.0000] <ningu>
is there a particular reason that the ecma standard is 262 and the committee is 39?

[17:48:04.0000] <ningu>
ok, I see that ECMA has various standards, so it makes sense 262 is only one of them

[17:48:09.0000] <ningu>
but does it have other technical committees? :P

[17:48:33.0000] <ningu>
apparently it does

[19:04:00.0000] <devsnek>
react hooks got me thinking

[19:04:13.0000] <devsnek>
what if there was a way to expose the location of a call expression as a symbol or something

[19:04:44.0000] <devsnek>
a while ago I made a little clone of hooks that uses tagged templates to this effect but it's obviously a strange api

[19:05:57.0000] <devsnek>
maybe react hooks are just a bad api and this is a silly topic but imo it does show off some interesting design patterns

[21:34:29.0000] <ljharb>
the requirement to call them in the same unconditional order imo is a bad API design


2019-06-03
[11:40:24.0000] <Domenic>
Has everyone seen TCO: the musical yet? https://www.youtube.com/watch?v=-PX0BV9hGZY

[11:59:12.0000] <ljharb>
that's amazing

[12:24:47.0000] <FireFly>
heh, indeed

[13:53:12.0000] <akirose>
this is incredible

[14:25:39.0000] <rkirsling>
üëè too good


2019-06-04
[01:48:26.0000] <ErrorIsNullError>
Jordan, I can hear you

[01:49:25.0000] <ljharb>
ErrorIsNullError: thanks - on the call?

[01:50:34.0000] <ErrorIsNullError>
Yes.

[01:55:58.0000] <joyee>
how do I rejoin the delegates channel?

[01:56:35.0000] <ljharb>
joyee: ping one of the chairs (aki, yulia, brian) to invite you

[01:56:51.0000] <joyee>
ljharb: k thanks

[01:59:07.0000] <akirose>
joyee: you have access, send `/msg ChanServ INVITE #tc39-delegates` if you can't get in

[02:00:08.0000] <joyee>
akirose: got it, thanks

[03:16:41.0000] <Bakkot>
any moddable folks on IRC? can you speak to how hard it would be to not output 'w' in this case? https://github.com/tc39/proposal-for-in-exploration/blob/dcca1337f04ee41567180c551beb94198297ce13/exploration/list-build-order.js

[03:17:06.0000] <Bakkot>
V8, SM, and JSC do not output it (Chakra does)

[08:55:37.0000] <joesepi>
Is this the document we were talking about in the newcomers meeting? https://timothygu.me/es-howto/

[09:04:05.0000] <devsnek>
I wasn't at the newcomers meeting but I can vouch that that is a really good document

[11:37:15.0000] <gibson042>
bterlson: ping on https://github.com/bterlson/ecmarkup/pulls

[11:47:05.0000] <bterlson>
gibson042: thanks for the ping, I've merged your recent PRs


2019-06-05
[02:06:58.0000] <TimothyGu>
joesepi: definitely could use some additions though‚Ä¶ PR welcome :)

[02:08:01.0000] <joesepi>
@TimothyGu: I will definitely read through it thoroughly and see how I can help.

[02:09:43.0000] <TimothyGu>
great!

[03:16:05.0000] <Domenic>
Does anyone remember any clashes between user code and specs for the global object? (Not prototype properties/methods.)

[03:17:41.0000] <Bakkot>
Domenic: I can't parse that

[03:18:14.0000] <Bakkot>
unless you mean "why didn't we call `globalThis` `global`"?

[03:18:14.0000] <Domenic>
Bakkot: like we clashed on Array.prototype.flatMap. But we did not clash on fetch or on Map or Set. Are there any clashes on the global that people remember?

[03:18:20.0000] <Domenic>
Oh right -_-

[03:18:20.0000] <Bakkot>
ah!

[03:18:26.0000] <Domenic>
Obviously globalThis is one hehe

[03:19:27.0000] <Bakkot>
global is actually the only one I can think of in js-land off the top of my head, though there might be others from the ES6 days


2019-06-06
[10:14:18.0000] <caitp>
Is anyone around who can answer some questions about the static class features proposal, WRT https://github.com/tc39/proposal-static-class-features/issues/38 ?

[10:17:07.0000] <caitp>
I'm assuming static fields are evaluated within the class lexical environment, and don't need any extra bindings like `this`, thus it doesn't need to be implemented as a method, right?

[11:41:35.0000] <ljharb>
caitp: i'm reasonable sure `class { static singleton = new this();  }` needs to work, if that's what you mean?

[11:43:04.0000] <caitp>
I don't think it should work, when `class C { static singleton = new C(); }` would work and do what is expected

[11:43:24.0000] <caitp>
makes a lot more sense than rebinding `this`

[11:48:54.0000] <ljharb>
the class fields proposal explicitly intended that to work

[11:49:15.0000] <ljharb>
(that `this` directly inside the class body is either the instance or the class)

[11:49:46.0000] <caitp>
where on earth is that stated? (that is a bad idea)

[11:53:21.0000] <ljharb>
why is it a bad idea??

[11:57:01.0000] <ljharb>
caitp: https://github.com/tc39/proposal-class-public-fields/issues/50

[11:58:56.0000] <caitp>
it's a bad idea because `this` changes meaning without crossing a function boundary

[11:59:26.0000] <ljharb>
it adds "the class boundary" as a place where it can change, and matches many people's intuition

[11:59:42.0000] <ljharb>
similarly, in an instance field, `foo = this`, `this` is the instance

[11:59:54.0000] <caitp>
class boundary really should not be a thing

[12:00:05.0000] <ljharb>
yet there's curly braces there :-p

[12:00:21.0000] <ljharb>
it sounds like in general you don't like the idea of fields at all tho

[12:00:35.0000] <ljharb>
the entire proposal is predicated on making "class boundary" a thing

[12:01:03.0000] <caitp>
nothing against fields, but `singleton = new this();` isn't any better than `singleton = new ClassName()`

[12:01:25.0000] <caitp>
which is arguably significantly easier to reason about

[12:01:37.0000] <caitp>
and doesn't prohbit accessing stuff from the real `this`

[12:03:16.0000] <caitp>
ClassName is in the lexical scope, has been since day 1, we should use that instead of doing some awkward stuff with `this`

[12:03:36.0000] <ljharb>
it's better because you don't have to repeat the classname in code

[12:03:44.0000] <ljharb>
and because not every class has a name at all

[12:03:55.0000] <ljharb>
ie an anonymous class expression

[12:04:09.0000] <caitp>
yeah so the solution there is to not use it in those cases innit

[12:04:13.0000] <ljharb>
lol

[12:04:20.0000] <ljharb>
that's one option

[12:05:45.0000] <caitp>
I'd rather provide a new metaproperty for people who really want to do that

[12:05:58.0000] <ljharb>
https://github.com/tc39/proposal-class-access-expressions

[12:06:00.0000] <caitp>
call it Self

[12:06:04.0000] <caitp>
make the rustaceans happy

[12:06:14.0000] <ljharb>
either way tho, `this` needs to be the instance inside instance fields

[12:06:24.0000] <ljharb>
so disallowing `this` in static fields doesn't seem very useful

[12:07:09.0000] <caitp>
I don't think you would disallow it, just let it evaluate to the `this` that already exists

[12:09:37.0000] <ljharb>
that'd be very confusing

[12:09:49.0000] <ljharb>
because tons of people expect it to be the class itself

[12:10:39.0000] <caitp>
I wouldn't expect it to be the class itself, I don't think I've ever written in any language where `this` refers to the class currently being defined

[12:11:04.0000] <caitp>
does python do that? maybe python does

[12:11:06.0000] <caitp>
but everybody hates python

[12:11:55.0000] <caitp>
excluding the possible exceptions of python/ruby/perl, what else does?

[12:16:06.0000] <caitp>
but anyways, regardless of all of that, where in the actual proposal does it say any of this?

[12:42:05.0000] <FireFly>
I would find overriding `this` with yet another meaning in another context to be confusing...

[12:43:49.0000] <FireFly>
in function expressions you have to specify a name if you want to refer to the function itself (e.g. to call it recursively) -- I would expect the same to be the case with class expressions

[12:44:42.0000] <FireFly>
How does `this` behave in static methods inside a class today?

[12:46:07.0000] <ljharb>
FireFly: it's the class

[12:46:12.0000] <FireFly>
Always?

[12:46:14.0000] <FireFly>
hmm

[12:47:20.0000] <FireFly>
alright, I guess it might make some sense (in that "usual rules" of method calls would make `this` be the class if you invoke it as Class.staticMethod())

[12:47:57.0000] <FireFly>
But it still seems a bit of a pity to me to add another rule to remember about what value `this` resolves to..

[12:52:02.0000] <ljharb>
caitp: i'm not sure where in the current proposal it says that tbh

[12:58:00.0000] <caitp>
"Define an own property on the constructor which is set to the value of the initializer expression. The initializer is evaluated in a scope where the binding of the class is available--unlike in computed property names, the class can be referred to from inside initializers without leading to a ReferenceError. The this value in the initializer is the constructor." << that is...

[12:58:18.0000] <caitp>
so we can have scope swapping before and after every initializer is evaluated, for no reason

[13:00:32.0000] <caitp>
I really don't see this as being something worth having in the spec, from a user perspective -or- implementor perspective

[13:01:09.0000] <caitp>
I will be ok with it if computed properties see the same `this` as initializers, but it's still nutso


2019-06-07
[17:12:54.0000] <akirose>
https://tc39.es

[17:14:15.0000] <rkirsling>
woohoo üéä

[19:52:43.0000] <devsnek>
akirose: i don't mean to be a bummer, but search engines downrank .es domains if your language isn't spanish

[19:52:57.0000] <devsnek>
httpstatus.es had this problem

[19:53:07.0000] <devsnek>
so they moved to httpstatuses.com

[19:55:29.0000] <devsnek>
(though it does get a serious boost if your language *is* set to spanish)

[23:38:57.0000] <FireFly>
huh

[03:09:50.0000] <akirose>
devsnek: we also have TC39.org. I‚Äôll put some thought into redirect/canonical/how much I actually care about SEO

[03:21:23.0000] <annevk>
akirose: given downstream effects of everyone having to update links and such it'd be nice if that decision could be made quickly, though I understand it's been a long week...

[03:22:42.0000] <annevk>
.org might be a little safer long term given the weird things that happen with country TLDs, though I suppose .es should be quite safe

[03:43:39.0000] <akirose>
Yeah I‚Äôm not feeling‚Ä¶ especially concerned about it.

[03:44:18.0000] <akirose>
For all of the community outreach and engagement that has been the priority of my chairing, I‚Ä¶ don‚Äôt especially care about SEO.

[03:48:13.0000] <rkirsling>
it only matters if people would have trouble finding the living spec as opposed to the snapshots

[03:48:42.0000] <rkirsling>
I hope devsnek's not implying that üò±

[07:50:58.0000] <caitp>
clearly the solution is to change the canonical language of ecma262 to spanish, no?

[07:55:56.0000] <oliverdunk>
TabAtkins: is there anything I could do to help move https://github.com/w3c/csswg-drafts/issues/4004 forward?

[08:01:32.0000] <TabAtkins>
Nah, we just need to discuss it in CSSWG. We just did our f2f, so next call will be in two weeks.

[08:02:04.0000] <oliverdunk>
Ok, thanks :)


2019-06-10
[21:42:32.0000] <TimothyGu>
akirose: is there a way to make http://tc39.es redirect to HTTPS?

[21:42:56.0000] <TimothyGu>
well, I guess that does redirect, but http://tc39.es/ecma262/ doesn't

[22:12:29.0000] <akirose>
Something something github pages?

[22:12:49.0000] <TimothyGu>
akirose: yeah I think there's a switch on tc39/ecma262

[22:13:50.0000] <akirose>
I‚Äôll take a peek tomorrow!

[23:07:25.0000] <ljharb>
TimothyGu: akirose fixed

[23:07:35.0000] <TimothyGu>
ljharb: thx

[06:38:20.0000] <devsnek>
wasn't there an arraybuffer realloc proposal at some point

[07:14:09.0000] <Domenic>
devsnek: yeah, https://github.com/domenic/proposal-arraybuffer-transfer/, which I haven't had time to get back to.

[09:01:14.0000] <towc>
hey all! Has there already been a proposal on making Math.random reproducible?

[09:02:17.0000] <towc>
it seems like a pretty crucial part of making tests pass, and as there's more and more data science tools for JS, it might be nice to not need to go to external libraries for seedable randomness

[09:03:48.0000] <devsnek>
towc: https://github.com/tc39/proposal-seeded-random

[09:04:14.0000] <towc>
oh neat!

[09:04:15.0000] <towc>
thanks

[09:05:03.0000] <towc>
oh, I don't know how much I like the choices from that proposal, but it's something

[09:05:31.0000] <devsnek>
lol

[09:05:37.0000] <devsnek>
welcome to language design

[09:08:57.0000] <towc>
TabAtkins: can we talk about this? I don't see how you couldn't just have something like `Math.seedRandom(<seed>)` once. Sure, this would be global and that might be undesired in many cases, but I think it will cover 95% of all seeding needs. A generator could still be used, as another function

[09:10:12.0000] <devsnek>
`Math.seededPRNG({ seed }).next().value`?

[09:10:51.0000] <towc>
I mean that this is fine. A bit clunky, but fine. I'd just love it if there was going to be a simpler solution for simpler cases

[09:11:51.0000] <towc>
also would be nice to make already existing code (that uses Math.random) be reproducible

[09:13:09.0000] <towc>
and that might require a lot of restructuring, if the only solution is this definition of `seededPRNG`

[10:07:46.0000] <towc>
and how about a way to destructure a default import?

[10:08:06.0000] <towc>
something like `import ({ a, b }) from './exports/default'`

[11:19:06.0000] <ljharb>
towc: that'd be confusing since `import { a, b }` already isn't destructuring

[11:20:19.0000] <towc>
well, then an additional keyword maybe?

[11:21:10.0000] <towc>
`import default as { a, b } from './exports/default'`?

[11:21:22.0000] <towc>
actually, can you use `as` for this already?

[11:23:34.0000] <ljharb>
you can `import { a as b }` already

[11:23:46.0000] <ljharb>
what's the benefit of inline destructuring there? just avoiding a second line?

[11:31:03.0000] <towc>
I'd argue that's pretty important actually

[11:31:17.0000] <towc>
imports should be your first statements

[11:31:29.0000] <towc>
that means that the second line could be quite a ways down

[11:31:44.0000] <towc>
and I don't see why it should

[11:32:29.0000] <towc>
plus, there's one more unneeded item in your namespace, which might not be a big deal, but damn, it bothers me :/

[11:33:12.0000] <towc>
and I meant using `as` to destructure a default import

[11:33:52.0000] <towc>
if it's possible, I can't get it to work

[11:34:19.0000] <towc>
intuitively, it would be `import itemWhoseNameMightBeThrownAway as { a, b } from './exports/default'`

[11:34:33.0000] <towc>
but that's invalid syntax

[11:36:35.0000] <towc>
or more meaningfully, `import as { a, b } from './exports/default'`

[11:37:08.0000] <ljharb>
towc: it always could be, but you can put it immediately afterwards

[11:37:13.0000] <ljharb>
allowing destructuring inline won't force it

[11:39:30.0000] <towc>
I'd rather avoid polluting the "import" part of my scripts

[11:39:37.0000] <towc>
but sure

[11:40:45.0000] <devsnek>
if your default import commonly needs to be destructured

[11:40:52.0000] <devsnek>
perhaps it should be multiple named exports

[11:41:04.0000] <ljharb>
^

[13:56:22.0000] <towc>
apparently the airbnb styleguide favours default exports

[13:56:53.0000] <devsnek>
if you only export one thing*

[13:57:29.0000] <towc>
and when writing tests, if I import named exports at the beginning, and they don't exist, the whole test fails, without going through what could still be tested

[13:57:47.0000] <towc>
oh, it says that?

[13:59:00.0000] <towc>
oh, it does

[13:59:02.0000] <ljharb>
towc: yes, it favors default exports almost always

[13:59:14.0000] <towc>
well, my linter didn't tell me that

[13:59:19.0000] <towc>
'^^

[13:59:22.0000] <ljharb>
towc: the principle is, that a default export is what a module *is*, and a named export is what a module *has*. most every module should *be* something.

[13:59:58.0000] <towc>
how about a `util` module?

[14:01:02.0000] <ljharb>
certainly that has many things, but i'd also say, don't have util modules :-)

[14:01:28.0000] <towc>
where do you put your generic helpers?

[14:01:51.0000] <towc>
sure, probably someone already wrote something that covers that

[14:02:13.0000] <towc>
but I also don't want to combine many coding styles

[14:02:49.0000] <devsnek>
a file for each util https://github.com/engine262/engine262/tree/master/src/static-semantics

[14:03:08.0000] <devsnek>
oheck the ci failed

[14:03:24.0000] <towc>
oh my, that's worrying

[14:24:57.0000] <ljharb>
towc: i use folders, not files, to group modules.


2019-06-12
[10:24:38.0000] <devsnek>
has there ever been something proposed to check if a function can be constructed

[11:05:28.0000] <ljharb>
devsnek: https://esdiscuss.org/topic/add-reflect-isconstructor-and-reflect-iscallable#content-2 but i don't think anyone proposed it

[11:09:37.0000] <devsnek>
ljharb: it's in the 2015/01 agenda

[11:10:56.0000] <ljharb>
oh snap, i have no recollection of it. What happened?

[11:17:42.0000] <gkatsev>
apparently, it wasn't discussed at all

[11:21:57.0000] <devsnek>
lol

[11:46:03.0000] <ljharb>
jorendorff: you put the item on that agenda; do you recall why it wasn't discussed/never came back?

[11:58:29.0000] <jorendorff>
ljharb: no, i don't remember

[12:01:43.0000] <ljharb>
want to put it back on? :-p


2019-06-13
[20:23:56.0000] <Domenic>
I vaguely recall there being a discussion, which concluded a few things: adding an alias for typeof === "function" is kind of silly; Reflect is not the right place; and if what's left is isConstructor, do we have any real use cases?

[20:34:12.0000] <TimothyGu>
the discussion Domenic is talking about seems to be https://esdiscuss.org/topic/determine-if-a-value-is-callable-constructible

[20:34:29.0000] <Domenic>
OK, I guess it didn't happen in committee, my memory just assumed it did

[20:36:03.0000] <Domenic>
And apparently I mostly remembered my own points, so yay

[20:36:09.0000] <TimothyGu>
lol

[21:06:44.0000] <TimothyGu>
bterlson:

[21:06:46.0000] <TimothyGu>
oops

[21:07:30.0000] <TimothyGu>
bterlson: is it possible to suppress ecmarkup autolinking for a particular instance?

[21:34:39.0000] <ljharb>
isCallable would ideally return false for a class, tho

[21:35:07.0000] <ljharb>
it seems absurd to me to install a [[Call]] slot for no other purpose than to make `typeof` return "function", since we could also change typeof to check [[Call]] or [[Construct]]

[07:19:07.0000] <devsnek>
isConstructor comes up every once in a while when I'm working on polyfilling something or trying to match certain semantics that engines have

[07:20:46.0000] <devsnek>
most recently (and what prompted me to post this) was that node's napi can check if something is callable/constructable for napi_new_instance and napi_call and return early, but I can't duplicate this behaviour

[08:55:29.0000] <ErrorIsNullError>
Stupid question: in ecmarkup, does the '?' instead of a '!' before a call indicate that it might be nullish or that it might be falsey?

[08:56:12.0000] <jmdyck>
neither, it indicates that the result might be an abrupt completion.

[08:56:27.0000] <ErrorIsNullError>
Ah.  Thanks for explaining.

[08:56:49.0000] <ErrorIsNullError>
So the recursive call in isArray

[08:56:51.0000] <ErrorIsNullError>
	a.	Return ?¬†https://tc39.es/ecma262/#sec-isarray(target).

[08:57:22.0000] <ErrorIsNullError>
Is '?' because it might return abruptly if a nested proxyhandler is null.

[08:57:36.0000] <ErrorIsNullError>
Err

[08:57:46.0000] <ErrorIsNullError>
    a.  Return ? IsArray(target).

[08:58:33.0000] <jmdyck>
if the top-level arg is a proxy whose target is a proxy whose handler is null

[08:59:10.0000] <ErrorIsNullError>
yep

[09:02:24.0000] <devsnek>
ErrorIsNullError: ? and ! are macros

[09:02:54.0000] <ErrorIsNullError>
Thanks for explaining.  I see section 5.2.3.4 now.

[09:03:06.0000] <ErrorIsNullError>
ReturnIfAbrupt shorthands.

[09:03:13.0000] <devsnek>
yep

[09:03:15.0000] <ErrorIsNullError>
I had been looking in ecmarkup and ecmarkdown.

[09:03:15.0000] <devsnek>
was about to link

[16:05:28.0000] <TimothyGu>
jmdyck: next time, feel free to link https://timothygu.me/es-howto/#completion-records-and-shorthands :)


2019-06-14
[05:26:37.0000] <sberkov>
What do you think of `nameof` operator? In C# there is `nameof`, in Swift you can do the same by calling `let keyPath = \Person.mother.firstName NSPredicate(format: "%K == %@", keyPath, "Andrew")`. Let's introduce `nameof` in ES, please.

[05:28:31.0000] <sberkov>
Devs from TypeScript don't want to introduce this feature in TypeScript unless it is available in ES ( https://github.com/microsoft/TypeScript/issues/1579 )

[07:23:33.0000] <caitp>
gsathya: do you know if computed property names for static class fields are intended to be evaluated before the initializer (like in object literals)? Or is it just sort of UB?

[07:27:21.0000] <gsathya>
they are computed at class definition time, so yes before the initializer

[07:47:09.0000] <caitp>
they're defined on the class at definition time also

[07:48:43.0000] <caitp>
but, my question was misguided, for some reason I forgot there was an actual spec in the proposal, not just the github README

[07:48:58.0000] <caitp>
so I'm sure it's defined clearly.

[14:50:33.0000] <caiolima>
ljharb: are you around?

[14:51:51.0000] <ljharb>
caiolima: yo

[14:54:07.0000] <caiolima>
ljharb: I'm thinking into change the charset into https://github.com/tc39/ecma262/pull/1135. Also, this is blocking BigInt PR as well and I think we need more reviews, right?

[14:54:27.0000] <caiolima>
I'm wondering how can we get it...

[14:58:03.0000] <ljharb>
caiolima: we talked about it in this week's editor meeting; it's high on the list

[14:59:33.0000] <ljharb>
caiolima: changing the charset seems fine to me

[15:00:20.0000] <caiolima>
ljharb: Thx for the update! I'll rebase + include change on charset then.

[15:05:35.0000] <ljharb>
caiolima: great! if you *want* you could also change the base branch of the bigint PR to be the number PR, and then rebase the bigint PR?

[15:05:44.0000] <ljharb>
that way the diffs will be readable and the merge conflicts will be pre-resolved

[15:06:07.0000] <ljharb>
(rebase the bigint pr on top of the number PR)

[15:06:42.0000] <caiolima>
ljharb: SGTM


2019-06-15
[15:32:56.0000] <devsnek>
why does everything fail this test https://github.com/tc39/test262/pull/2177/files

[15:33:06.0000] <devsnek>
even engine262 fails this test, and i can't figure out why

[15:48:41.0000] <ljharb>
devsnek: they fail an even simpler one: `Reflect.construct(Object, { b: 2 })` matching `new Object({ b: 2 })`

[15:49:05.0000] <devsnek>
i'm having trouble following why any of these engines fail this though

[15:49:27.0000] <ljharb>
you mean like, why they're implemented in a way such that it fails?

[15:49:39.0000] <devsnek>
yeah

[15:50:04.0000] <ljharb>
my uneducated guess is, Object is legacy, Reflect.construct probably has a bunch of edge case bugs with pre-ES6 builtins

[15:50:31.0000] <ljharb>
oh wait

[15:50:40.0000] <ljharb>
`Reflect.construct(Object, [{ b: 2 }])` does work, my bad

[15:50:40.0000] <devsnek>
doesn't this weird you out

[15:51:26.0000] <ljharb>
so it's not even Reflect.construct, it's that `extends Object` doesn't seem to work

[15:51:49.0000] <ljharb>
ie `new class extends Object {} ({ b: 2 }).b === 2` fails

[15:52:25.0000] <devsnek>
yes

[15:58:11.0000] <rkirsling>
fwiw `constructor(x) { super(x); }` doesn't help though I guess it'd be even more worrying if it did

[16:00:59.0000] <devsnek>
i legit can't figure out why this doesn't work

[16:02:13.0000] <devsnek>
rkirsling: that's the default constructor anyway

[16:03:32.0000] <devsnek>
ugh that reminds me of how annoying this spacing is `constructor(... args){ super (...args);}`

[16:03:53.0000] <rkirsling>
yeah exactly

[16:04:06.0000] <devsnek>
did they do that just to annoy people

[16:04:16.0000] <rkirsling>
wait where is that spacing from?

[16:04:19.0000] <devsnek>
the spec

[16:04:37.0000] <devsnek>
https://tc39.es/ecma262/#sec-runtime-semantics-classdefinitionevaluation

[16:04:43.0000] <devsnek>
step 10

[16:04:58.0000] <rkirsling>
oof

[16:05:04.0000] <rkirsling>
if you don't PR that, I might

[16:05:10.0000] <devsnek>
i was afraid to

[16:05:18.0000] <devsnek>
like it might start some battle about styles

[16:06:36.0000] <rkirsling>
perhaps. that section appears to be unique though

[16:07:09.0000] <devsnek>
it's the only place in the entire spec that defines builtin behaviour in terms of source code

[16:07:36.0000] <devsnek>
usually there'd be a builtin function

[16:07:36.0000] <rkirsling>
yeah I wonder why

[16:07:57.0000] <rkirsling>
maybe that's the real fix? but I don't have the background / have only looked at this for a few seconds

[16:08:15.0000] <devsnek>
ü§∑

[16:08:29.0000] <devsnek>
i'm still just trying to figure out why engine262 fails this thing

[16:08:34.0000] <rkirsling>
like even just taking out the spaces there would be acceptable to be

[16:08:38.0000] <rkirsling>
*to me

[16:08:46.0000] <devsnek>
just any sort of consistency

[16:08:51.0000] <rkirsling>
'cause there's `f(){}` elsewhere which is fine

[16:09:25.0000] <rkirsling>
as well as the note here: https://tc39.es/ecma262/#sec-declarative-environment-records-setmutablebinding-n-v-s

[16:10:02.0000] <devsnek>
the code in the string has extra space thouguh

[16:10:14.0000] <rkirsling>
lol true

[16:11:41.0000] <devsnek>
ok so in this test

[16:11:57.0000] <devsnek>
active function is `Object`

[16:12:18.0000] <devsnek>
`NewTarget` is `O`

[16:12:45.0000] <devsnek>
so it should return OrdinaryCreateFromConstructor right?

[16:13:23.0000] <devsnek>
that makes me feel like chakra is wrong and everything else is right

[16:13:40.0000] <devsnek>
am i reading this wrong

[16:24:54.0000] <devsnek>
https://gc.gy/405dd6cb-02ea-4795-bfe4-8a484a67d3eb.png

[16:45:29.0000] <rkirsling>
huh that is interesting

[16:45:53.0000] <rkirsling>
also #1482 must have containined an ecmarkdown typo

[16:46:08.0000] <rkirsling>
digging for it now

[16:46:19.0000] <rkirsling>
*contained even

[16:53:06.0000] <rkirsling>
lol `&lt;` and... `&rt;`

[16:53:18.0000] <devsnek>
üëç

[16:54:20.0000] <rkirsling>
oh hm. that was part of it but evidently not all of it.


2019-06-16
[17:10:27.0000] <rkirsling>
ah, there was an HTML comment added adjacent to ecmarkdown inside of an <li>

[17:28:57.0000] <rkirsling>
if it weren't for the ecma262 repo, I still wouldn't know how to git blame from the CLI lol

[20:18:54.0000] <null93>
Hi all, has there been any proposals for the "not" keyword to be added? Searched the repo and came up with none. Particularly, I would love to have the 'not' keyword be used in this manner: if ( "key" not in someObj ) {}

[20:55:26.0000] <ljharb>
null93: adding a new bareword in unlikely; in this case, it‚Äôd have to be a modifier on more than just ‚Äúin‚Äù. also i think there‚Äôs far more of a use case for a ‚Äúhas‚Äù operator if we‚Äôre going to add a new keyword :-)

[21:18:25.0000] <null93>
Understandable, thought i'd throw it out there. Thanks!

[21:59:13.0000] <ljharb>
rkirsling: can you elaborate on the html comment thing?

[22:10:47.0000] <jmdyck>
rkirsling was probably referring to https://github.com/tc39/ecma262/pull/1482/files#diff-3540caefa502006d8a33cb1385720803R23445

[22:13:51.0000] <ljharb>
jmdyck: yeah but i mean, i don't get why that'd cause rendering issues

[22:14:55.0000] <jmdyck>
Did it? Doesn't seem to have.

[22:17:14.0000] <jmdyck>
oh yay, 1245 got merged.

[07:46:55.0000] <rkirsling>
ljharb: sorry, running on jetlag schedule here -- evidently that's what was preventing the markup from rendering. if you build HEAD~2 and ctrl-F for the backtick character, you'll see that instead of 28 results you get over 4700. I didn't dig deeply but the issue seems to be that the comment was directly adjacent to ecmarkdown text instead of another HTML element

[08:57:15.0000] <ljharb>
rkirsling: gotcha. want to file an ecmarkup bug? :-) ideally it either works or fails to build in that case rather than silently doing the wrong thing

[08:57:36.0000] <rkirsling>
ljharb: may as well :)

[08:57:43.0000] <ljharb>
yay ty

[09:19:23.0000] <rkirsling>
ljharb: https://github.com/bterlson/ecmarkup/issues/155

[09:22:14.0000] <ljharb>
thanks!

[09:23:05.0000] <rkirsling>
my pleasure


2019-06-18
[19:29:27.0000] <devsnek>
https://github.com/tc39/test262/blob/master/test/built-ins/Promise/all/invoke-resolve-get-error-close.js

[19:29:32.0000] <devsnek>
shouldn't returnCount be 1 here

[19:29:46.0000] <devsnek>
iteratorRecord.Done is false

[19:29:49.0000] <devsnek>
so IteratorClose is called

[19:29:56.0000] <devsnek>
which calls the iterator's return

[19:30:01.0000] <devsnek>
leobalter: cc

[19:31:39.0000] <devsnek>
seems like everything is failing it now https://test262.report/browse/built-ins/Promise/all/invoke-resolve-get-error-close.js

[19:33:02.0000] <rkirsling>
(whoa unrelated but big woot that XS is on there now too!)

[19:33:11.0000] <devsnek>
yeah that's pretty cool

[19:33:47.0000] <devsnek>
maybe one day engine262 will be on there too ü§û

[19:33:56.0000] <rkirsling>
:D

[19:34:15.0000] <devsnek>
i've implemented all the recent changes except dynamic import

[09:45:54.0000] <ErrorIsNullError>
Who might understand the history behind the requirement for dynamic import "Every call to HostImportModuleDynamically with the same¬†referencingScriptOrModule¬†and¬†specifier¬†arguments must conform to the¬†same¬†set of requirements above as previous calls do."

[09:47:54.0000] <ErrorIsNullError>
Is that meant to allow devs to reason about the cost of dynamic import with a constant value in a loop?

[09:49:18.0000] <ErrorIsNullError>
Or does this allow some engine implementors to do some extra caching?

[09:51:20.0000] <ljharb>
ErrorIsNullError: is there something you want to do that requirement prevents?

[09:51:52.0000] <ErrorIsNullError>
On the trusted types front.

[09:52:12.0000] <ErrorIsNullError>
we'd like to treat import() as a sink and guard it.

[09:52:44.0000] <ErrorIsNullError>
import('data:text/javascript,‚Ä¶') has been a CSP bypass.

[09:53:10.0000] <ErrorIsNullError>
So I have an agenda, but I'm mostly trying to understand how the pieces fit together right now.

[09:53:56.0000] <ErrorIsNullError>
I'm trying to understand the need for that in light of the later requirement in HostResolveImportModule: "This operation must be idempotent if it completes normally. Each time it is called with a specific¬†referencingScriptOrModule,¬†specifier¬†pair as arguments it must return the same¬†https://tc39.github.io/ecma262/#sec-abstract-module-records¬†instance."

[09:54:09.0000] <ljharb>
to me that just means it can't change over the life of the program

[09:54:35.0000] <ljharb>
you could block it during linking, or you could allow it, but once it fails or succeeds, it can't change out from under you

[09:54:50.0000] <ErrorIsNullError>
My question is more about the intent.

[09:55:11.0000] <ljharb>
Domenic and littledan can probably speak to that best - the above is just my interpretation of the intent

[09:55:11.0000] <ErrorIsNullError>
It seems like an implemenation that did not have the problem would cause confusion.

[09:55:20.0000] <ErrorIsNullError>
Thanks

[09:56:27.0000] <ErrorIsNullError>
I'll reach out to them.

[11:00:13.0000] <devsnek>
ErrorIsNullError: as in `import(x)` in one area could work while `import(x)` in another area fails?

[11:01:04.0000] <devsnek>
i think the intention is that when it succeeds it must always be the same result, not that once it succeeds it must always succeed

[11:06:00.0000] <devsnek>
Domenic: ^

[11:11:52.0000] <ljharb>
devsnek: "That is, if the host environment takes the success path once for a given referencingScriptOrModule, specifier pair, it must always do so, and the same for the failure path." https://tc39.es/ecma262/#sec-hostimportmoduledynamically

[11:12:49.0000] <devsnek>
yeah in a given module

[11:13:24.0000] <devsnek>
for csp wouldn't it be different sources

[11:15:11.0000] <ljharb>
ah right, true

[11:16:08.0000] <devsnek>
actually for different sources

[11:16:40.0000] <devsnek>
the rule is always for (referrer, specifier)

[11:16:44.0000] <devsnek>
not the resulting module

[13:18:59.0000] <littledan>
Right, in different modules the resolution can be different, e.g., due to a different base URL (and with import maps, due to scoped maps)

[13:19:18.0000] <littledan>
So this is what "with the same referencingScriptOrModule and specifier arguments " is getting at

[13:47:37.0000] <ljharb>
and i guess import maps can already remap the specifier for a given module to be "nothing" as well?


2019-06-19
[10:48:43.0000] <keith_mi_>
Does anyone know if anyone has proposed a if (let myVariable = ...) { } syntax before?

[10:48:45.0000] <keith_mi_>
I couldn't find anything.

[10:55:13.0000] <rkirsling>
interesting...would be surprising if it were never discussed, given its existence in other langs ü§î

[11:02:05.0000] <devsnek>
keith_mi_: what's the `...`

[11:02:25.0000] <devsnek>
usually `if let` is part of pattern matching right?

[11:02:30.0000] <keith_mi_>
devsnek: Some expression that you want to bind

[11:02:56.0000] <keith_mi_>
like if (let foo = bar.baz())

[11:03:05.0000] <cloudshu>
keith_mi_: spidermonkey used to have let expressions but not quite that form i don't think

[11:03:27.0000] <keith_mi_>
basically any RHS expression

[11:03:44.0000] <keith_mi_>
ok, I make a proposal then

[11:04:02.0000] <devsnek>
is this always truthy?

[11:04:04.0000] <devsnek>
always falsy?

[11:04:09.0000] <cloudshu>
it looks real odd by today's standards `let (x = y) z`

[11:04:38.0000] <cloudshu>
what is always truthy or always falsy?

[11:04:43.0000] <devsnek>
like

[11:04:48.0000] <devsnek>
when does this if block run

[11:04:51.0000] <keith_mi_>
it's truthy if the RHS is truthy

[11:04:57.0000] <cloudshu>
yeah, like in C i imagine

[11:05:06.0000] <devsnek>
i wasn't aware this was a thing in C

[11:05:09.0000] <devsnek>
but ok

[11:05:16.0000] <cloudshu>
if (let foo = bar()) runs when bar() is truthy

[11:05:22.0000] <keith_mi_>
it's sugar for { let variable = expression; if (variable) { ... } }

[11:05:27.0000] <devsnek>
ok

[11:05:33.0000] <cloudshu>
keith_mi_: real talk do you want the binding to be available in the else branch

[11:05:39.0000] <keith_mi_>
no

[11:05:42.0000] <cloudshu>
o really

[11:05:52.0000] <devsnek>
would interact weirdly with `else if (let`

[11:05:52.0000] <keith_mi_>
I mean that's not how any other language does it

[11:06:02.0000] <devsnek>
you'd just stack up declarations

[11:06:16.0000] <keith_mi_>
I guess it's not quite sugar then...

[11:06:18.0000] <keith_mi_>
but yeah

[11:06:44.0000] <rkirsling>
I mean we're just talking about https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions, yeah?

[11:06:59.0000] <devsnek>
no

[11:07:05.0000] <devsnek>
that's what i thought this was too

[11:07:09.0000] <rkirsling>
except for the parens difference and the expression difference

[11:07:10.0000] <keith_mi_>
no that's doing destructuring

[11:07:20.0000] <cloudshu>
keith_mi_: that breaks with c

[11:07:22.0000] <keith_mi_>
which you could do here possibly

[11:07:25.0000] <cloudshu>
keith_mi_: in c the binding is available in both branches

[11:07:32.0000] <keith_mi_>
wait really?

[11:08:19.0000] <keith_mi_>
oh wow...

[11:09:09.0000] <keith_mi_>
idk I'm neutral on it being on both sides

[11:09:34.0000] <rkirsling>
er sorry, I guess Rust is hard to compare with since do exprs and pattern matching are outstanding, but lemme rephrase

[11:09:44.0000] <devsnek>
c isn't exactly a gold standard of language design

[11:10:04.0000] <rkirsling>
we're talking about C++17 "if auto", right?

[11:10:26.0000] <ljharb>
it seems gross to me to further conflate assignment with expressions

[11:10:28.0000] <keith_mi_>
If we ever had a pattern matching proposal we could choose something else to indicate you wanted a pattern match here

[11:10:32.0000] <devsnek>
`if (type = x`

[11:10:36.0000] <devsnek>
type could be auto

[11:10:44.0000] <ljharb>
i'd rather see us make assignments become statements if it were web compat :-)

[11:11:05.0000] <devsnek>
something something `let` reserved keyword

[11:11:26.0000] <rkirsling>
hmm yeah I'm inclined to agree that if we did this it should be after Kat and Dave get their stuff through :P

[11:11:51.0000] <rkirsling>
üò±

[11:12:25.0000] <devsnek>
is the matching proposal still weird

[11:12:53.0000] <zkat>
the pattern matching proposal mentions things like `if let`, iirc

[11:13:12.0000] <devsnek>
i just want matching as an expression

[11:13:12.0000] <zkat>
devsnek: what was weird about it? It's recently been updated, to support expressions.

[11:13:23.0000] <devsnek>
oh ok

[11:13:26.0000] <zkat>
then yes, there's expressions, in a limited sense, thanks to littledan

[11:13:39.0000] <devsnek>
just using the entire match as an expression was what i wanted

[11:13:45.0000] <zkat>
check out https://github.com/tc39/proposal-pattern-matching#motivating-examples

[11:13:50.0000] <devsnek>
yea just saw that

[11:13:52.0000] <devsnek>
üéâ

[11:13:57.0000] <zkat>
does that look like enough to you?

[11:14:11.0000] <devsnek>
looks more or less like what i imagined

[11:14:17.0000] <devsnek>
i'm kinda spoiled by rust though

[11:14:18.0000] <zkat>
like, not being able to do general-purpose expressions (so if you're in "expression mode", you can't use keywords and statements in legs)

[11:14:42.0000] <devsnek>
is that a left hand side expression

[11:14:59.0000] <zkat>
hm?

[11:15:15.0000] <devsnek>
the grammar of the expression side

[11:15:25.0000] <devsnek>
you said its not general-purpose expressions

[11:15:36.0000] <rkirsling>
seems like this bit is potentially directly relevant: https://github.com/tc39/proposal-pattern-matching/blob/latest/TO_INFINITY_AND_BEYOND.md#--if-case-convenience-sugar

[11:15:47.0000] <devsnek>
like has it been settled which expression production it is

[11:21:39.0000] <zkat>
I haven't messed with the grammar bits yet, no

[11:23:36.0000] <keith_mi_>
sorry had to get off the bus

[11:27:00.0000] <devsnek>
zkat: is `~x` a placeholder for `->`

[11:27:23.0000] <devsnek>
wait no that doesn't make sense

[11:27:38.0000] <zkat>
no, that was a reference to a now-dropped subproposal for extensible patterns

[11:27:53.0000] <devsnek>
oh ok

[11:28:38.0000] <zkat>
which might be replaces with `NewExpression`/`CallExpression` inversion, as in https://github.com/tc39/proposal-pattern-matching/issues/117

[11:39:27.0000] <keith_m__>
ljharb: While it's usually a bad idea to do assignment as an expression (I agree with you), I'm not convinced that would be a problem here.

[11:39:45.0000] <keith_m__>
my argument is there can only be one lexical assignment per if condition

[11:40:03.0000] <ljharb>
keith_m__: and what if you want two tho? like `const { foo } = obj; let { bar } = obj`

[11:40:16.0000] <keith_m__>
that would be a syntax error

[11:40:18.0000] <ljharb>
or even `const { foo, bar } = obj`

[11:40:30.0000] <keith_m__>
well that's destructuring so I'd be ok with that

[11:41:03.0000] <ljharb>
ok so, the limitation of destructuring not allowing mixing let/const is "fine" because you can do 2 statements - but if there's a place where you can only do one, that will likely present a problem

[11:41:03.0000] <devsnek>
why not `for (let a = b(); a;;) {}`

[11:41:07.0000] <devsnek>
:P

[11:41:37.0000] <keith_m__>
isn't that an infinite loop?

[11:41:43.0000] <devsnek>
oh yeah

[11:41:45.0000] <devsnek>
lol

[11:42:07.0000] <devsnek>
my thought process stopped at "yeah this would run and not run"

[11:42:12.0000] <keith_m__>
you also can't have an else

[11:43:21.0000] <keith_m__>
ljharb: Destructuring is also a bit weird because it's somewhat unclear what the conditional is?

[11:43:52.0000] <keith_m__>
is it the fact that the destructuring "succeeded"? Or that the RHS is actually an object?

[11:44:08.0000] <keith_m__>
so maybe destructuring is a bad choice

[11:44:15.0000] <devsnek>
if destructuring doesn't succeed it throws

[11:44:28.0000] <keith_m__>
I mean maybe you don't want that behavior here?

[11:44:34.0000] <devsnek>
but yeah that is getting into matching territory

[11:44:39.0000] <keith_m__>
fair

[11:45:12.0000] <keith_m__>
Also, you could do two statements for destructuring here

[11:45:17.0000] <devsnek>
`#pragma match` or `#pragma destructure` ftfy

[11:45:54.0000] <ljharb>
keith_m__: right, so then you block destructuring in an `if`, and now you have a weird sub-form of assignment

[11:45:57.0000] <keith_m__>
since you could do if (let { foo } = obj) { const { bar } = obj; }

[11:46:37.0000] <keith_m__>
but I think it's worth exploring what the different semantics could be

[11:48:20.0000] <keith_m__>
anywho I will make a proposal unless people think it's beating a dead horse

[11:50:18.0000] <ljharb>
keith_m__: i'd search esdiscuss first for previous discussions on it

[11:50:32.0000] <keith_m__>
I did some googling and couldn't find anything

[12:06:34.0000] <rkirsling>
definitely seems like a worth problem space to bring up in session

[12:15:27.0000] <cloudshu>
late reply: i think "c's not a great language to emulate" is more an argument for not having `if (let foo = bar)` the available-in-both-branches thing

[12:16:00.0000] <cloudshu>
if we're to have the form, it'd be weird to diverge imo

[12:16:54.0000] <Bakkot>
I don't think this syntax is worth it, in honesty

[12:18:12.0000] <cloudshu>
i'm like a weak agree on it not being worth it

[12:18:21.0000] <cloudshu>
i do use the form in c++ fairly frequently

[12:42:48.0000] <devsnek>
i never even knew it existed

[12:43:00.0000] <devsnek>
but same agreement as cloudshu

[13:34:19.0000] <Bakkot>
also, previous discussions: https://esdiscuss.org/topic/proposal-if-variable-initialization https://esdiscuss.org/topic/proposal-let-in-if-parentheses

[14:03:31.0000] <oliverdunk>
I think I'm understanding the fetch spec right, but just to check - is it intended then when fetching a resource with {redirect: "manual"}, the response type is always "cors" (even with Access-Control-Allow-Origin set to *), unless there's a redirect, in which case the response type is "opaqueredirect"?

[14:08:04.0000] <rkirsling>
oliverdunk: I think you'd have to talk to WHATWG about fetch; it's not part of the language spec

[14:08:28.0000] <oliverdunk>
Gotcha, that makes sense rkirsling.

[14:42:49.0000] <Bakkot>
gh-1158 is merged! :hooray:

[14:44:38.0000] <Bakkot>
getting archive.is/TeTng fixed has been on my todo list for _three years_

[14:45:58.0000] <rkirsling>
wow, that's the first time I've actually viewed that site

[15:39:51.0000] <devsnek>
just watched cj's talk at jsconf

[15:40:11.0000] <devsnek>
reminds me of the arguments in the std proposal

[15:40:43.0000] <rkirsling>
the energy of being in the front row for that and not knowing what was coming, man. it was really something

[15:41:54.0000] <rkirsling>
but yeah there's a common theme in the ether, I think


2019-06-20
[17:33:01.0000] <jmdyck>
cj's talk = https://www.youtube.com/watch?v=MO8hZlgK5zc ?

[17:39:11.0000] <rkirsling>
jmdyck: yep!

[17:39:18.0000] <jmdyck>
tx

[18:46:08.0000] <devsnek>
someone who works on test262.report, do you know on average how many tests are marked skip/flake by engines?

[06:54:05.0000] <ErrorIsNullError>
devsnek, I still don't understand.  Prehaps "intent" is the wrong word/ I'm trying to figure out what it enables engines to do?  AFAICT, all the predictability benefits fall out of the similar language in HostResolveImportedModule.  I suppose without it  a transient network or file-system failure during the first call to HostImportModuleDynamically(referencingScriptOrModule,specifier) or a cache expiration between calls might l

[07:27:00.0000] <devsnek>
ErrorIsNullError: it's about preventing the thing you can do in commonjs where you modify the module cache

[07:46:15.0000] <ErrorIsNullError>
devsnek, As in require.cache in Node.js?

[07:46:32.0000] <devsnek>
yes

[07:46:39.0000] <ErrorIsNullError>
Thanks for explaining.

[07:46:39.0000] <devsnek>
I guess webpack has that too

[07:47:53.0000] <ErrorIsNullError>
Yeah.  IIRC, webpack creates a stub require function, and requiring a module looks up into a cache and evals the rewritten module body text on a cache miss.

[07:50:33.0000] <ErrorIsNullError>
I've been reading the related parts of html.spec.whatwg and I think I've got a better handle on how FinishDynamicImport expects the module graph to be fleshed out (per the Assert of the evaluated bit).

[07:50:56.0000] <ErrorIsNullError>
I was missing that bit of context though, so thanks for that.

[07:53:27.0000] <ErrorIsNullError>
I'll prep an editorial PR that adds a note relating to that, and invite Daniel+Domenic to review.  May lead to useful discussion, and/or help someone else who has the same confusion.

[11:26:37.0000] <keith_mi_>
cloudshu: Another possibly controversial proposal now that we have WeakRef collection semantics: WeakSet/Map iteration

[11:26:41.0000] <keith_mi_>
thoughts?

[11:27:00.0000] <Bakkot>
:(

[11:27:10.0000] <keith_mi_>
why :(

[11:27:30.0000] <cloudshu>
keith_mi_: you want to iterate over existing WeakMaps?

[11:27:34.0000] <Bakkot>
WeakRefs are a thing which very few people should need to know about or use, which limits the extent to which GC is exposed to random people writing JS; this is not the case for WeakMaps

[11:27:36.0000] <keith_mi_>
seems like a useful feature and is an example on the WeakRef doc

[11:27:42.0000] <cloudshu>
which are explicitly ephemeron things that aren't meant to be iterable?

[11:28:01.0000] <cloudshu>
yeah i'm with Bakkot on this one

[11:28:02.0000] <keith_mi_>
Yeah basically

[11:28:59.0000] <devsnek>
are weak collection iterators async iterators

[11:29:04.0000] <keith_mi_>
word, I can 100% guarantee you that there's going to be a library that makes an iterable WeakMap and it's going to be popular

[11:29:21.0000] <devsnek>
i'd rather it was a library

[11:29:24.0000] <keith_mi_>
there's not iterators right now

[11:29:31.0000] <devsnek>
no i mean

[11:29:39.0000] <devsnek>
the conceptual weak collection iterators

[11:29:51.0000] <keith_mi_>
why would they need to be?

[11:30:09.0000] <devsnek>
couldn't you observe collection by doing like `while (true) { [...thing.values()] }`

[11:30:21.0000] <keith_mi_>
no it would have the same semantics as WeakRef

[11:30:25.0000] <devsnek>
isn't that why finalization groups call back in a next tick

[11:30:40.0000] <keith_mi_>
once you have iterated the value it's keptAlive until the next tick

[11:30:45.0000] <devsnek>
oh ok

[11:30:47.0000] <devsnek>
makes sense

[11:31:03.0000] <devsnek>
still with bakkot though

[11:31:19.0000] <devsnek>
the thing i really want is a WeakValueMap

[11:31:25.0000] <keith_mi_>
I don't get the advantage of it being a library

[11:31:33.0000] <cloudshu>
keith_mi_: oh for sure, there will be an iterable weakmap on top of weakrefs

[11:31:40.0000] <cloudshu>
you can do weakvaluemaps on top of weakrefs also

[11:31:54.0000] <devsnek>
yeah but it would be nice in std

[11:31:56.0000] <keith_mi_>
devsnek: that's just weakMap where the values are WeakRefs

[11:32:03.0000] <devsnek>
yes

[11:33:17.0000] <cloudshu>
keith_mi_: i think the advantage is that the existing invariant for WeakMaps stays as is, and that the "there be heavy impl-dependent timing here" is only limited to grepping for weakrefs

[11:33:38.0000] <keith_mi_>
cloudshu: I think that would still be true

[11:33:48.0000] <cloudshu>
keith_mi_: what's the motivation for adding iteration beyond "it'll be possible anyway with a container on top of weakrefs"?

[11:34:07.0000] <keith_mi_>
I just think it's going to be in 100% of wild uses of WeakMap

[11:34:13.0000] <keith_mi_>
so we might as well add it

[11:34:23.0000] <keith_mi_>
so engines can optimize

[11:34:27.0000] <devsnek>
i think people also take advantage of weak collections being uninspectable

[11:34:34.0000] <devsnek>
whatever the term is

[11:34:42.0000] <Bakkot>
wat

[11:34:43.0000] <Bakkot>
WeakMaps are already widely used without iteration

[11:35:04.0000] <devsnek>
there is one case i can think of where i would use this

[11:35:13.0000] <cloudshu>
keith_mi_: wait, what

[11:35:13.0000] <devsnek>
but that's one case in like a billion times i've used weakmap

[11:35:43.0000] <cloudshu>
what are you envisioning people doing? creating a shadow map of weakrefs holding on to weakmap keys, just so they can iterate?

[11:35:47.0000] <keith_mi_>
afaik all the web inspectors have added this themselves

[11:36:35.0000] <Bakkot>
they've also all exposed promise resolution status, beause it's nice when debugging, but that doesn't mean it makes sense to add that to the language

[11:37:06.0000] <keith_mi_>
My point is now that it's possible to add it's going to be done, ubiquitously.

[11:37:16.0000] <devsnek>
wouldn't this also break the implementation style where weakmaps are just a wrapper that assign hidden props on the key objects

[11:37:32.0000] <cloudshu>
well, presumably not until you actually do the iteration

[11:37:39.0000] <keith_mi_>
how would it?

[11:37:46.0000] <keith_mi_>
the weakmap isn't exposed

[11:38:57.0000] <cloudshu>
keith_mi_: put another way, what are we gaining by standardizing it becaues it's possible?

[11:39:06.0000] <cloudshu>
i can't really say i agree or disagree with ubiquity

[11:39:22.0000] <Bakkot>
I expect it will be done less, much less, if it's in a library rather than in the language.

[11:39:30.0000] <devsnek>
anyone have any theories about why lint would fail on ci but work locally

[11:39:56.0000] <keith_mi_>
I mean there's no rush on this since we can easily find out later

[11:39:59.0000] <Bakkot>
(and also being in a library will mean it's opt-in; adding a library will not grant other people the ability to iterate my non-library weakmaps)

[11:40:33.0000] <ljharb>
making an iterable weakmap is fine, but allowing weakmaps to be iterable would be terrible

[11:40:56.0000] <cloudshu>
i'm still confused how the library will do tihs for existing weakmaps besides keeping a shadow map

[11:42:20.0000] <keith_mi_>
cloudshu: it's in https://github.com/tc39/proposal-weakrefs

[11:42:25.0000] <keith_mi_>
as an example

[11:43:12.0000] <keith_mi_>
and yeah it's a "shadow" map

[11:43:40.0000] <keith_mi_>
but that's much more expensive than having the VM iterate it for you since we already can

[11:44:01.0000] <cloudshu>
oh i never scrolled that far down

[11:44:04.0000] <keith_mi_>
As you now have 3 maps where you really only need one

[11:44:10.0000] <keith_mi_>
LOL

[11:44:16.0000] <devsnek>
can't you make the finalization group itself the map

[11:44:28.0000] <keith_mi_>
devsnek: There's no find

[11:44:31.0000] <devsnek>
aw

[11:44:33.0000] <keith_mi_>
in finalization group

[11:44:47.0000] <keith_mi_>
*I think*

[11:45:20.0000] <cloudshu>
keith_mi_: yeah i mean i could be convinced with usage numbers but it just feels unlikely

[11:46:17.0000] <devsnek>
i'm concerned that this api could expose data people thought was safely concealed

[11:46:27.0000] <cloudshu>
how so?

[11:46:34.0000] <devsnek>
if you assume people can't read a weakmap

[11:46:36.0000] <devsnek>
because they can't

[11:46:47.0000] <devsnek>
then suddenly someone runs your code on a new version of node

[11:46:54.0000] <keith_mi_>
Yeah, it's possible it'd have to be a subclass of WeakMap

[11:47:03.0000] <keith_mi_>
I'm sure Mark would feel that way

[11:47:11.0000] <ljharb>
it'd definitely have to be

[11:47:15.0000] <devsnek>
probably the first time i've ever agreed with mark

[11:47:21.0000] <keith_mi_>
haha

[11:47:41.0000] <devsnek>
i wouldn't mind a subclass

[11:47:51.0000] <ljharb>
(it's a similar reason Map and Set should have used SameValue and not SameValueZero :-p)

[11:48:02.0000] <devsnek>
Proxy.revokable, WeakMap.iterable

[11:48:17.0000] <keith_mi_>
Is that the plan...

[11:48:29.0000] <keith_mi_>
to have the subclass be a property of the main class

[11:48:39.0000] <devsnek>
wow is it really revocable

[11:48:39.0000] <keith_mi_>
so weird

[11:48:56.0000] <cloudshu>
well revocable isn't a subclass constructor

[11:49:03.0000] <cloudshu>
it's just like a function that returns a revocable proxy

[11:49:20.0000] <devsnek>
nah i'd expect it to be like `IterableWeakMap` or smth

[11:49:51.0000] <keith_mi_>
/me goes to a meeting

[11:50:23.0000] <cloudshu>
keith_mi_: wait hold up can you do proposals my controversial ideas because i don't want the headache

[11:51:12.0000] <cloudshu>
1) mutable arguments.callStack that lets you programmatically unwind and do stack surgery

[11:51:12.0000] <keith_mi_>
cloudshu: Is there a missing of in there because I don't understand you otherwise?

[11:51:17.0000] <ljharb>
lol

[11:51:34.0000] <keith_mi_>
ü§Æ

[11:51:45.0000] <cloudshu>
how else can we write real debuggers??

[11:52:10.0000] <cloudshu>
one day i will make that proposal

[11:52:14.0000] <keith_mi_>
use the inspector?

[11:52:33.0000] <devsnek>
mutable global.stack

[11:53:19.0000] <ljharb>
first you have to get stack in the first place

[11:53:24.0000] <cloudshu>
2) Object.prototype.{castTo,castFrom}BigInt

[11:54:13.0000] <devsnek>
O.O

[11:54:34.0000] <cloudshu>
one day people will come around to my ideas

[11:55:02.0000] <devsnek>
i fear these ideas

[11:55:36.0000] <ljharb>
cloudshu: lol cast an object from a bigint?

[11:55:51.0000] <cloudshu>
yes, it will replace the guts of the this value

[11:56:12.0000] <cloudshu>
it'll find the object whose pointer is the bigint value argument, and then replace guts

[11:56:46.0000] <ljharb>
what's a pointer

[11:57:12.0000] <cloudshu>
that's kind of a philosophical question

[11:58:35.0000] <ljharb>
:-p


2019-06-22
[11:51:21.0000] <rkirsling>
anybody have an example of a pattern-matching use case where the when-clause bindings *should* be mutable?

[11:51:57.0000] <rkirsling>
it's really hard to conceive of because it runs counter to the pedigree of the feature üòÖ


2019-06-23
[17:49:07.0000] <ljharb>
rkirsling: same use case where any variable should be mutable

[18:39:01.0000] <rkirsling>
ljharb: I don't think that's true though? at best it would be "wherever you might like to use `if let` and actually have it be `let` and not `const`" and I'm not sure I know when that would be

[18:39:31.0000] <rkirsling>
the current examples focus on destructuring objects, and it seems like you would typically be interested in a *view* into that object

[18:39:34.0000] <ljharb>
many use cases for let are ‚Äúi want to reuse this variable name‚Äù - all of those would still apply.

[18:40:18.0000] <ljharb>
iow the initial var might just be for the matching, and they might want to use the var name in concise property shorthand later with a different value

[18:40:47.0000] <rkirsling>
hmm

[18:41:00.0000] <rkirsling>
I see what you're saying

[18:43:17.0000] <rkirsling>
that too I'd want to prevent with a lint rule of course :D but I get that we don't have any immutable-by-default expectation in JS, I was just hoping there'd be some more convincing use case than just "these are the expectations inherited from existing constructs"

[18:43:53.0000] <devsnek>
without any explicit declaration i'd expect immutable

[18:44:16.0000] <devsnek>
not based on how stuff like function arguments work

[18:44:22.0000] <devsnek>
but how the ecosystem uses them


2019-06-24
[15:00:36.0000] <devsnek>
mathiasbynens: given an array of numbers, do you know what the difference between `sort()` and this sort function are? https://gist.github.com/devsnek/ffab4d437816cbaf169d7f93d259ce72

[15:04:05.0000] <devsnek>
what i'd like to be able to do is duplicate the behaviour of that sorting function without having to convert things to strings

[15:05:27.0000] <ljharb>
devsnek: `return a - b`?

[15:05:47.0000] <devsnek>
isn't that already how sort() works?

[15:06:06.0000] <ljharb>
i think sort's default is `return String(b).localeCompare(a)` or something

[15:06:33.0000] <ljharb>
otherwise it'd sort `[1, 10, 2]` into `[1, 2, 10]` instead of leaving it untouched

[15:06:57.0000] <devsnek>
wow

[15:07:01.0000] <ljharb>
oh wait `String(a).localeCompare(b)`

[15:07:03.0000] <devsnek>
i didn't realize sorting was this broken lol

[15:07:08.0000] <ljharb>
it's not broken

[15:07:21.0000] <ljharb>
( `[1, 10, 2].sort()` is the same as `[1, 10, 2].sort((a, b) => String(a).localeCompare(b))`)

[15:07:36.0000] <devsnek>
not literally broken

[15:07:45.0000] <ljharb>
devsnek: either the comparator had to be required, or some default had to be chosen; string is a much more sensible default than number

[15:08:01.0000] <ljharb>
imo it'd be much nicer if the comparator was required, but here we are

[15:08:15.0000] <devsnek>
in slither i choose the sorting system based off the first item

[15:08:48.0000] <ljharb>
that means `[1, '10']` and `['10', 1]` sort differently, that seems super surprising to me

[15:09:08.0000] <devsnek>
well it throws if it tries to compare two elements that aren't the same type

[15:09:13.0000] <devsnek>
oh well

[15:09:15.0000] <ljharb>
you could pick the mode of the types

[15:09:38.0000] <ljharb>
but the reality is that if they're not all the same type, you either have to pick something (that will be super broken for many use cases) or throw

[15:09:42.0000] <rkirsling>
devsnek: that would be really bad default behavior for a dynamic language though üò±

[15:09:54.0000] <devsnek>
would it?

[15:09:57.0000] <ljharb>
yes

[15:10:11.0000] <devsnek>
how often to you try to sort heterogeneous arrays

[15:10:34.0000] <rkirsling>
I know but shouldn't and can't are very different

[15:10:57.0000] <devsnek>
if you want to sort between things that aren't the same type use a comparison function ü§∑

[15:11:15.0000] <ljharb>
devsnek: right but then you should throw before ever invoking the function

[15:11:26.0000] <devsnek>
hmm using a - b still didn't work

[15:11:33.0000] <ljharb>
b - a?

[15:11:46.0000] <devsnek>
oh wait is that

[15:12:06.0000] <devsnek>
lol

[15:12:18.0000] <ljharb>
comparators are like USB A connectors for me, whichever way i try it first is always wrong

[15:12:26.0000] <devsnek>
yea

[15:13:19.0000] <devsnek>
yeah just doing number sort doesn't produce the same output

[15:14:28.0000] <devsnek>
probably has to do with the conversion and stuff with strings

[15:20:39.0000] <rkirsling>
hmm, I guess I forgot that Python separates the types

[15:20:56.0000] <rkirsling>
>>> sorted(['hi', 1, 10, 2])

[15:20:56.0000] <rkirsling>
[1, 2, 10, 'hi']

[15:23:07.0000] <devsnek>
i have that partially, to sort object keys


2019-06-25
[13:16:44.0000] <devsnek>
what if there were a feature like `arguments.location` which gives a Symbol based on the location of the call

[13:16:58.0000] <devsnek>
allowing behaviour similar to how tagged templates work but with normal calls

[13:17:25.0000] <ljharb>
it wouldn't work in arrows tho; so maybe `function.callsite` or something

[13:17:38.0000] <devsnek>
`System.locationSymbol()`

[13:19:06.0000] <devsnek>
i don't actually have any real use case for this, i'm just annoyed by how react hooks work

[15:25:22.0000] <TabAtkins>
devsnek: Does that let you cache the results of a given call so multiple invocations of the same thing can act the same?

[15:25:46.0000] <devsnek>
TabAtkins: that is one thing you could do


2019-06-26
[20:57:26.0000] <TimothyGu>
ljharb: any word on https://github.com/tc39/ecma262/pull/1406?

[20:58:18.0000] <TimothyGu>
https://github.com/tc39/ecma262/pull/1284 too I guess?

[20:58:40.0000] <ljharb>
TimothyGu: thanks for the reminder. i'd like waldemar to review 1406 before it goes in; i wasn't at the june meeting but i'll ask him at the july meeting

[20:59:25.0000] <ljharb>
same for 1284, but it'd be good to have domenic review that first as well since for-await-of was his proposal

[21:01:09.0000] <TimothyGu>
ljharb: thanks; shall I remind you again when the meeting is being held?

[21:01:18.0000] <ljharb>
TimothyGu: it definitely couldn't hurt :-)

[21:01:24.0000] <TimothyGu>
okie

[00:32:00.0000] <akirose>
Waldemar wasn't at the June meeting and apparently just got back from the north pole?

[11:39:23.0000] <caiolima>
Does anyone know where I can ask for an invitation letter to TC39 meeting? I'm not sure if it is mandatory, but may be required by border control when I travel there.


2019-06-27
[19:11:28.0000] <devsnek>
caiolima: if you haven't resolved that yet, try asking in the delegates channel

[04:41:54.0000] <caiolima>
devsnek: That's a good advice. Thx.


2019-06-30
[14:43:23.0000] <devsnek>
was there ever talk of moving JSON modules to ecma262

[14:46:20.0000] <jmdyck>
There was talk of JSON modules...

[14:48:05.0000] <jmdyck>
https://github.com/rwaldron/tc39-notes/blob/master/meetings/2019-06/june-5.md#status-update-on-non-js-module-types-eg-json-css-webidl

[14:48:29.0000] <devsnek>
jmdyck: they exist in html spec atm

[14:50:26.0000] <jmdyck>
https://docs.google.com/presentation/d/1w8jWjD41htD7VxOejFqiHi6uGgHVWtZ_XmgFxgKkS7Q/edit#slide=id.g5947c7781f_0_36 says "JSON modules in TC39?"

[14:50:50.0000] <devsnek>
notes seem more like just explaining that these module types have reason to exist

[14:56:10.0000] <jmdyck>
Well, DE asks "Should we ship JSON modules in TC39?" and MM says "favor for fully in TC39"

[14:56:26.0000] <jmdyck>
but no conclusion/resolution

