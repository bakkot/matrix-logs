2025-02-12
[03:42:51.0849] <eemeli>
Looking over and considering Jesse's upcoming Decimal/Measure presentation and explainer, I get the sense that we really ought to find a way to reach the end goals here in multiple smaller steps, rather than one big leap. By Decimal normalising trailing zeros, the use cases for them introduce a dependency on Measure, but it gets a bit hairy if Measure then also depends on Decimal for its value representation.

What if we were to initially not include _any_ conversions in Measure? Then we wouldn't need to change its inputs at all, and we would still be providing a way for Intl.NumberFormat and Intl.MessageFormat to get their formattable inputs as a combined value+units+precision package.

Then we could consider separately the Smart Units part of this whole thing adding unit conversions, and Decimal defining its accessors on Measure, and we'd avoid having everythin depend on everything else.

[04:11:38.0886] <eemeli>
Here's a sketch of what that might look like: https://gist.github.com/eemeli/0bd413d2f711cbd6016673af8d68c38c

That's in TS, so the real thing would need to have appropriate runtime checks for the types. The lack of any methods on the class is quite intentional, as is freezing it.

I'm also starting to think that we might want to call this "Amount" rather than "Measure", mostly because then it also makes sense for currencies: it feels really clumsy to talk of a "measure of money", whereas an "amount of money" (or anything else, really) makes more sense.

[04:17:23.0096] <Jesse>
thanks!

[04:18:49.0872] <Jesse>
happy to discuss another name

[04:19:34.0784] <Jesse>
"measure" suggests physical quantities and (it feels like) is excludes currencies; "amount" clearly includes currencies but (to my mind) weakly excludes other kinds of measurements

[04:22:29.0800] <Jesse>
shouldn't we have a toLocaleString or at least toString in Amounts?

[04:29:36.0662] <Jesse>
I wonder if want to tie in to ISO 4217 (standardization of currencies) somehow or whether measure/amount is merely any tagged number (or string, or bigint) at all

[04:30:09.0079] <Jesse>
`new Amount(42.75, "foobar gramz")`

[04:30:55.0318] <Jesse>
I like the simplicity of the zero-method approach but I wonder if this deflates the value-add too much

[04:31:28.0406] <Jesse>
one of the nice value-add parts of measure, to my mind, was its tie-in to CLDR's units.xml

[04:31:49.0994] <Jesse>
exposing new capabilities to the language, rather than merely attaching a string to a number

[04:43:30.0766] <eemeli>
I would argue that e.g. "3 meters" or "42 grams" are both also "amounts", whereas calling those "measures" or "measurements" would be more opinionated about how the figure was reached.

[04:44:28.0320] <eemeli>
toLocaleString potentially yes, delegating to Intl.NumberFormat. Not at all so sure about toString; what would be the use case for it?

[04:45:44.0998] <eemeli>
I think that's a question that would be best answered within a more general currency formatting context, as any answer here ought to match the answer given by Intl.NumberFormat.

[04:47:57.0156] <eemeli>
I agree that conversion is nice, but I think it's also complicated -- and has its own Stage 1 proposal: https://github.com/tc39/proposal-smart-unit-preferences

[04:57:08.0967] <Jesse>
ah, right

[04:57:27.0015] <Jesse>
I wonder if the harmony under discussion should also include smart units

[04:57:39.0255] <Jesse>
the current measure README explicitly refers to smart units

[05:03:06.0937] <eemeli>
Yeah, there's a continuum of (at least) three separate considerations here that we're trying to solve:
- How to represent a number together with its unit/currency/precision (Measure/Amount)
- How to convert values between compatible units (Smart Units)
- How to represent numbers better (Decimal)

I think Decimal depends on Amount, and unit conversion _might_ depend on Decimal if that's the chosen type for the value of an Amount after conversion. So I'm looking for a way to solve the first problem in a way that doesn't require simultaneously solving all the problems and introducing all of these cross-dependencies.

[05:09:12.0850] <Jesse>
I like the suggestion to use decimal as the result of doing conversions

[05:09:49.0234] <Jesse>
these typically involve things like taking reciporocals or multiplying values (including squaring, cubing, etc.) so decimal feels like a good match

[05:10:06.0311] <Jesse>
since it's promise is to provide more precision

[05:10:31.0620] <eemeli>
The cleanest way that I see for this stack to proceed would be:
1. Amount
2. Decimal
3. Unit conversions

Then each step would only depend on things before it.

[05:12:57.0943] <Jesse>
that looks good -- I'd like to see decimal building on amount/measure so I think it makes sense to focus on amount

[05:42:33.0698] <Jesse>
I think given the amount of interest in these topics it might make sense to set up a regular call for decimal, measure/amount, and smart units

[05:43:27.0156] <Jesse>
things are sort of scattered atm -- I've discussed this stuff in TG2, TG3, in plenary, in this channel, and (to a much lesser extent) the delegates channel

[05:44:59.0825] <Jesse>
how about tomorrow (Thursday, February 13th) at, say, 18:00 CET?

[05:58:07.0274] <littledan>
I'm glad that we're laying out the whole space, but let's see if we can keep the result, or at least the first step, not too complex.

[06:00:33.0514] <littledan>
I'm sold on the need for a unit'ed Measure class, but I don't know why we'd have a third class

[06:01:14.0104] <littledan>
or is Amount just a way to rename Measure?

[06:01:47.0113] <littledan>
sorry maybe this was just me skimming too fast and the proposal is already good :)

[06:02:21.0448] <Jesse>
I think the current thinking is that amount is just a renaming of measure

[06:02:35.0766] <Jesse>
plus a certain shrinking of its scope

[06:04:01.0246] <Jesse>
there was a discussion in various places about whether measure/amount should support arithmetic, at all, and the consensus seems to be "no"; the most recent sketch is of a class that has no methods at all (except possibly toLocaleString)

[06:04:47.0971] <littledan>
I can see the argument for arithmetic, but it's really complicated, and having the base type exist facilitates people writing libraries to do that. (Of course the same could be said for Temporal)

[06:05:23.0059] <sffc>
(I can join tomorrow at 18:00 CET, or earlier)

[06:05:44.0720] <littledan>
I'd expect (citation needed!) that keeping it to one numerical type is probably simpler implementation-wise, but 3 classes vs one class with multiple possibilities for the value's type doesn't really simplify anything.

[06:05:45.0737] <littledan>
 Personally I don't mind Measure baking in Decimal (since measured quantities are very often decimals, and other numeric types might just be used in error)

[06:08:11.0979] <Jesse>
to my mind there are a couple senses of "arithmetic" -- 1. adding (or multiplying, or ...) two measure objects; and (2) converting to a "higher-order" unit, such as going from meter to meter^3 and converting between compatible scales (meters and inches)

[06:08:33.0922] <Jesse>
my understanding is that (1) is currently not very well received, but I'm not sure about (2)

[06:09:08.0074] <sffc>
Just looked at Jesse's slides. They look like exactly the kind of conversation I think we should be having right now. üëçÔ∏è

[06:10:10.0196] <eemeli>
Yeah, "Amount" is effectively a synonym "Measure".

[06:10:36.0971] <Jesse>
> <@littledan:matrix.org> Personally I don't mind Measure baking in Decimal (since measured quantities are very often decimals, and other numeric types might just be used in error)

agree, though I can see the value in rolling just with currently existing primitive types

[06:11:01.0955] <Jesse>
(one could go even further an imagine supporting only Number)

[06:13:24.0410] <eemeli>
As I see it, the primary utility gained from a minimal Amount/Measure is in the improvements of the Intl.NumberFormat API, and so it'd be rather suprising if `new Amount('42')` or `new Amount(42)` would not work.

[06:13:53.0800] <eemeli>
Given that calling `nf.format('42')` or `nf.format(42)` works.

[06:14:36.0548] <littledan>
Well, we could apply the `new Decimal` logic in the Measure constructor

[06:14:41.0351] <littledan>
for casting

[06:15:00.0760] <eemeli>
Huh, just realised as I typed that that `new Amount(42)` doesn't feel as wrong as `new Measure(42)` does, i.e. without the options.

[06:15:29.0347] <littledan>
(I like the name `Measure`)

[06:16:11.0863] <eemeli>
Why should `new Amount(x).value === x` not be retained? Something like `new Amount(x).asDecimal()` could be a thing, but there's no reason to throw away the original input value.

[06:17:05.0070] <Jesse>
> <@littledan:matrix.org> Well, we could apply the `new Decimal` logic in the Measure constructor

I like that idea too but I've heard from a couple people that they'd like to use bigints in measures/amounts, and I'm a bit uncomfortable with going beyond the range of Decimal128

[06:20:27.0829] <Jesse>
I've made a new calendar item PR but it's not merged yet

[06:20:43.0436] <Jesse>
https://github.com/tc39/Reflector/issues/551

[06:23:36.0881] <eemeli>
I should be able to make that time as well.

[06:24:32.0274] <eemeli>
I'd appreciate a calendar invite at eemeli@mozilla.com for the meeting, once such is available.

[06:37:22.0216] <littledan>
why is this identity important?

[06:45:40.0024] <eemeli>
Because it would be surprising for that identity not to hold, and because it makes it straightforward to support all the same types that are supported by Intl.NumberFormat.

[06:48:46.0098] <eemeli>
I'm not so sure that it's important for the value type to be retained after e.g. conversion. So something like
```
new Amount(42, { unit: 'meter' }).convertTo('foot-and-inch').value
```
could well be a Decimal. Which is why I think we ought to do Amount first, then Decimal, then unit conversions. That way each step only depends on previous work.

[06:51:46.0600] <Jesse>
I think I'm favor having something like an `.asDecimal` method, to make any conversion explicit

[06:54:54.0624] <eemeli>
I added a `.toLocaleString()` to the gist.

[06:58:48.0074] <littledan>
I don't really feel like "this identity is intuitive" is a strong enough reason to make the data model more complex. I'd want to see a use case where you really want the representation to be something other than Decimal.

[06:59:01.0133] <littledan>
(yes, more flexible is more complex)

[06:59:38.0885] <littledan>
that only makes sense if the underlying data model is flexible among types

[07:02:52.0327] <Jesse>
> <@littledan:matrix.org> I don't really feel like "this identity is intuitive" is a strong enough reason to make the data model more complex. I'd want to see a use case where you really want the representation to be something other than Decimal.

I've heard Mark want to use measure/amount to represent values of cryptocurrencies where one has a huge number of significant digits (beyond what can be faithfully represented in Decimal128)

[07:03:39.0809] <Jesse>
so I think for him being able to get the original value (in his case, a bigint) would be important

[07:06:55.0459] <littledan>
I don't understand why cryptocurrencies need more than 34 significant digits. Maybe they forgot that it's floating point rather than fixed point?

[07:07:40.0215] <littledan>
anyway sounds like an argument for BigDecimal over Decimal128; this is the wrong level to make that change IMO

[07:07:40.0399] <Jesse>
I also didn't push him on that; the cryptocurrencies I know don't use that many digits, but MM works in this space so I didn't push

[07:08:08.0184] <Jesse>
FWIW the Ethereum VM uses Decimal256

[07:08:31.0641] <Jesse>
so I guess they foresee a need for a vast number of digits

[07:08:56.0143] <littledan>
sure... idk I think this use case needs to be pushed on before we make a complexity-increasing decision on that basis

[07:09:17.0594] <Jesse>
right, I'm not familia with any other use case where such range is needed

[07:09:21.0105] <littledan>
you can always just not use this library

[07:09:30.0847] <littledan>
(and you can always fall back on Intl.NumberFormat taking strings)

[07:12:41.0983] <Jesse>
Decimal128 also seems to be the upper limit, today, of out-of-the-box compiler support, which is another indicator that 128 bits should be enough

[07:13:11.0613] <Jesse>
I like the argument that if 34 significant digits isn't enough, there are other ways to get what you want

[07:13:37.0350] <littledan>
I don't think compiler support is extremely relevant. This is more of a library thing. Anyway IEEE defines up to 128.

[07:48:36.0816] <eemeli>
If there's a need to do anything with the value, that's easier if it's a number, because then you can use `+` `-` `*` `/` etc. If my use case doesn't need the full 128 bits of precision, then a Decimal value would be clumsier to use.

[07:49:24.0134] <eemeli>
I would be open to removing the `.value` accessor`, and including something like `.asNumber()`.

[07:49:33.0121] <eemeli>
* I would be open to removing the `.value` accessor, and including something like `.asNumber()`.

[07:50:20.0049] <eemeli>
That would make adding a `.asDecimal()` later rather straightforward.

[07:55:04.0705] <littledan>
do you have an example of a case where that's a valid, rather than buggy, thing to do?

[07:55:37.0325] <littledan>
the design of Decimal is based on the hope that its methods *won't* be too clumsy to use in practice

[07:56:36.0374] <littledan>
I don't understand the argument for getting rid of an accessor for the value. IMO we should just decide on the data model and then represent it directly; no need to hide it.

[08:06:08.0249] <eemeli>
I see enforcing the Amount value to be a Decimal to be unnecessary complexity, because that's not needed when Amount is used when passing it between user code, _or_ when passing it to Intl.NumberFormat. I would also like to not make Amount conditional on Decimal, because that seems unnecessary. The primary direct use case for it that I have in mind is Intl.NumberFormat, and for that it'd be fine if it was just an opaque blob.

It would be _nice_ if it was also useful for passing between user code, but if that requires reaching consensus on Decimal, then I would much prefer introducing it as a part of that consensus.

[08:09:37.0990] <littledan>
OK, sounds like there aren't any particular use cases, and we just disagree on what "simpler" means

[08:09:51.0116] <littledan>
but I do think we can work these details out after getting consensus on the broader plan overall

