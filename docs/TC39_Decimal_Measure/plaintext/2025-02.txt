2025-02-12
[03:42:51.0849] <eemeli>
Looking over and considering Jesse's upcoming Decimal/Measure presentation and explainer, I get the sense that we really ought to find a way to reach the end goals here in multiple smaller steps, rather than one big leap. By Decimal normalising trailing zeros, the use cases for them introduce a dependency on Measure, but it gets a bit hairy if Measure then also depends on Decimal for its value representation.

What if we were to initially not include _any_ conversions in Measure? Then we wouldn't need to change its inputs at all, and we would still be providing a way for Intl.NumberFormat and Intl.MessageFormat to get their formattable inputs as a combined value+units+precision package.

Then we could consider separately the Smart Units part of this whole thing adding unit conversions, and Decimal defining its accessors on Measure, and we'd avoid having everythin depend on everything else.

[04:11:38.0886] <eemeli>
Here's a sketch of what that might look like: https://gist.github.com/eemeli/0bd413d2f711cbd6016673af8d68c38c

That's in TS, so the real thing would need to have appropriate runtime checks for the types. The lack of any methods on the class is quite intentional, as is freezing it.

I'm also starting to think that we might want to call this "Amount" rather than "Measure", mostly because then it also makes sense for currencies: it feels really clumsy to talk of a "measure of money", whereas an "amount of money" (or anything else, really) makes more sense.

[04:17:23.0096] <Jesse>
thanks!

[04:18:49.0872] <Jesse>
happy to discuss another name

[04:19:34.0784] <Jesse>
"measure" suggests physical quantities and (it feels like) is excludes currencies; "amount" clearly includes currencies but (to my mind) weakly excludes other kinds of measurements

[04:22:29.0800] <Jesse>
shouldn't we have a toLocaleString or at least toString in Amounts?

[04:29:36.0662] <Jesse>
I wonder if want to tie in to ISO 4217 (standardization of currencies) somehow or whether measure/amount is merely any tagged number (or string, or bigint) at all

[04:30:09.0079] <Jesse>
`new Amount(42.75, "foobar gramz")`

[04:30:55.0318] <Jesse>
I like the simplicity of the zero-method approach but I wonder if this deflates the value-add too much

[04:31:28.0406] <Jesse>
one of the nice value-add parts of measure, to my mind, was its tie-in to CLDR's units.xml

[04:31:49.0994] <Jesse>
exposing new capabilities to the language, rather than merely attaching a string to a number

[04:43:30.0766] <eemeli>
I would argue that e.g. "3 meters" or "42 grams" are both also "amounts", whereas calling those "measures" or "measurements" would be more opinionated about how the figure was reached.

[04:44:28.0320] <eemeli>
toLocaleString potentially yes, delegating to Intl.NumberFormat. Not at all so sure about toString; what would be the use case for it?

[04:45:44.0998] <eemeli>
I think that's a question that would be best answered within a more general currency formatting context, as any answer here ought to match the answer given by Intl.NumberFormat.

[04:47:57.0156] <eemeli>
I agree that conversion is nice, but I think it's also complicated -- and has its own Stage 1 proposal: https://github.com/tc39/proposal-smart-unit-preferences

[04:57:08.0967] <Jesse>
ah, right

[04:57:27.0015] <Jesse>
I wonder if the harmony under discussion should also include smart units

[04:57:39.0255] <Jesse>
the current measure README explicitly refers to smart units

[05:03:06.0937] <eemeli>
Yeah, there's a continuum of (at least) three separate considerations here that we're trying to solve:
- How to represent a number together with its unit/currency/precision (Measure/Amount)
- How to convert values between compatible units (Smart Units)
- How to represent numbers better (Decimal)

I think Decimal depends on Amount, and unit conversion _might_ depend on Decimal if that's the chosen type for the value of an Amount after conversion. So I'm looking for a way to solve the first problem in a way that doesn't require simultaneously solving all the problems and introducing all of these cross-dependencies.

[05:09:12.0850] <Jesse>
I like the suggestion to use decimal as the result of doing conversions

[05:09:49.0234] <Jesse>
these typically involve things like taking reciporocals or multiplying values (including squaring, cubing, etc.) so decimal feels like a good match

[05:10:06.0311] <Jesse>
since it's promise is to provide more precision

[05:10:31.0620] <eemeli>
The cleanest way that I see for this stack to proceed would be:
1. Amount
2. Decimal
3. Unit conversions

Then each step would only depend on things before it.

[05:12:57.0943] <Jesse>
that looks good -- I'd like to see decimal building on amount/measure so I think it makes sense to focus on amount

[05:42:33.0698] <Jesse>
I think given the amount of interest in these topics it might make sense to set up a regular call for decimal, measure/amount, and smart units

[05:43:27.0156] <Jesse>
things are sort of scattered atm -- I've discussed this stuff in TG2, TG3, in plenary, in this channel, and (to a much lesser extent) the delegates channel

[05:44:59.0825] <Jesse>
how about tomorrow (Thursday, February 13th) at, say, 18:00 CET?

[05:58:07.0274] <littledan>
I'm glad that we're laying out the whole space, but let's see if we can keep the result, or at least the first step, not too complex.

[06:00:33.0514] <littledan>
I'm sold on the need for a unit'ed Measure class, but I don't know why we'd have a third class

[06:01:14.0104] <littledan>
or is Amount just a way to rename Measure?

[06:01:47.0113] <littledan>
sorry maybe this was just me skimming too fast and the proposal is already good :)

[06:02:21.0448] <Jesse>
I think the current thinking is that amount is just a renaming of measure

[06:02:35.0766] <Jesse>
plus a certain shrinking of its scope

[06:04:01.0246] <Jesse>
there was a discussion in various places about whether measure/amount should support arithmetic, at all, and the consensus seems to be "no"; the most recent sketch is of a class that has no methods at all (except possibly toLocaleString)

[06:04:47.0971] <littledan>
I can see the argument for arithmetic, but it's really complicated, and having the base type exist facilitates people writing libraries to do that. (Of course the same could be said for Temporal)

[06:05:23.0059] <sffc>
(I can join tomorrow at 18:00 CET, or earlier)

[06:05:44.0720] <littledan>
I'd expect (citation needed!) that keeping it to one numerical type is probably simpler implementation-wise, but 3 classes vs one class with multiple possibilities for the value's type doesn't really simplify anything.

[06:05:45.0737] <littledan>
 Personally I don't mind Measure baking in Decimal (since measured quantities are very often decimals, and other numeric types might just be used in error)

[06:08:11.0979] <Jesse>
to my mind there are a couple senses of "arithmetic" -- 1. adding (or multiplying, or ...) two measure objects; and (2) converting to a "higher-order" unit, such as going from meter to meter^3 and converting between compatible scales (meters and inches)

[06:08:33.0922] <Jesse>
my understanding is that (1) is currently not very well received, but I'm not sure about (2)

[06:09:08.0074] <sffc>
Just looked at Jesse's slides. They look like exactly the kind of conversation I think we should be having right now. üëçÔ∏è

[06:10:10.0196] <eemeli>
Yeah, "Amount" is effectively a synonym "Measure".

[06:10:36.0971] <Jesse>
> <@littledan:matrix.org> Personally I don't mind Measure baking in Decimal (since measured quantities are very often decimals, and other numeric types might just be used in error)

agree, though I can see the value in rolling just with currently existing primitive types

[06:11:01.0955] <Jesse>
(one could go even further an imagine supporting only Number)

[06:13:24.0410] <eemeli>
As I see it, the primary utility gained from a minimal Amount/Measure is in the improvements of the Intl.NumberFormat API, and so it'd be rather suprising if `new Amount('42')` or `new Amount(42)` would not work.

[06:13:53.0800] <eemeli>
Given that calling `nf.format('42')` or `nf.format(42)` works.

[06:14:36.0548] <littledan>
Well, we could apply the `new Decimal` logic in the Measure constructor

[06:14:41.0351] <littledan>
for casting

[06:15:00.0760] <eemeli>
Huh, just realised as I typed that that `new Amount(42)` doesn't feel as wrong as `new Measure(42)` does, i.e. without the options.

[06:15:29.0347] <littledan>
(I like the name `Measure`)

[06:16:11.0863] <eemeli>
Why should `new Amount(x).value === x` not be retained? Something like `new Amount(x).asDecimal()` could be a thing, but there's no reason to throw away the original input value.

[06:17:05.0070] <Jesse>
> <@littledan:matrix.org> Well, we could apply the `new Decimal` logic in the Measure constructor

I like that idea too but I've heard from a couple people that they'd like to use bigints in measures/amounts, and I'm a bit uncomfortable with going beyond the range of Decimal128

[06:20:27.0829] <Jesse>
I've made a new calendar item PR but it's not merged yet

[06:20:43.0436] <Jesse>
https://github.com/tc39/Reflector/issues/551

[06:23:36.0881] <eemeli>
I should be able to make that time as well.

[06:24:32.0274] <eemeli>
I'd appreciate a calendar invite at eemeli@mozilla.com for the meeting, once such is available.

[06:37:22.0216] <littledan>
why is this identity important?

[06:45:40.0024] <eemeli>
Because it would be surprising for that identity not to hold, and because it makes it straightforward to support all the same types that are supported by Intl.NumberFormat.

[06:48:46.0098] <eemeli>
I'm not so sure that it's important for the value type to be retained after e.g. conversion. So something like
```
new Amount(42, { unit: 'meter' }).convertTo('foot-and-inch').value
```
could well be a Decimal. Which is why I think we ought to do Amount first, then Decimal, then unit conversions. That way each step only depends on previous work.

[06:51:46.0600] <Jesse>
I think I'm favor having something like an `.asDecimal` method, to make any conversion explicit

[06:54:54.0624] <eemeli>
I added a `.toLocaleString()` to the gist.

[06:58:48.0074] <littledan>
I don't really feel like "this identity is intuitive" is a strong enough reason to make the data model more complex. I'd want to see a use case where you really want the representation to be something other than Decimal.

[06:59:01.0133] <littledan>
(yes, more flexible is more complex)

[06:59:38.0885] <littledan>
that only makes sense if the underlying data model is flexible among types

[07:02:52.0327] <Jesse>
> <@littledan:matrix.org> I don't really feel like "this identity is intuitive" is a strong enough reason to make the data model more complex. I'd want to see a use case where you really want the representation to be something other than Decimal.

I've heard Mark want to use measure/amount to represent values of cryptocurrencies where one has a huge number of significant digits (beyond what can be faithfully represented in Decimal128)

[07:03:39.0809] <Jesse>
so I think for him being able to get the original value (in his case, a bigint) would be important

[07:06:55.0459] <littledan>
I don't understand why cryptocurrencies need more than 34 significant digits. Maybe they forgot that it's floating point rather than fixed point?

[07:07:40.0215] <littledan>
anyway sounds like an argument for BigDecimal over Decimal128; this is the wrong level to make that change IMO

[07:07:40.0399] <Jesse>
I also didn't push him on that; the cryptocurrencies I know don't use that many digits, but MM works in this space so I didn't push

[07:08:08.0184] <Jesse>
FWIW the Ethereum VM uses Decimal256

[07:08:31.0641] <Jesse>
so I guess they foresee a need for a vast number of digits

[07:08:56.0143] <littledan>
sure... idk I think this use case needs to be pushed on before we make a complexity-increasing decision on that basis

[07:09:17.0594] <Jesse>
right, I'm not familia with any other use case where such range is needed

[07:09:21.0105] <littledan>
you can always just not use this library

[07:09:30.0847] <littledan>
(and you can always fall back on Intl.NumberFormat taking strings)

[07:12:41.0983] <Jesse>
Decimal128 also seems to be the upper limit, today, of out-of-the-box compiler support, which is another indicator that 128 bits should be enough

[07:13:11.0613] <Jesse>
I like the argument that if 34 significant digits isn't enough, there are other ways to get what you want

[07:13:37.0350] <littledan>
I don't think compiler support is extremely relevant. This is more of a library thing. Anyway IEEE defines up to 128.

[07:48:36.0816] <eemeli>
If there's a need to do anything with the value, that's easier if it's a number, because then you can use `+` `-` `*` `/` etc. If my use case doesn't need the full 128 bits of precision, then a Decimal value would be clumsier to use.

[07:49:24.0134] <eemeli>
I would be open to removing the `.value` accessor`, and including something like `.asNumber()`.

[07:49:33.0121] <eemeli>
* I would be open to removing the `.value` accessor, and including something like `.asNumber()`.

[07:50:20.0049] <eemeli>
That would make adding a `.asDecimal()` later rather straightforward.

[07:55:04.0705] <littledan>
do you have an example of a case where that's a valid, rather than buggy, thing to do?

[07:55:37.0325] <littledan>
the design of Decimal is based on the hope that its methods *won't* be too clumsy to use in practice

[07:56:36.0374] <littledan>
I don't understand the argument for getting rid of an accessor for the value. IMO we should just decide on the data model and then represent it directly; no need to hide it.

[08:06:08.0249] <eemeli>
I see enforcing the Amount value to be a Decimal to be unnecessary complexity, because that's not needed when Amount is used when passing it between user code, _or_ when passing it to Intl.NumberFormat. I would also like to not make Amount conditional on Decimal, because that seems unnecessary. The primary direct use case for it that I have in mind is Intl.NumberFormat, and for that it'd be fine if it was just an opaque blob.

It would be _nice_ if it was also useful for passing between user code, but if that requires reaching consensus on Decimal, then I would much prefer introducing it as a part of that consensus.

[08:09:37.0990] <littledan>
OK, sounds like there aren't any particular use cases, and we just disagree on what "simpler" means

[08:09:51.0116] <littledan>
but I do think we can work these details out after getting consensus on the broader plan overall

[08:11:26.0701] <eemeli>
Are there any particular use cases that would explicitly benefit from having the value as a Decimal?

[08:12:12.0290] <littledan>
well, if given a Measure as a parameter, then you know which type you get out of `.value`, and you know that you're not changing the value when accessing it as a decimal. So it becomes easier to use reliably.

[08:13:21.0971] <eemeli>
Hang on, "changing the value"? The Amount/Measure values should be immutable, yes?

[08:13:45.0320] <littledan>
changing in the sense of, when I access the value as a decimal, I faithfully get the exact thing

[08:13:50.0263] <littledan>
it's not transformed during the access

[08:14:18.0020] <eemeli>
If that's a concern, then would it not also be a concern if the transformation happens in the constructor?

[08:14:58.0494] <littledan>
well, it's a question of the data model, but sure, my personal preference would be for it to be strict

[08:15:24.0068] <littledan>
anyway, I think this is not that major of a question

[08:15:38.0848] <littledan>
the major question is: are we happy with introducing two classes like this? does this resolve the needs of Measure and Decimal?

[08:16:10.0148] <sffc>
If we stick with `Amount` always being a decimal, then we could just say that `new Amount(42)` or `new Amount(42n)` are not allowed; you need to create one from a Decimal

[08:17:32.0893] <eemeli>
It seems really rather unergonomic to need to do `new Amount(new Decimal(42))`.

[08:18:13.0327] <littledan>
I'm really confused about what goals you're trying to achieve, Eemeli

[08:19:02.0949] <littledan>
is it an abstract sense of minimalism/good design, or is there anything more concrete that you're trying to ensure is enabled?

[08:25:04.0652] <eemeli>
I am primarily looking to improve the experience of using Intl.NumberFormat by better separating the "what" and the "how" of its inputs, where we currently require `unit` and `currency` to be defined in the constructor, while the numerical value is passed in in the `.format()` method.

This is particularly problematic in localization, where the options bag otherwise contains values that a translator may want or need to tweak. Including `currency: 'EUR'` there means that a translator working from French to US English could "fix" that option to say `currency: 'USD'` instead. Amount solves this problem by letting the developer fully control the value being formatted, by wrapping it in an object that includes both the currency code and the value.

[08:26:47.0943] <littledan>
OK, so then the problem with certain designs is that it'd make the upgrade of existing code more complicated, to insert decimal128 into the mix when the surrounding code already works?

[08:29:04.0900] <eemeli>
It would add extra, unnecessary work for an implementation to need to convert a value to Decimal before passing it on to Intl.NumberFormat, which already supports numbers, bigints, and numerical strings.

[08:29:16.0551] <littledan>
Alright, I see that argument

[08:29:44.0633] <eemeli>
And it adds complexity to our process to have two proposals each depend on the other.

[08:30:51.0678] <littledan>
I'm still not super excited about you saying that this means that Measure can come before Decimal -- I hope that Decimal can proceed once we work out the relationship with Measure (maybe Measure would come sooner, but I don't want to add artificial extra delay to Decimal)

[08:33:05.0417] <littledan>
anyway, I'm OK if we end up making Amount/Measure be polymorphic in this way -- not my first choice, but not terrible

[09:16:51.0270] <eemeli>
So here's an idle thought: If we end up with an opaque Amount that can hold a value + units + precision, and the units and precision are optional, then why should we add a separate Decimal class if we were to want to do operations like `.add()` or `.multiply()` on such values?

As in, wouldn't it be cleaner to consider unitless values as just a type of Amount, rather than needing its own special class?

[09:18:03.0981] <eemeli>
At least personally, I find `amount.add(otherAmount)` much less objectionable than `decimal.add(otherDecimal)`, because in the former the values don't feel like they ought to be representable as primitives.

[09:25:06.0259] <Jesse>
one of the issues that has come up with arithmetic on numbers with precision is how to propagate the precision to the result

[09:25:26.0969] <Jesse>
IEEE 754 gives an answer to that, but there are other valid answers

[09:27:04.0588] <Jesse>
I guess the issue with rounding errors in JS Numbers (mainly arising once one starts doing arithmetic) would persist in this approach

[09:28:21.0289] <sffc>
I have a few arguments against the polymorphic Measure:

1. Solves confusion regarding how we record precision 
2. More seamless i18n integration with the new number ecosystem we're building 
3. Easier to implement

I acknowledge that integrating polymorphic Amount into an existing code base is a lossless transformation. However, I've previously been convinced by Jesse that Decimal128 covers basically all use cases. So I don't find that argument for polymorphic Amount to be very strong.

[09:34:14.0827] <eemeli>
sffc: Could you clarify what you mean by "polymorphic Amount"? Is that an Amount with a value that can be one of multiple different types?

[09:37:11.0385] <Jesse>
I think of dimensionless, unitless Amount as a sort of limiting case; I think of decimals as mathematical values

[09:37:55.0716] <Jesse>
and I guess developers would also think of them as such (though I admit that that's a bit hand wavy on my part)

[09:39:09.0932] <Jesse>
I can imagine an app that only works with integers under, say, 1 million. Using bigints for those numbers is fine, and helps me to think more clearly about my program than if I were to use Numbers

[09:39:22.0240] <Jesse>
(just making an analogy to existing datatypes)

[09:40:23.0297] <sffc>
> <@eemeli:mozilla.org> sffc: Could you clarify what you mean by "polymorphic Amount"? Is that an Amount with a value that can be one of multiple different types?

Correct, as opposed to an Amount that is always Decimal

[09:40:32.0999] <Jesse>
 * I think of precision-less, unitless Amount as a sort of limiting case; I think of decimals as mathematical values

[09:43:47.0819] <eemeli>
This suggests to me that starting out with an opaque Amount would be safest, as it would allow its value to later be defined as a Decimal, or for the capabilities of Amount to later be expanded to cover what's proposed for Decimal.

[09:45:58.0425] <nicolo-ribaudo>
If we day "for now Amount is opaque basically containing a string / mathematical value", end then we re-explain it in terms of decimal, we have to be careful about how it might round differently

[09:47:16.0518] <eemeli>
We would need to initially impose limits in the Amount constructor that would be within the limits of what's expressible in IEEE 754.

[09:47:54.0699] <Jesse>
just to be precise, we mean the limits of IEEE 754 Decimal128?

[09:48:01.0186] <eemeli>
Yeah.

[10:02:44.0686] <littledan>
I'd like the discussion during the meeting to focus first on building consensus in committee that we should do both of these classes, and then later we can work out details like proposal merging vs not, and polymorphic vs decimal-linked measure. For this, it'd be ideal if all of us could hold back so that the queue could initially be *others* in committee who haven't already been discussing this as a group at length. (And then afterwards we can make statements about our positions within this, but I take it we all agree with this two-class approach where they have basically this role.) What do you think?

[10:03:09.0863] <littledan>
(I mean, not necessarily all of us, but the group who's been more active in discussion)

[10:03:46.0632] <littledan>
for example, ljharb has repeatedly expressed opposition for an unrelated reason. I think we should get that out of the way before we go into these additional details. (That topic is usually brought up just at the very end of the timebox, which doesn't allow for discussion)

[10:04:25.0506] <littledan>
but also we should explore other concerns the rest of the committee might have, e.g., "is this class worth it at all, or should it just be a library?"

[10:04:55.0475] <littledan>
I *think* we've made clear good reasons for all those basic points, but if people still disagree with them, we also won't get Stage 2, even if we have agreement among this group

[10:06:03.0116] <littledan>
sorry I don't mean to dictate the order, we can do whatever order, as long as we make space to hear out the various concerns. I just want to make sure that this conversation is broad and not *only* the same people who are in this channel and other meetings outside of plenary arguing among ourselves.

[10:09:52.0342] <Jesse>
I'd hope that, because the presentation is about measure, too, the set of those in committee who might have useful feedback would be somewhat wider

[10:10:24.0853] <Jesse>
and I hope others who have watched the development of related-but-distinct proposals might have some insight

[12:09:50.0044] <eemeli>
> I take it we all agree with this two-class approach where they have basically this role.

I'm not sure that I agree with this part. I think the discussions so far have identified valid use cases that are served by Amount/Measure, and not by Decimal. Furthermore, I think that an opaque Amount can be defined and can be useful without any dependence on Decimal. Presuming then that at least one class (Amount) is added to the language, it is not clear to me that it would be better to add a second Decimal class, rather than including its functionality in Amount.

[12:12:06.0355] <eemeli>
* > I take it we all agree with this two-class approach where they have basically this role.

I'm not sure that I agree with this part. I think the discussions so far have identified valid use cases that are served exclusively by Amount/Measure. Furthermore, I think that an opaque Amount can be defined and can be useful without any dependence on Decimal. Presuming then that at least one class (Amount) is added to the language, it is not clear to me that it would be better to add a second Decimal class, rather than including its functionality in Amount.

[12:17:45.0581] <eemeli>
I updated the gist again to show an opaque Amount, with a `toString()` method to get at a string representation of the value:
https://gist.github.com/eemeli/0bd413d2f711cbd6016673af8d68c38c

[13:19:03.0934] <littledan>
How does this relate to arithmetic operations?

[13:19:48.0955] <littledan>
I understand if Amount/Measure serves your use cases, but we've presented a bunch of others which are not just that.

[13:20:31.0655] <littledan>
the other thing is, I was imagining that Amount/Measure would represent exactly the value that's passed into it; it doesn't form a floating point exponent itself

[13:20:46.0212] <littledan>
* the other thing is, I was imagining that Amount/Measure would represent exactly the value that's passed into it; it doesn't form a floating point exponent itself. And this is exactly what we're missing for decimal numbers.

[13:22:05.0095] <littledan>
Sometimes, a feature comes through which is useful for some people in committee rather than others. For example, most of TC39 is rather bored by Intl proposals, but they seem like a reasonable standard library, so they let them through. I'm wondering if Decimal might fall into that category for you, or whether it's something that you find to be important to block.

[13:40:37.0024] <eemeli>
I'm trying to say that as it seems like arithmetic operations can reasonably be considered to be included on Amount/Measure (they're currently included in its [README](https://github.com/tc39/proposal-measure/?tab=readme-ov-file#mathematical-operations), even), it's not clear to me how or why those arithmetic operations would differ from the arithmetic operations of a Decimal.

So if we were to do pretty much what you proposed earlier, and consider the value of an Amount to be the same as the opaque value of a Decimal, we could serve the use cases of Decimal with an Amount that had `.add()`, `multiply()` and the other Decimal methds on it.

[13:42:17.0883] <eemeli>
Essentially, I'm trying to ask why we would need a second class beyond Amount.

[14:17:58.0922] <littledan>
Part of the reason was to make Decimal simpler by following the IEEE 754 data model, rather than make up our own arithmetic that would work against various values that can be in Amount

[14:25:07.0484] <eemeli>
What's to prevent using that with Amount values?

[14:25:47.0390] <littledan>
well, you didn't want the data model to be decimal, you wanted it to be number or string. So then it's not clear how to define arithmetic operations, or even everyday things like numerical equality.

[14:32:59.0998] <eemeli>
I am by no means settled in my opinions, and they've clearly evolved during this discussion. I do still think that having an explicitly Decimal value within an Amount is unnecessarily complex, but having an Amount effectively _be_ a Decimal seems like it would simplify things quite a bit.

[14:40:23.0755] <littledan>
well... you've raised analogous opinions before (when it was strings), and we've talked it through, and seem to continue to disagree. What are next steps?

[14:41:29.0197] <littledan>
I'm still interested in understanding, when you say "unnecessarily complex", whether this means "I don't feel like using it in my programs" or "it's essential that JavaScript doesn't have this complexity"

[14:52:55.0458] <nicolo-ribaudo>
Something that worries me about having a single class is that operations on units can get very complex. As long as it's just a conversion between "compatible" units everything is fine, but to support basic arithmetic you need to:
- potentially throw on add/subtract for incompatible units 
- for multiplication and division, support fractions (e.g. kg*m/s)

[14:53:24.0230] <nicolo-ribaudo>
While with the split it's easier to say "this class has more metadata, while this one supports arithmetic"


2025-02-13
[23:19:57.0396] <Jesse>
one thing that's nice about having decimal as the underlying data for measure/amount (and, looking forward, for smart units), is that things like reciporcals, squaring & cubing, multiplication arise quite naturally. Decimal128 is a good fit because it offers a lot of precision in the face of these operations

[03:57:41.0000] <eemeli>
Mostly I'm trying to estimate complexity in terms of the conceptual load we're introducing. Right now we have two types in the spec that hold a numerical value (number and bigint), and with Amount we're due to introduce a third one. The core pitch with Decimal (as I understand it) is to represent decimal numbers, i.e. ones coming from the real world. But don't those almost always have some implicit unit attached? Its stated primary use case is for monetary values, so why not include the currency code with the value? I would think that it would be a very positive feature for something like
```
new Amount(42, { currency: 'USD' }).add(new Amount(13, { currency: 'BTC' }))
```
to throw an error.

So from a JS developer point of view, I would think that it'd be simpler to understand a single Amount as being the thing to use for values coming from the real world, rather than needing to decide between an Amount and a Decimal, depending on what sort of operations might need to be done with the value.

[04:01:30.0149] <eemeli>
Let's say I start with two values
```
const foo = new Amount(42, { currency: 'EUR' })
const bar = new Amount(13, { currency: 'EUR' })
```

With an amount that did decimal math, I could add those up as
```
foo.add(bar)
```
but if their values were Decimal instances, then I'd need to do
```
const sum = foo.value.add(bar.value)
new Amount(sum, { currency: foo.currency })
```

To me that seems clumsier, more verbose, and it skips all the validation fo the former about `foo` and `bar` being addable.

[04:03:55.0303] <eemeli>
Are there many use cases for decimal values that do not have an implicit unit or currency attached to them?

[06:20:58.0762] <sffc>
Is there a meeting today at 18:00?

[06:29:15.0979] <eemeli>
I at least intend to join the call at the link mentioned in the Reflector issue: https://meetings.igalia.com/tc39jsnumerics

[06:29:45.0618] <eemeli>
Also, issue link: https://github.com/tc39/Reflector/issues/551

[06:39:41.0074] <Jesse>
yes, meeting today at 18:00 CET!

[06:39:52.0127] <Jesse>
(it's not yet in the TC39 calendar yet, sorry)

[07:45:59.0019] <littledan>
eemeli: Do you have any thoughts on the complexity that nicolo-ribaudo noted?

[08:19:45.0985] <eemeli>
The compatibility check will need to take into account the operation type and possibly include a conversion; for instance, adding `meter` and `centimeter` should be allowed with a conversion of one into the other, while adding `kilogram` to `meter-per-second` should fail. Multiplying a `kilogram` with a `meter-per-second` should still work, resulting in a `kilogram-meter-per-second`. The `-per-` infix/divisor is already supported by Intl.NumberFormat, btw.

Similarly, adding a unitless value to one with a unit should fail, while multiplication ought to work. Currencies should not be considered convertible between different codes.

In general, operating on things that may include a unit/currency and a precision indicator in addition to a numerical value does add a little bit of work, but only when those fields are actually used. Beyond the compatibility check & possible conversion, we would need to apply some strategy to merging the precisions.

As a default strategy, the significant-figures approach should work: If either Amount has its precision as fraction digits, that number is converted to significant digits by adding `Math.floor(Math.log10(n) + 1)` to the value. if only one Amount has it set, that's applied on the result. If both have, then the smaller significant digits value is applied to the result. This same strategy can work for all arithmetic operations.

As a later step, it could be possible to customize the precision calculation strategy, similarly to how it's possible to consider different precision indicators to work next to fraction & significant digits (e.g. error bars).

The arithmetic operation on the value ought to be defined just as it is currently proposed for Decimal.

[08:21:29.0272] <eemeli>
* The compatibility check will need to take into account the operation type and possibly include a conversion; for instance, adding `meter` and `centimeter` should be allowed with a conversion of one into the other, while adding `kilogram` to `meter-per-second` should fail. Multiplying a `kilogram` with a `meter-per-second` should still work, resulting in a `kilogram-meter-per-second`. The `-per-` infix/divisor is already supported by Intl.NumberFormat, btw.

Similarly, adding a unitless value to one with a unit should fail, while multiplication ought to work. Currencies should not be considered convertible between different codes.

In general, operating on things that may include a unit/currency and a precision indicator in addition to a numerical value does add a little bit of work, but only when those fields are actually used. Beyond the compatibility check & possible conversion, we would need to apply some strategy to merging the precisions.

As a default strategy, the significant-figures approach should work: If either Amount has its precision as fraction digits, that number is converted to significant digits by adding `Math.floor(Math.log10(n) + 1)` to the value. if only one Amount has a precision set, that's applied on the result. If both have, then the smaller significant digits value is applied to the result. This same strategy can work for all arithmetic operations.

As a later step, it could be possible to customize the precision calculation strategy, similarly to how it's possible to consider different precision indicators to work next to fraction & significant digits (e.g. error bars).

The arithmetic operation on the value ought to be defined just as it is currently proposed for Decimal.

