2020-02-05
[17:21:43.0000] <globbot>
channel logging requested by akirose: https://freenode.logbot.info/tc39-delegates

[17:37:12.0000] <michaelficarra>
globbot is back?

[17:37:32.0000] <michaelficarra>
PogChamp it's working! https://freenode.logbot.info/tc39-delegates

[17:37:36.0000] <rkirsling>
haxjs: prior art is important like that üòÖ

[17:37:49.0000] <devsnek>
test

[17:37:53.0000] <devsnek>
its fast

[17:38:20.0000] <akirose>
üôãüèª‚Äç‚ôÄÔ∏è hi friends okay i sketched out the schedule in pencil https://hackmd.io/@aki/rJFTzg8MI

[17:39:13.0000] <akirose>
haxjs: i tried to put you in your morning but should move you to end of day wednesday?

[17:39:18.0000] <haxjs>
rkirsling yeah,many people tell, all good part in js is copied from other langs, and all things js itself invented are bad part. ü§£

[17:39:37.0000] <ljharb>
psh

[17:40:08.0000] <Bakkot>
most of the bad parts are also copied from other languages, to be fair

[17:40:13.0000] <Bakkot>
*cough Date cough*

[17:40:27.0000] <decompiled>
akirose: yayyyy for draft schedule :)

[17:40:29.0000] <devsnek>
*cough RegExp cough*

[17:40:30.0000] <michaelficarra>
most of the worst parts come from Java imo

[17:40:32.0000] <ljharb>
switch cough null cough Number cough

[17:40:52.0000] <devsnek>
*cough statements*

[17:40:53.0000] <haxjs>
yeah! like "var", it seems many old scripts all use function scope vars, no block scope var.

[17:41:02.0000] <ljharb>
old scripts only had var as an option

[17:41:36.0000] <haxjs>
I mean other script languages.

[17:42:04.0000] <ljharb>
languages where block scope was an option?

[17:42:43.0000] <haxjs>
I mean many old script languages also only have function scope vars, no block scope. So js just copied them :-P

[17:43:10.0000] <ljharb>
ah

[17:44:01.0000] <michaelficarra>
wow this is a great first conversation for our logs; delegates shitting all over the language lol

[17:44:03.0000] <haxjs>
I feel java didn't bring many bad part, the most bad from java is Date! But java depracated it in 1.1, while JS used it 20 years... So it seems we can't blame java...

[17:48:27.0000] <haxjs>
akirose  pls put me to the last day if possible, it could help me to adapt to jet lag...

[17:48:37.0000] <akirose>
done

[17:48:57.0000] <haxjs>
akirose Thank you!

[17:49:45.0000] <michaelficarra>
that trichotomy is not true for NaN

[17:50:15.0000] <devsnek>
the precision is defined by the number format

[17:50:23.0000] <michaelficarra>
haxjs: I thought you weren't traveling

[17:51:37.0000] <haxjs>
michaelficarra no I weren't traveling but i still need to adjust my timezone ... starting from my 4AM is really pain... my brain acutally stop work now

[17:53:56.0000] <haxjs>
michaelficarra what trichotomy not work for NaN? I missed it

[17:54:15.0000] <michaelficarra>
a < b or a > b or a === b

[17:55:42.0000] <devsnek>
nan comparisons are always falsy

[17:56:00.0000] <haxjs>
oh :-P  NaN is notanumber but typeof NaN === 'number',  I won't be surprised on everything about NaN :-)

[17:56:08.0000] <bterlson>
Is it just me or is littledan using U+006F LATIN SMALL LETTER O instead of U+0030 DIGIT ZERO?

[17:56:26.0000] <akirose>
I WAS WONDERING THAT TOO

[17:56:31.0000] <devsnek>
bterlson: google "lowercase numbers"

[17:56:33.0000] <shu>
it's that font

[17:56:35.0000] <devsnek>
its the font

[17:56:46.0000] <robpalme>
name that font

[17:56:56.0000] <shu>
it has oldstyle figures by default, which is only a good idea for actual prose usually

[17:56:58.0000] <devsnek>
it's inconsola right

[17:57:02.0000] <akirose>
who's gonna tell him we can't distinguish between white & grey bgs

[17:57:08.0000] <haxjs>
it's latin small lettter?   maybe „Äá ?

[17:57:35.0000] <devsnek>
i always use that font in my proposal slides

[17:57:42.0000] <jackworks>
we're not going to have a global settings on bigdecimals right? global settings are bad

[17:57:57.0000] <devsnek>
right

[17:58:47.0000] <devsnek>
robpalme: playfair display is the name of the font

[17:58:52.0000] <michaelficarra>
jackworks: what does global setting mean?

[17:59:05.0000] <devsnek>
like python's decimal.getcontext()

[17:59:06.0000] <robpalme>
jackworks: the laughter in the room when that came up is a sign that global settings would be highly unlikely to be introduced

[18:00:34.0000] <haxjs>
toJSON is really a problem

[18:00:42.0000] <jackworks>
robpalme: LOL I missed that part

[18:00:47.0000] <bterlson>
Shouldn't thinks like IEEE-754-2008 use upper case numerals or tabular figures? I'd like to see some iteration on the font this deck uses and maybe we can circle back next meeting

[18:01:40.0000] <robpalme>
fonts are normally a stage 2 concern

[18:02:34.0000] <haxjs>
wrote a idea about toJSON issue: https://gist.github.com/hax/5691ca8acdf9179e63043857cdc3616b

[18:05:01.0000] <jridgewell>
@haxjs: @michaelficarra had a proposal for serializing bigints

[18:05:21.0000] <michaelficarra>
did I? I don't remember

[18:05:31.0000] <jridgewell>
I thought?

[18:05:33.0000] <jridgewell>
Maybe not.

[18:05:38.0000] <ljharb>
that's gibson042

[18:05:39.0000] <bterlson>
You did, it was amazing and solved all problems

[18:06:00.0000] <apaprocki>
first proposal to reach stage 5

[18:06:01.0000] <bterlson>
unfortunately hte work was lost in the fire at TC39 HQ

[18:07:51.0000] <michaelficarra>
aww that's too bad

[18:07:59.0000] <devsnek>
i wanted the structured clone algo to move to tc39

[18:08:01.0000] <michaelficarra>
I can't tell if I'm in #tdz or not...

[18:08:06.0000] <jridgewell>
I'm like 90% sure it was michaelficarra

[18:08:28.0000] <jridgewell>
The BigInt to variable length array proposal

[18:08:37.0000] <ljharb>
jridgewell: https://github.com/tc39/proposal-json-parse-with-source

[18:08:57.0000] <jridgewell>
That's the opposite

[18:09:00.0000] <michaelficarra>
I think it was the 10%

[18:09:03.0000] <devsnek>
v8 and gmp both use the same format for bigint serialization

[18:09:11.0000] <devsnek>
i have a gist somewhere to convert between them

[18:09:14.0000] <ljharb>
ah

[18:09:30.0000] <gibson042>
JSON-compatible BigInt serialization is easy and already available with toString; my proposal is to make deserialization possible

[18:09:55.0000] <jridgewell>
https://es.discourse.group/t/bigint-enhancements/100/2

[18:10:13.0000] <Bakkot>
gibson042 wait, how? you can't output arbitrary-precision decimals with `JSON.stringify`

[18:10:31.0000] <devsnek>
https://gist.github.com/devsnek/49b6c63d8a9f9bf3c299a34bb51ed7eb

[18:10:47.0000] <gibson042>
yeah, that's the caveat

[18:11:25.0000] <jridgewell>
devsnek, what's that in a language I can understand?

[18:11:43.0000] <devsnek>
converts between gmplib (gnu bigint library) and v8's bigints

[18:11:54.0000] <devsnek>
using a standard format of <length, <array of u64>>

[18:12:13.0000] <devsnek>
in js the length is part of the array

[18:18:43.0000] <apaprocki>
re: adding the parameter: https://github.com/bloomberg/bde/blob/master/groups/bdl/bdldfp/bdldfp_decimalconvertutil.h#L175

[18:18:55.0000] <apaprocki>
notes from our api for converting from binary->decimal

[18:19:02.0000] <jackworks>
devsnek: +1 I also want to have structured clone algo move into JS and I have a heavily daily usage of custom serializable classes so I also want to have a "developer defined" structured clonable feature

[18:21:01.0000] <littledan>
jackworks: Have you seen the previous efforts towards this move?

[18:22:36.0000] <rickbutton>
for reference, schemes and lisps have literal syntax for decimals

[18:22:37.0000] <rbuckton>
C# has `decimal` which is *essentially* a primitive.

[18:22:39.0000] <haxjs>
littledan it seems there is an old structured clone proposal, but inactive?

[18:22:43.0000] <rickbutton>
(and rationals/complex/etc)

[18:23:03.0000] <rbuckton>
C# also has `0.999m`

[18:24:08.0000] <bterlson>
Anyone remember my preso on decimals from like 2015?

[18:24:14.0000] <bterlson>
those were the days

[18:24:31.0000] <jackworks>
littledan: yes there was a proposal but inactive now and it just a clone of structured clone proposal. I'd like to see an enhanced one

[18:24:37.0000] <bterlson>
I recall saying something like "we've almost solved the value types framework so this work should advance quickly"

[18:24:51.0000] <devsnek>
lol

[18:25:15.0000] <apaprocki>
yes, that was always brendan's feedback :)

[18:25:32.0000] <devsnek>
i have mixed feelings about getting involved after the spicy days

[18:26:02.0000] <rbuckton>
The question is, will value types have a unique `typeof` (i.e., one for *all* value types not per-value type)

[18:26:16.0000] <devsnek>
`typeof x === 'valuetype'`

[18:26:16.0000] <devsnek>
ez

[18:26:32.0000] <michaelficarra>
devsnek: I like that I got a taste of it and I also *really* like that those days are no more

[18:26:32.0000] <haxjs>
seems anything except "function" "object" are all value types.

[18:26:51.0000] <haxjs>
though there is a hole of null.

[18:27:05.0000] <rbuckton>
I'm tinkering with a strawman for value types via the `struct` keyword (similar to how `struct` represents a "value type" in C#), which would have a `typeof` of `"struct"`.

[18:27:10.0000] <devsnek>
i think of everything in js as a heap allocation

[18:27:13.0000] <michaelficarra>
haxjs: typeof null is "object"

[18:29:57.0000] <ljharb>
primitives are arguably "value types"

[18:29:59.0000] <haxjs>
devsnek> immutable object behave same as value type so yes they can all heap allocation

[18:30:04.0000] <ljharb>
anything where `Object(x) !== x`

[18:30:58.0000] <haxjs>
ljharb yeah, this is only robust test I ever know.

[18:31:39.0000] <littledan>
jackworks: Did you follow how that worked out on the HTML side, how there was an effort to work together on this in the past?

[18:31:48.0000] <ghermeto>
rbuckton do you have any resource you can share regarding "struct"?

[18:32:03.0000] <haxjs>
ljharb some very old engine would return some alien values for `typeof` for example "unknown" :)

[18:32:22.0000] <ljharb>
indeed

[18:33:04.0000] <rbuckton>
ghermeto: So far I just have a gist where I've been tinkering with syntax.

[18:33:13.0000] <devsnek>
now when engine internal values leak out of v8 they have typeof be"undefined"

[18:33:18.0000] <devsnek>
which just makes everything more confusing

[18:33:41.0000] <rickbutton>
can people remote hear Mark?

[18:33:44.0000] <devsnek>
yes

[18:33:47.0000] <haxjs>
yes

[18:38:57.0000] <MylesBorins>
hey all. There is a large twitter dm group to coordinate activities for folks in town (both for conference and tc39)

[18:39:10.0000] <MylesBorins>
I added folks whose handles I know, but if you were not included and want to be please lmk

[18:39:25.0000] <rickbutton>
MylesBorins: my twitter is rickbutton , plz add me

[18:39:53.0000] <littledan>
BTW it was a 0 in a weird font

[18:41:10.0000] <MylesBorins>
oh no "rickbutton" cannot be messaged

[18:41:26.0000] <MylesBorins>
I added you, maybe if you add me it will work

[18:41:31.0000] <ljharb>
open up those dms

[18:41:34.0000] <MylesBorins>
(unless you have groupdms turned off)

[18:41:48.0000] <rickbutton>
i wasn't following you try again

[18:41:49.0000] <rickbutton>
shame on me

[18:42:01.0000] <jackworks>
I'm @JackWorks_fvs on twitter

[18:42:38.0000] <ljharb>
jackworks: are you here in person?

[18:42:58.0000] <MylesBorins>
rickbutton: I think you have dms disabled

[18:43:22.0000] <rickbutton>
MylesBorins moving to private IRC to note pollute channel

[18:47:20.0000] <devsnek>
should coordinate with cf folks

[18:47:26.0000] <devsnek>
they're all about this because of cf workers

[18:48:20.0000] <michaelficarra>
devsnek: mark's not on IRC

[18:48:27.0000] <devsnek>
oh

[18:48:38.0000] <michaelficarra>
you'll have to send a pigeon or something

[19:02:43.0000] <littledan>
we could also consider this an overflow item at the end of the meeting, if the timebox has run out

[19:02:51.0000] <littledan>
(although I would like to discuss this further)

[19:03:13.0000] <michaelficarra>
it's a 30m timebox, so it seems appropriate to go to overflow

[19:03:33.0000] <ljharb>
has it gone 30m yet tho?

[19:04:03.0000] <akirose>
yes

[19:04:17.0000] <ljharb>
k

[19:04:43.0000] <devsnek>
ended with 1% battery

[19:04:47.0000] <devsnek>
zoom uses all the battery

[19:35:28.0000] <zuojian>
Hello, where can I find the meeting's note?

[19:38:51.0000] <rkirsling>
zuojian: you can find it via the "meeting info" link in the channel topic

[19:39:15.0000] <zuojian>
Thanks.

[19:41:08.0000] <sffc>
Any plans for dinner tonight?

[20:11:48.0000] <sffc>
I think the plan is 7:30pm at Gyu-Kaku

[20:19:34.0000] <rkirsling>
oh man, gyu-kaku is is the best

[20:19:47.0000] <rkirsling>
s/is is/is/

[21:12:16.0000] <sffc>
Text Myles if you want in; I think we have a reservation and seats are limited

[12:11:09.0000] <littledan>
can I just write my comments in the notes rather than taking up more time?

[12:11:15.0000] <littledan>
or, I could post it in an issue on the repo?

[12:11:27.0000] <littledan>
akirose: ystartsev ^

[12:11:32.0000] <robpalme>
if you're happy to and it's not a stage 1 blocker, pleas eod

[12:11:36.0000] <littledan>
OK

[12:12:04.0000] <jridgewell>
Filing an issue would be good

[12:20:02.0000] <devsnek>
realms have a map with reified intrinsic names?

[12:21:46.0000] <littledan>
does anyone have use cases for differentiating the this value and global object in Realms? I coudln't find anything in the repo, and filed this issue about it https://github.com/tc39/proposal-realms/issues/217

[12:22:10.0000] <devsnek>
littledan: isn't that how the window proxy works?

[12:22:26.0000] <littledan>
devsnek: On the web, there's only one thing you can get at

[12:22:30.0000] <devsnek>
oh ok

[12:22:32.0000] <littledan>
it's a proxy, yeah, but there aren't two separate values

[12:22:39.0000] <littledan>
I mean, there aren't two values available to JS

[12:22:55.0000] <devsnek>
right

[12:23:22.0000] <devsnek>
in node i exposed it as "global" on the new context api i'm trying to get merged in

[12:24:57.0000] <rbuckton>
littledan: There are two values (the window proxy and the target global), but the current evaluation context can only see one of them (the window proxy).

[12:25:15.0000] <littledan>
rbuckton: Right. So both the global and the this value would be the window proxy.

[12:25:37.0000] <littledan>
emulating the web isn't the use case here. I'm not sure what the use case is.

[12:26:15.0000] <rbuckton>
As far as the code under `evaluate` is concerned, yes. as far as the owner of the `Realm`, no. If you wanted to emulate a "window proxy" in your realm, you'd need to be able to access the *actual* global.

[12:27:24.0000] <littledan>
couldn't you do this by hooking two realms together, where you create a global object with the first one, and then you wrap it with a window proxy, and then you set that as the global object for the second one?

[12:27:56.0000] <rbuckton>
That sounds unnecessarily expensive. You'd end up with two sets of primordials.

[12:28:53.0000] <rbuckton>
If I were to make a change, it would be replacing `thisValue` in the realm init with a proxy handler (in which you access the actual global through proxy hooks).

[12:30:03.0000] <devsnek>
the first slide said one of the goals was supporting modules right

[12:44:20.0000] <devsnek>
numberformat is üëçüèª

[12:44:48.0000] <ghermeto>
mmarchini here

[12:45:31.0000] <michaelficarra>
I am sooooooo hyped for Intl.DurationFormatter

[12:45:54.0000] <devsnek>
everything on intl is pretty awesome

[12:46:08.0000] <devsnek>
except for Intl.v8BreakIterator

[12:46:14.0000] <devsnek>
:P

[12:46:14.0000] <rbuckton>
+1 for DurationFormatter, although I'd also like to see some kind of "time ago" or "time until"-style format as well.

[12:47:39.0000] <michaelficarra>
my interns were asking me for exactly DurationFormatter last week and I had nothing for them

[12:48:47.0000] <michaelficarra>
I love the format of this update, holy crap it's good

[12:49:13.0000] <devsnek>
yes

[12:49:16.0000] <michaelficarra>
kudos to sffc for making this super easy to follow

[12:50:15.0000] <akirose>
always

[12:50:37.0000] <akirose>
sffc's slides & presentations are always clear and easy to follow <3

[12:51:51.0000] <devsnek>
üéâ üéâ

[12:52:46.0000] <devsnek>
lol speaking of Intl.v8BreakIterator

[12:53:18.0000] <akirose>
caridy: did you catch that point of order?

[12:54:16.0000] <robpalme>
we need your slides, carridy

[12:59:35.0000] <caridy>
oh, sorry, it was linked from the readme of the proposal

[13:00:03.0000] <caridy>
https://github.com/tc39/proposal-realms/#presentations

[13:00:50.0000] <devsnek>
thank you

[13:00:55.0000] <devsnek>
in the future could you link it in the agenda?

[13:02:46.0000] <caridy>
oh, sure! I can do that too.

[13:03:12.0000] <devsnek>
thanks!

[13:03:36.0000] <ljharb>
caridy: added them to the agenda

[13:03:37.0000] <michaelficarra>
I already did it for you caridy

[13:03:51.0000] <michaelficarra>
btw the note takers are doing an excellent job this meeting!

[13:04:51.0000] <devsnek>
i just saw an Intl.Locale slide

[13:05:30.0000] <devsnek>
i see it again

[13:06:24.0000] <akirose>
jackworks: if we're ready for you, would you be able to go for lunch?

[13:11:17.0000] <michaelficarra>
ü§î I wonder who's going to be the first non-delegate to join...

[13:11:44.0000] <Bakkot>
does globbot count?

[13:11:49.0000] <michaelficarra>
no

[13:11:58.0000] <devsnek>
we already know who

[13:12:06.0000] <devsnek>
<--

[13:12:24.0000] <michaelficarra>
devsnek: you have +v, you don't count either

[13:12:29.0000] <michaelficarra>
also don't tell aki

[13:13:09.0000] <devsnek>
üëÄ

[13:13:59.0000] <ljharb>
also you're in the openjs foundation

[13:14:11.0000] <devsnek>
i'm not a delegate of the openjs foundation though

[13:14:20.0000] <michaelficarra>
shh yes you are

[13:14:22.0000] <akirose>
aren't you an "invited expert"

[13:14:40.0000] <devsnek>
that's my understanding

[13:14:47.0000] <robpalme>
rbuckton: are you good to go straight after lunch with resource mgmt?  that will be 12:30 hawaii time.

[13:14:59.0000] <rbuckton>
That's fine with me.

[13:17:12.0000] <robpalme>
thank yo!

[13:22:36.0000] <devsnek>
uhoh https://gc.gy/48642746.png

[13:24:05.0000] <Bakkot>
devsnek that's allowed

[13:24:21.0000] <Bakkot>
I think

[13:24:31.0000] <devsnek>
if you mean engine262, that's the current spec

[13:24:45.0000] <devsnek>
i was looking more at the undefined/null split

[13:25:00.0000] <Bakkot>
the undefined/null split is also allowed I think

[13:25:11.0000] <ljharb>
by virtue of "any crazy extension is allowed"?

[13:25:14.0000] <Bakkot>
yup

[13:25:26.0000] <Bakkot>
"caller" is one of the canonical crazy extensions

[13:25:41.0000] <devsnek>
this is a weird area

[13:26:36.0000] <akirose>
"one of the canonical crazy extensions" üëåüèª

[13:27:01.0000] <devsnek>
i just like that the spec uses the same "ThrowTypeError" function for so many different things

[13:27:18.0000] <devsnek>
"The caller, callee, and arguments properties may not be accessed on functions or the arguments objects for calls to them"

[13:30:01.0000] <devsnek>
point of order

[13:33:11.0000] <michaelficarra>
devsnek: yes?

[13:33:23.0000] <devsnek>
michaelficarra: shane had a point of order

[13:33:26.0000] <devsnek>
about who was talking

[13:33:38.0000] <devsnek>
i think the queue was updated

[13:33:47.0000] <akirose>
we good devsnek

[13:33:49.0000] <ystartsev>
akirose: will SES be done today?

[13:34:27.0000] <jackworks>
akirose: oops I'm in Shanghai can't go for lunch for you, it's 5am now in my place ü§£

[13:34:50.0000] <akirose>
haha i know jackworks lol i meant presenting before/after we took a break

[13:34:59.0000] <akirose>
but also i'd love to get lunch üòÇ

[13:35:18.0000] <ystartsev>
jackworks: damn, i can't make it past 3 am

[13:35:32.0000] <ystartsev>
i hope its the morning end of 5 am, not the night

[13:35:40.0000] <haxjs>
I'm eating my breakfast now, never east breakfast in 5am :)

[13:36:19.0000] <ystartsev>
im sitting in darkness o_o the evening drags on. there is no food

[13:36:30.0000] <ystartsev>
okok this should probably be in temporal dead zone

[13:37:16.0000] <rbuckton>
I need to grab myself some lunch. I should be back before the break is up

[14:36:26.0000] <akirose>
oh shit ystartsev i missed your earlier question

[14:36:30.0000] <akirose>
yeah i'm moving SES to tomorrow

[14:36:45.0000] <ystartsev>
ok, thanks akirose

[14:37:08.0000] <littledan>
hmm, I wonder if `using` could be spelled `try`...

[14:37:15.0000] <devsnek>
uh oh

[14:37:17.0000] <akirose>
O_O

[14:37:25.0000] <ystartsev>
try try?

[14:37:29.0000] <littledan>
(sorry, will follow up in issues)

[14:37:30.0000] <devsnek>
/me ducks

[14:54:56.0000] <cmorningstar>
akirose does Mark know you're moving the SES presentation?  I don't think he's following IRC

[14:55:27.0000] <akirose>
yeah and also the schedule is linked in the reflector

[14:55:41.0000] <cmorningstar>
(y)

[15:03:29.0000] <littledan>
`try expr` is free (if we require parens around an object literal), and we could permit it before declarations

[15:04:00.0000] <littledan>
`try const foo = bar;`, `try fooBar;`, `fn(try foo);`

[15:04:19.0000] <littledan>
(I also like Ron's answer)

[15:06:08.0000] <Bakkot>
I am a lot happier with the try-block form than the using-declaration form, personally

[15:06:16.0000] <Bakkot>
I'm curious how others feel

[15:06:31.0000] <devsnek>
i kinda want to explore the expression form more

[15:06:44.0000] <ljharb>
i like the using form, that can appear anywhere in a block

[15:11:27.0000] <robpalme>
ms person === "dean tribble"

[15:12:12.0000] <ljharb>
ms like microsoft? dean doesn't work for microsoft

[15:12:31.0000] <rbuckton>
he did many years ago

[15:12:49.0000] <ljharb>
ah

[15:16:05.0000] <shu>
rbuckton: is the awkwardness of having to name intermediates the only motivation for `using value` over only having `using const`?

[15:17:15.0000] <devsnek>
`using const _unused = ...`

[15:19:39.0000] <rbuckton>
It's not awkwardness. For cases like locking, you would be introducing an unused binding. IF you have multiple of these, you end up with a lot of unused bindings that clutter the scope. Also, you often have to contend with linters that error on unused bindings, meaning that many developers would have to add a fair amount of `// eslint-ignore`-like comments to their code for what would essentially have been:

[15:19:39.0000] <rbuckton>
```

[15:19:39.0000] <rbuckton>
try using(mutex.lock()) {

[15:19:39.0000] <rbuckton>
 ...

[15:19:39.0000] <rbuckton>
}

[15:19:39.0000] <rbuckton>
```

[15:20:38.0000] <shu>
rbuckton: i don't think linting is a real argument, since it'll still be syntactically distinguished with `using`

[15:20:52.0000] <shu>
rbuckton: as for "many unused bindings", this is not borne out by practice in large C++ code bases i've worked in

[15:20:56.0000] <rbuckton>
If we had resolved the destructuring issue to the stage1 semantics, we could have considered `using const {} = expr`, though that still feels odd.

[15:22:35.0000] <rbuckton>
shu: There was a reason we allowed `catch {}` without a binding. I'd very much like this feature to have a form that doesn't introduce a binding.

[15:23:09.0000] <shu>
i think the difference is the syntax cost for removing the binding for catch is much lower

[15:23:12.0000] <devsnek>
i can confirm i would use the bindingless version

[15:23:27.0000] <rbuckton>
shu: I've written a fair bit of JS code using async coordination primitives for synchronizing access to resources using async functions and make heavy use of the bindingless form for locking.

[15:23:49.0000] <devsnek>
and i don't know the state of the web locks api

[15:23:53.0000] <devsnek>
but i bet people using that would want to use it too

[15:24:35.0000] <rbuckton>
I would heavily use it with https://www.npmjs.com/package/@esfx/async

[15:24:49.0000] <devsnek>
is there some concern that iterator helpers is not going to happen?'

[15:24:57.0000] <rbuckton>
(which is a version of my old `prex` async coordination package).

[15:25:35.0000] <Bakkot>
devsnek no I just want them to happen in the right order

[15:25:40.0000] <devsnek>
k

[15:26:14.0000] <shu>
rbuckton: is there a stronger argument than "i would use it"? i mean i would use it with just the `using const` form for sure, since in my experience naming your RAII bindings is not really a big deal

[15:26:56.0000] <shu>
i think dan or someone earlier suggested just `using const (expr)` and not also `using value` and that is more preferable to me

[15:27:22.0000] <devsnek>
i can also confirm that its awkward in rust to need to name scoped allocations

[15:27:26.0000] <devsnek>
`let _ = ...`

[15:27:27.0000] <rbuckton>
shu: There's a *significant* amount of C# code written using C#'s version `using (expr) { ... }`

[15:27:43.0000] <shu>
that's not apples to apples?

[15:27:47.0000] <rbuckton>
`using const (expr)` is kind of interesting.

[15:28:28.0000] <rbuckton>
shu: The prior art in C# is where I pulled a lot of these concepts from, so I think it's applicable.

[15:28:47.0000] <shu>
rbuckton: using (expr) is a scope introduction form as well

[15:30:28.0000] <rbuckton>
shu: Yes. that was my question earlier. I see two paths forward:

[15:30:28.0000] <rbuckton>
1. Only `using const` and `using value` forms (no `try using` form).

[15:30:28.0000] <rbuckton>
1. `try using (const ...)`, `try using (expr)` and `using const` forms (no `using value`) (essentially the same as C# 8).

[15:30:56.0000] <rbuckton>
(why do I expect markdown numbered lists to work in IRCCloud)...

[15:32:19.0000] <devsnek>
lol

[15:33:22.0000] <shu>
rbuckton: i like a subset of the first 1. with only a binding form. if a bindingless form is overwhelmingly preferred by committee, that we only introduce a single syntax form

[15:34:02.0000] <littledan>
Object.keys is already a thing. Do we have any data on how slow are idioms using Object.keys?

[15:34:20.0000] <devsnek>
object.keys ain't that slow

[15:34:57.0000] <shu>
rbuckton: my objections are pretty weak

[15:35:03.0000] <shu>
rbuckton: i love RAII

[15:35:11.0000] <rbuckton>
shu: A bindingless form is important to several of the use cases that motivated my proposing this feature. I very much want some bindingless form to survive.

[15:35:37.0000] <littledan>
I can understand the argument that this propsal expresses intent better (modulo that I don't understand whether that's true or not) but I'm surprised that performance is used so much as a justification

[15:36:06.0000] <shu>
it seems slower than the previous version?

[15:39:29.0000] <littledan>
iterator helpers could be used with Object.keys and friends with Iterator.from()

[15:39:50.0000] <littledan>
I think the iterator helpers proposal is sort of predicated on the idea that this is a reasonable idiom

[15:40:04.0000] <littledan>
(which I think it is)

[15:40:58.0000] <shu>
i also do think it is a reasonable idiom. reality is that people do use objects for small-ish collections and will continue to

[15:41:12.0000] <rbuckton>
JSON `reviver` is *very* hard to use on any non-trivial JSON object graph. (without the proposed changes to JSON.parse).

[15:41:50.0000] <Bakkot>
I expect code bases which are using iterator helper to have a lot of `Thing.from(Iterator.from(obj).foo().bar())`

[15:41:55.0000] <Bakkot>
for node lists of whatever

[15:42:00.0000] <Bakkot>
*or whatever

[15:42:01.0000] <ystartsev>
rbuckton: do you think the reviver proposal in json parse helps this at all?

[15:42:26.0000] <Bakkot>
and having `Object.fromEntries(Iterator.from(Object.entries(obj)).foo().bar())` seems pretty much fine

[15:42:33.0000] <Bakkot>
it matches that pattern

[15:42:37.0000] <rbuckton>
ystartsev: For the most part, yes. It's definitely a step in the right direction.

[15:42:43.0000] <Bakkot>
where Object.iterateEntries() does not match that pattern

[15:42:49.0000] <ystartsev>
rbuckton: i would rather support that then, if that is the case that is really being solved

[15:43:04.0000] <ljharb>
Bakkot: `Object.fromEntries(Object.iterateEntries(obj).foo().bar())`?

[15:43:16.0000] <devsnek>
Iterator.from

[15:43:20.0000] <ljharb>
Bakkot: you wouldn't necessarily use Iterator.from if you're getting an iterator from a builtin

[15:43:22.0000] <devsnek>
foo and bar are iterator prototype methods

[15:43:29.0000] <ystartsev>
devsnek: iterator.from wont work in this case i think

[15:43:29.0000] <devsnek>
oh i see what you did nvm

[15:43:35.0000] <ljharb>
right but all the builtins are going to spit out Iterators already

[15:43:42.0000] <ljharb>
Iterator.from is for coercing user types

[15:43:48.0000] <devsnek>
i thought ljharb did Object.entries()

[15:43:49.0000] <Bakkot>
ljharb you would use a prototype method or Iterator.from, I expect

[15:43:52.0000] <ljharb>
just like you wouldn't use Array.from or Promise.resolve if you already know it's an array or a promise for sure

[15:44:12.0000] <devsnek>
i wouldn't do Iterator.from([].values())

[15:44:13.0000] <Bakkot>
I don't know that (e.g.) node lists expose a prototype method exposing an iterator

[15:44:21.0000] <Bakkot>
except for [Symbol.iterator]

[15:44:29.0000] <devsnek>
yeah you'd use Iterator.from on a node list

[15:44:32.0000] <Bakkot>
and I will absolutely use Iterator.from() over an explicit [Symbol.iterator]

[15:44:40.0000] <devsnek>
that's why its there

[15:44:42.0000] <devsnek>
üëçüèª

[15:44:46.0000] <michaelficarra>
agreed

[15:44:52.0000] <ljharb>
Bakkot: agreed on that part

[15:44:53.0000] <devsnek>
well also to cover iterators that don't inherit from Iterator.prototype

[15:45:10.0000] <ljharb>
Bakkot: but if you're using anything that spits out an iterator, you wouldn't want or need Iterator.from

[15:45:12.0000] <Bakkot>
presumably only user iterators will fail to inherit from Iterator.prototype

[15:45:15.0000] <ljharb>
* a real iterator

[15:45:16.0000] <ljharb>
Bakkot: right

[15:45:32.0000] <ljharb>
you might use it like `[].concat(x)` or `Promise.resolve(x)` to not have to think about it, sure

[15:45:34.0000] <Bakkot>
ljharb right but most things don't spit out iterators

[15:45:42.0000] <Bakkot>
they spit out nodelists

[15:45:44.0000] <Bakkot>
or whatever

[15:45:45.0000] <ljharb>
matchAll, values/keys/entries on things

[15:45:50.0000] <ljharb>
but yes that's true

[15:45:56.0000] <ljharb>
obv if you have an iterable you'd use Iterator.from

[15:47:24.0000] <rbuckton>
I'm still a little unsure of iterator helpers. It still feels like its the wrong abstraction (i.e. operate over an "iterator" rather than an "iterable").

[15:47:55.0000] <ljharb>
there's no inheritance chain for "iterable"s

[15:48:03.0000] <rbuckton>
Yeah, I know that.

[15:48:14.0000] <ljharb>
i definitely think that things that take iterators should always take iterables; but i don't see any other way for the helpers proposal to work

[15:48:14.0000] <devsnek>
you'd need a chain builder

[15:48:22.0000] <ljharb>
Iterator.from is that builder

[15:48:51.0000] <devsnek>
no like IterableBuilder(iterator).filter().map()[Symbol.iterator]()

[15:49:01.0000] <devsnek>
for ron's pattern

[15:49:05.0000] <ljharb>
ah

[15:49:09.0000] <rbuckton>
devsnek: That's what my `iterable-query` package does:

[15:49:10.0000] <rbuckton>
```

[15:49:10.0000] <rbuckton>
const { from } = require("iterable-query");

[15:49:10.0000] <rbuckton>
from(x).filter(...).map(...).toArray();

[15:49:10.0000] <rbuckton>
```

[15:49:18.0000] <rbuckton>
But it operates over iterables, not iterators.

[15:49:29.0000] <devsnek>
iterators are iterables

[15:49:36.0000] <ljharb>
`from` takes an iterable; but filter and map are surely operating on iterators?

[15:49:36.0000] <devsnek>
but i get your point

[15:49:41.0000] <Bakkot>
for things where you are coercing back at the end, it seems like you should absolutely be operating on iterators, not iterables

[15:49:42.0000] <rbuckton>
devsnek: not precisely.

[15:49:55.0000] <Bakkot>
you shouldn't need to build up the whole collection every time

[15:49:59.0000] <rbuckton>
built-in iterators are iterables.

[15:50:01.0000] <devsnek>
iterators are iterable by the definition of iterable in this language

[15:50:12.0000] <ljharb>
no

[15:50:12.0000] <devsnek>
oh i see what you mean

[15:50:16.0000] <devsnek>
fair enough

[15:50:17.0000] <rbuckton>
User-defined iterators aren't iterables (which was mentioned above).

[15:50:19.0000] <ljharb>
all built-in iterators happen to be iterables

[15:50:27.0000] <ljharb>
iterators have "next", iterables have Symbol.iterator

[15:50:38.0000] <rbuckton>
TypeScript calls them "IterableIterator"s

[15:50:42.0000] <Bakkot>
I have very rarely seen someone define an iterator without using a generator

[15:50:58.0000] <devsnek>
you won't get very far if your iterator isn't iterable though

[15:51:04.0000] <devsnek>
since for loops won't accept it

[15:51:43.0000] <littledan>
the reviver thing seems like a red herring; there are other reasons you might iterate over an object (e.g., they have really nice literals to use in JS). But that's why we have Object.keys/values/entries

[15:52:27.0000] <rbuckton>
If you look at C#/.NET's `Enumerable` class or RX, iterating over (or subscribing to) those chained operations by default result in re-executing each step in the chain against the original collection source.

[15:52:30.0000] <ljharb>
devsnek: for..of takes non-iterable iterators

[15:52:39.0000] <Bakkot>
ljharb wait does it?

[15:52:43.0000] <Bakkot>
how does that work?

[15:52:44.0000] <ljharb>
hm

[15:52:46.0000] <ljharb>
wait maybe not, one sec

[15:53:03.0000] <devsnek>
https://engine262.js.org/#gist=66a1fede0f3a2fa776e3c99dacd87b81

[15:53:04.0000] <ljharb>
ok no, it doesn't, i was fooled by an inherited Symbol.iterator method

[15:53:09.0000] <devsnek>
lol

[15:53:15.0000] <rbuckton>
`for..of`takes iterables. The iterators those iterables produce don't themselves need to be iterable.

[15:53:24.0000] <Bakkot>
even when you try to get a non-iterable iterator you can't :P

[15:53:37.0000] <rbuckton>
`for..of` never directly calls `next`.

[15:53:52.0000] <devsnek>
huh

[15:54:06.0000] <devsnek>
it calls it in the head of the loop

[15:54:06.0000] <ljharb>
rbuckton: wait what?

[15:54:16.0000] <rbuckton>
It indirectly calls `next`.

[15:54:27.0000] <devsnek>
it does IteratorNext/IteratorStep

[15:54:31.0000] <devsnek>
because we have a helper

[15:54:37.0000] <devsnek>
but that still seems pretty direct to me

[15:54:38.0000] <ljharb>
rbuckton: ah ok

[15:54:39.0000] <rbuckton>
`for (const x of y)` doesn't call` next` on `y`, it calls `next` on the result of `y[Symbol.iterator]()`.

[15:54:45.0000] <ljharb>
yeah i'd call that directly calling it

[15:54:49.0000] <ljharb>
right

[15:55:06.0000] <michaelficarra>
ugh I can't believe it's taken us this long to add these

[15:56:04.0000] <rbuckton>
```

[15:56:04.0000] <rbuckton>
for (const x of { [Symbol.iterator]() { return { next() { return { done: true }; } }; } }) { }

[15:56:04.0000] <rbuckton>
```

[15:56:04.0000] <rbuckton>
Works fine, the iterator returned from `[Symbol.iterator]` doesn't need to itself have a `[Symbol.iterator]`.

[15:56:06.0000] <rkirsling>
I wish we could replace the "Logical" in this proposal name but I don't have a better idea offhand and I guess it doesn't really matter wrt the ultimate spec/impl change s

[15:56:37.0000] <michaelficarra>
rkirsling: what's wrong with logical?

[15:56:45.0000] <michaelficarra>
they're the logical operators

[15:56:47.0000] <devsnek>
i'd call it "getting the rest of the binary operators"

[15:56:56.0000] <rkirsling>
but ?? isn't truth-oriented

[15:57:16.0000] <rkirsling>
which is what "logical" really means

[15:57:20.0000] <michaelficarra>
sorry, it *used to be* the logical operators

[15:57:29.0000] <rkirsling>
yes, that part is very true :D

[15:57:39.0000] <rbuckton>
rkirsling: it sort of is, but the "truth" is the truth of "is the operand null or undefined".

[15:57:53.0000] <ljharb>
they're not really logical operators tho, they're value selection operators

[15:57:59.0000] <ljharb>
imo logical operators produce booleans

[15:58:00.0000] <rbuckton>
Sure

[15:58:11.0000] <devsnek>
short circuiting binary operators take it or leave it

[15:58:16.0000] <rbuckton>
Fair enough.

[15:58:25.0000] <rbuckton>
devsnek: Wordy, but I like it.

[15:58:39.0000] <rbuckton>
ljharb: `"" || 1` does not produce a boolean.

[15:58:53.0000] <devsnek>
i think that's ljharb's point

[15:58:54.0000] <rkirsling>
I had brought this up here: https://github.com/tc39/proposal-nullish-coalescing/pull/50

[15:58:55.0000] <ljharb>
rbuckton: that's because it's not a logical operator

[15:59:09.0000] <ljharb>
rbuckton: in a language where || is a logical operator, it produces true or false

[15:59:10.0000] <rbuckton>
"logical-ish operators"

[15:59:13.0000] <rkirsling>
but I don't think in this case it'll have an impact on spec names anyway

[15:59:17.0000] <ljharb>
it's a value selection operator.

[15:59:19.0000] <rkirsling>
(I should verify)

[15:59:31.0000] <devsnek>
rkirsling: it got removed

[15:59:36.0000] <devsnek>
because of the parens thing

[15:59:36.0000] <michaelficarra>
the semantics in this proposal appear obviously correct

[15:59:43.0000] <rkirsling>
devsnek: what did?

[15:59:51.0000] <devsnek>
the name "ShortCircuitExpression"


2020-02-06
[16:00:02.0000] <rkirsling>
whaa

[16:00:10.0000] <devsnek>
oh wait it didn't

[16:00:11.0000] <devsnek>
i lied

[16:00:20.0000] <rbuckton>
ES logical-ish operators work on boolean-ish values like truthy and falsy.

[16:00:34.0000] <devsnek>
i was accidentally looking at bitwise ops

[16:00:39.0000] <rkirsling>
yeah phew

[16:01:11.0000] <ljharb>
rbuckton: some value selection operators pivot on truthiness. `??` is a value selection operator that pivots on nullishness.

[16:01:16.0000] <rkirsling>
rbuckton: yeah my point is to be really diligent about not mixing "truthy" and "nullish" terminology willy-nilly

[16:01:17.0000] <ljharb>
neither are logical.

[16:01:27.0000] <ljharb>
rkirsling: lol

[16:01:46.0000] <howdoi>
6 years ago https://usercontent.irccloud-cdn.com/file/uZGwDHvC/sc

[16:01:57.0000] <rbuckton>
ljharb: A few meetings ago there was a (possibly joking) proposal to introduce strict-logical operators `|||` and `&&&`

[16:01:57.0000] <rkirsling>
ljharb: :high-five:

[16:02:06.0000] <ljharb>
rbuckton: lol yes, and those would be logical

[16:02:16.0000] <howdoi>
https://esdiscuss.org/topic/shorthand-notation-for-attribute-creation

[16:02:49.0000] <devsnek>
"object creation" good orthogonality

[16:02:58.0000] <devsnek>
s/object/attribute/

[16:03:51.0000] <howdoi>
true that

[16:06:41.0000] <ystartsev>
rbuckton: omg

[16:09:54.0000] <devsnek>
if we go with the one where it doesn't call set

[16:10:00.0000] <devsnek>
does it block exceptions

[16:10:06.0000] <devsnek>
like `thisDoesNotExist ||= false`

[16:10:11.0000] <Bakkot>
michaelficarra by "in this proposal" do you mean the short-circuiting variant?

[16:10:30.0000] <michaelficarra>
yes

[16:10:34.0000] <rbuckton>
devsnek: if `thisDoesNotExist` is not defined, it would throw on the attempt to read the binding.

[16:10:42.0000] <devsnek>
oh true

[16:10:43.0000] <devsnek>
lol

[16:10:57.0000] <akirose>
haxjs: do you want to do one of your topics after the break (in about 20-30 minutes)?

[16:11:06.0000] <howdoi>
2001!

[16:11:48.0000] <Bakkot>
I have notes in my closet about adding class fields dating back to 1999

[16:11:55.0000] <rbuckton>
sffc: optional chaining doesn't permit assignment.

[16:12:24.0000] <rbuckton>
(as much as I would rather it did).

[16:12:48.0000] <howdoi>
Bakkot: wow!

[16:13:14.0000] <ystartsev>
sffc: optional chaining disallows assignment atm

[16:21:29.0000] <rbuckton>
That `a?.setValue(b)` works but `a?.value = b` doesn't is unfortunate to me.

[16:21:58.0000] <devsnek>
seems reasonable to me

[16:21:59.0000] <Bakkot>
yeah I am really happy that doesn't work

[16:23:37.0000] <robpalme>
breaking until 14:33 (10 mins)

[16:27:47.0000] <brad4d>
kiwi IRC keeps dropping my connection - what linux clients are folks using?

[16:28:07.0000] <akirose>
irssi

[16:28:38.0000] <akirose>
irssi running in tmux is what i used to use on linux

[16:28:51.0000] <akirose>
err no it was running in screen

[16:29:11.0000] <akirose>
i fell in love with tmux only in the past 5 or 10 years

[16:39:05.0000] <devsnek>
hearing "filter in" confuses me

[16:39:13.0000] <rkirsling>
^

[16:39:14.0000] <rbuckton>
Do any existing languages use `filterOut`? Scala and Kotlin use `filterNot`

[16:39:17.0000] <devsnek>
if you start with "filter out" then "filter in" makes sense

[16:39:28.0000] <devsnek>
but the other way around makes my brain not understand

[16:39:29.0000] <rkirsling>
I don't like `filterOut` because "filter in" is not an English phrase

[16:39:43.0000] <rkirsling>
but `filterWithout` might be not unthinkable?

[16:39:51.0000] <michaelficarra>
brad4d: I use empathy typically, but it's not working here due to blocked ports

[16:39:59.0000] <rbuckton>
I like `filterNot` because the semantics and name have precedence in other languages.

[16:40:02.0000] <michaelficarra>
so for now I'm using the freenode webchat

[16:40:23.0000] <rkirsling>
rbuckton: ditto but Justin doesn't like it

[16:40:56.0000] <rbuckton>
I would argue for prior art as it helps developers of multiple languages make sense of the feature.

[16:41:22.0000] <devsnek>
removeIfCallbackReturnsTrue

[16:41:41.0000] <devsnek>
actually

[16:41:43.0000] <devsnek>
remove and keep

[16:41:46.0000] <devsnek>
üëÄ

[16:42:00.0000] <rbuckton>
`.excludeIf` :/

[16:42:14.0000] <devsnek>
i don't like having "if" in the name

[16:42:20.0000] <devsnek>
removeIf and keepIf work though

[16:42:22.0000] <ljharb>
`.omit`, if we're not calling it filter something?

[16:42:22.0000] <rbuckton>
Me either.

[16:42:42.0000] <devsnek>
exclude is also a negative which is not ideal

[16:42:45.0000] <rbuckton>
`.omit` is interesting.

[16:43:03.0000] <devsnek>
omit and emit

[16:43:12.0000] <rbuckton>
devsnek: `exclude` is also the opposite of `include`, which is already used for a different meaning on arrays (i.e. ,`.includes(value)`)

[16:43:38.0000] <rbuckton>
devsnek: That'll just be another `wake` and `wait` problem.

[16:43:50.0000] <devsnek>
rbuckton: yeah i being facetious

[16:43:58.0000] <michaelficarra>
`Function.prototype.not = function() { let self = this; return function() { return !self.apply(this, arguments); }; };`

[16:44:05.0000] <devsnek>
oh no

[16:44:08.0000] <michaelficarra>
oh yes

[16:44:19.0000] <rbuckton>
oh the overhead

[16:44:27.0000] <rkirsling>
oh the humanity

[16:44:29.0000] <rkirsling>
(sorry)

[16:44:39.0000] <devsnek>
bindInverse

[16:45:01.0000] <rkirsling>
I think I'd support `.omit`

[16:45:08.0000] <devsnek>
omit is good

[16:45:15.0000] <devsnek>
assuming its the opposite of what filter does

[16:45:16.0000] <michaelficarra>
`reject` is fine

[16:45:19.0000] <devsnek>
i don't know what it does

[16:45:24.0000] <devsnek>
off the top of my head

[16:45:33.0000] <michaelficarra>
also I still kinda prefer groupBy/partition, we can kill two birds with one stone

[16:45:47.0000] <rbuckton>
I dislike `reject` because of possible `Promise.reject`confusion. I like `filterNot`, but `omit` isn't terrible.

[16:46:00.0000] <rbuckton>
I'd love `groupBy`

[16:46:02.0000] <rkirsling>
yeah I think the Promise.reject concern is legitimate too

[16:46:35.0000] <devsnek>
as in

[16:46:35.0000] <devsnek>
partition into two groups

[16:46:35.0000] <devsnek>
keep one?

[16:46:39.0000] <rbuckton>
Then again, my iterable-quer package has `groupBy`, so I'm biased.

[16:46:45.0000] <rbuckton>
*query

[16:46:59.0000] <michaelficarra>
devsnek: yeah, a special-cased groupBy

[16:47:09.0000] <devsnek>
why not just sort and slice

[16:47:12.0000] <devsnek>
:)

[16:47:41.0000] <michaelficarra>
justin has argued against groupBy/partition because of the perceived overhead from returning a container and taking out the bit you care about

[16:48:01.0000] <devsnek>
i wouldn't use partition to filter

[16:48:03.0000] <devsnek>
if it were a thing

[16:48:06.0000] <michaelficarra>
but I don't think we should really care about the wrappers that often don't actually have to be realised

[16:48:07.0000] <devsnek>
i'd use it to partition

[16:48:45.0000] <rbuckton>
Yeah, if you don't want the `false` values, `partition` would have unnecessary overhead since it would produce both sides of the condition.

[16:49:51.0000] <michaelficarra>
rbuckton: not necessarily though

[16:50:34.0000] <michaelficarra>
when you pull the thruthy result out immediately and the falsey result is unobservable, the engine doesn't need to realise it

[16:51:04.0000] <michaelficarra>
this kind of optimisation (the same we discussed earlier with Object.iterateKeys) seems fairly straightforward to me

[16:51:19.0000] <devsnek>
lot of overhead for non-jit impls

[16:51:25.0000] <devsnek>
especially in embedded case

[16:51:28.0000] <devsnek>
where memory is tight

[16:51:35.0000] <michaelficarra>
non-jit impls are dog slow ayway, who cares?

[16:51:37.0000] <michaelficarra>
*anyway

[16:51:48.0000] <devsnek>
performance isn't the only concern

[16:52:04.0000] <devsnek>
if you only have 64k of ram you can't be wasting it on unused arrays

[16:52:05.0000] <rbuckton>
Yeah. Even in a jit impl, you still need to hold onto all of the memory *just in case* the calling code requests it.

[16:52:41.0000] <michaelficarra>
rbuckton: there's no "just in case" when you can prove there's no way to observe it

[16:53:39.0000] <devsnek>
it may not always be as simple as partition(xyz)[0]

[16:54:13.0000] <devsnek>
my point was basically just "jit will make it usable" is not a great choice imo

[16:54:34.0000] <devsnek>
don't want to get too into the weeds of how things jit

[16:54:40.0000] <jridgewell>
`filterNot` only works as a name if you understand what `filter` does

[16:54:45.0000] <rbuckton>
Also depends on engine implementers actually implementing the optimization, which could take time depending on their backlog and other work.

[16:55:01.0000] <jridgewell>
The "not" doesn't imply what's happening

[16:55:10.0000] <michaelficarra>
ü§∑ you don't even need a JIT, keith_miller was saying it could probably be done at the interpreter level

[16:55:17.0000] <michaelficarra>
and I agree

[16:55:21.0000] <jridgewell>
It's simply inverting `filter`, which is my problem, I can't remember what `filter` does.

[16:55:33.0000] <rbuckton>
jridgewell: You said your self, every language that uses `filter` has the same semantics as JS, so it seems fairly obvious what `filterNot` would mean to those developers.

[16:55:40.0000] <devsnek>
interpreter is one of the stages of jit

[16:55:52.0000] <michaelficarra>
jridgewell: I think that regardless of what comes of this proposal, you're going to start remembering what filter does now

[16:55:54.0000] <michaelficarra>
problem solved

[16:55:58.0000] <devsnek>
(i assume no implementations are doing AST walks?)

[16:56:01.0000] <jridgewell>
Every language is wrong. üòõ

[16:56:09.0000] <devsnek>
(aside from engine262)

[16:56:34.0000] <devsnek>
i actually do know what splice does now

[16:58:01.0000] <devsnek>
michaelficarra: the point is that we shouldn't rely on engines performing optimizations to js code

[16:58:28.0000] <devsnek>
like something that walks over an ast tree is a valid (but slow) implementation

[16:58:54.0000] <michaelficarra>
I think we can't make performance-based justifications in the absence of information about performance optimisations

[16:59:44.0000] <rkirsling>
I think that just means we shouldn't make perf-based justifications for this?

[17:02:25.0000] <rbuckton>
Aside from perf discussions, it's a high bar to expect developers to reason that the opposite of `filter` is `partition(...)[0]` or `partition(...)[1]`, as they'd likely need to review documentation on `partition` to know which array was which.

[17:03:09.0000] <rkirsling>
yeah I don't really think those conversations should be merged

[17:03:48.0000] <michaelficarra>
rbuckton: who said array?

[17:03:58.0000] <michaelficarra>
`partition(...).true`

[17:04:12.0000] <michaelficarra>
`groupBy(...).true`

[17:04:18.0000] <michaelficarra>
same thing

[17:04:21.0000] <rbuckton>
I'd like `filterNot` (whatever it is named) for perf-critical scenarios, as there are a lot of *positive* filter callbacks out there (like `isString`, etc.), but you rarely see an `isNotString`, so you end up with a lot of `.filter(x => !isString(x))`, which produces more overhead than a `.filterNot(isString)`.

[17:05:12.0000] <rkirsling>
rbuckton: I mean you could reasonably expect that it would *eventually* lead to better perf but it wouldn't be a spec conformance req

[17:05:32.0000] <rbuckton>
michaelficarra: Definitely wouldn't use `groupBy` like that (i'd expect to be able to group by other keys besides booleans that may not have a reliable `toString` implementation). `partition` maybe, since all the `partition` implementations I've seen only split on boolean.

[17:06:14.0000] <littledan>
we've discussed the rationale for BigInt's JSON semantics at length in TC39; I'd be happy to follow up with anyone offline for background here

[17:16:46.0000] <michaelficarra>
why hasn't there been as much screaming about not being able to round trip undefined values?

[17:16:50.0000] <ystartsev>
ok folks, im out

[17:17:07.0000] <michaelficarra>
ECMAScript distinguishes null from undefined pretty consistently, for better or worse

[17:17:11.0000] <ystartsev>
ill be back in the morning

[17:17:15.0000] <ljharb>
michaelficarra: i assume because most languages don't have two nil values

[17:17:17.0000] <jridgewell>
üëã

[17:17:25.0000] <michaelficarra>
but in JSON we just convert to null and call it a day

[17:17:25.0000] <rkirsling>
üëã

[17:17:44.0000] <michaelficarra>
ljharb: but we are ECMAScript

[17:17:45.0000] <jridgewell>
michaelficarra: I've actually written code that depends on undefined not being round-tripped for security

[17:18:14.0000] <michaelficarra>
jridgewell: the question is why do people care so much about round-tripping of BigInt but not undefined?

[17:18:42.0000] <ljharb>
because undefined is one value, and it's not that useful to know it's there, but bigint represents infinite values

[17:19:56.0000] <michaelficarra>
ljharb: finite but very many

[17:20:08.0000] <ljharb>
sure

[17:20:09.0000] <apaprocki>
we get questions for NaN all the time

[17:20:18.0000] <michaelficarra>
infinite strings of characters are not valid JSON I believe

[17:20:34.0000] <ljharb>
a great many, then, the point stands

[17:20:35.0000] <michaelficarra>
apaprocki: same thing!

[17:21:22.0000] <bterlson>
wait, did ecma404 add  a size limit??

[17:22:16.0000] <michaelficarra>
bterlson: not a finite one, no

[17:22:55.0000] <devsnek>
lol

[17:23:47.0000] <devsnek>
ljharb: they have infinite precision but can only represent finite numbers

[17:24:34.0000] <apaprocki>
philosophical question.. does a string of infinite length have a trailing "?

[17:24:54.0000] <Bakkot>
"arbitrarily many"

[17:24:59.0000] <Bakkot>
apaprocki mu

[17:25:02.0000] <devsnek>
infinity+1

[17:25:10.0000] <Bakkot>
oh this is the wrong channel again

[17:25:42.0000] <michaelficarra>
as the meeting goes on, #tdz slowly merges with #tc39-delegates

[17:26:05.0000] <akirose>
every time

[17:28:14.0000] <rkirsling>
truly every time

[17:28:19.0000] <rkirsling>
this doesn't bode well for tomorrow

[17:35:03.0000] <littledan>
from remote I can hear Ron very well

[17:35:18.0000] <littledan>
Brian also talked

[17:35:23.0000] <littledan>
he's talking now

[17:35:39.0000] <Bakkot>
thanks littledan

[17:35:45.0000] <Bakkot>
our speaker is quiet for some reason

[17:35:46.0000] <Bakkot>
trying to fix it

[17:35:50.0000] <Bakkot>
fixed!

[17:38:56.0000] <littledan>
the comment about methods on each TypedArray prototype seems misplaced: the built-in methods are on the shared superclass

[17:42:56.0000] <cmorningstar>
michaelficarra an infinite string of characters *might* be valid JSON, but it's too soon to tell.

[17:43:50.0000] <michaelficarra>
I guess we'll just agree that it both is and isn't for now

[17:46:03.0000] <devsnek>
we are not using webidl

[17:46:05.0000] <devsnek>
in node core

[17:46:06.0000] <devsnek>
MylesBorins:

[17:47:23.0000] <shu>
SDO = standards development body btw

[17:49:07.0000] <rkirsling>
"org" you mean?

[17:50:23.0000] <bterlson>
SDO = Software Documentation Outhouse

[17:50:25.0000] <akirose>
pedant üòù

[17:50:29.0000] <bterlson>
wrong channel sorry

[17:50:33.0000] <littledan>
devsnek: Well, you might benefit in terms of spec compliance if you used a generator, and tests based on idlharness.js

[17:50:50.0000] <littledan>
my coworker Joyee has been working on applying this in Node.js Core, for existing APIs

[17:51:00.0000] <rkirsling>
akirose: oh sorry, I was actually making sure myself >_<

[17:51:08.0000] <devsnek>
littledan: yeah not saying we shouldn't

[17:51:12.0000] <devsnek>
just that we currently don't

[17:51:23.0000] <devsnek>
i love what jsdom does

[17:51:38.0000] <littledan>
oh right of course you know about this already, sorry for being redundant

[17:51:50.0000] <littledan>
my understanding was that WebCrypto in Node Core was pretty early

[17:52:06.0000] <devsnek>
currently separate repo https://github.com/nodejs/webcrypto

[17:55:17.0000] <michaelficarra>
we LITERALLY define subtraction by normative reference to another spec!

[17:55:22.0000] <michaelficarra>
what is this example?!

[17:55:34.0000] <Bakkot>
amazing

[17:55:42.0000] <michaelficarra>
same with Intl and the Unicode data sets

[17:59:29.0000] <littledan>
/me holds self back from clarifying, again, that we don't reference CLDR or ICU

[17:59:38.0000] <littledan>
oh, I guess I didn't do that right

[17:59:56.0000] <littledan>
(we do reference the Unicode Character Database)

[18:02:25.0000] <michaelficarra>
üòú

[18:03:58.0000] <littledan>
that comment in the WebCrypto repo was made by a W3C staffer. It's not clear how this relates to other W3C participants think.

[18:04:38.0000] <littledan>
and it's not clear what's meant by referencing the definition: should it observably call it, as we're talking about UUID doing?

[18:04:41.0000] <littledan>
https://github.com/w3c/webcrypto/issues/227

[18:04:52.0000] <Bakkot>
littledan oh, ok. he has the commit bit on the repo so I assumed he was the maintainer for these purposes

[18:07:05.0000] <littledan>
the W3C often performs useful functions in terms of releasing specifications and helping with broad review, so commit bits are not surprisng

[18:07:11.0000] <ljharb>
rbuckton: please lmk when you've renamed the proposal/repo, and i'll update the proposals repo

[18:07:37.0000] <rbuckton>
Sure.

[18:08:40.0000] <Bakkot>
littledan is there way to answer the question of what other W3C participants think?

[18:09:04.0000] <littledan>
Bakkot: Yeah, maybe you could reconvene the WebCrypto WG, whose charter expired? :)

[18:09:10.0000] <Bakkot>
uh

[18:09:15.0000] <Bakkot>
would prefer to not do that

[18:09:50.0000] <Bakkot>
Would reconvening be necessary if it's just a matter of shuffling which things are in which spec?

[18:12:37.0000] <littledan>
maybe starting with an email to the person who filed that issue (who's been landing things), the person listed as editor, and the other person landing things over the past year?

[18:13:04.0000] <littledan>
there's an interesting question of whether we care about a new standard being released, or whether it'd be enough to get an update into the editor's draft

[18:14:07.0000] <littledan>
long-brewing W3C work would enable just updating the editor's draft and not worrying. Lots of people just update the draft and are happy, even in the absence of this procedure.

[18:16:57.0000] <littledan>
Bakkot: Are we talking about an observable change, or just an editorial one?

[18:17:39.0000] <Bakkot>
littledan it sounds like Shu would not want changes where were observable from the perspective of web developers

[18:21:24.0000] <littledan>
Bakkot: Are you suggesting that we have two API entrypoints that reference the same internal algorithm, which is the CSRNG?

[18:21:58.0000] <ljharb>
that'd be the typical way these things are done; but i assume it's easier to virtualize if there's one, not two entry points that need replacing

[18:22:09.0000] <Bakkot>
littledan I am suggesting ECMA262 requires hosts to have a global named `crypto` which is required to have a property named `getRandomValues` which is specified to do exactly the thing the W3C crypto.getRandomValues does right now

[18:22:22.0000] <littledan>
oh, I see

[18:22:39.0000] <Bakkot>
possibly first make the observable change which would allow you to invoke it without `crypto` being the receiver, which is dumb

[18:23:30.0000] <jridgewell>
Wouldn't they be more annoyed that we "claimed" their object?

[18:23:37.0000] <littledan>
this would be slightly complicated to do unobservably--crypto.getRandomValues follows WebIDL, not ECMA-262, conventions. But it sounds possible to me. I'm not sure if the committee might have additional requirements (like this weakening you're suggesting)

[18:23:40.0000] <jridgewell>
`crypto` is a Web object

[18:24:01.0000] <rbuckton>
Bakkot: does it today? Unless its a WebIDL thing, I don't see anything in the spec text that enforces that.

[18:24:07.0000] <Bakkot>
rbuckton it is a webidl thing

[18:24:30.0000] <Bakkot>
jridgewell well, we'd have to ask

[18:24:31.0000] <Bakkot>
I would hope not

[18:24:46.0000] <devsnek>
it wouldn't be the first time a spec left w3c

[18:25:31.0000] <rbuckton>
My concern is that if ECMAScript ships a global `crypto` object, how would the crypto API make that a `Crypto` object (which also has a `subtle` property for `SubtleCrypto`)? Would we have to specify the prototype is "host defined"?

[18:26:07.0000] <littledan>
Bakkot: so, I'd lay that option out clearly in the issue, and then ping the people who have been landing patches and who maintain implementations

[18:26:22.0000] <ljharb>
rbuckton: it'd probably have to ship a CryptoPrototype, so that there was a place for the web to stick stuff on

[18:26:33.0000] <rbuckton>
Or would the host just augment a theoretical `%cryptoprototype%`?

[18:26:36.0000] <ljharb>
^ that

[18:26:39.0000] <Bakkot>
yeah that

[18:26:53.0000] <rbuckton>
There's a possible web-compat problem though.

[18:27:04.0000] <Bakkot>
Is there?

[18:27:07.0000] <littledan>
WebIDL is specified in terms of stuff that ES exposes

[18:27:14.0000] <littledan>
we could do just the same things, and make the change unobservable

[18:27:26.0000] <rbuckton>
Yeah, code that might feature test for `crypto` vs `require("crypto")`.

[18:27:28.0000] <littledan>
or, we could decide that we don't like the looks of it and it must change

[18:27:36.0000] <Bakkot>
littledan right, I meant, I want to be able to do `(0, crypto.getRandomValues)()` and have that work

[18:27:41.0000] <Bakkot>
this was more of an aside

[18:27:46.0000] <ljharb>
rbuckton: true, but that kind of code would break with any new global

[18:27:47.0000] <rbuckton>
https://github.com/rbuckton/reflect-metadata/blob/master/Reflect.js#L1099

[18:28:08.0000] <littledan>
rbuckton: Sounds like you're talking about a Node-compat problem? But then the WebCrypto-in-Node effort faces that anyway

[18:28:18.0000] <ljharb>
rbuckton: that wouldn't break, that'd just start working better once the global appeared

[18:28:19.0000] <Bakkot>
rbuckton that isn't web compate, it's node compat, right?

[18:28:20.0000] <rbuckton>
Then again, that wouldn't break because it *does* use `getRandomValues`, but there could be others.

[18:28:24.0000] <littledan>
anyway there could be ecosystem compat problems due partial implementations, yes

[18:28:34.0000] <ljharb>
if node suddenly added a matching `crypto`, then your code Just Works

[18:29:01.0000] <wsdferdksl>
rbuckton: I get a 404 on this link from the proposal: https://rbuckton.github.io/proposal-arraybuffer-fillrandom

[18:29:03.0000] <ljharb>
and if the code needs `crypto.foo` and isn't checking for the presence of `crypto.foo` then it's brittle anyways

[18:29:20.0000] <rbuckton>
wsdferdksl: I just transferred it to tc39-transfer

[18:29:29.0000] <littledan>
Bakkot: Right, I'm pretty worried that there are several different things that are different about WebIDL from TC39's work, and making the change unobservable would be controversial for us

[18:29:38.0000] <rbuckton>
Ah, there's no spec text generated yet.

[18:29:39.0000] <littledan>
I'd really prefer that, if we do port it, that we don't make these changes

[18:29:51.0000] <Bakkot>
littledan yeah, it would be a two-step thing

[18:30:02.0000] <Bakkot>
ideally get them to change, and then port it

[18:30:03.0000] <littledan>
remember, TC39's changes to TypedArrays still aren't ecosystem reality

[18:30:07.0000] <Bakkot>
but alternatively just don't worry about it

[18:30:08.0000] <rbuckton>
Rather, there's no ecmarkup generated spec text yet.

[18:30:09.0000] <littledan>
some of them are, some of them aren't

[18:30:12.0000] <Bakkot>
and do the thing W3C says

[18:30:18.0000] <ljharb>
wsdferdksl: https://tc39-transfer.github.io/proposal-csprng/

[18:30:35.0000] <ljharb>
wsdferdksl: the url will change again tho once a chair (akirose robpalme MylesBorins bterlson) bounces it into the tc39 org

[18:30:57.0000] <akirose>
on it

[18:31:01.0000] <ljharb>
oh lol the spec is empty anyways

[18:31:08.0000] <ljharb>
akirose: ty

[18:31:16.0000] <rbuckton>
There's nothing in there right now though. All of the current spec text exists in the explainer.

[18:31:23.0000] <Bakkot>
littledan: fwiw the change I want to crypto.getRandomValues is just making a non-error into an error, so I am almost certain is web compat

[18:31:45.0000] <rbuckton>
I'll clean that up once the transfer process has completed.

[18:32:10.0000] <wsdferdksl>
The links towards the end point to the rbuckton.github.io version.

[18:32:42.0000] <michaelficarra>
Bakkot: you mean the other way around?

[18:32:47.0000] <rbuckton>
I can fix that too. Its surprising GH doesn't auto-forward those like it does for other URLs related to a transfer.

[18:32:52.0000] <Bakkot>
michaelficarra uh yeah that

[18:33:39.0000] <littledan>
Bakkot: There's also a question of how much extra work it will be to go and weaken this. And if you look at everything, I bet you'll come up with more changes you feel like making

[18:33:48.0000] <littledan>
*work in implementations

[18:34:30.0000] <ljharb>
rbuckton: unfortunately there's no easy way to forward both

[18:34:41.0000] <Bakkot>
littledan I have looked at everything and that is the only change I think is worth making

[18:34:44.0000] <ljharb>
rbuckton: if you ever make a new repo with the same name as an old name, it breaks the repo redirects

[18:35:04.0000] <rbuckton>
ljharb: There wasn't anything substantive in there anyways, so I'll adjust the URL once the transfer finishes.

[18:39:10.0000] <ljharb>
kk

[18:40:02.0000] <sffc>
I also added one more 30-min timebox to the end of the agenda of we have time tomorrow

[18:42:37.0000] <michaelficarra>
sffc: I think we should add agenda items in the appropriate order, regardless of whether they were added late

[18:42:38.0000] <robpalme>
sffc: we currently have 3hrs 50mins of content to fit into a 5 hour window.  so we will probably have time to add your 30min topic

[18:42:45.0000] <michaelficarra>
leave it to the chairs to prioritise

[18:44:11.0000] <rbuckton>
I've just redirected the spec link to the #todo section for now.

[18:44:40.0000] <shu>
slides seem pretty slow to advance

[18:44:58.0000] <jridgewell>
Dan is always super laggy on calls.

[18:45:06.0000] <michaelficarra>
I think littledan just always has some delay

[18:47:58.0000] <littledan>
sorry! were you able to understand me anyway?

[18:48:04.0000] <littledan>
I'm not sure how to remove the delay?

[18:48:58.0000] <jridgewell>
It was only the slides

[18:49:02.0000] <jridgewell>
So your audio seemed fine

[18:49:14.0000] <jridgewell>
But you were talking about something before we could see the slide you were discussing

[18:49:42.0000] <Bakkot>
keith_miller https://tc39.es/proposal-weakrefs/#sec-liveness

[18:49:50.0000] <Bakkot>
"WeakRef.prototype.deref being called on a WeakRef whose referent is obj"

[18:49:52.0000] <littledan>
oh, well, you know, the slides are linked from the agenda

[18:54:31.0000] <Bakkot>
shu I am pretty sure the liveness definition doesn't do what you want: if you have `a = {}; b = { a }; a.b = b;` and then WeakRefs to both `a` and `b`, and you lose access to both `a` and `b` but keep access to both WeakRefs, then `a` and `b` are still live, which seems bad

[19:59:48.0000] <rbuckton>
shu: I put up a draft PR to explore the possibility of devising a web-compatible `crypto` global in place of `ArrayBuffer.fillRandom`: https://github.com/tc39-transfer/proposal-csprng/pull/2

[20:00:09.0000] <shu>
thank you

[11:40:03.0000] <gibson042>
michaelficarra:

[11:40:03.0000] <gibson042>
$ eshost -se 'Object.keys({[2**32+3]:true, [2**32+2]:true, [2**32+1]:true, [2**32]:true, [2**32-1]:true, [2**32-2]:true, [2**32-3]:true}).map(n => n-2**32)'

[11:40:03.0000] <gibson042>
#### Chakra, JavaScriptCore, SpiderMonkey, V8, XS

[11:40:03.0000] <gibson042>
-3,-2,3,2,1,0,-1

[12:01:47.0000] <littledan>
note, it was possible to hear Yulia from remote

[12:02:30.0000] <brad4d>
in the room we have to turn on a microphone next to a zoom speaker to hear remote folks :)

[12:02:42.0000] <brad4d>
now fixed

[12:06:05.0000] <littledan>
note, I'd be happy to do this for all of my presentations as well, I'm just not sure how to set it up

[12:06:13.0000] <devsnek>
recordin?

[12:06:15.0000] <devsnek>
g

[12:06:15.0000] <littledan>
yes

[12:06:32.0000] <littledan>
it's a good idea to help share information around

[12:06:38.0000] <devsnek>
if you happen to be zooming you can use zoom

[12:06:46.0000] <devsnek>
otherwise obs works well

[12:07:11.0000] <littledan>
maybe the committee could help facilitate this recording too, and storing and presenting the uploaded videos

[12:12:13.0000] <bterlson>
I made this thing using Moddable's stuff: https://twitter.com/bterlson/status/1219461543647039490. This keyboard firmware will allow (safe) extensions too thanks to this SES stuff.

[12:12:38.0000] <bterlson>
https://gist.github.com/bterlson/c615924c7ef7bb5d45908cdb6417c3be is a code dump from a few weeks ago

[12:13:16.0000] <michaelficarra>
what non-static scoping is Mark referring to here?

[12:13:23.0000] <michaelficarra>
I assumed it was globals

[12:23:45.0000] <gibson042>
I like the Caridy's vocabulary from https://docs.google.com/presentation/d/1pkxAvJQvL-DeiygPFfs4ecdV39Cfv8cBe-zAfunhp5A/edit#slide=id.g75cbab44da_0_106 : "Primordials are the subset of Intrinsics that are reachable by ECMAScript source text"

[12:30:41.0000] <MylesBorins>
littledan: I can make sure that it is recording

[12:30:49.0000] <MylesBorins>
module attributes or do you have another presentation?

[12:31:04.0000] <littledan>
MylesBorins: I'd be happy with this; I probably should've recorded the decimal one

[12:34:23.0000] <michaelficarra>
for those with difficulty with colours, the MR items are all green, the first CMR item is blue and the rest are red, and the first 3 items of the STMR are blue, the last is red

[13:00:41.0000] <devsnek>
how does importSync work

[13:00:51.0000] <devsnek>
that doesn't make sense to me

[13:09:03.0000] <michaelficarra>
devsnek: different questions

[13:09:10.0000] <michaelficarra>
nobody answered you because you asked how it works

[13:09:15.0000] <michaelficarra>
not whether he described how it works

[13:09:20.0000] <devsnek>
oh fair point

[13:11:16.0000] <michaelficarra>
https://i.imgflip.com/3oev83.jpg

[13:11:27.0000] <littledan>
I guess importSync makes sense if modules are provided by a static map. It seems unfortunate to lose the dynamic case, but I can understand that, for some environments, it doesn't make sense

[13:11:48.0000] <littledan>
so I guess importSync would be unavailable if you provide a host hook for modules rather than the module map

[13:11:54.0000] <littledan>
(?)

[13:12:04.0000] <devsnek>
ü§∑üèª

[13:13:06.0000] <michaelficarra>
I needed this for a time elapsed/remaining display on effectively a video player we were making, just last week

[13:13:16.0000] <littledan>
this presentation is great

[13:13:32.0000] <littledan>
concreteness is really good

[13:13:36.0000] <michaelficarra>
littledan: agreed, I love seeing a variety of justifications up front

[13:14:17.0000] <michaelficarra>
needs an Oxford comma option though

[13:14:25.0000] <michaelficarra>
(or just include it always, fine by me)

[13:14:43.0000] <ljharb>
+1

[13:14:53.0000] <mmarchini>
formatting time duration is a pain on every language I had to do it so far

[13:15:15.0000] <mmarchini>
would love to see it improved on JS

[13:16:57.0000] <sffc>
jridgewell: yes, I think that's a typo

[13:24:33.0000] <michaelficarra>
oh man I'm going to miss the desk mics so much when we don't have them

[13:35:26.0000] <rbuckton>
There's an unfortunate web-compat issue I need to work out for CSPRNG if we intend to bring in part of WebCrypto: https://github.com/tc39/proposal-csprng/issues/5

[13:35:26.0000] <rbuckton>
Basically, WebCrypto throws `TypeMismatchError` and `QuotaExceededError`, but my current spec text just reuses `TypeError` and `RangeError`. It wasn't a web-compat issue when the API was attached to `ArrayBuffer` (because it wouldn't break existing code), but *is* a web-compat issue if we chose to bring in the global `crypto` object.

[13:36:20.0000] <rbuckton>
s/chose/choose

[14:16:35.0000] <haxjs>
can't find today's notes url...

[14:16:46.0000] <haxjs>
Could anyone repaste it?

[14:17:16.0000] <jridgewell>
Don‚Äôt paste it here

[14:17:22.0000] <jridgewell>
It‚Äôs on the reflector

[14:17:32.0000] <jridgewell>
1 sec

[14:18:06.0000] <jridgewell>
https://github.com/tc39/Reflector/issues/271

[14:18:12.0000] <haxjs>
ok! thank you!

[14:18:50.0000] <devsnek>
when are we resuming

[14:19:01.0000] <jridgewell>
12:30

[14:33:56.0000] <rbuckton>
Are there slides?

[14:34:05.0000] <Bakkot>
not that we are seeing

[15:21:46.0000] <shu>
akirose: robpalme: could you double check at the next meeting break that we retained consensus for independent lifetime FinalizationGroups? (retained in the sense this was the original, historical intent of the proposal, if confusing.) this was kind of implied by people saying they're okay with changing the name of the constructor to better reflect independent lifetimes and i'd like it explicitly asked

[15:22:42.0000] <ljharb>
bradleymeck: that's not a bug, that's by design - everything >= the first default argument is optional

[15:23:25.0000] <robpalme>
shu: ack

[15:26:02.0000] <bradleymeck>
ljharb: i'm not arguing the intent, but that bugs in libraries have occured due to misunderstanding and usage in the wild has shown issues

[15:28:15.0000] <ljharb>
k

[15:39:27.0000] <ljharb>
can we get istvan set up on the queue

[15:43:34.0000] <ljharb>
can a chair interrupt him please? there's later queue items about time zones and stuff

[15:43:40.0000] <ljharb>
akirose: robpalme MylesBorins ^

[15:49:43.0000] <ljharb>
akirose: totally fair point about stage 4 :-p

[15:49:59.0000] <akirose>
it came up in a panel at some point

[15:50:10.0000] <akirose>
"how fast can you ship a feature"

[15:50:13.0000] <akirose>
something like that

[15:50:48.0000] <ljharb>
i guess theoretically a patch to a browser, timed right before a release hits the train, could get out in a matter of weeks, with the cooperation of the browser?

[15:53:00.0000] <Bakkot>
browsers can ship things before stage 3 if they want

[15:53:01.0000] <michaelficarra>
I super agree with Saboff's point


2020-02-07
[16:10:57.0000] <ljharb>
i really like andrew's two-physical-location suggestion

[16:12:15.0000] <michaelficarra>
do we need the remote plenaries at all if we just held these topic-oriented calls?

[16:12:26.0000] <ystartsev>
yes

[16:12:34.0000] <michaelficarra>
ystartsev: why?

[16:12:35.0000] <ystartsev>
they have different purposes

[16:12:48.0000] <ystartsev>
one is plenary, the other is feedback

[16:12:52.0000] <ystartsev>
plenary has decisions

[16:12:52.0000] <devsnek>
full plenary gets people who aren't focused on x looking at x

[16:13:27.0000] <michaelficarra>
am I wrong in understanding that the goal with the first part is that we just want to reduce in-person plenaries?

[16:14:00.0000] <ystartsev>
from my perspective the two tasks need different kinds of focus

[16:14:23.0000] <jridgewell>
I agree with ystartsev

[16:14:27.0000] <ystartsev>
feedback is generative, decision making is narrowing -- we say no to things

[16:14:51.0000] <michaelficarra>
okay so for those who support remote plenary, why do you support it?

[16:15:35.0000] <ystartsev>
right now im remote. it works well. the main problem i am facing is that its three days in a row; I also participate in other standards bodies who have a weekly plenary meeting for 1 hour and meet once a year. it works well there

[16:15:55.0000] <michaelficarra>
we can have fewer in-person meetings if we just move some of the feedback and review from those meetings to remote meetings (where non-binding decisions are made)

[16:15:59.0000] <ystartsev>
the travel burden of 6 times a year is very hard for someone not in the USA, and we lose a lot of participation as a result

[16:16:25.0000] <ystartsev>
feedback rounds have different forms of thinking. i don't think they directly translate into decisons

[16:16:53.0000] <ystartsev>
and if we use incubation things as decision making spaces, then the real benefit of feedback rounds is lessened.

[16:16:58.0000] <michaelficarra>
ystartsev: I am getting the feeling you think I'm supporting 6 in-person meetings

[16:17:17.0000] <ystartsev>
no, i hear you -- you are fine with reducing without making decisions in calls

[16:17:41.0000] <michaelficarra>
yes and I think we agree on that point

[16:17:44.0000] <ystartsev>
my preference is to make decisions in calls, because i don't see that much benefit to keeping it to in person plenaries

[16:17:53.0000] <ystartsev>
and, i think that the two different forms of thinking are important

[16:18:18.0000] <ystartsev>
i would not be completely opposed to what you are proposing, for what its worth

[16:18:30.0000] <michaelficarra>
okay so you think we should have fewer in-person meetings, remote plenaries, and incubation calls?

[16:18:46.0000] <ystartsev>
i suspect incubation calls will be a subset of the committee

[16:18:56.0000] <michaelficarra>
yes I think that's the idea

[16:18:57.0000] <ljharb>
i suspect you're right

[16:20:06.0000] <ljharb>
tbh i don't think incubation calls (which i think are a good thing) really impact the remote plenary discussion, except in that it adds to the number of frequent calls that delegates have to add to their calendar

[16:20:19.0000] <ystartsev>
^yes thats true

[16:21:06.0000] <ljharb>
eg i already have about 6 hour-long calls, some weekly, some bi-weekly, and incubation calls and remote plenaries would add more things to that

[16:21:23.0000] <ljharb>
(probably more, i didn't go cout)

[16:21:25.0000] <ljharb>
*count

[16:28:38.0000] <decompil_>
as a concrete action, can we just get the incubation calls going?

[16:32:26.0000] <robpalme>
resuming at 14:42 with hax (10 mins)

[16:41:07.0000] <robpalme>
haxjs: please be aware that your timebox is reduced by 10 minutes due to your previous item overrunning.  so you have 20mins from now.

[16:43:34.0000] <sffc>
akirose: interested in the panel

[16:44:11.0000] <shu>
decompiled: i didn't want to spring it on people without heads up i guess, but since it's designed as a subset anyway, we can do a "trial run"

[16:44:13.0000] <gibson042>
I strongly agree with ystartsev and others about the quality of less-frequent in-person plenaries improving from better overall presence and participation

[16:44:22.0000] <shu>
decompiled: a trial run before the next in-person meeting

[16:44:28.0000] <shu>
decompiled: look out for a reflector thread if interested!

[16:45:01.0000] <decompiled>
shu: will do. definitely interested longer term as I bring subsequent proposals. would have helped ahead of the Object iteration one this time üòÖ

[16:45:25.0000] <shu>
decompiled: one thing we didn't get a chance to hammer on some more is that dan and i believe the incubation calls should be good mentoring spaces

[16:45:44.0000] <shu>
less people, more relaxed, no stigma about questions and taking time

[16:46:01.0000] <shu>
well, there'll be timeboxes, but there shouldn't be pressure that the end of the timebox means we need to have a conclusion

[16:46:19.0000] <decompiled>
yup, definitely a good principle to follow -- will help make this committee more inclusive and welcoming for sure

[16:49:10.0000] <rickbutton>
+1 shu

[17:03:28.0000] <ljharb>
jridgewell: `apply` is already a MOP operation, no?

[17:03:41.0000] <jridgewell>
Oh, I thought it was call.

[17:04:03.0000] <ljharb>
aren't apply vs call the same?

[17:04:53.0000] <akirose>
something about array vs arg list?

[17:04:57.0000] <akirose>
i didn't even google that

[17:05:14.0000] <jridgewell>
There are currently two operations in `obj.foo()`

[17:05:31.0000] <jridgewell>
1. A GET

[17:05:31.0000] <jridgewell>
2. An APPLY

[17:06:06.0000] <jridgewell>
(I think that APPLY is badly named, but oh well)

[17:06:13.0000] <jridgewell>
If we could instead combine those into a single "apply" operation

[17:06:35.0000] <jridgewell>
Then we could easily use wrapping proxies on the object to detect improper use

[17:06:37.0000] <ljharb>
ah like a getApply or something

[17:06:42.0000] <jridgewell>
Yah

[17:06:48.0000] <jridgewell>
Mark has wanted one for a while

[17:06:52.0000] <ljharb>
but then a proxy could make `obj.foo()` do something different than `(0,obj.foo).call(obj)`

[17:06:54.0000] <ljharb>
that seems super weird

[17:07:09.0000] <jridgewell>
Yes

[17:09:13.0000] <jridgewell>
Agree with shu

[17:10:27.0000] <ystartsev>
also agree with shu

[17:10:57.0000] <devsnek>
is shu the one that said it shouldn't stage 1 if we know its not going to get past that

[17:11:20.0000] <jridgewell>
I think he doesn't want to confuse people

[17:11:28.0000] <jridgewell>
The current solutions presented are unlikely to advance

[17:11:35.0000] <devsnek>
no i'm just trying to track who said what

[17:11:40.0000] <jridgewell>
So saying they're stage 1 would be confusing

[17:11:43.0000] <jridgewell>
Yes

[17:11:51.0000] <devsnek>
cool

[17:11:51.0000] <jridgewell>
That was shu

[17:11:59.0000] <ljharb>
devsnek: imo shu said that if the stage 1 thing is called "X", but "X" isn't the thing that's likely to proceed, it shouldn't be called "X"

[17:12:13.0000] <devsnek>
ok yes i realize it was a bad summary

[17:12:23.0000] <ljharb>
and since stage 1 is supposed to be about solving a problem, stage 1 proposals should probably be consistently/thoroughly named in a way that describes the problem, not a particular solution

[17:16:15.0000] <wsdferdksl>
I'm very uncomfortable with the pressure to make stage 1 proposals very vague.

[17:16:33.0000] <ljharb>
wsdferdksl: not vague - specific about the problem, which is what stage 1 is about

[17:16:47.0000] <wsdferdksl>
That's vague.

[17:17:21.0000] <apaprocki>
it is only an issue in cases where the proposed solution has clear objections but the "idea" has merit

[17:17:21.0000] <wsdferdksl>
I can name lots of problems for which there will be as many opinions about what a solution could be as there are folks in the meeting

[17:17:27.0000] <apaprocki>
that doesn't mean concrete stage 1 proposals are bad

[17:17:43.0000] <ljharb>
wsdferdksl: sure, but debating the solution is a stage 2 concern

[17:17:45.0000] <apaprocki>
just that if the concrete idea has clear objections, it needs to become more general

[17:17:55.0000] <ljharb>
wsdferdksl: meaning, it's mostly irrelevant when discussing stage 1 advancement

[17:18:11.0000] <wsdferdksl>
Not being on the same page just wastes the committee's time

[17:18:37.0000] <ljharb>
that's why it's so important that we're all on the same page about what problem is being solved

[17:18:52.0000] <ljharb>
(before we debate solutions, for which the primary motivating problem should be informing us)

[17:19:17.0000] <devsnek>
they are not blocked

[17:19:28.0000] <wsdferdksl>
Debating problems is not productive without a solution in mind. It's a waste of time.

[17:19:40.0000] <devsnek>
they could easily put this data in the import maps

[17:19:45.0000] <devsnek>
or something similar

[17:19:51.0000] <devsnek>
would reduce duplication too

[17:19:54.0000] <ljharb>
wsdferdksl: that's a strong opinion i'm not sure is universally shared

[17:20:17.0000] <wsdferdksl>
It probably isn't, but it's become a problem at this meeting.

[17:20:27.0000] <ystartsev>
who is wsderdksl?

[17:20:38.0000] <ystartsev>
can you set your whois?

[17:21:02.0000] <akirose>
++ waldemar please add your name to your nick

[17:21:14.0000] <ljharb>
wsdferdksl: i certainly expect most stage 1 proposals to have a solution in mind, but discussing that solution before we even agree that the problem needs solving imo is a much bigger waste of time

[17:21:33.0000] <wsdferdksl>
Sure

[17:21:37.0000] <ystartsev>
thanks

[17:22:30.0000] <wsdferdksl>
I was replying to ljharb

[17:22:35.0000] <ljharb>
wsdferdksl: i think that when a stage 1 proposal has a clearly understood problem, that it makes total sense to focus on a primary solution

[17:26:21.0000] <sffc>
akirose: I'd like at least 5-10 minutes to pitch my problem and get a list of people with opinions so we can follow up offline

[17:27:24.0000] <robpalme>
sffc: we might be able to get you 5 mins.  modules finishes at 15:50.

[17:30:10.0000] <haxjs>
I'm a little confused about how a stage 1 proposal should be, I try my best to explain  the problems, the use cases, and the possible solutions. It may be better to summary the question domain as: we need 1. a runtime reflection mechanism to check the intention of a callable whether it meet the requirement of an API, so it could protect programmers, 2. a declarative mechanism to mark the intention of a function

[17:30:10.0000] <haxjs>
whether  it's a method (we already have the way for constructor and normal callback like arrow functions) .  could such description better for advance for stage 1??

[17:30:12.0000] <michaelficarra>
haxjs: if you want help rewording your thisArgumentExpected proposal to be acceptable for stage 1, let me know

[17:30:33.0000] <michaelficarra>
oh, looks like we crossed paths, let me explain

[17:31:48.0000] <michaelficarra>
so the way you've described the domain you're looking into here seems fine to me, we just need to update the proposal document to remove the specific solution you brought forward

[17:32:07.0000] <ljharb>
(or de-emphasize?)

[17:32:25.0000] <michaelficarra>
shu was afraid that people would read too much into the proposed solution and assume we were going that route, when we do not want to express that intention

[17:32:36.0000] <haxjs>
Oh. but it seems there are some doubt about proposals without concrete solutions as possible direction in the past??

[17:32:46.0000] <michaelficarra>
haxjs: what are some examples of those?

[17:32:59.0000] <michaelficarra>
or do you mean that there was a doubt that there even could be a solution?

[17:34:40.0000] <ljharb>
i think that if the readme talks about the problem space, and then clearly and explicitly describes "here is one potential solution" but also explains that the committee had reservations about it, that it's fine

[17:35:07.0000] <michaelficarra>
we'd have to get confirmation from shu on that

[17:35:15.0000] <haxjs>
ok. I will edit the readmes!

[17:35:26.0000] <shu>
i think given the magnitude of the feedback

[17:35:53.0000] <shu>
it's not a potential solution, but a proposed rejected solution

[17:35:58.0000] <michaelficarra>
haxjs: to be clear, the explicit this proposal was rejected from stage 1, regardless of readme changes

[17:36:22.0000] <michaelficarra>
shu: that is probably a better way to describe it, yeah

[17:36:34.0000] <shu>
or rather, a rejected proposed solution

[17:36:40.0000] <haxjs>
Ok. but i need to understand the main concerns about the reason of rejection. Currently I'm not sure I get them.

[17:36:45.0000] <shu>
(proposed rejected sounds like it was proposed to be rejected)

[17:37:31.0000] <michaelficarra>
haxjs: from Waldemar, "WH: This does not solve any problem and introduces a new way of saying `this` in the language, which is not a problem that we have. It is not that phrasing it in a different way would make it more acceptable, I don‚Äôt see this as solving a problem."

[17:38:02.0000] <michaelficarra>
I think the general feeling I got among delegates was that they could already alias in the body with a let declaration

[17:38:12.0000] <ljharb>
* const :-p

[17:38:16.0000] <michaelficarra>
whatever

[17:38:59.0000] <devsnek>
but if you use out of band you don't need to worry about a host supporting or rejecting your syntax

[17:39:08.0000] <devsnek>
cuz the host just loads the metadata it knows how to load

[17:39:08.0000] <haxjs>
why it could be? it just like normal parameters... don't understand this part.

[17:39:46.0000] <haxjs>
this parameter syntax is only for userland code, why it will affect host?

[17:40:02.0000] <ljharb>
haxjs: that comment was re module attributes

[17:40:15.0000] <haxjs>
oh sorry

[17:40:27.0000] <devsnek>
oh yeah i wasn't referring to your proposal hax sorry

[17:42:21.0000] <haxjs>
michaelficarra "I think the general feeling I got among delegates was that they could already alias in the body with a let declaration" --- naming it only the side effect of "this parameter syntax", I already listed many other important usages like annotation/decorator which never possible without syntax.

[17:42:23.0000] <devsnek>
Bakkot: was it you who said the host could just reject resolution

[17:42:32.0000] <devsnek>
if the as thing is present

[17:42:34.0000] <Bakkot>
that was keith_miller I think

[17:42:56.0000] <devsnek>
keith_miller: forgot to ping you above

[17:42:59.0000] <keith_miller>
Bakkot: What was me?

[17:43:07.0000] <Bakkot>
keith_miller "who said the host could just reject resolution"

[17:43:12.0000] <keith_miller>
I don't know where I'm looking

[17:43:13.0000] <Bakkot>
"if the as thing is present"

[17:43:15.0000] <devsnek>
if one host rejects the load and another host needs it

[17:43:16.0000] <keith_miller>
Oh, yeah

[17:43:20.0000] <keith_miller>
That was me

[17:43:24.0000] <devsnek>
your code can't be loaded by anything

[17:44:03.0000] <devsnek>
on the other hand if the web knows to load a manifest file

[17:44:03.0000] <keith_miller>
Uhh, I guess you need to know what host your running on

[17:44:22.0000] <devsnek>
well yeah

[17:44:25.0000] <devsnek>
but that's kind of unfortunate

[17:44:35.0000] <keith_miller>
I'm not saying it's a good practice

[17:44:56.0000] <devsnek>
i'm not sure there is a possible practice

[17:45:00.0000] <devsnek>
you support host a or host b

[17:49:44.0000] <MylesBorins>
thanks for the great feedback everyone

[17:49:54.0000] <michaelficarra>
bradleymeck hit the nail on the head here

[17:50:10.0000] <ljharb>
my question is similar, i think

[17:50:12.0000] <michaelficarra>
symbols if they implement multiple interfaces, strings otherwise

[17:50:30.0000] <rbuckton>
The problem is that its too early to know, these objects may have a dual purpose in the future.

[17:50:48.0000] <ljharb>
seems like making one thing have two purposes is problematic?

[17:51:00.0000] <michaelficarra>
if they're very clearly single-purpose, they're basically like an arguments bag: use strings

[17:51:03.0000] <michaelficarra>
otherwise, use symbols

[17:53:11.0000] <Bakkot>
two specific purposes would also be fine

[17:53:18.0000] <Bakkot>
the question is whether it's random other stuff, or just those things

[17:53:35.0000] <michaelficarra>
agreed Bakkot

[17:53:53.0000] <ljharb>
fair

[17:55:37.0000] <Bakkot>
e.g. iterator needed to be a protocol because you have all kinds of things which are iterable, .then needed to be a protocol because you have a kinds of things which can be in a promise, etc. but options bags should be string-based.

[17:56:23.0000] <Bakkot>
*_iterable_ needed to be a protocol. but iterator didn't.

[17:56:49.0000] <michaelficarra>
we should document this design philosophy somewhere

[17:56:59.0000] <michaelficarra>
it's important and the community should also be aware

[17:57:38.0000] <michaelficarra>
oh wait, I know!

[17:57:40.0000] <michaelficarra>
https://freenode.logbot.info/tc39-delegates/20200207#c3203202-c3203222

[17:57:46.0000] <michaelficarra>
there we go, documented

[17:57:50.0000] <devsnek>
"Strings." is the motto of this month's tc39

[17:57:55.0000] <devsnek>
oops wrong channel

[18:02:29.0000] <devsnek>
thanks everyone, see y'all next time!

[18:04:38.0000] <michaelficarra>
üëã devsnek


2020-02-12
[02:20:01.0000] <mathiasbynens>
who has commit access to the tc39.github.io repo? please merge https://github.com/tc39/tc39.github.io/pull/187 asap

[03:20:56.0000] <littledan>
mathiasbynens: Thanks for the ping. Does anyone else want commit access?

[03:21:14.0000] <littledan>
I don't see the reason to restrict it; I think we can trust TC39 delegates to use this responsibly

[03:21:49.0000] <littledan>
well, or we could give it to everyone who seems to be actively, productively contributing to the website (which would include mathiasbynens and chicoxyzzy for example)

[09:07:00.0000] <bradleymeck>
whenever we get a chance to review/complete the transfer https://github.com/tc39-transfer/proposal-async-init that would be wonderful


2020-02-16
[17:15:26.0000] <rkirsling>
.


2020-02-17
[05:00:24.0000] <ystartsev>
I will be publishing the notes this week. Please make sure that your sections are correct

[05:01:00.0000] <ystartsev>
or, on monday next week actually, to make sure we have been at the 2 week mark from the last day

[05:02:11.0000] <ystartsev>
in any case, please check the notes!

[05:02:25.0000] <ystartsev>
i will not publish them before wednesday for sure


2020-02-21
[13:46:18.0000] <leobalter>
Hi everyone! I need some help. To continue working in the USA, I need to prove to the immigration department that my work on Test262 and ECMA-402 creates impact to the web as a whole. I've got some letters already but I'd love if anyone has time to help, I can also have the immigration lawyer to help drafting the letters. Please ping me.

[13:46:46.0000] <leobalter>
It feels shameful to ask it this way but it's personally critical.

[13:50:59.0000] <TabAtkins>
ain't nothing shameful about navigating the broken concept of citizenship, yo

[13:52:54.0000] <leobalter>
sure thing, but far from citizenship, this is even still for temporary residency

[13:53:41.0000] <rkirsling>
+1 to TabAtkins, the system is what's shameful...

[13:54:45.0000] <TabAtkins>
we need open borders, and that's that. in the meantime, you do what you gotta.


2020-02-24
[10:10:45.0000] <littledan>
interesting comparison for remote meetings: https://w3c.github.io/Guide/meetings/continuity.html (I don't think we're anywhere near this yet)

[10:11:13.0000] <littledan>
(this is about emergency situations; not related to "remote plenary")

[10:15:47.0000] <rkirsling>
could be directly relevant if the coronavirus situation doesn't improve though ü§î

[10:17:07.0000] <rkirsling>
we're already under an indefinite travel ban (though I can still make it to Cupertino since it's local)

[10:33:39.0000] <shu>
interesting advisory indeed

[10:44:46.0000] <ljharb>
the september meeting in tokyo seems potentially affected

[10:51:00.0000] <shu>
cdc has a level 2 travel notice on japan right now

[10:52:16.0000] <shu>
september is 7 months away but it looks like china is winding down while outbreak is speeding up outside of china, so potentially affects is probably right?

[14:41:23.0000] <shu>
ljharb: mind submitting a quick PR to test262 to fix the Atomics.store -0/+0 test?

[14:41:27.0000] <shu>
ljharb: there is no assert.ok in the test262 harness

[14:41:52.0000] <shu>
ljharb: think you want the plain assert()

[14:43:16.0000] <shu>
actually i'll submit one, could've done it by the time i typed out the messages :)

[15:20:03.0000] <ljharb>
shu: oops, my bad

[15:20:15.0000] <ljharb>
there's an assert.ok in node, so i assumed it'd be in test262


2020-02-26
[16:13:35.0000] <sffc>
Some experts are saying that the virus is not deadly enough to make it easy to control, and they think it may be inevitable that it spreads worldwide.  So it might affect Tokyo, but it might affect any other meeting as well.

[16:15:11.0000] <sffc>
I think it's basically viral pneumonia.  You can die from it, but you can also have the virus with mild to no symptoms.

[16:16:42.0000] <ljharb>
i mean, if we get to a point where travel doesn't make it worse, then we're good i gues

[16:16:45.0000] <ljharb>
"good"

[16:27:32.0000] <rkirsling>
SF declared state of emergency a few hours ago :-/

[16:27:42.0000] <rkirsling>
(in spite of no cases originating within the city)

[16:54:51.0000] <shu>
what really

[17:07:47.0000] <akirose>
that explains the panicked texts i just started getting

[17:09:05.0000] <akirose>
i am 3-5% worried about COVID-19 in case anyone is wondering

