2020-06-01
[17:24:37.0000] <rkirsling>
(whining aside though, it'll probably be beneficial to have a more structured schedule for a bit, lol)

[19:09:26.0000] <leobalter>
devsnek: congrats! Don’t stress out to much, it will probably be better to focus on the onboarding and take some rest if necessary instead of much of TC39 stuff. Don’t let the FOMO take out your energy.

[07:47:10.0000] <Bakkot>
morning all

[07:51:45.0000] <rkirsling>
mornin'

[07:55:01.0000] <bterlson>
TCQ: https://tcq.app/meeting/KfmX

[07:56:41.0000] <chicoxyzzy>
meeting info link in the topic is outdated. should be https://github.com/tc39/Reflector/issues/279

[07:58:28.0000] <chicoxyzzy>
thank you Rob :)

[07:59:33.0000] <mathiasbynens>
did anyone create notes docs already? happy to update the short URLs again

[08:01:36.0000] <Bakkot>
mathiasbynens they're in the reflector, yeah

[08:01:49.0000] <Bakkot>
also reminder to all not to link the notes here, in this publicly logged channel

[08:02:11.0000] <mathiasbynens>
i don't see them in https://github.com/tc39/Reflector/issues/279

[08:02:34.0000] <mathiasbynens>
i see, #294

[08:06:48.0000] <michaelficarra>
good morning everyone :-)

[08:08:31.0000] <howdoi>
Good morning! :)

[08:08:45.0000] <littledan>
if you call on me next, I can give my standard IPR disclaimer

[08:08:55.0000] <littledan>
I imagine Istvan's thing is not what was being asked about

[08:09:09.0000] <littledan>
akirose: ^

[08:09:15.0000] <mpcsh>
akirose: your headphones 😂

[08:09:22.0000] <mpcsh>
so fetch

[08:09:38.0000] <rkirsling>
+1

[08:10:00.0000] <rkirsling>
littledan: you kind of look like you're interrogating us with that light :p

[08:10:16.0000] <littledan>
heh I don't have my awesome coworking space setup

[08:10:49.0000] <littledan>
my partner is planning on building a nice planter behind me and hanging up some of his art so it can show up in my video calls, but I guess we didn't plan for the light

[08:11:51.0000] <rkirsling>
that sounds nice though :)

[08:13:30.0000] <rkirsling>
did you just say mancy

[08:13:43.0000] <rickbutton>
mancy

[08:36:25.0000] <shu>
i'm confused about this slides sharing

[08:36:31.0000] <shu>
*i* can control the slide?

[08:36:55.0000] <Bakkot>
oh no

[08:37:00.0000] <rricard>
deep powerpoint integration probably

[08:37:02.0000] <Bakkot>
that is too much power

[08:37:06.0000] <shu>
wait when i'm jumping around

[08:37:13.0000] <shu>
am i making it jump around for other viewers, or just myself

[08:37:14.0000] <rricard>
it's not jumping for us

[08:37:15.0000] <shu>
ok

[08:37:17.0000] <shu>
whew

[08:37:23.0000] <rricard>
you can peek ahead

[08:38:15.0000] <rickbutton>
I assume that doesn't work for Google Slides

[08:38:50.0000] <rricard>
I would assume that yes

[08:39:05.0000] <rricard>
you can always export your slides in ppt

[08:40:20.0000] <Bakkot>
presumably one would need to actually have ppt lying around for that to do you any good

[08:40:29.0000] <Bakkot>
I don't think I have used a machine with ppt since high school

[08:41:11.0000] <Bakkot>
oh, teams is a ppt viewer apparently, neat

[08:45:16.0000] <akirose>
fwiw i literally just uploaded Istvan's ppt that he had emailed to the chair straight to the teams client

[08:45:26.0000] <akirose>
no ppt.app launched

[08:46:43.0000] <ljharb>
phew, irc is working again

[08:46:47.0000] <ljharb>
(for me)

[08:48:33.0000] <akirose>
draft schedule link added to reflector#279

[08:54:36.0000] <littledan>
these editorial improvements are awesome!

[08:55:41.0000] <marja_>
+1

[08:56:22.0000] <rkirsling>
+1

[09:01:53.0000] <michaelficarra>
thanks littledan :-)

[09:23:35.0000] <littledan>
akirose: *green heart emoji* been feeling similarly

[09:23:55.0000] <rickbutton>
100000%

[09:26:32.0000] <devsnek>
is tcq showing everything or just stuff for today

[09:26:43.0000] <robpalme>
everything

[09:26:51.0000] <robpalme>
we chew through as much of it as we can

[09:27:03.0000] <robpalme>
it may not yet be fully populated but that is the intent

[09:27:36.0000] <devsnek>
cool

[09:27:53.0000] <devsnek>
do we have that hackmd schedule this time around

[09:28:03.0000] <Bakkot>
this channel is public and should not have the notes doc linked in it

[09:28:17.0000] <ryzokuken>
devsnek: we do

[09:28:22.0000] <Bakkot>
robpalme ^

[09:28:23.0000] <rickbutton>
devsnek: the hackmd is on the reflector issue for the meeting, its at the top, "Draft Schedule"

[09:29:26.0000] <ljharb>
robpalme: Bakkot should we move today's notes to another URL?

[09:29:39.0000] <Bakkot>
ehhhh it's probably not worth worrying about

[09:29:48.0000] <ystartsev>
i can move it

[09:29:51.0000] <ystartsev>
either at lunch or eod

[09:30:07.0000] <devsnek>
thanks

[09:30:13.0000] <ystartsev>
any preference?

[09:34:07.0000] <littledan>
yeah, I agree that late agenda items should be deprioritized

[09:35:02.0000] <ryzokuken>
Isn't today a holiday in parts of Europe?

[09:35:42.0000] <leobalter>
ryzokuken: it is

[09:36:03.0000] <ryzokuken>
that's likely the issue, I guess 😅

[09:44:55.0000] <Bakkot>
jridgewell I am glad/impressed you know those NamedEvaluation details off the top of your head

[09:45:00.0000] <Bakkot>
I just reviewed this change and I still don't

[09:45:07.0000] <rkirsling>
note that ease for polyfill doesn't correspond to ease for impl

[09:45:24.0000] <ljharb>
shu: to clarify, chrome is shipping it with or without the inferred name?

[09:45:44.0000] <shu>
ljharb: without currently, because it's not in the spec

[09:45:49.0000] <ljharb>
thanks

[09:45:54.0000] <shu>
ljharb: if it is added, there is plenty of time to add it in before it hits stable

[09:46:28.0000] <ljharb>
gotcha

[09:46:38.0000] <ljharb>
drousso: you had thoughts on the issue thread btw

[09:46:47.0000] <drousso>
ya

[09:46:53.0000] <drousso>
i don't feel strongly

[09:47:15.0000] <drousso>
i am slightly towards "no" because of the short circuiting behavior

[09:47:46.0000] <Bakkot>
short circuiting behavior actually leans towards yes, I think

[09:48:10.0000] <Bakkot>
because with short circuiting it desugars to `a && a = function(){}`, which gets named

[09:48:43.0000] <rkirsling>
the tricky part is that while that is the desugaring, it's not the current code you would write

[09:48:47.0000] <ljharb>
or `if (a) { a = function () {} }` which also gets named

[09:51:10.0000] <drousso>
+1 to what rkirsling

[09:51:11.0000] <drousso>
said

[09:51:19.0000] <littledan>
personally, I don't see the size of the Babel output, or the desugaring, as a very strong argument one way or another

[09:51:39.0000] <littledan>
it's more about the general pattern that, in these sort of direct syntax assignment cases ending in = or :, you do name assignment

[09:51:56.0000] <littledan>
(sorry for caucusing before...)

[09:52:31.0000] <Bakkot>
yeah, agreed with littledan

[09:53:55.0000] <littledan>
sorry, the conclusion was yes, go ahead with named evaluation?

[09:54:29.0000] <ljharb>
sounds like yes, infer the name, as long as implementors can commit to implementing that

[10:08:45.0000] <Bakkot>
petition to consider shorter lunch breaks the next three days

[10:09:06.0000] <ljharb>
esp considering we're not all eating lunch at the same times when remote

[10:09:07.0000] <Bakkot>
I just had breakfast, so I'm not going to eat lunch, so I'm just sitting around

[10:16:16.0000] <devsnek>
is iterator helpers happening now

[10:16:33.0000] <jridgewell>
It's a tech check

[10:16:52.0000] <jridgewell>
We're on break till the new hour

[10:17:06.0000] <devsnek>
ah ok

[10:18:15.0000] <robpalme>
***Note-takers and Note-readers*** Today's notes have been migrated.  Please find the new link here: https://github.com/tc39/Reflector/issues/279

[10:29:53.0000] <akirose>
i'm gonna mention this when we reconvene, but… we have way, way more time on the agenda than we have meeting time. use that information as you will.

[10:33:50.0000] <rkirsling>
folks in the breakout room feel like a one-hour lunch break doesn't really make sense under all-remote conditions

[10:36:57.0000] <bterlson>
rkirsling: as in, it's too long?

[10:37:16.0000] <rkirsling>
yeah

[10:38:08.0000] <rkirsling>
as in, like, even if you're in the appropriate time zone you might not need that long of a block of time when you're connected remotely anyway

[10:38:24.0000] <bterlson>
I dunno, I just finished cooking lunch, don't have that much time to eat :-P

[10:40:35.0000] <jridgewell>
The difference being it's ok to mute yourself and eat as presentations are going on

[10:40:44.0000] <jridgewell>
It's a little different than when we're in person

[10:40:57.0000] <shu>
shorter break time sgtm

[10:41:27.0000] <jridgewell>
Also the side discussions are much louder in-person, so having a long lunch break was nice

[10:50:39.0000] <ystartsev>
michaelficarra: are you around?

[10:56:24.0000] <sffc>
Is anyone here well-connected enough to get us an invitation to Clubhouse for the hallway track? https://www.wired.com/story/what-is-clubhouse-why-does-silicon-valley-care/

[10:58:29.0000] <akirose>
"a new social network more exclusive than Berghain" AHAHAHAHAHAHAHAH

[10:58:40.0000] <robpalme>
we are restarting in 1 minute!

[11:02:03.0000] <robpalme>
starting now!

[11:04:56.0000] <devsnek>
if there are questions about iterator helpers stuff i can address i'm watching the channel here but not actively listening to the call

[11:07:11.0000] <Bakkot>
ppt integration seems much worse than the share-screen integration

[11:11:35.0000] <ryzokuken>
akirose: `Intl.DurationFormat` is today according to https://hackmd.io/@tc39-chairs/rylG45f2L#1300-CDT, but it's not on the agenda.

[11:11:36.0000] <ystartsev>
yep..

[11:12:02.0000] <michaelficarra>
these slides are really good

[11:13:31.0000] <rbuckton>
Upstream iterator was never started either though

[11:13:42.0000] <littledan>
enclosing finally blocks around the current yield pause point are called by generator return  FWIW

[11:14:13.0000] <ljharb>
eesh, i didn't realize the slides were advanced, i was stuck on slide 5. guess i'll open the link myself

[11:14:14.0000] <Bakkot>
iterators don't get started

[11:14:18.0000] <Bakkot>
generators get started

[11:14:23.0000] <Bakkot>
... I think

[11:14:35.0000] <devsnek>
iterator is just a protocol

[11:14:41.0000] <devsnek>
there's no behaviour

[11:14:49.0000] <Bakkot>
but the protocol doesn't involve a "start" phase, I think

[11:14:59.0000] <devsnek>
right

[11:16:07.0000] <rbuckton>
Sure, but depending on .return to close upstream iterators isn't guaranteed either

[11:16:18.0000] <rbuckton>
s/close/"return"

[11:17:19.0000] <Bakkot>
not guaranteed, but it seems very strange to have a builtin which unconditionally prevents you from doing that

[11:17:28.0000] <Bakkot>
rather than deferring to the upstream

[11:18:51.0000] <littledan>
Bakkot: Well, you might think of the first .next() call is more or less a "start" phase

[11:20:03.0000] <akirose>
ryzokuken: working on it. bterlson & robpalme are debugging something

[11:20:21.0000] <Bakkot>
littledan: sure, but I wouldn't really expect that

[11:20:25.0000] <Bakkot>
you can call .return before .next

[11:20:42.0000] <Bakkot>
so it is reasonable to implement an iterator which is opened when it is obtained

[11:20:46.0000] <Bakkot>
not when it is first queried

[11:20:48.0000] <littledan>
right, this case is weird

[11:20:52.0000] <Bakkot>
and the builtins should work with that

[11:20:54.0000] <ryzokuken>
akirose: thanks.

[11:21:16.0000] <littledan>
(I wouldn't expect to have .return/.throw at all, and have previously proposed that we remove all that from the iterator protocol, but maybe it's too late now)

[11:21:33.0000] <devsnek>
there are many more slides

[11:21:43.0000] <rbuckton>
To me its inconsistent to have a built-in that differs in behavior from what a user could normally accomplish with a generator.

[11:21:44.0000] <Bakkot>
whatwg streams make use of them, I think

[11:22:11.0000] <Bakkot>
rbuckton why? generators are a convenient way of creating iterators, but not the only way

[11:22:33.0000] <rbuckton>
Of course, generators are essentially "lazy" since no code runs until the first call to `.next()`.

[11:22:43.0000] <michaelficarra>
jridgewell: it's iterator helpers, not iterable helpers

[11:23:10.0000] <jridgewell>
There's a constructor, no?

[11:23:23.0000] <jridgewell>
`new IterableHelpers(set)`

[11:23:24.0000] <littledan>
Bakkot: I thought that was pretty new/not universally shipped. But iterator .return/.throw has been shipped everywhere for years

[11:23:32.0000] <rbuckton>
michaelficarra: I still think targeting *iterator* and not *iterable* is the wrong abstraction.

[11:23:33.0000] <devsnek>
jridgewell: no

[11:23:34.0000] <ljharb>
rbuckton: every iterator-producing method in the spec already differs in that behavior.

[11:23:36.0000] <Bakkot>
littledan yeah, it's new. seems useful though!

[11:23:43.0000] <devsnek>
jridgewell: set.values().map()

[11:23:50.0000] <ljharb>
ES6 itself wasn't consistent between iterator-producing methods, and "what generators do"

[11:23:57.0000] <Bakkot>
re: "spec will be long", fwiw we could cut down the duplicate spec text the way we do for typed arrays and errors

[11:24:13.0000] <michaelficarra>
jridgewell: no, though there is Iterator.from

[11:24:22.0000] <devsnek>
Bakkot: i tried that, its still very long

[11:24:28.0000] <devsnek>
because each one has very different logic

[11:24:28.0000] <rbuckton>
I would have almost preferred `new Iterable(set.values()).map()`.

[11:24:55.0000] <jridgewell>
Does `Iterator.from` call `@@iterator`?

[11:24:59.0000] <devsnek>
yes

[11:25:01.0000] <michaelficarra>
yep

[11:25:04.0000] <jridgewell>
👍

[11:25:28.0000] <jridgewell>
Removed myself from the queue

[11:25:51.0000] <Bakkot>
devsnek: hm, that's surprising to me

[11:25:55.0000] <devsnek>
Yield macro just calls GeneratorYield or AsyncGeneratorYield

[11:25:59.0000] <devsnek>
no new machinery there

[11:26:02.0000] <Bakkot>
devsnek were you using abstract closures?

[11:26:12.0000] <devsnek>
Bakkot: i considered abstract closures

[11:26:19.0000] <devsnek>
i didn't come up with anything fantastic there

[11:26:35.0000] <Bakkot>
because with abstract closures you would just specify a State record and an abstract closure and .next would just invoke the abstract closure

[11:26:47.0000] <Bakkot>
it's only flatmap which would be more than that, I think

[11:27:08.0000] <devsnek>
i don't want to make something that needs special cases

[11:27:13.0000] <Bakkot>
meh

[11:27:14.0000] <michaelficarra>
I don't hate option 1: is there really a need to forward return/throw?

[11:27:15.0000] <devsnek>
just from a principled perspective

[11:27:17.0000] <rbuckton>
I wrote package that essentially has these helpers over iterables:

[11:27:17.0000] <rbuckton>
```js

[11:27:17.0000] <rbuckton>
const { from } = require("iter-query");

[11:27:17.0000] <rbuckton>
from(set.values()).map(...)

[11:27:17.0000] <rbuckton>
```

[11:27:18.0000] <rbuckton>
It makes a lot more sense to me at that level, though I understand the want to attach these to `%IteratorPrototype%` for convenience.

[11:27:18.0000] <Bakkot>
it's editorial

[11:27:21.0000] <devsnek>
i think we need good ways to add stdlib behaviour

[11:27:26.0000] <devsnek>
without special casing everything

[11:27:42.0000] <Bakkot>
I don't really think we should be optimizing for the spec being short

[11:27:56.0000] <Bakkot>
s/don't really think we should/strongly believe we should not/

[11:27:58.0000] <shu>
agreed

[11:28:08.0000] <rbuckton>
I'm personally a fan of something like Option 1 (or at least, that uses `[@@iterator]`)

[11:28:08.0000] <devsnek>
it's not about being short as much as its about being consistent

[11:28:24.0000] <Bakkot>
as long as the user-observable behavior is consistent, I don't know why we would care that much

[11:28:32.0000] <devsnek>
option 3 is polyfillable btw

[11:29:25.0000] <Bakkot>
michaelficarra it seems important that `.throw` and `.return` forward to the underlying iterators, personally

[11:29:45.0000] <Bakkot>
like `iter().map(x => x)` should be as close as possible to `iter()`

[11:29:58.0000] <devsnek>
option 3 doesn't directly forward but it keeps the state consistent

[11:30:10.0000] <devsnek>
it will call the methods, i mean

[11:30:27.0000] <shu>
what is the difference between 2 and 3 other than editorial?

[11:30:52.0000] <devsnek>
in 2 they are plain objects that are iterators

[11:30:57.0000] <devsnek>
in 3 they are actual generators

[11:31:10.0000] <shu>
ah, but specced using spec machinery instead of JS code?

[11:31:14.0000] <devsnek>
yeah

[11:32:39.0000] <littledan>
personally I like option 3 the best, and agree with this goal of avoiding special-casing.

[11:33:11.0000] <littledan>
(just because we used one-off solutions each time in the past does'nt mean we need to keep doing that forever in the future...)

[11:33:17.0000] <michaelficarra>
I really don't think the presence of the methods should be conditional

[11:33:21.0000] <michaelficarra>
ljharb ^

[11:33:24.0000] <littledan>
+1

[11:34:26.0000] <robpalme>
is bradford on IRC?

[11:34:28.0000] <ljharb>
michaelficarra: i can understand that position for sure. but also APIs that consume iterators might be checking for the presence of those methods now, and taking simpler code paths when they're absent, so it might have an impact

[11:34:55.0000] <Bakkot>
agreed it might have an effect but I agree with michaelficarra anyway

[11:36:48.0000] <devsnek>
Bakkot: what do you think about async abstract operations

[11:36:52.0000] <devsnek>
abstract closures*

[11:37:08.0000] <Bakkot>
devsnek hmmm

[11:37:12.0000] <Bakkot>
no inherent problem with them I guess

[11:37:20.0000] <Bakkot>
would need to be defined

[11:37:28.0000] <ljharb>
from outside, it'd just be a regular one that returned a promise

[11:37:30.0000] <ljharb>
seems fine to me also

[11:37:46.0000] <shu>
no, more than that

[11:37:58.0000] <shu>
but that part of the spec could use our going over anyhow

[11:38:07.0000] <shu>
the part that actualy does the continuation wrapping in a promise

[11:38:25.0000] <devsnek>
it would definitely require spec work

[11:39:28.0000] <rbuckton>
I still wish the helpers went through `[@@iterator]` so they could be copied to other objects that are iterable. For all built-in iterators as well as generators, `[@@iterator]()` just returns `this`. Just depending on the presence of a `next` method makes me think of all of the issues with `then` we've had in the past.

[11:40:08.0000] <ljharb>
shu: i know it'd need lots more for "inside" the async abstract closure - i meant like from the callsites

[11:40:24.0000] <michaelficarra>
unfortunately I don't think we're going to come to a clear decision before this timebox is over :-(

[11:40:52.0000] <devsnek>
rbuckton: the main concern is preventing people from getting into patterns that rely on @@iterator being reusable when it isn't

[11:40:58.0000] <keith_miller>
ystartsev: Wait so would something like Symbol.generatorInitialize solve option 1?

[11:41:13.0000] <devsnek>
what is Symbol.generatorInitialize

[11:41:15.0000] <keith_miller>
that is called when the generator function is first called

[11:41:26.0000] <brad4d>
robpalme sorry got dropped

[11:41:27.0000] <devsnek>
to validate args and stuff?

[11:41:31.0000] <brad4d>
what were you asking me?

[11:41:32.0000] <ljharb>
keith_miller: how would i do that syntactically tho with regular generators

[11:41:33.0000] <keith_miller>
yeah

[11:41:33.0000] <ystartsev>
ping jorendorff for that

[11:41:37.0000] <ystartsev>
pinging*

[11:42:43.0000] <keith_miller>
You'd have to have something like (function* myGenerator() { ... })[Symbol.initializeGenerator] = function init() { validate(arguments[0]); }

[11:42:50.0000] <keith_miller>
not saying it's pretty

[11:43:00.0000] <keith_miller>
ljharb: but it would let you do stuff

[11:43:30.0000] <ystartsev>
oh no that wouldn't solve it actually

[11:43:34.0000] <ljharb>
at the risk of making all calling of generators slower?

[11:43:36.0000] <keith_miller>
Ah, ok

[11:43:40.0000] <ystartsev>
because you wont be able to forward properly

[11:43:46.0000] <Bakkot>
I think you just write a function which invokes and generator and returns it

[11:43:58.0000] <keith_miller>
ystartsev: the initialize could set up the forwarding

[11:44:04.0000] <Bakkot>
function f(){ validate(); return function*(){}(); } or whatever

[11:44:13.0000] <keith_miller>
ljharb: I mean initializing generators is already crazy slow

[11:44:13.0000] <keith_miller>
lol

[11:44:13.0000] <devsnek>
that's what option 3 does

[11:44:19.0000] <Bakkot>
right

[11:44:25.0000] <Bakkot>
and I think userland code would do the same thing if they want this

[11:44:29.0000] <devsnek>
yep

[11:44:35.0000] <keith_miller>
would do this?

[11:44:53.0000] <keith_miller>
Or would make their equivalent of the polyfill?

[11:44:57.0000] <devsnek>
well actually what i want is a way to create a generator that has no initial yield

[11:45:24.0000] <keith_miller>
I mean sure, this is just a hacky way to get that

[11:45:28.0000] <jridgewell>
I don't think complicating generator functions even more is a good solution to this

[11:45:40.0000] <devsnek>
oh no i don't think we should do that as part of this

[11:45:50.0000] <devsnek>
none of these options ask for that

[11:46:38.0000] <keith_miller>
I mean option 3 is effectively asking VMs to do it

[11:46:45.0000] <jridgewell>
Options 2 and 3 seem to be regular functions that could return generator instances, which seems a better solution

[11:46:51.0000] <keith_miller>
so... for me there's no difference but I'm an implementor

[11:47:17.0000] <jridgewell>
Giving more magic to generator functions makes the transform muchhh more complicated

[11:47:36.0000] <devsnek>
did we get consensus to use option 3 there?

[11:47:37.0000] <jridgewell>
I already don't want to maintain the regenerator transform

[11:48:03.0000] <ystartsev>
we didn't really get a conclusion here right?

[11:48:10.0000] <devsnek>
yeah that was weird

[11:48:18.0000] <michaelficarra>
wow how did we get this far down on the agenda?

[11:48:30.0000] <michaelficarra>
time constraints?

[11:48:53.0000] <devsnek>
afaik the point of that presentation was to get consensus on how we should proceed

[11:48:55.0000] <haxjs>
I'm not sure how option 3 forward  the arg of first next call (which function.sent need)?

[11:49:09.0000] <devsnek>
haxjs: StartIteratorHelper calls .next() once

[11:49:20.0000] <devsnek>
which is why %SyncMap% starts with a Yield()

[11:51:02.0000] <haxjs>
Can't find it in https://gist.github.com/jorendorff/35504c2553170be98fc2810ccf60c608 🤔

[11:51:15.0000] <devsnek>
haxjs: the value is lost there

[11:51:22.0000] <devsnek>
that's not option 3

[11:51:28.0000] <jridgewell>
That's Option 1, I think

[11:52:09.0000] <haxjs>
Iterator.prototype = {

[11:52:09.0000] <haxjs>
  map(mapper) {

[11:52:09.0000] <haxjs>
    let it = SyncMap(this, mapper);

[11:52:09.0000] <haxjs>
    it.next();

[11:52:09.0000] <haxjs>
    return it;

[11:52:10.0000] <haxjs>
  }

[11:52:10.0000] <haxjs>
};

[11:52:29.0000] <devsnek>
haxjs: more or less, yeah

[11:56:34.0000] <ystartsev>
re: iterators

[11:56:39.0000] <ystartsev>
i have opened this issue: https://github.com/tc39/proposal-iterator-helpers/issues/97

[11:56:45.0000] <ljharb>
keith_miller: re your queue item; they already can't, because they're inside an expression position

[11:56:56.0000] <keith_miller>
ljharb: ??

[11:57:15.0000] <keith_miller>
I'm saying it's the same result as an eval

[11:57:15.0000] <ystartsev>
do you all think we could revisit this for 5 min on thursday?

[11:57:34.0000] <ljharb>
keith_miller: ah, k

[11:59:58.0000] <ljharb>
brad4d: an IIFE wouldn't necessarily preserve `super`, `arguments`, `this`; nor `await`, and it would make control flow questions complicated

[12:01:13.0000] <brad4d>
an arrow iife preserves `super`, `this`, `arguments`

[12:01:30.0000] <brad4d>
is it really desirable to return / break from a do {} expresssion?

[12:01:35.0000] <devsnek>
yes

[12:01:43.0000] <ljharb>
imo no, but some folks think yes

[12:01:51.0000] <jridgewell>
Arrow won't preserve `yield`

[12:01:55.0000] <ljharb>
or `await`

[12:02:11.0000] <devsnek>
i really want control flow from do expressions

[12:02:25.0000] <jridgewell>
You can use `await async () => { await x }`

[12:02:27.0000] <shu>
bradleymeck: control flow non-local to the do block is contentious

[12:02:54.0000] <jridgewell>
But not for `yield`, because we still don't have arrow generators

[12:04:51.0000] <bradleymeck>
shu: did you mean to ping me on that?

[12:05:05.0000] <shu>
bradleymeck: nope, sorry :)

[12:05:07.0000] <shu>
brad4d: ^

[12:05:35.0000] <brad4d>
shu ack

[12:07:34.0000] <bradleymeck>
i think control flow has utility in various positions that are annoying to deal with otherwise but not fatal to be missing

[12:10:04.0000] <bradleymeck>
there are some really odd things you can do though, like `do {continue}` on a destructuring default assignment to skip a loop

[12:12:05.0000] <ljharb>
does return/break/continue inside eval already work in an expression position?

[12:12:14.0000] <devsnek>
no

[12:12:19.0000] <brad4d>
you mean `let {x = do {continue}} = obj;` would continue a loop if `obj` doesn't have an `x`?

[12:12:43.0000] <brad4d>
I think that is harmful to readability.

[12:13:03.0000] <devsnek>
to me that's a linting concern

[12:13:20.0000] <devsnek>
there are places (outside of destructuring declarations) where continue can be useful

[12:14:14.0000] <akirose>
that's how zkat initially wrote those proposals iirc—pattern matching + do expressions intended to move through committee side-by-side

[12:14:21.0000] <brad4d>
devsnek could you point me at a use-case where flow-control inside a `do{}` would be beneficial? I can't seem to come up with one on my own?

[12:14:47.0000] <leobalter>
ljharb: the coupling with pattern matching would be a nice thing to discuss in incubator(ish?) calls

[12:15:03.0000] <leobalter>
idk Mark's irc handler if any

[12:15:10.0000] <ljharb>
leobalter: agreed; we're still pretty far from being ready for that tho (mpcsh)

[12:15:11.0000] <rkirsling>
it's been discussed in the pattern matching calls

[12:15:28.0000] <devsnek>
brad4d: there was one in the slides

[12:15:37.0000] <jridgewell>
Lol

[12:16:04.0000] <jridgewell>
/me sees myself to TDZ

[12:16:13.0000] <mpcsh>
ljharb leobalter Bakkot: should we try to get both of these proposals on an incubator call?

[12:16:23.0000] <ljharb>
leobalter: happy to invite you to the next pattern matching call if you're interested

[12:16:39.0000] <leobalter>
yes, please

[12:16:54.0000] <ljharb>
mpcsh: yes, but i think after i've got the PR ready to update the proposal :-)

[12:17:24.0000] <mpcsh>
👍

[12:18:22.0000] <rbuckton>
I've seen a fair amount of Kotlin code that does continue/break/return in expression positions:

[12:18:22.0000] <rbuckton>
```kotlin

[12:18:22.0000] <rbuckton>
for (x in list) {

[12:18:22.0000] <rbuckton>
  val y = x?.y ?: continue;

[12:18:22.0000] <rbuckton>
  ...

[12:18:23.0000] <rbuckton>
}

[12:18:23.0000] <rbuckton>
```

[12:19:08.0000] <jridgewell>
There's a goog internal server language that has `or exit` all over the place.

[12:19:08.0000] <littledan>
I share Bakkot 's intuition about blocking return, continue and break from expressions breaking some kind of invariant that we have

[12:19:14.0000] <rkirsling>
rbuckton: I don't think it'd be contentious without the visible boundary of `do {}`

[12:19:28.0000] <littledan>
so, I guess this is what exceptions are for?

[12:19:53.0000] <ljharb>
same; flow control doesn't belong in expression position

[12:20:21.0000] <rbuckton>
rkirsling: which wouldn't be contentious? `x?.y ?? continue` or `x?.y ?? do { continue; }`?

[12:20:27.0000] <devsnek>
there is no such invariant in how we have specified the language

[12:20:37.0000] <devsnek>
in fact completion values help allow it

[12:20:42.0000] <ljharb>
devsnek: sure, i didn't say they can't be. i said they shouldn't be.

[12:21:01.0000] <devsnek>
dan said there was an invariant

[12:21:04.0000] <devsnek>
which i strongly disagree on

[12:21:07.0000] <ljharb>
oh

[12:21:18.0000] <ljharb>
well, the invariant is that you currently can't do any non-throw flow control in expression position

[12:21:23.0000] <rkirsling>
rbuckton: the former wouldn't be, is my argument. "everything is an expression" doesn't induce confusion where "crossing the border between worlds" does

[12:21:26.0000] <ljharb>
it may or may not be intentional, but it remains an invariant

[12:21:30.0000] <leobalter>
I'm totally +1 to do expressions. Although, a spec draft would make it easier for an overview

[12:22:07.0000] <littledan>
hmm, I'm not sure why you'd have to care so much about the microtask ticks... I'd hope not many developers have to think in those terms

[12:22:18.0000] <ljharb>
people often think about overhead

[12:22:30.0000] <littledan>
devsnek: Well, it's currently an invariant; we can disagree about the priority of preserving it

[12:22:41.0000] <littledan>
like, it's currently a fact about JS that that doesn't happen

[12:23:04.0000] <devsnek>
that's not an invariant its just a hole

[12:23:05.0000] <rbuckton>
rkirsling: I have an issue on the do-expressions repo that suggests dropping `do {}` and updating ParenthesizedExpression to allow most statements. Then you would have `x ?? (continue)`. The parens are necessary to preserve precedence of `,`, which was one of Bakkot's concerns about throw expressions.

[12:23:16.0000] <littledan>
the JS spec notation allows all kinds of stuff that we have decided we won't do

[12:23:17.0000] <devsnek>
that's like saying %Iterator%.prototype.map not existing is an invariant of the language

[12:23:39.0000] <ljharb>
and indeed, it is right now

[12:23:46.0000] <littledan>
so, in general, I think that assertions of things being "invariants" are value judgements, and I'm comfortable calling my claim a value judgement

[12:23:50.0000] <ljharb>
devsnek: but i think there's a categorical difference there that you surely are aware of

[12:23:55.0000] <littledan>
it's a statement about what we want in the future

[12:24:22.0000] <ljharb>
drousso: what about the dev tools/repl?

[12:24:29.0000] <devsnek>
value judgement seems like a better term

[12:24:39.0000] <drousso>
ljharb i don't think those people think of that as "completion"

[12:24:44.0000] <rkirsling>
I'm confused by the non-specific confusion

[12:24:44.0000] <ljharb>
drousso: and yet that's what it is

[12:24:57.0000] <ljharb>
drousso: so would it be more palatable if do expressions were explained as "like in the dev tools"?

[12:25:09.0000] <rkirsling>
the goal is to continue preserving "ignorance is bliss" around completion values, was my understanding

[12:25:12.0000] <ljharb>
drousso: since that's something virtually every dev already understands?

[12:25:15.0000] <drousso>
ljharb im not convinced that developers even know what's going on in the console

[12:25:27.0000] <ljharb>
drousso: they figure it out very quickly. they type `3` and the result is `3`

[12:25:44.0000] <ljharb>
or `if (true) { 3 }` and the result is `3`

[12:25:53.0000] <drousso>
it doesn't work exactly like the devtools tho

[12:25:54.0000] <devsnek>
i just don't get like

[12:26:11.0000] <ljharb>
drousso: aside from "devtools exposes internals" and whatnot, how does it differ?

[12:26:20.0000] <devsnek>
why can't we just say some people don't like control flow there, and leave it to linters

[12:26:37.0000] <drousso>
oh wait i was thinking of something different

[12:26:44.0000] <drousso>
yes it does work the same as devtools

[12:26:56.0000] <drousso>
i don't think that that's a good way of explaining it though

[12:27:03.0000] <drousso>
as that doesn't clarify anything about what's happening

[12:27:11.0000] <drousso>
it just provides a "if you want to see it in action, use devtools"

[12:27:21.0000] <drousso>
it doesn't explain what's actually happening

[12:27:26.0000] <drousso>
s/it/devtools

[12:27:34.0000] <ljharb>
drousso: the explanation isn't needed tho, if everyone already intuits how it's supposed to work

[12:27:41.0000] <robpalme>
Younies is unavailable for his presentation so Record & Tuple is next.

[12:27:41.0000] <drousso>
i disagree with that

[12:27:44.0000] <drousso>
vehemently

[12:28:24.0000] <rkirsling>
can you give specific examples of what the people you spoke to thought the basic cases should do instead?

[12:28:49.0000] <drousso>
the function declaration

[12:28:54.0000] <haxjs>
+1 for banning too :)

[12:29:03.0000] <drousso>
many i spoke to thought that that would result in the function declaration being used

[12:29:08.0000] <littledan>
I disagree with the notion that a proposal like this would need to add new capabilities (like return/break/continue from an expression) to carry their own weight; I'm not sure if waldemar was alluding to that

[12:29:24.0000] <devsnek>
waldemar said this proposal isn't worth it without control flow

[12:29:33.0000] <Bakkot>
drousso you get a syntax error; I think "what does this code do? oh it's a syntax error" is not that big of a deal

[12:29:44.0000] <haxjs>
I think many devs only want some sugar for IIFE.

[12:29:54.0000] <devsnek>
i certainly won't use it as much as i was planning to without control flow

[12:30:01.0000] <ljharb>
haxjs: why does that mean they shouldn't get it?

[12:30:03.0000] <drousso>
i don't think syntax errors are a good way of teaching a developer how to use something

[12:30:40.0000] <drousso>
in fact i've spoken with many developers who find JS errors often unhelpful

[12:30:48.0000] <devsnek>
that's more on engines

[12:30:54.0000] <ljharb>
unfortunately we don't specify error messages, that's on the browsers

[12:30:58.0000] <ljharb>
* browsers/engines

[12:31:04.0000] <devsnek>
engines don't even bother to implement parsers which support reporting multiple errors

[12:31:08.0000] <ystartsev>
drousso: we had pretty strong support internally for this, its interesting that your front end developers have such a strong issue with this. Are there certain patterns that they are using that makes it more difficult?

[12:31:25.0000] <haxjs>
ljharb so any other capabilities just add confusion even they are powerful :)

[12:31:38.0000] <ystartsev>
and also, yes -- engines cannot really improve their error messages due to web compat

[12:31:43.0000] <ljharb>
haxjs: i agree that return/continue/break in do expressions are powerful and also add confusion, yes

[12:31:44.0000] <drousso>
that is true

[12:31:44.0000] <ystartsev>
we tried and had to back it out

[12:31:50.0000] <drousso>
im not saying that's the fault of this situation

[12:31:58.0000] <drousso>
or that it's up to this proposal to fix it

[12:32:07.0000] <drousso>
just that i believe errors are not a good way to teach things

[12:32:26.0000] <drousso>
brad4d +1000

[12:32:28.0000] <ljharb>
drousso: i think it's very unlikely devs will even try to do these things in the first place tho

[12:32:32.0000] <drousso>
brad4d completely agree

[12:32:36.0000] <ljharb>
drousso: iow, i think that most devs won't ever run into it.

[12:32:51.0000] <drousso>
ljharb if that's the case, why add it in the first place?

[12:33:02.0000] <rkirsling>
I will say that I too originally expected that `return` would serve as an early out _for the do expr_

[12:33:02.0000] <drousso>
or wait do you mean these "edge cases" or `do` in general?

[12:33:06.0000] <ljharb>
drousso: because they *will* try to use all the non-error cases in a block in expression position

[12:33:09.0000] <ljharb>
drousso: i mean the edge cases

[12:33:18.0000] <ljharb>
drousso: tons of people will immediately try to use the non-edge-cases in a ton of code

[12:33:19.0000] <rkirsling>
(but obviously it's moot if it's banned)

[12:33:40.0000] <ljharb>
drousso: especially in the react community inside jsx, not that i think that needs to be a motivation

[12:33:52.0000] <ljharb>
rkirsling: well, i'm saying i don't think they'll even run into the bans

[12:34:03.0000] <ljharb>
rkirsling: i think most users won't ever discover those are missing because they'll never think to try it

[12:34:15.0000] <haxjs>
But, I also think banning everything controversial  not really solve the problems, for example how can we break a loop and return a value (it seems it will be banned as slide)

[12:34:44.0000] <ljharb>
haxjs: same way you do now: return a sentinel value, and then check it in the main loop body

[12:35:08.0000] <rbuckton>
Back when I presented throw expressions I was asked by many in the committee to investigate converting other statements to expressions, especially `return`, `continue`, `break`. I'm actually surprised at the number of people in favor of banning those statements in a `do {}` expression.

[12:35:10.0000] <ystartsev>
re: iterator helpers issue: https://github.com/tc39/proposal-iterator-helpers/issues/97

[12:35:18.0000] <ystartsev>
please comment so we can get to a solution!

[12:35:26.0000] <devsnek>
ljharb: no right now you just `return`

[12:35:28.0000] <haxjs>
ljharb: so i guess dev would expect iife which can return a value directly :-P

[12:35:36.0000] <devsnek>
if anything not allowing control flow is a refactoring hazard

[12:35:38.0000] <ljharb>
devsnek: not if the value comes from an IIFE, or another function

[12:36:01.0000] <ljharb>
haxjs: they'll expect their do expression body to be able to produce a value; i'm saying they won't expect it to be able to force the containing function to return

[12:37:21.0000] <brad4d>
@devs

[12:37:44.0000] <brad4d>
devsnek allowing flow of control is a refactoring hazard if you're inlining a function

[12:39:39.0000] <brad4d>
`do{}` expressions would make function inlining much easier if they really act like inline functions

[12:39:41.0000] <haxjs>
ljharb: what I'm talking is code like `do { while(...) { if (...) { 1 ; break } } }`

[12:40:06.0000] <ljharb>
haxjs: that would work fine, because the loop you're breaking is fully inside the `do`

[12:40:11.0000] <ljharb>
haxjs: i think

[12:40:21.0000] <ljharb>
haxjs: ohh right but it wouldn't because of ending in a loop

[12:40:43.0000] <ljharb>
haxjs: so then `do { let v; while (…) { if (…) { v = 1; break; } } v; }`

[12:41:05.0000] <haxjs>
yeah, this is why i say devs may like iife sugar...

[12:42:38.0000] <ljharb>
gotcha, agreed

[12:43:02.0000] <ljharb>
well, i see what you mean anyways. i don't think they actually want a function invocation

[12:43:25.0000] <haxjs>
As i understand, basically current minimal proposal just have very similar power or even less power of iife.

[12:43:39.0000] <ljharb>
and less overhead

[12:44:16.0000] <haxjs>
yeah, so maybe iife sugar is what we need?

[12:44:47.0000] <Bakkot>
current proposal lets you do something you can't with IIFE, which is await/yield

[12:45:04.0000] <Bakkot>
await you can do with a microtask tick, yield... you just can't do, I think, at least without a bunch of wrappers

[12:45:21.0000] <ljharb>
^ that

[12:45:31.0000] <haxjs>
yeah! so it's iife + await async iife sugar :-P

[12:46:30.0000] <Bakkot>
bterlson/other chairs: voice jorendorff ?

[12:47:27.0000] <sffc>
I'll figure out my mic

[12:47:29.0000] <sffc>
go to the next speaker

[12:49:39.0000] <sffc>
I'll follow up on GitHub and/or in the hallway track

[12:50:01.0000] <ystartsev>
Bakkot: on it

[12:52:38.0000] <jorendorff>
thank you

[12:55:23.0000] <Bakkot>
complex numbers don't have -0, bah

[12:56:36.0000] <jorendorff>
haha

[12:57:40.0000] <Bakkot>
during the editor update I misspoke: it's actually caiolima doing the work to fix the number types in the spec. mea culpa.

[12:58:27.0000] <leobalter>
time is over for today, but we have someone logged in as Guest in the call, I believe we should avoid that tomorrow.

[12:58:48.0000] <rkirsling>
indeed

[13:03:41.0000] <leobalter>
SameValue makes sense if we want to follow pattern with `includes`, right?

[13:04:16.0000] <jorendorff>
well ... it seems more directly applicable to look at what `===` does, than `includes`

[13:04:24.0000] <Bakkot>
leobalter SameValueZero, technically

[13:05:00.0000] <Bakkot>
`[-0].includes(0)` and `[NaN].includes(NaN)` are both true

[13:06:00.0000] <mpcsh>
I am opposed to shortening lunch, for the record. the hallway-track social time is nice

[13:08:40.0000] <rkirsling>
mpcsh: I don't think we necessarily need to decrease break time, perhaps just rearrange it

[13:08:57.0000] <sffc>
Ujjwal and I are in the hallway track; would be nice to have more

[13:09:23.0000] <haxjs>
I  feel we should keep consistency with normal `===`. The weirdness of `===` is coming from IEEE float, developers are inevitable to learn it,  add an exception rule for tuple/record just make things worse and never really solve anything.

[13:09:37.0000] <sffc>
I have some thoughts about Record/Tuple that I'd like to discuss with the champions

[13:10:11.0000] <akirose>
did we fall back to hubs?

[13:10:19.0000] <ystartsev>
lets use online town for today

[13:10:24.0000] <akirose>
kk

[13:10:24.0000] <ystartsev>
and tomorrow switch to hubs

[13:10:38.0000] <ystartsev>
online town has some issues with distance that hubs didnt

[13:10:47.0000] <bradleymeck>
i think having any value fail to ever be === if a sub component is NaN is... highly surprising

[13:12:36.0000] <rickbutton>
sffc: do you want to chat now? I'm free, or via email?

[13:13:23.0000] <sffc>
I'm in the town, plus 5 others now

[13:13:31.0000] <rickbutton>
oh right

[13:13:35.0000] <rickbutton>
will be there shortly

[13:14:16.0000] <bterlson>
Chairs discussed shorter lunch break and we will stick with 1 hour for now. Delegates with free time should consider joining us in the hallway track! /cc Bakkot

[13:14:34.0000] <leobalter>
akirose bterlson how hard would it be to change my initials in the notes? I'd rather go with LFB (to reflect my actual initials), but I don't wanna cause too much work

[13:14:57.0000] <mpcsh>
leobalter: I switched mine from MCN to MPC a little while ago, it's not bad

[13:15:37.0000] <mpcsh>
just do a find & replace for today's notes, and submit a PR for old notes

[13:19:10.0000] <TabAtkins>
Bakkot: How are complex numbers avoiding -0?

[13:25:57.0000] <Bakkot>
TabAtkins the traditional definition of complex numbers does not include two distinct 0s

[13:26:04.0000] <Bakkot>
(or four, I guess)

[13:26:13.0000] <TabAtkins>
Well sure, but the traditional definition of the reals doesn't either.

[13:26:29.0000] <TabAtkins>
Complex-in-JS would probably have some -0s in it

[13:27:39.0000] <TabAtkins>
(Probably... 3? If they're just a pair of Numbers.)

[13:28:08.0000] <Bakkot>
0,0, -0,0, 0,-0, -0,-0 is four

[13:28:17.0000] <Bakkot>
I guess just three -0s though

[13:28:20.0000] <TabAtkins>
0,0 is a positive zero, yeah ^_^

[13:32:31.0000] <ljharb>
jorendorff: hopping into the hallway track if you wanted to chat now

[13:33:38.0000] <jorendorff>
@Bakkot believe it or not I think Brendan Eich exposed -0 to JS based on advice from Guy Steele that had to do with complex numbers

[13:33:39.0000] <Bakkot>
does css have a -0 which is observably different from 0?

[13:33:46.0000] <Bakkot>
jorendorff fascinating

[13:33:58.0000] <jorendorff>
in my hearing he only ever explained it far too fast for me to follow

[13:34:10.0000] <jorendorff>
/me looks for the hallway-track link

[13:34:17.0000] <Bakkot>
it's in the reflector I think

[13:34:19.0000] <shu>
"far too fast": checks out for brendan!

[13:37:53.0000] <jorendorff>
got it

[13:39:16.0000] <TabAtkins>
Bakkot: CSS grew a -0 that is *slightly* observable, to preserve IEEE semantics and JS compatibility. It gets censored into a plain zero the moment is would escape a math function.

[13:39:46.0000] <TabAtkins>
But yeah, `margin-left: calc(1/0);` is different from `calc(1/-0)`.

[13:43:24.0000] <Bakkot>
good times

[13:43:36.0000] <Bakkot>
-0 was a terrible idea

[13:43:41.0000] <Bakkot>
I will die mad about that

[13:44:22.0000] <jorendorff>
can't wait for some brave new language to just say no

[13:46:31.0000] <shu>
what... do i do for the rest of my day

[13:46:46.0000] <ljharb>
Bakkot: but how else can i express the limit of an integral approaching zero from the negative direction

[13:46:51.0000] <TabAtkins>
Oh jeez I forgot it was 3pm Central, I was waiting for the meetig to start again

[13:46:58.0000] <TabAtkins>
ljharb: OH easy, don't

[13:47:11.0000] <ljharb>
my calculus teacher would be horrified

[13:47:12.0000] <Bakkot>
ljharb: 0

[13:47:15.0000] <rickbutton>
shu: sleep

[13:47:40.0000] <Bakkot>
how do you express the limit of an integral approaching 1 from the negative direction? :P

[13:48:17.0000] <ljharb>
touché

[13:49:26.0000] <jorendorff>
ljharb: suppose we go with option 2, to me the most obvious way to do that would be different iterator types for map, filter, take, drop, etc.

[13:49:42.0000] <jorendorff>
ljharb: so, different internal slots for each

[13:49:49.0000] <jorendorff>
and every method has a brand check

[13:50:52.0000] <rkirsling>
Bakkot: +1 re -0

[13:51:25.0000] <rkirsling>
so many NaNs and yet two zeroes is too many

[13:51:41.0000] <rkirsling>
*two 0s

[13:52:23.0000] <ljharb>
jorendorff: sure, seems right to me

[13:52:42.0000] <ljharb>
jorendorff: altho it also seems doable as a single object type

[13:52:50.0000] <jorendorff>
ljharb: ok, right, I'm thinking about that now

[13:53:13.0000] <ljharb>
it might get weird with some of the types tho

[13:53:15.0000] <jorendorff>
they do all have something in common, which is that they all have a single source iterator... except there's `Iterator.prototype.flatMap()`, the sole exception

[13:53:24.0000] <ljharb>
that doesn't have a source iterator? or it has multiple

[13:53:41.0000] <ljharb>
(those were questions, not statements)

[13:54:10.0000] <Bakkot>
I think you'd have an abstract op which returned a list of values to yield, and everything except flatmap would return a list of length exactly 1

[13:54:14.0000] <Bakkot>
boom, no more special case

[13:55:07.0000] <jorendorff>
ok, so if we do this, we can have a common implementation of throw and return shared by all the iterator helpers

[13:55:14.0000] <jorendorff>
the common thing needs a name

[13:55:35.0000] <ljharb>
and the common thing would just be "innerIterator?.return()` etc?

[13:55:36.0000] <Bakkot>
if they're different objects, the common thing would be spec-internal, right?

[13:55:41.0000] <jorendorff>
Bakkot: wait, actually I didn't follow that

[13:55:43.0000] <Bakkot>
so the name doesn't matter so much

[13:55:45.0000] <ljharb>
or sorry `innerIterator.return?.()`

[13:55:51.0000] <Bakkot>
IteratorHelperReturn or whatever

[13:56:26.0000] <jorendorff>
Bakkot: "abstract op which returned a list of values to yield" I don't understand when this abstract op is used

[13:56:41.0000] <jorendorff>
I... don't think I understand this scheme at all actually

[13:57:03.0000] <Bakkot>
jorendorff the idea is that each helper would define such an abstract op, and the `next` would know how to invoke the abstract op

[13:57:06.0000] <Bakkot>
we can talk about it more tomorrow

[13:57:10.0000] <Bakkot>
hard to talk about it without code

[13:57:44.0000] <jorendorff>
ok, and the helper would have abstract ops for `throw` and `return` too?

[13:58:18.0000] <Bakkot>
the helper would specifically be the implementation of `.next`

[13:58:31.0000] <Bakkot>
but yeah maybe?

[13:58:38.0000] <Bakkot>
not sure

[13:58:41.0000] <Bakkot>
have to write it out

[13:59:12.0000] <jorendorff>
ok, let's meet up tomorrow and talk about it more, maybe sketch some things out?

[13:59:17.0000] <Bakkot>
y

[13:59:34.0000] <jorendorff>
ljharb: are you free tomorrow afternoon at 2PM Pacific time to chat?

[13:59:41.0000] <devsnek>
return/throw may also have to touch logic in the helper itself

[13:59:57.0000] <devsnek>
which is why i mentioned that it isn't ideal to have them just be methods that call the inner iterator

[14:00:06.0000] <ljharb>
jorendorff: yep, works for me

[14:00:28.0000] <Bakkot>
devsnek what logic in the helper do they need to touch?

[14:00:32.0000] <devsnek>
idk

[14:00:35.0000] <Bakkot>
other than "mark as stale", I guess

[14:00:48.0000] <devsnek>
flatMap is one

[14:00:52.0000] <jorendorff>
ljharb: thanks very much, let's all meet here 2PM Pacific tomorrow, then we'll set up a video chat

[14:01:05.0000] <devsnek>
there could be more in the future

[14:01:10.0000] <jorendorff>
I think flatMap is the only one; the others all do the same thing for throw (forward it) and return (forward it0

[14:01:16.0000] <jorendorff>
right, the only one at present

[14:01:19.0000] <Bakkot>
what does flatmap need to do specially?

[14:01:23.0000] <devsnek>
close two iterators

[14:01:38.0000] <Bakkot>
ah, yeah, sure

[14:01:45.0000] <devsnek>
we could have more in the future

[14:01:49.0000] <jorendorff>
flatmap is `for (let iterable in this) for (let value in iterable) yield value;`

[14:02:01.0000] <devsnek>
i'd rather do the work now to have a proper way to specify generators in our stdlib

[14:02:07.0000] <devsnek>
than keep having to make weird iterator things forever

[14:02:22.0000] <Bakkot>
I kind of prefer making weird iterator things forever, even if we had a proper way to specify generators

[14:02:23.0000] <jorendorff>
If the goal is to produce a common type of iterator that shares some implementation details with other iterators, with common throw/return methods,

[14:02:41.0000] <Bakkot>
ease of spec isn't really a priority

[14:03:06.0000] <devsnek>
i want consistency

[14:03:16.0000] <devsnek>
of how our systems behave

[14:03:17.0000] <jorendorff>
that doesn't expose implementation details,

[14:03:20.0000] <Bakkot>
weird iterator things forever is the consistent thing

[14:03:20.0000] <jorendorff>
...then the exact thing we are talking about as an ideal end state is... a generator

[14:03:30.0000] <devsnek>
^

[14:03:45.0000] <Bakkot>
right, if that's the goal

[14:03:49.0000] <jorendorff>
I agree weird iterator things forever is consistent with existing practice

[14:03:49.0000] <Bakkot>
I don't really share that goal

[14:03:56.0000] <Bakkot>
I don't object to it, but don't see why it's valuable

[14:04:15.0000] <jorendorff>
ease of spec is not what I'm concerned with

[14:04:17.0000] <devsnek>
i don't want generators for the sake of generators, i want them because they handle all the reentrancy and cleanup and whatnot properly

[14:04:25.0000] <jorendorff>
ease of using and understanding the spec matters to me

[14:05:14.0000] <devsnek>
i'm more concerned with ease of understanding but i also have to write all these methods so...

[14:05:55.0000] <jorendorff>
anyway -- we should talk more tomorrow. thanks again for your time

[14:06:41.0000] <jorendorff>
Bakkot: oh, btw - you mentioned today that you don't think programmers will try to use break/return from within do-expressions

[14:07:15.0000] <devsnek>
i feel like half of all js code is early returns

[14:07:33.0000] <jorendorff>
Bakkot: i think they will :( because there are lots of expression languages, most notably Ruby and Rust but I think it's not even uncommon these days

[14:08:00.0000] <Bakkot>
jorendorff did not mean to imply that

[14:08:02.0000] <jorendorff>
expression languages that have weird control flow stuff like `return`

[14:08:12.0000] <jorendorff>
(Smalltalk too)

[14:08:14.0000] <Bakkot>
I think people won't try to end their do-exprs with declarations

[14:08:23.0000] <Bakkot>
and yeah I've used the feature in ruby

[14:08:24.0000] <Bakkot>
and rust

[14:08:30.0000] <jorendorff>
oh, that I agree we can just call it a SyntaxError

[14:09:00.0000] <jorendorff>
my comment is limited to break/continue/return

[14:09:13.0000] <Bakkot>
yeah, like I say I didn't mean to imply people won't try that

[14:09:17.0000] <Bakkot>
if I did say that i misspoke

[14:09:36.0000] <jorendorff>
i probably misheared, i don't mean to put words in your mouth!

[14:10:00.0000] <rbuckton>
The TypeScript source heavily utilizes function declarations that trail the source code that uses them. I could see function declarations at the end of a `do {}` tripping people up if they're refactoring.

[14:10:26.0000] <Bakkot>
sounds like a good reason for that to be a syntax error!

[14:10:42.0000] <Bakkot>
if some people are actually going to expect to get the before-declaration value

[14:10:43.0000] <rbuckton>
No, that still would trip them up.

[14:10:45.0000] <Bakkot>
instead of the function itself

[14:11:05.0000] <rbuckton>
it would be better if function declarations don't contribute to the resulting value

[14:11:09.0000] <Bakkot>
People getting tripped up on things being a syntax error is the least bad kind of people getting tripped up.

[14:11:11.0000] <Bakkot>
Strong disagree.

[14:11:18.0000] <jorendorff>
agree with "least bad"

[14:11:40.0000] <Bakkot>
if `do { 1; function f(){} }` results in `1` and not a function, that's... not... correct

[14:11:44.0000] <rbuckton>
why do you disagree?

[14:11:46.0000] <ljharb>
yeah that'd be more bad

[14:11:57.0000] <sffc>
@chairs - can you inform the delegates of the decision of lunch break duration before tomorrow, so that I can adjust my schedule accordingly?  I'm trying to fit in non-TC39 meeting during the lunch break.

[14:12:07.0000] <rkirsling>
definitely more bad

[14:12:09.0000] <rbuckton>
To me that argues for explicit syntax for the return value.

[14:12:23.0000] <Bakkot>
sffc bterlson said above they will stick with 1 hour

[14:12:27.0000] <sffc>
I have a slight preference for 60-minute break because of that reason (ability to schedule a meeting during prime time)

[14:12:46.0000] <Bakkot>
rbuckton how so?

[14:12:55.0000] <Bakkot>
You can get the return value you want by putting an expression as the last statement.

[14:12:57.0000] <bterlson>
sffc: confirm, 1 hr lunch will continue

[14:13:08.0000] <Bakkot>
and putting a declaration as the last statement gives a syntax error

[14:13:19.0000] <sffc>
Sounds good, thanks

[14:13:25.0000] <Bakkot>
so you can do the things you want, and the surprising cases you can't run into

[14:13:54.0000] <jorendorff>
Bakkot: separate weird comment: `yield` expressions can already return ... you just ... don't have any control over it

[14:13:56.0000] <rbuckton>
Having to move the function is a mess WRT refactoring tooling

[14:13:59.0000] <ljharb>
or at least, you'll run into them immediately at dev time

[14:14:05.0000] <Bakkot>
jorendorff yeah I was avoiding bringing that up

[14:14:05.0000] <jorendorff>
I'm not sure what to conclude from that

[14:14:15.0000] <Bakkot>
it is true but obscure and also very strange

[14:14:16.0000] <jorendorff>
probably for the best

[14:14:29.0000] <devsnek>
i would conclude that making rules about what can occur in do expressions is dangerous

[14:14:30.0000] <jorendorff>
i mean, it means that the spec-internal wiring

[14:14:32.0000] <Bakkot>
rbuckton but at least you get an error instead of the wrong thing!

[14:14:41.0000] <Bakkot>
so you know your refactor needs to change

[14:14:42.0000] <rbuckton>
Consider this code:

[14:14:42.0000] <rbuckton>
```js

[14:14:42.0000] <rbuckton>
const fn = (x) => {

[14:14:42.0000] <rbuckton>
  // 1

[14:14:42.0000] <rbuckton>
  return x.map(visit);

[14:14:43.0000] <rbuckton>
  // 2

[14:14:43.0000] <rbuckton>
  function visit(y) { ... }

[14:14:44.0000] <rbuckton>
};

[14:14:44.0000] <rbuckton>
const a = fn(b);

[14:14:44.0000] <Bakkot>
seems fine to me

[14:14:45.0000] <rbuckton>
```

[14:14:45.0000] <rbuckton>
If I use tooling to inline `fn` as a `do` expression, the tooling would have to move `visit`, but does it also move `// 2` with it?

[14:14:46.0000] <jorendorff>
for returning from an expression, already exists and works

[14:15:25.0000] <Bakkot>
rbuckton probably yes; most tooling considers comments to attach to the following statement, which is decent heuristic

[14:15:55.0000] <Bakkot>
rbuckton but also I don't think "tooling which is automatically rewriting code will need to make a call about how to handle comments" is an argument which should have much weight

[14:16:22.0000] <rbuckton>
```

[14:16:22.0000] <rbuckton>
const fn = (x) => {

[14:16:22.0000] <rbuckton>
  // 1

[14:16:22.0000] <rbuckton>
  return x.map(visit);

[14:16:23.0000] <rbuckton>
  // long explanation of what visit does

[14:16:24.0000] <rbuckton>
  // even more text...

[14:16:24.0000] <rbuckton>
  function visit(y) { ... };

[14:16:25.0000] <rbuckton>
};

[14:16:25.0000] <rbuckton>
```

[14:16:29.0000] <ljharb>
comment attachment is definitely already an intractable problem imo

[14:16:48.0000] <Bakkot>
tooling usually considers all of the comments between statement A and statement B to be attached to B, unless they occur at the end of line A, in my experience

[14:16:54.0000] <ljharb>
rbuckton: if `visit` requires that much explanation, then why isn't it extracted into a separate tested module?

[14:16:54.0000] <Bakkot>
so the long explanation would get moved

[14:16:58.0000] <rbuckton>
I disagree, tooling is an important consideration, which is why there's a monthly tooling call

[14:17:04.0000] <Bakkot>
I agree that tooling is important.

[14:17:29.0000] <devsnek>
how about if do expressions allows control flow i'll write the eslint rule to disallow it for you

[14:17:37.0000] <Bakkot>
I disagree with the specific claim that "tooling which is automatically rewriting code will need to make a call about how to handle comments" is an argument which should have much weight

[14:17:43.0000] <Bakkot>
that is more specific than "tooling".

[14:18:52.0000] <ljharb>
devsnek: first you'd have to convince eslint core to add the rule, under their new rules policy

[14:19:13.0000] <devsnek>
what's that policy

[14:19:21.0000] <Bakkot>
devsnek I will continue having to read other code bases

[14:19:27.0000] <Bakkot>
more to the point, so will everyone else

[14:19:40.0000] <devsnek>
and they will read my beautiful code that uses control flow

[14:19:47.0000] <devsnek>
and say "wow bakkot's code is lacking in this amazing pattern"

[14:19:48.0000] <devsnek>
:P

[14:19:49.0000] <Bakkot>
they will read your code that uses control flow

[14:19:53.0000] <Bakkot>
that part I agree with

[14:20:40.0000] <Bakkot>
devsnek the policy is that they do not accept rules which just ban syntax, if you could write it with the forbidden syntax rule

[14:20:41.0000] <rbuckton>
Comparison:

[14:20:41.0000] <rbuckton>
```

[14:20:41.0000] <rbuckton>
// no cf

[14:20:41.0000] <rbuckton>
for (const x of ar) {

[14:20:41.0000] <rbuckton>
  const y = x.y;

[14:20:42.0000] <rbuckton>
  if (y === null || y === undefined) continue;

[14:20:42.0000] <rbuckton>
  ...

[14:20:43.0000] <rbuckton>
}

[14:20:44.0000] <rbuckton>
// with cf

[14:20:44.0000] <rbuckton>
for (const x of ar) {

[14:20:45.0000] <rbuckton>
}

[14:21:03.0000] <rbuckton>
```

[14:21:04.0000] <rbuckton>
// with cf

[14:21:04.0000] <rbuckton>
for (const x of ar) {

[14:21:04.0000] <rbuckton>
  const y = x.y ?? do { continue; }

[14:21:04.0000] <rbuckton>
}

[14:21:04.0000] <rbuckton>
```

[14:21:21.0000] <Bakkot>
rbuckton that example does not make me want to allow control flow

[14:21:23.0000] <rbuckton>
oi (code fragments in irccloud can be a pain)

[14:21:24.0000] <shu>
why is that better?

[14:21:32.0000] <shu>
rbuckton: yeah i may be having the opposite reaction you want

[14:21:37.0000] <shu>
rbuckton: which is that with cf is less readable

[14:21:43.0000] <shu>
i agree that it's terser

[14:21:51.0000] <ljharb>
i agree with that ^

[14:22:13.0000] <shu>
and the === null || === undefined is contrived

[14:22:19.0000] <shu>
if the intention is to test for nullish, == undefined is fine

[14:22:31.0000] <rbuckton>
shu: Its concise, same reason we have `??` now instead of `x !== null || x !== undefined ? x : y`

[14:22:49.0000] <rbuckton>
`== undefined` is not fine because of `document.all`

[14:22:52.0000] <shu>
rbuckton: that concision did not cross statement/expression boundaries

[14:22:58.0000] <shu>
rbuckton: fair enough for document.all

[14:23:03.0000] <Bakkot>
the point about ?? is that it is consise _and clearly expresses intent_

[14:23:22.0000] <Bakkot>
having a `const y =` which is also sometimes a `continue` does not, to me, clearly express intent

[14:23:28.0000] <jorendorff>
no but motivating examples should not be this ... extremely specific

[14:23:34.0000] <rbuckton>
It seems strange to be able to do `x ?? do { throw ... }` but not `x ?? do { continue; }`

[14:23:40.0000] <Bakkot>
why?

[14:23:44.0000] <Bakkot>
expressions can throw, that's normal

[14:23:48.0000] <Bakkot>
expression can't continue

[14:23:54.0000] <Bakkot>
exceptions are exceptional

[14:23:55.0000] <rbuckton>
a statement is a statement.

[14:24:17.0000] <Bakkot>
I don't think that's a distinction users really think about.

[14:24:24.0000] <Bakkot>
`if` is a statement, but does something exprsesions can do

[14:24:25.0000] <Bakkot>
that's fine

[14:25:15.0000] <shu>
i can sympathize with the desire to check all the boxes for all the statements, even though i disagree

[14:25:44.0000] <shu>
i also have an additional reason to ban, which is i don't really think it's worth either spec authors' time nor implementers' time to work through the corner cases like loop headers

[14:27:12.0000] <Bakkot>
there's a lot of edge cases, yeah

[14:27:30.0000] <rbuckton>
Bad alternative:

[14:27:30.0000] <rbuckton>
```

[14:27:30.0000] <rbuckton>
const sContinue = Symbol();

[14:27:30.0000] <rbuckton>
for (const x of ar) {

[14:27:30.0000] <rbuckton>
  try {

[14:27:31.0000] <rbuckton>
    const y = x.y ?? do { throw sContinue; }

[14:27:31.0000] <rbuckton>
  }

[14:27:32.0000] <rbuckton>
  catch (e) {

[14:27:32.0000] <rbuckton>
    if (e === sContinue) continue;

[14:27:33.0000] <rbuckton>
    throw e;

[14:27:33.0000] <rbuckton>
  }

[14:27:34.0000] <rbuckton>
}

[14:27:34.0000] <rbuckton>
```

[14:27:43.0000] <Bakkot>
yeah, people can write bad code if they want

[14:28:02.0000] <shu>
so the desire to have universal availability of statements at least has a caveats that the corner cases need some explanation. we can of course define _something_, but i reckon in the end it'll be more surprising that not. we can selectively ban, but that's an equally careful task to carry out, one that i am not happy to allocate staff to

[14:28:12.0000] <Bakkot>
I don't find "people can use this bad alternative" a good reason to allow a thing

[14:28:19.0000] <Bakkot>
I do not expect people to actually write that in practice

[14:28:30.0000] <Bakkot>
instead of your first non-cf example

[14:28:57.0000] <shu>
you can do arbitrary non-structured control flow if you reloop your code today, is that a reason to add goto?

[14:29:01.0000] <shu>
i mean i would personally love goto

[14:29:15.0000] <rbuckton>
At least with banning we can relax that later if there is enough interest in community. I'm not going to die on the hill of `break/continue/return` in `do{}` as I don't have a strong opinion.

[14:29:20.0000] <jorendorff>
shu: as far as `return` is concerned, I don't think there are necessarily any new corner cases to work through; since `yield` already exists, anything to do with expressions returning has already been sorted

[14:29:56.0000] <shu>
jorendorff: i don't follow

[14:30:01.0000] <ljharb>
rbuckton: i think that you wouldn't be alone in jumping on board an immediate follow-on proposal to relax the ban

[14:30:13.0000] <rbuckton>
shu: The only `goto` I want would be to jump to a specific falling switch case (as in C#).

[14:30:20.0000] <rbuckton>
s/falling/following

[14:30:44.0000] <shu>
jorendorff: mechanically being like return doesn't mean programmers think about them similarly, and my impression is that they're not thought of similarly

[14:31:11.0000] <jorendorff>
shu: was in response to the specific point that it wasn't worth spec authors' or implementors' time to work through special cases

[14:31:19.0000] <rbuckton>
But in C#'s case it's `goto case ...`

[14:31:23.0000] <shu>
jorendorff: ah, okay, and for return you're saying that's not true

[14:31:27.0000] <Bakkot>
jorendorff theere is one new edge case, which is `return` in parameter expressions

[14:31:35.0000] <Bakkot>
but yeah it's not nearly as bad as `break`

[14:31:42.0000] <jorendorff>
Bakkot: fantastic

[14:32:02.0000] <jorendorff>
Bakkot: yield is simply banned there, suggesting the same for return

[14:32:19.0000] <Bakkot>
yeah, it's not too bad

[14:33:15.0000] <rbuckton>
Banning `break`/`continue`/`return` is purely banning syntax. If they weren't banned the existing spec machinery would already cover how their handled. The downside of banning them is that it makes the spec more complex rather than less.

[14:33:50.0000] <ljharb>
rbuckton: i don't think it would? because it could happen from a bunch of new places

[14:33:53.0000] <rbuckton>
You also have to ban break/continue/return in eval in a `do`

[14:33:58.0000] <jorendorff>
i'm not sure the spec says clearly what `for (do {break};;)` ought to do

[14:34:02.0000] <Bakkot>
rbuckton: yeah, part of the reason I'm advocating for just banning `break/continue/return`, instead of e.g. having `return` mean "provide this value from the `do`", as some have suggested, is so that the restriction can be relaxed later if there is enough community and implementor interest and someone works through all the edge cases

[14:34:24.0000] <jorendorff>
rather, i'm not sure it does what we would want

[14:34:28.0000] <Bakkot>
rbuckton they are already banned

[14:34:39.0000] <Bakkot>
you cannot `break` out of an `eval`, even a sloppy direct eval

[14:34:51.0000] <jorendorff>
or return, sads

[14:35:00.0000] <rbuckton>
fair

[14:35:29.0000] <Bakkot>
(presumably for the same reason as I am proposing not to let you `break` out of a `do` :P)

[14:36:02.0000] <jorendorff>
/me registers doubt

[14:36:28.0000] <rbuckton>
Bakkot: by that you mean this? `for (...) do { break; }`?

[14:36:59.0000] <rbuckton>
or this: `do { break; /*early exit from the do itself*/ }`?

[14:37:03.0000] <Bakkot>
first one

[14:37:07.0000] <rbuckton>
k.

[14:37:17.0000] <rbuckton>
heh: `do { it: break it; }`

[14:37:25.0000] <Bakkot>
that was one of my examples!

[14:37:30.0000] <Bakkot>
actually slightly more complicated

[14:38:24.0000] <TabAtkins>
...can you `yield` within a parameter expression

[14:38:35.0000] <rbuckton>
banning break/continue is would just be changing how labeled evaluation works, correct? Or are you going to try to make `break`/`continue` syntactically invalid in the grammar?

[14:38:36.0000] <TabAtkins>
Ah, jorendorff seems to be saying they're banned there, ok

[14:39:23.0000] <shu>
rbuckton: i was imagining early error static semantics

[14:39:36.0000] <jorendorff>
i was also imagining EESS

[14:40:15.0000] <devsnek>
banning the control flow in loop headers and function parameters is fine

[14:40:17.0000] <rbuckton>
That's fine, just concerned about grammar complexity.

[14:40:57.0000] <Bakkot>
rbuckton the grammar is already set up not to allow an unlabeled `break` outside of a loop, or a `break l` out side of an `l`

[14:41:31.0000] <Bakkot>
making it so that there are no labels or loops visible to the `do` is actually easier than propagating that information through all expressions

[14:41:33.0000] <Bakkot>
(by a lot)

[14:41:45.0000] <devsnek>
not really

[14:41:51.0000] <devsnek>
you have to explicitly ban it using early errors

[14:41:58.0000] <rbuckton>
The grammar for `do {}`? Because there's no grammar restrictions in the spec: https://tc39.es/ecma262/#prod-BreakStatement

[14:42:10.0000] <devsnek>
or a parameter

[14:42:13.0000] <Bakkot>
devsnek you'd have to explicitly allow it, too

[14:42:18.0000] <devsnek>
no you wouldn't?

[14:42:27.0000] <Bakkot>
there is an early error for `break` outside of loops

[14:42:37.0000] <devsnek>
but not one for break inside blocks

[14:42:43.0000] <Bakkot>
to allow `for (;;) { (do { break;} ) }` you need to make the error not trip

[14:42:52.0000] <devsnek>
nothing explicitly allows `x: { break x; }`

[14:42:56.0000] <devsnek>
er

[14:43:09.0000] <devsnek>
`x: { { break x; } }`

[14:43:29.0000] <devsnek>
you don't need to add anything for `x: { do { break x; } }` to work there

[14:43:49.0000] <Bakkot>
yes, you do

[14:44:01.0000] <Bakkot>
you need to modify `ContainsUndefinedBreakTarget` to not error in that case

[14:44:03.0000] <Bakkot>
currently it would

[14:44:30.0000] <Bakkot>
(ok it might not, but it certainly would for e.g. `x: if(do{break x;}) ;`

[14:44:31.0000] <Bakkot>
)

[14:44:31.0000] <rbuckton>
LabelledEvaluation doesn't apply to expressions, so the labelSet wouldn't be populated.

[14:44:36.0000] <Bakkot>
right

[14:44:37.0000] <Bakkot>
so

[14:44:38.0000] <Bakkot>
it would error

[14:44:52.0000] <devsnek>
ok true labelled evaluation would need to be updated

[14:45:19.0000] <Bakkot>
labelled evaluation is runtime semantics

[14:45:24.0000] <Bakkot>
you'd also need to update the static semantics

[14:45:25.0000] <devsnek>
indeed

[14:45:51.0000] <devsnek>
are you sure about the if statement?

[14:45:57.0000] <rbuckton>
devsnek: a different example might be this: `switch (x) { case 0: do {break; } }` since it would have passed the `ContainsUndefinedBreakTarget` check

[14:46:18.0000] <rbuckton>
Or `do { do { break; } } while (true);` ;)

[14:46:27.0000] <devsnek>
lol

[14:46:29.0000] <devsnek>
got it

[14:46:55.0000] <Bakkot>
devsnek I am not sure if it would error. But either it would error, or `x: if(do{break y}); ` would not. so it would need to be updated one way or the eother.

[14:47:25.0000] <Bakkot>
you'd definitely to propagate the about labels/breaks through expressions, where currently and with my proposed semantics you do not need to do that.

[14:47:44.0000] <devsnek>
i'll write up the changes for that if you want

[14:47:46.0000] <Bakkot>
so, yeah, like I said; it's actually strictly simpler to spec my propose semantics. not that this should have much weight

[14:47:48.0000] <Bakkot>
nah

[14:47:55.0000] <Bakkot>
I don't think spec difficulty should matter, like I say

[14:48:09.0000] <Bakkot>
this was just a response to rbuckton's concern about the spec difficulty of my proposed semantics

[14:52:04.0000] <jorendorff>
devsnek: Other iterator prototypes have a toStringTag, like <https://tc39.es/ecma262/#sec-%arrayiteratorprototype%-@@tostringtag>.

[14:52:07.0000] <jorendorff>
devsnek: is it intentional that %WrapForValidIteratorPrototype% does not?

[14:52:51.0000] <devsnek>
no

[14:53:06.0000] <jorendorff>
ok, i'll ask adam if he can file a PR to add it

[14:55:20.0000] <shu>
rbuckton: so i think i can be convinced that selective banning may be the desirable solution as a follow-on, especially if a version without control flow is shipped first

[14:55:31.0000] <shu>
and we get to see what the uptake is like

[15:47:10.0000] <jorendorff>
hmm. are do-expressions already in any of the compile-to-js languages?

[15:47:27.0000] <jorendorff>
curious to know what the uptake is like already

[15:48:26.0000] <jridgewell>
Babel?

[15:48:52.0000] <ljharb>
jorendorff: lots of us do a lot of strong advocacy for people to never use pre-stage-3 proposals, so it may not be that clear a picture

[15:48:57.0000] <leobalter>
@jorendorff jridgewell https://babeljs.io/docs/en/babel-plugin-proposal-do-expressions

[15:49:46.0000] <Bakkot>
babel's is broken-ish though

[15:50:01.0000] <Bakkot>
but still popular with jsx, I think

[15:50:42.0000] <jridgewell>
Yah, I think JSX expressions is the biggest usecase

[15:51:41.0000] <jridgewell>
[Repl](https://babeljs.io/repl#?browsers=ie%2011&build=&builtIns=false&spec=false&loose=true&code_lz=MYewdgzgLgBCMF4YBN4G8BQMYEsBmMAFFAE4CuApgJQybbamVYwC-MFANhBbc9ngEMuFZiwwsgA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=true&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=stage-1&prettier=false&targets=&version=7.10.2&externalPlugins=)


2020-06-02
[07:56:30.0000] <mathiasbynens>
akirose: damn that's a nice ecma mug

[07:56:50.0000] <akirose>
my coffee is too hot to drink 😭

[07:57:04.0000] <akirose>
but yes it sure is an Ecma mug

[07:57:10.0000] <akirose>
🥳

[07:58:04.0000] <akirose>
when i was in geneva last year a couple of us raided the swag closet

[07:58:08.0000] <akirose>
i got an umbrella too

[07:58:23.0000] <mathiasbynens>
there’s umbrellas?!

[07:59:24.0000] <ystartsev>
yep

[07:59:28.0000] <ystartsev>
we are all jealous

[08:00:58.0000] <mathiasbynens>
my inner rihanna must have one

[08:03:34.0000] <leobalter>
My computer had a forced update. I’ll join the meeting soon

[08:07:54.0000] <robpalme>
we are about to start String#replaceAll

[08:10:35.0000] <akirose>
that was in july last year, right?

[08:11:01.0000] <rkirsling>
👏

[08:11:56.0000] <jridgewell>
👏

[08:12:12.0000] <rickbutton>
congrats on the Stage 4 (pending editors)!

[08:13:23.0000] <shu>
i hope we all reviewed before this meeting, we try to anyway

[08:18:26.0000] <shu>
jridgewell: btw logical assignment will be stable by 85 *with* NamedEvaluation, was a trivial patch

[08:24:25.0000] <michaelficarra>
not everything we do has to set a precedent

[08:24:43.0000] <ljharb>
and yet, everything we do tends to

[08:25:19.0000] <michaelficarra>
this same topic came up yesterday with iterator helpers

[08:25:55.0000] <rricard>
@jridgewell, can you complete your question in notes?

[08:26:54.0000] <msaboff>
ystartsev: What does l,34 mean in the notes doc?

[08:27:07.0000] <ystartsev>
msaboff: i had the same question

[08:27:32.0000] <msaboff>
mathiasbynens: ^^

[08:27:58.0000] <mathiasbynens>
mathiasbynens: me too, no idea who added it or what it means

[08:28:15.0000] <robpalme>
is Philip Chimento here?

[08:28:27.0000] <michaelficarra>
pipobscure, no?

[08:28:36.0000] <ryzokuken>
robpalme: can I take a message?

[08:28:59.0000] <marja_>
for more info, if you wonder how the AggregateError ctor order is observable, see the last test case here: https://chromium-review.googlesource.com/c/v8/v8/+/2139571/34/test/mjsunit/harmony/aggregate-error.js#1 (the last test, AggregateErrorCreation)

[08:29:07.0000] <robpalme>
enquiring if he is able to present Temporal now (after the current topic)

[08:29:27.0000] <ryzokuken>
robpalme: that's the plan 😇

[08:29:33.0000] <ryzokuken>
Let me make sure he's in the meeting.

[08:30:10.0000] <robpalme>
specifically after Promise.any and *before* Unicode

[08:30:31.0000] <ryzokuken>
oh, right. I'll let you know in a sec.

[08:31:50.0000] <jridgewell>
shu: 🙌, thanks!

[08:31:57.0000] <ryzokuken>
robpalme: yes, they can do it 😄

[08:32:25.0000] <robpalme>
thank you - we'll make it next and unicode will follow it (they are swapped)

[08:32:48.0000] <ryzokuken>
great, thanks for the heads up.

[08:33:17.0000] <rbuckton>
First convert to list, then call super, then assign errors?

[08:34:01.0000] <ljharb>
rbuckton: that would be fine with me, but the impl pushback was "prefer not to run any code before calling super"

[08:34:42.0000] <mathiasbynens>
the issue is https://github.com/tc39/proposal-promise-any/issues/14

[08:38:54.0000] <rwaldron>
shu I'll add that AggregateError change to my schedule for tomorrow, should be super quick

[08:39:27.0000] <shu>
rwaldron: +1 awesome

[08:46:53.0000] <sffc>
What is the phone number for today's Teams call so I can call in for audio? (please DM it to me)

[08:48:06.0000] <bterlson>
sffc: dm sent

[08:48:51.0000] <mathiasbynens>
rwaldron: both changes? :)

[08:50:15.0000] <rwaldron>
mathiasbynens any test changes necessary to address https://docs.google.com/presentation/d/1juwk662pDATPCPqPxlE8M9rBGeA9zAp0_sJBoxu3eMc/edit#slide=id.g8753e62b92_0_16

[08:50:27.0000] <rwaldron>
Unless you're referring to something else?

[08:50:46.0000] <rwaldron>
Looks like you an I are literally "on the same page"

[08:50:54.0000] <mathiasbynens>
rwaldron: yeah those are the two changes

[08:51:24.0000] <mathiasbynens>
rwaldron: just wanted to double-check you heard both discussions (since you said “change” not “changes”)

[08:51:41.0000] <mathiasbynens>
rwaldron: \o/ thanks!

[08:53:10.0000] <marja_>
rwaldron, afaics the order in which the aggregateerror ctor does stuff is not tested in test262, but it could be (see the link i posted above)

[08:53:35.0000] <marja_>
the tests in AggreagateErrors/errors must be rewritten, pretty much

[08:55:06.0000] <rwaldron>
marja_ thanks

[08:55:28.0000] <ljharb>
should be, imo

[08:56:01.0000] <shu>
how do you overflow bigints?

[08:56:02.0000] <shu>
oh

[08:57:21.0000] <michaelficarra>
a BigInt value in an internal slot?

[08:57:30.0000] <michaelficarra>
that makes no sense, they could just use mathematical values

[08:58:00.0000] <ljharb>
they may be thinking in terms of the polyfill

[08:58:18.0000] <ystartsev>
oh, dumb question - what would mathematical values mean here?

[08:58:29.0000] <ystartsev>
like, spec only values?

[08:58:32.0000] <mathiasbynens>
that

[08:59:02.0000] <bterlson>
I'm glad temporal continues the legacy of copying java by adopting their builder pattern

[08:59:56.0000] <rkirsling>
^ this definitely reads as sarcasm but I'm not 100% sure it is?

[09:00:32.0000] <ryzokuken>
I mean, there's definitely enough factory functions in there.

[09:00:37.0000] <ryzokuken>
so guilty as charged, I guess

[09:01:56.0000] <TabAtkins>
+1 to defaulting to the iso calendar. bug potential isn't worth the heavy cost of specifying a calendar before every operation when 99%+ of all temporal usage will be in the iso calendar

[09:02:36.0000] <TabAtkins>
michaelficarra: The BigInt mattered because they were talking about the return value of `.valueOf()`, it's not just internal

[09:04:10.0000] <ryzokuken>
right, plus `Date` and friends can return a number.

[09:04:45.0000] <ryzokuken>
but then it'd make comparisons almost instantly fail once you mix with something with `Time`.

[09:05:02.0000] <michaelficarra>
TabAtkins: it's easy to make a BigInt from a mathematical value in valueOf

[09:05:59.0000] <TabAtkins>
michaelficarra: Yes, there was no problem with producing a BigInt. "Return a BigInt" was just one of the presented options (the other was throwing)

[09:06:42.0000] <michaelficarra>
TabAtkins: my comment was in reference to their statement that a BigInt was used in an internal slot, before we started talking about valueOf

[09:06:51.0000] <TabAtkins>
Ah kk

[09:07:58.0000] <michaelficarra>
see line 10 from this topic's notes if you want to read back

[09:16:02.0000] <ljharb>
sffc: isn't adding a day calendar-dependent if you're crossing a year or month boundary?

[09:18:03.0000] <TabAtkins>
ljharb: The day still advances the same for all calendars, no? The displayed value in a given calendar can care, but it's still a 24-hour advancement

[09:18:26.0000] <ljharb>
ah, i see

[09:18:32.0000] <ljharb>
what about over leap days?

[09:18:35.0000] <TabAtkins>
oh lol i was joking, i regret bringing up martian days

[09:18:36.0000] <ljharb>
leap days are 23 or 25 hours

[09:19:02.0000] <TabAtkins>
ljharb: Hm, that's a good point

[09:19:08.0000] <TabAtkins>
ljharb: worth bringing up

[09:19:10.0000] <TabAtkins>
I'll do so

[09:19:21.0000] <ljharb>
thanks

[09:19:23.0000] <Bakkot>
... by "leap days" do you mean "days on which DST changes"?

[09:19:33.0000] <Bakkot>
Feb 29 is normally 24 hours

[09:19:35.0000] <ljharb>
oh duh sorry

[09:19:36.0000] <ljharb>
yes

[09:19:46.0000] <ljharb>
daylight savings days, not leap days. early morning brain hiccup

[09:44:25.0000] <robpalme>
is chris garrett here?

[09:48:41.0000] <mathiasbynens>
michaelficarra: adding the prose as non-normative would still addresses some of your concerns, right?

[09:49:58.0000] <ljharb>
mathiasbynens: that prose would be an improvement regardless

[09:53:21.0000] <mathiasbynens>
that’s what i thought, but when michaelficarra said he’d be “fine” with it i wasn’t sure anymore

[09:57:22.0000] <michaelficarra>
well it's a nice improvement, but it doesn't actually address the concerns I had

[09:57:48.0000] <ljharb>
same

[09:58:00.0000] <haxjs>
what's the next step of decorator?

[09:58:05.0000] <rbuckton>
As far as I can tell, nothing has changed yet with decorators, this primarily was providing information on the type of analysis that has been ongoing.

[10:00:38.0000] <marja_>
re longer lunch break, i appreciate the 1 hour break to be able to help out with kids; assuming it's similar for other folks who have whatever outside responsibilities

[10:12:39.0000] <rbuckton>
For whatever reason I can't get Edge or Chrome to pick the correct webcam to use on spatial.chat

[10:29:55.0000] <rickbutton>
rbuckton: same, using firefox prompted me for the webcam to use

[10:46:19.0000] <akirose>
took me this long just to cook my food

[10:46:26.0000] <akirose>
so i am ++ on hour lunches

[10:46:36.0000] <akirose>
also, it's bad, but i'll take that to TDZ

[10:51:16.0000] <sffc>
Is the schedule on hackmd.io still up to date?

[11:02:37.0000] <robpalme>
we are starting Function Impl Hiding now

[11:05:27.0000] <akirose>
sffc: close

[11:05:36.0000] <akirose>
i still need to catch up on what i missed before lunch

[11:06:07.0000] <sffc>
I assume Intl.NumberFormat v3 is moved up to 2pm local time, and Intl.DurationFormat up to 2:20pm local time?

[11:07:19.0000] <akirose>
assuming Function Implementation Hiding sticks to exactly 60 min, yeah? i think so?

[11:18:55.0000] <mmarchini>
fyi we'd be fine with being able to disable statically (for example, with a startup flag). I guess for this to be possible the feature would need to be optional?

[11:19:31.0000] <Bakkot>
you could just have a non-conforming implementation when the flag is on

[11:19:59.0000] <mmarchini>
right

[11:25:57.0000] <mmarchini>
when is the library call? I'd like to join too

[11:26:46.0000] <jridgewell>
I actually really like the "hide from stack traces" aspect

[11:26:53.0000] <ljharb>
i really like both :-(

[11:27:15.0000] <rkirsling>
ystartsev: really glad you said all that, I assumed that it was too much of a done deal to speak up at this point

[11:27:28.0000] <ljharb>
i'm very surprised that this is a common sentiment

[11:27:33.0000] <jridgewell>
Using Error helpers pollutes my error logging a ton

[11:27:35.0000] <ljharb>
stage 2 is supposed to mean "we are planning to put this in the language"

[11:27:49.0000] <ystartsev>
i need to look at how this was moved into stage 2

[11:27:54.0000] <mmarchini>
what is the expectation when reporting errors on libraries with stack hiding? wouldn't it make harder for authors to debug issues?

[11:27:56.0000] <jridgewell>
We had to build a GitHub bot that stripped out the useless crap from error reports to focus on the actual code

[11:27:59.0000] <ljharb>
if multiple delegates/implementors had this opinion much prior to now, then it shouldn't have been stage 2 in the first place.

[11:28:00.0000] <ystartsev>
but i think we were under the impression that it would also have a performance improvement

[11:28:14.0000] <drousso>
ystartsev really well spoken and thought out :)

[11:28:18.0000] <ljharb>
ystartsev: is that something knowable prior to implementations and stage 3?

[11:28:26.0000] <ystartsev>
yes

[11:28:30.0000] <littledan>
here's the notes from that outreach call: https://docs.google.com/document/d/1vvL357Z6r9IYTItvNwBf0wRH-uT4J_bAFIqnbQb-13I/edit#bookmark=id.xscidqxjp5nf

[11:28:31.0000] <ystartsev>
we know that this will not have an improvement

[11:28:32.0000] <ljharb>
k

[11:28:46.0000] <littledan>
I believe that some of the use cases *were* blackboxing (but it's possible I misunderstood people)

[11:29:04.0000] <bradleymeck>
that question should have been a new topic i guess

[11:29:08.0000] <ystartsev>
yes that is how i understood it as well

[11:29:59.0000] <ljharb>
hiding source also would have prevented angular 1 from making "changing argument names" a breaking change.

[11:30:39.0000] <mmarchini>
I don't think it would?

[11:31:09.0000] <jridgewell>
That requires the angular user to be proactive, though

[11:31:10.0000] <littledan>
I think we discussed the Angular and lack-of-memory-improvement issues when proposing this for Stage 2, but IMO if Mozilla has serious concerns now, we shouldn't discard them at this point.

[11:31:13.0000] <ljharb>
jridgewell: true

[11:32:45.0000] <shu>
i take yulia's point, and am a "weak accept" on "hide source" in that it doesn't seem to hurt, but i have serious concerns about "sensitive"

[11:34:19.0000] <ljharb>
shu: i'm a strong +1 on hide source and also have concerns about "sensitive", fwiw

[11:34:53.0000] <littledan>
Note, there's a separate tools call, but we haven't discussed function implementation hiding as far as I can tell in the notes https://docs.google.com/document/d/1RlnAnMa4QzQUK_tNOHdWfnske2X9KZ_e90VBG-DWqUo/edit

[11:35:14.0000] <ystartsev>
i am really sorry michaelficarra. let's keep talking about it and i will join thosee other calls

[11:35:48.0000] <michaelficarra>
ystartsev: I understand it's not personal

[11:37:39.0000] <howdoi>
/me this is what I really like about this committee, maturity and mutual respect! 🙏 

[11:37:51.0000] <shu>
i am not understanding leo's point

[11:38:11.0000] <rickbutton>
blocking the proposal overall vs blocking the stage advancement request?

[11:38:45.0000] <rkirsling>
rickbutton: the latter

[11:38:55.0000] <rkirsling>
I don't think the former is actually a thing

[11:39:07.0000] <rickbutton>
right, I believe LBR's comment was to specify specifically the latter

[11:39:29.0000] <rickbutton>
unless I misunderstood

[11:41:17.0000] <leobalter>
shu: my purpose was disambiguation in the notes. As I said, my topic was a meta discussion on the wording we use. It was easily fixed as we all had the context fresh

[11:41:18.0000] <michaelficarra>
for the people questioning the security implications of stack inspection, please review my slides here: https://docs.google.com/presentation/d/15IWa2HM4sYUWmN_orRGFZ4H1D0AsZO4IcNliY68FwBE/edit

[11:41:35.0000] <robpalme>
this is Intl.NumberRange for Stage-2

[11:42:23.0000] <leobalter>
robpalme: yes, but Intl.NumberFormat **V3** for Stage 2

[11:43:04.0000] <ystartsev>
michaelficarra: our security stance is based on the situation with spectre, anything that is presented as a security feature without taking into consideration spectre is considered to... basically not fulfill the security requirement. I know you have a different stance here and I respect that. From the browser perspective I don't think this will change any time soon

[11:43:22.0000] <robpalme>
good clarification leo

[11:44:18.0000] <shu>
leobalter: thanks

[11:45:10.0000] <shu>
michaelficarra: chrome basically agrees with that view re: "security" in context of JS

[11:45:40.0000] <michaelficarra>
because JavaScript can't be made secure on systems affected by spectre, it can't be be made secure on any systems? that seems backwards to me

[11:46:02.0000] <shu>
preventing info leaks via a side channel that JS execution itself attempts to lock down is not that compelling, in that we aren't in a position to dictate to all present and future web APIs that they must respect this

[11:46:08.0000] <shu>
plus, timing is the primary side channel still

[11:46:54.0000] <shu>
michaelficarra: i don't think anyone claimed something that general

[11:47:16.0000] <shu>
but favoring systems that are not affected by spectre is a theoretical concern from my POV

[11:47:22.0000] <shu>
s/favoring/securing

[11:48:11.0000] <ystartsev>
It comes down to whether the feature is worth implementing. Security would not be a benefit here, and could potentially harm users and developers alike on the web due to false assumptions

[11:48:20.0000] <littledan>
I continue to be sad about the loss of a scale option. It'd be really useful!

[11:48:49.0000] <ystartsev>
it might benefit the few systems that are not exposed to spectre, but those are few and do not have as significant an impact on users as something the scale of the web

[11:49:00.0000] <ystartsev>
since this has this double edge, it would be better not to introduce it

[11:50:12.0000] <littledan>
My understanding from the framework notes was that people sort of wanted this for blackboxing... then, it sounded like omitting the stack frames from reflection APIs was more of a minus than a plus

[11:50:20.0000] <littledan>
maybe I misunderstood; michaelficarra could clarify

[11:50:26.0000] <michaelficarra>
so because of spectre, we've given up on allowing untrusted code to execute in the same realm following trusted code? how are websites supposed to integrate third party modules?

[11:51:44.0000] <michaelficarra>
I am much more surprised by this backpedaling on the security goal than I am the rejection of "hide source"

[11:51:49.0000] <ystartsev>
the security model that the web is following now is around process isolation and same origin sources (which, i am sure you know, but in case anyone wasn't aware)

[11:52:27.0000] <ystartsev>
so, third party modules are seen as the responsibility of the site that runs them

[11:52:33.0000] <shu>
michaelficarra: because of spectre, features that enable "safer" execution same-process non-isolated JS code shouldn't be advertised as having "security benefits"

[11:52:41.0000] <ystartsev>
^ exactly

[11:53:01.0000] <ystartsev>
This isn't a backpedaling, its been an established position of browsers for some time now

[11:53:03.0000] <michaelficarra>
that's quite the renouncement of SES, then

[11:53:22.0000] <shu>
i am surprised you are surprised by my opinion on SES

[11:53:31.0000] <michaelficarra>
ystartsev: I see it as backpedaling because we acknowledged the problem when we moved my initial proposal to stage 1

[11:53:43.0000] <ystartsev>
SES has a much higher bar now, yes.

[11:54:19.0000] <Bakkot>
I think SES attempts to limit side channels like timing, fwiw

[11:55:59.0000] <chicoxyzzy>
can invited experts be reviewers?

[11:56:09.0000] <ystartsev>
It might have been a mistake but i thought blocking something from stage 1 could only be for very specific things that had been discussed before?

[11:56:20.0000] <michaelficarra>
chicoxyzzy: I don't see why not

[11:56:23.0000] <ljharb>
chicoxyzzy: yes afaik

[11:56:41.0000] <ljharb>
ystartsev: blocking stage 1 means you don't think it's worth committee time to keep discussing it

[11:56:53.0000] <chicoxyzzy>
I'd like to be a reviewer if possible

[11:56:59.0000] <ljharb>
(and really this isn't "blocking", it's "not agreeing to advancement", regardless of how we phrase it)

[11:57:00.0000] <michaelficarra>
ystartsev: stage 1 acknowledges the problem, stage 2 agrees on a general solution, stage 3 solidifies a solution and asks for implementation

[11:57:28.0000] <ystartsev>
ok, i don't think that was the case for stage 1. its not like it was something that we didn't need to discuss and at the time there was more of an argument in favor of the proposal

[11:58:16.0000] <michaelficarra>
sure, I understand that our strategy for security on the web has shifted since the initial move to stage 1

[11:58:21.0000] <michaelficarra>
still surprised me though

[11:58:39.0000] <ystartsev>
yes, it is unfortunate that this came as a surprise, and i am sorry for that

[11:59:22.0000] <ystartsev>
I do think it was time well spent at committee, and i think a lot of good work came out of this

[12:00:16.0000] <littledan>
chicoxyzzy: That'd be great! I think you should be able to be a reviewer. I am happy to answer any questions

[12:00:55.0000] <chicoxyzzy>
cool! thank you Daniel!

[12:02:34.0000] <ystartsev>
chatting with waldo, I might review shadowing him

[12:02:50.0000] <ystartsev>
cc sffc (so you might have a "joint mozillian review" there)

[12:03:15.0000] <sffc>
😊

[12:03:18.0000] <chicoxyzzy>
littledan: sffc: should I leave a comment somewhere?

[12:03:49.0000] <littledan>
maybe we should have a Stage 3 review issue, and we can collect the list of reviewers there

[12:04:06.0000] <littledan>
also ryzokuken and I might jointly do the Igalia review

[12:04:31.0000] <robpalme>
extra points for the prince of persia screenshot

[12:04:38.0000] <littledan>
so that's three reviews

[12:04:54.0000] <rkirsling>
robpalme: indeed

[12:05:01.0000] <michaelficarra>
I love the work being done in 402

[12:05:02.0000] <sffc>
Thanks, everyone!  Also note that we will also need reviewers for the Intl.DurationFormat proposal.  I'll make sure everyone here is mentioned in the meeting notes.

[12:05:23.0000] <michaelficarra>
sffc: I will review DurationFormat

[12:05:34.0000] <ryzokuken>
(and I can't volunteer for that one 🙈)

[12:05:38.0000] <ryzokuken>
michaelficarra: thanks!

[12:07:09.0000] <rbuckton>
Was the spec text for Intl.DurationFormat up prior to the meeting? I recall looking yesterday and the spec link on the repo was empty

[12:08:19.0000] <sffc>
It's been in a PR

[12:08:35.0000] <rickbutton>
is there still another reviewer needed for Intl.DurationFormat? any requirements to be a reviewer?

[12:08:37.0000] <sffc>
A couple people have left feedback on the PR

[12:08:55.0000] <rbuckton>
Ah, I didn't see the PR, thanks!

[12:09:03.0000] <ystartsev>
rickbutton: last year i did a "shadow review" with domenic, it was really helpful

[12:09:05.0000] <ryzokuken>
rbuckton: yeah, it was a PR that was finalized and merged recently. Sorry for the delay.

[12:09:14.0000] <ystartsev>
i want to do it a couple more times just to find my feet

[12:09:23.0000] <ystartsev>
so, might be a nice way for you to ramp up also?

[12:09:31.0000] <rickbutton>
ystartsev: that sounds like a great idea

[12:10:10.0000] <ystartsev>
i think that might be a good way to expand our pool of reviewers, *looks at other members of the committee who are nervous about reviewing. *

[12:12:06.0000] <mpcsh>
✋

[12:12:20.0000] <rkirsling>
don't be afraid

[12:12:22.0000] <rkirsling>
it's fun

[12:12:52.0000] <ystartsev>
we should mark "good first reviews" and pair people up

[12:13:07.0000] <mpcsh>
I'm already doing this for Intl.Segmenter

[12:16:00.0000] <rkirsling>
segmenter would be fun

[12:19:28.0000] <ystartsev>
sffc: waldo and i are pairing on the review, i will add it to the notes

[12:21:04.0000] <rkirsling>
I'm happy to review as well but Ron beat me to it :P

[12:21:11.0000] <rkirsling>
lemme know whether a third is desired

[12:21:23.0000] <ryzokuken>
rkirsling: I don't see why not! 😄

[12:21:48.0000] <ryzokuken>
I'll make a PR to the explainer adding you three. Thanks everyone!

[12:21:57.0000] <rkirsling>
👍

[12:24:21.0000] <robpalme>
this is Symbols as WeakMap keys for Stage 1

[12:28:35.0000] <michaelficarra>
… and now we consider SES again?

[12:31:05.0000] <Bakkot>
petition to move on from this topic

[12:31:21.0000] <Bakkot>
(meaning the "box" thing, in particular)

[12:31:29.0000] <Bakkot>
guess we now are moving on

[12:31:50.0000] <rkirsling>
Bakkot: are you suggesting we think outside the box

[12:32:02.0000] <rkirsling>
also Fiddler is definitely not obscure

[12:32:25.0000] <akirose>
sffc: you sound like you're in a different room

[12:32:32.0000] <akirose>
and screaming into our room

[12:32:56.0000] <akirose>
is your device maybe using the wrong mic?

[12:33:06.0000] <howdoi>
BoxMaker reminds me of Monads.

[12:33:37.0000] <ljharb>
i think you mean "the container that must not be named"

[12:34:17.0000] <howdoi>
^ nods

[12:34:51.0000] <Bakkot>
feeling a huge compulsion to argue about whether monads are containers

[12:35:10.0000] <ljharb>
oh noes

[12:35:16.0000] <akirose>
/me points at tdz

[12:35:19.0000] <akirose>
march, mister.

[12:35:19.0000] <rkirsling>
^

[12:35:23.0000] <ljharb>
um, call ended?

[12:35:30.0000] <howdoi>
no

[12:35:33.0000] <ljharb>
weird, must just be me

[12:35:42.0000] <ljharb>
maybe i accidentally pushed the button on my airpod

[12:35:56.0000] <howdoi>
ha, airpods

[12:36:39.0000] <howdoi>
Bakkot: would love to hear more!

[12:36:51.0000] <akirose>
due to the fact that Dan invited clarifying questions during his presentation, pls lmk if any of y'all feel strongly that your queue items should interrupt (or just use the "clarifying question" button)

[12:37:30.0000] <ljharb>
akirose: i added a topic because mine's "more of a clarifying comment"

[12:37:38.0000] <akirose>
/me nods

[12:39:08.0000] <sffc>
akirose: it says I'm muted on Teams

[12:39:46.0000] <jridgewell>
We muted you

[12:39:51.0000] <akirose>
yes it does.

[12:39:59.0000] <sffc>
Oops, sorry about that

[12:40:19.0000] <akirose>
all good

[12:40:21.0000] <sffc>
I got up to get a drink

[12:40:28.0000] <sffc>
and was talking in the other room

[12:40:50.0000] <Bakkot>
ljharb I'm not claiming this isn't motivated without records

[12:40:56.0000] <Bakkot>
just that it is not _worth it_ without records

[12:41:08.0000] <Bakkot>
I am aware of the motivation; you can read the existing discussion on github

[12:44:20.0000] <ljharb>
gotcha

[12:44:58.0000] <ljharb>
even without records, the template use case could still be a deeply frozen object, combined with a weakmap

[12:48:50.0000] <howdoi>
can anyone help me to find the definition for Temporal.Date.compare? [looking into the ployfill]

[12:49:21.0000] <sffc>
howdoi: the docs are https://github.com/tc39/proposal-temporal/blob/main/docs/date.md#temporaldatecompareone-temporaldate-two-temporaldate--number

[12:49:22.0000] <howdoi>
https://github.com/tc39/proposal-temporal/blob/61b88049ea2f8e099121ceb762b6465a8c161c10/polyfill/lib/date.mjs#L156 this?

[12:49:46.0000] <sffc>
Yeah, that looks like it

[12:49:52.0000] <howdoi>
cool, thanks

[12:50:05.0000] <ryzokuken>
howdoi: yep, that's it.

[12:50:09.0000] <ryzokuken>
but actually, also not.

[12:50:12.0000] <ryzokuken>
we have a PR

[12:50:18.0000] <ryzokuken>
for adding calendar logic.

[12:50:31.0000] <sffc>
I think the compare method doesn't delegate to the calendar

[12:50:37.0000] <ryzokuken>
oh

[12:50:38.0000] <sffc>
because we always compare in ISO space

[12:50:41.0000] <ryzokuken>
wait, yeah

[12:50:48.0000] <ryzokuken>
oof, my bad. you're right.

[12:51:35.0000] <sffc>
Relevant discussion: https://github.com/tc39/proposal-temporal/issues/625

[12:51:57.0000] <rickbutton>
I am massively in favor of this, I literally ran into this problem last night

[12:52:00.0000] <brad4d>
what is the name for the tdz chat? couldn't find it in a quick look through how-we-work / how-to-attend-meetings

[12:52:06.0000] <rickbutton>
*compiling to wasm

[12:52:09.0000] <rickbutton>
brad4d: temporaldeadzone

[12:52:54.0000] <howdoi>
> Comparison and equality of dates with different calendars

[12:52:54.0000] <howdoi>
Exactly was my next question!

[12:53:51.0000] <littledan>
I'm vaguely +1 on this proposal

[12:54:16.0000] <howdoi>
would be useful, if the user could define a custom comparator? sffc ryzokuken

[12:54:39.0000] <ryzokuken>
well, you could always convert all dates to a single calendar and then compare...

[12:54:46.0000] <sffc>
The comparator is literally only the compare method.  You have to call the method to use it

[12:55:00.0000] <ryzokuken>
we also considered allowing comparison if one of the calendars was ISO

[12:55:11.0000] <sffc>
For example, you have to pass Temporal.Date.prototype.compare into Array.prototype.sort

[12:55:36.0000] <sffc>
The comparator is not implicitly used anywhere

[12:56:00.0000] <sffc>
I think that's how it works at least

[13:39:58.0000] <rbuckton>
Temporal types now have a compare prototype member? Last I checked it was just a static compare

[13:40:25.0000] <ryzokuken>
rbuckton: just static compare indeed

[13:40:50.0000] <ryzokuken>
sffc: might've mistyped

[13:41:06.0000] <ryzokuken>
it's just `Temporal.Date.compare`, no prototype

[13:41:38.0000] <ryzokuken>
oooh, btw, dunno if you noticed, but we added a `.d.ts` 😇

[13:43:26.0000] <rbuckton>
I am working on a draft for adding `@@equals`, `@@hash` (for use with Map/Set/user-defined equality comparisons), and `@@compareTo` for relational comparisons. Note that neither has anything to do with operator overloading and doesn't affect equality or relational operators. Its based on what I did here: https://esfx.js.org/esfx/api/equatable.html, and here:

[13:43:26.0000] <rbuckton>
https://esfx.js.org/esfx/api/collections-hashmap/hashmap.html#_esfx_collections_hashmap_HashMap_class

[13:44:00.0000] <ljharb>
rbuckton: like for a proposal? or for your library

[13:44:19.0000] <rbuckton>
A proposal. My library consists of things that I'd eventually like to propose

[13:44:22.0000] <ljharb>
rbuckton: you may want to wait for the "generic comparison" proposal on thursday

[13:46:06.0000] <rbuckton>
I've talked briefly (at least in the irc) about alternatives to some of the proposals for handling equality in Map keys, such as providing an "equaler" (object consisting of an `equals(left, right)` and a `hash(value)` method), the HashMap class I point to above is based on that design.

[13:47:27.0000] <rbuckton>
The design is inspired by `IEquatable`, `IComparer`, `EqualityComparer`, and `Comparer` in .NET, but designed around ES symbols rather than interfaces.

[13:48:39.0000] <rbuckton>
Either way, I'd love to have a `Temporal.Date.prototype.compareTo` method, at least as a convenience.

[13:49:03.0000] <ryzokuken>
that could be a simple shorthand...

[13:49:37.0000] <ryzokuken>
`Temporal.Date.p.comareTo = (other) => Temporal.Date.compare(this, other);`

[13:50:23.0000] <rbuckton>
Honestly, I'd like to see both static and prototype versions of both `equals` and `compare`. The prototype methods make it easier to interact directly with objects, and that static versions are highly useful when passed as callbacks.

[13:50:50.0000] <ryzokuken>
right.

[13:51:26.0000] <rbuckton>
I'm averse to attaching members to a prototype like that that aren't part of a spec, don't want to run afoul of the issues with "flatten"

[13:51:31.0000] <ryzokuken>
rbuckton: I don't think that'd be too complicated either, spec-wise or otherwise. It's just a question of "is it important enough to increase the API surface?"

[13:51:57.0000] <ryzokuken>
which is likely less important here, since we have a ton of stuff in the API anyway.

[13:52:22.0000] <rbuckton>
ryzokuken: I also bring it up because I have a library that is based on the temporal proposal because I wanted to experiment a bit. I've been updating it to the latest version of the proposal recently.

[13:52:49.0000] <ryzokuken>
Oh yeah, that's been a shifting goalpost for a while.

[13:53:06.0000] <ryzokuken>
But we'll reach a good point after the npm release in a few days.

[13:53:39.0000] <rbuckton>
It uses the `@esfx/equatable` APIs so that I can use `Date`, etc. as keys in a `HashMap` from `@esfx/collections-hashmap`

[13:54:01.0000] <ljharb>
imo a prototype method implies that directionality matters

[13:54:02.0000] <ryzokuken>
oh wow

[13:54:12.0000] <ljharb>
or rather, matters beyond inverting the result

[13:54:23.0000] <ryzokuken>
ljharb: I mean, that way, `equals` should be static too.

[13:54:26.0000] <ljharb>
like, `(a, b)` and `(b, a)` should either both be zero, or both be opposite signs

[13:54:52.0000] <ljharb>
ryzokuken: yes, probably true. but for equals they should always be commutative, so that doesn't feel as necessary to imply to me

[13:55:30.0000] <rbuckton>
Most of `@esfx` grew out of wanting to have a shared core API, and includes things like "collection" interfaces via symbols that can be shimmed onto builtins so that you can generically access members of an `Array`, `Map`, `Set`, etc. without having to special case for each type.

[13:56:11.0000] <ljharb>
that doesn't make much sense to me as a general goal; they often have different semantics

[13:56:31.0000] <rbuckton>
https://esfx.js.org/esfx/api/collection-core.html, basically has `Collection`, `FixedSizeIndexedCollection`, `IndexedCollection`, `KeyedCollection`

[13:56:55.0000] <rbuckton>
Yeah, true, but you can add items to an Array and a Set, but for Array its `push` and for a set its `add`.

[13:57:43.0000] <rbuckton>
With those (and with the relevant shim), you just do `obj[Collection.add](value)`

[13:58:32.0000] <rbuckton>
Or `obj[Collection.size]` rather than `Array.isArray(obj) ? obj.length : obj.size`, etc.

[13:58:37.0000] <ljharb>
and Map is more like a record/struct/object, where array and set are more like Lists

[13:58:46.0000] <rbuckton>
Correct

[13:58:59.0000] <ljharb>
tbh it makes me feel that treating them generically is a category error

[13:59:06.0000] <rbuckton>
However they still share common characteristics. Both have an inherent size.

[13:59:11.0000] <ljharb>
so do strings

[13:59:16.0000] <Bakkot>
jorendorff ping

[13:59:17.0000] <rbuckton>
Yep

[13:59:26.0000] <jorendorff>
Bakkot: Good afternoon!

[13:59:32.0000] <ljharb>
but making strings iterable was a mistake :-)

[13:59:42.0000] <Bakkot>
time to talk about built-in generators?

[13:59:57.0000] <jorendorff>
ljharb, Bakkot, michaelficarra, devsnek, avandolder: would a Zoom meeting be OK?

[14:00:02.0000] <Bakkot>
wfm

[14:00:31.0000] <ljharb>
yup yup

[14:01:09.0000] <jorendorff>
ok, let's try https://mozilla.zoom.us/j/95168117347

[14:01:23.0000] <rbuckton>
A lot of popular mainstream languages work similarly for the various collection classes as well, and I've found a fair amount of use for the design even just within my own projects.

[14:12:12.0000] <NilSet>
reminds me of rust traits

[14:43:24.0000] <jorendorff>
Thanks again, iterator helpers

[14:43:40.0000] <jorendorff>
oops, is that a team name, do I need to order t-shirts

[14:43:56.0000] <rickbutton>
t-shirts should be a stage 2 requirement

[14:44:00.0000] <rkirsling>
niiice

[14:44:15.0000] <rickbutton>
* should be in tdz, whoops

[15:12:20.0000] <jorendorff>
I posted my understanding of our discussion in https://github.com/tc39/proposal-iterator-helpers/issues/97#issuecomment-637833039

[15:12:35.0000] <jorendorff>
devsnek in particular: take a look?

[15:13:11.0000] <devsnek>
will do

[15:31:39.0000] <akirose>
Aww right now was supposed to be the newcomer’s event

[15:40:34.0000] <rkirsling>
oh noo

[15:40:48.0000] <rkirsling>
I didn't realize that was happening at all

[15:41:09.0000] <rkirsling>
(or do you mean, if this were in person?)

[15:41:21.0000] <rkirsling>
we could still do one


2020-06-03
[18:01:23.0000] <shu>
i was writing a logical assignment test in C++ and tripped C++ trigraph warnings for ??

[18:01:59.0000] <Bakkot>
nice

[18:02:01.0000] <shu>
if i had known at the time of proposing nullish, who knows what my opinion would've been

[18:09:55.0000] <drousso>
shu i actually ran into the same thing 🤣

[18:12:16.0000] <shu>
drousso: beset by legacy features no matter where we work

[18:12:23.0000] <drousso>
😭

[18:42:10.0000] <devsnek>
we should add trigraphs to js

[18:43:07.0000] <devsnek>
by which I mean the c ones

[18:43:58.0000] <drousso>
shu i don't think the test262 tests for `AggregateError.prototype.errors` has been removed

[18:44:23.0000] <drousso>
oh wait i just found the PR

[18:44:27.0000] <drousso>
sorry 😅

[18:44:34.0000] <devsnek>
oh what was the conclusion on that

[18:45:07.0000] <drousso>
it should be an own property instead of a prototype accessor

[18:45:18.0000] <drousso>
im trying to change this in JSC right now <https://webkit.org/b/212677>

[18:45:26.0000] <devsnek>
nice

[18:47:23.0000] <rkirsling>
damn, Yusuke reviewed it before I even knew it existed

[18:47:25.0000] <rkirsling>
lol

[18:48:57.0000] <drousso>
rkirsling i asked him :P

[18:49:14.0000] <drousso>
rkirsling also, i think i have a fix for the `foo ??= function() {}` change :)

[18:49:41.0000] <rkirsling>
yeah I'm teasin', I know he reviewed the original (and gave lots of comments I wouldn't've been equipped to give)

[18:51:12.0000] <devsnek>
was it decided that it should get the name

[18:51:45.0000] <Bakkot>
yeah

[18:52:30.0000] <devsnek>
woo

[18:52:56.0000] <rkirsling>
I think by saying "woo" now you just expressed the most energetic sentiment there

[18:53:29.0000] <rkirsling>
people seemed to be pretty meh on the whole whether agreeing or disagreeing 😅

[18:54:28.0000] <drousso>
i genuinely could go either way on this lol

[22:23:00.0000] <rkirsling>
yikes. guess it's good we switched away? https://twitter.com/NicoAGrant/status/1268020841054269440

[22:38:57.0000] <ljharb>
personally i'd prefer name inference not exist, but i'm a -0 on adding it in new places

[22:39:24.0000] <ljharb>
rkirsling: i mean, that kind of presumes microsoft and google don't cooperate with law enforcement

[22:40:26.0000] <rkirsling>
perhaps

[22:40:29.0000] <rkirsling>
just seemed poorly put

[22:41:18.0000] <ljharb>
well sure, zoom is a garbage company. but their product is miles ahead of everyone else, and there's sadly not many companies that don't cooperate with law enforcement; we just don't hear about most of them.

[22:41:29.0000] <ljharb>
(also we'd be using a premium zoom account if we used it)

[22:42:45.0000] <rkirsling>
fair enough...

[08:11:15.0000] <michaelficarra>
I'm very excited about the extensibility of module attributes

[08:12:47.0000] <Bakkot>
has Chrome expressed a position on module attributes?

[08:12:53.0000] <Bakkot>
I feel like someone from the chrome team was opposed to them

[08:13:00.0000] <Bakkot>
domenic, maybe

[08:13:01.0000] <ljharb>
michaelficarra: the syntactic extensibility, or the host-carte-blanche extensibility?

[08:13:11.0000] <michaelficarra>
ljharb: syntactic

[08:13:15.0000] <ljharb>
gotcha, thanks

[08:13:49.0000] <michaelficarra>
I think littledan is missing the biggest reason why these must be in-band: import-site-specific metadata vs resource-specific metadata

[08:14:07.0000] <ljharb>
i'm confused; the queue item says "for stage 2" but the slide intro said "status update". is this proposal seeking advancement today?

[08:14:26.0000] <michaelficarra>
ljharb: I'm sure littledan will clarify that for us shortly

[08:14:29.0000] <ljharb>
kk

[08:14:48.0000] <michaelficarra>
oh I should stop mentioning his name while he's presenting, sorry Daniel!

[08:14:56.0000] <shu>
Bakkot: i am for the most part for them

[08:16:43.0000] <Bakkot>
shu neat, thanks

[08:17:18.0000] <shu>
Bakkot: this is a bottleneck for non-JS assets for web apps

[08:17:36.0000] <ljharb>
not for wasm tho?

[08:17:41.0000] <shu>
Bakkot: and given that i've been convinced that non-syntax alternatives are strictly technically worse, i'd prefer this get through

[08:17:44.0000] <shu>
yes, also for wasm?

[08:17:51.0000] <shu>
i mean, it affects wasm

[08:17:52.0000] <ljharb>
hm, can you help me understand that?

[08:17:57.0000] <shu>
i don't understand what your question is

[08:18:02.0000] <ljharb>
right but i mean, the motivating concerns don't apply to importing wasm, as i understand them

[08:18:06.0000] <ljharb>
only to non-code assets

[08:18:15.0000] <ljharb>
(json, css, html)

[08:18:46.0000] <shu>
that's not how i understand it

[08:19:13.0000] <ljharb>
what's your understanding? :-)

[08:19:32.0000] <shu>
the original motivating security concern from apple included both "noexecute" and "wrong parser"

[08:19:45.0000] <shu>
wasm falls in "wrong parser"

[08:21:06.0000] <shu>
the function does run differently depending on how you call it

[08:21:33.0000] <ljharb>
"wrong parser" can be solved without syntax tho on the web - it can use headers

[08:25:19.0000] <brad4d>
why did my question disappear from the queue? Was it inappropriate in some way?

[08:25:34.0000] <ljharb>
brad4d: hm, i never saw yours on there

[08:25:42.0000] <ljharb>
brad4d: reload the page?

[08:26:01.0000] <brad4d>
weird, refresh brings it back, thx

[08:26:09.0000] <jridgewell>
brad4d: sometimes the tcq is buggy

[08:26:35.0000] <ljharb>
ah lol yes i see it now that i refresh too

[08:26:36.0000] <jridgewell>
Or, sometimes 2 people click "delete" on the same row at the time time

[08:33:03.0000] <akirose>
i have done that before

[08:33:52.0000] <rkirsling>
do you mean both click delete on their own item at the same time?

[08:34:05.0000] <rkirsling>
'cause I don't think anybody can delete anybody else's

[08:35:58.0000] <akirose>
i mean as a chair

[08:36:44.0000] <akirose>
or like someone clicks "i'm done speaking" at the exact same time as i click "next speaker" bc i think they forgot and they did forget _until that exact moment_

[08:37:11.0000] <ljharb>
i did click "done speaking" on myself

[08:38:39.0000] <ljharb>
robpalme: i'm still on the queue (i had 2), and if you refresh you may see that i'm "speaking" right now :-) but i can go after bradley

[08:44:49.0000] <ljharb>
msaboff: you can't try/catch imports

[08:45:01.0000] <msaboff>
I know

[08:53:50.0000] <michaelficarra>
I have the same concerns about ignored vs rejected unknown attributes, but I also think it wouldn't kill this proposal either way; if it ends up being a problem, those attributes just unfortunately won't be added

[08:54:58.0000] <shu>
ljharb: to answer your question on here

[08:55:33.0000] <shu>
ljharb: i think the pressure to align isn't going to prevent aligning on a strictly worse solution, like a DSL inside module specifier

[08:56:42.0000] <keith_miller>
How would an envaluator work if you have two imports with different evaluators do you get different modules?

[08:57:05.0000] <keith_miller>
Because that would be wild

[08:57:17.0000] <michaelficarra>
I agree with Shu, they will just do something worse for the other attributes

[08:57:31.0000] <ljharb>
shu: out-of-band is also a viable option

[08:57:56.0000] <shu>
ljharb: i do not have the energy to be the middle man currently for this entire space

[08:58:00.0000] <ljharb>
ok

[08:58:07.0000] <akirose>
timebox, y'all. i'm about to start snapping like an impatient suburban mom

[08:58:13.0000] <shu>
akirose: this is an important proposal

[08:58:25.0000] <shu>
i believe extension is worth while

[08:58:35.0000] <akirose>
yes it is. and so are all the other things on the schedule.

[08:58:46.0000] <shu>
no, i believe this is more important than other things on the schedule

[08:58:58.0000] <ystartsev>
cool down period and come back to this topic?

[08:59:00.0000] <rbuckton>
ljharb: Limit the allowed keys of the `with { }` to just the one we care about for now?

[08:59:10.0000] <ystartsev>
@bterlson akirose robpalme  MylesBorins ?

[08:59:13.0000] <ljharb>
rbuckton: which is just "type", yes, i'd be happy with that for now

[08:59:17.0000] <michaelficarra>
I agree with Shu, can we take a break and come back to this later or tomorrow?

[08:59:28.0000] <ystartsev>
ditto

[08:59:38.0000] <akirose>
that's fine

[09:00:03.0000] <michaelficarra>
littledan please include me in the offline module attributes discussion

[09:01:17.0000] <michaelficarra>
I also encourage people to choose less restrictive timeboxes for time sensitive proposals like this

[09:01:25.0000] <littledan>
sorry aboutthat

[09:02:00.0000] <littledan>
I guess we can start this offline discussion during lunch

[09:02:59.0000] <sffc>
Great example of something to do in the hallway track

[09:03:27.0000] <ljharb>
littledan: i'll need 10m to make lunch but will hop in after that

[09:03:32.0000] <littledan>
OK good

[09:03:41.0000] <sffc>
I'm in favor of shorter timeboxes to identify conflicts, followed by hallway track to resolve those conflicts out of band

[09:04:00.0000] <sffc>
Since we are over-subscribed this meeting and I'm still hoping we can get to Intl.Segmenter, which fell off the end

[09:09:25.0000] <michaelficarra>
sffc: if it's any consolation, overflow from previous meetings precede other proposal agenda items

[09:10:11.0000] <michaelficarra>
though I don't necessarily agree with that ordering

[09:10:39.0000] <devsnek>
what is the argument for BuiltInModule being preferable to just having globals

[09:10:54.0000] <Bakkot>
devsnek I am about to ask that question

[09:11:08.0000] <ljharb>
wsdferdksl: you run the shimming Script first, and then later Modules are affected by it

[09:11:34.0000] <devsnek>
hasModule = name in global, import = global[name], export = global[name] = v, freezeModules = Object.freeze(global)?

[09:12:32.0000] <jridgewell>
Or, `import 'shim.js'; import 'main.js'`, and `shim.js` will run before imports

[09:12:41.0000] <Bakkot>
Object.freeze(global) has a lot of other effects

[09:12:45.0000] <Bakkot>
which you really don't want

[09:13:16.0000] <devsnek>
Bakkot: some application of removing configurability and writability then

[09:13:50.0000] <jridgewell>
Oh, maybe linking in `main.js` happens before execution of `shim.js`

[09:14:06.0000] <rkirsling>
+1 to Thomas Levy's question (not sure IRC handle)

[09:14:08.0000] <jridgewell>
I'm not 100% sure, since this would be the first time you could muck with it

[09:14:20.0000] <ljharb>
jridgewell: yeah you'd need `import 'shim.js'; await import('main.js')` i think

[09:14:46.0000] <devsnek>
would be nice to hear from implementations on that last point

[09:14:49.0000] <ljharb>
rkirsling: just like now, where applications must always choose to freeze the env if that's what they want, they must choose to freeze builtin modules

[09:15:01.0000] <devsnek>
they already have pretty reasonable accessor apis for lazy object creation

[09:15:02.0000] <ljharb>
rkirsling: (is how i understand it)

[09:15:24.0000] <rkirsling>
more specifically I'm wondering if this becomes the new way to begin a JS file

[09:15:28.0000] <Bakkot>
devsnek msaboff is an implementation

[09:15:37.0000] <rkirsling>
er wait not file

[09:15:38.0000] <Bakkot>
... implementor

[09:15:39.0000] <rkirsling>
app

[09:15:43.0000] <ljharb>
rkirsling: SES.lockdown() isn't the way to begin a JS file now :-)

[09:15:57.0000] <devsnek>
Bakkot: ah ok, the way he phrased that made it sound otherwise

[09:16:11.0000] <rkirsling>
ljharb: I mean I can take your word for that but I'm not familiar with SES envs

[09:16:38.0000] <rkirsling>
first-hand

[09:16:46.0000] <ljharb>
rkirsling: it's definitely the way to start any app that wants that kind of lockdown, sure

[09:17:06.0000] <rkirsling>
I mean I guess once-per-app is reasonable

[09:17:20.0000] <rkirsling>
I dunno why I thought once-per-file

[09:20:45.0000] <rkirsling>
oh... this is a new topic that jumped the queue

[09:20:52.0000] <rkirsling>
:-/

[09:21:21.0000] <devsnek>
so the only reason this is better than adding new apis to the global is because engines can lazy load?

[09:21:41.0000] <bradleymeck>
rkirsling: you don't freeze in prod due to perf

[09:22:00.0000] <bradleymeck>
perf goes down in a non-trivial way for frozen stuff in engines

[09:22:23.0000] <robpalme>
v8 does not really have much of a penalty once frozen

[09:22:30.0000] <rkirsling>
but I think locking down was for security _in prod_

[09:22:36.0000] <rkirsling>
*thought

[09:22:45.0000] <bradleymeck>
robpalme: has that been fixed? last i saw it still devolved into dict mode

[09:22:48.0000] <jridgewell>
robpalme: it did until about last year

[09:23:13.0000] <jridgewell>
bradleymeck: Yes, they fixed it very recently

[09:23:13.0000] <bradleymeck>
yay

[09:23:23.0000] <devsnek>
bradleymeck: it causes a deoptimization but everything can reoptimize again

[09:23:34.0000] <devsnek>
not locked to dict anymore

[09:23:35.0000] <bradleymeck>
so likely it is just a comms issue for that

[09:23:35.0000] <robpalme>
@bradleymeck we did a lot of benchmarking and could not find anything worth investing in fixing, so i's "good enough"

[09:23:49.0000] <rkirsling>
ohh I didn't realize we skipped ALL the replies

[09:23:58.0000] <rkirsling>
I too didn't recognize voices 😓

[09:24:30.0000] <gibson042>
mea culpa

[09:24:37.0000] <jridgewell>
I believe this is the public doc: https://docs.google.com/document/d/1X6zO5F_Zojizn2dmo_ftaOWsY8NltPHUhudBbUzMxnc/edit

[09:25:04.0000] <jridgewell>
^ "Fast frozen & sealed elements in V8"

[09:27:11.0000] <devsnek>
is freezeModules shallow?

[09:27:21.0000] <devsnek>
do you have to call freezeModules if your app is esm

[09:27:52.0000] <msaboff>
freezeModule doesn't freeze the module, just the module map.

[09:28:01.0000] <ljharb>
devsnek: i'm not sure how the BuiltinModules object would be made unavailable inside ESM

[09:28:13.0000] <ljharb>
devsnek: so i'd say yes

[09:28:42.0000] <devsnek>
well i wouldn't want anything to not be made available

[09:28:57.0000] <devsnek>
so if this is shallow, can't bad code still do bad things

[09:29:10.0000] <devsnek>
like i can't replace Temporal but i can replace Temporal.prototype.whatever

[09:29:16.0000] <shu>
i don't understand how shallow/deep applies to freezing the module map

[09:29:25.0000] <shu>
that doesn't do any freezing to things inside the module

[09:29:31.0000] <devsnek>
right so i'm asking

[09:29:33.0000] <devsnek>
what's the point of it

[09:29:35.0000] <jridgewell>
devsnek: I think that applies to global objects, too

[09:29:40.0000] <jridgewell>
This shouldn't be any different

[09:29:59.0000] <devsnek>
my understanding was freezeModules implies some sort of security

[09:30:04.0000] <shu>
no

[09:30:18.0000] <devsnek>
ok so what's it for

[09:31:06.0000] <ljharb>
it just means that the module namespace object can't be replaced any further

[09:31:12.0000] <ljharb>
replaced/modified

[09:31:18.0000] <devsnek>
right but why does someone want that

[09:31:36.0000] <devsnek>
what would be my motivation to call freezeModules()

[09:31:49.0000] <ljharb>
to have guarantees about the semantics of the rest of your application

[09:31:53.0000] <ljharb>
some of them

[09:31:58.0000] <devsnek>
what guarantees

[09:32:14.0000] <ljharb>
that `import * as ns from 'builtin module'` will always provide the `ns` you expect

[09:32:27.0000] <ljharb>
you certainly may also want to freeze the contents of that ns

[09:32:39.0000] <devsnek>
so its just like... a consistency thing

[09:32:52.0000] <ljharb>
you say "just" but i prioritize that pretty highly :-)

[09:33:05.0000] <devsnek>
i mean if we don't allow mutating the map in the first place

[09:33:26.0000] <devsnek>
sorry scratch that, if we don't have the distinction

[09:33:55.0000] <devsnek>
of application before freeze and application after freeze

[09:34:11.0000] <devsnek>
like with the global, you can apply whatever constraints you want

[09:34:17.0000] <devsnek>
at whatever point

[09:35:30.0000] <robpalme>
heads up on scheduling:  the next topic (deep-path properties) is 25min (11:45-12:10 CST) so will eat into lunch.  meaning lunch will be 50min instead of 60min.

[09:44:56.0000] <robpalme>
this font is not the greatest font in the world, it is just a tribute

[09:46:11.0000] <rkirsling>
robpalme: to tdz with ye

[09:46:39.0000] <robpalme>
@rkisling soory of course

[09:47:31.0000] <rkirsling>
(oh I'm not chastising so much as inviting lol)

[09:49:33.0000] <NilSet>
that nestd spread mess is used all over our codebase today, when we attempt to be immutable without a lib

[09:50:12.0000] <michaelficarra>
couldn't you theoretically do something like `newObj = (someFunction(immutableObj).deep.path.property = newValue)`?

[09:50:25.0000] <devsnek>
michaelficarra: i was thinking the same thing

[09:50:50.0000] <michaelficarra>
getters/setters solve the problem

[09:50:51.0000] <devsnek>
it would be unique for assignment to not return rhs though

[09:50:54.0000] <Bakkot>
no, that gives you newValue

[09:51:15.0000] <jridgewell>
Yah, that's the same as `newObj = … = newVal`

[09:51:15.0000] <devsnek>
Bakkot: it could not though

[09:51:19.0000] <jridgewell>
Whic his just `newVal`

[09:51:30.0000] <Bakkot>
devsnek yeah, I assumed the question was about using existing language features

[09:51:37.0000] <michaelficarra>
even when a setter is invoked, assignment returns the RHS?

[09:51:40.0000] <Bakkot>
yup

[09:51:42.0000] <michaelficarra>
aww

[09:51:53.0000] <devsnek>
like i said, unique

[09:52:08.0000] <jridgewell>
Yah, just like with `x = (uint8array[0] = 999)`

[09:52:12.0000] <jridgewell>
You get `999`

[09:52:28.0000] <jridgewell>
Even though `uint8array` will do a setter-like thing

[09:52:30.0000] <devsnek>
how about

[09:52:34.0000] <keith_miller>
shu: Do you or V8 have performance concerns with tuples generally?

[09:52:37.0000] <devsnek>
walrus operator

[09:52:47.0000] <keith_miller>
Since there's going to be a lot more object allocations

[09:52:54.0000] <devsnek>
`newRecord := oldRecord.x.y.z = 5`

[09:52:58.0000] <shu>
keith_miller: i haven't looked too deeply yet. i have vague anxiety, i guess

[09:53:01.0000] <ljharb>
lol walrus

[09:53:25.0000] <shu>
keith_miller: the default implementation technique means a lot more interning too

[09:53:34.0000] <keith_miller>
and it's hard to do escape analysis in JS, which is pretty important generally for other languages that have tuples.

[09:53:37.0000] <devsnek>
ljharb: i thought i was kidding but now i think i'm serious

[09:54:10.0000] <shu>
keith_miller: well yeah, and v8 at least wants things to be fast in the interpreter nowadays, we can't really lean escape analysis or scalar replacement and the like even if it were easy

[09:54:11.0000] <keith_miller>
so you can't do the normal just use the same cell

[09:54:20.0000] <jridgewell>
I want walrus operator just for the name.

[09:54:20.0000] <shu>
lean on*

[09:54:26.0000] <keith_miller>
right

[09:54:34.0000] <Bakkot>
python has tuples and is hard to escape-analyze

[09:54:37.0000] <jridgewell>
Eg, `||=` should forever be known as the mallet operator

[09:54:45.0000] <devsnek>
Bakkot: python is famously slow

[09:54:57.0000] <shu>
Bakkot: true, but python's performance demands is mostly offshored to C

[09:54:59.0000] <jridgewell>
https://github.com/tc39/proposal-logical-assignment/blame/master/README.md#L6

[09:55:02.0000] <ljharb>
jridgewell: ||= doesn't look like a mallet tho unless it's `||=` :-/

[09:55:05.0000] <shu>
in those FFI modules, is my understanding

[09:55:24.0000] <NilSet>
the turbofish operator <>:: is literally why i first looked at rust

[09:55:55.0000] <michaelficarra>
what does it mean for this proposal to advance to stage 1 when records/tuples is not stage 4?

[09:56:21.0000] <ljharb>
michaelficarra: stage 1 just means we're going to talk about it more

[09:56:33.0000] <michaelficarra>
because we agree there's a problem that needs to be solved

[09:56:43.0000] <michaelficarra>
how can there be a problem if there's no feature?

[09:56:44.0000] <gibson042>
stage(deepPathProperties) ≤ stage(recordsAndTuples)

[09:57:13.0000] <devsnek>
i feel like this should either be part of the more general object proposal

[09:57:13.0000] <Bakkot>
michaelficarra I think it's fine to say that we're advancing this to stage 1 with an eye towards a problem which does not yet exist but might in the future

[09:57:16.0000] <devsnek>
or the record/tuple proposal

[09:57:35.0000] <akirose>
wait isn't stage 1 acknowledging "there's a problem" and stage 2 "that we're interested in solving"

[09:57:41.0000] <jridgewell>
michaelficarra: See NilSet's comment

[09:57:44.0000] <jridgewell>
> that nestd spread mess is used all over our codebase today, when we attempt to be immutable without a lib

[09:58:09.0000] <jridgewell>
I think that means we have a larger issue than just record/tuple?

[09:58:13.0000] <Bakkot>
akirose stage 2 is "that we are interested in solving _with something like this solution_"

[09:58:31.0000] <Bakkot>
stage 2 implies a particular approach to solving the problem

[09:58:49.0000] <Bakkot>
(just with details omitted)

[09:58:58.0000] <michaelficarra>
^

[09:59:59.0000] <michaelficarra>
stage 1: we agree that there's a problem, stage 2: we've agreed on the important bits of our solution, stage 3: we've nailed down all the details of our solution

[09:59:59.0000] <rbuckton>
All of the mutations could be packed into a single result if the mutations within the same `{}` are tracked?

[10:01:12.0000] <michaelficarra>
nowObj = delete lens(oldObj).deep.property.name

[10:01:19.0000] <michaelficarra>
*newObj

[10:02:10.0000] <Bakkot>
michaelficarra fwiw we usually treat stage 1 as more like "we are not willing to declare that there is definitely not a problem"

[10:02:30.0000] <michaelficarra>
agreed, the bar for stage 1 is low

[10:02:40.0000] <michaelficarra>
and I think that's the right way to operate

[10:03:05.0000] <michaelficarra>
we should really add descriptions like these to the process document

[10:03:08.0000] <Bakkot>
request that we refrain from arguing about these details, given the timebox

[10:03:15.0000] <Bakkot>
the ones being discussed on the call, that is

[10:10:57.0000] <jridgewell>
Is "lenses" just codewords for proxy?

[10:11:49.0000] <michaelficarra>
jridgewell: all you could ever want to know about lenses: https://hackage.haskell.org/package/lens-tutorial-1.0.4/docs/Control-Lens-Tutorial.html

[10:12:14.0000] <rkirsling>
it's basically recreating property access in a pure FP setting

[10:12:29.0000] <rkirsling>
but I wasn't prepared to try to envision this in a JS setting

[10:13:03.0000] <TabAtkins>
OH wow, this was apparently not the morning for me to skip the pre-lunch parts of the meeting, if we're getting into lenses already

[10:13:11.0000] <jridgewell>
Can you translate into a normal language?

[10:13:13.0000] <jridgewell>
Lol.

[10:13:31.0000] <NilSet>
Question: What is a lens?

[10:13:32.0000] <NilSet>
Answer: A lens is a first class getter and setter

[10:13:42.0000] <rkirsling>
TabAtkins: lol. you missed it by a couple of minutes

[10:13:46.0000] <NilSet>
sounds to me like yes its codeword for proxy

[10:14:03.0000] <TabAtkins>
No, it's quite different from a proxy, but for ~mysterious reasons~

[10:14:22.0000] <NilSet>
or rather you could implement a lens with a function that returns a proxy

[10:14:54.0000] <rkirsling>
oh like using a proxy as a view

[10:15:18.0000] <TabAtkins>
I'm busy this morning trying to untangle the HTML spec's use of GOTO in algorithms into nested loops

[10:15:21.0000] <TabAtkins>
for real wtf

[10:15:26.0000] <rickbutton>
oh no

[10:17:45.0000] <devsnek>
TabAtkins: link?

[10:18:31.0000] <TabAtkins>
the one i'm working on right now is https://html.spec.whatwg.org/multipage/parsing.html#reconstruct-the-active-formatting-elements

[10:18:53.0000] <devsnek>
i lost it at "rewind"

[10:20:12.0000] <rkirsling>
reverse reverse

[10:22:02.0000] <shu>
ljharb: are we talking about module attributes?

[10:26:44.0000] <gibson042>
michaelficarra: https://tools.ietf.org/html/rfc3986#section-3

[10:27:05.0000] <jridgewell>
To answer the builtin modules discussion earlier:

[10:27:06.0000] <michaelficarra>
gibson042: huh?

[10:27:08.0000] <jridgewell>
https://gist.github.com/jridgewell/8428f797ef85346d3081c99518fa9fce

[10:27:17.0000] <ljharb>
shu: i'm here in the hallway track just now; littledan?

[10:27:27.0000] <jridgewell>
That will execute `shim.js` (which defines `js:foo`) before `main.js` links `js:foo`

[10:27:37.0000] <devsnek>
jridgewell: what if shim.mjs imports main.mjs

[10:27:40.0000] <shu>
ljharb: stepped away for a sec, omw

[10:27:49.0000] <jridgewell>
That would break it

[10:28:01.0000] <gibson042>
scheme      = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )

[10:28:15.0000] <gibson042>
sorry, that was for jridgewell

[10:44:07.0000] <bradleymeck>
jridgewell: in your gist the whole graph is lined prior to entry being ready to evaluate (and thus before shim)

[10:44:12.0000] <bradleymeck>
linked*

[10:44:29.0000] <bradleymeck>
so shim wouldn't execute prior to main linking

[10:45:23.0000] <jridgewell>
This behavior is msaboff's intention

[10:45:41.0000] <bradleymeck>
ah

[10:45:59.0000] <bradleymeck>
cycles would have to be isolated, that seems... hard

[10:47:19.0000] <msaboff>
If the shimming happens in a script loaded before a module that imports the shimed module, We propose that the shimmed module is the one that would be linked.

[10:48:17.0000] <bradleymeck>
<script> or Script (JS parse goal)

[10:48:19.0000] <bradleymeck>
?

[10:48:38.0000] <msaboff>
Yes

[10:48:57.0000] <bradleymeck>
which?

[10:49:16.0000] <msaboff>
Script

[10:49:22.0000] <msaboff>
parse goal

[10:49:25.0000] <bradleymeck>
msaboff: would the ESM module graph from an import be rewired is the question

[10:49:46.0000] <bradleymeck>
to my understanding your Script/<script> would be outside of the ESM module graph it can instrument

[10:49:58.0000] <bradleymeck>
not like the linked gist

[10:50:03.0000] <msaboff>
I'd like to talk with you about how that would work.

[10:52:27.0000] <msaboff>
In the linked gist, it is my desire that shim.js would be processed first, before the second import, but we need to talk.

[10:58:36.0000] <shu>
sorry had to close spatial chat

[10:58:42.0000] <shu>
was making my gsuite laggy :/

[10:58:59.0000] <robpalme>
two minutes warning!

[10:59:09.0000] <bradleymeck>
msaboff: that would be a change for sure to how ESM currently works

[10:59:22.0000] <robpalme>
we will be starting with Restrict subclassing support for built-inmethods

[10:59:25.0000] <bradleymeck>
linking is in early error domain currently

[10:59:27.0000] <msaboff>
Let's figure out a time to talk.

[10:59:36.0000] <rwaldron>
bterlson tomorrow do a 4 minute warning. https://www.youtube.com/watch?v=6eyUrpOl40k

[11:00:48.0000] <rkirsling>
ooh yes, been waiting for this topic

[11:02:28.0000] <leobalter>
littledan: for what I want, it's ok for -0 to be similar as in `0 === -0`, at the same time I want the flexibility of not breaking a deep comparison because of NaN

[11:03:03.0000] <ljharb>
leobalter: that's SameValueZero

[11:03:14.0000] <leobalter>
yes

[11:03:23.0000] <leobalter>
yes

[11:03:24.0000] <keith_miller>
rickbutton: littledan: Thinking about record/tuple more, have you considered just one type? so #["a"] is just sugar for #{ 0:"a" }?

[11:03:50.0000] <ljharb>
keith_miller: lists and structs should be conceptually distinct imo, that seems odd

[11:03:51.0000] <jridgewell>
Can we just throw if you insert a `NaN` inside a record?

[11:04:16.0000] <rickbutton>
keith_miller: it would need to sugar to #{ 0: "a", length: 1 }

[11:04:26.0000] <keith_miller>
ljharb: It's weird to me that those wouldn't be the same?

[11:04:28.0000] <keith_miller>
rickbutton: Sure

[11:04:42.0000] <ljharb>
keith_miller: a list has N items, a struct has N pairs

[11:04:57.0000] <ljharb>
also there's a ton of methods you want on Tuples that don't really make sense on Records

[11:05:14.0000] <littledan>
keith_miller: Tuples have Array-like methods on their prototype, whereas Records probably shouldn't have those

[11:05:31.0000] <littledan>
also Tuples have a .length, but I guess that could be part of the desugaring

[11:05:50.0000] <Bakkot>
jridgewell markm proposed that but a lot of people didn't like it

[11:05:52.0000] <Bakkot>
I also don't like it

[11:05:54.0000] <keith_miller>
I don't know how much it matters for the array methods to be on the prototype

[11:05:56.0000] <Bakkot>
though I don't hate it I guess

[11:06:01.0000] <keith_miller>
since it just wouldn't do anything

[11:06:23.0000] <rickbutton>
keith_miller I think it matters a lot, because we want people to be able to use tuples like they already use arrays, which use prototype methods

[11:06:31.0000] <rickbutton>
Array.prototype.slice doesn't mutate the array

[11:06:34.0000] <Bakkot>
jridgewell https://github.com/tc39/proposal-record-tuple/issues/65#issuecomment-635771624

[11:06:36.0000] <keith_miller>
I just find it mildly confusing that a record could have exactly the same members as a tuple but not be ==

[11:06:39.0000] <ljharb>
keith_miller: if they're own properties you can't polyfill Tuple methods.

[11:06:44.0000] <jridgewell>
`NaN` causes hairy equality issues, which is bad if records are motivated by equality.

[11:06:59.0000] <ljharb>
keith_miller: imo that's a feature. a list and a struct can't be the same

[11:07:01.0000] <jridgewell>
We already have runtime checks for disallowing mutable objects

[11:07:22.0000] <keith_miller>
ljharb: But that's not how objects in JS work

[11:07:43.0000] <keith_miller>
Objects in JS can have both indexed and non-index properties

[11:07:43.0000] <ljharb>
keith_miller: depends on what custom comparison logic you choose

[11:07:47.0000] <keith_miller>
so can arrays

[11:08:01.0000] <ljharb>
keith_miller: most comparison libraries (including the quite popular ones i maintain) consider arrays and objects to not be equalish

[11:08:06.0000] <ljharb>
also node's assert

[11:08:07.0000] <jridgewell>
Bakkot: I think Mark was also proposing `#[-0]` throws

[11:08:13.0000] <Bakkot>
jridgewell true

[11:08:23.0000] <Bakkot>
-0 also causes hairy equality issues, tbf

[11:08:29.0000] <keith_miller>
What do you mean by custom comparison logic?

[11:08:31.0000] <devsnek>
thinking of tuples in terms of arrays is surprising to me

[11:08:41.0000] <ljharb>
keith_miller: like, what's the implementation of your `isEqual(a, b)` function

[11:08:43.0000] <rickbutton>
I would be against #[-0] throwing, there are legitimate cases where -0 can appear, we don't want those to throw

[11:08:48.0000] <jridgewell>
I think `===` has good equality for `-0`.

[11:09:02.0000] <ljharb>
keith_miller: if it includes an Array.isArray check, as all the common ones do, then an array and an object would never be considered equal

[11:09:17.0000] <jridgewell>
It doesn't for `NaN`

[11:09:31.0000] <keith_miller>
But that's not part of the actual type system that's just what people implement when they do deep comparison

[11:10:06.0000] <keith_miller>
You could also do any amount of prototype chain checking

[11:10:21.0000] <shu>
keith_miller: after this item you got a min to talk through the deep property path escape analysis comment you had

[11:10:25.0000] <rickbutton>
it is a part of the type system, if you consider that object being an "array" exotic object is a part of the type itself

[11:10:36.0000] <keith_miller>
shu: Sure

[11:10:57.0000] <keith_miller>
shu: You mean the presentation or IRC?

[11:11:07.0000] <shu>
keith_miller: the presentation

[11:11:13.0000] <keith_miller>
👍🏾

[11:11:14.0000] <shu>
keith_miller: i just wanted to queue it up

[11:11:48.0000] <keith_miller>
👍🏼

[11:13:11.0000] <ljharb>
keith_miller: right but i'm saying that virtually the whole ecosystem does check the type when doing deep comparison at this point

[11:13:21.0000] <ljharb>
keith_miller: which means that many would find it confusing for JS not to do that

[11:14:47.0000] <keith_miller>
ljharb: The only way you'd see a distinction is if you create a record that looks exactly like a tuple

[11:15:47.0000] <keith_miller>
So, it's not even really a thing that's going to come up

[11:17:02.0000] <ljharb>
it comes up with arrays and objects.

[11:18:08.0000] <keith_miller>
So does equality not look at the prototype chain?

[11:18:20.0000] <rickbutton>
equality of what?

[11:18:30.0000] <ljharb>
keith_miller: normal JS equality does not, no

[11:18:38.0000] <keith_miller>
rickbutton: ljharb's isEqual function

[11:18:43.0000] <ljharb>
keith_miller: ecosystem deepEqual methods compare the [[Prototype]]

[11:19:00.0000] <ljharb>
iow `{ __proto__ A }` is not equal to `{ __proto__: B }`

[11:19:30.0000] <keith_miller>
Ok, so yeah, that makes sense because those are different types then.

[11:19:41.0000] <ljharb>
and so is `[]` and `{}`

[11:24:55.0000] <shu>
yikes

[11:24:59.0000] <shu>
robot

[11:25:01.0000] <ljharb>
jridgewell: you're a bit roboty

[11:25:03.0000] <bterlson>
droids

[11:25:09.0000] <ljharb>
jridgewell: ok you're better now

[11:25:15.0000] <leobalter>
daleks

[11:25:15.0000] <shu>
oh man that was jarring, the transition

[11:25:22.0000] <shu>
it was like watching the t-1000 heal

[11:25:29.0000] <robpalme>
sounded like a vocoder

[11:25:36.0000] <jorendorff>
`CustomArray.of` and `CustomArray.from` silently changing to not return a CustomArray seems almost mean

[11:25:41.0000] <bterlson>
any signals geeks know what happened there?

[11:26:03.0000] <ljharb>
jorendorff: only if there's a single person doing that tho, which i'm not sure is established :-p

[11:26:15.0000] <jorendorff>
true

[11:26:21.0000] <rickbutton>
bterlson: gremlins in the wires

[11:27:47.0000] <leobalter>
I want to take the opportunity of new types to fix a long time issue with === and NaN. I'd love for Records and Tuples to have a SameValueZero out of the box if I use ===

[11:28:50.0000] <rkirsling>
<3 "stepping up to take out the trash"

[11:31:33.0000] <jorendorff>
+1

[11:38:54.0000] <keith_miller>
rbuckton: Wait what were you saying? I zipped out for a second what's the problem with this.constructor?

[11:39:26.0000] <littledan>
I'm a very strong supporter of this proposal

[11:40:03.0000] <littledan>
(I think I added the species support in feross's buffer library...)

[11:40:19.0000] <keith_miller>
littledan: I heard you speaking about the this.constructor thing

[11:40:41.0000] <rbuckton>
This:

[11:40:41.0000] <rbuckton>
```

[11:40:41.0000] <rbuckton>
class MyArray extends Array {

[11:40:41.0000] <rbuckton>
  constructor(options, items) {

[11:40:41.0000] <rbuckton>
    super(...items);

[11:40:42.0000] <rbuckton>
    this.options = options;

[11:40:42.0000] <rbuckton>
  }

[11:40:43.0000] <rbuckton>
}

[11:40:43.0000] <rbuckton>
```

[11:40:44.0000] <rbuckton>
If we use `this.constructor` for `map`, calling `map` on a `MyArray` results in garbage.

[11:40:51.0000] <littledan>
https://github.com/feross/buffer/pull/97

[11:40:59.0000] <littledan>
is this what people are referring to as the only correct usage of species?

[11:41:26.0000] <littledan>
yeah, that problem came up in the buffer library, and was actually a sort of web compat issue for ES6

[11:41:33.0000] <bradleymeck>
littledan: it is the only one that doesn't do things like accidentally stop subclasses from working

[11:41:52.0000] <bradleymeck>
i'm sure there are *some* examples of using it properly elsewhere

[11:42:05.0000] <bradleymeck>
but not on sites i've crawled/code searches

[11:42:08.0000] <rbuckton>
With species I can do something like:

[11:42:09.0000] <rbuckton>
```

[11:42:09.0000] <rbuckton>
class MyArray extends Array {

[11:42:09.0000] <rbuckton>
  ...

[11:42:09.0000] <rbuckton>
}

[11:42:09.0000] <rbuckton>
MyArray[Symbol.species] = function(...args) { return new MyArray({}, ...args); };

[11:42:09.0000] <rbuckton>
```

[11:42:24.0000] <bradleymeck>
which makes me question if actually setting it is too complex

[11:42:31.0000] <rkirsling>
wait I thought 2-without-3 was on the table

[11:42:35.0000] <rbuckton>
If we use `this.constructor`, I have to override `map` hack around the use of `this.constructor`.

[11:42:47.0000] <bradleymeck>
rwaldron: if you have examples of cross realm apps/libs/sites/etc. I'd appreciate since writing cross context hooks is a bit involved

[11:42:54.0000] <rkirsling>
(er "remove 3 without removing 2")

[11:43:34.0000] <ljharb>
rbuckton: `constructor() { super(); this.constructor = custom; }`?

[11:43:50.0000] <michaelficarra>
yeah rkirsling that's not what the slides said

[11:44:21.0000] <shu>
rkirsling: oh, not via .constructor

[11:44:33.0000] <shu>
maybe there's a better way but i don't have any ideas

[11:44:37.0000] <shu>
i think there was indeed miscommunication here

[11:44:46.0000] <rkirsling>
oops

[11:48:42.0000] <rkirsling>
yay

[11:48:47.0000] <rwaldron>
bradleymeck It's not really something that's well advertised about apps

[11:48:56.0000] <rwaldron>
or libraries, or whatever

[11:48:58.0000] <ljharb>
mpcsh: on it

[11:49:01.0000] <bradleymeck>
yea, so not easy for me to find :-/

[11:49:11.0000] <keith_miller>
Bakkot: RE the branch on pageload, there's so much other stuff that's in builtin functions that normal user code would never do already

[11:49:40.0000] <shu>
i think folks are overfocusing a bit on it being "an unnecessary branch"

[11:50:05.0000] <shu>
it propagates to a lot more complexity in V8 and SM than just a single branch, though that's what it is in the spec text

[11:50:08.0000] <keith_miller>
i.e. you'd get better perf by rewriting all the iterator methods anyway

[11:50:12.0000] <keith_miller>
err

[11:50:15.0000] <bradleymeck>
rwaldron: right now the crawler just replaces every method that calls [@@species] with a devtools debugger trap. in theory it should catch cross realm stuff, but idk if any of our listed sites do that

[11:50:22.0000] <devsnek>
i'm a big fan of async context

[11:50:27.0000] <keith_miller>
prototype

[11:50:39.0000] <rwaldron>
What is the current preferred way of adding things to the notes that we didn't get to?

[11:50:52.0000] <msaboff>
So is the "restrict subclassing support" the first stage 1 or greater proposal to remove normative behavior?

[11:51:23.0000] <rwaldron>
msaboff nope, I think I get that award: renaming Atomics.wake to Atomics.notify

[11:51:32.0000] <rwaldron>
That was in a published spec

[11:51:47.0000] <keith_miller>
shu: How do V8/SM do their fast path check?

[11:51:57.0000] <rwaldron>
ᕦ(ò_óˇ)

[11:52:26.0000] <rickbutton>
rwaldron: like additional queue items?

[11:52:27.0000] <rbuckton>
Yay, async call contexts. I've wanted this for awhile. Kind of like `Threading.AsyncLocal` in .NET.

[11:52:43.0000] <rickbutton>
(that didn't make it)

[11:52:52.0000] <jridgewell>
bradleymeck: Are you using `Object.defineProperty` for that?

[11:53:02.0000] <shu>
keith_miller: there're two ways: 1) manual fast/slow path dispatch in the built-in implementation

[11:53:07.0000] <jridgewell>
The `@@species` props are all no-set getters

[11:53:10.0000] <msaboff>
rwaldron =: Okay.  But we knew that wasn't web breaking because the feature was turned off (and still is).

[11:53:10.0000] <bradleymeck>
jridgewell: no, just replacing the primordial method with a diff function

[11:53:15.0000] <shu>
keith_miller: 2) a monotonic "protector bit" that gets flipped if the page does something that results in a bad time, i think as you call it

[11:53:36.0000] <ystartsev>
do i get an award for having my first championed proposal be to remove normative behavior instead of add?

[11:53:43.0000] <bradleymeck>
jridgewell: basically we are trapping [].map not [][@@species]

[11:53:46.0000] <shu>
keith_miller: it's much worse for regexp than Array#map

[11:53:47.0000] <rickbutton>
you certainly should ystartsev

[11:54:13.0000] <shu>
keith_miller: okay, so to dequeue my question earlier

[11:54:16.0000] <rkirsling>
I removed early ref error 🤔

[11:54:23.0000] <rkirsling>
but it was a normative PR lol

[11:54:29.0000] <rbuckton>
I think the Queue is still on a topic from the last agenda item?

[11:54:41.0000] <shu>
keith_miller: help me understand the escape analysis issue, more in detail?

[11:54:50.0000] <robpalme>
you should get 10x more tc39 points for deleting lines from the spec vs adding them

[11:54:51.0000] <shu>
keith_miller: what allocations would it elide if the optimization applies?

[11:54:51.0000] <bradleymeck>
jridgewell: slightly old but same idea in https://gist.github.com/bmeck/5f195c4ae08009db4f3eefdc8bb360c9

[11:55:00.0000] <bradleymeck>
we have a lot more coreJS detection stuff now :-/

[11:55:06.0000] <rwaldron>
rickbutton yeah, I was in the queue

[11:55:17.0000] <keith_miller>
shu: Yeah, I think we mostly use the our equivalent of bit method.

[11:55:20.0000] <rwaldron>
There's a pretty important point that I need to add to the notes

[11:55:23.0000] <keith_miller>
But I haven't looked in a while

[11:55:29.0000] <rickbutton>
rwaldron: we usually just append them to the end of the notes for the section

[11:55:35.0000] <rickbutton>
:%s/section/proposal section/g

[11:55:37.0000] <rwaldron>
I think it changes our understanding of what would be affected by @@species removal

[11:55:49.0000] <rwaldron>
Because it's not @@species being used directly

[11:56:00.0000] <rickbutton>
with like a header of "remaining queue items" or something

[11:56:04.0000] <rkirsling>
robpalme: we should add that to how-we-work

[11:56:05.0000] <shu>
rwaldron: what's the point?

[11:56:29.0000] <shu>
rwaldron: the proposed semantics is that the built-ins create an instance of the built-in in the current realm

[11:56:39.0000] <ljharb>
mpcsh: rickbutton tell me where to add my skipped queue item for that one btw

[11:56:43.0000] <rwaldron>
shu you shook something loose when you mentioned looking through old code (or something like that)

[11:57:05.0000] <shu>
what does that mean? :)

[11:57:10.0000] <rwaldron>
I'm getting to it

[11:57:16.0000] <keith_miller>
shu: So in most languages that have simple updates to immutable things they are either refcounted (so refCount == 1 means mutate in place) or they heavily rely on an escape analysis to prove that the tuple doesn't leave the function so you don't need to allocate it at all

[11:57:22.0000] <rwaldron>
I need to check something

[11:57:25.0000] <rwaldron>
No, I can do that later

[11:57:39.0000] <rickbutton>
ljharb just put it after the conclusion in the "restrict subclassing support" section

[11:57:39.0000] <rwaldron>
If we remove @@species, I believe we will break every site that ever used Zepto

[11:57:42.0000] <keith_miller>
actually you need the escape for the ref count thing anyway

[11:58:11.0000] <shu>
rwaldron: fascinating, would love to dig in

[11:58:23.0000] <keith_miller>
But you can't really do that optimization in JS without a lot of speculation due to getters

[11:58:34.0000] <rwaldron>
shu https://github.com/tc39/notes/blob/master/meetings/2014-11/nov-18.md#46-zepto-broken-by-new-thisconstruct-usage-in-some-arrayprototype-methods

[11:58:54.0000] <shu>
keith_miller: ah, that's a general concern about records/tuples, not a specific one about the deep path properties?

[11:59:20.0000] <keith_miller>
shu: Yeah, true but deep path properties make it much more ergonomic.

[11:59:23.0000] <ljharb>
rwaldron: that's if we remove species *and* use constructor?

[11:59:57.0000] <keith_miller>
And I don't think people realize that it's going to be very expensive

[12:00:12.0000] <shu>
keith_miller: ah, i see. kinda a moral hazard argument that they might think records and tuples are cheaper than object literals

[12:00:15.0000] <shu>
when they are in fact worse

[12:01:01.0000] <keith_miller>
shu: If deep path mutation is in a userland library they 1 need to find it and 2 probably have different expectations on its performance

[12:01:28.0000] <shu>
rwaldron: good find, though my read is of that is how @@species broke ES5-era behavior (the "old semantics" we're proposing), and removing @@species and constructor delegation altogether gets us back to ES5-era behavior, and would be compatible

[12:01:42.0000] <rickbutton>
keith_miller: these are valid arguments, can you list your performance considerations in the issue tracker?

[12:01:51.0000] <shu>
that's a big part of the intuition that this change IS compatible fwiw, because it was what it was in es5 and we broke it for a bit and worked around with @@species

[12:01:55.0000] <keith_miller>
rickbutton: sure

[12:01:58.0000] <rickbutton>
thank you :)

[12:02:03.0000] <shu>
keith_miller: and to make sure i understand some more...

[12:02:14.0000] <shu>
keith_miller: the worst case here for tuples is _as many allocations_ as mutable objects

[12:02:21.0000] <shu>
not somehow inherently worse than mutable objects?

[12:03:02.0000] <shu>
i guess this is also a question for wsdferdksl

[12:03:08.0000] <shu>
i still don't fully understand his concern

[12:03:15.0000] <keith_miller>
shu: I'm not sure I understand your concern

[12:03:23.0000] <shu>
i have no concern yet

[12:03:24.0000] <keith_miller>
err clarification

[12:03:49.0000] <shu>
keith_miller: like, suppose we definitely cannot do any smart optimizations

[12:04:18.0000] <keith_miller>
It's just that when I do `foo.bar.baz = 1` on an object it doesn't do an allocation people don't think about the fact that the immutable thing will do allocations

[12:04:26.0000] <shu>
what will be the performance characteristic of records be? wouldn't it be the same as using mutable objects as if they were immutable??

[12:04:36.0000] <shu>
ah, i see, ok

[12:04:38.0000] <keith_miller>
Oh, I see what you're saying

[12:04:41.0000] <keith_miller>
yeah, it's the same

[12:04:54.0000] <shu>
didn't mean 2 question marks

[12:05:00.0000] <shu>
still working trigraphs out of my system

[12:05:21.0000] <keith_miller>
But it's just much harder to work with so people are unlikely to do it.

[12:05:35.0000] <shu>
right, i get your concern now

[12:05:49.0000] <keith_miller>
I'd just be sad if we add this feature then every linter in the world say "DON'T DO IT FOR PERF!!!!11!!"

[12:06:10.0000] <keith_miller>
it's gonna ruin your page load time

[12:06:26.0000] <keith_miller>
maybe that won't happen though...

[12:06:35.0000] <keith_miller>
It's more just something I'd like to consider

[12:07:25.0000] <jridgewell>
> `foo.bar.baz = 1`

[12:07:25.0000] <jridgewell>
Isn't it clear from `{ ...record, x: 1 }`'s syntax that it will be doing a clone?

[12:07:27.0000] <rickbutton>
I would also be sad if that is the case. I think it would be useful to find some examples of cases where this kind of thing is already happening, during the prez redux got mentioned, where deeply-nested "many allocations" with regular objects are common/expected.

[12:08:22.0000] <shu>
jridgewell: you'd think, but we were just talking yesterday about IIFEs being a suitable replacement for a do-block, despite the extra allocations

[12:18:10.0000] <rwaldron>
shu you may indeed be right, but I just want to make sure we don't miss any of the historic context

[12:22:03.0000] <shu>
rwaldron: +100

[12:22:05.0000] <devsnek>
shu: fwiw people who use products like datadog and sentry tracing and stuff all opt into the perf hit and seem fine with it

[12:22:34.0000] <devsnek>
(i still think these should be disabled by default)

[12:22:53.0000] <shu>
devsnek: sure, the point is we want it to be opt in

[12:23:07.0000] <shu>
devsnek: but last time the feedback was we don't know how to make the performance characteristic to be opt in

[12:23:45.0000] <devsnek>
got it, understand you now

[12:23:55.0000] <rwaldron>
mmarchini I think you just gave me a flash back to Domains

[12:24:07.0000] <mmarchini>
lol

[12:24:11.0000] <mmarchini>
sorry

[12:24:17.0000] <devsnek>
"flash back" i wish domains were in my past

[12:24:18.0000] <rwaldron>
That was the Zones issue, IIRC

[12:24:21.0000] <rwaldron>
right?

[12:24:22.0000] <bradleymeck>
rwaldron: zones were a 21 line wrapper around domains

[12:24:27.0000] <rwaldron>
Yep ^^^

[12:24:31.0000] <bradleymeck>
/me wiggles eyebrows

[12:24:39.0000] <rwaldron>
hahahahaha

[12:24:41.0000] <mmarchini>
LOL

[12:24:41.0000] <devsnek>
zones are a small wrapper around async hooks as well

[12:26:51.0000] <rwaldron>
This proposal makes me want to revive my "async blocks" syntax proposal

[12:27:00.0000] <rwaldron>
(I can't tell if I'm serious yet)

[12:27:08.0000] <jridgewell>
Async blocks?

[12:27:13.0000] <rwaldron>
yeah dog

[12:27:27.0000] <Bakkot>
rwaldron I mentioned `async do {}` in my do-exprs proposal

[12:27:37.0000] <rwaldron>
I knooooooowwwww

[12:27:39.0000] <shu>
i miss when people said dog

[12:27:40.0000] <rwaldron>
;)

[12:28:06.0000] <rwaldron>
Bakkot I was *thrilled*

[12:28:22.0000] <devsnek>
tracking the causality of async tasks bro

[12:29:53.0000] <rwaldron>
Gus, don't you mean "tracking the causality of async tasks dog"

[12:30:13.0000] <rkirsling>
not dawg though?

[12:30:18.0000] <rwaldron>
That works as well

[12:30:23.0000] <rwaldron>
Interchangeable

[12:31:51.0000] <rwaldron>
Bakkot jridgewell my old timey proposal was basically something that I came up with when Luke Hoban first started working on async functions

[12:32:19.0000] <ystartsev>
akirose: regarding announcments, would tomorrow morning work?

[12:36:54.0000] <leobalter>
robpalme I have to pause for another meeting, I won't be able to catch the Intl Enumeration discussion. Please let me know if anything else will be discussed today, if you have time to do it, of course :)

[12:37:09.0000] <devsnek>
i'm so confused about the stage 1 block

[12:37:29.0000] <rwaldron>
devsnek I've been confused by Stage 1 since forever

[12:37:31.0000] <devsnek>
isn't people agreeing this is a problem the exact stage 1

[12:37:35.0000] <devsnek>
requirement

[12:37:36.0000] <robpalme>
we have nothing else scheduled. this will take us to 6 minutes beyond the scheduled end.

[12:37:50.0000] <ljharb>
devsnek: stage 1 also means, we want to talk about it more in committee

[12:37:56.0000] <devsnek>
right

[12:38:04.0000] <ljharb>
devsnek: to me it sounds like the blocks mean "we are currently convinced there's nothing further to discuss"

[12:39:08.0000] <ryzokuken>
right, I always thought of a stage 1 block as "this is a non-starter. we don't even think this warrants attention."

[12:39:10.0000] <devsnek>
i don't think stage 1 requires exhaustively proving no solution will be found

[12:39:24.0000] <michaelficarra>
is there a reason we're skipping Intl.Segmenter for stage 3?

[12:39:39.0000] <michaelficarra>
we're not going to get to it today and it's not on the schedule for tomorrow

[12:39:42.0000] <ljharb>
devsnek: it generally requires convincing everyone that a solution *could* be found

[12:39:58.0000] <ljharb>
michaelficarra: it was added late, so it'd be done last

[12:40:09.0000] <michaelficarra>
since when?

[12:40:30.0000] <michaelficarra>
we do agenda items in order (modulo timing constraints)

[12:40:36.0000] <ljharb>
that's true

[12:40:38.0000] <ljharb>
i'm not really sure

[12:40:49.0000] <ljharb>
it came up on monday and the chairs suggested it going later

[12:40:54.0000] <michaelficarra>
being added late only changes whether we think it's justifiable to reject based on timing alone

[12:40:59.0000] <ljharb>
agreed

[12:41:08.0000] <michaelficarra>
oh it was added after we agreed to the agenda?

[12:41:20.0000] <rbuckton>
michaelficarra: are you looking at the draft schedule or TCQ?

[12:41:26.0000] <ljharb>
michaelficarra: no https://github.com/tc39/agendas/commit/ec18f27dce69959586ad5f205bfb00b690201d26#diff-3441294351e2ad1cc9682d5d1eafb082

[12:41:43.0000] <rbuckton>
In the draft schedule Intl.Segmenter is listed as Overflow

[12:41:56.0000] <michaelficarra>
oh then we should definitely prioritise it ahead of stage 0 things

[12:42:08.0000] <ljharb>
but michaelficarra is right; being added late is not supposed to mean they get bumped to the end

[12:42:12.0000] <ljharb>
akirose et al? ^

[12:42:33.0000] <rickbutton>
it's on the draft agenda twice, once under overflow, once under "items added after deadline"

[12:42:48.0000] <keith_miller>
I could see an argument for bumping it FWIW, not that I care that much one way or the other

[12:42:49.0000] <ystartsev>
michaelficarra: i think this was a response to how packed the agenda and there was a question asked to the room if things that missed the deadline should be deprioritized, and the answer was yes

[12:43:35.0000] <ystartsev>
since it was added late, this is grounds for not allowing it to move forward due to a technicality, and it might not be a good use of time

[12:45:29.0000] <michaelficarra>
we could ask if anyone feels it should be skipped for this reason before starting, but I don't think it's appropriate to assume that it would not be a good use of our time

[12:45:59.0000] <sffc>
I would like Intl.Segmenter to be prioritized if possible

[12:46:04.0000] <sffc>
Chrome is getting ready to ship it

[12:46:13.0000] <sffc>
But it would be awkward to ship a Stage 2 proposal

[12:46:31.0000] <sffc>
It's been ready for Stage 3 for a few months, but it just never got added to the agenda

[12:46:49.0000] <rickbutton>
will it truly take 30 minutes? could consider slipping it in as a smaller timeslot

[12:46:57.0000] <ystartsev>
could it be shorter?

[12:47:06.0000] <ystartsev>
it already got the ok from zibi so we are fine with it

[12:47:17.0000] <ystartsev>
the problem is it was added to the agenda after the deadline, so the team didn't review it

[12:47:23.0000] <ystartsev>
and i don't want that to become acceptable practice.

[12:47:34.0000] <sffc>
We could timebox it for 10-15 minutes, and attempt for Stage 2

[12:47:40.0000] <ystartsev>
that deadline for advancement is really important

[12:48:01.0000] <sffc>
I agree about the deadline being important

[12:48:12.0000] <sffc>
attempt for *Stage 3*

[12:48:46.0000] <ystartsev>
chrome is preparing to ship it, that is a little strange for stage 2 no?

[12:49:19.0000] <sffc>
I mean, it's implemented, but I think Frank won't flip the bit until it gets to Stage 3 at TC39

[12:50:06.0000] <ystartsev>
i have to say i am not comfortable with having something shoe horned in. we are lucky that zibi had been working on this so much so we are already invested

[12:50:09.0000] <ystartsev>
that isn't true for all delegates

[12:50:29.0000] <ystartsev>
just because something is ready for stage 3 for a long time doesn't necessarily mean people have checked it for review

[12:50:38.0000] <michaelficarra>
ystartsev: if that is the case, you are completely justified in rejecting advancement

[12:50:41.0000] <ystartsev>
that said, overall, we don't have an issue

[12:50:56.0000] <michaelficarra>
I don't want you to feel pressured

[12:51:21.0000] <rkirsling>
I agree the principle may be more important here, even if the thing is totally uncontroversial

[12:51:50.0000] <rkirsling>
(i.e. I'd actually like to see it advance now rather than later but I'd prioritize the principle)

[12:53:03.0000] <ljharb>
there's plenty of things we discuss that aren't up for advancement

[12:53:14.0000] <ystartsev>
yeah ... it was added on thursday last week which only gives 1 full day for review

[12:53:17.0000] <ljharb>
even if advancement is off the table due to not enough review time, discussing the item could still be valuable

[12:53:47.0000] <ystartsev>
we could discuss it, but would that be a good use of time if it doesn't advance?

[12:53:58.0000] <Bakkot>
fwiw I am totally on board with the chairs making that kind of call

[12:54:03.0000] <ystartsev>
same

[12:54:09.0000] <ljharb>
that's really up to the champions i'd think? as i said above, tons of things are worth the time even when they don't request advancement.

[12:54:24.0000] <ljharb>
if advancement is the main criteria, then we shouldn't have any items that aren't advancement requests

[12:54:47.0000] <ljharb>
i think it's appropriate to leave it up to the chairs when it means the difference between completing the agenda or not

[12:55:06.0000] <ljharb>
but the intention when adding that deadline was to not obstruct people's ability to add discussions even at the last minute

[12:55:33.0000] <Bakkot>
I'd support changing the agenda rules to say that anything added after the advancement deadline is deprioritized even if it isn't looking to advance, absent some particular reason it is time-sensitive

[12:55:35.0000] <ljharb>
iow, it's not to prevent the need for someone to block based on the deadline; it's to make that blocking low-cost

[12:55:50.0000] <Bakkot>
we also review the agenda after the deadline to make sure we know what we think about all of the topics on the agenda

[12:55:53.0000] <jridgewell>
wsdferdksl: https://github.com/bslassey/privacy-budget

[12:55:55.0000] <ljharb>
Bakkot: if we got consensus on that (like we did on the original deadline) then that seems fine to me too

[12:55:56.0000] <Bakkot>
and we don't have that for things added after the deadline

[12:56:21.0000] <ystartsev>
we do the same as bakkot

[12:56:57.0000] <ljharb>
understood, and while review's always helpful, and for some is critical to permit advancement, that doesn't mean that lack of review should block the discussion

[12:57:08.0000] <ljharb>
stage 1-seeking proposals don't even have to provide materials

[12:57:20.0000] <rkirsling>
but they should >_<

[12:57:25.0000] <Bakkot>
ljharb ehhhhhhhhh

[12:57:31.0000] <rkirsling>
did we not finish that discussion?

[12:57:32.0000] <Bakkot>
I think it should deprioritize the discussion

[12:57:34.0000] <ljharb>
sure. and "should", but not "must", was an explicitly chosen difference.

[12:57:34.0000] <ystartsev>
they do now? they require a proposal

[12:57:34.0000] <rkirsling>
there was a thread

[12:57:49.0000] <littledan>
I think browser TC39 representatives have been monitoring browser fingerprinting concerns; at least that's been the case in ECMA-402

[12:57:54.0000] <rkirsling>
yeah I know we had a full PR...

[12:57:56.0000] <ljharb>
ystartsev: yes we changed it recently to "Such proposals must link to a proposal repository and they should link to supporting materials when possible."

[12:57:59.0000] <ljharb>
but i don't have to have anything in the repo

[12:58:05.0000] <rkirsling>
https://github.com/tc39/process-document/pull/26

[12:58:24.0000] <ystartsev>
ok but we are getting into a digression

[12:58:24.0000] <michaelficarra>
Bakkot: I would prefer we continue to prioritise by stage, regardless of when the item was added or whether it is looking for advancement, so that we continue to make progress on reducing our in-progress work

[12:58:24.0000] <ljharb>
ah true, that requires the repo "capture the above requirements"

[12:58:49.0000] <ljharb>
sorry for the digression

[12:58:54.0000] <Bakkot>
michaelficarra except it is difficult to make progress on things when there isn't time for people to review htem

[12:59:12.0000] <ljharb>
sometimes difficult. and not impossible.

[12:59:18.0000] <ljharb>
and that seems like something the champions should be able to judge?

[12:59:23.0000] <michaelficarra>
maybe not as productive as they could have been, but I doubt the champion would bring it forward if they didn't think it could be useful

[13:21:22.0000] <bradleymeck>
hallway track definitely keeps cutting off audio, anyone else seeing that

[13:22:08.0000] <rickbutton>
not happening for me

[13:42:52.0000] <rkirsling>
oof, so much for 26 C; it's now 33

[14:32:01.0000] <shu>
ljharb: i confirmed internally with some folks that the 'type' attribute should suffice for the web use cases currently

[14:32:28.0000] <ljharb>
shu: awesome, great to hear!

[14:32:47.0000] <shu>
ljharb: (of course, the formulation where it's up to the host to process the value)

[14:32:52.0000] <shu>
the value of the 'type' key

[14:32:55.0000] <ljharb>
yes, agreed

[14:35:34.0000] <shu>
while we disagree on the signals that ecma262 do or should send, i believe we understand each other, and i'm more than happy to move forward with the check-style only restriction

[14:41:14.0000] <bradleymeck>
i did realize i have one evaluator i want somewhat badly, `wrapToAvoidThenable=true`

[14:42:55.0000] <ljharb>
bradleymeck: that seems like it only applies to dynamic import, and would be the same Module object, it just would wrap it in a container. not just a "check" to be sure, but i'm not sure that qualifies as an evaluator either

[14:43:24.0000] <bradleymeck>
import.wrapped() would be fine to me

[14:53:21.0000] <shu>
big oof @ thenables

[14:54:15.0000] <gibson042>
ystartsev: the spec hasn't changed since team review from last time when the Mozilla objection was withdrawn

[14:55:12.0000] <gibson042>
but I realized that Intl.Segmenter stage 3 official review #2 is still pending and so advancement will/would be conditional upon that anyway. But there is an important issue to discuss that stretches beyond this specific proposal and should be discussed if there's time: https://docs.google.com/presentation/d/1Pe9eVhgK93cgB3KCufTQvzqCjIYj3RRxJaOeNIbWN_A/edit#slide=id.g87b4869bad_0_0

[14:56:56.0000] <gibson042>
I'm willing to defer because I did miss the deadline, but fwiw the requirement is "must be added (and noted as such) *along with the necessary materials* prior to the deadline", and every meeting there are always tons of slides and spec text slipping in to an otherwise empty placeholder slot after the deadline

[16:51:49.0000] <rkirsling>
wow, it could've been called @@copyConstructor, huh

[16:52:18.0000] <rkirsling>
that would've been way less "I have zero idea what this word will be used to mean"-inducing than @@species :p


2020-06-04
[18:10:05.0000] <rkirsling>
given that Temporal seems almost similar to 402 in size, I think it would be an excellent way to ease into having a multifile 262

[18:25:26.0000] <rkirsling>
(I could rewrite that as an issue on the repo, I suppose)

[00:42:46.0000] <ystartsev>
gibson042: mozilla doesn't have any remaining concerns, as i mentioned earlier

[00:43:27.0000] <ystartsev>
also, we have objected to stage advancement for proposals that did not have stage appropriate materials present such as spec text

[00:43:53.0000] <ystartsev>
the deadline represents the point at which I finish my collection and summarization of materials for the spidermonkey team, and we begin the process of review

[00:44:40.0000] <ystartsev>
If we do not have a chance to review, then we can't approriately evaluate a proposal for stage advancement. for lower stage proposals such as stage 1, a detailed review is not required, we are usually just happy to listen

[00:44:52.0000] <ystartsev>
however for other stages, review is necessary

[00:45:26.0000] <ystartsev>
in this case, we were following Intl.segmenter closely, we are aware of what is being advanced, however not all members have been and many likely have a similar process as us

[00:45:34.0000] <ystartsev>
and for this reason, i raised the importance of the deadline.

[00:47:36.0000] <ystartsev>
I didn't make the decision of prioritization, that is with the chairs, but i support whatever they will choose, as the schedule is particularily challenging this time

[00:55:21.0000] <ystartsev>
I imagine this is very frustrating for you, and it is unfortunate since Intl.Segmenter has gone through a long and difficult process to get to where it is. However, this is the second time this year that we are looking a proposal you are trying to advance that can, and arguably should be blocked on process grounds. Submitting a proposal for advancement to stage 3 with only one working day until the committee

[00:55:21.0000] <ystartsev>
member is far too little notice. Would it be helpful for you to review the process document and agenda structure? I would like to see this situation avoided in the future, since it is disappointing to have to say something like this about a proposal that is otherwise in good state.

[01:02:28.0000] <ystartsev>
(that is, bar the missing review)

[02:50:07.0000] <ystartsev>
I may have been a bit too direct here, sorry about that. I am open for continuing the conversation though.

[05:06:32.0000] <littledan>
I want to second what Mozilla is saying about Intl.Segmenter. I want this proposal to advance, but these things should be put up with more notice so that everyone can review them.

[05:17:41.0000] <littledan>
I think it's more important to declare the advancement with a repository link ahead of the deadline than to have all the slide presentation ready by then (since, ultimately, the advancement is of the contents of the repository)

[07:53:40.0000] <gibson042>
I'm not disputing the above. The agenda matters, and I own my mistake in adding to it late, and that on its own is grounds for blocking advancement. But Intl.Segmenter was not the only or even the last entry to be added late, and that's even more true for the supporting materials requirement (which includes the slides, but more importantly also includes significant work in proposal repositories between the deadline and the m

[07:54:16.0000] <rkirsling>
bradleymeck: hmm... it's always smalltalk... :(

[07:54:25.0000] <gibson042>
As for how to ensure sufficient review time in the future (which I agree is the right perspective), I appreciate upcoming-meeting reminders but would *never* expect someone else to provide them. The root issue for me personally is that the rest of my professional life is very far removed from this space, with a compounding factor in this case of thinking "TC39 in June" when the relevant deadline was well ahead of that.

[07:55:06.0000] <gibson042>
There is something that would help, though: creating the next meeting's document by the start of the current meeting. This is the time when I'm most likely to be thinking about TC39-relevant content, and it would be really great to add agenda items in the moment rather than taking a note for future action.

[07:57:47.0000] <littledan>
that often happens, but I guess we don't have the July meeting agenda yet this time around

[08:01:23.0000] <ystartsev>
i am not really sure what to respond here. I have protested in the past if something was added to the agenda without the required materials, late. and it is clearly outlined in our agenda document that this is a likely outcome

[08:01:32.0000] <gibson042>
and to be clear, any frustration I feel is self-directed. I had hoped to move JSON.parse source text access forward, but didn't have time to work on it. I was able to Intl.Segmenter only because it was ready to go from before.

[08:02:33.0000] <gibson042>
I do not have ill feelings towards anyone about this, and ystartsev in particular has been a consistent voice of reason and fairness

[08:03:07.0000] <ystartsev>
gibson042: i am looking forward to giving this the green light very soon. i think the spec looks good

[08:05:34.0000] <bterlson>
leobalter: ready in 3 minutes?

[08:05:44.0000] <keith_miller>
jorendorff: Why have only one function for all iterator helpers? Seem bad for profiling

[08:05:53.0000] <leobalter>
@bterlson yes, Caridy will present

[08:05:58.0000] <leobalter>
he's ready too

[08:08:06.0000] <keith_miller>
jorendorff: Since you'll end up with a megamorphic function for each of the things your iterating

[08:08:50.0000] <keith_miller>
You really want to know that only one iterable type is going into each loop so you can inline the next functions it.

[08:08:59.0000] <keith_miller>
into it*

[08:09:15.0000] <jorendorff>
keith_miller: I don't think it'll end up being bad for profiling. It might be more work to optimize, since it's a new thing

[08:09:24.0000] <keith_miller>
This is a problem for all the TypedArray share functions too

[08:09:26.0000] <jorendorff>
the inlining is harder to do

[08:09:56.0000] <keith_miller>
You'd need to do some very sophisticated optimizations that AFAIK, no engine does

[08:10:17.0000] <ystartsev>
i have another request for time from the chairs akirose bterlson MylesBorins robpalme -> if there is time, Felienne and i have a 1 min announcement regarding the new research call

[08:10:18.0000] <keith_miller>
Since you're profiling well see the next call as a virtual call

[08:10:23.0000] <keith_miller>
will*

[08:10:51.0000] <keith_miller>
If you see 10 different iterators it's going to be 10 different call targets

[08:10:53.0000] <bterlson>
ystartsev: literally 1 minute?

[08:10:56.0000] <jorendorff>
keith_miller: It is up to the implementation to decide whether it's a virtual call or what. It could easily be part of the "hidden class" that is not visible to users

[08:11:08.0000] <jorendorff>
keith_miller: I say "easily", knowing nothing about how that's implemented in other engines

[08:11:11.0000] <ystartsev>
for anyone here, Felienne and I are opening out 1:1 research call to everyone, who might want to discuss data gathering and research methods, first one is June 25 at 17:45 CEST

[08:11:19.0000] <ystartsev>
bterlson: it is exactly that ^

[08:11:29.0000] <akirose>
quick PSA for everyone

[08:11:41.0000] <keith_miller>
jorendorff: You have 10 different hidden objects in coming into map each has a different next function

[08:11:41.0000] <jorendorff>
keith_miller: but if an implementation wants to make all of these objects distinct types, it certainly can.

[08:12:07.0000] <keith_miller>
How do you inline those nexts into map without map being inlined into every caller?

[08:12:08.0000] <jorendorff>
oh, you mean optimizing .map() itself, rather than .next()?

[08:12:12.0000] <akirose>
any time you have one of those moments where you're like "i need to request a little schedule change in the middle of the meeting and idk which chair to ping"

[08:12:14.0000] <keith_miller>
jorendorff: yeah

[08:12:23.0000] <jorendorff>
you have *many* different objects coming into .map(), it's a method on Iterator.prototype

[08:12:26.0000] <keith_miller>
I want to be able to trivially inline the next call into the map

[08:12:27.0000] <akirose>
any time you need to send a quick message to the chair group

[08:12:30.0000] <devsnek>
i just joined, did he say why import() is on realms?

[08:12:33.0000] <jorendorff>
could be called on anything

[08:12:38.0000] <akirose>
use `/notice #tc39-chairs your message here`

[08:12:48.0000] <keith_miller>
but that's exactly why I want it to be one per iterator helper prototype

[08:13:02.0000] <leobalter>
devsnek: we will have more examples over the import() in Realms and use cases

[08:14:03.0000] <jorendorff>
keith_miller: I want to make sure I understand. "inlining next into map" doesn't make sense to me because Iterator.prototype.map doesn't call any next method

[08:14:41.0000] <jorendorff>
But also I think you have a particular implementation in mind that does inlining but then can't specialize on what is inlined, forgive me, I don't know much about that stuff to begin with

[08:14:55.0000] <devsnek>
keith_miller: the next methods call into differing user code

[08:16:03.0000] <jorendorff>
keith_miller: but just to be clear, this is a performance problem caused by the extra level of indirection, right? and not a profiling problem exactly

[08:16:07.0000] <keith_miller>
It can't inline when calls are non-monomorphic because it's almost never profitable to do inlining there

[08:16:21.0000] <ljharb>
gibson042: i'll create the july agenda today

[08:16:23.0000] <devsnek>
they should have the same characteristics as optimizing Generator.prototype.next except you know a lot more about the body of the generator

[08:16:28.0000] <keith_miller>
It's a performance problem because inlining when monomorphic can be VERY profitable

[08:16:47.0000] <keith_miller>
So over sharing functions can hurt performance

[08:17:28.0000] <keith_miller>
jorendorff: To clarify this is to share map with Iterator.prototype and AsyncIterator.prototype on some shared prototyp?

[08:17:41.0000] <keith_miller>
maybe I misunderstood the slides

[08:18:05.0000] <jorendorff>
keith_miller: yeah, let's start over :)

[08:18:22.0000] <keith_miller>
haha ok

[08:18:30.0000] <jorendorff>
keith_miller: so, Iterator.prototype and AsyncIterator.prototype are totally separate prototype chains, we can set aside AsyncIterator

[08:18:33.0000] <keith_miller>
it's too early for me >.>

[08:18:46.0000] <jorendorff>
keith_miller: no, you're great, I'm glad you brought it up

[08:18:49.0000] <jorendorff>
they're different interfaces

[08:19:50.0000] <jorendorff>
so Iterator.prototype.map is inherently a generic method shared across all (sync) iterators.

[08:20:30.0000] <jorendorff>
AIUI Array.prototype.map already poses some issues for inlining strategy because the mapFn you pass to it will be different every time; the function call in there is megamorphic, unless you inline .map into its caller

[08:20:37.0000] <jorendorff>
and then it magically isn't

[08:21:18.0000] <jorendorff>
Iterator.prototype.map is like that, only much worse, because

[08:21:20.0000] <keith_miller>
jorendorff: The main difference is that for any given iterator the next will be the same consistently

[08:21:25.0000] <jorendorff>
1. it has the same problem with mapFn;

[08:21:31.0000] <jorendorff>
2. it *also* is going to be megamorphic in `this` which will be all different kinds of iterator

[08:21:47.0000] <jorendorff>
each with a different next method, layout etc.

[08:21:57.0000] <keith_miller>
I mean I can imagine things that change their next but... that seems rare

[08:22:14.0000] <jorendorff>
no, there are already a dozen next methods in the spec

[08:22:23.0000] <jorendorff>
many iterator types

[08:22:35.0000] <jorendorff>
but we're not done yet

[08:23:03.0000] <jorendorff>
3. Array.prototype.map() at least gets to do all its work at once. Iterator.prototype.map() has to return an iterator. The JIT doesn't necessarily get to see how/where that iterator is used

[08:23:04.0000] <keith_miller>
I get that, I'm saying that each prototype that has a next could also have a map.

[08:23:20.0000] <keith_miller>
That's a bit grosser because user iterators don't have access to a map

[08:24:09.0000] <keith_miller>
Otherwise users will be better off, for each iterator adding their own map function, since they'll likely get better performance

[08:24:52.0000] <keith_miller>
i.e. put a new map onto each ArrayIterator.prototype MapIterator.prototype, etc

[08:26:47.0000] <jorendorff>
there are about 12 iterator helper methods

[08:27:03.0000] <keith_miller>
FWIW, I've given this advice to people using typed arrays that had perf problems

[08:27:13.0000] <jorendorff>
makes sense

[08:27:15.0000] <keith_miller>
IIRC, they got a 2-4x improvement

[08:27:22.0000] <jorendorff>
just working in pure JS?

[08:27:29.0000] <keith_miller>
Yeah

[08:27:40.0000] <keith_miller>
I mean they can also skip a bunch of checks

[08:27:42.0000] <ljharb>
keith_miller: i mean, should the spec add a .map for each TypedArray type?

[08:27:57.0000] <ljharb>
if that's inherently more performant?

[08:28:00.0000] <keith_miller>
ljharb: It used to!

[08:28:05.0000] <keith_miller>
then ES6 changed it lol

[08:28:08.0000] <Bakkot>
that one seems like not an obviously bad idea, tbh

[08:28:34.0000] <ljharb>
i mean like, philosophically imo the current way it's done is better, with a single method

[08:28:34.0000] <Bakkot>
but the iterator helpers seem more obviously like shared things, to me

[08:29:19.0000] <ljharb>
but if there's a significant perf improvement from not sharing the methods, and it's not likely to ever be overcome, then we should be encouraging non=-sharing of megamorphic things as a pattern (which, coincidentally, is what the "remove species" proposal will force for subclasses)

[08:29:47.0000] <devsnek>
an iterator is free to specialize the implementation of something on the prototype

[08:30:42.0000] <devsnek>
for example if your iterator is over a collection type, the map can walk directly over that instead of indirecting through the collection iterator

[08:30:44.0000] <keith_miller>
Sorry, 🐈 had a panic attack that I was up but didn't feed them

[08:31:00.0000] <jorendorff>
no worries

[08:31:38.0000] <keith_miller>
Yeah, we could move back to pre-ES6 behavior

[08:31:44.0000] <keith_miller>
I'm not opposed to that

[08:31:46.0000] <devsnek>
did leo say why import is directly on realms instead of compartments

[08:32:19.0000] <devsnek>
i got distracted by iterator stuff

[08:32:19.0000] <keith_miller>
devsnek: The hard part is when is it profitable to decide to do that, which requires profiling, which has costs

[08:32:35.0000] <devsnek>
keith_miller: oh i meant a human can do that

[08:33:13.0000] <bradleymeck>
devsnek: it's going to be on a realm which has a root/host provided behavior, compartment would have a more granular/user provided behavior. so both would be having a import mechanism

[08:33:27.0000] <ystartsev>
does metamorphic mean this? https://en.wikipedia.org/wiki/Inline_caching#Megamorphic_inline_caching

[08:33:43.0000] <ystartsev>
s\meta\mega

[08:33:46.0000] <devsnek>
bradleymeck: doesn't a compartment with no hook defer to the host?

[08:33:58.0000] <devsnek>
ystartsev: yeah

[08:34:00.0000] <keith_miller>
devsnek: In the engine? That would still be hard because you'd need to teach executables that they can have different ones base on the this value

[08:34:03.0000] <bradleymeck>
for import, it should defer to its realm

[08:34:15.0000] <keith_miller>
it's not impossible but it's far far from simple

[08:34:31.0000] <devsnek>
keith_miller: no i meant like, if you're writing a hashmap class in js, you can bring your own iterator forEach impl

[08:34:57.0000] <gibson042>
does anyone have a link to the slides that Caridy is presenting?

[08:34:58.0000] <keith_miller>
Oh, yeah, that's the recommendation I've given to devs when they find these methods hot

[08:35:04.0000] <keith_miller>
are hot*

[08:35:22.0000] <leobalter>
gibson042: https://docs.google.com/presentation/d/1TfVtfolisUrxAPflzm8wIhBBv_7ij3KLeqkfpdvpFiQ/edit?ts=5ed5d3e7

[08:35:23.0000] <keith_miller>
devsnek: but I'd be good for that to be "free"

[08:35:33.0000] <gibson042>
thank you

[08:35:44.0000] <devsnek>
bradleymeck: the realm is the host, cuz the realm can't hook anything

[08:36:07.0000] <bradleymeck>
realm inside a compartment is hooked

[08:36:16.0000] <keith_miller>
jorendorff: shu: Does SM/V8 do inlining?

[08:36:19.0000] <leobalter>
devsnek bradleymeck I can't focus in answering here but if you could bring it to the queue...

[08:36:32.0000] <keith_miller>
I don't actually know. I assume yes

[08:36:49.0000] <devsnek>
v8 has inlining

[08:37:02.0000] <devsnek>
i won't go so far as to say what makes something eligible for it

[08:37:35.0000] <shu>
keith_miller: in the optimized tier, yes

[08:37:35.0000] <keith_miller>
devsnek: I mean JSC's heuristic is basically just bytecode size...

[08:37:56.0000] <shu>
keith_miller: both user code and manually written inlines for recognized builtins

[08:37:58.0000] <keith_miller>
which is a surprisingly good heuristic

[08:38:41.0000] <devsnek>
all i know about v8's inlining is that the compiler doesn't account for the scope changing and you have to manually look it up every time

[08:38:42.0000] <keith_miller>
shu: Oh, you can't parse your torque (name?) bytecode for builtins?

[08:38:53.0000] <devsnek>
torque doesn't have bytecode

[08:38:58.0000] <shu>
keith_miller: torque compiles down to masm calls, basically

[08:38:59.0000] <devsnek>
it compiles to c++ csa

[08:39:17.0000] <keith_miller>
Ah, I thought it was compiled to bytecode

[08:39:20.0000] <keith_miller>
my b

[08:39:23.0000] <ystartsev>
keith_miller: sm has inlining

[08:40:00.0000] <keith_miller>
Cool so then I'd guess every has some flavor of the issue I'm talking about

[08:40:01.0000] <jorendorff>
keith_miller: Yes, SM does inlining in the most-optimized tier

[08:40:05.0000] <keith_miller>
everyone*

[08:40:36.0000] <shu>
keith_miller: that seems like a reasonable extension to me, of parsing torque, identifying the fast paths, and auto-generating optimized tier specializations as well

[08:40:38.0000] <keith_miller>
jorendorff: Do you have more than one optimizing tier? I thought it was just one?

[08:40:43.0000] <shu>
keith_miller: though i'm not on the compiler team and that might not be feasible for other reasons

[08:40:55.0000] <keith_miller>
fair enough

[08:40:59.0000] <jorendorff>
keith_miller: just the one

[08:41:35.0000] <devsnek>
shu: i think its generally more profitable to handle the output of torque in the graph form

[08:42:02.0000] <keith_miller>
jorendorff Yeah, wasn't sure from the phrasing. Inlining into a template JIT seems less profitable :P

[08:44:04.0000] <shu>
devsnek: not sure what you mean; if what you're driving at is torque needing a new output format that feeds into the graph builder instead emitting CSA calls, then i agree

[08:45:23.0000] <devsnek>
shu: does csa not go through the sea of nodes graph

[08:46:26.0000] <devsnek>
graph reducer

[08:50:42.0000] <shu>
devsnek: yes but that's pretty low level. my intuition is you need to do some higher-level processing to identify what fast paths make sense to emit for the optimized tier

[08:54:06.0000] <ystartsev>
sorry, more dumb questions. What does CSA mean? my search turned up Coupled Simulated Annealing

[08:54:16.0000] <shu>
it's a v8-ism

[08:54:20.0000] <shu>
CodeStubAssembler

[08:54:32.0000] <ljharb>
shu: is that you typing?

[08:54:37.0000] <shu>
a higher-level assembler abstracion

[08:54:38.0000] <shu>
oops sorryu

[08:54:47.0000] <ystartsev>
i see, thanks for the clarification

[08:54:56.0000] <rkirsling>
heh I tried to figure that out from googling too but it's part of the Torque article evidently

[08:55:13.0000] <rkirsling>
er well linked from there

[08:55:15.0000] <rkirsling>
(https://v8.dev/blog/csa)

[08:55:29.0000] <ystartsev>
neat, thanks for the link

[08:56:04.0000] <devsnek>
the idea of torque is basically to make writing csa less of a pain

[08:57:02.0000] <rkirsling>
JSC just uses JS itself but with reviewer-enforced stylistic restrictions, hehe

[08:57:58.0000] <devsnek>
v8 used to do that

[09:00:49.0000] <jorendorff>
Right, SM does that. Ours is not great; it's kind of JS, but with every one-off hack we need

[09:01:14.0000] <jorendorff>
Apart from our lack of investment, JS turns out to be a kind of meh language for the purpose of implementing spec algorithms

[09:02:27.0000] <shu>
my view is SM and V8 have both been bitten by the cons of self-hosting

[09:03:56.0000] <bradleymeck>
node is also doing some stylistic stuff with robustness :-/ , it is difficult at best and definitely down to human review

[09:04:10.0000] <devsnek>
that glorious span of time where people hated promises because v8's self-hosted impl was so slow

[09:04:11.0000] <bradleymeck>
so even runtimes ontop of engines are doing this kind of stuff

[09:07:13.0000] <michaelficarra>
AFAIK chemists use Celsius

[09:07:20.0000] <michaelficarra>
which scientific fields primarily use Kelvin?

[09:07:31.0000] <ystartsev>
maybe physics?

[09:07:37.0000] <rkirsling>
astrophysics surely

[09:07:41.0000] <michaelficarra>
I would guess physics?

[09:08:29.0000] <ljharb>
physics for sure

[09:09:39.0000] <akirose>
y'all see all the "missing information" tags on these new delegate issues? I'd love to get them wrapped & closed! pls check if you're on there or someone you know is https://github.com/tc39/Admin-and-Business/issues

[09:10:32.0000] <michaelficarra>
as an American, I can't help but be embarrassed during this presentation

[09:11:14.0000] <bterlson>
Except for fahrenheit which is a superior scale for non-scientific applications 😀

[09:12:12.0000] <rkirsling>
:fry:

[09:15:05.0000] <shu>
what is the phrase they're saying?

[09:15:08.0000] <shu>
baby highs?

[09:15:47.0000] <drousso>
@bterlson +1 omg _thank you_ yes

[09:16:16.0000] <bradleymeck>
shu: baby heights

[09:17:17.0000] <shu>
does that... use different units than teenager heights or adult heights? i am not a parent

[09:18:00.0000] <ljharb>
baby height is "about 4 inches higher than you thought was safe"

[09:18:05.0000] <Bakkot>
baby heights are inches

[09:18:10.0000] <Bakkot>
not feet and inches

[09:18:11.0000] <Bakkot>
so, yes

[09:18:17.0000] <robpalme>
maybe it's locale specific. in the uk babies are measured in cm

[09:18:27.0000] <ystartsev>
i suspect this is for temporaldeadzone

[09:18:39.0000] <ljharb>
oh oops, sorry

[09:32:54.0000] <littledan>
I'm curious why we're prioritizing Intl.Segmenter when it was a late agenda addition

[09:33:06.0000] <littledan>
this is pushing other things off the agenda that were added before the agenda deadline

[09:34:59.0000] <rkirsling>
wow that Array.from second param

[09:35:04.0000] <michaelficarra>
littledan: we discussed this yesterday, late additions do not mean deprioritised

[09:35:32.0000] <michaelficarra>
we should still prioritise higher-stage proposals over lower-stage ones

[09:36:07.0000] <littledan>
sorry, I guess I missed that discussion (and continue to disagree)

[09:36:21.0000] <michaelficarra>
by "we discussed this yesterday", I mean it was discussed in this channel yesterday

[09:36:25.0000] <michaelficarra>
I did not mean to imply you were present

[09:36:50.0000] <littledan>
right, I didn't mean to imply that anyone but me was at fault for missing it

[09:37:01.0000] <shu>
ystartsev: do you think subclassing removal would benefit from an incubation call? i'm thinking no, since the feedback we want are not from delegates

[09:37:18.0000] <ystartsev>
i think no

[09:37:22.0000] <michaelficarra>
littledan: we can have that process discussion at some point, but there's no precedent for changing priority based on when an agenda item was added

[09:38:23.0000] <ljharb>
the deadline has always been indended only for advancement, since that's the only thing that requires sufficient time to review

[09:39:32.0000] <littledan>
I'll drop this; it's not productive for me to be complaining, and I hope the presenter understands that this isn't personal (of course I'm a fan of this proposal, and I'm really happy that the presenter has taken it up and is championing it in an improved direction from when I started it)

[09:40:02.0000] <littledan>
I've reviewed these changes and they all seem like good ideas to me

[09:40:19.0000] <littledan>
well, except I disagree about the exotic internal slots hazard

[09:41:09.0000] <michaelficarra>
I wish the committee would form a consistent security model that we can use to inform our designs

[09:41:31.0000] <michaelficarra>
I feel we are constantly going back and forth on whether the model SES is based on is valid

[09:41:59.0000] <shu>
michaelficarra: yes, i wish we'd settle as well

[09:42:03.0000] <drousso>
+1

[09:42:12.0000] <shu>
michaelficarra: though of course i am, as a browser, firmly on the invalid side

[09:42:32.0000] <littledan>
so, the exotic internal slot thing seems new. I've been working on following SES constraints for years, but this is a new idea about restrictions on proposals

[09:42:42.0000] <littledan>
I don't see why you couldn't have a prototype around something that has an internal slot containing an object

[09:43:20.0000] <devsnek>
did we move to Promise.any stuff

[09:43:48.0000] <ljharb>
no but the concern overlaps

[09:44:20.0000] <devsnek>
promises have internal slots that hold non-primitive data

[09:44:30.0000] <devsnek>
thenables and whatnot

[09:44:39.0000] <ljharb>
the problem isn't slots holding objects

[09:44:47.0000] <ljharb>
it's *revealing* mutable objects, held in slots

[09:45:04.0000] <ystartsev>
michaelficarra: yeah same.

[09:46:21.0000] <ljharb>
i think the real issue here is that the design of Proxy didn't account for internal slots "properly" for the security model they have in mind

[09:47:03.0000] <michaelficarra>
sounds about right ljharb

[09:48:58.0000] <ljharb>
sorry

[09:49:17.0000] <ljharb>
every single JS type besides Error and Array has prototype methods that check internal slots and thus throw on proxies

[09:49:29.0000] <ljharb>
that slots make proxies throw is irrelevant here

[09:50:37.0000] <ljharb>
(specifically, things with exotic objects are defined in the spec to mean "has exotic internal methods" which has nothing to do with slots)

[09:51:32.0000] <sffc>
mpcsh, maybe try reloading the doc? There is a lot of activity, and maybe you have lag

[09:51:44.0000] <ljharb>
(objects are also data; "primitives" is the term that we should be using here)

[09:52:03.0000] <mpcsh>
sffc: good call

[09:54:59.0000] <jorendorff>
https://tc39.es/ecma262/#sec-get-%typedarray%.prototype.buffer

[09:55:07.0000] <rkirsling>
is there any precedent for "getting back to the Intl class instance"?

[09:55:13.0000] <rkirsling>
seems super random

[09:55:25.0000] <jorendorff>
^ that seems to be a getter that returns an object out of an internal slot

[09:56:15.0000] <ljharb>
jorendorff: ohhhh snap

[09:56:19.0000] <shu>
lol what is going on right now

[09:56:26.0000] <shu>
how are function closures not reified

[09:56:34.0000] <shu>
???

[09:56:50.0000] <ljharb>
i can clarify but i don't think this discussion is useful right now

[09:56:58.0000] <devsnek>
they're using the word closure differently

[09:57:06.0000] <devsnek>
waldemar is referring to the function as a closure

[09:57:09.0000] <michaelficarra>
I don't think there's an ecmascript value that we call a "closure" in the spec

[09:57:22.0000] <shu>
i don't think there are different meanings of "closure", there is a single meaning of closure

[09:57:37.0000] <devsnek>
and someone else is using the term closure to refer to the scope

[09:57:45.0000] <devsnek>
not the function

[09:57:58.0000] <jorendorff>
ljharb is right, this conversation is *terrible*

[09:58:22.0000] <michaelficarra>
^

[09:59:14.0000] <michaelficarra>
really, I blame this committee for not having a consistent security model that we could be reasoning about right now

[10:00:48.0000] <sffc>
+1 shu, let's not hypothesize about SES without Mark Miller here

[10:01:15.0000] <bterlson>
You want to do the opposite of table it. It's on the table right now; we're discussing it.

[10:01:36.0000] <NilSet>
seems to me like if the membrane pattern is fragile to changes in the spec like this, it SHOULD in fact be actually part of the spec

[10:01:42.0000] <rkirsling>
bterlson: boooo

[10:02:13.0000] <shu>
have i been using "tabling" wrong my entire life??

[10:02:17.0000] <bterlson>
sorry no

[10:02:19.0000] <ljharb>
NilSet: that, or, we should have consensus not to support that pattern. the problem is that consensus for either one is likely not possible.

[10:02:23.0000] <rkirsling>
shu: no you're 100% correct for US english

[10:02:24.0000] <bterlson>
US vs British english distinction

[10:02:28.0000] <shu>
for real?

[10:02:34.0000] <shu>
it means the opposite in british english?

[10:02:36.0000] <rkirsling>
yeah it's literally the opposite

[10:02:38.0000] <rkirsling>
it's horrible

[10:02:49.0000] <bterlson>
IMO the meaning of "to table" is one of the few things British English gets right. We already have ways to say "defer"

[10:03:01.0000] <ljharb>
bollocks

[10:03:18.0000] <drousso>
wow

[10:03:23.0000] <drousso>
🤯🤯🤯

[10:03:26.0000] <ljharb>
but i'll take my blown mind about UK english's meaning of "table" to tdz

[10:03:28.0000] <ryzokuken>
https://english.stackexchange.com/questions/16285/what-is-the-meaning-of-the-expression-we-can-table-this

[10:03:35.0000] <sffc>
For a US-based meeting let's use the US definition of "table" :)

[10:03:36.0000] <rkirsling>
bterlson: we also have ways to say "schedule" though

[10:04:08.0000] <bterlson>
table is to bring up for discussion immediately

[10:04:35.0000] <bterlson>
it's also a good metaphor. You table a proposal. You can table supporting documents.

[10:06:08.0000] <NilSet>
so table is a contronym?

[10:06:16.0000] <NilSet>
like chuffed?

[10:09:22.0000] <ljharb>
NilSet: join #temporaldeadzone, i have questions

[10:29:52.0000] <devsnek>
is frank tang on irc

[10:59:28.0000] <robpalme>
we are restarting in 1 minute!

[11:13:27.0000] <littledan>
devsnek: I don't think so but I can introduce you by email if you want

[11:13:50.0000] <devsnek>
oh i just wanted to let him know his camera was on during lunch

[11:15:41.0000] <ljharb>
littledan: fwiw we do have that strawperson solution, it's the spaceship operator

[11:16:22.0000] <littledan>
ah OK. That would work with Arrays?

[11:16:38.0000] <littledan>
maybe we should go down the queue?

[11:17:21.0000] <ljharb>
littledan: yes, it would come with a Symbol.compare protocol, as in the example in the slides, that would be defined on Array.prototype

[11:17:39.0000] <howdoi>
[false, null, 1, "1"].sort() today would return [ 1, '1', false, null ]

[11:19:26.0000] <ljharb>
shu: (not to preempt your queue item) but arrays can contain any value, so to compare array contents we need to know how to compare any variable

[11:19:29.0000] <ljharb>
*any value

[11:22:37.0000] <michaelficarra>
I agree with Shu that I do not want to spend committee time on the black hole that is generic equality

[11:22:53.0000] <shu>
it's a bigger hole than just equality

[11:23:07.0000] <michaelficarra>
that's true, also ordering

[11:23:09.0000] <rkirsling>
I think shu's summarized opinion was quite well put

[11:23:12.0000] <shu>
i don't think we should think about partial orders and so forth

[11:23:33.0000] <michaelficarra>
I don't think we should spend time on either individually or both

[11:23:37.0000] <shu>
to wit, i don't think it's sensical kinda along the arguments that waldemar put forward

[11:24:18.0000] <michaelficarra>
does Set equality take into account the insertion order? gross

[11:24:32.0000] <devsnek>
its observable via -0

[11:24:41.0000] <michaelficarra>
it's observable via iteration

[11:24:42.0000] <ljharb>
michaelficarra: it wouldn't have to

[11:24:53.0000] <ljharb>
michaelficarra: all the deepEqual libraries on npm do not regard order in Set and Map comparison

[11:25:08.0000] <ljharb>
(also node's assert)

[11:25:11.0000] <michaelficarra>
that doesn't mean it's the *one true equality definition*

[11:25:13.0000] <Bakkot>
if I want it to do I need to overwrite Set.prototype[Symbol.whatever]?

[11:25:24.0000] <ljharb>
iow the semantics for how to judge values as equal are already largely consistent in the ecosystem

[11:25:44.0000] <ljharb>
Bakkot: replace it, or shadow it via own or subclass, yes

[11:26:52.0000] <rbuckton>
I'm interested in exploring equality, relational equality, and structural equality

[11:27:31.0000] <shu>
rbuckton: what is relational equality?

[11:27:54.0000] <rbuckton>
relational operators, essentially `Symbol.compare`

[11:28:01.0000] <rbuckton>
(from the slides)

[11:28:21.0000] <shu>
what is the equality part of "relational equality"?

[11:29:23.0000] <rbuckton>
I'm just talking about relational operators like `<`, `<=`, `>`, `>=`

[11:29:29.0000] <shu>
ah okay

[11:30:21.0000] <rbuckton>
For example, If we had a `[Symbol.compareTo]` method, we could have `Array.prototype.sort` use that as a fallback before going to comparing the `ToString` of each element.

[11:32:39.0000] <michaelficarra>
agree with Shu again, even though he jumped queue

[11:32:49.0000] <shu>
i'm sorry i didn't know there was a queue!

[11:32:58.0000] <shu>
thought it was empty, should have the tab open

[11:32:58.0000] <michaelficarra>
there's always a queue

[11:33:02.0000] <michaelficarra>
:-P

[11:33:04.0000] <shu>
i heard rob said it was empty

[11:33:35.0000] <akirose>
it was

[11:33:37.0000] <akirose>
and then it wasn't

[11:34:59.0000] <michaelficarra>
good point, littledan, public perception of what we've approved is important

[11:35:07.0000] <shu>
agree

[11:35:33.0000] <ljharb>
+1

[11:35:57.0000] <michaelficarra>
I'm very happy in general with everyone's contributions during this topic. Good job everyone!

[11:36:13.0000] <rkirsling>
:nod:

[11:37:14.0000] <littledan>
ftr I think a spaceship operator someday would be awesome, but I agree with Waldemar that it would need to be four-valued

[11:37:47.0000] <devsnek>
what's the fourth value

[11:37:49.0000] <devsnek>
no comparison?

[11:37:49.0000] <littledan>
maybe spaceship could be built on operator overloading, if we do that. It'd be cool if spaceship and other comparison operators kinda agreed

[11:38:01.0000] <littledan>
devsnek: Yes, uncomparable. Like NaN, but there are other partial orders

[11:38:20.0000] <rkirsling>
mmm negative indices

[11:38:24.0000] <ljharb>
negative, postiive, zero, NaN?

[11:38:58.0000] <devsnek>
+Infinity, -Infinity, 0, null

[11:39:20.0000] <michaelficarra>
ljharb: may want to look here for some inspiration: https://pursuit.purescript.org/packages/purescript-higher-order/0.2.0/docs/Data.PartialOrd#t:PartialOrd

[11:39:55.0000] <ljharb>
"just true"?

[11:40:16.0000] <devsnek>
or https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html

[11:40:29.0000] <ljharb>
those laws do make sense to me tho; if i wasn't afraid of touching > and < and == i'd expect them all to agree

[11:40:36.0000] <michaelficarra>
are Arguments exotic objects "indexable"?

[11:40:47.0000] <ljharb>
yes?

[11:41:27.0000] <michaelficarra>
so how will they get this method?

[11:41:56.0000] <devsnek>
i don't see much of a reason to add it

[11:41:57.0000] <rbuckton>
What I've been thinking about is a set of protocols and APIs around equality:

[11:41:57.0000] <rbuckton>
- `[@@equals](other)`, `[@@hash]()` - Allows an object itself to define whether it is equal to another object in a generic fashion. Useful for `Map`, `Set`, and cross-compatibility between userland libraries.

[11:41:57.0000] <rbuckton>
- `[@@compareTo](other)` - Defines a relational comparison on an object itself, returning `-1 | 0 | 1` (similar to this proposal)

[11:41:57.0000] <rbuckton>
- `[@@structuralEquals](other, equaler)` - Allows an object to define how it should be equated structurally with another object, using the provided `Equaler` (see below)

[11:41:57.0000] <rbuckton>
- `[@@structuralHash](equaler)` - A version of `@@hash` for structural equality.

[11:41:58.0000] <rbuckton>
- `[@@structuralCompareTo](other, comparer)` - A version of `@@compareTo` for structural comparisons.

[11:41:58.0000] <rbuckton>
- `Equaler` - An object with `equals(a, b)` and `hash(a)` methods that can be used to define equality independent of objects. Also useful for `Map` and `Set` when working with keys that do not maintain their own `@@equals`/`@@hash` members.

[11:41:59.0000] <rbuckton>
- `Comparer` - An object with a `compare(a, b)` method that can be used to define comparability independent of objects.

[11:41:59.0000] <rbuckton>
- `StructuralEqualer` - An object with `structuralEquals(a, b, equaler)` and `structuralHash(a, equaler)` methods.

[11:42:00.0000] <rbuckton>
- `StructuralComparer` - An object with `structuralCompare(a, b, comparer)` methods.

[11:42:01.0000] <rbuckton>
The design is derived from `IEquatable`, `IComparable`, `IStructuralEquatable`, `IStructuralComparable`, `EqualityComparer`, and `Comparer` in C#/.NET.

[11:42:03.0000] <ljharb>
eesh

[11:42:05.0000] <devsnek>
but its not like they can't have an own property

[11:43:15.0000] <michaelficarra>
rbuckton: you don't need to end every proposal with "this design is derived from […] C#/.NET"; we already know

[11:43:25.0000] <ljharb>
lulz

[11:43:25.0000] <rbuckton>
michaelficarra: :P

[11:44:07.0000] <devsnek>
i need to start adding js features to c#

[11:44:09.0000] <devsnek>
to balance it out

[11:44:18.0000] <ljharb>
add typeof null

[11:44:22.0000] <ljharb>
oops this isn't tdz

[11:44:23.0000] <rkirsling>
michaelficarra: 🔥

[11:45:04.0000] <michaelficarra>
rbuckton: 💙

[11:45:06.0000] <rbuckton>
ActiveX/COM objects in old IE/Chakra exposed both an indexer and a `item()` method with the same meaning. Probably not a compat issue for Array.prototype...

[11:45:42.0000] <Bakkot>
I feel like switching null to undefined is going to break stuff

[11:45:43.0000] <rbuckton>
michaelficarra: not always true though, partial application isn't based on .NET at all :)

[11:46:39.0000] <jorendorff>
(re: null → undefined) yes ...only if anyone is using .item() to start with

[11:47:01.0000] <Bakkot>
fair

[11:47:05.0000] <Bakkot>
i assumed it was common

[11:47:24.0000] <jorendorff>
maybe? literally no idea

[11:47:35.0000] <Bakkot>
I guess I'd usually use the indexing syntax though

[11:47:44.0000] <rkirsling>
I would be surprised if it's a thing

[11:47:53.0000] <rkirsling>
but the web is a surprising place, so who knows

[11:48:51.0000] <Bakkot>
michaelficarra I don't see a reason to want that

[11:48:52.0000] <devsnek>
michaelficarra: own proprety :P

[11:49:05.0000] <Bakkot>
I don't see a reason for people to have arguments objects in new code at all

[11:49:26.0000] <jorendorff>
it's funny to have `arr.item(Infinity)` able to hit an expando property

[11:49:36.0000] <rickbutton>
sometimes you have to make bad choices to level out the good ones Bakkot

[11:49:36.0000] <haxjs>
I guess if we can had arguments be array, it already be array in ES6?

[11:50:07.0000] <jorendorff>
it's also funny to have `arr.item(-100)`, where arr.length is 3, able to hit expando properties

[11:50:10.0000] <jridgewell>
We define `Symbol.iterator` on `arguments`

[11:50:31.0000] <Bakkot>
haxjs I don't know if we explored having arguments be an array in strict mode. it definitely could not be in sloppy mode because there is the magical behavior of mapped arguments objects

[11:50:36.0000] <jridgewell>
As an own-data method

[11:50:39.0000] <leobalter>
michaelficarra: I don't see a use case for arguments other than we don't have it there. I don't think it's interesting enough to add just because this

[11:50:46.0000] <Bakkot>
jridgewell that's a good example

[11:50:57.0000] <michaelficarra>
arguments.item(-1) is useful

[11:51:11.0000] <Bakkot>
michaelficarra only if you have an arguments object, which, why do you have an arguments object

[11:51:26.0000] <michaelficarra>
because it's in-scope as `arguments` in every function invocation?

[11:51:30.0000] <jridgewell>
And it's the `Array.prototype.values` method, so shared between all `arguments`

[11:51:38.0000] <ljharb>
jorendorff: wait, what

[11:51:47.0000] <ljharb>
jorendorff: why would `item` accept anything that's not an integer

[11:51:47.0000] <michaelficarra>
jridgewell: that's great precedent! even if gross

[11:51:55.0000] <ljharb>
jorendorff: or at least a finite number

[11:52:05.0000] <Bakkot>
michaelficarra so? `eval` is in scope too, but, like, don't touch it

[11:52:10.0000] <michaelficarra>
sounds like we could probably do the same with Array::item

[11:52:36.0000] <jorendorff>
ljharb: I'm kind of saying I agree. just going by the slides

[11:52:37.0000] <devsnek>
michaelficarra: `...args` is an array that you can item(-1) on

[11:52:41.0000] <ljharb>
littledan: https://apidock.com/rails/Array/forty_two

[11:53:00.0000] <michaelficarra>
devsnek: can't always use rest parameters

[11:53:05.0000] <rkirsling>
I mean if we hit web compat issues with the Web APIs then *just* having a "from the right" method might suffice

[11:53:16.0000] <devsnek>
michaelficarra: why not

[11:53:17.0000] <Bakkot>
littledan I don't see why indexing with `-1` is any worse than indexing with `0`

[11:53:29.0000] <michaelficarra>
devsnek: use strict directive or weird parameter ordering conventions a la node

[11:53:40.0000] <michaelficarra>
Bakkot: +1

[11:53:42.0000] <devsnek>
Array.prototype.item.call(arguments, -1)

[11:53:54.0000] <michaelficarra>
devsnek: yeah that's a decent alternative

[11:54:15.0000] <michaelficarra>
or the old reliable `args = [].slice.call(arguments)`

[11:54:16.0000] <ljharb>
RIP `arguments::Array.prototype.item(-1)`

[11:54:23.0000] <devsnek>
lmao

[11:54:36.0000] <michaelficarra>
ljharb: :'(

[11:54:50.0000] <haxjs>
Can we revive it?

[11:55:01.0000] <michaelficarra>
haxjs: it wasn't too popular

[11:55:04.0000] <howdoi>
ljharb: epic! self[41]

[11:55:19.0000] <littledan>
rbuckton: peek sounds like a great name

[11:55:23.0000] <leobalter>
picking the last item from `arguments` without checking the length sounds weird. For arguments you either expect a length or - if you expect many arguments - it feels like rest parameter is already a good design

[11:55:50.0000] <gibson042>
peek by convention is from the front

[11:56:04.0000] <ystartsev>
peek sounds too ambiguous to me

[11:56:11.0000] <devsnek>
https://apidock.com/rails/Array/forty_two

[11:56:17.0000] <gibson042>
x.peek(0) is like x[0]

[11:56:29.0000] <devsnek>
what does peek mean

[11:56:34.0000] <ystartsev>
i understand peek as similar to next, without advancing

[11:56:37.0000] <devsnek>
i only know it in the context of iterators

[11:56:39.0000] <gibson042>
it's actually a good candidate replacement for "item" if that name doesn't work out

[11:56:42.0000] <rkirsling>
peek is great if you're already a parser geek, but...

[11:56:50.0000] <rbuckton>
gibson042: that wouldn't match with `push` and `pop` being from the back and being queue-like operations on Array.

[11:56:57.0000] <littledan>
sorry don't worry about my concern about .item(-1), it doesn't seem really bad to me, ljharb makes a good point about .slice

[11:57:01.0000] <ljharb>
peek is like pop and push, it's just weird because arrays conflate Lists and Queues

[11:57:09.0000] <littledan>
I still like the idea of .lastElement() somehow or other

[11:57:17.0000] <rbuckton>
This proposal was already suggested in an issue on last: https://github.com/tc39/proposal-array-last/issues/27

[11:57:17.0000] <ystartsev>
i think the concept is good

[11:57:20.0000] <devsnek>
ljharb: wdym "like pop and push"

[11:57:21.0000] <ystartsev>
i would support moving it forward

[11:57:39.0000] <ljharb>
devsnek: peek is "pop but don't remove it"

[11:57:43.0000] <rbuckton>
Well maybe not the same proposal, please ignore.

[11:57:49.0000] <devsnek>
ahhh got it

[11:57:51.0000] <gibson042>
peek is "next but don't remove it"

[11:58:11.0000] <devsnek>
yeah i wasn't sure what it meant on collection types

[11:58:13.0000] <ljharb>
arrays actually conflate the concepts of List, Stack, and Queue, i think?

[11:58:19.0000] <gibson042>
yeah

[11:58:22.0000] <ljharb>
pop/push, shift/unshift, and then everything else

[11:58:50.0000] <devsnek>
they're also dictionaries

[11:58:59.0000] <littledan>
+1 for Stage 1!

[11:59:03.0000] <rkirsling>
ship it

[11:59:13.0000] <devsnek>
[-1] for stage 1

[12:00:50.0000] <jridgewell>
I think of arrays as being closer to stacks then queues

[12:01:06.0000] <devsnek>
they have the methods needed to be queues

[12:01:07.0000] <rkirsling>
jridgewell: I think performance encourages that view

[12:01:14.0000] <jridgewell>
Mainly because `shift` is O(n) and `pop` is O(1)

[12:01:18.0000] <devsnek>
yeah performance *definitely* is on the side of that

[12:01:18.0000] <rkirsling>
yeah.

[12:01:41.0000] <gibson042>
yep

[12:01:48.0000] <devsnek>
you could do a butterfly allocation for every array

[12:04:09.0000] <rbuckton>
jridgewell: agreed, I misspoke when I said "queue-like operations" above, I meant to say "stack-like operations" w.r.t. `push/pop`. Hence why I think `.peek` makes sense as "look at the nth element of the array starting from the last element".

[12:04:43.0000] <ljharb>
ystartsev: fwiw the motivation is to do it in node, and even if node is adding webcrypto, it seems like it should be in the language :-/

[12:05:02.0000] <jridgewell>
Yah, I agree with `peek` being backwards looking for it

[12:05:08.0000] <devsnek>
crypto sounds good

[12:05:17.0000] <devsnek>
i still don't think uuid belongs in stdlib

[12:07:06.0000] <ystartsev>
ljharb: thats actually the argument we had regarding why it should be in webcrypto, node is implementing it

[12:07:10.0000] <michaelficarra>
shu: in case it was not obvious, I have an interest in attending that security model call

[12:07:37.0000] <ljharb>
ystartsev: ok but then that still means it wouldn't be portable outside browsers and node

[12:07:45.0000] <ystartsev>
rbuckton: we have already discussed it, we may rechartere it

[12:07:53.0000] <ljharb>
it's really weird imo for stuff that's not web-specific to only be in web specs.

[12:08:11.0000] <ystartsev>
ljharb: this is why i brought up a more wholistic approach to crypto

[12:08:25.0000] <ljharb>
gotcha

[12:08:33.0000] <keith_miller>
shu: Sorry, I missed part of this because I had a thingy. Was it discussed if we could have these be normative optional?

[12:08:51.0000] <rbuckton>
Given that NodeJS is also intending to implement something akin to Web Cryptography, I feel it might make sense to adopt part or all of Web Crypto in the language/standard library itself.

[12:08:56.0000] <ljharb>
^

[12:08:58.0000] <ystartsev>
the view of our security folks is that if we start introducing bits and pieces of crypto to just js, we should have a holistic picture so that we add things that are strateegic

[12:09:08.0000] <ljharb>
littledan: i'm not sure temporal is ready for wider review until the rate of change slows?

[12:09:12.0000] <ystartsev>
there was also discussion about moving web crypto to tc39, but it is blocked

[12:09:14.0000] <devsnek>
its worth noting that node and the web are not all of js

[12:09:15.0000] <devsnek>
just most of it

[12:09:25.0000] <ljharb>
ystartsev: phrased that way ("the view of" part) is quite compelling

[12:09:30.0000] <rbuckton>
ystartsev: Due to EventTarget, or for some other reason?

[12:09:37.0000] <ystartsev>
due to a process reason

[12:09:58.0000] <ystartsev>
i can raise it again, there was an ongoing discussion around this

[12:10:03.0000] <keith_miller>
ystartsev: Was it blocked becaues there are places where it doesn't make sense or because we don't want to be the arbiters?

[12:10:41.0000] <keith_miller>
IMO, I'm kind of a fan of standardizing many more things as normative optional and letting hosts define which things they should expose

[12:10:47.0000] <littledan>
ljharb: Temporal is seeking feedback, as announced in the presentation.

[12:10:50.0000] <rbuckton>
I'd be interested in knowing more, as I was asked by the committee to explore moving my `ArrayBuffer.getRandomBytes` proposal to bringing at least part of `crypto` to the language.

[12:10:59.0000] <keith_miller>
If we don't think they make sense everywhere

[12:11:22.0000] <shu>
keith_miller: what's normative optional?

[12:11:24.0000] <ystartsev>
therre were a couple of things -> one is that the layering and moving of bits of web crypto was offered by someone who was in an admin role but couldn't make that call

[12:11:34.0000] <shu>
keith_miller: .item()?

[12:11:45.0000] <keith_miller>
shu: no sorry, things like getRandomBytes

[12:11:50.0000] <shu>
keith_miller: oh i have no idea

[12:11:54.0000] <keith_miller>
where some contexts don't want it

[12:11:54.0000] <devsnek>
bradleymeck: did you pull the module string exports

[12:11:58.0000] <shu>
keith_miller: i'm kinda on the move to webcrypto train

[12:11:59.0000] <keith_miller>
because security or w/e

[12:12:01.0000] <ystartsev>
the second issue is that mozilla itself would be opposed to moving things out of web crypto as they see this as well defined and are being implemented by external consumers anyway (such as node)

[12:12:07.0000] <Bakkot>
workers don't expose most of crypto, for reasons which are totally unclear to me

[12:12:14.0000] <Bakkot>
they expose getRandomValues and nothing else, IIRC

[12:12:16.0000] <shu>
keith_miller: but i want the champions to hear that and respond, not me parroting them

[12:12:16.0000] <bradleymeck>
devsnek: arbitrary namespace bindings? nah, that went through

[12:12:17.0000] <keith_miller>
shu: One upside is that then node can share the spec

[12:12:23.0000] <keith_miller>
but I don't care too much

[12:12:26.0000] <devsnek>
bradleymeck: stage 1?

[12:12:31.0000] <devsnek>
oh i see it on the queue now

[12:12:37.0000] <bradleymeck>
`from ... import` has feedback that it doesn't carry enough weight so I'm de-prioritizing

[12:12:45.0000] <keith_miller>
I guess we can implement it in JSC regardless 🤷‍♂️

[12:13:16.0000] <keith_miller>
Just feels like a failure of the language if the spec can't have "core" library features

[12:13:16.0000] <bradleymeck>
devsnek: no stage because i didn't ask, it should go quickly through staging though as it seemed only validity of strings is the question

[12:13:38.0000] <devsnek>
bradleymeck: like utf validity?

[12:14:01.0000] <bradleymeck>
yes

[12:14:18.0000] <rbuckton>
ystartsev: `UUID` is essentially dependent on `getRandomValues` (at least per the requirements of some members of TC39). Are you suggesting that `UUID` be moved from TC39 to a proposal to Web Crypto?

[12:14:23.0000] <devsnek>
js strings aren't required to be valid utf anything are they?

[12:14:29.0000] <ystartsev>
rbuckton: yse

[12:14:34.0000] <Bakkot>
devsnek indeed

[12:14:39.0000] <Bakkot>
but they are in many other languages

[12:14:40.0000] <keith_miller>
shu: Oh sure, I'm not saying they should feel obligated. Just that I think a lot of proposals don't come to TC-39 because of things like SES concerns, which I think is a shame.

[12:14:41.0000] <ystartsev>
rathre than move getRandomValues to tc39

[12:14:52.0000] <michaelficarra>
devsnek: nope, just a sequence of UTF-16 code units

[12:15:01.0000] <devsnek>
so what's the problem then lol

[12:15:04.0000] <shu>
keith_miller: ah, interesting observation

[12:15:25.0000] <bradleymeck>
devsnek: exporting invalid stuff that other langs couldn't deal w/

[12:15:37.0000] <keith_miller>
shu: if we could solve that via normative optional then we might have a better path forwar

[12:15:41.0000] <keith_miller>
forward*

[12:15:50.0000] <michaelficarra>
I'm glad we're getting to this editorial topic

[12:15:54.0000] <rkirsling>
oh man

[12:15:55.0000] <michaelficarra>
being an editor and all lol

[12:16:02.0000] <rkirsling>
most heated editorial topic ever

[12:16:06.0000] <rbuckton>
ystartsev: There's a broader question of whether there's the possibility of other ES standard library APIs that might depend on UUID, and then can't because it isn't specified. I suppose they would have to rely on merely a string or `ArrayBuffer` representation of the UUID.

[12:16:25.0000] <ystartsev>
rbuckton: are there specific apis you have in mind?

[12:16:34.0000] <rbuckton>
"might depend on UUID" in the future, rather.

[12:16:55.0000] <devsnek>
why would something have to depend on uuid

[12:17:21.0000] <gibson042>
shu: optional to implement, but if implemented must conform with the spec

[12:17:41.0000] <rkirsling>
definitely did *not* know about cbrt

[12:19:02.0000] <rbuckton>
ystartsev: Nothing concrete at the moment, no. I know that, in languages like C#, UUID (or rather, `Guid`) usage is fairly prevalent within the standard library.

[12:19:05.0000] <keith_miller>
devsnek: I don't think they are forced to be UTF-16 but it's a pain to do a lot of RegExp stuff if they're not in that form

[12:19:38.0000] <keith_miller>
If we didn't have non-unicode RegExp's with unicode characters then it would probably fine lol

[12:19:42.0000] <devsnek>
keith_miller: of course one *shouldn't* store nonsense in them

[12:19:44.0000] <ystartsev>
rbuckton: what kind of usage do we mean here? as a building block for other rthings?

[12:19:45.0000] <devsnek>
but one *can*

[12:20:06.0000] <keith_miller>
devsnek: store?

[12:20:17.0000] <keith_miller>
maybe we are talking about different things?

[12:20:18.0000] <rbuckton>
ystartsev: Yes.

[12:20:20.0000] <devsnek>
strings

[12:20:22.0000] <devsnek>
in js

[12:20:32.0000] <devsnek>
people used to store binary data in them before we got arraybuffer

[12:20:37.0000] <ystartsev>
rbuckton: from our perspective, it doesn't make sense in duplicating the standard, or having slightly different implementations of the same thing, or maintaining two implementations in parallel

[12:20:38.0000] <Bakkot>
fwiw I am in favor of requiring those strings to be valid UTF16

[12:20:39.0000] <keith_miller>
I don't think it's the string so much as the code points

[12:20:50.0000] <Bakkot>
they're not arbitrary data; they're specifically an interop point, potentially with other languages

[12:20:50.0000] <keith_miller>
for regexps

[12:20:56.0000] <ystartsev>
rbuckton: i am unaware of any features that we are planning to add to js that would rely on uuid

[12:20:59.0000] <rbuckton>
I'm not opposed to UUID moving to web crypto, but I do wonder if we might have to revisit this again in the future.

[12:21:09.0000] <Bakkot>
and you can't export a dynamic string, so it's not like you have to check your strings or whatever

[12:21:13.0000] <devsnek>
Bakkot: a language may use a mangling scheme which is not valid utf

[12:21:15.0000] <Bakkot>
it would be an early error

[12:21:21.0000] <Bakkot>
devsnek ehhhhh

[12:21:26.0000] <devsnek>
i mean i doubt it exists

[12:21:29.0000] <Bakkot>
devsnek JS strings are not strings of bytes

[12:21:32.0000] <devsnek>
i don't see a reason to limit it though

[12:21:33.0000] <Bakkot>
they are strings of 16-bit values

[12:21:37.0000] <ystartsev>
i will see where the rechartering of webcrypto is at the moment, and i will get back to folks

[12:21:48.0000] <devsnek>
Bakkot: people used them as byte strings

[12:21:50.0000] <ystartsev>
the alternative is a holistic approach to crypto in tc39 that compliments web crypto

[12:21:56.0000] <keith_miller>
rbuckton: If we put UUID in W3C how would anything in TC-39 depend on it anyway?

[12:22:03.0000] <Bakkot>
devsnek yes, but this is an interop point, not an arbitrary string

[12:22:10.0000] <Bakkot>
devsnek the reason to limit it is so that the interop is "unicode strings" rather "sequences of 16-bit values"

[12:22:26.0000] <Bakkot>
if the strings were literally bytes, that might be reasonable, but they aren't

[12:22:32.0000] <Bakkot>
bytes are a kind of reasonable interop point

[12:22:39.0000] <Bakkot>
sequences of 16-bit values are not

[12:23:02.0000] <keith_miller>
i.e. I don't see how having TC-39 have it as normative optional would be different from a TC-39 use

[12:23:04.0000] <rbuckton>
keith_miller: As far as I can tell, we couldn't. At best, if we did need to support it we could depend on a uniform string representation of a UUID and users would have to depend on the host to give them a mechanism to generate one.

[12:23:13.0000] <rbuckton>
string or ArrayBuffer

[12:23:38.0000] <devsnek>
rbuckton: what is the use case that requires uuids

[12:24:05.0000] <devsnek>
vs some other somewhat unique value

[12:24:06.0000] <keith_miller>
rbuckton: I'd also be surprised since we can't add UUID to TC-39 we could add anything that depends on it

[12:24:40.0000] <rbuckton>
devsnek: I don't have one currently. I find myself often needing UUIDs in user code, and would find it acceptable if Web Crypto implemented UUID, as long as a compatible implementation is also available on Node.

[12:26:47.0000] <keith_miller>
ystartsev: I'd really like to see us consider normative optional before moving to WebCrypto but obviously I'm not championing the UUID proposal

[12:26:56.0000] <rbuckton>
My experience in C# has shown that `Guid` is often heavily used in larger programs and is tied to a number of standard library features in .NET. It would be unfortunate that we wouldn't be able to define something that is consistent and broadly available across all hosts, but it isn't the end of the world.

[12:27:18.0000] <keith_miller>
ystartsev: Not that you are either AFAICT, but you mentioned rechartering the group above

[12:27:37.0000] <ystartsev>
just a sec

[12:27:43.0000] <keith_miller>
no worries

[12:28:49.0000] <Bakkot>
rbuckton fwiw I think that's a C3-specific thing

[12:28:52.0000] <Bakkot>
*C#

[12:29:01.0000] <Bakkot>
I don't think Guid gets a lot of use in random programs in other languages

[12:29:52.0000] <rbuckton>
It's also a C++/MFC thing, heavily steeped in the fact that much of the Windows registry is built around GUID/UUIDs

[12:30:14.0000] <devsnek>
i've literally never seen UUIDs used outside of databases

[12:31:30.0000] <rbuckton>
devsnek: You pretty much can't write a shared Windows native library without them, though in recent years its not as obvious to the user.

[12:31:48.0000] <devsnek>
ah there's the problem

[12:31:52.0000] <devsnek>
i don't write shared windows libaries

[12:31:58.0000] <devsnek>
or libraries

[12:33:05.0000] <Bakkot>
jorendorff host hooks are "host-defined abstract operations"

[12:33:10.0000] <Bakkot>
that is the phrase used in the spec

[12:33:18.0000] <Bakkot>
I think this is equivalent to "AOs which start with the word Host"

[12:36:37.0000] <littledan>
should we go down the queue?

[12:51:37.0000] <Bakkot>
shu ljharb michaelficarra fwiw I am fine with writing down the thing Waldemar said and preserving that distinction

[12:51:47.0000] <shu>
yes, i was about to suggest that

[12:51:58.0000] <shu>
what waldemar is saying he finds it useful to editorially distinguish

[12:52:08.0000] <shu>
that is fine with me, as long as we get guidelines for editors to apply our judgment

[12:52:36.0000] <michaelficarra>
I don't fully understand what Waldemar wants

[12:53:04.0000] <Bakkot>
michaelficarra he wants us to only use "implementation-defined" when there is not a clearly correct answer

[12:53:09.0000] <michaelficarra>
still just an editorial distinction?

[12:53:15.0000] <Bakkot>
yup

[12:53:23.0000] <michaelficarra>
and we can still make it host-defined?

[12:53:31.0000] <Bakkot>
with committee approval, it sounds like

[12:53:34.0000] <michaelficarra>
aww

[12:53:56.0000] <Bakkot>
(that was chip's point)

[12:54:01.0000] <Bakkot>
(not waldemar's)

[12:54:30.0000] <rkirsling>
how does "implementation-dependent" as a phrase conjure up an image of "there is a best answer"

[12:54:46.0000] <ljharb>
to me, "dependent" and "defined" are identical

[12:54:50.0000] <ljharb>
like in terms of english words

[12:54:58.0000] <keith_miller>
You folks just play word games

[12:55:04.0000] <keith_miller>
Is that like words with friends?

[12:55:04.0000] <ljharb>
i mean, that's accurate

[12:55:12.0000] <gibson042>
I appreciate the distinction in of "defined" being specifiable and "dependent" not

[12:55:34.0000] <rkirsling>
^ I'm okay with "defined" emphasizing a "definition" but

[12:55:36.0000] <ljharb>
regardless of the editorial category, the current wording is very unclear to me

[12:55:38.0000] <ystartsev>
ok so my understanding of this proposal is doing this: https://github.com/tc39/ecma262/issues/1524

[12:55:42.0000] <ystartsev>
oops

[12:55:43.0000] <ystartsev>
sorry

[12:55:47.0000] <rickbutton>
IMO, the editors have a specific role to play word games, that's like the point?

[12:55:53.0000] <ystartsev>
https://github.com/tc39/ecma262/issues/1524#issuecomment-611692464

[12:55:54.0000] <ystartsev>
this

[12:56:02.0000] <ljharb>
rickbutton: that's a triple word score right there

[12:56:17.0000] <gibson042>
the collapse of a quantum superposition is experiment-dependent, but the result of a classical coin flip is experiment-defined

[12:56:30.0000] <ystartsev>
my question might not have been clear

[12:56:41.0000] <ljharb>
gibson042: how are those not the same, a classical coin flip still depends on quantum effects

[12:56:53.0000] <gibson042>
"classical" by definition excludes quantum

[12:56:57.0000] <ljharb>
ah k

[12:57:07.0000] <ljharb>
still not clear on the difference in the terms tho

[12:57:23.0000] <ljharb>
i just think "dependent" and "defined" don't actually have different meanings conversationally, even if in C++ era languages they have a concrete meaning

[12:57:41.0000] <devsnek>
the point there is about causality

[12:57:49.0000] <ljharb>
and importantly, the spec currently does not have any normative distinction between them i'm aware of

[12:57:59.0000] <gibson042>
that part I absolutely agree with

[12:58:07.0000] <devsnek>
like engines don't choose what the cube root of a number is

[12:58:20.0000] <ljharb>
devsnek: they're allowed to, tho.

[12:58:27.0000] <devsnek>
i mean a real number

[12:58:55.0000] <michaelficarra>
note-takers (rricard): feel free to use point of order, that's why it's there

[12:59:25.0000] <gibson042>
nondeterminism would be more concerning in something specified as "implementation-defined" than something "implementation-dependent"

[12:59:33.0000] <shu>
michaelficarra: Bakkot: i did get the sense some delegates have a different notion of "normative" than narrowly scoped to "observably different"

[12:59:50.0000] <shu>
if normative expands to also capture intent

[12:59:52.0000] <shu>
that alarms me

[12:59:58.0000] <ljharb>
i don't see how anything is normative if you can't write a program that observes the difference

[13:00:00.0000] <gibson042>
but both out of scope for ECMA 262 anyway

[13:00:04.0000] <michaelficarra>
yeah I don't think everyone was fully prepared to have this conversation

[13:01:36.0000] <rkirsling>
ljharb: +1

[13:02:09.0000] <shu>
Bakkot: excellent summary, thanks

[13:31:11.0000] <Bakkot>
shu I think it is less that there is disagreement about "normative", more that there are things which are not normative which people (e.g. Chip) feel should not be totally at the discretion of editors

[13:31:33.0000] <shu>
right, that's very sensible

[15:01:46.0000] <shu>
ystartsev: did you and keith schedule anything next week?

[15:19:27.0000] <keith_miller>
shu: Oh I thought it was gonna happen at the incubator meeting?

[15:20:55.0000] <shu>
keith_miller: wait -- the normative optional topic? no that wasn't my intention

[15:21:20.0000] <keith_miller>
Ah ok. Sure we can set something up.

[15:23:19.0000] <shu>
keith_miller: ystartsev: okay i'll set something up

[15:23:45.0000] <keith_miller>
Ok, thanks! are you gonna send us a doodles?

[15:23:50.0000] <shu>
yeah

[15:24:06.0000] <shu>
though that site is like, as much a cpu hog as VC software

[15:24:33.0000] <shu>
are there lighter doodle alternatives

[15:25:10.0000] <drousso>
shu i used <http://whenisgood.net> a lot in college :P

[15:25:37.0000] <drousso>
much uglier, but still very functional and super lightweight

[15:25:38.0000] <keith_miller>
shu: I have it open and it's all of Safari is using 2% of CPU? Either I need to use your VC software or somethings weird in your browser...

[15:25:49.0000] <shu>
keith_miller: there are like 6 banner ads

[15:25:52.0000] <ljharb>
whenisgood is great

[15:26:02.0000] <keith_miller>
Oh, I have content blockers

[15:26:20.0000] <shu>
keith_miller: i support the hand the feeds me i guess...

[15:26:27.0000] <shu>
that*

[15:26:35.0000] <keith_miller>
Because I hate adds more than I want to support the web lol

[15:27:20.0000] <shu>
no judgment from me

[15:31:10.0000] <drousso>
shu you could always buy a Premium account for no ads :P <http://whenisgood.net/Pricing>


2020-06-05
[18:41:05.0000] <shu>
PSA: i'm proposing the next incubator call to be on June 16 (in 2 weeks) and we talk about UUID: https://github.com/tc39/Reflector/issues/297

[11:00:33.0000] <leobalter>
shu: do you think we have enough traction for the incubator calls becoming weekly? We definitely have enough topics, IMO, what I can't say is if people would be available

[11:02:45.0000] <shu>
leobalter: would you like to propose that at the next meeting? it's too late now to adequately get the word out

[11:03:06.0000] <shu>
leobalter: i do not think i have the bandwidth to facilitate a weekly call. but if you are volunteering... ;)

[11:04:08.0000] <leobalter>
ofc. I didn't want to create bikeshed in the TC39 meeting  as we didn't have much time left by suggesting that, but that's good enough to bring up for the next meeting and we can collect feedback from the upcoming calls

[11:04:30.0000] <shu>
sgtm

[11:05:02.0000] <shu>
i support the idea, as long as there's sufficient content and interest in helping facilitate

[11:06:40.0000] <shu>
leobalter: we could even decide on a per-charter basis. if there're a lot of topics, propose weekly, otherwise every other week

[11:13:50.0000] <leobalter>
shu https://github.com/tc39/agendas/pull/790

[11:17:14.0000] <leobalter>
and just in case, I opened a Reflector issue for reference: https://github.com/tc39/Reflector/issues/300

[11:23:04.0000] <shu>
excellent, ty

[11:24:33.0000] <leobalter>
well, ty for hosting the incubator calls. I've got to say I really enjoyed the experience

[11:25:47.0000] <shu>
happy to hear that :)


2020-06-06
[17:26:08.0000] <brad4d>
I'm curious about "membranes" - can anyone point to something that explains them?

[17:26:30.0000] <brad4d>
I don't see anything on the realms proposal or its explainer as I expected to.

[17:28:33.0000] <rkirsling>
brad4d: heh, I think it has to be TC39's #1 "most discussed and least understood" topic

[17:29:23.0000] <shu>
this is the one i know: https://tvcutsem.github.io/js-membranes

[17:29:25.0000] <shu>
but it is perhaps out of date at this point

[17:32:20.0000] <Bakkot>
shu / brad4d: https://github.com/ajvincent/es-membrane

[17:33:27.0000] <shu>
so long

[17:38:01.0000] <jridgewell>
I found the two Cutsem articles most helpful, mainly because of their drawings

[17:38:20.0000] <jridgewell>
1. https://tvcutsem.github.io/js-membranes

[17:38:20.0000] <jridgewell>
2. https://tvcutsem.github.io/membranes

[17:39:35.0000] <shu>
tom's a great guy

[17:39:39.0000] <shu>
i wonder what he's up to

[17:42:56.0000] <jridgewell>
There's also the Membrane invariants, described a bit at https://docs.google.com/presentation/d/1HWM_pREmpz7QN9VrNeFt5T-x6CfKBL06pXhiQcxgfgU/edit#slide=id.g463771ef80_0_75

[17:43:03.0000] <rkirsling>
I haven't seen these Cutsem ones but they do seem more readable

[17:43:15.0000] <rkirsling>
I think I attempted to read the one Bakkot linked before


2020-06-08
[13:26:41.0000] <rkirsling>
huh. seems like JSC is the only engine that throws on legacy decimal literals `\8` (template regardless of strictness) and 'use strict'; '\8'; (strict non-template)

[13:26:58.0000] <rkirsling>
but it seems like this should be correct

[13:43:25.0000] <rkirsling>
time to write some tests, I guess

[13:49:55.0000] <avp>
rkirsling: i've been trying to understand this as well today - were multiple bug reports filed? https://github.com/facebook/hermes/issues/267

[13:50:24.0000] <rkirsling>
avp: yeah looks like it: https://bugs.webkit.org/show_bug.cgi?id=212887

[13:51:19.0000] <rkirsling>
it's weird to have a case where engines are mostly converging on a non-conformant solution but that appears to be the case, due to lack of tests

[13:53:27.0000] <avp>
rkirsling: yeah i was second guessing my reading of the spec due to multiple other engines' behavior, but it's good to see JSC agrees

[13:54:07.0000] <Bakkot>
I could swear this was tested

[13:55:06.0000] <rkirsling>
I'm honestly shocked

[13:58:00.0000] <Bakkot>
lol, looks like I added `\08` but didn't cover `\8`

[13:58:02.0000] <Bakkot>
https://github.com/tc39/test262/pull/1063

[13:58:52.0000] <rkirsling>
"noctal" haha

[14:00:20.0000] <Bakkot>
and there's https://github.com/tc39/test262/blob/master/test/language/literals/regexp/u-invalid-oob-decimal-escape.js for regexps

[14:03:06.0000] <Bakkot>
v8 actually tests that \8 and \9 are legal in templates: https://source.chromium.org/chromium/chromium/src/+/master:v8/test/mjsunit/es6/templates.js;l=509-512?q=templates.js&ss=chromium%2Fchromium%2Fsrc&originalUrl=https:%2F%2Fcs.chromium.org%2F

[14:03:35.0000] <rkirsling>
filed https://github.com/tc39/test262/issues/2653

[14:04:21.0000] <rkirsling>
ehh, it's not unusual to have lingering tests for current but no-longer-conformant behavior

[14:06:39.0000] <Bakkot>
I don't think that was ever conformant

[14:11:55.0000] <rkirsling>
er yeah that part is odd

[14:49:00.0000] <rkirsling>
and PR https://github.com/tc39/test262/pull/2654

[14:53:32.0000] <rkirsling>
heh test262 circle CI sends emails now?

[15:05:05.0000] <Bakkot>
aww, I can't see the circleCI results without authing with github, which grants read-and-write access to all my repos

[15:05:12.0000] <Bakkot>
(which I am not going to do)

[15:06:27.0000] <rkirsling>
I did it the first time without thinking much of it but I was required to re-auth just now which is super annoying


2020-06-09
[13:55:07.0000] <rkirsling>
Bakkot: avp: apparently I read the spec too wishfully and it's altogether unspecified 😅 https://github.com/tc39/ecma262/issues/2039

[13:55:49.0000] <rkirsling>
in my mind the expected behavior seems clear though; hopefully it's not just me

[14:12:49.0000] <Bakkot>
pop quiz: what does `/[\1]/.test('\u{1}')` evaluate to

[14:15:59.0000] <rkirsling>
oof

[14:16:18.0000] <rkirsling>
didn't realize `/[\1]/u` is a syntax error either

[14:16:36.0000] <Bakkot>
it isn't

[14:16:42.0000] <Bakkot>
it is not a syntax error

[14:18:58.0000] <rkirsling>
oh then that's a V8 bug whoops

[14:19:21.0000] <Bakkot>
my v8 does not give an error for that?

[14:21:07.0000] <rkirsling>
everybody but Ch gives a syntax error for me

[14:21:20.0000] <Bakkot>
uh

[14:21:35.0000] <Bakkot>
... really?

[14:21:57.0000] <rkirsling>
not for your original example

[14:22:25.0000] <Bakkot>
oh!

[14:22:29.0000] <Bakkot>
I missed the `\u`

[14:22:32.0000] <Bakkot>
*`/u`

[14:22:36.0000] <Bakkot>
yes, with the `u` it's a syntax error

[14:23:13.0000] <Bakkot>
(because the only production which would allow it is `IdentityEscape: [~U] SourceCharacterIdentityEscape [?N]`, which is gated on `~U`)

[14:25:05.0000] <rkirsling>
yeah

[14:36:03.0000] <Bakkot>
sorry, rather, it would also be allowed by `CharacterEscape :: [~U] LegacyOctalEscapeSequence`, but that's also gated)

[14:57:28.0000] <rkirsling>
shu: what's your opinion on https://github.com/tc39/ecma262/issues/2039

[14:58:20.0000] <rkirsling>
(namely whether it's worth trying to forbid \8 and \9 altogether after the fact)

[14:58:48.0000] <shu>
what in the world is \8

[15:00:36.0000] <Bakkot>
an unfortunate way of spelling `8`

[15:03:47.0000] <shu>
what does a legacy octal escape do?

[15:04:34.0000] <Bakkot>
lets you write a code point by writing its code point value in octal

[15:04:37.0000] <shu>
does it produce the ascii code?

[15:05:44.0000] <shu>
well then

[15:08:37.0000] <rickbutton>
is there a standard way that people like to use to generate spec html in a PR for a proposal repo?

[15:09:55.0000] <ljharb>
rickbutton: it's basically just `ecmarkup path/to/emu/file`

[15:10:05.0000] <shu>
rkirsling: i wholeheartedly agree with michael ficarra's preference of making them errors

[15:10:09.0000] <ljharb>
rickbutton: if the proposal is generated from the template, the machinery is already there

[15:10:17.0000] <rickbutton>
right, i mean the hosting part, like the "put it on a webserver when a PR is opened" magic

[15:10:19.0000] <Bakkot>
I assumed the question was about getting previews

[15:10:22.0000] <shu>
rkirsling: but i also do not want to do the work

[15:10:43.0000] <ljharb>
rickbutton: set your repo's github pages settings to use the master branch

[15:10:50.0000] <ljharb>
rickbutton: and then `index.html` will Just Work

[15:10:56.0000] <devsnek>
rickbutton: in the olden days people used @alrra/travis-scripts but now i think people use gh actions

[15:10:59.0000] <shu>
rkirsling: the work of figuring out if anyone depends on this awful behavior

[15:11:04.0000] <ljharb>
rickbutton: see the steps here https://github.com/tc39/template-for-proposals#create-your-proposal-repo

[15:11:09.0000] <ljharb>
ahhh

[15:11:11.0000] <rkirsling>
shu: yeah that's the thing :-/

[15:11:23.0000] <ljharb>
rickbutton: yeah if you want to *automatically* generate it you'd need something like an action

[15:11:51.0000] <ljharb>
rickbutton: devsnek: i've got one in progress for the template that auto-rebases PRs to include the updated spec text, fwiw

[15:12:20.0000] <rkirsling>
shu: I actually was only think of this in terms of surface tokens and wasn't dwelling on the fact that `"\7" !== "7"` so that makes me definitely feel like consistency with numeric literals isn't any sort of imperative here but

[15:12:27.0000] <rickbutton>
yeah I've set up something like netlify for this before, was interested to see if anyone else had done it, I can peek at other proposal repos, I feel like I've seen it before

[15:12:51.0000] <shu>
rkirsling: i don't see what consistency there is

[15:13:20.0000] <ljharb>
rickbutton: since github has github pages built in it seems unnecessary to add a dependency on an external service ¯\_(ツ)_/¯

[15:13:34.0000] <rickbutton>
ljharb: you aren't wrong, especially with github actions

[15:14:53.0000] <shu>
rkirsling: i think i'm fine with forbidding \8 and \9 tbh

[15:15:06.0000] <shu>
rkirsling: we can query http archive for \8 and \9

[15:15:24.0000] <rkirsling>
shu: yeah I think it was a naive miscategorization on my part. but if we can't collect data then I guess the only other option is "ship and see what fires arise"

[15:15:39.0000] <rkirsling>
ah that's fair

[15:15:39.0000] <shu>
well for this we *can* collect data right

[15:16:34.0000] <shu>
like it could come back there're no occurrences of \8 or \9, which seems likely to me

[15:17:00.0000] <rkirsling>
sure

[15:19:38.0000] <shu>
rkirsling: if you write some SQL and ping me to run it, sounds easy enough to figure out

[15:22:37.0000] <rkirsling>
shu: fair enough. I haven't actually looked at this before; now I get what the "don't run this" in that presentation was about 😂

[15:24:40.0000] <rkirsling>
hmm, if it only gives an occurrence count, I wonder if we need to consciously filter out regexes?

[15:25:01.0000] <shu>
it doesn't have to give an occurrence count

[15:25:11.0000] <shu>
you can have it return the page URLs or the asset URLs

[15:25:17.0000] <shu>
and then look at them manually

[15:25:25.0000] <rkirsling>
ah cool

[15:25:54.0000] <shu>
the main problem is i don't know how to use GCP

[15:25:59.0000] <shu>
or any cloud platform, for that matter

[15:34:16.0000] <rkirsling>
yeah I'm looking at the tutorial

[15:34:29.0000] <rkirsling>
who did the stuff for the subclassing query?

[15:35:12.0000] <shu>
bradleymeck and myself

[15:54:00.0000] <rkirsling>
um so simply editing that query, I think this might be reasonable

[15:54:05.0000] <rkirsling>
https://www.irccloud.com/pastebin/LcAkatsE/

[15:55:01.0000] <rkirsling>
I can try to run it myself and see if it yells about insufficient funds lol

[15:56:49.0000] <rkirsling>
oh whoa those two tables are like 20 TB together

[16:00:30.0000] <rkirsling>
shu: wdyt

[16:03:50.0000] <shu>
rkirsling: let's look at it tomorrow, no time today unfortunately

[16:03:59.0000] <rkirsling>
sgtm

[16:04:02.0000] <shu>
and yeah shit is huge

[16:06:40.0000] <shu>
i'm not *this* much of a capitalist, but suppose if we didn't have access to a corp-sponsored GCP instance and had to spend our own money to even begin asking a web compat question

[16:06:53.0000] <shu>
i wonder what our calculus will be

[16:07:25.0000] <shu>
"is changing behavior at least worth the $XXX in compute"

[16:14:39.0000] <ljharb>
so it'd be in the 3 digit range?

[16:15:44.0000] <ljharb>
(that's a genuine q, i actually have no idea how much it'd cost)

[16:22:28.0000] <rkirsling>
I'm seeing 5 USD / TB

[16:23:18.0000] <ljharb>
how many tibs does a web compat check typically take tho

[16:24:51.0000] <rkirsling>
seems like "20 if you don't make a mistake"?

[16:25:25.0000] <ljharb>
i mean, $100 to figure out if we can unmake a mistake in the ecosystem where mistakes can never be unmade seems like a bargain?

[16:26:05.0000] <ljharb>
like i feel like it wouldn't be hard to find a dozen developers somewhere who'd happily sponsor $100 to fix some little edge case

[16:26:14.0000] <rkirsling>
sure; to be clear, I meant a mistake in the query, since it's kind of like really expensive punchcards

[16:27:12.0000] <ljharb>
fair

[16:27:30.0000] <ljharb>
but i mean like, i feel like it'd be easy to raise thousands for something like this, which would give multiple tries

[16:27:34.0000] <ljharb>
i dunno tho, i've obv never tried it

[16:47:49.0000] <Bakkot>
personally I prefer spending Google's money if that's an option

[16:48:35.0000] <rkirsling>
thankfully that appears to be the present situation


2020-06-10
[17:01:51.0000] <ljharb>
well yes, ofc :-)

[18:06:25.0000] <keith_miller>
ljharb: Is there anything I need to do to get my PR landed?

[18:06:44.0000] <keith_miller>
Or is it waiting on someone more reviews?

[18:06:49.0000] <keith_miller>
/me doesn't know the process that well

[18:08:37.0000] <rkirsling>
looks like it's effectively on the docket for merge

[18:15:33.0000] <shu>
ljharb: yes, i think when the benefits of undoing a mistake is undeniable

[18:15:45.0000] <shu>
ljharb: but in the case of disallowing \8 and \9

[18:15:49.0000] <shu>
i mean, i don't _like_ it

[18:15:53.0000] <shu>
but who runs into that?

[18:20:35.0000] <devsnek>
my billion dollar business will topple to the ground if \8 isn't handled correctly

[18:21:01.0000] <keith_miller>
devsnek: I can fix that in JSC... for a price

[18:21:21.0000] <keith_miller>
:P

[18:21:24.0000] <devsnek>
🤑

[18:24:07.0000] <shu>
i'll fix it for $5 less than what keith charges

[18:24:35.0000] <keith_miller>
I'm charging $4 so you owe devsnek a $

[18:25:20.0000] <devsnek>
i approve of this

[18:25:35.0000] <shu>
have you learned nothing from VC-funded wealth

[18:25:45.0000] <shu>
i lose $ now, and maybe i'll keep losing $ for 5 years

[18:25:55.0000] <shu>
but one day i'll go public once i have cornered the \8 market

[18:26:27.0000] <keith_miller>
shu: How's Google going to feel that you've cornered one third of their \/8 market?

[18:27:01.0000] <shu>
whoa whoa nobody said that

[18:27:14.0000] <rkirsling>
lol

[18:27:25.0000] <shu>
the logs need to be scrubbed

[18:27:42.0000] <devsnek>
i didn't see nothin'

[18:30:20.0000] <keith_miller>
lol

[18:30:43.0000] <rkirsling>
isn't it two-thirds though

[18:30:52.0000] <rkirsling>
or am I misinterpreting the joke

[18:31:20.0000] <keith_miller>
Yeah my b

[18:31:28.0000] <keith_miller>
Gotta work fast

[19:07:56.0000] <ljharb>
keith_miller: generally once 3 editors have stamped it and it has no X’s, i merge it within a few hours

[19:08:05.0000] <ljharb>
keith_miller: so in this case it needs one more editor to stamp it

[19:08:16.0000] <keith_miller>
🤞

[19:08:20.0000] <keith_miller>
Thanks

[19:08:50.0000] <ljharb>
shu: lol true but like, the future is longer than the past, and $1000 to merely make something more consistent sounds worth it to me

[19:09:05.0000] <ljharb>
I’ve spent more money on far more inconsequential things

[12:30:41.0000] <rkirsling>
what is the idea of having NotEscapeSequence be an escape sequence for tagged templates?

[12:31:29.0000] <rkirsling>
like, it would be one thing if it gave you the raw characters

[12:48:13.0000] <rkirsling>
er well TV is `undefined` so I guess saying it "is an escape sequence" is a stretch, but still

[12:53:47.0000] <Bakkot>
rkirsling I don't understand the question

[12:54:07.0000] <Bakkot>
do you mean, why does the grammar talk about those at all? It's so String.raw`\xGG` works.

[13:09:43.0000] <rkirsling>
ah hm

[13:11:00.0000] <rkirsling>
but it seems like foo`...` is neither

[13:11:46.0000] <Bakkot>
is neither what?

[13:12:54.0000] <rkirsling>
neither a raw \ nor an error

[13:15:07.0000] <Bakkot>
tthere's no backslash there?

[13:15:13.0000] <Bakkot>
why would you expect a  `\`

[13:15:32.0000] <rkirsling>
sorry I didn't mean literally ...

[13:15:45.0000] <rkirsling>
I'm just really confused, partially because engines aren't agreeing

[13:15:49.0000] <Bakkot>
can you give a concrete example?

[13:15:53.0000] <rkirsling>
foo`\8`

[13:16:03.0000] <rkirsling>
is the main point

[13:16:16.0000] <Bakkot>
that looks like a NotEscapeSequence to me

[13:16:24.0000] <rkirsling>
yeah so JSC just has undefined

[13:16:51.0000] <Bakkot>
undefined is correct per spec, pretty sure

[13:16:52.0000] <rkirsling>
(other engines just escape the `8`)

[13:16:53.0000] <rkirsling>
yeah

[13:16:58.0000] <rkirsling>
I believe so

[13:17:05.0000] <Bakkot>
"The TV of TemplateCharacter::\NotEscapeSequence is undefined."

[13:17:43.0000] <rkirsling>
I was just saying that I'm surprised that it's neither an error (like an untagged template) nor raw characters (meaning that String.raw is not something you can make in userland)

[13:18:10.0000] <Bakkot>
oh, you get the raw characters

[13:18:14.0000] <Bakkot>
they're on the `.raw` property of the array

[13:18:25.0000] <Bakkot>
that's how tagged templates work in general

[13:19:15.0000] <rkirsling>
ohh

[13:20:44.0000] <rkirsling>
thanks

[13:52:23.0000] <shu>
my honey?

[13:52:30.0000] <shu>
what does that mean

[13:52:37.0000] <shu>
oops, wrong window :P

[14:28:49.0000] <ljharb>
rofl

[14:35:47.0000] <drousso>
🤣

[15:37:24.0000] <shu>
i could try to explain, but i think that'll only make things worse


2020-06-12
[17:28:56.0000] <shu>
as it turns out, it is super hard to use weakrefs correctly, whoda thought

[17:45:12.0000] <devsnek>
whatcha' weakref'n

[17:47:55.0000] <drousso_>
really?

[17:48:02.0000] <drousso_>
i'd love to know more

[17:48:15.0000] <drousso_>
i have plans/hopes to use them quite extensively for certain things

[17:48:43.0000] <shu>
i was writing an example for a talk which wraps event listeners in weakrefs so you don't have to manually unregister event listeners

[17:48:47.0000] <shu>
since that's a super common way to leak memory

[17:49:12.0000] <shu>
my example had a class like so:

[17:49:33.0000] <devsnek>
i don't think i've ever heard of memory being leaked via event listeners

[17:49:38.0000] <devsnek>
except code that accidentally attaches them in a loop

[17:52:47.0000] <shu>
https://gist.github.com/syg/13d44f2b1a36095a90f722a1b84e6da2

[17:53:04.0000] <shu>
if you forget to unregister an event listener when you close a panel, for instance, it tends to leak everything the listener held onto

[17:54:31.0000] <shu>
it is my impression that's a common gotcha in frontend programming

[17:54:52.0000] <shu>
oops, that gist has a bug

[17:55:23.0000] <shu>
reload please

[17:55:45.0000] <shu>
drousso_: can you spot the bug? `this.listener` isn't collectable in V8's GC

[17:55:51.0000] <shu>
and i reckon in JSC's GC as well

[17:56:14.0000] <drousso_>
shu that's actually one of the primary use cases i'd want 😅

[17:56:27.0000] <drousso_>
Web Inspector has it's own event listener system which keeps things alive

[17:56:30.0000] <shu>
drousso_: yep!

[17:56:40.0000] <drousso_>
using a `WeakRef` to hold the `thisObject` would likely eliminate that issue

[17:56:46.0000] <shu>
there're plenty of google JS code that has some notion of "observer" that gets misused

[17:56:51.0000] <shu>
and leaks craptons

[17:57:00.0000] <devsnek>
the listener function isn't collectable?

[17:57:03.0000] <shu>
nope

[17:57:09.0000] <drousso_>
shu is the issue that `this` is captured by the arrow function?

[17:57:13.0000] <shu>
it's for a really shitty subtle reason

[17:57:25.0000] <shu>
drousso_: bingo, specifically, this chain:

[17:57:32.0000] <shu>
- this.listener captures `this`

[17:57:35.0000] <drousso_>
ya

[17:57:41.0000] <devsnek>
but `this` is the only thing that holds it

[17:57:47.0000] <devsnek>
isn't that a normal cycle

[17:57:51.0000] <shu>
- the wrapper arrow function is held onto strongly by the holdings of the FR

[17:58:16.0000] <drousso_>
shu i agree that that's a pretty massive footgun

[17:58:20.0000] <shu>
the wrapper arrow holds alive the environment of the function

[17:58:21.0000] <devsnek>
oh the other arrow function

[17:58:41.0000] <shu>
the environment has references to two things: the `this`, and `weakRef`

[17:58:54.0000] <devsnek>
y'all should not capture `this` if nothing inside references it

[17:58:56.0000] <drousso_>
shu if you're curious, i prototyped a patch for Web Inspector's event listener system to use `WeakRef` <https://webkit.org/b/196956>

[17:59:09.0000] <shu>
which means the FR can reach the `this` in the environment, and thus `this.listener`, making `this.listener` held alive by the FR

[17:59:09.0000] <drousso_>
the way i did it was just to manually change it so that we never used an arrow function :P

[17:59:28.0000] <shu>
devsnek: V8 tried a patch to split the environment so that there are different environments for different inner closures

[17:59:32.0000] <Bakkot>
off

[17:59:37.0000] <drousso_>
the majority of Web Inspector's event listener usage is bound to a prototype function anyways (i.e. non-local non-anonymous functions) so it's not that bad IMO

[17:59:43.0000] <Bakkot>
*oof

[17:59:50.0000] <shu>
e.g., in that example, the first arrow only captures `this`, but the second arrow only captures `weakRef`, so they shouldn't both capture the *same* environment that has both things alive

[17:59:59.0000] <shu>
that patch ended up causing memory regressions and couldn't land

[18:00:02.0000] <shu>
so there is no easy answer atm

[18:00:04.0000] <devsnek>
aw

[18:00:09.0000] <Bakkot>
I do not think we should be telling webdevs about weakrefs

[18:00:14.0000] <shu>
haha

[18:00:22.0000] <Bakkot>
weakrefs are for chains with wasm, and for no other purpose

[18:00:28.0000] <Bakkot>
s/chains/cycles/

[18:00:29.0000] <shu>
drousso_: yeah, bind() is okay for V8

[18:00:39.0000] <drousso_>
oh we don't even use `bind()`

[18:00:44.0000] <drousso_>
sorry i should've clarified

[18:00:46.0000] <devsnek>
Bakkot: web devs write wasm now

[18:00:47.0000] <shu>
Bakkot: fwiw i do think the event listener case *is* compelling

[18:00:53.0000] <Bakkot>
devsnek no they don't

[18:00:54.0000] <shu>
you almost never want to hold onto event listeners strongly

[18:00:55.0000] <Bakkot>
devsnek their tools do

[18:01:09.0000] <devsnek>
nah they manually write the heap implementation

[18:01:12.0000] <drousso_>
shu because we have our own Event Listener system, we allow the `thisObject` to passed in along with the `listener`, which are both held by the `eventTarget`

[18:01:21.0000] <Bakkot>
devsnek well, they should not do that either

[18:01:26.0000] <shu>
drousso_: ah ha

[18:01:27.0000] <Bakkot>
webdevs use weakrefs too I'm sure

[18:01:30.0000] <Bakkot>
but, like, don't

[18:01:37.0000] <devsnek>
i use weakrefs sometimes

[18:01:40.0000] <drousso_>
shu this way we can avoid creating new functions when using a prototype/class function as the `listener`

[18:01:47.0000] <shu>
i mean the "you must be this tall to ride" is like 10ft

[18:01:47.0000] <devsnek>
i should check for that in my usage of them

[18:02:00.0000] <shu>
because it requires you to understand, like this example shows, to understand not only the GC but how closures are represented

[18:02:05.0000] <shu>
which seems unreasonable to ask of for most web devs

[18:02:06.0000] <Bakkot>
shu I clean up my listeners manually when I'm done with them, which seems... obviously superior?

[18:02:18.0000] <Bakkot>
I guess this is the manual vs automatic memory management debate

[18:02:23.0000] <shu>
Bakkot: correct

[18:02:37.0000] <Bakkot>
except that the automatic one is way harder to use because it is not automatic at all

[18:02:39.0000] <devsnek>
why do js devs not leaksan

[18:02:48.0000] <drousso_>
Bakkot the "problem" with that is knowing when you're done with them

[18:03:01.0000] <drousso_>
it's totally doable

[18:03:10.0000] <shu>
Bakkot: at even google levels of effort, whatever you take that to mean, there is evidence that manual management does not scale to complex projects, like GSuite

[18:03:12.0000] <drousso_>
just can be hard to keep track of as the size of something increases

[18:03:14.0000] <shu>
leaks abound

[18:03:22.0000] <shu>
there is a Disposable pattern that people recommend using

[18:03:24.0000] <drousso_>
^ same here

[18:03:26.0000] <shu>
but it is buggy

[18:04:19.0000] <Bakkot>
shu I am not convinced leaks will go down if we tell people about weakrefs, though

[18:04:28.0000] <shu>
that's a separate discussion

[18:04:35.0000] <drousso_>
i think it's more library/framework authors that'll benefit

[18:04:35.0000] <shu>
i definitely agree most people will use them wrong

[18:04:45.0000] <shu>
but yeah i agree with drousso_

[18:04:52.0000] <Bakkot>
right, so, we shouldn't tell webdevs about weakrefs :P

[18:04:57.0000] <shu>
i want the framework people at the big web property cos to hear about it

[18:05:00.0000] <drousso_>
lol

[18:05:18.0000] <drousso_>
ah poop i gtg

[18:05:23.0000] <devsnek>
when someone asks about weakrefs "who's asking 👀"

[18:05:25.0000] <drousso_>
have a good night yall :)

[18:05:29.0000] <drousso_>
(or equivalent wherever you are)

[18:05:33.0000] <shu>
g'night

[18:05:52.0000] <Bakkot>
we should get yusuke or someone to write a library that does the right thing and tell people about that instea

[18:05:56.0000] <Bakkot>
d

[18:06:58.0000] <Bakkot>
maybe I'll ask Gilad if he wants to do that after his current project

[18:07:04.0000] <Bakkot>
the answer will be no, though

[18:07:20.0000] <shu>
gilad?

[18:07:49.0000] <Bakkot>
https://en.wikipedia.org/wiki/Gilad_Bracha

[18:08:10.0000] <Bakkot>
used to sit two desks over from me, back when being proximate to other people was not illegal

[18:08:45.0000] <devsnek>
oh he made java

[18:08:56.0000] <shu>
ah *the* gilad

[18:08:57.0000] <shu>
he's at f5?

[18:09:12.0000] <Bakkot>
yeah, joined Shape a few months before the acquisition

[18:09:41.0000] <shu>
oh wow, good catch

[18:09:49.0000] <shu>
sure ask away, i'm also sure it'll be a no

[18:09:56.0000] <rkirsling>
lol he made a Newspeak language with all sorts of associated 1984 references?

[18:10:00.0000] <rkirsling>
amusing

[07:37:32.0000] <littledan>
shu: Everyone's been talking about this observer pattern as a primary use case; it'd be great to have some code for this in the WeakRefs README so people can use it as a "cookbook"

[07:37:48.0000] <littledan>
once you work it out correctly...

[08:08:24.0000] <shu>
littledan: a cookbook sounds good...


2020-06-13
[21:07:25.0000] <jridgewell>
Seems like `WeakRef`s need some basic sanity tests in test262

[21:08:12.0000] <leobalter>
jridgewell do you mean the recent changes?

[21:08:25.0000] <jridgewell>
shu's https://gist.github.com/syg/13d44f2b1a36095a90f722a1b84e6da2 example

[21:08:39.0000] <jridgewell>
An engine optimization prevents GC

[21:09:30.0000] <jridgewell>
Because the two arrows share a function context, and one uses `this`, so both strongly hold the `this`.

[07:08:45.0000] <littledan>
jridgewell: The WeakRef spec allows JS engines to leak as much as they want, formally speaking

[07:09:29.0000] <littledan>
we *expect* that there will be engine-specific leaks as well as leaks that are in common between engines

[07:09:37.0000] <littledan>
engines may also arbitrarily delay collection and then do it some time later

[08:08:06.0000] <shu>
jridgewell: yeah i agree with dan

[08:08:23.0000] <shu>
my example is the faustian bargain for weakrefs

[08:12:23.0000] <shu>
should not test reachability of implementation choices

[08:58:49.0000] <devsnek>
this came up a while ago when i was trying to verify the weakref spec in engine262

[08:59:42.0000] <devsnek>
the implementation-contributed directory in test262 could include more aggressive tests that match real-world expectations

[09:04:37.0000] <leobalter>
devsnek I’ve discussed this from time to time, Test262 can’t enforce behavior not demanded by the specs. Implementation defined/dependent are blockers for full comprehensive tests.

[09:05:12.0000] <devsnek>
leobalter: isn't the the "implementation-contributed" directory for that purpose?

[09:05:18.0000] <devsnek>
like it has tco tests and stuff

[09:05:31.0000] <devsnek>
well lackthereof tco tests

[09:05:39.0000] <leobalter>
Nope. That directory is a simply upstream to be then converted to Test262

[09:06:05.0000] <devsnek>
interesting

[09:06:33.0000] <leobalter>
There was no time available to convert all of these tests.

[09:07:01.0000] <devsnek>
would be interesting to have some shared "real world" tests

[09:07:33.0000] <leobalter>
Not on Test262

[09:08:20.0000] <devsnek>
how come

[09:08:25.0000] <leobalter>
As I said, I’ve discussed this from time to time. Test262 goal is to provide tests for the specs. I’d be up for a different repo with other tests meant to be shared among implementations

[09:09:53.0000] <leobalter>
If we cannot specify, why should we enforce tests? The project is also big enough and very hard to maintain.

[09:11:20.0000] <leobalter>
We have specific requirements in order to have the tests available/compatible for those using it. The other general tests follow a lot of implementation specific testing api

[09:13:59.0000] <leobalter>
It’s Saturday. I’d be happy to have a call and discuss more shared collaboration.

[09:14:11.0000] <leobalter>
During the week, ofc


2020-06-15
[11:20:43.0000] <leobalter>
Hi everyone! I'm gonna follow this guide from Godfrey Chan to set Test262's default branch to `main`. https://github.com/chancancode/branch-rename#gradual-migration

[11:21:02.0000] <leobalter>
I'll ping this channel back and I have some of the GitHub actions running.

[11:21:18.0000] <leobalter>
is Godfrey here?

[12:00:16.0000] <leobalter>
plans aborted for now. I need to find out a plan for mirroring protected branches


2020-06-16
[06:16:43.0000] <leobalter>
ECMA-262 + ECMA-402 2020 Editions approved.

[06:17:06.0000] <leobalter>
<sarcasm>(Now you can start using the new features.</sarcasm>

[14:16:18.0000] <rkirsling>
spec-editing question

[14:17:26.0000] <rkirsling>
if B.1.1 has a NonOctalDigit production and I want to use it in B.1.2 too, should I just duplicate it? is there going to be a problem with reusing that name?

[14:19:36.0000] <rkirsling>
(oh wait I might not need it, I think I can just inline the 8 and 9 since multi-digit numbers aren't allowed)

[14:40:16.0000] <Bakkot>
It would be fine to just use it, I think; that production does not have different variants in the main spec vs annex B so there's no chance of ambiguity

[14:40:29.0000] <Bakkot>
sidebar: I do want to get back to the "upstream annex b" project someday

[14:40:30.0000] <Bakkot>
someday...

[14:43:18.0000] <rkirsling>
oh they're essentially globals?

[14:43:45.0000] <rkirsling>
yeah Claude suggested merging B.1.2 in while I'm at it but that's a much larger change

[14:43:55.0000] <rkirsling>
another q:

[14:44:05.0000] <rkirsling>
can this line be deleted?

[14:44:10.0000] <rkirsling>
> The SV of EscapeSequence::LegacyOctalEscapeSequence is the SV of LegacyOctalEscapeSequence.

[14:44:58.0000] <rkirsling>
the main spec seems to assume such things without stating them

[14:45:53.0000] <rkirsling>
i.e. there is no "The SV of EscapeSequence :: CharacterEscapeSequence", there's just "The SV of CharacterEscapeSequence :: ..."

[14:46:21.0000] <Bakkot>
yeah, see https://tc39.es/ecma262/#sec-algorithm-conventions-syntax-directed-operations

[14:46:29.0000] <Bakkot>
Unless explicitly specified otherwise, all chain productions have an implicit definition for every operation that might be applied to that production's left-hand side nonterminal. The implicit definition simply reapplies the same operation with the same parameters, if any, to the chain production's sole right-hand side nonterminal and then returns the result.

[14:48:41.0000] <rkirsling>
nice, thanks!

[15:05:30.0000] <rkirsling>
oh shit

[15:05:47.0000] <rkirsling>
does this affect B.1.4 too given that LegacyOctalEscapeSequence is used there too?

[15:06:21.0000] <rkirsling>
it does...

[15:07:16.0000] <Bakkot>
b.1.4 already has IdentityEscape, which allows \8 and \9 (meaning 8 and 9) in regexp literals

[15:07:21.0000] <rkirsling>
ohh

[15:07:23.0000] <Bakkot>
so I don't think it really matters

[15:08:04.0000] <rkirsling>
SourceCharacterbut not one of c (or k)

[15:08:11.0000] <rkirsling>
yeah okay cool

[15:08:15.0000] <rkirsling>
almost missed that somehow

[15:44:48.0000] <rkirsling>
ugh why won't these productions link

[15:59:56.0000] <rkirsling>
I swear this used to work


2020-06-17
[18:14:17.0000] <keith_miller>
ljharb: Bakkot: Thanks for the reviews on my patch! Much appreciated.


2020-06-18
[12:09:29.0000] <rkirsling>
hmm looks like the time in the doodle is assuming ET instead of PT

[12:21:29.0000] <rkirsling>
oh it's the September one that just got created

[12:22:01.0000] <rkirsling>
so still wrong time zone but should be JST :p

[12:31:25.0000] <ljharb>
rkirsling: ping patrick on that issue and ask him to fix it

[12:31:31.0000] <ljharb>
(if you don't mind)

[12:31:38.0000] <rkirsling>
I did reply

[12:31:55.0000] <rkirsling>
I can add an @ for good measure

[12:33:01.0000] <ljharb>
cool thanks

[14:39:54.0000] <rkirsling>
huh, apparently twitter now has lists and e.g. W3C staff has one https://twitter.com/i/lists/9808561

[14:40:03.0000] <rkirsling>
wonder if we should have a TC39 one 🤔

[14:56:42.0000] <jridgewell>
That would be cool

[14:57:46.0000] <Bakkot>
twitter has had lists for ages, no?

[14:59:24.0000] <rkirsling>
not sure

[14:59:28.0000] <rkirsling>
https://usercontent.irccloud-cdn.com/file/osypOy7x/image.png

[15:00:01.0000] <rkirsling>
tweetdeck certainly has lists that you create for yourself, but...

[15:00:08.0000] <Bakkot>
https://mashable.com/2009/11/02/twitter-lists-guide/

[15:37:35.0000] <ljharb>
yes, twitter's had lists for a long time

[15:37:41.0000] <ljharb>
the TC39 account could certainly make one

[15:48:56.0000] <rkirsling>
I wonder what's "new" then, specifically


2020-06-19
[19:19:57.0000] <ljharb>
ah, maybe the discovery mechanism

[19:20:06.0000] <ljharb>
lists weren't browseable before except from a specific user's profile


2020-06-21
[07:57:55.0000] <howdoi>
If were to publish a post about a proposal, do we mention just the authors or the champions too?

[08:04:08.0000] <ryzokuken>
howdoi: it's ideal to mention both the authors and champions.

[08:04:50.0000] <ryzokuken>
I mean, also, why not? 😇

[08:05:06.0000] <howdoi>
ryzokuken: agree, but I have heard few cases where champions didn't want their names to be mentioned

[08:08:40.0000] <ryzokuken>
Oh, I didn't. Well, in those cases I suppose it's best to leave them out.

[08:09:00.0000] <ryzokuken>
But like... I default to including everyone.

[08:14:37.0000] <howdoi>
Nods, would like to hear other opinions, also if there is a formal process


2020-06-22
[20:09:26.0000] <Bakkot>
there is not a formal process

[20:09:44.0000] <Bakkot>
that said, I'd suggest reaching out to the relevant people, including authors and champions, first

[20:09:51.0000] <Bakkot>
if nothing else to make sure you don't misrepresent their positions

[22:23:30.0000] <ljharb>
imo, definitely always ask first before you post about somebody. that said, if someone's championing a proposal they've kind of signed up for their name to be associated with it, so i'd be surprised if that was a problem

[22:38:27.0000] <ljharb>
did we want `eval?.(x)` to be considered a direct eval? https://github.com/tc39/test262/pull/2667

[22:38:36.0000] <ljharb>
it seems like we could choose to make it indirect

[22:45:02.0000] <rkirsling>
pretty sure that's a spec bug

[22:48:11.0000] <rkirsling>
JSC/SM/V8 all have a direct eval and I understood the intention to be "act as if the ?. weren't there"

[22:48:31.0000] <ljharb>
that's what the test is testing

[22:48:40.0000] <ljharb>
i'm asking, should `eval?.()` be an indirect eval instead

[22:48:46.0000] <ljharb>
because we want less direct evals, not more

[22:49:22.0000] <rkirsling>
I always have trouble remembering the implication there

[22:49:58.0000] <rkirsling>
but the point is we're not assigning anything

[22:52:18.0000] <ljharb>
sure, but given that `x?.(...a)` arguably desugars to `do { const tmp = x; tmp === null | tmp === undefined ? tmp : tmp(...a) }`, that'd be an indirect eval :-D

[22:54:42.0000] <rkirsling>
lol lol

[22:54:51.0000] <rkirsling>
oops

[22:54:56.0000] <rkirsling>
just meant one lol

[22:56:52.0000] <rkirsling>
I don't think that reflects anyone's actual viewpoint though

[22:58:11.0000] <rkirsling>
the user viewpoint can just think of ?: or && and the AST viewpoint can just wrap the eval call in an optional node

[22:58:30.0000] <ljharb>
sure, i get the easy arguments to direct

[22:58:41.0000] <ljharb>
i'm just wondering if it's a missed opportunity to kill more direct eval calls

[23:10:28.0000] <leobalter>
I wish we could have avoided the optional call form. This has sailed.

[23:10:55.0000] <ljharb>
is it really a web compat issue to change tho?

[23:11:29.0000] <leobalter>
It seems reasonable to have it as an indirect eval. I can’t read the specs right now (no computer at Sunday night policy at home)

[23:11:51.0000] <leobalter>
What does the spec says today?

[23:12:01.0000] <leobalter>
/me is lazy

[23:15:43.0000] <ljharb>
oh i assume it says it's direct, from that test262 PR, let me check

[23:24:28.0000] <ljharb>
"direct eval" links to https://tc39.es/ecma262/#sec-function-calls-runtime-semantics-evaluation , but it deals with cover grammars and MemberExpression and i can't tell if `?.` is part of that

[23:31:38.0000] <rkirsling>
the test262 PR is saying it's indirect

[23:31:45.0000] <rkirsling>
that's why I said there's a spec bug

[23:31:51.0000] <ljharb>
ohhhh ok

[23:32:03.0000] <ljharb>
i misread the OP then

[23:32:11.0000] <ljharb>
indirect seems better to me

[23:32:52.0000] <rkirsling>
yeah but everybody shipped with the intent of direct is the point

[23:33:24.0000] <leobalter>
PR is saying that, but apparently engines disagree. I’ll check the spec tomorrow.

[23:33:25.0000] <rkirsling>
it's possible Claude did that intentionally and none of us knew what to look for, but

[23:33:51.0000] <ljharb>
i hope it's an engine bug tbh

[23:34:20.0000] <rkirsling>
I think it's a spec bug either way if everyone read it wrong

[23:34:55.0000] <ljharb>
fair

[23:39:25.0000] <rkirsling>
hmmmmmmmmm

[23:39:26.0000] <rkirsling>
https://github.com/tc39/proposal-optional-chaining/issues/21

[23:40:57.0000] <ljharb>
looks like it's intentional

[23:42:32.0000] <rkirsling>
never heard of `(0,eval)(foo)` but if "going out of one's way for indirect eval" is a thing then I guess that'd give `eval?.()` a reason to exist beyond like, "it seemed weirder to ban it" (which was my understanding)

[23:43:32.0000] <ljharb>
new forms of direct eval are what should imo be avoided

[23:44:16.0000] <ljharb>
(`(0,x.y)()` is a common form in babel output for "don't bring the receiver along", fwiw)

[23:46:29.0000] <rkirsling>
ah cool

[23:46:37.0000] <rkirsling>
that's good to know

[23:51:22.0000] <ljharb>
i also often use it when i don't want nasty ES6 name inferencing breaking my anonymous function test cases

[23:52:32.0000] <rkirsling>
guess you'll have to apply that to logical assignment too then

[23:52:37.0000] <rkirsling>
that's too bad

[23:52:43.0000] <ljharb>
yup

[10:25:56.0000] <howdoi>
Bakkot: roger that!

[10:27:10.0000] <leobalter>
ljharb rkirsling: ok, reading specs ... I believe it's indirect. I can stress it out with step by step, not to long but can be boring

[10:28:40.0000] <ljharb>
thanks, i'd love to understand if you have the time :-)

[10:47:56.0000] <leobalter>
I'm writing it all down

[10:54:50.0000] <leobalter>
ljharb: rkirsling https://gist.github.com/leobalter/0b32f73470b134617bed170492cd2089

[10:55:18.0000] <leobalter>
please correct me if I'm wrong. It's Monday morning :)

[10:59:02.0000] <devsnek>
wouldn't be a monday morning without some discussion of indirect eval

[11:01:35.0000] <ljharb>
leobalter: i'm not clear on how you get from EvaluateCall to eval()

[11:03:41.0000] <devsnek>
ljharb: Call() calls eval

[11:03:50.0000] <devsnek>
the actual %eval%

[11:05:01.0000] <ljharb>
where does the fourth arg to `PerformEval` come from?

[11:05:22.0000] <devsnek>
https://tc39.es/ecma262/#sec-eval-x

[11:07:42.0000] <leobalter>
EvaluateCall, step 7, the Call will defer to eval, as devsnek mentioned. I just skipped that part but you can go to Call, then F.[[Call]] and https://tc39.es/ecma262/#sec-built-in-function-objects-call-thisargument-argumentslist

[11:11:03.0000] <ljharb>
ohh i see

[11:11:04.0000] <ljharb>
thanks

[11:11:07.0000] <ljharb>
makes sense to me

[11:11:26.0000] <devsnek>
https://gc.gy/60554244.png

[11:11:42.0000] <devsnek>
classic case of having too much abstraction

[11:45:53.0000] <devsnek>
doesn't this mean that babel/ts transforms for optional chaining are incorrect for eval?.()

[11:59:56.0000] <shu>
i feel like eval?.() should not be indirect eval

[12:01:14.0000] <ljharb>
why not

[12:01:15.0000] <ljharb>
?

[12:06:20.0000] <ljharb>
i can see the argument both ways, ofc, but it seems like when either answer makes sense we should pick the one that avoids the bad thing

[12:07:43.0000] <shu>
because the original motivation was analyzability, and a global `eval?.()` is perfectly analyzable. and a pretty weak simplicity argument: less stuff to remember if the property is "non-member calls to e-v-a-l" instead of "non-member non-optional calls to e-v-a-l-("

[12:08:03.0000] <shu>
the second argument being pretty weak since maybe for some folks just remembering "e-v-a-l-(" is the easier thing

[12:08:04.0000] <ljharb>
interesting, i didn't know the original motivation

[12:08:52.0000] <shu>
ljharb: it is THE backwards breaking change. without saying indirect eval didn't have access to the local bindings, i honestly think JS wouldn't have taken off the way it has

[12:09:28.0000] <ljharb>
i mean, i think i get why indirect eval matters

[12:09:39.0000] <ljharb>
i didn't think about it in terms of analyzability

[12:11:33.0000] <shu>
yeah we wouldn't have been able to put bindings on-stack otherwise

[12:12:42.0000] <devsnek>
direct eval is big deopt

[12:12:49.0000] <leobalter>
shu: in this case we need a normative change. I'm not opposed to any direction we pick. I'd prefer consistency with what web developers expect. And as a web dev, I see `eval?.(x)` as `eval ?? eval(x)`, in the direct form. That's totally debatable.

[12:13:18.0000] <shu>
leobalter: yeah, i agree we should err towards minimizing surprises for this one

[12:13:27.0000] <shu>
there're no good first-principles arguments

[12:13:35.0000] <devsnek>
i think the whole direct/indirect thing is weird enough that there is no useful rule to follow

[12:13:52.0000] <ljharb>
right, i think we can revisionist history to justify either decision equally

[12:14:22.0000] <devsnek>
https://gc.gy/60558260.png

[12:15:40.0000] <rkirsling>
PRNG has spoken

[12:21:01.0000] <rkirsling>
but yeah I don't want to implement this unless we're sure

[12:21:18.0000] <rkirsling>
seeing as we have consistency in what's shipping right now

[12:21:31.0000] <rkirsling>
it's a little weird to me that SM moved so quickly

[12:21:55.0000] <leobalter>
I wonder who is relying on eval today (they do exist, right?) and what they really expect. I'd find odd of anyone relying on the very specific `eval?.(x)` case. The test came in after an implementation for ESLint, so I don't think they care if it's direct eval or not other than for spec consistency.

[12:24:41.0000] <jridgewell>
I'm fine with whichever we choose

[12:24:59.0000] <jridgewell>
Side note: `eval ?? eval(x)` is incorrect, because it won't eval the RHS

[12:25:34.0000] <jridgewell>
I think we should add interrobang operator `!?` to do "RHS if LHS is non-nullish"

[12:29:00.0000] <rkirsling>
I can understand an argument for utility if `eval?.()` is easier than `(0,eval)()` but I don't think that implies that it's intuitive

[12:29:21.0000] <rkirsling>
it's kind of a fancy hack

[12:30:18.0000] <shu>
yeah i guess i don't really care

[12:30:49.0000] <jridgewell>
I think the easier option is to make it a direct eval

[12:31:15.0000] <jridgewell>
Because every implementation (except engine262) and transpiler uses direct eval

[12:32:09.0000] <jridgewell>
Ooo, XS does indirect, too.

[12:32:22.0000] <rkirsling>
yeah I think the reason we all agreed on it was because we were all understanding that the behavior of ?. is meant to be just the behavior without it, when the LHS is non-nullish

[12:32:58.0000] <jridgewell>
That makes sense to me.

[12:33:15.0000] <leobalter>
that was me trying to be smart instead of using &&

[12:34:29.0000] <ljharb>
jridgewell: wait, how is that incorrect

[12:34:45.0000] <ljharb>
jridgewell: `x?.(y)` is like `x ?? x(y)`, no? including the short-circuiting?

[12:34:57.0000] <ljharb>
(just not including the double evaluation of x)

[12:35:09.0000] <rkirsling>
no there's no call if you're satisfied with `x`

[12:35:11.0000] <jridgewell>
`x ?? y` is `x == null ? y : x`

[12:35:28.0000] <jridgewell>
`x?.()` is `x == null ? undefined : x()`

[12:36:29.0000] <jridgewell>
So `x ?? x()` is `x == null ? x() : x`

[12:36:41.0000] <jridgewell>
We invoke a `null`/`undefined`

[12:36:53.0000] <ljharb>
oh right, the opposite

[12:36:57.0000] <jridgewell>
Yah

[12:37:03.0000] <ljharb>
so it'd be like `x ‽ x(y)` i guess

[12:37:14.0000] <jridgewell>
So, interrobang does a not-nullish check, instead of a nullish check.

[12:37:18.0000] <ljharb>
right

[12:37:36.0000] <rkirsling>
or &&

[12:37:41.0000] <ljharb>
would it be !? or ?! tho

[12:37:45.0000] <jridgewell>
I like it because interrobangs should be a thing

[12:37:47.0000] <rkirsling>
?. is a more precise &&, ?? is a more precise ||

[12:37:56.0000] <jridgewell>
And `!?` reads "not nullish"

[12:38:19.0000] <ljharb>
would you then expect `a!?.b` even tho that be silly since it'd always throw?

[12:38:31.0000] <ljharb>
or only as a binary operator

[12:39:09.0000] <jridgewell>
> ?. is a more precise &&

[12:39:09.0000] <jridgewell>
Only if you mean property access. Doesn't work well for root value

[12:39:37.0000] <jridgewell>
Only the binary operator, `!?.` makes no sense (and is already valid-but-bad typescript code)

[12:39:51.0000] <ljharb>
right

[12:39:58.0000] <rkirsling>
but `??` can be read as "falls back to" and to `?.` covers the `&&` guarding usage so

[12:40:29.0000] <jridgewell>
Only if you're doing property access

[12:40:34.0000] <rkirsling>
I don't think this `!?` would actually be very useful...I think it could really confuse wrt ?.

[12:40:39.0000] <jridgewell>
Babel had a case with private optional

[12:41:10.0000] <jridgewell>
Where we do `obj == null : undefined : getPrivate(obj)`

[12:41:25.0000] <jridgewell>
And that can't be represented with either `?.` nor `??`.

[12:41:33.0000] <jridgewell>
We need interrobang to do it.

[12:42:29.0000] <jridgewell>
So, `??` is stricter `||` and `!?` is stricter `&&`.

[12:42:44.0000] <ljharb>
i don't think ?? is a stricter ||

[12:42:51.0000] <ljharb>
stricter || would be "true or false" instead of "truthy or falsy"

[12:42:59.0000] <jridgewell>
And `?.` is a special case of `&&` for property access/call

[12:43:45.0000] <rkirsling>
I'm just saying, this whole tangent started because of a genuine mistake where !? wouldn't have actually been appropriate

[12:44:21.0000] <rkirsling>
and viewing !? as a solution is dangerous if it's going to confuse people that should be using ?.

[12:44:51.0000] <jridgewell>
`!?` is the appropriate solution, though.

[12:45:03.0000] <jridgewell>
`eval !? eval('test')`

[12:45:48.0000] <rkirsling>
but that code should never be written

[12:46:38.0000] <jridgewell>
The Babel case needed it, too.

[12:47:08.0000] <rkirsling>
sure I get that you already came up with it previously for that reason, yeah

[13:19:06.0000] <rkirsling>
seems like the case you gave could be handled _inside_ the function instead though, and while `!?.` would be nonsensical, `!?=` would be expected, yet of questionable utility

[13:19:27.0000] <rkirsling>
the issue is that with || and &&, truthy and falsy are on equal footing

[13:20:04.0000] <rkirsling>
nullish can never be on equal footing with non-nullish because if we could go back and do things over again, we would just have null and not nullish

[13:23:25.0000] <rkirsling>
so even though ?? and ?. bear similarity with these, there's a baked-in notion of "falling back" since it's all about convenient null-guarding and not about two similar buckets

[14:06:45.0000] <littledan>
Hey everyone, let's try to keep technical discussion in #tc39 when possible, so it's publicly accessible

[14:07:16.0000] <jridgewell>
But this is publicly accessible?

[14:07:19.0000] <ljharb>
littledan: this channel is publicly accessible already

[14:07:37.0000] <ljharb>
the only place we can't have technical discussions is the reflector.

[14:08:12.0000] <littledan>
I'm not talking about in terms of policy requirements, but we have more non-delegates hanging out in #tc39, since we advertise the existence of #tc39 publicly

[14:08:26.0000] <littledan>
(sorry, my comment was imprecise)

[14:08:28.0000] <ljharb>
sure. but sometimes we don't want to have the discussion with non-delegates, and that's what this channel is for

[14:08:33.0000] <littledan>
ok

[14:09:38.0000] <rkirsling>
sometimes it's just inertia over where a topic started

[14:09:40.0000] <rkirsling>
or like

[14:10:00.0000] <rkirsling>
if there's multiple topics then our channel count is effectively our thread count

[14:10:05.0000] <rkirsling>
hehe

[15:20:04.0000] <rickbutton>
spec question: is it valid to use a spec-List as a `this` argument to a function `Call`? (specifically, the `this` argument of the `adder` in a usage of `AddEntriesFromIterable`. it is mentioned that spec-types should not be used as object properties or variable values, but does that also apply to `this`?

[16:21:43.0000] <ljharb>
rickbutton: it's not valid

[16:21:49.0000] <ljharb>
rickbutton: spec values can't be exposed to user code

[16:22:12.0000] <ljharb>
rickbutton: in the AddEntriesToIterable case, you could argue that it's not exposed, but that'd be an editorial question the editors haven't previously had to consider

[16:35:24.0000] <rickbutton>
makes sense.

[16:37:40.0000] <rickbutton>
I don't think I will be able to re-use AddEntriesFromIterable in that case, will have to create a new op. either way its a small amount of spec


2020-06-23
[17:00:38.0000] <ljharb>
rickbutton: i was kind of thinking you'd be able to define `adder` as a closure around the List

[19:52:59.0000] <rickbutton>
oh duh

[21:42:28.0000] <Bakkot>
I want to second littledan's suggestion that we default to #tc39 unless there's a reason the discussion only makes sense among delegates

[21:42:55.0000] <Bakkot>
yeah there's always inertia and all, and it's not a big deal if something is here rather than there, just a thing to keep in mind

[21:45:55.0000] <rkirsling>
yep it's a good reminder

[07:49:28.0000] <rickbutton>
+1 will do, thanks for the reminder

[13:04:45.0000] <rkirsling>
hmmm if leobalter is changing his acronym I might hop on that train too

[13:10:47.0000] <leobalter>
I’ve had people asking me if R from LBR is an initial for some actual last name

[13:11:09.0000] <leobalter>
Which is not and I don’t want to continue explaining that from time to time

[13:11:47.0000] <rkirsling>
ah I mean, that's an inherent problem with our acronymization scheme for sure, for anybody with >2 name parts

[13:15:12.0000] <ljharb>
mine's the same way, JHD

[13:15:26.0000] <ljharb>
jafar nabbed JH first :-p

[13:17:22.0000] <rkirsling>
ljharb: oh man and it's easy for people to forget that your last name ends in a D ha

[13:17:59.0000] <shu>
you gotta start spelling it like a 70s/80s band art

[13:18:02.0000] <shu>
HarbanD

[13:18:10.0000] <ljharb>
i did purchase the domain `har.band`

[13:18:17.0000] <ljharb>
so i got that going for me

[13:18:34.0000] <rkirsling>
is it like a band that distributes their work in HAR files

[13:18:41.0000] <rkirsling>
(am I trying too hard)

[13:18:57.0000] <ljharb>
lol yes. but i haven't yet decided what my signature joke will be for that domain name

[13:20:36.0000] <ljharb>
(iow, submissions accepted)

[13:22:55.0000] <rkirsling>
guess it could be hairband without the I

[13:23:10.0000] <rkirsling>
or "there's no I in Harband"

[13:37:13.0000] <devsnek>
but there is in standardization

[13:40:35.0000] <rkirsling>
damn.

[13:45:18.0000] <shu>
there're two

[13:46:43.0000] <rkirsling>
but no u

[13:47:30.0000] <ljharb>
could always do british spelling and go with "standardizatioun"

[13:47:42.0000] <ljharb>
oh wait, "standardisatioun"

[13:47:56.0000] <ljharb>
:-p

[14:10:04.0000] <rkirsling>
oh leobalter I just realized you pinged an unrelated Yulia here: https://github.com/tc39/test262/pull/2667#issuecomment-647685804

[14:10:31.0000] <rkirsling>
she's @codehag on GH

[14:17:29.0000] <leobalter>
heh

[14:17:39.0000] <leobalter>
thanks! I fixed it

[14:19:02.0000] <rkirsling>
not super sure what the best way to resolve that discussion is though

[15:42:40.0000] <leobalter>
Sometimes I wonder if we should rename AssignmentExpression to SingleExpression in order to quickly differentiate it from Expression

[15:43:19.0000] <leobalter>
LonelyExpression... I should move this to tdz...

[16:58:42.0000] <rkirsling>
oh wait this is interesting


2020-06-24
[17:00:16.0000] <rkirsling>
so even though direct eval might feel conceptually simpler (and perhaps even be simpler in implementation), the spec change really would involve "adding a new direct eval case"?

[17:01:45.0000] <rkirsling>
i.e. because an optional call isn't a CallExpression we'd actually need to duplicate the algo text corresponding to the direct call?

[17:04:01.0000] <rkirsling>
i.e. we'd need to copy all of step 6 @ https://tc39.es/ecma262/#sec-function-calls-runtime-semantics-evaluation or make it an AO

[17:04:24.0000] <rkirsling>
I can see why people would feel hesitant about that

[17:04:45.0000] <rkirsling>
(even if it's potentially backwards wrt priority of constituencies)

[17:07:49.0000] <rkirsling>
hmm also

[17:08:06.0000] <rkirsling>
6. If Type(ref) is Reference, IsPropertyReference(ref) is false, and GetReferencedName(ref) is "eval", then

[17:08:06.0000] <rkirsling>
    a. If SameValue(func, %eval%) is true, then

[17:08:45.0000] <rkirsling>
does that mean a local `eval` is still direct eval?

[17:19:35.0000] <bakkot_>
yup

[17:20:09.0000] <bakkot_>
`{ let a = 0; let eval = window.eval; eval('a') }` // 0

[17:23:38.0000] <shu>
as long as it's the same thing and is spelled e-v-a-l, yeah

[17:24:23.0000] <shu>
(not sure if any other way is implementable, unless eval() was specced as special syntax like import())

[17:27:57.0000] <devsnek>
reminder of #tc39

[17:30:35.0000] <rkirsling>
right right, failing right off the bat, we can move


2020-06-25
[18:39:57.0000] <rkirsling>
nobody does toxicity quite like the pipeline repo

[18:40:20.0000] <rkirsling>
(these days anyway)

[07:02:15.0000] <littledan>
hmm, should we do something about that? I guess I'm kind of responsible

[07:02:25.0000] <littledan>
I'm not sure what to do

[09:48:23.0000] <ljharb>
someone with admin rights on the repo would ideally moderate the threads

[12:30:45.0000] <ystartsev>
should it be a coc thing?

[12:36:06.0000] <rkirsling>
yeah Aki did handle the specific thread that got called out

[12:36:27.0000] <rkirsling>
but I feel like it's always on the edge of happening again with the regular crowd in there :(


2020-06-26
[09:14:26.0000] <TabAtkins>
Oh dang should I be glad I haven't even thought about the pipeline stuff for the last two weeks?

[09:15:24.0000] <rkirsling>
signs points to yes

[09:15:27.0000] <rkirsling>
*point

[09:29:44.0000] <ljharb>
|> yes


2020-06-30
[09:02:11.0000] <shu>
rickbutton: incubator call?

[15:00:00.0000] <devsnek>
can someone turn on https redirects for http://tc39.es/proposal-slice-notation/

[15:06:50.0000] <akirose>
done

[15:07:18.0000] <devsnek>
thank you!

[15:07:40.0000] <devsnek>
idk why gh pages even has an option to allow http

