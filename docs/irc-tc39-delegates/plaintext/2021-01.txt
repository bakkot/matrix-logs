2021-01-01
[16:36:50.0000] <devsnek>
üéä

[18:08:01.0000] <Bakkot>
here's to having a better time in 2020

[18:08:09.0000] <Bakkot>
er

[18:08:10.0000] <Bakkot>
in 2021

[18:08:14.0000] <Bakkot>
than in 2020

[18:08:24.0000] <Bakkot>
and also a better Date!

[00:16:07.0000] <ryzokuken>
ü•≥

[00:16:09.0000] <ryzokuken>
Happy New Year from the future, everyone!

[00:17:50.0000] <rkirsling>
I think it's basically everywhere now :D


2021-01-05
[07:22:59.0000] <ystartsev>
who would be a good person to look at some changes related to super?

[07:44:57.0000] <ystartsev>
ah, i just made the pr. now you all have to look at it


2021-01-08
[21:00:00.0000] <MylesBorins>
hey all... I accidentally just pushed something really stupid to tc39/ecma262 master

[21:00:26.0000] <MylesBorins>
as I'm an admin I temporarily removed branch protection so I could force push and remove the offending commits

[21:00:47.0000] <MylesBorins>
I've re-enabled branch protection but may have not enabled all of the correct protections so someone may want to take a look at it

[21:00:55.0000] <MylesBorins>
I'm emailing the chair group as well to make sure folks are aware of thins

[21:00:58.0000] <MylesBorins>
extremely sorry :S

[21:07:36.0000] <ljharb>
MylesBorins: you only needed to uncheck "include administrators", for future reference, you don't have to delete all the settings

[21:07:56.0000] <MylesBorins>
GitHub was 404'ing when I tried to edit the rule

[21:07:59.0000] <ljharb>
ouch

[21:08:06.0000] <MylesBorins>
yeah... and I didn't want to leave those commits there

[21:10:30.0000] <Bakkot>
huh, yeah, it worked the first time I clicked "edit" on the rule but now it's 500'ing

[21:10:31.0000] <Bakkot>
fun!

[21:10:49.0000] <ljharb>
i'll get them set back up

[21:11:27.0000] <ljharb>
lol ok well i think i set them up right, but the "edit" page is 500ing so i can't verify

[21:11:45.0000] <ljharb>
perhaps someone who works at github could look into that :-p

[21:12:18.0000] <Bakkot>
anyway the branch itself looks to be in a reasonable state, which is the most important part

[21:12:31.0000] <ljharb>
right, it's the same sha i expect from 3 hours ago

[21:12:46.0000] <MylesBorins>
yeah I knew the exact two commits I pushed so it was p easy to rollback

[21:12:54.0000] <MylesBorins>
I also have a "git mcfly" alias for just such an occasion

[21:13:10.0000] <MylesBorins>
https://github.com/MylesBorins/dot-files/blob/main/.gitconfig#L30

[21:13:13.0000] <Bakkot>
tempted to just repeatedly load the 500'ing page in the hopes of causing enough log messages that someone looks at it

[21:14:14.0000] <ljharb>
i wonder how many 500s it takes to trigger pagerduty

[21:17:25.0000] <Bakkot>
MylesBorins your dotfile lacks an alias for "git push origin $CURRENT_BRANCH_NAME"

[21:17:25.0000] <MylesBorins>
https://github.com/tc39/ecma262/issues/2269

[21:17:39.0000] <Bakkot>
can I recommend `po = "!f() { git push -u origin $(git rev-parse --abbrev-ref HEAD); }; f"`

[21:18:21.0000] <MylesBorins>
oh I was on the right branch name

[21:18:22.0000] <MylesBorins>
I pushed the wrong remote

[21:18:23.0000] <MylesBorins>
should have removed the upstream remote the second I was up to tomfoolery

[21:18:24.0000] <MylesBorins>
that's on me

[21:19:07.0000] <MylesBorins>
ok gonna go chill out, thanks for being understanding about it :D

[21:19:37.0000] <Bakkot>
all is well

[21:19:40.0000] <Bakkot>
except github, github is broken


2021-01-12
[09:54:23.0000] <shu>
rbuckton: are you planning to ask for stage 3 for /d for matchindices at the next meeting?


2021-01-13
[11:09:43.0000] <littledan>
The TC39 agenda looks pretty short. Should we start collecting topics for breakout groups?

[11:15:14.0000] <ljharb>
probably worth waiting til the deadline hits, people often add things last minute (i have one to add too)

[11:17:56.0000] <Bakkot>
yeah same

[11:31:29.0000] <devsnek>
i wonder if there's ever been an empty agenda

[12:05:53.0000] <ljharb>
could always fill the time by arguing about NaN, PTC, or ASI /me ducks into TDZ

[12:06:31.0000] <devsnek>
i'd be down to argue about tail calls

[12:08:06.0000] <ljharb>
that's just because you weren't there the last time we did, so for you it wouldn't be recursion :-p


2021-01-15
[07:36:17.0000] <ljharb>
rbuckton: as a reminder, a requirement for stage 4 eligibility is an editor-approved PR to the main spec

[07:44:09.0000] <ljharb>
ah, I‚Äôd forgotten 1713 :-) it will need the updates tho

[09:38:10.0000] <robpalme>
@Bakkot Will you be able to run the Google Speech for the forthcoming meeting, like last time?

[09:42:04.0000] <Bakkot>
yup

[09:55:01.0000] <robpalme>
ty


2021-01-16
[17:17:14.0000] <shu>
but will someone else be willing to give elocution lessons so that the speech transcription is more accurate?

[17:17:28.0000] <shu>
michael saboff is the reigning champ from last meeting iirc

[17:27:41.0000] <Bakkot>
I am teaching it about all of our idiosyncrasies: https://github.com/bakkot/transcribe-to-gdocs/blob/e3bf9ac8682bbe2e5f823a171c91c961663b7b5f/replacements.js#L5-L26

[17:28:47.0000] <Bakkot>
since last meeting I've added the ability to hot-reload this list without interrupting transcription, so hopefully I'll be able to make common corrections in real time

[21:10:20.0000] <ljharb>
Bakkot: is this open source at all? it‚Äôd be broadly useful i think

[21:24:09.0000] <Bakkot>
the source is on github: https://github.com/bakkot/transcribe-to-gdocs but since I didn't put a LICENSE file in it the OSI probably would say I shouldn't call it open source

[21:41:10.0000] <rkirsling>
easy to rectify

[04:48:13.0000] <robpalme>
is there an audio equivalent of an avatar?  if we could all use a realtime audio conversion service to make us sound like michael saboff, then kevin's bot will transcribe our words perfectly

[07:40:50.0000] <devsnek>
robpalme: https://www.entertainmentearth.com/product/ben-10-alien-voice-changer/ba27290

[07:42:03.0000] <robpalme>
Sold out üôÅ


2021-01-18
[18:23:26.0000] <ljharb>
heads up that the spec URLs on ecma's website are all broken: https://github.com/tc39/Reflector/issues/349

[02:06:33.0000] <littledan>
yeah, Ecma does a lot of these moves without introducing redirects... we might need to email Patrick C and Istvan if they're not responsive on GitHub

[08:16:12.0000] <ljharb>
k, emailed them


2021-01-25
[09:44:08.0000] <michaelficarra>
is anyone in the meeting yet?

[09:55:23.0000] <ljharb>
michaelficarra: to change your name, you have to leave and rejoin i believe.

[09:59:38.0000] <ryzokuken>
do we need to fill in the table on the docs?

[09:59:46.0000] <ryzokuken>
since we already have an attendance form?

[10:02:00.0000] <Bakkot>
ryzokuken the table in the docs is useful for the note-takers, I think

[10:02:14.0000] <ryzokuken>
oh right

[10:02:16.0000] <ryzokuken>
thanks

[10:02:47.0000] <ljharb>
akirose: force quit and reopened the ipad app, and i briefly saw the BA again, then the slides popped in, so i'm good

[10:03:09.0000] <rkirsling>
everyone does indeed look like themself, ha

[10:08:12.0000] <gibson042>
Teams doesn't seem to be working for me; is anyone else stuck on something like "You're not on Teams yet, but you can set it up for your organization"?

[10:08:26.0000] <ljharb>
gibson042: you have to sign in as a guest

[10:09:09.0000] <gibson042>
I don't even see a way to do that

[10:09:16.0000] <gibson042>
anyway, joining via browser seems to work

[10:09:45.0000] <rbuckton>
transcription bot: `s/Baht/bot`

[10:10:21.0000] <ljharb>
gibson042: it's possible if you're logged into your microsoft passport account it skips that screen

[10:14:00.0000] <ystartsev>
editors ready after this?

[10:14:51.0000] <gibson042>
hmm, now Teams is showing a "Sign in" screen but there is no guest option

[10:15:06.0000] <akirose>
what the heck

[10:15:26.0000] <gibson042>
whatever, the web app is working so I'll stick with that

[10:16:02.0000] <sffc>
It might work if you join as a guest using the web client

[10:16:13.0000] <sffc>
yep

[10:24:26.0000] <ryzokuken>
I have had some informal comms with CalConnect folks, they are actively working on it, just as an FYI.

[10:24:29.0000] <leobalter>
sffc: wrt ECMA-402 updates, we should communicate we're doing the cut of ECMA-402 for the 2021 candidate. I believe the only next additions before the cut would be DTF formatRange and perhaps the current listed PRs if they get consensus in this meeting.

[10:24:40.0000] <leobalter>
gibson042: ^^

[10:27:51.0000] <sffc>
leobalter gibson042: I added a slide.  Do you want to discuss it?

[10:28:25.0000] <sffc>
(also, this is #tc39-delegates; we have #tc39-ecma402 for i18n discussions)

[10:29:42.0000] <leobalter>
moving the discussion there

[10:30:46.0000] <Bakkot>
also for anyone considering taking notes, you should know that it usually does a better job than it was doing iwth Istvan

[10:31:03.0000] <Bakkot>
e.g. it got dan almost perfectly

[10:42:42.0000] <akirose>
"SDO" is also the acronym for standards orgs

[10:43:16.0000] <akirose>
standards develop(ing|ment) organization

[10:45:25.0000] <ystartsev>
I am so happy about this channge

[10:46:02.0000] <ljharb>
super great

[10:47:26.0000] <littledan>
omg I'm so excited about this

[10:47:32.0000] <littledan>
this is awesome

[10:53:22.0000] <ystartsev>
Editor group has done amazing stuff

[10:53:50.0000] <JaseW>
That

[10:55:06.0000] <JaseW>
That's great news Bakkot

[10:56:32.0000] <michaelficarra>
btw a lot of these changes will apply to ECMA-402 as well, since they use ecmarkup

[10:58:56.0000] <michaelficarra>
littledan ystartsev we are, too!

[11:00:07.0000] <michaelficarra>
as editors, we spend a decent amount of time navigating the spec and we were constantly feeling the pains addressed by the SDO re-org

[11:04:02.0000] <rpamely>
I just noticed the reflector issue link in the room title is old. Current meeting is issue 340.

[11:07:19.0000] <ljharb>
rpamely: thanks, fixed

[11:17:59.0000] <ryzokuken>
üëè

[11:20:31.0000] <akirose>
the department of meta

[11:34:06.0000] <ljharb>
ok so `(console.log(0), null)[console.log(1)] = console.log(2);` logs 0,1,2 in my browser - what order does the current spec dictate? (Bakkot, ystartsev)

[11:34:27.0000] <Bakkot>
ljharb it dictates 0, 1, throw, I believe

[11:34:29.0000] <ljharb>
i'd kind of expect 0, throw

[11:34:30.0000] <ljharb>
ah k

[11:34:37.0000] <Bakkot>
not totally sure; might be 0, throw

[11:35:35.0000] <Bakkot>
ah, I was right the first time

[11:35:45.0000] <Bakkot>
that's part of why it's so painful

[11:35:52.0000] <Bakkot>
because you look at the object, then the key, then the object again

[11:36:57.0000] <ljharb>
which is what you already have to do for `o[k]` in case o is a proxy or has a setter on o[k], no?

[11:37:12.0000] <ljharb>
i guess in those two cases you'd have to have the RHS first

[11:37:46.0000] <Bakkot>
sorry, so, current spec dictates:

[11:37:59.0000] <Bakkot>
object, key, object, rhs, object+key+rhs

[11:38:16.0000] <Bakkot>
you do have to check for proxies or setters or whatever, but those happen as part of performing the assingment

[11:38:20.0000] <Bakkot>
which happens after evaluating the HRS

[11:38:24.0000] <Bakkot>
*RHS

[11:39:03.0000] <ljharb>
right

[11:39:21.0000] <ljharb>
so this would just become "object, key, rhs, all"

[11:40:06.0000] <Bakkot>
yeah

[11:41:25.0000] <ljharb>
k, thanks

[11:41:41.0000] <ystartsev>
sorry for the mixup earlier

[11:42:05.0000] <ystartsev>
the chairing transition was a bit rough

[11:43:15.0000] <JaseW>
I think the note taker has stopped

[11:43:27.0000] <JaseW>
and it's back

[11:43:28.0000] <Bakkot>
JaseW refresh

[11:43:30.0000] <Bakkot>
yeah

[11:43:35.0000] <Bakkot>
ljharb in fact it was even worse than that, now that I've looked

[11:43:50.0000] <Bakkot>
it was, evaluate obj, evaluate prop, coerce obj to object, coerce prop to string, evaluate RHS, perform assignment

[11:43:56.0000] <ljharb>
and now?

[11:44:11.0000] <Bakkot>
now it's just evaluate object, evaluate prop, coerce prop to string, evaluate RHS, perform assignment

[11:44:23.0000] <Bakkot>
so the "evaluate prop" and "coerce prop to string" become adjacent

[11:45:14.0000] <ystartsev>
^ yeah that is the main change

[11:45:21.0000] <ljharb>
and "coerce obj to object" happens as part of "perform assignment"

[11:45:26.0000] <ljharb>
gotcha

[11:45:56.0000] <shu>
46!

[11:45:57.0000] <ystartsev>
yeah, ToObject basically does the same

[11:46:44.0000] <ystartsev>
there is a more in depth write up in my test repo for it

[11:56:49.0000] <ystartsev>
sffc: I got the thumbs up on #500

[11:56:55.0000] <ystartsev>
sorry for the delay and thanks for the patience

[12:01:42.0000] <sffc>
ystartzev: thanks!

[12:03:50.0000] <shu>
rbuckton: yay, thanks for presenting

[12:04:00.0000] <rbuckton>
üëç

[13:09:53.0000] <msaboff>
rbuckton Someone on the JSC team ask a question about materializing "indices" and I didn't know the answer.

[13:11:19.0000] <msaboff>
rbuckton With the latest, just approved, version of the spec, is there a reason we don't set 'indices' to 'undefined' when the 'd' flag isn't present?

[13:12:04.0000] <msaboff>
I haven't run any perf tests on that variant and I don't remember it being discuss as part of the new option discussion.

[13:12:53.0000] <msaboff>
The team member noted that 'indices' has a different creation semantic than the 'groups' property.

[13:25:23.0000] <rbuckton>
msaboff: No particular reason, other than not to have it if its not requested. If we unconditionally create the property (like we do for groups), and leave it as `undefined`, I would have no issue.

[13:26:19.0000] <msaboff>
rbuckton Okay.  I can run perf tests to see if there is any issue.  I'll try to get to that by the end of the meeting.

[13:32:52.0000] <littledan>
+100 to ljharb 's point on the queue

[13:46:31.0000] <caridy>
I get the same impression than Waldemar, same issue with Trusted Types!

[13:47:04.0000] <caridy>
you must own/control the whole app, the whole code running for the app to make this any useful

[13:49:34.0000] <littledan>
I don't think Mark's proposed constraint makes sense. I think it would be a very unreasonable constraint on the development of the JS standard library

[13:49:48.0000] <littledan>
I agree that checking whether a template tag is literal is a rather low-level property

[13:51:21.0000] <jridgewell>
From Google‚Äôs experience, controling the whole app is expected

[13:52:20.0000] <caridy>
right! but majority of apps are not like that! anything using anything from NPM is automatically in the other category!

[13:52:52.0000] <jridgewell>
I‚Äôm not sure I agree

[13:53:22.0000] <jridgewell>
The point isn‚Äôt to guard against a truly malicious 3p script running on the page

[13:53:33.0000] <jridgewell>
It‚Äôs to guard against accidental usage

[13:54:28.0000] <ljharb>
i don't think there's agreement that that's not the point

[13:55:07.0000] <jridgewell>
Having `makeSafeUrl(codeIThoughtWasStaticButIsActuallyDynamic)` is a wholey different attack than `makeSafeUrl'https://im.actually.static'`

[13:55:38.0000] <jridgewell>
Potecting against a page that‚Äôs exposed `eval`, you‚Äôre entire app is insecure, their‚Äôs no fixing that.

[13:55:46.0000] <littledan>
there's sort of an interesting parallel between the shape of Mark's argument and previous arguments against SES-motivated features: both allege that the scenario where the feature is useful is impractical

[13:56:01.0000] <ljharb>
jridgewell: there's tons of ways to protect against eval

[13:56:02.0000] <littledan>
I wonder if we could dig into this practicality and think about how to assess it more broadly

[13:56:07.0000] <ljharb>
jridgewell: eval doesn't break closures.

[13:56:16.0000] <littledan>
ljharb: +1

[13:56:21.0000] <Bakkot>
jridgewell I still pretty much agree with waldemar

[13:56:32.0000] <Bakkot>
if you are not concerned about malicious code, checking for "it's frozen and has a raw property" is good enough

[13:56:38.0000] <Bakkot>
if you are concerned about malicious code, this doesn't help

[13:58:08.0000] <littledan>
this is a sort of integrity feature. It gets exactly what you want in terms of "did this really come from syntax". A bunch of people asked me if this feature is related to my topic later, about tests like Map.isMap, and my initial reaction was "no" but now I've sort of come around to, they are kind of logically similar, in letting you check whether something really is something

[14:07:42.0000] <littledan>
jridgewell: Module blocks are like module specifiers, not namespace objects

[14:13:05.0000] <rbuckton>
If it was a _real_ ModuleSpecifier, you could do this... (though I'm unsure as to whether this is a good idea or not)

[14:13:06.0000] <rbuckton>
```

[14:13:06.0000] <rbuckton>
import { x } from module {

[14:13:06.0000] <rbuckton>
  export const x = 1;

[14:13:06.0000] <rbuckton>
};

[14:13:06.0000] <rbuckton>
```

[14:13:34.0000] <jridgewell>
I didn't realize you needed to import them.

[14:17:50.0000] <michaelficarra>
rbuckton: makes sense to me

[14:31:12.0000] <ljharb>
kind of seems like if we had `class.foo = bar` syntax we wouldn't have to use `this`

[14:33:25.0000] <shu>
i think ClassName suffices, still, kind of like kevin

[14:33:38.0000] <shu>
that was the conclusion from the subclassing hazard discussion

[14:34:54.0000] <shu>
it doesn't follow from that that we should *ban* `this`; i'm just saying ron's implication in the other direction that `this` is the natural way to assign static properties

[14:35:03.0000] <shu>
isn't that compelling

[14:36:22.0000] <ljharb>
i agree that repeating the class name is the status quo, and is "fine"

[14:36:31.0000] <ljharb>
but i also think repeating it sucks, and that's why i liked the `class.` proposal

[14:36:50.0000] <ljharb>
but we could go with "repeat the class name" here and still do `class.` later

[14:37:12.0000] <shu>
ah

[14:37:22.0000] <shu>
there are weird inconsistencies that cut both ways

[14:37:28.0000] <shu>
like Ron i feel _really_ strongly that vars shouldn't hoist out

[14:37:29.0000] <shu>
pls no

[14:38:16.0000] <Bakkot>
this is 50% idealogical and 50% a very practical concern that this straight-up doesn't work for half the code I wrote, which has `await`

[14:39:00.0000] <littledan>
I really think that this makes sense to treat like static field initializers

[14:39:14.0000] <littledan>
both in terms of scoping and ordering

[14:39:22.0000] <ljharb>
Bakkot: you write a lot of code that sets static properties on a class and uses `await`?

[14:39:24.0000] <Bakkot>
well, the proposal does not match filed initializers

[14:39:41.0000] <Bakkot>
ljharb of the code I wrote that sets static properties on a class, 50% uses initializers

[14:39:49.0000] <ljharb>
interesting, k

[14:39:53.0000] <Bakkot>
er

[14:39:56.0000] <Bakkot>
50% uses await

[14:39:58.0000] <ljharb>
right

[14:39:59.0000] <littledan>
Bakkot: Well, it's fairly close; I'd prefer that it match entirely but I can buy the motivation for the changes

[14:39:59.0000] <Bakkot>
sorry, too many words going on

[14:40:02.0000] <ljharb>
what about this proposal doesn't match field initializers?

[14:40:08.0000] <Bakkot>
littledan this proposal is that static {} runs last, regardless of where it is relative to initializers

[14:40:17.0000] <littledan>
right, I'd be up for changing that

[14:40:49.0000] <Bakkot>
littledan fwiw the major upshot of this conversation is that I feel like static initializers should inherit the ability to `await`

[14:41:10.0000] <littledan>
well... I'm happy that we designed them to behave like little methods instead

[14:41:17.0000] <littledan>
that was a deliberate design

[14:41:25.0000] <Bakkot>
mostly to match regular fields

[14:41:30.0000] <Bakkot>
where it makes a lot of sense

[14:41:34.0000] <Bakkot>
makes much less sense for static methods

[14:41:40.0000] <Bakkot>
er, static initalizers

[14:43:37.0000] <ljharb>
Bakkot: notes, `a weight` should be `await` most often in the bot :-p

[14:45:11.0000] <rkirsling>
in a phrase like "allow a weight to carry over" you can hardly blame it lol

[14:45:20.0000] <ljharb>
lol true

[14:45:56.0000] <Bakkot>
ljharb I made that change a minute ago, just doesn't work if it ends up doing the post when it only has the `a` ready

[14:46:02.0000] <ljharb>
ah true

[14:46:08.0000] <littledan>
it was not underspecified. It has been specified as undefined the whole time

[14:46:42.0000] <littledan>
but the good thing is, the class features specs are all rebased and in great shape thanks to Ms2ger so this is more clear

[14:47:04.0000] <littledan>
you can see the spec at https://arai-a.github.io/ecma262-compare/?pr=1668

[14:47:18.0000] <shu>
oh good

[14:47:39.0000] <shu>
allowing multiple interleaving blocks in order seems the most JS-y thing

[14:47:44.0000] <littledan>
(it = new.target in static field initializers)

[14:47:44.0000] <shu>
i see no good reason to limit to 1

[14:47:49.0000] <littledan>
shu: +1

[14:47:56.0000] <Bakkot>
would they interleave with static initalizers?

[14:47:59.0000] <Bakkot>
(presumably yes?)

[14:47:59.0000] <shu>
yes

[14:48:01.0000] <shu>
i think that's the point yes

[14:48:06.0000] <ljharb>
top-down order seems pretty important

[14:50:16.0000] <Bakkot>
oh god we've lost note taking

[14:54:14.0000] <Bakkot>
would `var`s be shared?

[14:54:24.0000] <Bakkot>
would they be visible to computed property names?

[14:54:55.0000] <ljharb>
i'd hope no

[14:58:22.0000] <shu>
Bakkot: yeah, i also hope each block would have its own var scope as the single initialized block does now

[15:04:45.0000] <littledan>
woohoo!

[15:06:13.0000] <rkirsling>
sorry, I'll help with notes tomorrow >_<

[15:29:44.0000] <Bakkot>
the bot's unedited output definitely has some of the character of gpt2

[15:30:06.0000] <Bakkot>
where it's _almost_ coherent and _almost_ topical but it's also complete gibberish

[15:41:06.0000] <rkirsling>
hubs is way shinier than before

[15:41:16.0000] <rkirsling>
might just be a UI refresh but I like it


2021-01-26
[18:09:26.0000] <rbuckton>
Somewhat offtopic, but if there are any NodeJS implementers present that are familiar with Node's support for the W3C Web Performance APIs, can they reach out to me either via IRC or email?

[20:40:03.0000] <devsnek>
rbuckton: sup

[09:40:33.0000] <littledan>
rbuckton: On Node.js Web APIs, are you in touch with James Snell or Matteo Collina? They're doing a lot of implementation these days. I can put you in touch by email if you want.

[10:08:38.0000] <michaelficarra>
I love everything about this proposal

[10:10:55.0000] <rickbutton>
yep format*ToParts is universally great

[10:11:32.0000] <rkirsling>
editing is still intense, wow

[10:11:53.0000] <rkirsling>
the delay is large enough that it's easy to forget what was said by the time the mistake appears

[10:12:13.0000] <devsnek>
resizable arraybuffers are good

[10:12:17.0000] <Bakkot>
rkirsling yeah :(

[10:12:36.0000] <rbuckton>
littledan: that would help. We switched TS to leveraging the WC3 perf API for some performance monitoring in the TypeScript compiler and have run into cases where using perf_hooks is 20x slower than what we were doing before.

[10:12:36.0000] <Bakkot>
a bit of that is introduced by me for dumb technical reasons

[10:12:50.0000] <Bakkot>
rkirsling I kind of want to look into putting teams on a one-second lag while I'm taking notes

[10:13:00.0000] <rkirsling>
ahh yeah

[10:13:10.0000] <devsnek>
rbuckton: i'm curious how that performs if you use node >=15 with `--turbo-fast-api-calls`

[10:20:16.0000] <littledan>
rbuckton: Oh, I see. BTW you can find more information about people and discussions in this area at https://github.com/nodejs/diagnostics

[10:21:00.0000] <devsnek>
qard is also working on improving tracing api performance

[10:21:02.0000] <rbuckton>
devsnek, littledan thanks!

[10:27:19.0000] <Bakkot>
rkirsling are you still taking notes?

[10:27:23.0000] <Bakkot>
I've been doing it but want to tweak the bot

[10:27:29.0000] <Bakkot>
and it'll get behind if I step away

[10:28:04.0000] <rkirsling>
Bakkot: I think my eyes are not strong enough to keep up with something like this

[10:28:10.0000] <Bakkot>
kk, not to worry

[10:29:43.0000] <rkirsling>
I'm struggling with them daily as it is but this feels more intense than your average competitive video game

[10:31:24.0000] <rkirsling>
like I feel mildly sick from 20 minutes of it

[10:32:07.0000] <ystartsev>
general newbie question for this topic: does this make page size observable? maybe it already is from wasm?

[10:32:36.0000] <ystartsev>
are these slides published anywhere? i see other people looking at it but its not on the agenda or in the notes?

[10:35:06.0000] <rkirsling>
ystartsev: they're in the agenda?

[10:35:12.0000] <rkirsling>
https://docs.google.com/presentation/d/1lkDe1j1LcX8fg4KeLRKEeBG6VF0ffBz4Q_kA130V_aQ/edit?usp=sharing

[10:35:15.0000] <Bakkot>
mark is current winner for person-who-bot-likes-best

[10:35:32.0000] <ystartsev>
ah, i didn't refresh recently

[10:42:36.0000] <Bakkot>
can someone fixup peter's acronym in the notes

[10:42:39.0000] <Bakkot>
I don't have time to look it up

[10:44:21.0000] <michaelficarra>
Bakkot: PHE

[10:44:22.0000] <ljharb>
Bakkot: on it

[10:44:25.0000] <ljharb>
nvm

[10:44:36.0000] <michaelficarra>
already got it ljharb ;-)

[10:45:50.0000] <michaelficarra>
delegate shorthands are listed in https://github.com/tc39/notes/blob/master/delegates.txt FYI

[10:46:05.0000] <michaelficarra>
it's good to keep that handy when on note-taking duty

[10:51:05.0000] <devsnek>
queue needs to be advanced

[10:53:11.0000] <ljharb>
fwiw a ton of my packages have a necessary use of `Function` in their dep graph, so while getting rid of `eval` seems achievable, getting rid of `Function` seems significantly less so.

[10:54:10.0000] <devsnek>
i see that a lot too

[10:55:07.0000] <caridy>
yeah, this is also related with his presentation yesterday. the fact that when using anything from someone else, having a global setting is not going to work. make it work usually wins over security issues unfortunately!

[10:55:13.0000] <rkirsling>
what is the necessary use of Function?

[10:55:55.0000] <rkirsling>
the d3-dsv readme just states that it's `(safe) use of dynamic code generation for fast parsing`

[10:56:36.0000] <ljharb>
rkirsling: objects only reachable from syntax - ie, AsyncFunction, GeneratorFunction, AsyncGeneratorFunction, etc.

[10:56:41.0000] <Bakkot>
bot writes "eval" as "evil" like 80% of the time

[10:56:55.0000] <ljharb>
rkirsling: iow by making them "not globals", a significant percentage of the web ends up having use of `Function` ¬Ø\_(„ÉÑ)_/¬Ø

[10:57:03.0000] <ljharb>
Bakkot: where's the error tho

[10:57:10.0000] <rkirsling>
I see...

[11:02:58.0000] <akirose>
i've had to make some big overhauls to the schedule, please lmk if you see any misses or conflicts

[11:08:19.0000] <michaelficarra>
note takers: the shorthand for the current speaker is KOT, not KKL

[11:08:45.0000] <Bakkot>
oops, I probably did that all day yesterday too

[11:08:49.0000] <Bakkot>
they're adjacent in delegates.txt

[11:09:46.0000] <michaelficarra>
nope, it's correct yesterday

[11:11:55.0000] <devsnek>
so if d3 can create a trusted types thing

[11:12:12.0000] <devsnek>
what stops some other random evil thing from creating a trusted types thing

[11:12:27.0000] <Bakkot>
devsnek if you can create a policy you can already run arbitrary code

[11:12:30.0000] <Bakkot>
is the assumption

[11:12:53.0000] <devsnek>
oh does the policy say "the d3 url" can create trusted types?

[11:13:10.0000] <Bakkot>
no

[11:13:13.0000] <devsnek>
i guess i'm confused about the scoping of this

[11:13:14.0000] <Bakkot>
am taking notes thoug hsorry

[11:13:21.0000] <devsnek>
no worries

[11:22:33.0000] <michaelficarra>
I feel the current concerns should be pre-stage 2, not post-stage 2

[11:22:43.0000] <Bakkot>
same

[11:22:46.0000] <gibson042>
I get the same impression

[11:22:47.0000] <devsnek>
same

[11:22:57.0000] <littledan>
I am slightly sympathetic to Caridy's argument (which seems valid to hold Stage 2 for), but completely disagree with several of Mark's points.

[11:23:06.0000] <littledan>
I don't think these should be thought about as the same point

[11:23:09.0000] <ljharb>
since they deal with "should this be in the language", that seems decidedly pre-stage-2 to me

[11:23:18.0000] <bradleymeck>
i'm actually fine w/ stage 2 but think it needs a fair amount of modification

[11:24:07.0000] <akirose>
the queue kkotowicz https://snaps.akibraun.com/588t7.jpg

[11:25:14.0000] <robpalme>
thanks aki

[11:25:26.0000] <robpalme>
this item is 30mins (not 60 mins as tcq indicates)

[11:26:03.0000] <michaelficarra>
am I supposed to be seeing slides?

[11:26:10.0000] <akirose>
no

[11:26:11.0000] <rickbutton>
woah selfhosted screenshots

[11:26:36.0000] <akirose>
rickbutton: Monosnap + AWS S3 + CloudFront

[11:26:43.0000] <devsnek>
i host my screenshots on s3 as well

[11:26:48.0000] <rickbutton>
nice

[11:26:53.0000] <devsnek>
there's some bug where they don't charge me for s3 usage

[11:26:57.0000] <devsnek>
and i don't intend to tell them

[11:27:14.0000] <rickbutton>
bezos covers your s3 bill with his pocket lint

[11:27:51.0000] <akirose>
i got real upset when Evernote bought and ruined Skitch in 2012 so I decided never again and set up the above.

[11:28:11.0000] <devsnek>
i had to add this big scary sentence to the vm docs https://gc.gy/79394277.png

[11:29:48.0000] <bradleymeck>
devsnek: that ain't stopping people

[11:29:51.0000] <bradleymeck>
XD

[11:30:05.0000] <devsnek>
it did reduce the number of issues people opened asking if vm is safe

[11:30:11.0000] <bradleymeck>
fair

[11:30:32.0000] <devsnek>
if i don't observe the exploit it doesn't exist :P

[11:32:03.0000] <bradleymeck>
shu: we have some slides that show the cycle problem somewhere around here when we tried to figure out some stuff for Loaders

[11:32:40.0000] <Bakkot>
syg there is another serious flaw with this approach

[11:32:48.0000] <Bakkot>
remind me to talk about it

[11:35:01.0000] <shu>
Bakkot: "this approach" = sync message-passing?

[11:35:06.0000] <Bakkot>
yeah

[11:35:07.0000] <shu>
put yourself on the queue?

[11:35:11.0000] <Bakkot>
am notes

[11:35:14.0000] <shu>
ah

[11:37:38.0000] <Bakkot>
am now on queue

[11:40:35.0000] <chicoxyzzy>
The font in TCQ needs some more weight IMHO. It's a bit hard to read sometimes

[11:40:53.0000] <ljharb>
+1

[11:42:39.0000] <rkirsling>
I agree on the queue screen in particular

[11:42:54.0000] <rkirsling>
light font weight could be used for Agenda Item, Topic, and Speaking

[11:43:32.0000] <rkirsling>
but using it for the values of those makes them harder to read

[11:43:50.0000] <ystartsev>
bterlson is working on a new version

[11:43:57.0000] <ystartsev>
but i guess for now we can update it to be easier to read?

[11:50:39.0000] <ljharb>
re Bakkot's point, if "we can fix some of it" is ok for trusted types, why isn't it ok for realms?

[11:51:09.0000] <ljharb>
the line about "spectre, so who cares" is pretty frustrating

[11:51:55.0000] <ystartsev>
I think there is the option of renaming, and that might be a good direction

[11:52:40.0000] <ystartsev>
i think the highlighting of membranes as a pattern rather than an end in it self is pretty important, and I am curious about some of the discussion that has been had here so far... what that middle road is

[11:52:55.0000] <ystartsev>
I would like to see the fleshed out proposal

[11:53:26.0000] <devsnek>
honestly i'm still not 100% sure what a membrane is

[11:53:51.0000] <rickbutton>
a bunch of code that isolates two sides of an object graph

[11:54:11.0000] <devsnek>
neat

[11:55:01.0000] <ystartsev>
i've been thinking about it as telepresence

[11:55:02.0000] <robpalme>
i believe there is a wet and dry side

[11:55:19.0000] <devsnek>
yeah i remember the wet and dry side

[11:55:35.0000] <devsnek>
that was my first tc39 meeting üòÖ

[11:56:17.0000] <rbuckton>
Is the problem that we keep trying to define these "security" features piecemeal? Each individual piece doesn't solve a specific security issue and on their own seem to be considered a footgun. Do we need a comprehensive strategy for security boundaries and trust levels in synchronous code?

[11:57:02.0000] <devsnek>
i think mark would say yes we need a comprehensive principled approach

[11:57:10.0000] <rickbutton>
i think we should ban the word security without a qualifier

[11:57:59.0000] <rbuckton>
For example, I could see a built-in mechanism combining Proxies/Membranes, Realms, and import assertions to establish trust levels between imports and exports, such that when one module interacts with another module that it doesn't "trust", it goes through a membrane and isolates the other module/package.

[11:58:10.0000] <shu>
bradleymeck: there is a broader strategy they're executing on

[11:58:12.0000] <shu>
coop/coep

[11:58:30.0000] <shu>
features to nudge people to opt in to the process boundary and disabling those APIs otherwise

[12:00:11.0000] <devsnek>
i'm still surprised that major js engines don't support HMR better

[12:01:08.0000] <devsnek>
especially google after all that work on dart/flutter hot reload

[12:01:09.0000] <caridy>
just to clarify, it seems that some folks are confused, the main issue solved by the counter proposal from google is to avoid the two objects graphs to be interconnected, basically, it avoid identity discontinuity all together

[12:01:45.0000] <bradleymeck>
shu: that isn't the strategy of others XD

[12:02:00.0000] <devsnek>
isn't isTemplateObject being driven by google?

[12:02:16.0000] <devsnek>
seems to be part of the identity discontinuity issue

[12:02:17.0000] <shu>
yes

[12:02:20.0000] <shu>
it is?

[12:02:56.0000] <shu>
actually i have to run for an hour, sorry will be unresponsive

[12:03:02.0000] <devsnek>
no worries

[12:05:55.0000] <bradleymeck>
shu: that is only the web contingent and doesn't work for things like Node, also has a large implication of same domain model

[12:09:24.0000] <Bakkot>
devsnek the answer to your earlier question about policies (if I understand it correctly) is that policies have names, you have to put the names in the CSP header, and the names are use-once

[12:09:38.0000] <Bakkot>
or at least this was my understanding last I checked

[12:09:54.0000] <Bakkot>
so to use the d3 lib you would add "polices: d3-csv" to your CSP (or whatever the actual syntax is)

[12:09:58.0000] <Bakkot>
and this would whitelist only d3

[12:10:01.0000] <devsnek>
ah ok

[12:10:19.0000] <Bakkot>
or, if some other dependency tried to use it, doing so would break d3

[12:11:07.0000] <Bakkot>
I am uhhhhhhhhh let me say "somewhat skeptical" that companies other that google will actually have the process in place to reliably go from "added a transtive npm dependency to some component" to "updated their CSP"

[12:11:10.0000] <Bakkot>
but that's the theory

[12:13:44.0000] <bradleymeck>
doesn't that mean that it is only applied to an entire source text and doesn't do bundling issues? the slide on reasons people continue to use eval mentioned the usage of eval exactly because of bundling

[12:13:57.0000] <bradleymeck>
everyone bundles at some level, even Google

[12:15:23.0000] <Bakkot>
bradleymeck the idea is that they would convince all the dependencies to move to a pattern of using trusted types in a way which would allow them to be used both by non-TT and TT consumers, I think

[12:15:46.0000] <Bakkot>
but there is also this "default policy" escape hatch

[12:16:01.0000] <Bakkot>
which you can read about at https://w3c.github.io/webappsec-trusted-types/dist/spec/#default-policy-hdr

[12:18:07.0000] <ljharb>
mathiasbynens: once rebased, https://github.com/tc39/ecma262/pull/1585 seems like it should be ready

[12:21:11.0000] <bradleymeck>
Bakkot: i guess? but that wouldn't have per invocation site tuning since it lacks a referrer of some kind. likely they expect every library to use a unique policy name in its source text???

[12:41:45.0000] <Bakkot>
bradleymeck I shouldn't speak for them, but that is what I understood

[12:55:38.0000] <Bakkot>
mathiasbynens there's a few editorial tweaks necessary for 1585 to land, in addition to the rebase. since we want to cut 2021, it's probably easiest if the editors just take care of that, unless you / szuend object?

[13:12:22.0000] <littledan>
+1 to Shane's comment. We should not be designing locale data schema in plenary; there are other standards here

[13:13:19.0000] <littledan>
the ECMA-402 calls manage to bring in more i18n experts than we get in plenary. I encourage people who want to argue out the details to join that, though more feedback here is always good

[13:17:40.0000] <michaelficarra>
littledan: I'm not trying to (re)design the API here, I'm trying to validate its usefulness (as presented) for JavaScript devs

[13:17:53.0000] <littledan>
OK, that's legit, sorry for my comment

[13:17:56.0000] <michaelficarra>
I think that's kind of the purpose of 402 presenting fully worked proposals ot committee

[13:18:01.0000] <littledan>
yes

[13:19:02.0000] <michaelficarra>
as I said, I'm not an expert and don't feel qualified to propose an alternative or even really sit at the table with the TG2 people when they do their design

[13:19:39.0000] <Bakkot>
ystartsev I might kill the bot while frank is talking

[13:19:48.0000] <Bakkot>
not sure it's capturing him well enough to be worth it

[13:19:49.0000] <Bakkot>
thoughts?

[13:19:55.0000] <ystartsev>
hm

[13:20:02.0000] <ystartsev>
sure

[13:20:32.0000] <ystartsev>
its not bad though

[13:26:23.0000] <ystartsev>
"Flying on Auntie here Yeah this one." brilliant

[13:27:42.0000] <shu>
aunties always meddling

[13:29:02.0000] <gibson042>
https://github.com/unicode-org/cldr/blob/master/common/bcp47/calendar.xml , for those following along at home

[13:29:29.0000] <Bakkot>
gibson042 thanks, I put it in the notes

[13:31:40.0000] <ljharb>
queue needs advancing also

[13:31:52.0000] <ljharb>
all set

[13:43:19.0000] <littledan>
It'd be great to let this presentation finish before we do any more queue items IMO

[14:01:35.0000] <robpalme>
hey, i am kinda proud we spent a total of 7 minutes on chair elections this year

[14:02:38.0000] <littledan>
hmm, was the queue cleared on purpose?

[14:02:48.0000] <littledan>
I had something on there that now seems like it's gone

[14:03:29.0000] <robpalme>
please refresh

[14:11:20.0000] <ljharb>
i'm confused why "understand common X" implies "we refuse to understand uncommon X"

[14:34:21.0000] <littledan>
TC39 has been following the 10-day rule for a long time, with Ecma management aware of this. We should propose bylaws changes if Ecma wants to start enforcing a 3-week period.

[14:34:48.0000] <michaelficarra>
reflector thread about security TG: https://github.com/tc39/Reflector/issues/313

[14:35:17.0000] <michaelficarra>
littledan: I don't think it's a concern, since we won't be actually forming until the next meeting where the chairs recommend a leadership selection process

[14:37:40.0000] <rkirsling>
also do exprs creates a motivation to fix completion value bugs in engines lol

[14:38:06.0000] <rkirsling>
'cause JSC doesn't not eval `try` blocks correctly :P

[14:38:25.0000] <rkirsling>
*does not

[14:38:43.0000] <TabAtkins>
This example would be even more evocative if it was `const`, bc that's a *very* annoying case to do this exact thing with.

[14:39:02.0000] <michaelficarra>
do + try is a convenient way to turn throwing APIs into predicate APIs

[14:39:20.0000] <michaelficarra>
isValidJSON becomes much less awkward, for example

[14:39:35.0000] <rkirsling>
mhm

[14:39:36.0000] <TabAtkins>
Oooh, interesting point

[14:40:29.0000] <rkirsling>
I still maintain that "sorry, magic doesn't happen" suffices as an explanation for the loop case

[14:41:10.0000] <TabAtkins>
yeah i'm very happy to handle comprehensions on their own, and much better, than smuggling a basic version in via do-exprs

[14:42:45.0000] <TabAtkins>
i don't understand why break/return would be controversial, i presume there's something subtle in the mechanics

[14:43:00.0000] <TabAtkins>
to my ordinary-webdev eyes, it looks like something that should "just work"

[14:43:33.0000] <ljharb>
TabAtkins: to mine, that would be bad code that every styleguide i influenced would aggressively ban

[14:43:51.0000] <TabAtkins>
i don't disagree with that, but that doesn't mean we should disallow them imo

[14:43:57.0000] <ljharb>
TabAtkins: conflating flow control with expression positions is confusing and hard to maintain, it's why the airbnb guide bans assignment in expression position, for example.

[14:44:01.0000] <TabAtkins>
i'll ask on q

[14:45:33.0000] <TabAtkins>
someone remind me what the completion value of a loop is?

[14:45:44.0000] <littledan>
This proposal is awesome! Let's go for it!

[14:46:15.0000] <ljharb>
TabAtkins: without checking, i'm not sure you'd get any common answer if you polled people about that

[14:46:20.0000] <TabAtkins>
lol def

[14:46:27.0000] <ljharb>
TabAtkins: i *think* it's the last completion value of the last iteration tho

[14:46:30.0000] <TabAtkins>
i'll check, was just asking if someone had it at hand

[14:46:33.0000] <TabAtkins>
that's what i presumed

[14:46:56.0000] <ljharb>
TabAtkins: yeah, `eval('for (var i = 0; i < 3; i++) { i; }')` produces 2

[14:47:42.0000] <shu>
+1 should be legal in sloppy

[14:48:41.0000] <michaelficarra>
I kind of prefer it introducing a strict context actually

[14:48:52.0000] <michaelficarra>
it's a new feature, who would want to write sloppy code inside a new feature?

[14:49:03.0000] <ljharb>
yeah i kind of like that too

[14:49:22.0000] <ljharb>
historically the pushback to that is "refactoring hazard", but somehow that was fine for Modules and `class`

[14:49:31.0000] <michaelficarra>
yeah

[14:49:36.0000] <ljharb>
(ie, `async function`, generators, etc weren't auto-strict for that reason, iirc)

[14:50:18.0000] <michaelficarra>
that makes sense though since functions don't auto-introduce strict and they're just function variants

[14:50:22.0000] <michaelficarra>
this is a new kind of thing, like class

[14:50:34.0000] <michaelficarra>
totally fine for those to introduce strict mode

[14:50:39.0000] <ljharb>
fair

[14:50:57.0000] <rkirsling>
in a way, given that `async function` is a kind of `function` it makes sense that it would need to use `'use strict''` whereas `do {}`, like `class {}`, wouldn't have a directive _within_ it

[14:51:11.0000] <michaelficarra>
^ exactly

[14:51:18.0000] <rkirsling>
so I would agree with strict-only unless we can think of a way in which it is harmful

[14:51:35.0000] <michaelficarra>
I guess I'll open an issue on the repo

[14:53:09.0000] <gibson042>
the intent seems to be introduction of a new block in expression context; silently adding strictness inside that would be quite surprising

[14:53:35.0000] <devsnek>
i'm still sad that control flow isn't allowed

[14:53:51.0000] <michaelficarra>
strictness issue: https://github.com/bakkot/do-expressions-v2/issues/7

[14:53:56.0000] <rkirsling>
gibson042: how do you feel about `x = class {}` though?

[14:54:21.0000] <leobalter>
ljharb: your topic should be a reply, just saying :)

[14:54:26.0000] <gibson042>
the scope introduced by a class expression is much more than a simple block

[14:55:01.0000] <ljharb>
thanks, couldn't find the button

[14:55:56.0000] <rkirsling>
obligatory "stop wanting that"

[14:56:03.0000] <drousso>
^ +1

[14:56:42.0000] <devsnek>
is bradford on irc

[14:56:55.0000] <bradleymeck>
rkirsling: it isn't just about "want" it is about expect

[14:57:06.0000] <rkirsling>
yeah I know

[14:57:06.0000] <bradleymeck>
see people coming from languages from comprehensions

[14:57:15.0000] <bradleymeck>
with comprehensions*

[14:59:08.0000] <TabAtkins>
yeah, requiring an expr limits the usefulness of this a lot

[15:01:17.0000] <rkirsling>
I guess banning loops makes banning break/continue a corollary

[15:01:44.0000] <devsnek>
i don't agree

[15:01:48.0000] <rkirsling>
oh wait

[15:01:49.0000] <shu>
oh god

[15:01:50.0000] <shu>
noooooo

[15:01:53.0000] <shu>
kill me nooooo

[15:01:53.0000] <rkirsling>
no that's not true sorry

[15:01:54.0000] <rickbutton>
tab has ascended

[15:02:04.0000] <TabAtkins>
ugh fuck my cam does this sometimes

[15:02:06.0000] <devsnek>
when ur tesla coil goes off

[15:02:06.0000] <TabAtkins>
skip me for now

[15:02:08.0000] <rkirsling>
was that a shaver? or a taser

[15:02:17.0000] <rickbutton>
thats the sound of someone becoming one with the internet

[15:02:24.0000] <gibson042>
teleporter

[15:02:28.0000] <ystartsev>
the start of some epic noise music

[15:02:36.0000] <rickbutton>
^

[15:03:49.0000] <devsnek>
we had answers for these questions, one of which was that the loop heads don't allow break/continue in them

[15:04:36.0000] <rkirsling>
I feel like the question of what `return` does is an even more legitimate source of confusion than the loop thing

[15:05:26.0000] <devsnek>
the only thing i've seen is that people would expect "return" to be the return value of the do expression

[15:05:33.0000] <devsnek>
which seems surface level enough to not be a blocking concern

[15:05:57.0000] <ljharb>
that's a major point of confusion

[15:06:01.0000] <ljharb>
or would be

[15:06:04.0000] <rkirsling>
I thought there were people arguing for returning from the containing function

[15:06:08.0000] <leobalter>
bterlson: if we still have objections to Stage 2, I'd set this for overflow. I hope we get stage 2 in this meeting

[15:06:30.0000] <ljharb>
rkirsling: the problem is that there's not a common intuition about what it does

[15:06:38.0000] <rkirsling>
that's what I'm saying

[15:06:43.0000] <michaelficarra>
this is an unfortunate situation :-(

[15:06:47.0000] <TabAtkins>
Ugh, no.

[15:06:57.0000] <ljharb>
wsdferdksl: fwiw there's a big difference between a statement that runs 0/1 times, and one that runs 0-N times, and what programmers will expect as the completion value.

[15:07:03.0000] <TabAtkins>
yes def

[15:07:05.0000] <rkirsling>
I *want* to be like "deal with it" for the loop thing but `return` is WAY harder to argue

[15:07:22.0000] <devsnek>
i am surprised that people find return scarier than the loops

[15:07:31.0000] <ljharb>
flow control bad

[15:07:33.0000] <TabAtkins>
rkirsling: Yes, `return` should trigger a return from the containing function.

[15:07:56.0000] <devsnek>
i think if you tell someone what a do expression is

[15:08:02.0000] <rkirsling>
yeah so my problem is that I don't feel like either interpretation is obviously wrong

[15:08:10.0000] <devsnek>
it would be clear to them that the return wouldn't be part of it

[15:08:21.0000] <devsnek>
if someone doesn't know what a do expression is this is all moot anyway

[15:08:38.0000] <devsnek>
since they wouldn't know it has anything to do with `return`

[15:08:55.0000] <TabAtkins>
I mean, having the ability to early-"return" from a do-expr makes sense, but finagling that separately from returning from the outer context is a bunch of work and you might as well just IIFE then

[15:08:57.0000] <rbuckton>
Since `do` is a new syntactic construct, perhaps we could introduce a keyword for explicitly exiting a `do` block with a value, rather than implicitly relying on completion values

[15:08:58.0000] <ljharb>
and when there's multiple intuitive solutions, banning it is both a thing we've done before, and a reasonably approach

[15:09:04.0000] <Bakkot>
alas :(

[15:09:24.0000] <Bakkot>
rbuckton that's been proposed multiple times and fairly resoundingly rejected; I at least am not interested in trying to pick it up again

[15:09:45.0000] <littledan>
Bakkot: keep going!

[15:09:45.0000] <devsnek>
i'm surprised that people think returning early from a do expression makes sense

[15:10:17.0000] <rbuckton>
devsnek: less about returning early, more about making it explicit what the result value is.

[15:10:40.0000] <rkirsling>
is it a block in an "everything's an expression language"? or is it IIFE-like?

[15:10:45.0000] <rbuckton>
If the result value was explicitly defined, then there'd be no confusion about `for`/`while`/etc.

[15:10:57.0000] <rkirsling>
both views can hold for most purposes

[15:11:08.0000] <rkirsling>
therefore both views will exist among the masses

[15:11:16.0000] <devsnek>
i mean with rust, which has expression blocks, i've never seen a single person be confused about it

[15:11:21.0000] <shu>
i remain of the opinion that while early returns from the outer function are useful in obvious places, risks run high of understandability of either figuring out what it should do in the positions where it is currently impossible, or how to best ban them

[15:11:24.0000] <devsnek>
and it's not like a different mental model from js or smth

[15:11:29.0000] <ljharb>
rkirsling: i think in ruby, a block's last completion value is what the block is, but `return` returns from the containing function? it's been awhile tho

[15:11:29.0000] <rkirsling>
devsnek: it's not confusing in Rust

[15:11:37.0000] <rkirsling>
it is a fundamental construct

[15:11:51.0000] <shu>
i imagine rust syntax was designed from ground up to have a more meaningful statement vs expression distinction

[15:11:56.0000] <rkirsling>
^

[15:11:58.0000] <devsnek>
rkirsling: it would even be the same syntax if we didn't have object literals

[15:12:03.0000] <shu>
we have an... accreted such understanding of the distinction in JS

[15:12:15.0000] <rbuckton>
The slides didn't describe `yield`, just that `await` is deferred until `async do` is a thing...

[15:12:18.0000] <rkirsling>
devsnek: I'm not sure that object literals are relevant though?

[15:12:29.0000] <shu>
but not like JS statement-vs-expr distinction was designed with principles

[15:12:33.0000] <devsnek>
no i'm just confused why rust is being dismissed as prior art

[15:12:39.0000] <devsnek>
it seems identical to this

[15:12:42.0000] <shu>
because it is not actually prior art

[15:12:43.0000] <rkirsling>
the question is about the default behavior of statements in a language

[15:12:46.0000] <shu>
we are prior art

[15:13:10.0000] <devsnek>
its prior art on being useful

[15:13:17.0000] <rkirsling>
yeah, this is sandboxed "everything's an expression"

[15:13:29.0000] <rbuckton>
nm, confusion about `async do`. `await` was called out as supported in `do {}`, but `yield` wasn't (though I assume it would be as well, if the outer context was `+Yield`).

[15:13:51.0000] <devsnek>
rkirsling: i don't know what you mean

[15:14:09.0000] <rkirsling>
I mean I've said it to you personally in every conversation about this

[15:14:18.0000] <Bakkot>
rbuckton yeah, see readme: https://github.com/bakkot/do-expressions-v2#awaityield

[15:14:22.0000] <devsnek>
no i mean i literally don't know what you're saying

[15:14:26.0000] <rkirsling>
Rust isn't confusing because there's nothing to be confused by in an everything's-an-expression language

[15:14:58.0000] <devsnek>
i'm saying no one has ever been confused by returns inside blocks inside expression positions

[15:15:06.0000] <ystartsev>
Bakkot:  some stuff might be testable via a usability study

[15:15:17.0000] <rkirsling>
but when you're adding that behavior on *top* of a language's norms then people can find justification for different interpretations

[15:15:20.0000] <ystartsev>
if that sounds interesting i can raise it with the research group? it would be a nice topic for us

[15:15:21.0000] <devsnek>
and i guess you're saying rust is so fundamentally different from js that it doesn't count?

[15:15:28.0000] <devsnek>
but i don't agree with that

[15:15:52.0000] <TabAtkins>
`yield` not implying `return` makes sense from the code-review standpoint (we expect `yield` to be resumed from; if it doesn't, that's a massive code smell on its own), but at least it assures me that there's nothing technical about `return` being hard (unlike `break`/`continue`)

[15:15:53.0000] <Bakkot>
ystartsev I think in this particular case a usability study wouldn't help with anything

[15:15:57.0000] <rkirsling>
I don't mean it doesn't count

[15:16:26.0000] <rkirsling>
it's just that if we're gonna worry about loop behavior, which I do not consider confusing within the context of JS

[15:16:31.0000] <ystartsev>
well, let me know if we can help -- it would allow testing out some intuitions people might have about how people would approach these things

[15:16:34.0000] <rbuckton>
If we allow `const x = y ?? do { return; }`, why wouldn't we just allow `const x = y ?? return;` (following the "everthing's an expression" concept). We investigated this when we were discussing throw expressions.

[15:16:39.0000] <rkirsling>
then `return` is obviously a *greater* concern than that

[15:17:01.0000] <rkirsling>
because there are justifications for both views within the context of JS norms

[15:17:29.0000] <TabAtkins>
rbuckton: I mean, sure, but that's neither here nor there. return-exprs don't seem too wild to me, but neither is there a big request for them

[15:17:49.0000] <TabAtkins>
vs the more complex code flow we implicitly expect in a do-expr, which I *do* think I'll end up wanting to put early-returns into

[15:17:52.0000] <devsnek>
rkirsling: i also don't see the connection between the loops and this

[15:18:20.0000] <rbuckton>
There was back when I first introduced `throw` expressions, at least from the committee's side.

[15:18:43.0000] <TabAtkins>
In the context of throw-exprs, return-exprs seem like a natural extension, sure

[15:18:51.0000] <rkirsling>
devsnek: they are the controversial topics

[15:18:52.0000] <TabAtkins>
But this is a different context. ^_^

[15:19:51.0000] <devsnek>
rkirsling: yeah it just seems to me that the controversy of the control flow is mostly coming from people who won't look at languages with block expressions as evidence that this isn't confusing

[15:21:20.0000] <rbuckton>
The biggest issue with `throw` expressions was that `do` was possibly going to be a thing, and that they'd have to be in `Expression`, so things like `const x = throw a, b = c` would be illegal, since `throw a, b = c` has a meaning as a staetment (i.e., you'd need to write `const x = (throw a, b = c)` or `const x = (throw a), b = c`).

[15:21:40.0000] <TabAtkins>
Ok thinking about the break/continue case, I can definitely see how something like `while(...) { for(var i = 0; i < do { continue; }; i++) { ... } }` is confusing - I don't know whether I'd expect it to continue the `while` or the `for`

[15:21:57.0000] <devsnek>
i don't think break/continue should be allowed in loop heads

[15:22:00.0000] <Bakkot>
devsnek I've used such languages a fair bit and I agree with rkirsling that they are not that strong of evidence

[15:22:06.0000] <rbuckton>
that even lead me to propose `ParenthesizedExpression: ( Statement )` on the `do` proposal issue tracker.

[15:22:09.0000] <devsnek>
like i wouldn't even put the restriction on do expressions

[15:22:14.0000] <devsnek>
i'd put it on the entirety of the head

[15:22:27.0000] <TabAtkins>
yeah, just having a restriction against their use in loop heads works for me, it's just another special-case restriction to learn. probably reasonable tho, imo.

[15:23:18.0000] <devsnek>
on an interesting note, back when v8 had do expressions because they used them internally, if you put break/continue in loop heads it would segfault

[15:24:07.0000] <devsnek>
Bakkot: yeah but like *why*

[15:24:37.0000] <devsnek>
i mean i can see why you might say using haskell or something is not a great comparison to how js people would approach it

[15:24:48.0000] <devsnek>
but these are not niche fp languages

[15:24:52.0000] <Bakkot>
because in languages in which everything is an expression you are not surprised when you can return in expression context, and this is not true for languages where not everything is an expression

[15:25:08.0000] <Bakkot>
like I just don't agree that you can generalize from rust to js

[15:25:28.0000] <devsnek>
what does "surprised" mean

[15:25:31.0000] <Bakkot>
or scala to js or whatever

[15:25:32.0000] <Bakkot>
they are different styles of programmnig

[15:26:21.0000] <Bakkot>
devsnek in this context, it mostly means "likely to miss or misunderstand what the code does when reading it"

[15:26:34.0000] <rkirsling>
it's not about niche-ness

[15:27:58.0000] <devsnek>
i'd actually be surprised if most people who use rust know that return is an expression

[15:29:34.0000] <Bakkot>
anyway I am not entirely sure what to do here

[15:29:43.0000] <rkirsling>
same...

[15:29:56.0000] <Bakkot>
I've heard from people that they are not willing to advance this if it allows return/break

[15:30:08.0000] <Bakkot>
and wsdferdksl says he is not willing to advance without

[15:30:09.0000] <Bakkot>
so

[15:30:24.0000] <rkirsling>
ljharb is in the former camp right?

[15:30:42.0000] <rkirsling>
so then we have a standstill?

[15:31:00.0000] <rkirsling>
I don't understand why it would be necessary initially

[15:31:03.0000] <Bakkot>
seems like

[15:32:12.0000] <rkirsling>
really vexing seeing how pattern matching is depending on this

[15:32:57.0000] <devsnek>
i think pattern matching depends on the consensus around how the completions are handled, not the literal do expression?

[15:33:11.0000] <devsnek>
and stuff like if loops/returns/etc are allowed

[15:36:28.0000] <shu>
ljharb is opposed to any return?

[15:37:45.0000] <devsnek>
if i were a more assertive i'd probably block on the lack of return

[15:38:08.0000] <shu>
and you would ban do expressions in loop heads?

[15:38:22.0000] <devsnek>
no i would ban break/continue in loop heads

[15:38:26.0000] <ljharb>
i think allowing `return` is a big problem, yes

[15:38:45.0000] <shu>
devsnek: ok

[15:39:04.0000] <ljharb>
it's very confusing; people won't universally intuit whether it returns from the containing function or from just the do expression, and allowing flow control to change in more places makes understanding the language harder, especially in the edge cases.

[15:39:46.0000] <shu>
devsnek: and you are also opposed to the "conservative MVP, relax later if demand arises" plan, like waldemar?

[15:40:02.0000] <ljharb>
i do agree that it could be added later if it ended up being a sticking point, but the value of do expression for me doesn't include return/break/continue, or loop completion values.

[15:40:17.0000] <devsnek>
shu: i don't enjoy that type of plan but to be clear i'm not blocking here

[15:40:26.0000] <shu>
ok

[15:42:30.0000] <ljharb>
(also, for me, "exactly replaces IIFEs" is definitely more than enough to warrant its syntactic weight, but i recognize everyone doesn't agree with that)

[15:42:58.0000] <devsnek>
I think at the very least, the limitation makes it more difficult to refactor code because you have to start refactoring control flow in addition to value flow

[15:44:34.0000] <rkirsling>
I mean

[15:44:36.0000] <ljharb>
devsnek: do you have some examples? my suspicion is that such a refactor would make the code much clearer

[15:44:44.0000] <ljharb>
meaning, it'd be an improvement even without do expressions

[15:44:48.0000] <devsnek>
1s

[15:44:50.0000] <ljharb>
ty

[15:44:54.0000] <rkirsling>
sometimes you explicit *don't* want to let people use a thing as a drop-in replacement

[15:45:04.0000] <rkirsling>
I'm not saying that's for sure the case here but

[15:45:12.0000] <rkirsling>
that is a valid stance for a proposal to take

[15:45:19.0000] <rkirsling>
*explicitly

[15:46:03.0000] <rkirsling>
just thinking, y'know, maybe it's a good thing that you don't have a subcommunity arise that's all

[15:46:14.0000] <rkirsling>
"protip: wrap your modules in do {}"

[15:46:19.0000] <devsnek>
ljharb: https://gist.github.com/devsnek/4ca441da666caa9eff80877a97e858dc

[15:47:25.0000] <rkirsling>
is quix the nestle version of quux

[15:47:30.0000] <ljharb>
devsnek: i mean, i'd model that as `const x = do { /* foo/bar/baz */ }; if (x) { doSomethingWith(x); } else { return quix; }`, but it's tricky to talk about contrived examples

[15:47:57.0000] <devsnek>
i feel like that code, albeit with more realistic conditions, exists exactly as written in lots of code bases

[15:48:19.0000] <devsnek>
and your refactoring moves the domain of x to include the control flow

[15:48:52.0000] <ljharb>
in the refactoring, it separates "pick a value, and process it" from "return a value"

[15:49:08.0000] <ljharb>
it's subjective ofc, but that seems cleaner to me

[15:49:18.0000] <devsnek>
i mean like, what if `x` could be zero

[15:49:24.0000] <devsnek>
or what if x could be null

[15:49:27.0000] <devsnek>
or what if x could be undefined

[15:49:43.0000] <ljharb>
ok so let's say `x` can be any value, since the others have obvious answers:

[15:49:57.0000] <devsnek>
the point is that i now have to think about that or just not take advantage of an otherwise useful feature

[15:50:15.0000] <ljharb>
actually yeah for this example where the context isn't present, i'm not sure what i'd do

[15:50:29.0000] <devsnek>
i think "don't use do expressions" is a valid answer

[15:50:32.0000] <ljharb>
but the do expression refactoring you *want* there isn't really an improvement

[15:50:33.0000] <devsnek>
it just makes me sad

[15:50:34.0000] <ljharb>
yes, me toop

[15:50:38.0000] <ljharb>
but i think you shouldn't use them there anyways

[15:50:55.0000] <ljharb>
because it isn't adding clarity. it's just making a series of statements *also* have the implications of expression position.

[15:52:35.0000] <devsnek>
I think the code would be clearer with and even be idiomatic with do expressions and return

[15:52:44.0000] <devsnek>
at least based on how people use this functionality in other languages

[15:53:21.0000] <ljharb>
i'm not sure one can reliably draw conclusions about idioms in JS from idioms in other languages, but i think i understand your point


2021-01-27
[16:08:56.0000] <shu>
for the ResizableArrayBuffer rounding discussion, i filed two issues: https://github.com/tc39/proposal-resizablearraybuffer/issues/23 and https://github.com/tc39/proposal-resizablearraybuffer/issues/24 to separate the questions of rounding maxByteLength vs byteLength, please let me know of your thoughts in there

[16:14:55.0000] <devsnek>
shu: is there a chance the rounding could be used for fingerprinting?

[16:17:39.0000] <shu>
devsnek: yeah, i called that out in the presentation. depending on the degree of implementation latitude allowed

[16:18:18.0000] <shu>
devsnek: i'm not sure how much of a fingerprinting concern that is vs other vectors

[16:18:39.0000] <devsnek>
yeah, its nice to keep a handle on though

[16:19:03.0000] <shu>
it'll tell you the version(s) of the VM you're on, probably, but not much else

[16:19:34.0000] <shu>
that kind of fingerprinting is inherently built-in via other vectors as well

[17:58:24.0000] <shu>
rbuckton: do you happen to have any links to positive or negative sentiment expressed for match indices?

[17:58:48.0000] <shu>
a recent refinement of the blink shipping process is evidence supporting "developer signal"

[17:59:16.0000] <shu>
i thought we have captured in the notes somewhere that non-browser dev practitioners (e.g. ljharb) would use match indices if they were available, but i can't find it

[18:05:39.0000] <ljharb>
i don't have concrete use cases off hand, but i have clear memories of needing this functionality in the past

[18:06:25.0000] <ljharb>
shu: probably not, but does 304 votes on https://twitter.com/ljharb/status/1154100770985242624 help?

[18:09:25.0000] <shu>
ljharb: yes it does!

[18:09:29.0000] <ljharb>
yay

[18:09:32.0000] <shu>
well, at least obliquely

[18:09:46.0000] <ljharb>
it's not *no* signal, i guess

[18:09:51.0000] <shu>
the amount of votes show that a some devs in the wild care about it

[18:10:17.0000] <ljharb>
a few replies also

[18:10:21.0000] <shu>
and we can probably reasonably extrapolate that a portion of the 300 participants are non-browser devs

[18:10:26.0000] <shu>
yeah, the replies are good

[18:10:59.0000] <shu>
i am not happy about this new shipping process requirement, given that i think tc39 already represents practitioner constituents directly through delegates such as yourself

[18:11:16.0000] <shu>
but otoh, having evidence too show there's positive sentiment does seem fair

[18:11:19.0000] <ljharb>
sure

[18:11:40.0000] <ljharb>
but also, a tweet "do yall like this?" from a chromium account would probably answer that rapidly

[18:11:53.0000] <shu>
what am i, devrel?

[18:11:58.0000] <ljharb>
lol

[18:12:27.0000] <shu>
(no disparagement too devrel, but being that popular seems hard)

[18:12:42.0000] <shu>
stupid key sticking on the mba keyboard

[05:10:41.0000] <littledan>
I'm pretty unsympathetic to both the strong-pro and strong-con arguments on return

[05:11:04.0000] <littledan>
I don't think that we have to care so much about programmers suddenly generating an intuition that do expressions get their own return semantics

[05:11:26.0000] <littledan>
I mean, there's a completely unbounded amount of possible intuitions people could get. It just isn't possible to control for these.

[05:12:00.0000] <littledan>
On the other hand, I don't mind restricting the "power" of do expressions to not let them do control flow that jumps over their boundaries; that feels reasonable

[10:00:34.0000] <robpalme>
anyone having trouble getting into the meeting?

[10:00:55.0000] <robpalme>
we have 16 folk in

[10:09:22.0000] <rkirsling>
littledan: I don't think I understand what position you're expressing (aside from the last sentence which makes sense)

[10:09:41.0000] <littledan>
rkirsling: That, I'd be OK with return being permitted or prohibited from do expressions

[10:10:10.0000] <littledan>
what I disagree with is the strong arguments that it must be included or excluded

[10:10:22.0000] <rkirsling>
ah yeah. I agree with that

[10:12:56.0000] <michaelficarra>
haxjs: are you currently available for your presentation?

[10:15:11.0000] <michaelficarra>
is the transcription bot dead?

[10:15:32.0000] <michaelficarra>
never mind, it just got congested

[10:17:38.0000] <ryzokuken>
is IRCCloud okay?

[10:17:52.0000] <rickbutton>
works for me

[10:18:04.0000] <ljharb>
given that it wouldn't make any sense at all to allow `return` in `async do`, it seems like thats a consistency argument to forbid `return` in `do`.

[10:18:30.0000] <ryzokuken>
rickbutton: do you see the netsplits?

[10:18:37.0000] <ryzokuken>
or is it something on my end?

[10:18:53.0000] <ljharb>
what is graalix (sp) ?

[10:18:54.0000] <rickbutton>
only if the return returns from the surrounding function, not the do ljharb, but yes i agree with the consistency argument

[10:19:05.0000] <rkirsling>
oh phew it's back

[10:19:12.0000] <ljharb>
rickbutton: true. if it returns just from the `do` it could work in both

[10:19:28.0000] <rkirsling>
supposedly unstable more than completely out: https://twitter.com/IRCCloud/status/1354490157563572228

[10:23:22.0000] <gibson042>
ljharb: I've seen it as "grawlix"

[10:23:39.0000] <gibson042>
https://en.wiktionary.org/wiki/grawlix

[10:23:59.0000] <ljharb>
gibson042: ty

[10:24:09.0000] <ljharb>
rkirsling: i must be on ipv4, i didn't notice any issues

[10:24:41.0000] <TabAtkins>
ljharb: I dont' understand - why wouldn't it make sense to `return` in `async do`?

[10:24:55.0000] <TabAtkins>
It seems to make exactly as much sense as returning in a sync do.

[10:24:58.0000] <ljharb>
TabAtkins: kevin explained, because the containing function has already returned

[10:25:01.0000] <TabAtkins>
OH WAIT

[10:25:08.0000] <TabAtkins>
I'm being dumb, ignore me

[10:25:21.0000] <TabAtkins>
Yeah, the async context would prevent a `return` from escaping

[10:25:24.0000] <ljharb>
right

[10:25:29.0000] <ljharb>
"early exiting the `do` with an explicit value" makes sense in both

[10:25:38.0000] <ljharb>
but "early returning the containing function" can only work in sync do

[10:25:38.0000] <ystartsev>
I had the same comment as shu, but yep that is our concern as well

[10:26:42.0000] <TabAtkins>
Yes. So I agree, given that I think `async do` is a must-have on top of sync-do, and `return` would *necessarily* do something local in async-do,  *and* `return` in sync-do has two different obvious things it could do, we should just ban `return` in sync-do.

[10:27:26.0000] <rickbutton>
i still argue that only one of those obvious things is obvious

[10:27:54.0000] <rickbutton>
(to me, a return inside a do does not imply return from outer function)

[10:28:17.0000] <ljharb>
TabAtkins: that is my conclusion as well

[10:28:32.0000] <TabAtkins>
i popped a comment on the queue to state it on record

[10:28:35.0000] <ljharb>
sweet

[10:29:16.0000] <TabAtkins>
rickbutton: It was perfectly obvious to me that it would return from outer function, so my statement was correct that there are two obvious things. ^_^

[10:29:41.0000] <rickbutton>
yeah i understand i just really want to be able to early return from these

[10:30:07.0000] <ljharb>
make a follow-on for a new keyword to do it :-p

[10:30:10.0000] <TabAtkins>
yup

[10:30:11.0000] <rickbutton>
gross

[10:30:13.0000] <ljharb>
`return.from.do.expression value`

[10:30:17.0000] <rickbutton>
early_exit

[10:30:35.0000] <ljharb>
`return.{} value`

[10:30:47.0000] <rickbutton>
do.return

[10:30:55.0000] <ljharb>
ha, nice

[10:30:56.0000] <rickbutton>
ugh, they keep getting worse

[10:31:12.0000] <TabAtkins>
meta properties are real :millie-bobby-brown-mind-blown-gif:

[10:31:12.0000] <ljharb>
`do.yield`

[10:31:25.0000] <rickbutton>
gotta get do generators first

[10:31:36.0000] <ljharb>
oh_no.jpg

[10:32:39.0000] <rickbutton>
I'm gonna keep playing devils advocate and say that you could say the opposite, that the fact that async-do return can only work one way, that sync should just also work that way

[10:32:41.0000] <rickbutton>
troll.png

[10:33:03.0000] <ljharb>
ban it from both, yes

[10:33:42.0000] <ljharb>
(i don't actually care about yield either way)

[10:34:17.0000] <ljharb>
wsdferdksl: what's the confusion about `this`?

[10:34:30.0000] <ljharb>
littledan: jinx, you owe me a coke

[10:34:43.0000] <littledan>
haha

[10:36:47.0000] <littledan>
I guess Waldemar was doing a kind of reductio ad absurdum and wasn't actually arguing to ban `this`

[10:36:57.0000] <littledan>
so, I don't think I'll follow up with it in the issues

[10:37:29.0000] <michaelficarra>
maybe we disable transcription for this topic?

[10:38:09.0000] <ryzokuken>
michaelficarra: I guess it would be best to manually transcribe?

[10:38:23.0000] <TabAtkins>
I also don't understand what the `this` confusion could even possibly be. Where would you get the `this` binding other than from the outer context?

[10:39:34.0000] <michaelficarra>
ryzokuken: I think so, yes

[10:47:33.0000] <ystartsev>
huh.. is that the right understanding ljharb? i was thinking that the brand check would be from the class, and you wouldn't need to check each one?

[10:48:20.0000] <ljharb>
ystartsev: it depends how rigorous you need to be; technically you can have one private field installed on a number of objects, and other private fields on other objects

[10:48:32.0000] <TabAtkins>
rickbutton: I'm curious why your intuition says that `return` in sync-do should be block-local, but `await` and `yield` escape the block.

[10:48:48.0000] <ljharb>
ystartsev: but it's pretty obscure. in the common case, the checks are basically the same - whether "has one field", "has all fields", or hax's "is class C"

[10:49:08.0000] <rickbutton>
TabAtkins: I don't think await and yield should escape the block, if return doesn't either

[10:49:17.0000] <ystartsev>
cool, thanks for clarifying

[10:49:34.0000] <ljharb>
ystartsev: so for the common case, it's just about which is clearer to understand. my argument is that both are needed for that, and mine is the lower-level one that the higher-level one can be built with; hax's can add the higher-level one on top.

[10:49:49.0000] <TabAtkins>
Ah, k. So that makes sync-do much less useful in async contexts. (yield is definitely of marginal utility either way)

[10:50:25.0000] <TabAtkins>
Hmmmm I can feel my intuition reconfiguring, I'll have to write an issue.

[10:50:28.0000] <rickbutton>
yeah, you would instead use an async do in an async context

[10:51:10.0000] <rickbutton>
yeah plz do, ill comment my thoughts too. im not an objector either way, do/async do will have great utility either way

[10:51:15.0000] <TabAtkins>
Ehhh that's just more keywords scattered about. Would mean that if your do-expr needs to await something, you have to prefix it with `await async`

[10:51:37.0000] <rickbutton>
further down the rabbit hole, do inside async is implicitly an async do

[10:51:42.0000] <rickbutton>
feels gross

[10:52:13.0000] <rickbutton>
actually nvm

[10:52:17.0000] <littledan>
I'm kinda confused by examples. None of them field initializers, so instances will either have all fields or none, so I don't understand this point about checking all of the fields. You should only ever check one.

[10:52:20.0000] <rkirsling>
rickbutton: no that distinction was addressed

[10:53:08.0000] <ystartsev>
wsdferdksl: do you want to ask that clarifying question now or is it ok to wait until he finishs?

[10:53:35.0000] <rickbutton>
yes, sorry missing words from that sentence, i mean to suggest that as an alternative to requiring an async do inside async ctx in order to await inside do, not that async/sync do inside async ctx are the same

[10:53:43.0000] <rickbutton>
but either way bad idea ignore it

[10:59:39.0000] <robpalme>
it sounds like, if the class uses class.hasInstance, we expect the implementation to tag the instances somehow so that the check can occur later.  and the reason for the "if" is that this tagging may have a memory overhead.

[11:04:36.0000] <ljharb>
ystartsev: 3 replies,. waldemar's is first

[11:05:27.0000] <ystartsev>
whoops, it jumped ahead

[11:08:29.0000] <ljharb>
ooh, very good question

[11:12:42.0000] <littledan>
to be concrete, it sounds like Hax is proposing that this get added in the same way as methods (at the beginning of the fields). Is that accurate?

[11:13:20.0000] <ljharb>
it's not clear if it would install a new field and check for that, or if it would check for "all expected private fields"

[11:14:56.0000] <littledan>
OK, it sounds like the idea is to leave this as an open question for later

[11:17:56.0000] <ljharb>
ystartsev: these are stage 2 concerns, can we maybe defer them?

[11:18:52.0000] <jridgewell>
just now joining. How does `hasInstance` work with subclasses?

[11:19:07.0000] <ljharb>
jridgewell: it'd return true as long as the subclass called super, i assume

[11:19:14.0000] <ljharb>
just like `#x in o` would

[11:19:19.0000] <jridgewell>
Ok

[11:22:08.0000] <littledan>
I support Stage 3

[11:32:33.0000] <michaelficarra>
I am deeply appreciative of the unique perspective that Bradley brings to committee :-)

[11:32:55.0000] <akirose>
me too!

[11:33:16.0000] <wsdferdksl>
Agree

[11:34:11.0000] <akirose>
also something i was thinking about is how much i respect how a handful of y'all are super comfortable saying "i don't know" (Bradley included) when relevant. the committee does better work because of it.

[11:40:14.0000] <shu>
ystartsev: request for facilitator to keep discussion on GC short

[11:40:18.0000] <shu>
it's not that material imo

[11:40:38.0000] <gibson042>
haxjs: given `class C extends class{constructor(v){return v}} { constructor(){super(...arguments)} #a; #x = (()=>{throw new Error()})(); #b; }`, evaluating `new C({})` will add private field #a but *not* #b

[11:40:41.0000] <ystartsev>
ok

[11:42:10.0000] <haxjs>
@gibson042 , I understand that. The issue is whether such edge case is strong enough to support another individual syntax feature for that.

[11:42:44.0000] <gibson042>
what do you mean by "another" individual syntax?

[11:42:50.0000] <littledan>
maybe we can ask for acknowledgement?

[11:44:08.0000] <bradleymeck>
forgot i had to connect, sorry

[11:44:47.0000] <bradleymeck>
littledan: to my knowledge per my reading, a finalizer never *must* fire, but it appeared it cannot fire if its target is stored in a private field?

[11:45:08.0000] <bradleymeck>
/me goes back rereading weakrefs

[11:46:07.0000] <haxjs>
@gibson042 I mean use `#x in o` to test these edge cases.

[11:47:05.0000] <gibson042>
yes, the point of this proposal is to make it more ergonomic to detect the presence vs. absence of a private field

[11:47:48.0000] <gibson042>
it adds no new capability, just syntax sugar

[11:48:18.0000] <shu>
what is going on

[11:48:45.0000] <ystartsev>
we want to make sure we don't go ahead without a soun check

[11:49:14.0000] <ljharb>
we don't want technical difficulties or language barriers to cause someone's voice to go unheard.

[11:49:22.0000] <shu>
ah okay, sg

[11:51:27.0000] <wsdferdksl>
ystartsev: Thank you for herding cats this morning!

[11:51:41.0000] <ystartsev>
that was one of the harder ones!

[11:51:53.0000] <littledan>
well-done ystartsev !

[11:51:58.0000] <rickbutton>
fantastic job

[11:52:04.0000] <wsdferdksl>
I agree

[11:53:28.0000] <ljharb>
ystartsev: +1, thank you very much for chairing a contentious topic so calmly

[11:54:30.0000] <shu>
+2

[11:57:44.0000] <robpalme>
can the google folk make sure Frank Tang is around to present next

[11:58:16.0000] <shu>
i will ping him

[11:58:20.0000] <shu>
first up after lunch?

[11:58:51.0000] <robpalme>
it's ok - he is here on the call

[12:01:27.0000] <Bakkot>
if anyone is in touch with the person who was on the call as "Zelda Jay", can you ask them to add their preferred abbreviation to https://github.com/tc39/notes/blob/master/delegates.txt ?

[12:02:09.0000] <Bakkot>
(or tell me which one it is, if they're already on it)

[12:11:50.0000] <ljharb>
i believe it's LZU

[12:12:11.0000] <ljharb>
haxjs ^ can you confirm?

[12:12:42.0000] <haxjs>
confirm what?

[12:13:05.0000] <ljharb>
haxjs: that zeldajay is limin zhu

[12:13:58.0000] <haxjs>
Ok I will check that

[12:14:04.0000] <ljharb>
thanks!

[12:14:22.0000] <ljharb>
(if not, then "which abbreviation in delegates.txt is zeldajay")

[12:14:48.0000] <haxjs>
It should be LZJ

[12:15:04.0000] <ljharb>
aha ty

[12:15:09.0000] <haxjs>
zeldjay is  Zhi Jie Li (LZJ) I believe

[12:15:18.0000] <ljharb>
https://github.com/tc39/notes/blob/master/delegates.txt#L372, perfect

[12:15:19.0000] <ljharb>
Bakkot: ^

[12:15:30.0000] <ljharb>
i remembered an L and a Z but wasn't sure which :-)

[12:15:32.0000] <Bakkot>
thanks!

[12:15:32.0000] <haxjs>
he is not online now, i will update if i make it wrong.

[12:15:36.0000] <ljharb>
perfect

[12:23:50.0000] <Bakkot>
I made a survey about do-expressions. I'd highly appreciate if delegates could fill it out; it should only take a second: https://docs.google.com/forms/d/e/1FAIpQLScyNcGNfjoJXMTmfBkLRMREKCP2TihiFGqc26HhjL4710qdiA/viewform?usp=sf_link

[12:24:32.0000] <Bakkot>
akirose / other chairs: if we have a spare minute or two today, I'd like to speak on the VC to ask people to fill it out

[12:27:27.0000] <akirose>
robpalme: heads up ‚òùüèª would you like me to explicitly put it on the schedule?

[12:28:57.0000] <robpalme>
plz

[12:29:09.0000] <ystartsev>
Bakkot: can i share it with my team?

[12:29:34.0000] <Bakkot>
ystartsev sure!

[12:29:44.0000] <ystartsev>
sweet

[12:30:05.0000] <Bakkot>
ask them to put "(mozilla)" in their "who are you", maybe, so I know who they are?

[12:30:50.0000] <robpalme>
*** we restart at 12:50 PT ***  i.e. 10 mins earlier than usual

[12:31:10.0000] <ystartsev>
Bakkot: will do -- if any get missed and you aren't sure you can run the names by me and i will confirm if they are from my team

[12:31:14.0000] <Bakkot>
‚àö

[12:49:07.0000] <robpalme>
*** we are starting in 1 minute ***

[12:51:28.0000] <robpalme>
bakkot - are you good with notes?

[12:52:17.0000] <Bakkot>
robpalme yup

[12:52:29.0000] <robpalme>
thank you (i forgot to ask)

[13:00:02.0000] <sffc>
I'm prepared to give eraDisplay for Stage 1 today if there's time

[13:00:11.0000] <sffc>
it's currently scheduled for tomorrow

[13:01:52.0000] <robpalme>
thank you, sffc, I think we will take you up on that

[13:25:36.0000] <michaelficarra>
since all these functions are going to have different names, should we have a `Symbol.brandChecker` that is a getter for the brand checking function for that particular built-in?

[13:25:48.0000] <Bakkot>
not sure if seroius

[13:25:49.0000] <Bakkot>
but

[13:25:49.0000] <Bakkot>
no

[13:25:52.0000] <ljharb>
michaelficarra: on the constructor or the instance?

[13:25:59.0000] <michaelficarra>
the contructor

[13:26:14.0000] <ljharb>
either way, if we had a symbol, it wouldn't be robust unless that property was nonconfigurable/nonwritable

[13:26:40.0000] <michaelficarra>
Array.isArray is nonconfigurable?

[13:26:52.0000] <ljharb>
oh i see what you mean

[13:26:58.0000] <rickbutton>
suggestion: put a [[Brand]] Symbol on Map, make Object.hasBrand(myMap, Map)

[13:27:00.0000] <michaelficarra>
these things are robust only when you already have a pointer to them

[13:27:06.0000] <ljharb>
so not Map.isMap(), but just Map[Symbol.brandChecker]?

[13:27:15.0000] <michaelficarra>
rickbutton: that also works

[13:27:19.0000] <ljharb>
rickbutton: right, a single global method that looks up a symbol would be one approach

[13:27:28.0000] <michaelficarra>
ljharb: or both

[13:27:32.0000] <ljharb>
sure

[13:27:37.0000] <ljharb>
i'm fine with that, especially if the thing behind the symbol is a cacheable function

[13:27:49.0000] <michaelficarra>
yeah, it can be the same value

[13:30:52.0000] <bradleymeck>
littledan: per my comment; I'm curious if reliable check exists how/why it would differ from a public API for class.hasInstance

[13:31:27.0000] <ljharb>
bradleymeck: because regular classes wouldn't need to have anything by default more than `instanceof`

[13:31:44.0000] <ljharb>
bradleymeck: however if there's a symbol protocol, a user class could choose to make it more robust than that

[13:33:07.0000] <bradleymeck>
ljharb: if I install a Symbol.hasInstance on a 3rd party it wouldn't actually check that class has the internal slots

[13:33:09.0000] <ystartsev>
littledan ljharb can we write down the context that came to light regarding the thinking around brand checks? I can bug you next week.

[13:33:22.0000] <ljharb>
bradleymeck: right - but if that class author did so then it could check that

[13:33:33.0000] <ystartsev>
also, if anyone is curious, at() is not currently shipping. i believe we only had it behind a flag and that has not changed: https://bugzilla.mozilla.org/show_bug.cgi?id=1681371

[13:33:36.0000] <ystartsev>
we almost turned it on

[13:33:44.0000] <ystartsev>
but the web compat issue came up just before we did

[13:33:45.0000] <bradleymeck>
ljharb: if it makes it non-configurable/writable yes, but this seems extremely uncommoon

[13:33:52.0000] <ljharb>
ystartsev: i don't know if anything "came to light", i think it's just that my request for module blocks made dan realize this was a problem worth solving holistically

[13:34:09.0000] <ljharb>
whereas i've always thought this, but thought it was a nonstarter given previous committee reaction to it

[13:34:10.0000] <ystartsev>
ljharb: i mean around the reasoning for the invariant

[13:34:18.0000] <ystartsev>
sorry, if that wasn't clear

[13:34:32.0000] <ystartsev>
because iiuc the context might be worth writing down?

[13:34:45.0000] <ljharb>
oh. i'm not sure there's any new reasoning? it's basically "make sure the thing i'm given is the thing i'm expecting"

[13:34:49.0000] <ljharb>
is, not "has the same interface as"

[13:36:33.0000] <ljharb>
shu: tbh the easiest fix for them is to add `'$' +` to the assignment/lookup of the key

[13:37:05.0000] <littledan>
which library was that?

[13:37:11.0000] <michaelficarra>
I thought the SugarJS usage was compatible though

[13:37:18.0000] <littledan>
these compatibility issues often have to do with how the methods are installed

[13:37:24.0000] <littledan>
like, if they are installed unconditionally, it's fine

[13:37:48.0000] <michaelficarra>
exactly, which Is why I think it was okay

[13:38:16.0000] <jridgewell>
I think they are using it as a map

[13:38:29.0000] <jridgewell>
Eg, random setting/lookup of keys

[13:38:46.0000] <jridgewell>
And `at` is a valid key for them

[13:39:32.0000] <rkirsling>
yeah 'at' is key from a query string of theirs

[13:39:41.0000] <littledan>
haxjs: Can we make sure that the version numbers are written in the notes so it can be followed up on later?

[13:40:11.0000] <haxjs>
sugarjs first version to 1.3.9

[13:40:38.0000] <haxjs>
corejs 0.2.0 to the version they released 2 month ago

[13:41:04.0000] <ljharb>
wait, core-js 3 had string.prototype.at?

[13:41:09.0000] <haxjs>
yes

[13:41:12.0000] <ljharb>
i thought core-js 3 stopped shipping pre-stage-3 proposals by default, hm

[13:41:15.0000] <haxjs>
they always have.

[13:41:28.0000] <haxjs>
no, if u import 'core-js' u will have everything.

[13:41:38.0000] <haxjs>
include pre-stage-3

[13:41:40.0000] <ljharb>
ouch, ok

[13:41:56.0000] <shu>
ljharb: i'm just waiting for them to respond; yes, i imagine there're a variety of ways to do a quick fix

[13:42:02.0000] <ljharb>
core-js has almost disrupted as much as mootools by now :-(

[13:42:47.0000] <haxjs>
the good news is babel-runtime will not take these polyfills.

[13:43:06.0000] <haxjs>
but still very dangerous

[13:43:17.0000] <haxjs>
especially string case is very subtle.

[13:52:51.0000] <Bakkot>
survey: https://docs.google.com/forms/d/e/1FAIpQLScyNcGNfjoJXMTmfBkLRMREKCP2TihiFGqc26HhjL4710qdiA/viewform?usp=sf_link

[13:53:25.0000] <Bakkot>
https://docs.google.com/forms/d/e/1FAIpQLScyNcGNfjoJXMTmfBkLRMREKCP2TihiFGqc26HhjL4710qdiA/viewform?usp=sf_link

[13:55:29.0000] <haxjs>
There are some questions all options can't match my opinion precisely :)

[14:02:20.0000] <Bakkot>
haxjs feel free to use the "other concerns" box to explain in more depth!

[14:04:12.0000] <haxjs>
Yes, already submit.

[14:11:18.0000] <michaelficarra>
"at least as useful as an existing feature" seems like a high/arbitrary bar IMO

[14:19:28.0000] <akirose>
so we're all clear, and I _think_ this is a theme of the comments but also i seem to be struggling to follow complex thoughts this afternoon, nothing we do will eliminate the fact that humans are making these decisions and humans are fallible

[14:20:03.0000] <littledan>
server-side apps have resource limitations as well

[14:20:09.0000] <akirose>
we're not trying to pretend that we can magically objective (yes i'm using that as a verb) our decisions, right?

[14:20:13.0000] <littledan>
but, yeah, I agree, we should consider all of these things

[14:24:13.0000] <wsdferdksl>
Agenda for tomorrow afternoon is rapidly shrinking‚Ä¶

[14:26:50.0000] <brad4d>
re: .at() I was surprised that a single website was sufficient to force unshipping. Is bricklink especially important?

[14:27:52.0000] <brad4d>
It's a LEGO marketplace. :)

[14:28:00.0000] <robpalme>
so... yes?

[14:29:01.0000] <brad4d>
I guess I'm kind of amazed that we ever manage to ship anything - not trying to be mean if that how it sounded

[14:29:44.0000] <akirose>
we take "don't break the web" very seriously

[14:29:47.0000] <rkirsling>
the sins of the past have certainly made adding methods to builtins difficult

[14:29:51.0000] <ljharb>
space jam website 4 eva

[14:29:59.0000] <michaelficarra>
someone needs a space jam link

[14:30:05.0000] <michaelficarra>
ljharb: lol beat me to it

[14:30:09.0000] <akirose>
lolol

[14:30:11.0000] <rkirsling>
https://spacejam.com

[14:31:18.0000] <brad4d>
in this case it's clearly a business that would be harmed - if it were, say, my personal website, that wouldn't have forced unshipping would it?

[14:31:48.0000] <ystartsev>
this is starting to sound all very familiar

[14:32:18.0000] <ljharb>
brad4d: there's no hard rule, but it tends to depend on popularity and cultural relevance a bit

[14:32:37.0000] <ljharb>
brad4d: iow, would web users switch browsers if that was what it took to make your website work?

[14:32:50.0000] <michaelficarra>
brad4d: I think it's much more about popularity than "does someone's livelihood depend on this?"

[14:32:52.0000] <ljharb>
if the answer is "my mom would" then i doubt it'd obstruct anything

[14:32:53.0000] <rkirsling>
data is collected by the browser vendors to see whether stuff seems to have broken

[14:33:01.0000] <ljharb>
but if the answer is "tens of thousands of people would" it might matter

[14:33:14.0000] <rkirsling>
that data is extremely important wrt stage 4 advancement

[14:34:34.0000] <ystartsev>
I feel like something like a framework would work reallywewll here

[14:34:39.0000] <ystartsev>
for designing studies

[14:35:33.0000] <rickbutton>
re: bricklink, imo it would be harmful to use any other metric than traffic/browser usage, tc39 shouldn't take an opinion on the usefulness of a website to the greater web

[14:35:50.0000] <rkirsling>
^

[14:35:53.0000] <Bakkot>
well, and how broken the page was

[14:36:01.0000] <ljharb>
agreed

[14:36:03.0000] <Bakkot>
"can't spin your 3d objects" is less serious than "can't log in", or whatever

[14:36:08.0000] <rickbutton>
sure

[14:36:18.0000] <rickbutton>
also depends on actual impact to said site

[14:36:21.0000] <ljharb>
rickbutton: well. i think it's reasonable when there's small usage, if the site is still particularly important for some other reason, that we protect it

[14:36:29.0000] <akirose>
historical significance ain't nuthin. (though the manner in which we introduce our own biases is a whole other conversation)

[14:36:52.0000] <rickbutton>
sure ljharb, would be real unfortunate if we shipped a proposal that broke tc39.es, even it if doesn't get much traffic :)

[14:37:00.0000] <ljharb>
ha, yes

[14:37:07.0000] <ljharb>
altho i'd hope evangelism would help us there

[14:37:15.0000] <rickbutton>
or maybe broke the website that hawaii used to send nuclear bomb alerts, for example

[14:37:41.0000] <rickbutton>
(wasn't a browser break that caused that, was a misclick)

[14:38:56.0000] <shu>
brad4d: to be clear, that was not a TC39 decision to unship

[14:39:05.0000] <shu>
brad4d: that is a product decision i made for v8 and chrome, and someone else made for safari

[14:39:08.0000] <rkirsling>
that too

[14:39:09.0000] <brad4d>
also related to .at(): even if unshipping hadn't occurred, wouldn't it have been too soon to ask for stage 4?

[14:39:25.0000] <rkirsling>
tc39's decision is really based on "are browser vendors willing to ship this"

[14:39:28.0000] <shu>
brad4d: it would've had 3 shipping implementations, so no, seems fine?

[14:39:29.0000] <rickbutton>
it would have landed in chrome and safari if not for the unship

[14:39:41.0000] <brad4d>
https://github.com/tc39/how-we-work/blob/master/champion.md

[14:39:44.0000] <rkirsling>
no it would have been the perfect time to ask for Stage 4

[14:39:50.0000] <brad4d>
"significant in-the-field experience"

[14:39:52.0000] <rkirsling>
the problem was detected in the nick of time

[14:40:09.0000] <brad4d>
doesn't that mean it has to have been out there and being used by developers for some reasonable period of time?

[14:40:11.0000] <ystartsev>
shu: sorry i think i came across as overly negative there

[14:40:15.0000] <shu>
brad4d: canary was shipping for whole release cycle, almost

[14:40:26.0000] <shu>
brad4d: we don't have a quantified "reasonable period of time"

[14:40:34.0000] <shu>
ystartsev: oh i didn't take that tone at all

[14:40:35.0000] <ystartsev>
i actually agree with what you were saying, i mostly wanted to add that -- hopefully there are tools and we are sort of trying to do that

[14:40:48.0000] <ystartsev>
with limited success so far, but hey

[14:41:14.0000] <shu>
ystartsev: i think it's really great you're doing the research group and it is a strict improvement where applicable

[14:41:30.0000] <ljharb>
brad4d: anyone using it would have to still work when it's absent

[14:41:39.0000] <shu>
ystartsev: in a way i was calling for more staffing investment in standards work

[14:41:41.0000] <ljharb>
brad4d: we don't worry about websites that are already broken on multiple browsers

[14:41:55.0000] <ystartsev>
shu: i totally support that

[14:42:56.0000] <brad4d>
shu: I thought you'd need your monitoring data to show a signifcant usage existed of `.at()` in real websites before you could move to stage 4

[14:43:09.0000] <shu>
brad4d: oh, certainly not

[14:43:19.0000] <shu>
brad4d: popularity is not a requirement

[14:44:18.0000] <brad4d>
hmmm, I thought lack of sufficient usage was one reason why the various "field" proposals haven't moved to stage 4

[14:44:27.0000] <shu>
ystartsev: cf how product features are aggressively (overly so!) a/b tested with data that may get abused etc

[14:44:48.0000] <shu>
ystartsev: we operate almost on the other end of the spectrum, and as such much of our debate is about how we feel, and how we think others would feel, about these proposals

[14:44:59.0000] <ystartsev>
yes, thats something that we need to be careful about -- that is where qualitative or mixed methods can help

[14:45:11.0000] <shu>
we of course _cannot_ a/b test feature proposals, because the output is interoperability

[14:45:19.0000] <shu>
yes, agree

[14:45:29.0000] <ljharb>
brad4d: not usage, just shipping

[14:45:38.0000] <ystartsev>
It also depends on the kind of question we want to answer (or if we know what the question really is)

[14:45:50.0000] <ystartsev>
This is something I've been thinking about in terms of our problem statements

[14:46:50.0000] <ljharb>
brad4d: afaik the combined class fields proposal was waiting on editor reviews of the updated PR, as well as more unflagged browser implementations

[14:47:29.0000] <rkirsling>
yeah JSC has been very behind on shipping those

[14:47:50.0000] <shu>
i thought igalia was helping out with implementation

[14:49:22.0000] <ystartsev>
Bakkot: halp

[14:49:32.0000] <Bakkot>
w?

[14:49:38.0000] <ystartsev>
i think the bot can be stopped?

[14:49:48.0000] <Bakkot>
ah, was gonna capture this bit too

[14:49:52.0000] <ystartsev>
never mind

[14:49:52.0000] <Bakkot>
will do the notes msyelf

[14:49:55.0000] <ystartsev>
spoke too soon

[14:51:47.0000] <rickbutton>
cant imagine a situation where we want to ship a proposal that has -no- support

[14:53:49.0000] <ystartsev>
ü§î

[14:54:43.0000] <littledan>
I don't really see why we'd need a process change to note committee members' comments in the conclusion section of the notes for Stage 3 advancement, since the notes format is not described in the process document

[14:55:17.0000] <ljharb>
agreed

[14:58:45.0000] <Bakkot>
btw a feature of the notes bot is that it fixes some of the common substitutions the speech-to-text API makes: https://github.com/bakkot/transcribe-to-gdocs/blob/master/replacements.js#L5-L56

[14:58:53.0000] <Bakkot>
which grows as I notice more

[14:59:15.0000] <Bakkot>
and when other people volunteer to take notes I can add them more readily and improve the experience for all future note takers

[14:59:21.0000] <Bakkot>
(hint hint)

[14:59:46.0000] <michaelficarra>
hahaha I didn't notice tempura

[14:59:47.0000] <shu>
copying over from my clarifications in tdz to here for more visibility

[14:59:53.0000] <shu>
what i'm asking is, concretely:

[15:00:03.0000] <shu>
so nothing formal, but that if you have direct anecdotal evidence of developer sentiment

[15:00:03.0000] <shu>
14:55:52 it would be good to either relay that in committee discussion for it to be recorded in the notes, or,

[15:00:03.0000] <shu>
14:56:14 if you are yourself a non-browser developer, put that hat on and speak to your own sentiment for whether you would use that or not

[15:00:03.0000] <shu>
14:56:20 we already do this, but it's often implicit

[15:00:03.0000] <shu>
14:56:36 some of us are very explicit, like yehuda

[15:00:04.0000] <shu>
14:56:42 who often says "i would use this in ember today"

[15:00:04.0000] <shu>
14:56:53 but if it were reflected in the notes that makes my life a lot easier

[15:01:47.0000] <ystartsev>
ok, thats clear, thanks

[15:04:53.0000] <shu>
ystartsev: from chrome's pov there's no work from other browser vendors

[15:04:59.0000] <shu>
"developer" here means non-web browser developer

[15:06:32.0000] <littledan>
I think we can simply call for folks to make statements about how they feel about this as a web developer, and write these in the minutes in the conclusion

[15:07:34.0000] <littledan>
(or, as JS developers in general)

[15:07:42.0000] <littledan>
we also have the frameworks and tools calls as a data source (though recent attendance of framework calls has been poor). The notes are public.

[15:16:53.0000] <shu>
littledan: +1 sgtm

[15:17:11.0000] <shu>
littledan: yes, i was already planning to use the minutes of the frameworks calls, thanks for calling that out

[15:19:52.0000] <jridgewell>
I see that _30m Revisiting RegExp.escape, Jordan Harband_ got moved to the end of the third day, which is now done?

[15:19:58.0000] <jridgewell>
But I don‚Äôt see it discussed in the notes

[15:20:10.0000] <jridgewell>
Should this on the agenda for day 4?

[15:20:10.0000] <ljharb>
jridgewell: we didn't have time

[15:20:21.0000] <ljharb>
the draft schedule will surely be updated for day 4, not sure when it'll be

[15:24:18.0000] <Bakkot>
can I get an admin of the tc39 org to make me an admin of the do-expressions repo? https://github.com/tc39/proposal-do-expressions/

[15:24:27.0000] <Bakkot>
dave is fine with this but he's not an admin and so can't do it himself

[15:24:38.0000] <Bakkot>
(not sure who admins are, so not sure who to ping)

[15:25:08.0000] <ljharb>
Bakkot: chairs

[15:30:22.0000] <ljharb>
haxjs: don't forget to transfer your class brand checks repo into tc39-transfer


2021-01-28
[16:03:39.0000] <robpalme>
bakkot: access granted

[16:13:12.0000] <Bakkot>
robpalme thanks!

[16:30:46.0000] <Bakkot>
> do do 42; while (false) while (false)

[16:30:49.0000] <Bakkot>
this is legal

[16:30:54.0000] <Bakkot>
good times

[16:31:00.0000] <Bakkot>
(as in, already legal)

[16:36:57.0000] <ljharb>
Bakkot: with your proposal tho, if you added curly braces it wouldn't be suddenly legal tho, right?

[16:37:10.0000] <ljharb>
like, it's legal right now as a statement, but it'd be a syntax error as a do expression

[16:38:42.0000] <Bakkot>
ljharb uuhhhh can you be more concrete?

[16:38:48.0000] <Bakkot>
i.e. write out what you're asking about

[16:39:46.0000] <ljharb>
`do { do { 42 } while (false) } while (false)` wouldn't be legal

[16:40:05.0000] <Bakkot>
that is currently legal

[16:40:08.0000] <Bakkot>
and would remain so

[16:41:19.0000] <ljharb>
sorry, i mean, in expression position

[16:41:37.0000] <ljharb>
`(do { do { 42 } while (false) } while (false))` or `(do do 42; while (false) while (false))`

[16:41:57.0000] <Bakkot>
ah: yeah, those are both illegal

[16:42:13.0000] <ljharb>
so there's not a refactoring hazard

[16:42:28.0000] <Bakkot>
first is illegal twice: it has a do-expr ending in a loop, and also it has `while` in a context it can't appear

[16:42:36.0000] <Bakkot>
second is illegal because `do`-exprs need braces

[16:43:08.0000] <Bakkot>
(though... I guess we could revisit that...)

[16:43:14.0000] <Bakkot>
(but maybe at a later point.)

[16:46:28.0000] <rkirsling>
needing braces feels weird if you're thinking of `do` as a control flow keyword but it doesn't feel weird if it's effectively a sigil on the braces

[16:46:46.0000] <rkirsling>
more and more I feel like `class {}` is a helpful comparison

[16:48:54.0000] <rkirsling>
(because I think braces should be required but that requires a conception that it's a "block marked by `do`" and not "`do` taking a block as an argument")

[16:49:40.0000] <Bakkot>
fwiw a `catch` block requires braces and there's no obvious "it's a block marked by `catch`" analogy there

[16:50:15.0000] <rkirsling>
hrmmmm

[16:50:18.0000] <Bakkot>
(I don't actually have any idea why we allow `if`/`else` without braces but not `try`/`catch`.)

[16:50:37.0000] <rkirsling>
tbh try/catch could easily drop the braces requirement

[16:50:48.0000] <rkirsling>
I just expect somebody to object

[16:51:16.0000] <rkirsling>
on a "you get a new footgun but you're not really solving a problem" basis

[16:51:18.0000] <Bakkot>
I guess maybe you end up with the dangling-else problem?

[16:51:29.0000] <rkirsling>
hmm, I haven't thought that through

[16:52:07.0000] <Bakkot>
`try try foo(); catch bar(); finally baz();` -> with which `try` do associate the `finally`?

[16:52:13.0000] <Bakkot>
*do you associate

[16:54:18.0000] <Bakkot>
aaaaaanyway I don't really want to do it for `catch` but it's marginally more appealing for `do`

[16:54:25.0000] <rkirsling>
surely the second but yeah, I'd expect that to raise an objection from somebody

[16:54:42.0000] <Bakkot>
surely the second? I'd say surely the first

[16:54:54.0000] <rkirsling>
wait really

[16:54:57.0000] <rkirsling>
how come

[16:54:57.0000] <Bakkot>
`else` binds to the closest `if`; why wouldn't `finally`?

[16:55:44.0000] <rkirsling>
that was my rationale for saying the second but I might have confused myself

[16:56:35.0000] <Bakkot>
if you put it on the second you end up (in that particular example) with something which would be legal, whereas you do not if you put it on the frst

[16:56:48.0000] <Bakkot>
but, you don't know if there's another `finally` coming

[16:57:17.0000] <Bakkot>
and it would be odd to say you have to wait until you parse the next thing to decide which `try` to associate the `finally` with

[17:01:23.0000] <rkirsling>
I'm actually not sure how you'd describe the logic to have it interpreted as `try { try foo(); } catch bar(); finally baz();` though, if that's what you mean

[17:03:50.0000] <Bakkot>
no

[17:04:16.0000] <Bakkot>
the natural interpretation is `try { try foo(); catch { bar(); } finally { baz(); }`

[17:04:30.0000] <Bakkot>
which would be as syntax error because the other `try` has neither `catch` nor `finally`

[17:04:44.0000] <Bakkot>
er, sorry, that should be `try { try { foo(); } catch { bar(); } finally { baz(); }`

[17:04:55.0000] <rkirsling>
yeah that was what I meant by "second"

[17:05:05.0000] <rkirsling>
second lexically

[17:05:11.0000] <Bakkot>
ahh

[17:05:29.0000] <Bakkot>
ok yes that was the confusion

[17:05:36.0000] <rkirsling>
whoops :)

[17:06:00.0000] <Bakkot>
that's on me probably; you're right that the token that comes first is "first"

[17:07:02.0000] <Bakkot>
ljharb I found this comment from 2018: https://github.com/tc39/proposal-do-expressions/issues/30#issuecomment-417389134

[17:07:56.0000] <Bakkot>
(not holding you to that opinion, obviously, just was amused)

[17:28:27.0000] <devsnek>
did relative indexing make stage 4

[17:29:15.0000] <Bakkot>
no, wasn't going for it because of the web compat issue

[17:29:27.0000] <Bakkot>
but they're gonna try outreach and re-shipping

[17:29:36.0000] <devsnek>
compat with "item" or "at"?

[17:33:25.0000] <Bakkot>
`at`

[17:33:37.0000] <Bakkot>
https://github.com/tc39/proposal-relative-indexing-method/issues/41

[17:33:58.0000] <devsnek>
ah, unfortunate

[19:17:23.0000] <ljharb>
Bakkot: lol yeah, altho essentially i've been convinced that 2 is confusing, leaving 3

[01:26:29.0000] <ystartsev>
shu: right, no problem. I was wondering if you wanted to order how we did the "intent to prototype" emails because that might give you something to point at, where developers from different communities might comment. We have the same situation with mozilla standards positions, where we sometimes have developers commenting on specific features.

[01:26:52.0000] <ystartsev>
But i think what you came up with will be closer to your goal so, we don't have to discuss it further

[09:58:37.0000] <ystartsev>
are we really only 10 people?

[09:59:15.0000] <michaelficarra>
4 days is rough

[10:00:18.0000] <Bakkot>
up to 18 now

[10:00:26.0000] <Bakkot>
people were just waiting for 10am

[10:01:14.0000] <michaelficarra>
everybody out chatting in the hallway over breakfast?

[10:06:21.0000] <michaelficarra>
remember that this is for stage 1, so this example syntax is not set in stone

[10:06:38.0000] <michaelficarra>
the syntax shown on the previous slide would not have been backwards compatible, for example

[10:07:30.0000] <TabAtkins>
Does this proposal end up meaning that infinite numbers of nested square brackets are valid? like `[0-9]` and `[[[[[0-9]]]]]` are the same thing

[10:08:30.0000] <devsnek>
pretty soon we're gonna need multiline regex

[10:08:43.0000] <michaelficarra>
it appears that way TabAtkins

[10:09:01.0000] <TabAtkins>
not a problem, was just wondering. ^_^

[10:09:12.0000] <ljharb>
enter, comments via "number of square brackets"

[10:09:27.0000] <TabAtkins>
devsnek: already got them via RegExp() with backtick strings

[10:09:36.0000] <devsnek>
awkward escaping though

[10:10:06.0000] <devsnek>
i guess new RegExp(String.raw``) would work?

[10:12:05.0000] <Bakkot>
bot seems to be working better today

[10:12:08.0000] <michaelficarra>
I don't think we should adopt that character class operand restriction

[10:12:09.0000] <rkirsling>
I know it's not either-or but actual Set operations seem much higher priority than this, hmm

[10:12:29.0000] <Bakkot>
I tweaked it a bit to maybe have fewer doubled words, which seems to have woorked, or else the speakers are just speaking more clearly

[10:12:36.0000] <rbuckton>
devsnek: I'm working up multiple RegExp proposals at https://gist.github.com/rbuckton/2f262b5298d4b2031cb7e0d5a1a62e19. One feature would allow for multi-line regexp. I'm also putting together a broad comparison of regexp engines (I showed some of that on day one with the flag comparisons at https://gist.github.com/rbuckton/cb0ea57949a8dfe0b4998301b6f46552).

[10:18:36.0000] <jridgewell>
mathiasbynens: Does regexpu already support set notation?

[10:18:47.0000] <jridgewell>
Or will Babel need to parse syntax to do it?

[10:18:56.0000] <mathiasbynens>
jridgewell: it does not. I've been using `regenerate` to do this kind of stuff by hand

[10:19:18.0000] <haxjs>
it seems the schedule changed?

[10:20:03.0000] <littledan>
haxjs: Is there a change you're concerned about?

[10:20:21.0000] <haxjs>
Isn't that my turn to present?

[10:20:23.0000] <jridgewell>
I think he was expecting to present now?

[10:20:34.0000] <littledan>
oh, I see

[10:20:44.0000] <haxjs>
what's the latest schedule?

[10:21:03.0000] <jridgewell>
Don't link it here

[10:21:18.0000] <jridgewell>
It's the hack.md link in the Reflector issue

[10:21:23.0000] <jridgewell>
https://github.com/tc39/Reflector/issues/340

[10:21:55.0000] <jridgewell>
Sorry, the "Draft Schedule" link

[10:22:09.0000] <littledan>
well, that doc has haxjs going now

[10:22:13.0000] <littledan>
bterlson: akirose ^

[10:22:47.0000] <devsnek>
haxjs: tcq says you're next

[10:23:01.0000] <rbuckton>
There was discussion about the schedule at the beginning of the day, based on what's in TCQ.

[10:23:21.0000] <haxjs>
ok, so i will be next?

[10:23:24.0000] <haxjs>
thank u

[10:23:50.0000] <ljharb>
https://github.com/benjamingr/RegExp.tag

[10:27:42.0000] <rbuckton>
A Regexp.escape that aggressively escapes (i.e., one that replaces characters or escapes with different meanings in and outside of character classes with `\u` sequences)? Or maybe a `u`-flag specific escape sequence like `/Escape{any content except unescaped curly brace }`.

[10:29:35.0000] <ljharb>
brad4d: such a repo already exists: https://github.com/benjamingr/RegExp.escape

[10:31:16.0000] <jorendorff>
``RegExp.build`${thing}?` `` will mean something different from ``new RegExp(`${RegExp.escape(thing)}?`)``

[10:31:19.0000] <jorendorff>
wow

[10:31:45.0000] <jorendorff>
RegExp.build`${thing}?`    would mean something different from    new RegExp(`${RegExp.escape(thing)}?`)

[10:31:51.0000] <gibson042>
background: the "even-odd problem" https://github.com/benjamingr/RegExp.escape/issues/37

[10:33:04.0000] <jorendorff>
if we're going to be motivated by fear of what vendors might do, I'd like to know which vendors

[10:33:50.0000] <ljharb>
jorendorff: https://github.com/benjamingr/RegExp.escape/issues/43#issuecomment-738950494 implies that HTML monkeypatching it onto RegExp is a viable path

[10:34:17.0000] <ljharb>
jorendorff: and similar comments in that thread are about node's willingness to ship it as a utility module.

[10:36:22.0000] <wsdferdksl>
Is there a way to turn off the embedly previews?

[10:36:41.0000] <michaelficarra>
wsdferdksl: what is embedly and where are you seeing this?

[10:36:56.0000] <wsdferdksl>
webchat.freenode.net

[10:37:06.0000] <ljharb>
irccloud has no previews of github links for me. it seems client-specific

[10:38:27.0000] <ljharb>
wsdferdksl: it doesn't appear that kiwiirc (the webchat client) allows disabling of that feature

[10:38:40.0000] <rbuckton>
I wrote a tag-based solution as an npm package, but in user-land it suffers from the same requirements as `RegExp.escape` would.

[10:39:30.0000] <rbuckton>
I just aggressively escape any character that could have a meaning either in or out of a character class.

[10:39:32.0000] <wsdferdksl>
I get huge images of ljharb together with a snippet of the title and "Read the article on github.com"

[10:40:12.0000] <wsdferdksl>
This thing tries really hard to turn github pages into facebook profiles

[10:40:37.0000] <wsdferdksl>
Which is just silly for github issues

[10:40:41.0000] <ljharb>
agreed

[10:40:43.0000] <michaelficarra>
I am using a desktop IRC client and I do not get these things

[10:42:21.0000] <rbuckton>
The funny part is that a tag-template approach needs to be able to differentiate between safe an unsafe values, so you can do

[10:42:21.0000] <rbuckton>
```

[10:42:21.0000] <rbuckton>
R`unescaped${escaped}${R`unescaped`}`

[10:42:21.0000] <rbuckton>
```

[10:42:49.0000] <jorendorff>
ljharb: this is in the context of a node developer explicitly asking what would be appropriate and constructive to the standards process

[10:43:14.0000] <msaboff>
Why can't RegExp.escape() return a string wrapped with '(?:' ... ')'

[10:43:16.0000] <jorendorff>
is that right?

[10:44:22.0000] <msaboff>
RegExp.escape("foo [123]!") => "(?:foo \[123\]\!)"

[10:44:56.0000] <msaboff>
Seems like that should reduce / eliminate injection concerns.

[10:45:29.0000] <gibson042>
it reduces them, but does not eliminate them

[10:46:02.0000] <rbuckton>
Aggresively escape `RegExp.escape = (value) => value.replace(/./, _ => convertToUnicodeEscape(_))` where convertToUnicodeEscape just makes everything into its `\u{...}` form. No code injection, though slight differences with surrogate pairs in character classes...

[10:46:18.0000] <rbuckton>
msaboff: then it can't be used in a character class

[10:46:34.0000] <msaboff>
rbuckton Precisely!

[10:46:55.0000] <rbuckton>
well, it can be, but your character class would include `(:)` as characters

[10:47:06.0000] <rbuckton>
`(?:)` rather

[10:48:22.0000] <msaboff>
Do you think it is a common use case to escape a string and then put that in a character class?

[10:48:54.0000] <rbuckton>
msaboff no, but its not outside the realm of possibility.

[10:49:07.0000] <msaboff>
If not, let's come up with wrapping that would cause a syntax error if the returned string is put directly in a character class.

[10:49:18.0000] <ljharb>
msaboff: ooh, i like that

[10:49:30.0000] <devsnek>
i'd rather try to allow returning references from functions than have the ^ syntax

[10:50:03.0000] <littledan>
(or, have a setAt method...)

[10:50:04.0000] <rbuckton>
msaboff: possible for `u`-flag, may be impossible without

[10:50:50.0000] <rbuckton>
I actually brought up `^` in the slice notation syntax repo.

[10:50:53.0000] <msaboff>
It would also make sense to add {1} at the end of the returned string so that other immediately trailing quantifiers cause a syntax error.

[10:50:56.0000] <gibson042>
https://esdiscuss.org/topic/regexp-escape#content-55

[10:51:44.0000] <rbuckton>
msaboff: Not sure about that. I might want to have a quantifier, in fact many of my use cases *do* use a quantifier.

[10:52:18.0000] <msaboff>
rbuckton So then you'd want the result as a non-captured group.

[10:52:38.0000] <rbuckton>
Though I suppose the workaround is `` new RegExp(`(?:${Regexp.escape(input)})?`) ``

[10:53:01.0000] <rbuckton>
well, irclcoud doesn't really understand markdown code sample syntax.

[10:53:18.0000] <devsnek>
ljharb: its solving setting

[10:53:22.0000] <devsnek>
you can't do `a.at(-1) = 5`

[10:53:23.0000] <ljharb>
rbuckton: surround it in ```

[10:53:33.0000] <rbuckton>
ljharb: yeah

[10:53:39.0000] <ljharb>
that's normal markdown syntax for that

[10:54:02.0000] <ljharb>
``` new RegExp(`(?:${Regexp.escape(input)})?`) ```

[10:54:10.0000] <rbuckton>
ljharb: commonmark specifies you can use a balanced set of n-backticks for a code sample

[10:54:21.0000] <ljharb>
at this point GFM is "normal markdown" :-)

[10:54:24.0000] <rbuckton>
```

[10:54:25.0000] <rbuckton>
`` ` ``

[10:54:25.0000] <rbuckton>
```

[10:54:27.0000] <leobalter_>
ljharb: setting elements

[10:54:33.0000] <leobalter_>
wrt your queue item

[10:54:34.0000] <rbuckton>
That's GFM too (GFM is commonmark++)

[10:54:39.0000] <leobalter_>
arr[ÀÜ1] = x

[10:54:42.0000] <ljharb>
leobalter_: ah, thanks. i'll see if that's what's claimed

[10:55:10.0000] <ljharb>
rbuckton: ah ok, i've never found that to work reliably - slack, at least, works just like irccloud here, so maybe i've just assumed npm/github works the same

[10:55:55.0000] <ljharb>
jridgewell: can you mute

[10:56:06.0000] <ljharb>
ty

[10:56:53.0000] <shu>
wait, how does s[^n] for a string have any different behavior than code units?

[10:56:58.0000] <rbuckton>
The important bit is you have to have a space between the leading backticks/trailing backticks and if the sample starts or ends with a backtick. Leading/trailing spaces are removed (source: wrote a 100% compliant commonmark/gfm parser)

[10:57:49.0000] <devsnek>
i would not intuit that `x[^a]` is relative to x's length

[10:57:51.0000] <leobalter_>
I have a very positive support for this proposal but I don't like this take of discussing it in some exclusive way for this proposal vs .at

[10:58:29.0000] <rbuckton>
devsnek: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/ranges

[10:59:01.0000] <devsnek>
rbuckton: i don't consider c# to be the best language either :P

[10:59:20.0000] <shu>
GME level volume on the queue

[10:59:35.0000] <jridgewell>
WHY DOES TEAMS ALLOW ME TO JOIN WITH AN UNMUTED MIC?!

[10:59:47.0000] <devsnek>
keeps you on your toes

[11:00:07.0000] <wsdferdksl>
This is the longest queue I've seen in a long time

[11:00:35.0000] <rbuckton>
jridgewell: didn't it ask you if you wanted your mic on or video broadcasting as part of the join process?

[11:00:41.0000] <devsnek>
i think a lot of it is not stage 1 concerns

[11:00:46.0000] <jridgewell>
I hit "rejoin" on my app

[11:00:49.0000] <devsnek>
due to how scoped this presentation is

[11:00:49.0000] <jridgewell>
Didn't change anything

[11:00:56.0000] <ljharb>
shu: +1 to your point

[11:00:58.0000] <jridgewell>
I was muted on the way out, I expect to be muted on the way in.

[11:01:09.0000] <rkirsling>
this feels wildly inappropriate, to suddenly propose a Stage 1 proposal that attacks what could have been a Stage 4 proposal in the same meeting

[11:01:22.0000] <rbuckton>
jridgewell: Odd. I'll take a note to send to the teams dev team

[11:02:15.0000] <jridgewell>
(This is the 2nd time it's happened, too. Yulia muted me yesterday after rejoining)

[11:02:43.0000] <rbuckton>
jridgewell: can you /msg me teams version/system specs in case its a version/os specific issue?

[11:07:50.0000] <devsnek>
i had a demo of some functionality a while back where you could do like `Array.prototype.at = function(n) { return &this[n < 0 ? this.length + n : n] }`

[11:07:57.0000] <devsnek>
and then `x.at(-1) = 5`

[11:08:21.0000] <shu>
we _could_ introduce pointers to JS

[11:08:31.0000] <devsnek>
well its narrowly scoped to return/functions

[11:08:44.0000] <shu>
but why? (:

[11:08:48.0000] <devsnek>
ü§∑üèª

[11:08:49.0000] <rbuckton>
shu: Pointers bad, memory-managed referenced maybe

[11:08:52.0000] <devsnek>
i'd be down to reify References

[11:08:55.0000] <devsnek>
as long as we use * and &

[11:09:00.0000] <devsnek>
:P

[11:09:07.0000] <shu>
and `->`?

[11:09:07.0000] <Bakkot>
wow what a strong oppose to this proposed negative 0 behavior

[11:09:10.0000] <Bakkot>
er

[11:09:15.0000] <Bakkot>
*I strongly oppose, that is

[11:09:16.0000] <rbuckton>
devsnek: https://github.com/rbuckton/proposal-refs

[11:09:26.0000] <shu>
i strongly oppose treating -0 differently

[11:09:29.0000] <shu>
that is quite out there

[11:09:58.0000] <devsnek>
does ^n have the same meaning as at(n)

[11:09:59.0000] <TabAtkins>
I've never once run into a -0 problem in Python, I dont' understand what th eissue is

[11:10:08.0000] <devsnek>
or is it a different thing

[11:10:19.0000] <shu>
devsnek: no, because ^0 means .length - 0

[11:10:20.0000] <TabAtkins>
devsnek: No, ^n is equal to at(-n-1), as proposed

[11:10:22.0000] <shu>
(i.e. one beyond the end)

[11:10:29.0000] <devsnek>
ah

[11:10:31.0000] <devsnek>
that seems worse

[11:10:33.0000] <TabAtkins>
oh shoot yeah, sorry, not the -1

[11:11:09.0000] <devsnek>
i think the at behavior is much more intuitive and composable

[11:11:32.0000] <shu>
i can see the scope of this proposal expanding to work with the slice proposal champions

[11:11:43.0000] <shu>
as it stands now it's kinda narrow

[11:11:55.0000] <shu>
for new syntax, that is

[11:12:03.0000] <TabAtkins>
Yeah def, if we're going to add syntax to indexing this should *absolutely* be done in concert with slices, that'd be great

[11:12:32.0000] <rickbutton>
if a[^1] works I would expect that a[(^1)] works

[11:12:58.0000] <devsnek>
i kind of want to do a poll on how people feel about refs

[11:12:58.0000] <TabAtkins>
I wouldn't necessarily - I'm reading the ^ as part of the [] syntax, so it's like the [^] operator

[11:13:04.0000] <ljharb>
^ same

[11:13:07.0000] <rbuckton>
C# uses `^` for negative index values, and `..` for ranges

[11:13:16.0000] <devsnek>
ljharb: same to me or rick?

[11:13:20.0000] <ljharb>
to tab

[11:13:21.0000] <ljharb>
if `a[(^1)]` works than `^1` has to be a first-class thing, which doesn't make sense

[11:13:22.0000] <rickbutton>
or tab :)

[11:13:37.0000] <ljharb>
because then you have a third kind of property key

[11:13:41.0000] <michaelficarra>
ljharb: how does¬†RegExp.escape¬†escape properly for capture group names?

[11:13:45.0000] <devsnek>
^ is never a valid unop, so we *could* make it valid

[11:14:05.0000] <ljharb>
michaelficarra: haven't tried it - it probably doesn't, since that's a newish feature

[11:14:18.0000] <ljharb>
devsnek: right but then what would it make

[11:14:22.0000] <rbuckton>
For now I'd be happy with

[11:14:22.0000] <rbuckton>
```

[11:14:22.0000] <rbuckton>
MemberExpression `[^` PrimaryExpression `]`

[11:14:22.0000] <rbuckton>
```

[11:14:49.0000] <devsnek>
rbuckton: `[^` or `[` `^`

[11:15:07.0000] <devsnek>
ljharb: only valid inside indexing, of course

[11:15:12.0000] <rbuckton>
devsnek: either.

[11:15:19.0000] <ljharb>
devsnek: right but then it's not a unary operator :-)

[11:15:32.0000] <rbuckton>
If we ever introduced `^` on its own, the above would give us room to expand

[11:15:37.0000] <michaelficarra>
ljharb: that context is particularly problematic, as supporting it would force us to \uXXXX escape everything non-identifiery

[11:16:08.0000] <devsnek>
ljharb: oh "it" is `a[(^x)]`, not making `^` a unary operator

[11:17:53.0000] <ljharb>
michaelficarra: can you file an issue? that seems like an important thing to look into

[11:18:01.0000] <ljharb>
devsnek: ah ok

[11:18:03.0000] <michaelficarra>
ljharb: already did

[11:18:10.0000] <ljharb>
ty

[11:18:21.0000] <rbuckton>
In the slice proposal, I mentioned a possible future of `@@seti`, `@@geti`, and reified `Index` and `Range` types so that `^x` and `x:y` could stand on their own.

[11:18:22.0000] <ljharb>
devsnek: but the parens working there suggest to me that it *is* a unary operator.

[11:18:33.0000] <devsnek>
ljharb: yeah i agree it would be confusing

[11:18:49.0000] <TabAtkins>
with slicing, I wouldn't think `a[(1:2)]` would work either, honestly

[11:19:17.0000] <rbuckton>
I brought up `^` in the slice proposal here: https://github.com/tc39/proposal-slice-notation/issues/30

[11:20:08.0000] <rbuckton>
I also brought up slice extensibility (including reified values for `^x` and `x:y`) here: https://github.com/tc39/proposal-slice-notation/issues/19

[11:20:36.0000] <TabAtkins>
I guess reifying them is useful; being able to store indexes somewhere else and later use them to lookup into an array is good, and being able to do that simply, rather than tracking the syntax out-of-band, would be good

[11:23:00.0000] <TabAtkins>
Tho reifying doesn't require the syntax to be invokable outside of the [] - it could just be a new object type for keys you can manually construct, but which is automatically done by the [] syntax

[11:23:01.0000] <Bakkot>
TabAtkins "lastIndexOf" is the most relevant precedent

[11:23:04.0000] <Bakkot>
not strings

[11:23:10.0000] <rbuckton>
The drawback to reification is that it could slow down implementations. Indexed access wouldn't just be coercion to string or symbol, instead it would have to check if the index expression is an object value with a `@@geti` (or `@@seti`) for indirection first

[11:23:19.0000] <rickbutton>
reified `x:y` would allow for `for (let x in 1:10) {}` which is fun

[11:23:27.0000] <TabAtkins>
Right, but that's talking about the last instance. The *direction* (in findFromX) is called "end"

[11:24:25.0000] <TabAtkins>
rickbutton: But we're already trying to handle that in the `range()` proposal too.

[11:25:09.0000] <rickbutton>
ah yeah forgot about the range proposal

[11:25:42.0000] <TabAtkins>
findLast() is fine. findFromLast() is not.

[11:25:43.0000] <rbuckton>
Strings don't have `find` or `findIndex` anyways

[11:25:51.0000] <devsnek>
*yet*

[11:26:00.0000] <jorendorff>
yay last

[11:26:38.0000] <rbuckton>
TabAtkins: no reason we couldn't have `range(x,y)` and `x:y`. We already have `Array(1, 2, 3)` and `[1, 2, 3]` :)

[11:27:29.0000] <TabAtkins>
Technically true, but I just wouldn't want to block `arr[1:2]` if a naked `1:2` is problematic. ^_^

[11:27:40.0000] <rickbutton>
^ agree

[11:27:47.0000] <rbuckton>
Plus `^x` and `x:y` would be unforgeable (at least, in the same way as `[]` and `{}` are)

[11:29:22.0000] <rbuckton>
TabAtkins: I think its a matter of framing the syntax for slice/negative index so that there's room to expand later (i.e., not `[^ Expression ]`, since changing `^` to infix later would break code)

[11:31:17.0000] <wsdferdksl>
rbuckton: What's "unforgeable"?

[11:32:01.0000] <rbuckton>
`Array` can be replaced globally, so `new Array()` could create something different than `[]`, which always creates an array per spec text.

[11:32:21.0000] <ljharb>
not that anyone should be using `new Array` in any code ever :-)

[11:32:31.0000] <wsdferdksl>
And what would ^x and x:y create?

[11:32:50.0000] <wsdferdksl>
New kinds of range objects?

[11:32:52.0000] <rbuckton>
Same for `new RegExp("foo")` vs `/foo/`.

[11:33:04.0000] <TabAtkins>
wsdferdksl: Yes, a reified Offset/Range object

[11:33:11.0000] <wsdferdksl>
OK

[11:33:14.0000] <rbuckton>
wsdferdksl: that's that I was just discussing, yes. Reified values for `^x` and `x:y`

[11:33:42.0000] <rbuckton>
that's not part of the proposal, but something I've discussed on the issue tracker for slice notation.

[11:34:24.0000] <wsdferdksl>
I can imagine lots of mistakes where folks wrote [a:b] when they meant (a:b), and it works but uses gobs of unnecessary memory.

[11:34:48.0000] <wsdferdksl>
Iterating over [a:b] instead of (a:b)

[11:36:07.0000] <haxjs>
I think the motivation of slice notation is ergonomics, so reification of `^i` and `a:b` should be a  separate proposal.

[11:36:07.0000] <michaelficarra>
other than WithStatements, is there ever a case where reading from an in-scope identifier could have effects?

[11:36:52.0000] <TabAtkins>
wsdferdksl: Can you elaborate? I'm not sure what sort of potential mistake you're referring to

[11:36:56.0000] <wsdferdksl>
Reification of ^i cannot be a separate proposal because a[^b] would preclude it.

[11:36:56.0000] <devsnek>
this proposal seems unworkable due to TLA

[11:37:02.0000] <ljharb>
michaelficarra: a global getter?

[11:37:16.0000] <ljharb>
michaelficarra: otherwise i don't think so

[11:37:29.0000] <michaelficarra>
yeah I don't consider a global getter as in-scope

[11:37:45.0000] <wsdferdksl>
If we're doing them at all, we need to do them together

[11:39:16.0000] <wsdferdksl>
devsnek: TLA = Three Letter Acronym?

[11:39:23.0000] <gibson042>
"top-level await"

[11:39:26.0000] <devsnek>
wsdferdksl: top level await üòÑ

[11:39:37.0000] <haxjs>
@TabAtkins the -0 problem in Python is like, you want  a[1:-n] express drop n elements in the end, but if `n` could be 0, u have to write code like n == 0 ? a[1:] : a[1:-n]

[11:40:23.0000] <TabAtkins>
hm, ok. I've never run into that situation, but i get it

[11:41:09.0000] <wsdferdksl>
haxjs: The same problem occurs with all of the array methods that take negative indexes. How do you plan on fixing all of those?

[11:41:25.0000] <haxjs>
only slice/splice use neg index.

[11:41:54.0000] <haxjs>
Are there any other?

[11:43:00.0000] <wsdferdksl>
haxjs: That's incorrect

[11:43:01.0000] <TabAtkins>
If we have ranges *and* you can compose : and ^, then the syntax would fix it - `arr[1:^n]`

[11:43:31.0000] <haxjs>
@TabAtkins Yes, that what I want :-)

[11:44:00.0000] <michaelficarra>
imported names are not globals...

[11:44:26.0000] <haxjs>
@wsdferdksl Is there any other methods use neg index?

[11:44:42.0000] <wsdferdksl>
Yes

[11:44:56.0000] <haxjs>
which one?

[11:45:57.0000] <michaelficarra>
haxjs: Array.prototype.splice

[11:46:06.0000] <michaelficarra>
oops you mentioned splice

[11:46:24.0000] <michaelficarra>
TypedArray copyWithin

[11:46:46.0000] <ljharb>
copyWithin is what i was going to mention yeah

[11:46:50.0000] <ljharb>
regular arrays have it too

[11:47:01.0000] <michaelficarra>
oh wow didn't notice

[11:47:13.0000] <ljharb>
it's a really annoying one to shim

[11:47:18.0000] <michaelficarra>
also fill on Arrays and TypedArray

[11:47:20.0000] <ljharb>
to implement, rather

[11:47:29.0000] <wsdferdksl>
haxjs: There are lots of them. I'm surprised that you're unfamiliar with them when promoting a proposal to replace negative indexes.

[11:47:32.0000] <haxjs>
oh thank u , so we have three methods: slice/splice/copyWithin

[11:47:38.0000] <ljharb>
ahh yes, fill's `start` and `end` arguments

[11:47:46.0000] <michaelficarra>
also subarray on TypedArray

[11:47:59.0000] <michaelficarra>
haxjs: at least 5

[11:48:25.0000] <ljharb>
also anything that takes fromIndex, like includes, indexOf, lastIndexOf, etc

[11:48:50.0000] <ljharb>
ok so i think that's it - 7 on array and 8 on typedarray

[11:48:54.0000] <michaelficarra>
tl;dr it's pretty common

[11:49:00.0000] <TabAtkins>
Anyway, a reified ^ could be passed to all of those, I suppose. ^_^

[11:49:09.0000] <michaelficarra>
ljharb: also arraybuffer and sharedarraybuffer

[11:49:12.0000] <devsnek>
this is some cursed code

[11:49:29.0000] <ljharb>
which only has slice, yeah

[11:49:37.0000] <shu>
no no no no no

[11:49:39.0000] <shu>
nooooooo

[11:49:42.0000] <rbuckton>
devsnek: throwing a promise isn't new. See: React

[11:49:45.0000] <haxjs>
Ok. so at least we can have a better slice :)

[11:49:49.0000] <robpalme>
this is beautiful

[11:49:58.0000] <ljharb>
rbuckton: and it's cursed that react does it too

[11:50:00.0000] <shu>
what have we wrought

[11:50:01.0000] <devsnek>
rbuckton: oh i know, it just makes me sad

[11:50:12.0000] <ljharb>
rbuckton: and react's Suspense/Lazy model is still not really "finished" or fully fleshed out.

[11:50:23.0000] <wsdferdksl>
devsnek: yup!

[11:50:26.0000] <ljharb>
the ability to reject with a promise is absurd and i continue to think it's a mistake

[11:50:44.0000] <ljharb>
(to have a promise rejected with a `reason` that is itself a Promise, i mean)

[11:51:38.0000] <rbuckton>
ljharb: having had to use `Suspense` I can't say I disagree, its highly confusing

[11:51:49.0000] <shu>
i think i missed the connection between React's cursed code and how lazyInit would replace that use case

[11:52:12.0000] <rbuckton>
shu: more discussing the code example that showed throwing a Promise

[11:52:34.0000] <shu>
rbuckton: right, it's doing an iloop to simulate blocking and using thrown promises for control flow, or am i missing something?

[11:52:37.0000] <ljharb>
shu: the way you "suspend" a component in react is by throwing a promise. i believe that's also possibly how some react hooks work

[11:52:55.0000] <shu>
and how would lazyInit help?

[11:54:05.0000] <shu>
i thought those things were a sub-ESM boundary

[11:54:25.0000] <rricard>
it covers the lazy-component loading use case from suspense

[11:54:29.0000] <rricard>
not the full thing

[11:54:37.0000] <rricard>
(as I understand it)

[11:54:44.0000] <leobalter_>
My brain is still on Test262: https://gist.github.com/leobalter/f9ba9cc3fde91567212150ad2883eb77

[11:58:04.0000] <littledan>
this is the Chrome investigation Shu is talking about https://docs.google.com/document/d/1o3qgHBx5_T0cV6kFU3HzSp8-bBOJFEtlRJKh59-ljgc/edit

[11:58:30.0000] <leobalter_>
seems like `a` is certain to end early on main.js, but it's a bit odd for "b"

[11:59:02.0000] <littledan>
here's my take on what we might do in HTML to make that reality https://github.com/whatwg/html/issues/4400#issuecomment-738737956

[11:59:46.0000] <littledan>
note that this laziness has been prototyped https://github.com/whatwg/html/issues/4400#issuecomment-739049763 and doesn't *yet* help, though maybe it could if other changes are made

[11:59:57.0000] <littledan>
(changes inside the browser, not spec changes)

[12:00:33.0000] <Bakkot>
purity annotations!!!!

[12:00:53.0000] <Bakkot>
I mean they're a bad idea but I am still excited they're being brought up, even as a bad idea

[12:00:55.0000] <shu>
i regret bringing it up

[12:01:04.0000] <Bakkot>
it's fine I think we all know they're bad

[12:01:09.0000] <Bakkot>
even if I want them in my soul

[12:01:11.0000] <shu>
ystartsev: i worked on PJS too!

[12:01:15.0000] <shu>
big failure

[12:02:40.0000] <devsnek>
ljharb: let me introduce you to getters on the global object üòÑ

[12:02:45.0000] <michaelficarra>
I second ljharb's horror

[12:02:47.0000] <shu>
yes, i mean we have getters

[12:02:49.0000] <shu>
we have that horror

[12:03:04.0000] <ljharb>
devsnek: i am aware of the existing horrors that i have no wish to repeat

[12:03:07.0000] <littledan>
JoelMarcey is trying to enroll as a delegate. Are there any Facebook colleagues who could help?

[12:03:10.0000] <devsnek>
i remember someone made a thing with exceptions and global getters to have `__LINE__` in js

[12:03:20.0000] <shu>
ljharb: i think the point is that there's nothing to repeat

[12:03:30.0000] <bradleymeck>
i keep touching something on my keyboard and it is unmuting me in teams

[12:03:32.0000] <shu>
ljharb: we're not adding a new thing that repeats the horror, but variable references now are already a horror

[12:03:40.0000] <ljharb>
shu: right, fair

[12:03:50.0000] <bradleymeck>
devsnek, I did __LINE

[12:03:52.0000] <ljharb>
shu: i don't want to expand the cases where the horror is reified

[12:03:57.0000] <bradleymeck>
/me :chef's kiss:

[12:04:06.0000] <bradleymeck>
oh god why did my client do that

[12:04:09.0000] <michaelficarra>
that reminds me, someone from Microsoft should help Wenlu Wang get added to delegates.txt

[12:04:09.0000] <jridgewell>
I love `__LINE__` actually

[12:04:26.0000] <shu>
ljharb: that may be contentious too, you can take the position that i think yulia is taking, which is that it _is_ a getter

[12:04:35.0000] <michaelficarra>
(rbuckton bterlson) see above

[12:04:39.0000] <ljharb>
shu: right but it's not a global one

[12:04:44.0000] <bradleymeck>
jridgewell: it gets really weird though once you start dealing with code wrappers

[12:04:49.0000] <ljharb>
shu: it's a module-level getter, which is not a thing that exists yet.

[12:04:51.0000] <shu>
ljharb: what's the global distinction?

[12:04:52.0000] <shu>
ah

[12:05:08.0000] <shu>
hmm, need to think on that

[12:05:19.0000] <ljharb>
shu: iow, either 100% or 0% of my code has this horror available. adding it at module level means i need to worry about it per-module instead of per-app

[12:05:31.0000] <ljharb>
so the cognitive load is much, much higher.

[12:05:59.0000] <shu>
ljharb: but module toplevels can reference things on the global scope, which may have getters

[12:06:00.0000] <ljharb>
also global getters are a bad thing and basically nobody does them; the point of this new feature is to encourage people to do it

[12:06:10.0000] <devsnek>
*technically* all imports are getters rn

[12:06:14.0000] <shu>
ljharb: and in general, when you look at an isolated variable use, you have no idea what it is

[12:06:21.0000] <ljharb>
shu: eval exists but we wouldn't want new features that encourage use of eval

[12:06:31.0000] <michaelficarra>
shu: you know when a variable is in scope or not

[12:06:43.0000] <devsnek>
do you?

[12:06:44.0000] <michaelficarra>
as in, would resolve before the global object

[12:06:44.0000] <ystartsev>
for what its worth, making the import binding a getter is basically how we do this in fx

[12:06:46.0000] <ljharb>
devsnek: sure but a guaranteed side-effect-free getter

[12:06:54.0000] <shu>
michaelficarra: that is ... mostly true

[12:07:04.0000] <shu>
michaelficarra: but only false for an arcane terrible reason

[12:07:14.0000] <shu>
which is that the global lexical scope is shared among script tags

[12:07:15.0000] <michaelficarra>
with statement?

[12:07:20.0000] <devsnek>
honestly i'd be more interested in a variant of dynamic import which has to take a string literal

[12:07:21.0000] <shu>
well, with too

[12:07:26.0000] <devsnek>
so the engine can eagerly load it

[12:07:29.0000] <ljharb>
devsnek: that would be great

[12:07:39.0000] <devsnek>
it still introduces async though

[12:07:44.0000] <shu>
michaelficarra: but yeah, good point

[12:07:44.0000] <devsnek>
which is blocking i think

[12:07:49.0000] <ljharb>
devsnek: altho that's an optimization they could already apply with a literal, right?

[12:08:08.0000] <shu>
michaelficarra: i can better relate to the qualitative difference of why this is added horror

[12:08:08.0000] <devsnek>
yes, but i think the point is that they don't want to refactor their code to have a dynamic import somewhere in it

[12:08:41.0000] <ystartsev>
not only that, but dynamic import has significant implications for a codebase

[12:08:46.0000] <ystartsev>
as shown by react's use case

[12:09:32.0000] <ystartsev>
because we have investigated just using a script to rewrite everything that use our lazy getter to use dynamic import

[12:09:33.0000] <shu>
ystartsev: to make sure i understand the async-should-be-eager point

[12:09:56.0000] <shu>
the problem is just that you can't kick off a sync fetch on variable access

[12:10:03.0000] <shu>
because... the programmer intention was async?

[12:10:20.0000] <ystartsev>
no because it would break run to completion

[12:10:35.0000] <shu>
oh right

[12:10:37.0000] <shu>
of course, thanks

[12:10:40.0000] <shu>
it changes the timing completely

[12:11:00.0000] <ystartsev>
so, one way to deal with side-effectful code, that i looked at, was the same approach as top level await

[12:11:12.0000] <ystartsev>
but it requires analysis and definition of what is side effectful

[12:11:32.0000] <ystartsev>
in practice, it might end up delazifying everything and only allows modules that are basically just lists of functions to be lazy

[12:11:50.0000] <ystartsev>
I didn't bring that up really clearly, but that was my worry there

[12:12:03.0000] <ystartsev>
if there is a way to do this, i would be interested because it would resolve this issue

[12:36:10.0000] <shu>
ystartsev: that's a good worry

[12:36:24.0000] <shu>
ystartsev: really looking forward to having an incubator call and bringing the chrome module streaming folks to the table

[12:36:40.0000] <ystartsev>
yeah, very excited to talk further about it

[12:56:59.0000] <robpalme>
we are restarting in 4 mins

[13:17:20.0000] <michaelficarra>
I appreciate the phrasing of "exploring the space of language negotiation" sffc

[13:19:27.0000] <shu>
+1

[13:28:48.0000] <michaelficarra>
we have logs now!

[13:29:07.0000] <rkirsling>
I still don't know what a bouncer is, concretely lol

[13:29:14.0000] <shu>
we COULD ask ecma to get an irccloud paid team account for delegates

[13:29:15.0000] <rkirsling>
not interested in figuring that out

[13:29:27.0000] <rkirsling>
shu: true

[13:29:33.0000] <ljharb>
i think we should

[13:29:37.0000] <michaelficarra>
shu: sounds like we could just go down the Slack route at that point

[13:29:46.0000] <devsnek>
anything but slack

[13:29:53.0000] <shu>
slack has additional complications, no?

[13:30:11.0000] <shu>
michaelficarra: it'll also be as-needed

[13:30:26.0000] <michaelficarra>
it has custom emojis, so‚Ä¶ trade-offs

[13:30:28.0000] <devsnek>
slack doesn't allow user to user moderation (like blocking, etc)

[13:30:30.0000] <rkirsling>
#webkit is dead so Sony doesn't actually have a reason to keep paying for my team's accounts (though I can still be an exception, I just have to go out of my way)

[13:36:19.0000] <rbuckton>
I'm unfamiliar with Matrix. While I'd been hoping for a response from Discord, the fact that I can't switch between personal and a "work" Discord account makes me interested in trying out Matrix.

[13:36:49.0000] <TabAtkins>
Anything but Slack, yes.

[13:38:07.0000] <ljharb>
slack's great but i'm in camp "anything but discord"

[13:38:44.0000] <rkirsling>
I will round out the group by saying that I like Slack and Discord and am sad to add yet another platform to the mix

[13:40:34.0000] <jridgewell>
Can I be in "anything but IRC" camp?

[13:41:01.0000] <ryzokuken>
ljharb: count me in that camp as well

[13:41:05.0000] <ljharb>
jridgewell: #tc39-inclusion tends to include those folks

[13:41:20.0000] <jridgewell>
Replacing IRCCloud with X is net negative for me, but I'll get to forget IRC exists which is net positive.

[13:41:21.0000] <ryzokuken>
not the former

[13:41:38.0000] <jridgewell>
net neutral**

[13:41:52.0000] <jridgewell>
Ugh, correction isn't clear.

[13:42:14.0000] <jridgewell>
Replacing IRCCloud with X is net neutral** for me, but I'll get to forget IRC exists which is net positive.

[13:43:34.0000] <rkirsling>
I like IRCCloud but I have no other reason to use it, so at least I'm not actually adding to the number of active chat apps on my computer

[13:43:45.0000] <rkirsling>
by swapping it out with something else

[13:44:08.0000] <akirose>
ljharb: pls repost question after i advance q

[13:44:17.0000] <ryzokuken>
jridgewell: do you wish you wrote this on a platform that allows editing? :D

[13:44:26.0000] <ljharb>
akirose: ahh not enough time to copy paste, will try to retype

[13:44:36.0000] <akirose>
i got u

[13:44:49.0000] <ljharb>
ooh ty

[13:45:11.0000] <rkirsling>
ryzokuken: that is another big point toward "anything but IRC", yeah

[13:45:29.0000] <rkirsling>
I edit _constantly_ when that feature exists

[13:45:54.0000] <ryzokuken>
I think editing is awesome

[13:45:56.0000] <devsnek>
ljharb: you think multi-method protocols are inherently bad?

[13:46:13.0000] <ljharb>
devsnek: besides RegExp, do you have an example of one you think isn't bad?

[13:46:46.0000] <rickbutton>
Set?

[13:47:05.0000] <rickbutton>
add/delete

[13:47:05.0000] <devsnek>
the collection types more or less

[13:47:06.0000] <ljharb>
indeed, and we've already as a committee ran into that as a problem

[13:47:08.0000] <rkirsling>
if we ever do reify protocols, I sincerely hope that we stop calling them protocols

[13:47:13.0000] <devsnek>
rkirsling: traits

[13:47:17.0000] <rkirsling>
because no one has any idea what that word means

[13:47:19.0000] <ljharb>
that the Set constructor observably calls "add" is why Set methods haven't advanced.

[13:47:25.0000] <rkirsling>
yeah that'd be fine

[13:47:51.0000] <bradleymeck>
i had happily forgot the pain caused by Set and add()

[13:48:07.0000] <rkirsling>
I couldn't remember what Set methods were blocked by yeah

[13:51:26.0000] <ljharb>
akirose: my clarifying question isn't a question so i could just say it as part of my topic

[13:51:28.0000] <bradleymeck>
base class calling subclass is just a rats nest

[13:51:44.0000] <ljharb>
akirose: arguably i should have edited my topic to add that, but i can't edit :-)

[13:51:52.0000] <ljharb>
bradleymeck: yes

[13:56:06.0000] <Bakkot>
ljharb that is not why

[13:56:34.0000] <ljharb>
k, please correct me :-)

[13:58:13.0000] <jorendorff>
dictionaries are recognized as a special thing in webidl

[13:58:18.0000] <jorendorff>
aren't they?

[14:00:14.0000] <bradleymeck>
jorendorff: https://heycam.github.io/webidl/#idl-dictionaries

[14:00:41.0000] <Bakkot>
ljharb the main question was about reading internal slots when querying and how that would interact with subclassing

[14:00:50.0000] <Bakkot>
the fact that the set ctor calls "add" wasn't super relevant

[14:00:56.0000] <ljharb>
k

[14:01:34.0000] <Bakkot>
ljharb you don't validate "is this a calendar"

[14:01:46.0000] <ljharb>
i do if i want my API to give useful error messages when my users give me the wrong thing

[14:01:57.0000] <Bakkot>
how do you validate "is this a valid set of options to pass to babel"

[14:01:58.0000] <Bakkot>
you don't

[14:02:03.0000] <Bakkot>
it's just a grab bag of options

[14:02:09.0000] <Bakkot>
that's how JS works

[14:02:12.0000] <ljharb>
there's no class for "BabelOptions"

[14:02:16.0000] <Bakkot>
yup

[14:02:17.0000] <Bakkot>
that's good

[14:02:17.0000] <ljharb>
thus yes, it's just a grab bag

[14:02:26.0000] <ljharb>
the existence of a Calendar and TimeZone class mean it's not that.

[14:02:35.0000] <devsnek>
its different

[14:02:45.0000] <ljharb>
than a typical grab bag of options? yes, i think it is different.

[14:02:46.0000] <Bakkot>
if someone made such a class to let people more conveniently set them up, that would change the situation

[14:02:53.0000] <Bakkot>
*that would _not_ change the situation

[14:02:54.0000] <devsnek>
there is both a nominal and a structural definition

[14:02:58.0000] <devsnek>
that's the point of the protocol

[14:03:17.0000] <devsnek>
the nominal one is like the default impl in stdlib

[14:03:26.0000] <ljharb>
a calendar is not just a set of options tho

[14:03:33.0000] <Bakkot>
is too

[14:03:34.0000] <ljharb>
options are often separable.

[14:03:49.0000] <ljharb>
no part of the calendar is conceptually separable, all of the methods have to work in concert

[14:03:58.0000] <devsnek>
you could say "a calendar is an object with these methods and these properties"

[14:04:01.0000] <Bakkot>
options are not necessarily separable, that's just a thing which sometimes happens to be true

[14:04:11.0000] <ljharb>
true

[14:04:23.0000] <ljharb>
devsnek: right, so, how do i validate that an object someone gave me has the right methods and properties

[14:04:51.0000] <devsnek>
you could do it manually

[14:04:59.0000] <devsnek>
there's a proposal somewhere for `x implements Y`

[14:05:06.0000] <Bakkot>
could and should, since being an instance of the class does not imply it has those methods

[14:05:46.0000] <ljharb>
Bakkot: i'm fine assuming that a subclass is well-formed, that's not the same as assuming that any random object is.

[14:05:59.0000] <ljharb>
for a thenable i can `typeof x.then === 'function'` and assume the rest

[14:06:08.0000] <devsnek>
that's a manual check

[14:06:10.0000] <ljharb>
sure

[14:06:12.0000] <ljharb>
of a single method.

[14:06:24.0000] <devsnek>
because that's what a thenable is

[14:06:45.0000] <Bakkot>
iterator results objects have both a `value` and a `done`

[14:06:50.0000] <ljharb>
it's not difficult to distinguish objects conforming to a single-method protocol.

[14:06:58.0000] <ljharb>
Bakkot: those aren't methods. iterator results objects are just data.

[14:07:08.0000] <ljharb>
i'm not pretending there's a short list of simple rules here.

[14:07:13.0000] <ljharb>
but these things are not all the same.

[14:07:18.0000] <Bakkot>
timezone objects are also just data, they're just implemented as code

[14:07:37.0000] <jorendorff>
self-sends

[14:08:01.0000] <shu>
okay thanks

[14:08:03.0000] <Bakkot>
ljharb the reason to provide a class is to provide a convenient way to get a set of default behavior, if you want that

[14:08:04.0000] <shu>
sends as in sending messages

[14:08:33.0000] <ljharb>
Bakkot: a function serves that purpose

[14:08:41.0000] <Bakkot>
so does a class

[14:08:47.0000] <ljharb>
sure. but a function doesn't encourage subclassing.

[14:08:57.0000] <jorendorff>
the Set constructor does self-sends: https://tc39.es/ecma262/#sec-set-iterable

[14:09:01.0000] <jorendorff>
it's not required

[14:09:12.0000] <Bakkot>
it allows subclassing

[14:09:44.0000] <gibson042>
the proposal is that a time zone is an object with methods such as "getNextTransition"

[14:11:39.0000] <shu>
jorendorff: so self-sends means where the default implementation of a method calls out to another virtual method that also has a default implementation

[14:11:45.0000] <shu>
on the same receiver

[14:12:06.0000] <Bakkot>
ljharb I just do not agree with the claim that being a class encourages subclassing

[14:12:10.0000] <jorendorff>
That's my understanding, yes.

[14:12:24.0000] <shu>
jorendorff: cool thanks

[14:12:28.0000] <michaelficarra>
shu: correct

[14:12:41.0000] <ljharb>
Bakkot: i have heard many people ask me "if i'm not supposed to subclass Promise why can i `extends Promise`"

[14:12:49.0000] <Bakkot>
you can `extends Function` too

[14:12:51.0000] <Bakkot>
so what

[14:12:52.0000] <ljharb>
Bakkot: obv anecdotal but that's my experience

[14:13:01.0000] <shu>
what's the difference between that and "if i'm not supposed to never terminate my function why can i write for(;;)"?

[14:13:02.0000] <ljharb>
Bakkot: yes, and someone asked me *12 hours ago* how to make that work without violating CSP

[14:13:20.0000] <devsnek>
ljharb: you can extends any random function (arrows aside)

[14:13:21.0000] <ljharb>
Bakkot: because their opinion was, Function is a class, i should be able to subclass it

[14:13:21.0000] <michaelficarra>
we should not involve Promise in this discussion, every decision made for Promise was the wrong decision

[14:13:34.0000] <gibson042>
lol, perfect

[14:13:39.0000] <ljharb>
because "being a class" does, for some, imply it's subclassable.

[14:13:40.0000] <shu>
michaelficarra: the name was pretty good

[14:13:49.0000] <devsnek>
ljharb: i can even subclass your functions

[14:13:58.0000] <shu>
ljharb: i think that is a dangerous position to accept

[14:14:01.0000] <ljharb>
devsnek: sure, if i don't make them arrows or concise methods

[14:14:01.0000] <Bakkot>
ljharb I don't think the existence of people with that opinion is a very strong argument, on its own, that we should avoid having class for encapsulating a set of methods

[14:14:03.0000] <ljharb>
shu: dangerous how?

[14:14:17.0000] <ljharb>
devsnek: or async functions or generators

[14:14:19.0000] <shu>
ljharb: possibility is a far cry from "supposed to"

[14:14:40.0000] <Bakkot>
also like

[14:14:43.0000] <Bakkot>
it is fine to subclass these things

[14:14:57.0000] <devsnek>
agree with mark

[14:15:00.0000] <ljharb>
shu: that is true that it being possible is not the same as saying people should do it.

[14:15:40.0000] <Bakkot>
if these things brand check their arguments, that implies you're supposed to subclass

[14:15:42.0000] <ljharb>
shu: but it does mean the *easiest* way to override one method is to subclass it, so that's what people are likely to do

[14:15:46.0000] <ljharb>
Bakkot: that i agree with

[14:15:52.0000] <Bakkot>
but if they take options bags, there is no such implication

[14:16:36.0000] <ljharb>
i think the current design also means that every time a stored calendar object has a method invoked, it's observably Get-ed off the object - the Proxy handler pattern, basically. is that what we want?

[14:16:43.0000] <ljharb>
meaning, should it cache the methods rather than the object?

[14:17:02.0000] <Bakkot>
sure, having temporal cache sgtm

[14:17:08.0000] <Bakkot>
no strong feelings though

[14:17:58.0000] <ljharb>
i would say if it extracts functions off of the object and caches them, then *that* would be treating it like an object bag, and the object's identity/characteristics becomes irrelevant

[14:18:42.0000] <Bakkot>
eh, i think the majority of consumers of options bag consume the arguments as-needed, rather than pulling them off up front

[14:18:52.0000] <Bakkot>
or at least this was true before destructuring made it easier to pull them off

[14:19:00.0000] <gibson042>
I think that would hinder ergonomics, at least in Temporal

[14:19:38.0000] <ljharb>
gibson042: what sort of ergonomics

[14:20:50.0000] <gibson042>
Temporal.TimeZone.from("America/New_York").getNextTransition === Temporal.TimeZone.from("Europe/Paris").getNextTransition, but we definitely don't want the same output for the same input

[14:21:02.0000] <michaelficarra>
FYI first-class protocols proposal includes an easy way to check for conformance to a protocol

[14:21:06.0000] <gibson042>
there's state held in the object

[14:21:50.0000] <jorendorff>
geez how are we having this discussion

[14:22:08.0000] <jorendorff>
JS is not that language, let's move on

[14:22:19.0000] <ljharb>
michaelficarra: yes that would be a perfect answer to this queue item, to be fair.

[14:22:27.0000] <ljharb>
michaelficarra: +1 for first-class protocols

[14:22:38.0000] <Bakkot>
protocols aren't a good fit for this, since this isn't a protocol

[14:23:47.0000] <michaelficarra>
Bakkot: first-class protocols proposal can represent string-based "duck typing"/"protocols" in the same way it represents symbol-based protocols

[14:24:12.0000] <michaelficarra>
we don't want to provide the same convenience for *installing* string-based protocols, since they're not meant to be shared

[14:24:18.0000] <michaelficarra>
but for confirming them, it's fine

[14:24:28.0000] <Bakkot>
eh, sure, ok

[14:24:43.0000] <Bakkot>
ljharb if you only care about wildly wrong things, just pick some particular method and look for that one

[14:24:52.0000] <michaelficarra>
I've thought about this stuff *a lot*

[14:24:55.0000] <Bakkot>
does it have a `day` method? it's probably a calendar. does it not? throw an error

[14:27:41.0000] <ljharb>
littledan: i'm not sure why storing a Record holding all the functions wouldn't work the same

[14:29:13.0000] <shu>
i remain woefully ignorant of temporal

[14:29:18.0000] <shu>
is the current behavior subclassing or not subclassing?

[14:29:31.0000] <devsnek>
yes

[14:29:36.0000] <Bakkot>
shu there's a class, but you don't have to use it

[14:29:42.0000] <Bakkot>
you can just give a grab bag

[14:29:43.0000] <shu>
Bakkot: but to hook behavior, is it to subclass?

[14:29:48.0000] <shu>
okay, so it is not to subclass

[14:29:50.0000] <shu>
great

[14:29:53.0000] <gibson042>
ljharb: it would work if it held the functions *and* the object, with observable differences in the two approaches being whether or not code like `Temporal.TimeZone.prototype.getNextTransition = ‚Ä¶` has any effect on already-used time zones

[14:29:58.0000] <littledan>
ljharb: Since the instances have an internal slot that the methods need to access

[14:30:05.0000] <mathiasbynens>
can someone help to move https://github.com/tc39-transfer/proposal-regexp-set-notation to the proper tc39 org? thanks! cc bterlson

[14:30:06.0000] <Bakkot>
shu subclassing works if you want that, I understand

[14:30:17.0000] <shu>
o

[14:30:21.0000] <ljharb>
littledan: that means it'd need to store the object too, to use as the receiver, sure - but not that it'd need to also do an observable Get every time.

[14:30:27.0000] <shu>
so Temporal does self-sends

[14:30:31.0000] <littledan>
yes

[14:30:39.0000] <shu>
ok

[14:30:52.0000] <ljharb>
gibson042: that is true, but to be that'd be less surprising - it'd mean breaking things only breaks *later* calendar/timezone usage instead of already-constructed, allegedly immutable instances.

[14:31:00.0000] <littledan>
ljharb: Yes, that is a different possible observable semantics

[14:31:06.0000] <ljharb>
gibson042: iow "immutable" seems like it a claim that would *want* the behavior i'm describibng.

[14:31:29.0000] <gibson042>
yes, I can see value in this position

[14:31:32.0000] <ljharb>
ie, Temporal objects as specified are not immutable at all - they're mutable by mutating a calendar method.

[14:31:38.0000] <ljharb>
*replacing

[14:33:32.0000] <gibson042>
but it's now a much narrower difference, just "Get(‚Ä¶) every time" vs. "Get(‚Ä¶) on ingest only"

[14:34:29.0000] <Bakkot>
fwiw it actually looks like Ecma 402 usually does ingestion relatively eagerly

[14:34:44.0000] <Bakkot>
e.g. https://tc39.es/ecma402/#sec-initializedatetimeformat

[14:37:11.0000] <ljharb>
gibson042: it'd be "Get once, plus Call every time" rather than "Get + Call every time"

[14:37:30.0000] <gibson042>
yep

[14:37:31.0000] <ljharb>
gibson042: which was the same change, with a perf motivation,. to look up `this.resolve` in all the Promise methods

[14:37:40.0000] <ljharb>
*combinators

[14:37:49.0000] <gibson042>
also in Map/Set/etc. constructors IIRC

[14:38:11.0000] <gibson042>
there was/is an exception in 402 that I'm looking for now

[14:38:22.0000] <gibson042>
but it was clearly unintentional, and a mess

[14:38:34.0000] <Bakkot>
gibson042 yes for map/set/etc ctors, though that was internal to a single method rather than caching for laters

[14:39:12.0000] <ystartsev>
wsdferdksl: i noticed people sometimes talk over you but it doesn't seem intentional, is it a delay issue? i don't know if others have noticed it

[14:39:45.0000] <ystartsev>
also, a bunch of people just left

[14:39:47.0000] <Bakkot>
it's only happened in the last hour or two that I noticed, and I think it's a network issue yeah

[14:40:10.0000] <ljharb>
i can't see tab's video

[14:40:28.0000] <ljharb>
(because teams doesn't let me browse through everybody while seeing their video)

[14:42:56.0000] <TabAtkins>
It's all right, it's just me in my jammies and housecoat, and pretty scruffily unshaved

[14:44:43.0000] <gibson042>
https://github.com/tc39/ecma402/issues/132 is definitely relevant

[14:47:04.0000] <gibson042>
https://github.com/tc39/ecma402/pull/493#discussion_r465537106 is what I was thinking of, which is related but distinct

[14:51:27.0000] <ljharb>
gibson042: thanks for finding that

[14:59:10.0000] <jridgewell>
We should do JSConf Hawaii again in the aftertimes.

[15:00:55.0000] <TabAtkins>
yes absolutely

[15:01:04.0000] <Bakkot>
I am most excited to actually have the tokyo meeting

[15:01:10.0000] <michaelficarra>
was Hawaii a sufficient compromise timezone-wise for Asian delegate inclusion, or would Tokyo be better?

[15:01:15.0000] <Bakkot>
I keep making plans to go to Japan or HK and having them not work out

[15:01:24.0000] <Bakkot>
(and HK is probably not an option any more...)

[15:01:37.0000] <ljharb>
sooooo sad about tokyo and looking forward to that meeting

[15:02:04.0000] <ljharb>
michaelficarra: tough to tell; none attended, but it was also covid time for them

[15:02:11.0000] <jridgewell>
I don't believe any Asian delegates were in HI

[15:02:17.0000] <jridgewell>
So, probably not good enough?

[15:02:39.0000] <ljharb>
also i think that particular week was a holiday in china?

[15:02:42.0000] <TabAtkins>
i had an *amazing* alaska/japan cruise planned last year, that obviously had to get canceled. as did my mediterranean cruise that was supposed to happen this summer, too :(

[15:03:11.0000] <michaelficarra>
TabAtkins: I bet you are a fun cruise partner

[15:03:30.0000] <TabAtkins>
I do board game cruises (BGG At Sea) and yeah, I hope so

[15:03:33.0000] <TabAtkins>
my wife enjoys it at least

[15:08:44.0000] <Bakkot>
also a reminder to please fill out the do-exprs survey if you haven't yet: https://docs.google.com/forms/d/e/1FAIpQLScyNcGNfjoJXMTmfBkLRMREKCP2TihiFGqc26HhjL4710qdiA/viewform?usp=sf_link

[15:09:06.0000] <jridgewell>
I bought a heated floor mat for my feet, and it's the üí£

[15:09:11.0000] <jridgewell>
Now I feel like a cat.

[15:09:34.0000] <Bakkot>
i bought slippers

[15:09:49.0000] <jridgewell>
I have slippers, and they weren't doing the job well enough.


2021-01-29
[19:12:01.0000] <shu__>
@@species strikes again!!

[19:12:25.0000] <shu__>
the fuzzers found a bug with a correctness i fixed in async generators in v8 from february *last year*

[19:12:34.0000] <shu__>
because of monkeypatched Promise.constructor :(

[06:55:11.0000] <littledan>
it it time to create the 2021/03 agenda?

[08:29:36.0000] <ljharb>
yep, i'll take care of it

[10:28:47.0000] <leobalter_ic>
I'm very happy to see Temporal for Stage 3 in the 2021/03 agenda.

[10:54:17.0000] <leobalter_ic>
I really like ystartsev's modules lazy import, but I find it unfortunate the TC39 presentation was not recorded. I could have used it to share internally with my team


2021-01-30
[19:56:30.0000] <Bakkot>
could I ask a chair to move the open issues on https://github.com/bakkot/do-expressions-v2/issues to https://github.com/tc39/proposal-do-expressions/ ?

[20:00:31.0000] <Bakkot>
also to bounce https://github.com/tc39-transfer/proposal-async-do-expressions to the main tc39 org

[20:00:52.0000] <Bakkot>
(no rush on these, of course; I expect we're all pretty dead after plenary)

[21:42:30.0000] <ljharb>
Bakkot: they'd have to be in the same org to be able to transfer issues.

[21:42:48.0000] <Bakkot>
awwww, really?

[21:42:51.0000] <ljharb>
yep

[21:43:00.0000] <ljharb>
you can bounce the repo to transfer, move the issues yourself, and then move the repo back to your username tho

[21:43:17.0000] <ljharb>
oh wait, nvm, the actual proposal is on tc39

[21:43:43.0000] <Bakkot>
that's dumb

[21:43:45.0000] <ljharb>
so yeah you have to move yours to tc39 via hops in order to transfer them

[21:43:49.0000] <Bakkot>
I guess I will just manually recreate them

[21:43:55.0000] <ljharb>
probably easiest

[01:01:48.0000] <ystartsev>
leobalter_ic: yeah sometimes i wonder if we could have the prsentationtions recorded regularily

