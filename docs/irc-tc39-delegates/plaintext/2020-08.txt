2020-08-03
[09:45:43.0000] <leobalter>
littledan: I'm not a big fan of trailing comma in the import conditions for `import()`

[09:45:45.0000] <leobalter>
https://github.com/tc39/proposal-import-assertions/pull/77/files#diff-3540caefa502006d8a33cb1385720803R38

[09:46:29.0000] <leobalter>
idk, it looks like an approach to make it similar to function calls, but it distorts from what we have today from other expressions

[09:46:33.0000] <leobalter>
like void and typeof

[09:47:37.0000] <leobalter>
it is not a big deal, but I definitely need to take it with a grain of salt

[09:48:50.0000] <leobalter>
and while I see some motivation for function calls leaving a trailing comma, I don't see many for import, it's too specific and cannot really be monkey patched.

[09:51:22.0000] <ljharb>
it's the same motivation

[09:51:56.0000] <devsnek>
i think import calls should always have had trailing commas

[09:51:59.0000] <ljharb>
note that webpack requires special comments between `import(` and the specifier, and people often write them multiline - `import(\n\t/* webpack magic */\n\tspecifier\n)`

[09:52:22.0000] <ljharb>
and by allowing a trailing comma, you minimize git diffs when adding or removing the import assertions - minimizing diffs imo is the motivation for trailing commas anywhere

[09:52:31.0000] <ljharb>
+1 to `import()` should always have allowed trailing commas

[10:23:50.0000] <littledan>
hopefully it's not a problem that we don't allow leading comments!

[10:24:04.0000] <littledan>
leobalter: I could go either way on trailing commas for import assertions, personally

[10:24:25.0000] <littledan>
I was persuaded by the argument devsnek and ljharb make above that really, all calls should have this

[10:25:21.0000] <leobalter>
as I said, I need to accept this with a grain of salt

[10:28:02.0000] <leobalter>
the motivations are not good enough for me, but shipping this little awful part is a better goal won't cause me harm on everyday usage or get me stuck on future code.

[10:28:49.0000] <devsnek>
what is the comparison to void and typeof

[10:29:02.0000] <leobalter>
they are all expressions like import

[10:29:14.0000] <devsnek>
I mean what do they have to do with trailing commas

[10:29:35.0000] <leobalter>
they don't have a usage format with trailing commas

[10:29:54.0000] <devsnek>
neither does addition

[10:30:54.0000] <leobalter>
are you devaluaing my subjective point of view? Even when I say I'm ok with this "feature"?

[10:31:04.0000] <devsnek>
no I'm trying to understand it

[10:31:08.0000] <leobalter>
I'm not sure where we can go from here

[10:31:47.0000] <devsnek>
I just don't understand what parallel there is between void and import in the context of trailing commas, and I wanted to understand it

[10:32:09.0000] <leobalter>
they are all expressions

[10:32:30.0000] <devsnek>
you can join expressions with commas

[10:32:35.0000] <devsnek>
is that what you're saying?

[10:32:39.0000] <leobalter>
not function calls, even if they look like function calls

[10:32:47.0000] <devsnek>
void looks like a function call?

[10:32:57.0000] <devsnek>
oh do you mean

[10:33:00.0000] <leobalter>
`void(0)`

[10:33:01.0000] <devsnek>
void (x)?

[10:33:07.0000] <devsnek>
ok now I understand

[10:33:22.0000] <devsnek>
do people actually do that

[10:59:51.0000] <bradleymeck>
devsnek: typeof(x) is seen enough for me to be familiar with

[12:12:01.0000] <ljharb>
littledan: in the first position of `import()`? they're surely allowed

[12:12:10.0000] <ljharb>
littledan: "any expression" is allowed there

[12:13:00.0000] <ljharb>
leobalter: `super()` allows trailing commas: `class C extends Object { constructor() { super(3,); } }`

[12:13:06.0000] <ljharb>
leobalter: `import()` is exactly like `super()`.

[12:13:12.0000] <ljharb>
(as opposed to being like typeof/void)

[12:15:41.0000] <leobalter>
in my brain, super takes arguments. These arguments are arbitrarily-picked by the developer. Where the import() is an expression without args but a specific notation of settings.

[12:17:03.0000] <leobalter>
it's subjective. It's weird that we came so long with `import(x)` not being a function that even empty args are invalid syntax

[12:17:05.0000] <ljharb>
to me, `import()` is conceptually calling a function, just like `super()` is, and import assertions makes that even more true

[12:17:31.0000] <littledan>
I meant, you can't do `import(\n\t/* webpack magic */,\n\tspecifier\n)`

[12:17:39.0000] <ljharb>
also tho, `void` and `typeof` are not function-like at all; `super()` and `import()` are.

[12:17:43.0000] <littledan>
it was a joke; I don't think this is up for debate

[12:17:52.0000] <ljharb>
littledan: without the comma you can :-p

[12:17:57.0000] <littledan>
heh yes

[12:18:00.0000] <ljharb>
lol k

[12:18:24.0000] <leobalter>
nit: `import()` itself is a syntax error

[12:18:49.0000] <ljharb>
indeed, that is true

[12:18:52.0000] <leobalter>
and extend this to `import(/* magic */)`

[12:20:30.0000] <leobalter>
consistency w/ Arguments is not a strong argument for me here (puns not intended) as we can never be completely consistent.

[12:21:46.0000] <leobalter>
in any case, I'm not trying to block and I'm not insisting for us to change this.

[12:21:54.0000] <leobalter>
I personally don't like it

[12:22:05.0000] <littledan>
we could just permit Arguments in `import()`

[12:22:16.0000] <littledan>
and just ignore it if people give too many ,and cast from undefined if people give too few

[12:22:26.0000] <leobalter>
I'd prefer if this could be separate from Import Assertions, but not worth all the hassle

[12:22:52.0000] <littledan>
I agree that these changes aren't worth much hassle one way or another

[12:24:51.0000] <rkirsling>
what if...we made `()` a value

[12:24:56.0000] <rkirsling>
oops this isn't TDZ

[12:25:34.0000] <leobalter>
I'm not sure what optimization do we want that prevents us from going with: `import Arguments`. Releasing a lot of static errors that are exclusively to `import()`

[12:26:57.0000] <leobalter>
we could benefit from something like:

[12:26:57.0000] <leobalter>
const settings = [specifier, opts];

[12:26:57.0000] <leobalter>
import(...settings);

[12:28:46.0000] <littledan>
I think there was some logic that, if import is a keyword, it shouldn't have call-like syntax

[12:28:51.0000] <littledan>
I don't really get that argument

[12:29:07.0000] <littledan>
I'd be fine to break out a separate PR to change the syntax of `import() `to take arbitrary Arguments

[12:33:39.0000] <leobalter>
A PR for that should be relatively easy. I’d probably ask if we want empty arguments as valid too.

[13:02:50.0000] <ljharb>
since empty arguments will *always* be a bug, detectable only asynchronously, why would we want to allow it?

[13:02:53.0000] <ljharb>
same with spreading an empty array

[13:03:25.0000] <ljharb>
i don't think 100% consistency is more important than providing reasonable things everyone expects, like trailing commas, and prohibiting harmful things nobody expects to be permitted


2020-08-04
[17:20:53.0000] <devsnek>
we have lots of functions where passing no arguments is a bug

[17:21:48.0000] <Bakkot>
none of the rest of them are identifiable purely syntactically though

[16:36:08.0000] <rkirsling>
where is the step 1 for onboarding somebody located

[16:39:44.0000] <rkirsling>
ahh comments in the issue template, I see


2020-08-07
[11:13:57.0000] <shu>
did we ever talk about Math.fround on bigints? alon (who works on emscripten) reached out to me that as it is currently specced (float64->float32), trying to round BigInts to float32s requires accumulating rounding errors by first going to a float64

[11:14:16.0000] <shu>
i'm assuming this rounding behavior actually broke the compilation of some c/c++ code in emscripten

[11:16:45.0000] <devsnek>
we need to generally get bigint supported in math methods

[11:16:50.0000] <ljharb>
+1

[11:16:51.0000] <devsnek>
its on my list of proposals

[11:16:59.0000] <ljharb>
i haven't had time to get that together but will be happy to cochampion with whoever does

[11:17:13.0000] <devsnek>
https://snek.dev/proposal-list

[11:18:07.0000] <shu>
i am not sure all math methods make sense

[11:18:24.0000] <devsnek>
well not literally all of them

[11:18:33.0000] <devsnek>
wouldn't make much sense with Math.sin

[11:19:51.0000] <shu>
it's a fairly small subset actually

[11:20:35.0000] <shu>
the bitwise stuff, min/max, uh... sign, abs

[11:21:21.0000] <devsnek>
abs, cbrt, clz32, fround, imul, the logs, max, min, pow, sign

[11:25:11.0000] <shu>
sgtm

[11:45:01.0000] <Bakkot>
the logs are kinda weird because you often want a number out

[11:45:28.0000] <Bakkot>
most bigints in my code are such that log2(bigint) would be less than 2**53

[11:45:41.0000] <shu>
i assumed the logs would continue to output numbers

[11:46:01.0000] <shu>
it would be unusual to want integral logs, right?

[11:49:10.0000] <bradleymeck>
except for change of base?

[11:49:22.0000] <Bakkot>
dunno about that. integral log2 (rounded up) tells you how many bits are are in a thing.

[11:50:23.0000] <TabAtkins>
Yeah but you can just... round up, if you want that. I'd want the actual fp log of my bigint by default.

[11:51:58.0000] <Bakkot>
sure, just saying that integral logs are not unusual

[12:01:53.0000] <ljharb>
shu: it'd definitely be a case by case audit

[12:02:00.0000] <ljharb>
but anything where it makes sense, it should work

[12:49:32.0000] <TabAtkins>
just print the number and hold your ruler up to the screen if you want integral log, imo

[14:39:05.0000] <littledan>
> Private data that isn’t bad

[14:39:05.0000] <littledan>
devsnek: I would be interested in your thoughts on this

[14:39:33.0000] <devsnek>
i feel like i've vocalized my thoughts on private fields already :P

[14:40:28.0000] <littledan>
Oh sorry I guess I forgot what they were, if there was something additive. Do you have a reference?

[14:40:50.0000] <littledan>
(if not that's fine)

[14:41:07.0000] <devsnek>
i mean the tl;dr is i think they are a bad thing that doesn't fit the rest of the language

[14:42:10.0000] <littledan>
Right so I wasn't sure which part you might want to fix with a proposal

[14:43:04.0000] <devsnek>
something without new syntax and forced throwing

[14:51:05.0000] <littledan>
throwing?

[14:52:38.0000] <littledan>
shu: Curious why this comes up from JS and not just Wasm. I thought Math.fround was sort of an asm.js albatross at this point.

[14:55:46.0000] <devsnek>
littledan: they throw instead of returning undefined

[14:56:28.0000] <devsnek>
also the emscripten stdlib on the js side has to do various operations, i'd guess that's where the problem is

[14:59:54.0000] <littledan>
In which case (re private)?

[15:04:44.0000] <littledan>
I mean, it already does throw in a bunch of cases; that was a design goal. Do you mean how they're default-initialized to undefined as fields?

[15:10:04.0000] <devsnek>
littledan: no I mean I don't think they should throw if they don't exist on the receiver

[15:10:25.0000] <littledan>
oh, you meant *without* throwing, OK

[15:11:06.0000] <devsnek>
now that they are implementation reality one can only hope we can add all the features needed to make them usable

[15:19:16.0000] <littledan>
so, which features would those be?

[15:19:42.0000] <devsnek>
probably the simplest would be reifying them

[15:20:16.0000] <devsnek>
cuz then you could just use the value with `in` and as a computed lookup and add it to existing objects and delete it from things and etc

[15:23:04.0000] <devsnek>
you could do each one of those as its own bespoke feature but that gets into my point about composing with the language

[15:37:43.0000] <shu>
littledan: it came up in emscripten generated js fallback code

[15:37:54.0000] <shu>
so that aligns with your understanding


2020-08-08
[17:48:02.0000] <littledan>
shu: What do you mean by "fallback"? Is this path invoked only in older browsers?

[12:15:45.0000] <shu>
littledan: yes, for without wasm i think

[14:23:41.0000] <littledan>
Shu, hmm, it's hard for me to see how new JS library features would help this kind of case, at least in browser/node environments which do support Wasm


2020-08-12
[11:17:26.0000] <MylesBorins>
how do people feel about something like bufferlist for Uint8Arrays?

[11:17:37.0000] <MylesBorins>
would this make sense for TC39? maytbe a whatwg thing?

[11:17:58.0000] <MylesBorins>
https://www.npmjs.com/package/bl

[11:19:39.0000] <Bakkot>
MylesBorins I can't entirely tell what that does?

[11:19:50.0000] <MylesBorins>
this was something that was created to work with Node.js buffers

[11:20:08.0000] <MylesBorins>
if you are receiving a stream of buffers you can use the bl interface to compile them into a list of buffers and operate on them

[11:20:20.0000] <MylesBorins>
Deno is starting to implement their own approach to buffers / solving groups of buffers

[11:20:45.0000] <MylesBorins>
I'm on the fence if this should be a language feature (and as such WHATWG might be more appropriate)

[11:21:41.0000] <devsnek>
so like

[11:21:41.0000] <devsnek>
optimized TypedArray concat?

[11:22:08.0000] <MylesBorins>
I've had a need for this when automating and concatenating output from child processes

[11:22:38.0000] <MylesBorins>
if you simply turn the buffer to string you can end up converting a buffer that has partial data

[11:22:51.0000] <MylesBorins>
so the buffer list allows you to collect all the buffers that make up the message before converting to string

[11:31:13.0000] <ljharb>
i've had use cases of being able to combine Maps/Sets without iterating over all of them, or WeakMaps/WeakSets, which can't be iterated over; which seems like the same kind of "lazy combination wrapper" as bufferlist?

[11:31:51.0000] <shu>
do you want a StringBuffer, but for Buffers? like a BufferBuffer?

[11:33:15.0000] <shu>
also unclear on why this needs to be a language feature

[11:33:51.0000] <devsnek>
i'm assuming performance

[11:33:59.0000] <devsnek>
typedarray.p.set is not ideal

[11:34:18.0000] <ljharb>
it's really annoying to implement a WeakSet that also wraps existing WeakSets

[11:34:23.0000] <ljharb>
totally doable, but not trivial

[11:34:31.0000] <shu>
are we talking about weaksets or buffers

[11:34:43.0000] <devsnek>
i'm talking about buffers

[11:34:47.0000] <shu>
also unclear you get performance benefits with a generic lazy combination buffer

[11:34:49.0000] <ljharb>
lol sorry, i guess i bogarted the topic a bit, let's go back to buffers

[11:34:55.0000] <devsnek>
ljharb: isn't there already a set union proposal

[11:35:03.0000] <ljharb>
devsnek: set, not weakset

[11:35:11.0000] <devsnek>
open an issue i gus

[11:35:12.0000] <devsnek>
guess

[11:35:39.0000] <devsnek>
shu: we have Buffer.concat in node for a reason :P

[11:35:59.0000] <Bakkot>
MylesBorins there might be something here but I'm not entirely sure what problems you have that this solves, which makes it hard to tell

[11:36:13.0000] <shu>
devsnek: and that reason is?

[11:36:19.0000] <Bakkot>
if the motivation is _just_ converting to strings, it sounds like a thing for TextEncoder (it could take a list of buffers instead of just a buffer), which is (somewhat unfortunately) a WHATWG thing

[11:36:49.0000] <devsnek>
its faster to make c++ do it

[11:37:23.0000] <devsnek>
actually i take this all back Buffer.concat was ported to js

[11:38:08.0000] <Bakkot>
MylesBorins I am definitely on board with adding more stuff for working with buffers in general though

[11:39:10.0000] <MylesBorins>
so at a very very high level thing here

[11:39:24.0000] <MylesBorins>
node has Buffer.concat

[11:39:30.0000] <MylesBorins>
the ecosystem has stuff like bl

[11:39:35.0000] <MylesBorins>
deno is starting to solve this problem too

[11:39:54.0000] <MylesBorins>
(I'm not as familliar with front end problems that might need this type of solution)

[11:40:05.0000] <MylesBorins>
but avoiding environments from continuing to diverge is a huge goal to me

[11:40:14.0000] <Bakkot>
if the problem is quickly making a new buffer from some existing buffers, sounds like it would be a good proposal, yeah

[11:40:16.0000] <shu>
Buffer itself has already diverged

[11:40:19.0000] <MylesBorins>
I think "is this a language feature" is a super fair question

[11:40:34.0000] <MylesBorins>
and why I'm not 100% convinced 262 is the right venue

[11:40:46.0000] <shu>
would the ability to concat ArrayBuffers ease transition from node buffers to ArrayBuffers? (which are pretty different ergonomically)

[11:41:07.0000] <MylesBorins>
shu TBH I'm not as deep into this part of the code base, so solid maybe

[11:41:20.0000] <shu>
so i see two divergence problems: deno and node, and server and front-end

[11:41:33.0000] <shu>
i *think* my feeling about the Buffer polyfill is that it's a scourage?

[11:41:34.0000] <shu>
scourge

[11:42:04.0000] <MylesBorins>
I got pinged by Mikeal Rogers about this, specifically because he is seeing all the work we are having to do in node to tease us off buffer

[11:42:05.0000] <MylesBorins>
and seeing deno head in the same direction

[11:42:17.0000] <shu>
"tease us off buffer" -> where does node wanna go?

[11:42:40.0000] <devsnek>
in terms of buffer we'd rather just use normal Uint8Arrays

[11:44:04.0000] <MylesBorins>
yeah, I defer to the devsnek here ::P

[11:44:14.0000] <devsnek>
the thing is

[11:44:21.0000] <devsnek>
when we hit some sort of usability problem along that pathway

[11:44:40.0000] <devsnek>
the question is whether its a problem with uint8array or a problem with node

[11:44:50.0000] <devsnek>
i think that's sort of what myles meant above?

[11:46:14.0000] <shu>
in the specific concat and BL cases, it does smell like a pre-generalized solution that mainly cares about strings. is that accurate?

[11:46:28.0000] <MylesBorins>
shu not neccessarily

[11:46:36.0000] <MylesBorins>
strings were just the example I have personal experience with

[11:46:57.0000] <MylesBorins>
my understanding is that folks who work with streaming interfaces use bl extensively as an intermediary format for the incoming data

[11:47:47.0000] <shu>
that gets into a separate domain of streams

[11:48:14.0000] <MylesBorins>
streams utilize this, even emitters utilize this as well

[11:48:40.0000] <MylesBorins>
if you have an emitter or a async iterable that is returning buffers you may want to deal with them as an opitmized list

[11:48:47.0000] <MylesBorins>
as opposed to shove them all in an array and concat later

[11:49:01.0000] <shu>
i guess i'm also missing what is the optimization opportunity

[11:49:15.0000] <shu>
the individual buffers are still all there and observable?

[11:50:04.0000] <MylesBorins>
I've asked mikeal to give me more examples

[11:50:05.0000] <MylesBorins>
tbh I'm serving much more as a middle person here

[11:53:12.0000] <devsnek>
the individual buffers are still there

[11:53:26.0000] <devsnek>
ideally this would be more like preallocating a buffer and passing it to the api

[11:53:35.0000] <devsnek>
but js doesn't have resizable buffer types yet


2020-08-13
[07:31:27.0000] <bradleymeck>
littledan: is the educators call still a thing?


2020-08-14
[06:24:37.0000] <littledan>
bradleymeck: yes, now it's run by bkardell and Jory, and the meetings tend to be shorter or sometimes cancelled. They are focusing on producing introductory content for TC39

[06:25:20.0000] <littledan>
I hope that we can get back to "reviewing proposals from an educational perspective" at some point, but this does not seem to be the focus of the current attendees

[16:30:05.0000] <Bakkot>
I like the C++ committee's description of how their consensus process works: https://isocpp.org/std/standing-documents/sd-4-wg21-practices-and-procedures#consensus


2020-08-15
[20:49:31.0000] <ljharb>
TabAtkins: i'm finishing the polyfills for `item`, and i'm curious - what should `'abc'.item(-4)` return? `'abc'.item(3)` should obv return undefined, but should `-4` return undefined, or should it be the same as `'abc'.item(-1)`? the current algorithm seems to make it equal to `'abc'.item(0)` which seems weird

[20:50:05.0000] <ljharb>
like, i'd expect modulo/wrapping, or undefined, but i wouldn't expect "everything that tries to go before 0, provides 0"

[20:53:12.0000] <ljharb>
(oops, obv the string one would produce the empty string while the array one produced undefined, but, same question)

[20:55:17.0000] <devsnek>
ljharb: `this.len + index`

[20:55:30.0000] <devsnek>
oh nvm i get what you're asking

[20:55:53.0000] <ljharb>
right

[20:56:06.0000] <ljharb>
the current "relative" math works when it the positive or negative number is within 0,length

[20:56:13.0000] <devsnek>
ya

[20:56:17.0000] <Bakkot>
undefined, I would expect

[20:56:23.0000] <devsnek>
if you go around more than once it forces it to be 0

[20:56:25.0000] <ljharb>
but if you pass ">= length", you'll get undefined/empty string, as expected

[20:56:30.0000] <Bakkot>
see what Python does with its negative indexes

[20:56:36.0000] <ljharb>
but if you pass `<= -length`, that's not what the current spec does

[20:56:42.0000] <devsnek>
i like undefined for that

[20:57:01.0000] <Bakkot>
python gives RangeError, which means we should give undefined

[20:57:01.0000] <ljharb>
(because of the `max(?, 0)`

[20:57:08.0000] <ljharb>
Bakkot: i agree

[20:57:15.0000] <ljharb>
ok, i'll make a PR to fix the spec

[20:57:16.0000] <Bakkot>
*IndexError is I guess what they call it

[20:57:25.0000] <Bakkot>
I think there is an issue about thiis?

[20:57:32.0000] <ljharb>
oh

[20:58:14.0000] <Bakkot>
mahttps://github.com/tc39/proposal-item-method/issues/11

[20:59:15.0000] <Bakkot>
I have no idea where that "ma" came from

[20:59:33.0000] <devsnek>
aha the built spec just needs to be updated

[21:00:19.0000] <ljharb>
my internet's having trouble, but i can make a PR for that shortly

[21:01:29.0000] <Bakkot>
gotta make CI enforce that git state is clean after `npm run build`

[21:01:46.0000] <ljharb>
i suppose i could add that too

[21:02:39.0000] <Bakkot>
I guess that would involve _having_ CI, first

[21:02:46.0000] <Bakkot>
which is maybe a burden not worth the benefit

[21:02:51.0000] <TabAtkins>
ljharb: Clamping isn't the current spec.

[21:03:12.0000] <Bakkot>
maybe it is worth it though, especially once I get linting in a state where it works for proposals

[21:03:28.0000] <devsnek>
multipage will be key for proposals

[21:03:33.0000] <devsnek>
:P

[21:03:33.0000] <TabAtkins>
Oh wait nm, the spec proposal hasn't been updated yet, ugh.

[21:03:46.0000] <Bakkot>
devsnek lol

[21:03:58.0000] <Bakkot>
I'll get to that PR at some point before the next release probably

[21:04:04.0000] <devsnek>
cool

[21:04:16.0000] <Bakkot>
(no guarantee I'll merge it before the release though)

[21:04:19.0000] <ljharb>
TabAtkins: looking at https://tc39.es/proposal-item-method/

[21:04:22.0000] <Bakkot>
have to figure out what I'm doing about ecma402's normative-optionality before I cut a new release

[21:04:31.0000] <TabAtkins>
Huh, maybe it hasnt' been built yet? https://github.com/tc39/proposal-item-method/commit/5235acba371d18dcca6383c9f0e25cdbd518a7f6 fixes it to return undefined for oob

[21:04:46.0000] <devsnek>
did you see the normative optional thing I put in the __proto__ pr

[21:04:46.0000] <ljharb>
TabAtkins: i think it's what Bakkot said above; CI doesn't force `npm run build` to be run

[21:04:53.0000] <devsnek>
I stole it from the weakref proposal

[21:05:01.0000] <ljharb>
TabAtkins: i'll make a PR shortly to bring in the github action that automates doing that, from the templat

[21:05:04.0000] <devsnek>
but it looks nice

[21:05:07.0000] <devsnek>
you could use that

[21:05:35.0000] <Bakkot>
ah, sorry, I should have been more clear

[21:05:40.0000] <Bakkot>
402 has normative-optional steps

[21:05:49.0000] <devsnek>
ohno

[21:06:00.0000] <TabAtkins>
ah, danke

[21:06:02.0000] <devsnek>
hm actually I guess we do too

[21:06:13.0000] <devsnek>
because we decided to make Optionally, do X

[21:06:15.0000] <Bakkot>
which they accomplish like this: https://github.com/tc39/ecma402/blob/62583d85e66bcec8639153347119d3fb1b99387d/spec/numberformat.html#L704-L716

[21:06:20.0000] <devsnek>
even though X is already a host hook

[21:06:27.0000] <ljharb>
TabAtkins: as soon as comcast stops being broken :-p

[21:06:45.0000] <Bakkot>
and ecmarkup's linter does not like starting steps with indices other than 1, because I assumed the step-references thing would suffice to get rid of those

[21:07:13.0000] <Bakkot>
so I will probably teach ecmarkup about this pattern as well, so that this pattern does not require you to explicitly include the offsets

[21:07:30.0000] <devsnek>
I'd say, [optional]

[21:07:45.0000] <devsnek>
[optional, id=x]

[21:07:47.0000] <devsnek>
etc

[21:07:52.0000] <Bakkot>
yeah, the alternative is to introduce a new pattern and PR 402 to use that

[21:08:04.0000] <Bakkot>
but I kind of prefer not changing what's there

[21:08:13.0000] <Bakkot>
but only kind of

[21:08:15.0000] <Bakkot>
not sure yet

[21:08:31.0000] <devsnek>
I think it's definitely bad for there to be explicit step numbers

[21:08:50.0000] <Bakkot>
right, any approach will result in that not being there

[21:09:24.0000] <Bakkot>
"teaching ecmarkup about this pattern" means teaching it to compute the right offsets itself when it encounters this pattern

[21:09:58.0000] <devsnek>
I guess the question is what's best for multiple steps in a row being optional

[22:26:47.0000] <ljharb>
TabAtkins: https://github.com/tc39/proposal-item-method/pull/18


2020-08-16
[22:04:20.0000] <ljharb>
Bakkot: i wonder how much weirdness is explained by "ecma liked word"


2020-08-18
[16:57:02.0000] <ljharb>
i requested the tc39 org be enabled for the new "default branch for new repos" setting; if the chairs (akirose MylesBorins robpalme bterlson) could go to https://github.com/organizations/tc39/settings/repository-defaults , that can be set to "main" for all new repos in that org right now.


2020-08-19
[17:09:59.0000] <Bakkot>
gibson042: https://github.com/tc39/ecma262/commit/fd89c38c38bacc2fc0369630d06995bbe8f15cce should probably have been its own PR

[17:11:01.0000] <Bakkot>
both because it's unrelated to the actual change in #2021 and because when you add nontrivial changes to an existing PR after it's been reviewed those changes might get merged without review, as just happened

[18:00:32.0000] <MylesBorins>
ljharb done

[18:00:40.0000] <ljharb>
thanks!

[18:02:34.0000] <ljharb>
Bakkot: happy to revert that one commit (i kept them separate) and it can come back as a separate PR, if you'd prefer

[18:03:52.0000] <Bakkot>
ljharb it looks fine; I don't think it needs reverting. I'd've just preferred to review it before it was landed, is all

[18:04:00.0000] <Bakkot>
ideally in its own PR

[18:04:08.0000] <ljharb>
noted, i'll look out for that sort of thing in the future

[18:50:09.0000] <Bakkot>
ljharb btw it looks like the most recent commit on https://github.com/tc39/template-for-proposals/commits/main failed, probably because of the master->main rename

[18:50:53.0000] <Bakkot>
ljharb also I am confused by the claim "ecmarkup uses HTML syntax, but is not HTML"

[18:50:56.0000] <Bakkot>
how is it not HTML?

[18:51:06.0000] <ljharb>
thanks, i'll take a look

[18:51:16.0000] <ljharb>
i think it might be the protected branch thing, which i'd enabled

[18:51:22.0000] <Bakkot>
ahh, yeah, probably that

[18:51:40.0000] <Bakkot>
protected branches are good, it'd be a shame if we can't use them

[18:52:02.0000] <ljharb>
so i think it's because i pushed directly to the default branch

[18:52:14.0000] <ljharb>
normally, the action kicks off on PRs, and so it doesn't need to update anything once merged

[18:52:50.0000] <ljharb>
anyways re the ecmarkup thing, it's not html because it can't be rendered in a web browser as is, and it's not valid html? not sure this is really worth getting into a debate about tho

[18:52:55.0000] <ljharb>
name the file whatever you want ofc

[18:54:41.0000] <Bakkot>
it is valid HTML and can be rendered in a web browser as-is, that's the bit I'm confused about

[18:56:53.0000] <Bakkot>
but yeah I don't much care

[18:56:53.0000] <ljharb>
<emu-alg> isn't a valid html element afaik

[18:56:54.0000] <ljharb>
re the template PR, we don't want `--strict` with `--watch`?

[18:56:54.0000] <Bakkot>
the notion of what is a valid element changed significantly with the introduction of web components

[18:56:54.0000] <Bakkot>
re: pr, I think not? I would assume if someone is doing --watch they just want to see the rendered output

[18:57:01.0000] <Bakkot>
and can worry about fixing errors later

[18:57:27.0000] <Bakkot>
also it's not clear what it would even mean; do you abort the watch job?

[18:57:44.0000] <Bakkot>
actually yeah I made it so ecmarkup won't let you combine them, for that reason: https://github.com/tc39/ecmarkup/blob/0a0d7b6b9028c5e90f20302e8285602258681f70/src/cli.ts#L22-L25

[18:58:11.0000] <ljharb>
i'd want the job to continue but all strict errors to log, just like every test framework does in watch mode

[18:58:23.0000] <ljharb>
(i think web components aren't valid until you have JS to define them tho; and we're not defining all our emu elements)

[18:58:23.0000] <Bakkot>
ahh, they log whether or not you pass the flag

[18:58:27.0000] <ljharb>
oh

[18:58:33.0000] <ljharb>
so `--strict` is only about the exit behavior

[18:58:34.0000] <Bakkot>
--strict just makes them fail the build

[18:58:35.0000] <ljharb>
k

[18:58:40.0000] <ljharb>
makes sense

[18:58:56.0000] <Bakkot>
well, also prevents the file from getting written, because I am opposed to writing files on non-zero exit code

[18:59:33.0000] <Bakkot>
re: web components, I guess that hinges on what you mean by "valid"

[19:00:07.0000] <ljharb>
fair


2020-08-21
[23:24:16.0000] <haxjs>
`Promise({})` v8 error info "undefined is not a promise"  is really confusing...

[23:28:40.0000] <Bakkot>
haxjs: I believe V8 accepts bugs which are just "this is a bad error message"

[23:28:49.0000] <Bakkot>
there might already be one for that, but if not you could file one

[23:32:15.0000] <Bakkot>
they have more reasonable messages for things like `Map()`: "Constructor Map requires 'new'"

[23:32:37.0000] <Bakkot>
so I'm guessing this one is just an oversight, which hopefully wouldn't be too hard to fix

[23:58:49.0000] <haxjs>
Bakkot https://bugs.chromium.org/p/v8/issues/detail?id=10817 filed.

[08:43:45.0000] <devsnek>
haxjs: it's a pretty simple fix if you want to contribute to v8 :D


2020-08-24
[08:08:19.0000] <haxjs>
do we have incubator call now?


2020-08-25
[08:28:35.0000] <keith_mi_>
shu: Are there any WPT tests for disconnected iframes and FinalizationRegistry?

[08:28:58.0000] <keith_mi_>
I need to hook that up before enabling by default and existing tests would save me some time :P

[09:26:53.0000] <shu>
keith_miller: i don't think so, let me double check though

[09:27:57.0000] <keith_miller>
shu: TBF, I didn't see any tests in our WPT tests that referenced FinalizationRegistry.

[09:28:00.0000] <keith_miller>
So my guess is no

[09:28:22.0000] <shu>
there are no WPT tests for weakrefs-related APIs, because WPT doesn't have a notion of gc(), i think

[09:28:31.0000] <shu>
i had asked bocoup to work on it, and they are

[09:28:40.0000] <shu>
there are some chrome-only tests i wrote, but not a lot, so i'm grepping

[09:28:49.0000] <keith_miller>
Oh, gotcha. I guess that makes sense

[09:30:07.0000] <shu>
also what do you want to test with detached iframes

[09:30:11.0000] <shu>
is that behavior specced?

[09:30:26.0000] <keith_miller>
Just that the finalizers from that iframe don't run

[09:30:38.0000] <shu>
ah

[09:30:41.0000] <shu>
https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/web_tests/js/weakrefs/?q=third_party%2Fblink%2Fweb_tests%2Fjs%2Fweakrefs&ss=chromium is what i got

[09:30:45.0000] <keith_miller>
IIUC, that's the spec'd behavior?

[09:30:47.0000] <shu>
mainly around timing of microtasks


2020-08-26
[19:34:17.0000] <shu>
call for incubator call facilitators: https://github.com/tc39/Reflector/issues/319, would love a deeper bench!

[04:32:49.0000] <littledan>
Hey, it's really unfortunate how several Mozilla tech writers working on MDN were laid off. These people wrote most of MDN's content about TC39's output. What should we do to make up for this loss?

[07:32:42.0000] <ljharb>
maybe some of the larger member companies would be willing to hire them

[15:54:55.0000] <mmarchini>
kinda thinking about making a proposal for https://twitter.com/robpalmer2/status/1298733657381908480. Anyone else working on something similar already?

[16:06:50.0000] <Bakkot>
mmarchini closest thing I can think of is the Error.prototype.stack proposal

[16:57:39.0000] <mmarchini>
yeah, that's the closest one I can think of

[16:57:50.0000] <mmarchini>
even though they are not _that_ close


2020-08-27
[19:15:44.0000] <ljharb>
mmarchini: would "cause" interact with stack traces at all?

[19:18:55.0000] <devsnek>
this sounds like an application of AggregateError

[19:19:30.0000] <devsnek>
robpalme: ^

[19:40:18.0000] <mmarchini>
devsnek oh that might be a good idea to explore

[19:42:48.0000] <mmarchini>
ljharb: on how they are displayed maybe (not the content of .stack, but what is printed by the gmail/runtime), I don’t think it will directly affect the stack trace structure

[19:43:51.0000] <ljharb>
mmarchini: what is printed is the stack itself? Or do you mean it’d affect the toString

[19:48:31.0000] <mmarchini>
I wouldn’t expect any of the error properties to be affected, but: 1) the runtime will have the option to print all the error chain when something is uncaught 2) user land will be able to transverse the chain to handle as it sees fit

[19:49:10.0000] <mmarchini>
How is aggregatorerror printed today? What’s the result of .toString on an aggregatorerror?

[20:58:25.0000] <ljharb>
mmarchini: impl-defined, but expectation is that it’s something like a combo of the toStrings of all the errors

[09:16:11.0000] <bradleymeck>
do we have a shared survey service (survey monkey, Google/MS forms, etc) we use to ask questions about proposals? We had the research call today and I realized I didn't know if we did.

[09:39:26.0000] <keith_miller>
ljharb: I believe JSC's stack is the stack where we created the error. Not a combo of the different errors. Is the combo preferred?

[09:44:18.0000] <ljharb>
keith_miller: for the .stack, that's what i'd expect, but for the .toString, i'd expect something creative :-)

[09:44:40.0000] <devsnek>
toString is specified

[09:44:48.0000] <ljharb>
keith_miller: but there's no requirement or anything, it's just that i'd want, when debugging, an aggregate error to show me in my logs some of the info about the .errors

[09:45:01.0000] <devsnek>
it is .stack where you'd have per-engine creativity

[09:45:16.0000] <ljharb>
devsnek: oof, you're right

[09:45:17.0000] <keith_miller>
Oh, I think the console has all the errors in an expandable thing.

[09:45:23.0000] <ljharb>
i forgot we got rid of AggregateError.prototype.toString

[09:45:25.0000] <ljharb>
nvm then

[09:45:47.0000] <devsnek>
we need to support AggregateError in node's inspect

[10:47:04.0000] <drousso>
isn't `stack` customizable?

[10:51:06.0000] <devsnek>
stack isn't part of the spec

[11:12:29.0000] <ljharb>
drousso: it's not customizable by users tho

[11:12:55.0000] <drousso>
it is in Safari

[11:13:04.0000] <drousso>
and it's respected by Web Inspector

[11:13:33.0000] <ljharb>
oof

[11:13:37.0000] <ljharb>
how?

[11:13:50.0000] <ljharb>
i know safari has `.displayName`, which is sad for the stacks proposal (unless yall are willing to remove it)

[11:14:04.0000] <drousso>
wdym "how"?

[11:14:32.0000] <ljharb>
like how do i customize it

[11:14:45.0000] <ljharb>
or do you mean i can just stick any `.stack` string on it

[11:15:10.0000] <drousso>
yes

[11:15:13.0000] <drousso>
it's just a string

[11:15:36.0000] <drousso>
and Web Inspector will parse it to generate a trace UI

[11:15:50.0000] <ljharb>
ah ok

[11:16:05.0000] <ljharb>
that's just an inspector thing then, not something the stacks proposal has to worry about

[12:37:12.0000] <keith_miller>
ljharb: Is there a reason not to respect the .displayName for the stacks proposal?

[12:37:37.0000] <keith_miller>
at least in the inspector?

[12:37:50.0000] <ljharb>
keith_miller: because no other browser does it and it complicates the spec :-)

[12:38:13.0000] <ljharb>
keith_miller: iow, if safari won't remove it then we'll definitely have to figure out how to specify it, but the easiest solution is to remove this thing that's in no other browser

[12:38:21.0000] <ljharb>
(easiest for me, at least :-p )

[12:38:39.0000] <keith_miller>
ljharb: To be fair, I don't think we can remove it. We probably have too many internal clients relying on it

[12:38:55.0000] <ljharb>
keith_miller: things that can't change to setting the `name` instead?

[12:39:01.0000] <ljharb>
i presume displayName predates configurable function names

[12:39:56.0000] <keith_miller>
ljharb: I mean, we *maybe* could get first party apps to fix themselves but I doubt third party apps will do that.

[12:40:12.0000] <keith_miller>
Also does the stacks proposal only look at the .name when .stack is accessed?

[12:40:19.0000] <keith_miller>
If not, that's gonna be a no-go

[12:40:20.0000] <ljharb>
keith_miller: right but third party apps all presumably work on other browsers, no?

[12:40:33.0000] <keith_miller>
not on iOS

[12:40:35.0000] <ljharb>
ah k

[12:40:50.0000] <ljharb>
the entire stack contents are generated at error creation time

[12:40:58.0000] <keith_miller>
oh, yeah, that's not gonna fly

[12:41:02.0000] <ljharb>
um, why not?

[12:41:03.0000] <keith_miller>
that's a huge perf it

[12:41:07.0000] <keith_miller>
hit*

[12:41:17.0000] <ljharb>
you don't actually have to generate them obv

[12:41:38.0000] <keith_miller>
even accessing the .name property would probably be a big perf hit

[12:41:39.0000] <ljharb>
perf hit in a thrown exception case?

[12:41:42.0000] <ljharb>
hm

[12:41:47.0000] <keith_miller>
most exceptions don't look at the stack

[12:41:57.0000] <keith_miller>
especially in things like Speedometer

[12:42:02.0000] <ljharb>
right but i mean, why is there perf sensitivity in error cases

[12:42:26.0000] <devsnek>
there's perf sensitivity in everything

[12:42:28.0000] <keith_miller>
sites throw a *lot* of exceptions

[12:42:52.0000] <ljharb>
what do other browsers do here?

[12:43:07.0000] <keith_miller>
not sure

[12:43:26.0000] <ljharb>
like, if i make an error inside a function, and then change the function's name in a setTimeout to the timestamp, can i figure out roughly when .stack was first accessed?

[12:43:26.0000] <devsnek>
in which case specifically

[12:43:27.0000] <keith_miller>
IIRC, v8 is lazy dunno about SM though

[12:43:45.0000] <ljharb>
v8 has the "prepareStackTrace" thing but iirc there's an open issue to make it eager, per the proposal

[12:44:10.0000] <keith_miller>
ljharb: Yeah, you can tell, I think

[12:44:16.0000] <ljharb>
eesh, ok

[12:44:31.0000] <ljharb>
i *really* wish we'd been able to specify the structure and not the contents as an interim step :-/

[12:44:49.0000] <keith_miller>
ljharb: even worse, I think there are cases where we know you're likely to look at the stack and generate it eager

[12:44:53.0000] <devsnek>
generating the structure would take time too

[12:45:09.0000] <keith_miller>
We also generate it when a function is going to get GCed

[12:45:20.0000] <keith_miller>
So you can tell if a GC happened on your function in the trace

[12:45:30.0000] <devsnek>
O.o

[12:46:25.0000] <ljharb>
devsnek: by specify the structure i mean the format, meaning "how many frames" or "what's in them" would be left implementation-defined for now

[12:46:52.0000] <ljharb>
but 1 or 2 delegates blocked and insisted that any proposal 100% standardize the existing .stack

[12:46:59.0000] <devsnek>
what's the difference between the format and the contents

[12:47:10.0000] <ljharb>
specifying the format means you can reliably parse it

[12:47:23.0000] <keith_miller>
To be fair, IIRC, we only do the GC thing if the .name isn't a getter. So it's not like we are running code.

[12:47:25.0000] <ljharb>
specifying the contents talks about things like the function name, GC'd functions, wording, etc

[12:47:35.0000] <devsnek>
i don't understand how those are different

[12:47:41.0000] <keith_miller>
Although, that doesn't change the observability of it

[12:48:27.0000] <ljharb>
devsnek: the format of a regular expression is in the spec, the contents of regular expressions aren't

[12:48:50.0000] <devsnek>
ya but like

[12:48:52.0000] <devsnek>
if you say

[12:48:52.0000] <ljharb>
devsnek: the format of a JS program is in the spec, the contents aren't, etc

[12:49:04.0000] <devsnek>
do you mean like you would start by saying

[12:49:22.0000] <devsnek>
`at (IdentifierName)` and then later say `at ({function.name})`

[12:49:27.0000] <ljharb>
no

[12:49:57.0000] <ljharb>
the current spec says the format is https://tc39.es/proposal-error-stacks/#sec-getstackstring

[12:50:10.0000] <devsnek>
that looks like contents to me

[12:50:12.0000] <ljharb>
it's not

[12:50:18.0000] <ljharb>
it doesn't care if it's an identifier name or not

[12:50:22.0000] <ljharb>
it just says "at something"

[12:50:35.0000] <ljharb>
the structure is all the slots; the contents is what's in those slots.

[12:50:45.0000] <devsnek>
it says it has to be frame.[[Name]]

[12:50:55.0000] <ljharb>
which can be any string

[12:51:07.0000] <ljharb>
specifying the contents would be saying "it's a function name" or something

[12:51:11.0000] <devsnek>
i see

[12:51:20.0000] <devsnek>
that's not really parsable then lol

[12:51:48.0000] <devsnek>
assuming an adversarial frame.[[Name]] anyway

[12:51:55.0000] <ljharb>
well sure, it's an interim step

[12:52:01.0000] <ljharb>
it means you'd be able to parse "what engines actually do"

[12:52:17.0000] <ljharb>
it just also means an engine would be free to deviate if they were malicious

[12:52:56.0000] <devsnek>
yeah i see what you mean now

[12:58:05.0000] <ryzokuken>
stupid question, but is it okay for any delegate to merge things into tc39/notes?

[12:58:23.0000] <ryzokuken>
I saw a really "nice" PR by rkirsling here: https://github.com/tc39/notes/pull/69

[12:58:42.0000] <ryzokuken>
so I approved it, but didn't know if I should just go ahead and merge.

[12:59:01.0000] <ryzokuken>
(or leave for the chair group to actually do the honors)

[16:23:31.0000] <ljharb>
MylesBorins: https://github.com/tc39/process-document/pull/29#issuecomment-682240037 seems like a github bug, any chance you could help it get to the right person? :-D


2020-08-28
[18:56:51.0000] <MylesBorins>
ljharb I'm OOO for the rest of the week

[18:57:01.0000] <MylesBorins>
if you want to send an email abut it I can try and chase it down monday

[18:57:11.0000] <ljharb>
ok, i'll try to remember to do that :-)

[08:42:01.0000] <mpcsh>
hi friends, I'd like to introduce everyone to shrutikapoor, our new delegate from PayPal! Shruti is a GraphQL, React, and JS developer; a frequent conference speaker and host; and she writes the JSBytes newsletter! you can find her on twitter (twitter.com/shrutikapoor08), and you can subscribe to JSBytes here! (https://tinyletter.com/shrutikapoor)

[09:00:45.0000] <ryzokuken>
o/

[10:45:43.0000] <Bakkot>
hi shrutikapoor! in case you haven't been pointed to it yet, there's public logs for this channel linked in the title (https://freenode.logbot.info/tc39-delegates), if you are inclined to scroll through some history


2020-08-30
[00:18:41.0000] <ljharb>
littledan: leobalter: https://www.irccloud.com/pastebin/mL3Z1VXI/ appears to work in chrome 84 but break in chrome 85. is that expected?

[05:50:32.0000] <littledan>
ljharb: yes

[07:10:47.0000] <ljharb>
can you help me understand why? all the mdn docs imply it’s fine


2020-08-31
[00:09:18.0000] <ryzokuken>
ljharb: didn'

[00:09:22.0000] <ryzokuken>
ugh, sorry

[00:09:32.0000] <ryzokuken>
didn't dateStyle land in Chrome 85?

[00:09:51.0000] <ryzokuken>
in Chrome 84, the dateStyle option was being ignored

[00:10:14.0000] <ryzokuken>
but from Chrome 85 onwards, it is not ignored and conflicts with the rest of your options.

[00:11:24.0000] <ryzokuken>
I'm still not 100% sure of the version it was released in, but this is _why_ it should be failing rn, let me confirm.

[00:26:26.0000] <ryzokuken>
https://tc39.es/proposal-intl-datetime-style/#sec-initializedatetimeformat throws if any of the old options are used alongside dateStyle.

[08:53:21.0000] <ljharb>
ryzokuken: ok thanks, that makes sense; it’s still breaking this user’s site tho

[09:28:44.0000] <ryzokuken>
ljharb: previously, the dateStyle option was being ignored

[10:29:11.0000] <ljharb>
we still don't have a reflector link posted for https://github.com/tc39/agendas/blob/master/2020/09.md - is this one bloomberg?

