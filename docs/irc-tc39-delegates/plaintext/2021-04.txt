2021-04-07
[11:00:14.0000] <Bakkot>
holy crap tc39 is in < 2 weeks

[11:00:27.0000] <Bakkot>
this new schedule is a lot

[11:15:50.0000] <rkirsling>
😱

[12:55:32.0000] <Bakkot>
deadline for advancement eligibility is in like two days and we have about 1 day's worth of content on the agenda so far: https://github.com/tc39/agendas/blob/master/2021/04.md

[12:56:46.0000] <ljharb>
surely more things will roll in on friday, and also there's likely a number of non-advancement things that don't need the deadline

[13:20:59.0000] <gsathya>
oooh class fields going for stage4

[13:21:06.0000] <gsathya>
that will be fun

[13:25:55.0000] <ljharb>
gsathya: any idea how chrome's implementation of `#x in obj` is going? :-D

[13:26:48.0000] <ljharb>
test262 tests still haven't landed, so i wouldn't be surprised if it's not going yet

[13:27:37.0000] <gsathya>
https://chromestatus.com/feature/5006138707804160

[13:27:45.0000] <gsathya>
says shipping in 91

[13:27:57.0000] <ljharb>
score, ty

[13:29:09.0000] <ljharb>
gsathya: which v8 version might that be in? (so i can poke node)

[13:30:06.0000] <gsathya>
9.1

[13:30:57.0000] <ljharb>
awesome thanks


2021-04-09
[09:16:32.0000] <robpalme>
Reminder:  if anyone wants to try out the new Jitsi AV in preparation for plenary, please join us in 15 minutes:  https://github.com/tc39/Reflector/issues/366#issuecomment-816794278


2021-04-11
[13:38:59.0000] <devsnek>
can plenary be added to the tc39 calendar?

[13:56:46.0000] <ljharb>
devsnek: it's already on there

[13:57:05.0000] <ljharb>
it's marked "all day" tho, let me update it to the actual times

[13:57:59.0000] <ljharb>
k, done

[14:00:07.0000] <devsnek>
oh cool it shows up now

[14:00:08.0000] <devsnek>
thx

[14:02:04.0000] <ljharb>
it was surely there before, just as a bar on top of all the days

[14:02:16.0000] <ljharb>
i went ahead and updated all the 2021 meetings so they're appropriate timed and timezoned tho


2021-04-16
[19:56:23.0000] <devsnek>
https://github.com/tc39/proposal-async-iteration should be archived i think

[21:23:15.0000] <ljharb>
devsnek: yeah there's a number of stage 4 repos that need it; as soon as the chairs give me the goahead i'll be auditing all of them


2021-04-18
[12:13:23.0000] <robpalme>
Could I get a one-line review here please https://github.com/tc39/notes/pull/116

[12:24:33.0000] <ljharb>
robpalme: lol i'm trying but it seems like a github bug rn, no JS errors but the "review changes" dropdown won't drop

[12:24:50.0000] <ljharb>
it won't even let me comment

[12:33:55.0000] <ljharb>
k got it

[12:36:26.0000] <robpalme>
i was about to say, i'd love to invoke myles to fix the github website but last i checked he was on vacation ;-)

[12:36:35.0000] <robpalme>
thank you

[12:36:50.0000] <ljharb>
np

[12:36:58.0000] <ljharb>
may have just been my browser, i dunno


2021-04-19
[06:17:47.0000] <robpalme>
good morning/afternoon/evening all

[06:19:27.0000] <robpalme>
The Jitsi video conferencing for today's meeting has a passcode that, for some reason is limited to 10 characters.  You can find this once you use the Entry form on the Reflector post (see IRC Topic).

[06:38:44.0000] <robpalme>
has anyone tried to join the video call yet? I am the only one on.

[06:45:27.0000] <robpalme>
Istvan has joined

[07:09:35.0000] <gibson042>
8x8 isn't letting me in, did we fall back to Teams?

[07:09:45.0000] <robpalme>
no - we are using Jitsi

[07:09:53.0000] <robpalme>
40 people are in the call

[07:10:21.0000] <robpalme>
the password is stated in the entry form

[07:10:33.0000] <gibson042>
it's rejecting the passcode :\

[07:10:46.0000] <robpalme>
trim it to 10 letters

[07:10:51.0000] <robpalme>
chacters

[07:11:04.0000] <robpalme>
(I updated the form to explain this)

[07:11:39.0000] <gibson042>
awesome, thanks!

[07:11:40.0000] <michaelficarra>
#tc39-editors should be on this list

[07:11:58.0000] <shu>
do you mean #tc39-editor-group?

[07:12:02.0000] <michaelficarra>
see?

[07:12:06.0000] <shu>
(i've mistakenly joined tc39-editors on many an occassion)

[07:12:42.0000] <michaelficarra>
I just have it auto-join since this is the only thing I use IRC for

[07:13:55.0000] <ljharb>
irccloud just remembers which channels i'm in ¯\_(ツ)_/¯

[07:16:17.0000] <shu>
it's kicked me out of stuff before due to maintenance net splits, but that's about it i guess

[07:16:57.0000] <robpalme>
Daniel Rosenwasser will be helping us to facilitate this meeting.

[07:23:03.0000] <littledan>
someone extra seems to have their audio on

[07:25:15.0000] <ljharb>
i think i see frank on two different cameras

[07:30:46.0000] <littledan>
the burden of running the VC system falls on the chairs in practice, not the hosts, as the meetings are fully remote

[07:31:55.0000] <littledan>
I definitely think Felienne deserves an award. Maybe we can make a TC39-level award if Ecma refuses to recognize her great work.

[07:33:07.0000] <ljharb>
+1

[07:37:15.0000] <ystartsev>
i feel pretty strongly about anba as well

[07:37:28.0000] <ystartsev>
so, this is very sad

[07:40:23.0000] <ystartsev>
I think that we put forward andre and jordan this timem

[07:40:45.0000] <ljharb>
istvan did mention "2"

[07:47:30.0000] <ystartsev>
yes, i believe this is what the situation was

[07:47:54.0000] <ystartsev>
so this is very unfortunate, but i would be happy to see them both nominated for the first tc39 recognition award

[08:05:34.0000] <akirose>
https://github.com/tc39/ecma402/wiki/Proposal-and-PR-Progress-Tracking

[08:09:14.0000] <littledan>
If anyone has any concerns or questions about Temporal at Stage 3, please ask

[08:10:35.0000] <devsnek>
littledan: what kind of data is needed to implement temporal

[08:11:12.0000] <littledan>
probably mostly the TZDB (if you want it to work well)

[08:11:30.0000] <devsnek>
sounds simple

[08:13:18.0000] <littledan>
I mean, if you're making a JS meta-circular interpreter, you can reverse-engineer the data from Intl

[08:15:02.0000] <devsnek>
if the data can change i prefer to bundle a separate version so it works even in older engines

[08:16:12.0000] <Bakkot>
slides: https://docs.google.com/presentation/d/13s8STWY1zVab3KRK62Q0mhWeKQ2aLKS1wTTKgyJe7iQ/edit#slide=id.g6e7d7a6a09_0_93

[08:16:48.0000] <ystartsev>
https://docs.google.com/presentation/d/13s8STWY1zVab3KRK62Q0mhWeKQ2aLKS1wTTKgyJe7iQ/edit#slide=id.g6e7d7a6a09_0_98

[08:17:22.0000] <ryzokuken>
devsnek: there is a node package with the ICU data btw

[08:18:56.0000] <devsnek>
ryzokuken: do you mean the one that node can dynamically load?

[08:19:18.0000] <ryzokuken>
yes

[08:19:21.0000] <devsnek>
the main issue is not the raw data, it's the processing of it

[08:19:30.0000] <ryzokuken>
there's also a module for that haha

[08:19:35.0000] <devsnek>
o.O

[08:19:58.0000] <leobalter>
devsnek: I miss a thread of something to discuss about Test262 for stage 3 before a meeting

[08:20:58.0000] <ryzokuken>
devsnek: https://www.npmjs.com/package/cldrjs

[08:21:48.0000] <leobalter>
I don't think the way the topic about Test262 is being addressed is ideal. I'd like to make sure it does have space for proper feedback from people historically contributing to the tests

[08:22:34.0000] <devsnek>
leobalter: i figured an ideal place to gather that was here, where everyone gathers in one "room"

[08:23:12.0000] <ystartsev>
sffc: something to follow up on?

[08:23:17.0000] <leobalter>
and for a very quick feedback: In general I'm against Test262 a place for tests before stage 3. It's a matter of convenience for champions vs burden of maintenance.

[08:24:03.0000] <leobalter>
devsnek: the reality is that most Test262 contributors (not limited to me, Rick, or Mike Pennisi) are not attending TC39 meetings

[08:24:24.0000] <ryzokuken>
leobalter: what if they are not added to the test262 repo but maintained in just the proposal repo instead?

[08:24:47.0000] <Bakkot>
yeah we should just say "tests" rather than "test262 tests"

[08:25:18.0000] <devsnek>
one thing i was going to suggest was having an open pr with tests, even if they aren't merged yet

[08:25:31.0000] <devsnek>
just something that implementors can go off of

[08:25:36.0000] <ryzokuken>
I understand the concerns but it's also really useful for implementers to have tests ready I feel

[08:25:39.0000] <ryzokuken>
yeah

[08:25:46.0000] <leobalter>
well, you can have Test262 tests today that are not in Test262's main branch. Saying the tests are good, done, ready becomes way more subjective such as saying tests are available for browsers to import too

[08:26:09.0000] <leobalter>
open prs is not a solution if they are required to be reviewed

[08:26:36.0000] <leobalter>
otherwise one could just open a PR with anything and say there is an open PR

[08:27:21.0000] <devsnek>
yeah there's lots of choices and things to consider

[08:27:32.0000] <devsnek>
so i put a big chunk of time on the schedule

[08:27:34.0000] <leobalter>
there is a lot of problems with tests for stage 2, usefulness for implementers is something else I consider complex, there is a lot of caveats

[08:27:42.0000] <devsnek>
i can make it longer if you want

[08:27:59.0000] <leobalter>
devsnek: full disclosure I don't feel comfortable with that topic

[08:28:30.0000] <leobalter>
because I know a big majority will just throw ideas on how Test262 would be more convenient. This happens all the time

[08:28:50.0000] <leobalter>
the same amount of cheered suggestions is opposed to commitment in maintenance

[08:29:20.0000] <leobalter>
I don't feel comfortable with the discussion being held before an open github thread

[08:29:24.0000] <leobalter>
without a summary

[08:30:04.0000] <littledan>
omg what is the japanese approximate symbol? now I need to know

[08:30:26.0000] <ryzokuken>
littledan: lol I asked the same thing on #temporaldeadzone

[08:30:40.0000] <ryzokuken>
since it's early stage we can't even check...

[08:34:00.0000] <devsnek>
leobalter: you mean on the test262 repo? i'm not sure that matches who the tc39 process document applies to

[08:35:03.0000] <devsnek>
i think from the perspective of maintaining the test262 repo the cost is the same, the tests just get merged sooner, and might actually be written by the people making the proposal because stage 3 is a big carrot

[08:36:09.0000] <leobalter>
I don't feel comfortable discussing this topic within the dynamics of a chat. My request is to have a proper thread. If TC39 delegates can't commit to that, I'm not gonna expose myself for another Test262 burnout

[08:36:15.0000] <leobalter>
so I'm done discussing here. Sorry.

[08:36:46.0000] <littledan>
halfEven sounds weird but it's really important to counter cascading errors in floating point calculations

[08:37:04.0000] <littledan>
for the record, Caio Lima will be championing Decimal going forward :)

[08:42:03.0000] <devsnek>
leobalter: i'm not planning to ask for any consensus at this meeting, i want to ask members of the committee how they feel about these requirements

[08:43:10.0000] <devsnek>
happy to discuss additional feedback after the meeting or in a pm or something, it's just unclear to me what you're asking

[08:44:05.0000] <Bakkot>
what's the algorithm shane refered to?

[08:44:39.0000] <leobalter>
devsnek: I can assure you there is a likely chance people will cheer your suggestion without consideration of the things I pointed out

[08:45:02.0000] <leobalter>
If I don't attend that discussion, there is a likely chance it will become an echo chamber

[08:45:14.0000] <leobalter>
but I can insist: the maintenance burden is awful

[08:45:26.0000] <leobalter>
I'm asking a simple thing:

[08:45:44.0000] <leobalter>
open a thread in Test262

[08:45:53.0000] <leobalter>
this discussion happened several times in the past

[08:46:04.0000] <leobalter>
let people who maintain Test262 to chime in

[08:46:58.0000] <leobalter>
AFAIK, Mike Pennisi is the one doing Test262 for v8+Bocoup. There are other people involved.

[08:47:30.0000] <devsnek>
ok. if members feel like this is something they would feel comfortable with i will open a thread on test262

[08:47:59.0000] <devsnek>
but it is still unclear to me what feedback is being gathered in that thread

[08:49:09.0000] <leobalter>
the feedback is what I'm trying to say so many times

[08:49:15.0000] <leobalter>
burden of maintenance is very high

[08:49:28.0000] <leobalter>
Test262 maintenance already causes burnout

[08:49:41.0000] <leobalter>
your proposal adds a lot of cost on maintenance, a lot

[08:49:50.0000] <leobalter>
so if it's unclear to you

[08:49:53.0000] <devsnek>
so like

[08:50:11.0000] <devsnek>
"do you feel that champions contributing tests earlier would increase maintenance burden"

[08:50:48.0000] <leobalter>
that's what I hate to be doing. I told I don't feel like answering these questions in a chat. I'm trying to attend the meeting

[08:51:07.0000] <leobalter>
I'd appreciate an async discussion

[08:51:19.0000] <leobalter>
but if you really require me to tell you all the dots

[08:51:23.0000] <leobalter>
I hate this btw

[08:51:36.0000] <leobalter>
champions can contribute with tests at ANY MOMENT

[08:51:42.0000] <devsnek>
sorry i just meant is that the question you're wanting to ask, feel free to message me later

[08:51:46.0000] <leobalter>
to test262 as PRs, to stage 3

[08:52:19.0000] <leobalter>
I won't message later in any private capacity

[08:53:20.0000] <leobalter>
well

[08:56:22.0000] <ljharb>
it seems like such a requirement (test262 tests before stage 3) would move the friction of "champions or test262 maintainers writing tests" from "before stage 4" to "before stage 3". wouldn't this be the same burden, just moved earlier in the process? or are you worried that this would result in _more_ proposals needing test262 tests, ones that might not otherwise make it to stage 3 - or that proposals will have larger kinds of

[08:56:23.0000] <ljharb>
change before stage 3, resulting in more test262 churn?

[08:57:18.0000] <leobalter>
I need to jump to another computer. Jitsi's audio stopped working here

[09:00:49.0000] <ystartsev>
we've had tests rejected from test262 because it wasn't at stage 3 if I recall correctly

[09:02:42.0000] <leobalter>
ystartsev: that's correct

[09:03:15.0000] <leobalter>
I can try to illustrate what's the problem, but most people tend to not give a worry about it

[09:03:22.0000] <ljharb>
(which makes sense now, when the requirement is to add them during stage 3. seems obvious that if we changed the requirement test262 would change their criteria)

[09:03:57.0000] <leobalter>
I will be at the breakout session if anyone wants to talk about it.

[09:06:41.0000] <leobalter>
quick reminder: I'm at hubs available if anyone wants to talk about Test262. Apparently I'm the only one there so far.

[09:09:48.0000] <ystartsev>
I have dinner right now

[09:10:59.0000] <sffc>
ystartsev: We have a number of ECMA-402 proposals in the works which may require some scrutiny and feedback from a user privacy perspective.  At the meeting where the security TG was proposed, I asked if we could include privacy in the charter.  Since the TG decided to move forward without including privacy, it just leaves that question unresolved.

[09:11:59.0000] <sffc>
On that front, I would personally be happy if there were a dedicated person or set of people to address privacy questions on TC39 proposals.  It doesn't need to be a full TG.

[09:13:05.0000] <ystartsev>
right, do we have anyone with that competency on committee? we haven't had a volunteer yet so I am guessing we either don't or we don't have someone with the time...

[09:13:46.0000] <ystartsev>
or, we might have someone who wants to grow in that direction and focus on it?

[09:18:10.0000] <sffc>
For Intl Enumeration API, we relied on delegates to outsource the privacy questions.  AFAIK, we don't have anyone who regularly attends TC39 with that expertise.

[09:31:56.0000] <annevk>
I mentioned this to zibi at some point, but talking to W3C PING when you need such expertise is encouraged

[09:32:32.0000] <annevk>
Privacy teams from browsers as well, but hopefully they get looped in regardless when it's appropriate

[09:33:07.0000] <ystartsev>
That sounds like a really good idea

[09:33:38.0000] <ystartsev>
I haven't been much on intl so I don't know all of the discussions there, but I'll try to make sure we have that happening

[09:53:15.0000] <devsnek>
can someone enable https redirects for tc39.es? i think its just a checkbox on the github settings

[10:25:33.0000] <rkirsling>
true, it feels like a standing ovation

[10:28:01.0000] <bnb>
when the staging process was implemented, was there specific logic around the choice of two browsers shipping a feature for stage four?

[10:28:20.0000] <ljharb>
bnb: it's the one requirement that's vague, because there's no consensus on the specifics

[10:28:30.0000] <ystartsev>
devsnek: sure

[10:28:48.0000] <bnb>
I'm wondering specifically if there was assumptions around there being a certain number of browsers who could implement it

[10:28:52.0000] <ljharb>
bnb: the logic was something like "make sure the feature has been exposed to web reality, and to many users/usage, and to different implementations"

[10:28:57.0000] <ljharb>
bnb: so yeah that was part of it

[10:29:02.0000] <ljharb>
bnb: but not every feature requires it

[10:34:18.0000] <rkirsling>
yeah, this feels absurdly unprofessional

[10:35:13.0000] <devsnek>
360 wasn't a member when it hit stage 3. not arguing one way or the other

[10:36:45.0000] <ljharb>
i wasn't a member when the class keyword was chosen to be spelled "class". doesn't mean i could have objected to ES6 on those grounds.

[10:37:20.0000] <ryzokuken>
devsnek: I don't think that's the point though. 360 was certainly a member when the agenda item was added, they could still voice this concern in a better way?

[10:37:49.0000] <ryzokuken>
we have a whole process around timing constraints for example, which they did not use.

[10:45:53.0000] <littledan>
Who is "we"?

[10:46:02.0000] <ljharb>
in this case, huawei

[10:46:06.0000] <littledan>
I see

[10:47:54.0000] <littledan>
I think it's more of a UI thing than an optimization thing--how do you represent which class the private name came from

[10:48:04.0000] <littledan>
I think there was a Chromium issue about this as well

[10:48:09.0000] <ljharb>
tbh i'd prefer that the inspector not show private fields at all

[10:48:13.0000] <ljharb>
but the inspector is utterly out of our scope

[10:48:28.0000] <littledan>
agree that it's out of scope. I think it's useful to show them for debugging, though

[10:49:30.0000] <ljharb>
drousso: excellent example re dom element, ty

[10:49:52.0000] <drousso>
👍

[10:50:00.0000] <drousso>
(shameless plug too cause I added that feature :P)

[10:55:44.0000] <leobalter>
I can tell so much how I agree with BT

[10:56:09.0000] <littledan>
Can we extend the timebox by 30 minutes, given that we don't have anything afterwards?

[10:56:15.0000] <leobalter>
+1

[10:56:59.0000] <michaelficarra>
we can be honest and just say we're moving forward without consensus

[10:57:39.0000] <michaelficarra>
IMO it's fine for the chairs to do that

[10:58:23.0000] <littledan>
the process document specifies what is in scope for blocking Stage 4

[10:58:55.0000] <leobalter>
we are moving forward without objections that meet the requirements BT just mentioned

[10:59:01.0000] <littledan>
exactly

[11:00:40.0000] <leobalter>
ystartsev: nit pick: they've been at tc39 for longer than an year

[11:00:45.0000] <ljharb>
ystartsev: well said

[11:00:48.0000] <rkirsling>
+1, this cannot be stated sharply enough

[11:00:53.0000] <ryzokuken>
+1

[11:00:58.0000] <leobalter>
+1, ofc

[11:07:52.0000] <shu>
akirose: bterlson: my hat off to the chair group for navigating this, chapeau

[11:11:07.0000] <littledan>
=1

[11:11:09.0000] <littledan>
+1

[11:11:12.0000] <ystartsev>
+1

[11:12:28.0000] <littledan>
For reference, TC39's process scopes which kinds of arguments can block Stage 4 consensus in https://tc39.es/process-document/ in the paragraph starting with "Given that consensus on Stage 3 means..."

[11:13:42.0000] <rkirsling>
👏

[11:13:47.0000] <ystartsev>
As a browser implementer, I will say that stage 3 must retain its significance

[11:14:08.0000] <rkirsling>
^

[11:14:17.0000] <ystartsev>
If we need more design space, then it may make sense to add a stage

[11:14:31.0000] <ystartsev>
but there _must_ be a stage for implementers to do their work, and it _must_ be a protected stage

[11:14:35.0000] <ystartsev>
that has been stage 3 historically

[11:14:35.0000] <littledan>
I can do my funding process discussion in 15 minutes, I think

[11:14:46.0000] <littledan>
but, it's lower priority than other agenda items

[11:15:01.0000] <ryzokuken>
akirose: ^

[11:15:23.0000] <akirose>
YESSSSSSS hero

[11:28:42.0000] <Bakkot>
I have to run pick up a family member; will leave the bot running but if it dies I am sorry

[11:47:39.0000] <michaelficarra>
I consider our request for typesetting support a complete failure

[11:47:54.0000] <shu>
yes

[11:48:58.0000] <ljharb>
i'm still really confused

[11:49:02.0000] <ljharb>
did they say no?

[11:49:09.0000] <ljharb>
or did they say "yes but with these absurd constraints"?

[11:49:28.0000] <shu>
my read was they said "here's a one-off approval with these absurd constraints, which requires more work from you"

[11:49:29.0000] <michaelficarra>
the latter

[11:49:50.0000] <shu>
while the whole point was "we'd like to produce a good printed thing for _you_, ecma, since you like to archive, help us help you"

[11:50:08.0000] <ljharb>
right

[11:50:13.0000] <ystartsev>
yikes

[11:50:34.0000] <ljharb>
not sure how we can make it clearer "pdf quality will not improve until you agree to our request verbatim"

[11:55:16.0000] <michaelficarra>
we contacted companies that provide exactly this service we are looking for

[11:55:33.0000] <michaelficarra>
they produce PDF for print layout and epub/mobi for ereader


2021-04-20
[06:46:52.0000] <robpalme>
Jitsi video conferencing is now open.  Meeting starts in 13 mins.

[07:14:57.0000] <wsdferdksl>
Is there a way to get rid of the #&$(*!@#(* buttons that the video conference software displays on top of the slides?

[07:16:06.0000] <rricard>
removing the mouse cursor from the window should do the trick

[07:17:46.0000] <wsdferdksl>
rricard: It doesn't. They're always there. Makes slides unreadable.

[07:18:10.0000] <rricard>
I would try clicking in the window and removing then

[07:19:31.0000] <wsdferdksl>
rricard: Tried that. Clicking in the window doesn't do anything.

[07:19:55.0000] <rricard>
well I don't know, I do use the electron client maybe it has the feature

[07:28:19.0000] <akirose>
wsdferdksl make your window taller

[07:41:11.0000] <michaelficarra>
wsdferdksl: paste this in your console:

[07:41:13.0000] <michaelficarra>
((a) => a.parentNode.removeChild(a))(document.getElementsByClassName('toolbox-content')[0])

[07:55:33.0000] <michaelficarra>
isn't Intl effectively all optional? why do we care that much about data size?

[07:57:07.0000] <Bakkot>
I don't think it's optional for browsers?

[07:57:13.0000] <ystartsev>
its not optional for browsers

[07:58:15.0000] <shu>
michaelficarra: who's "we"? the committee?

[07:58:22.0000] <michaelficarra>
shu: yes

[07:59:05.0000] <devsnek>
i wanted to add `\U{character name instead of codepoint}` but browsers were against it due to size

[07:59:27.0000] <michaelficarra>
ystartsev: Bakkot: The APIs are not optional, but the data set can be effectively empty, right? There should be no conformance issue.

[07:59:48.0000] <Bakkot>
what would be the point of that

[07:59:55.0000] <shu>
yeah conformance is not a goal for products

[07:59:58.0000] <devsnek>
that's what node did for years

[08:00:05.0000] <devsnek>
intl but all the intl apis return garbage

[08:00:52.0000] <shu>
well, that's a little overgeneralization. but conformance is never prioritized over actually providing useful APIs

[08:00:52.0000] <devsnek>
lol https://gc.gy/86635848.png

[08:00:55.0000] <michaelficarra>
because then we are saying, as a standards body, "if you want to provide this functionality, here is how you provide it. If it is too costly, you don't have to provide anything."

[08:01:31.0000] <shu>
michaelficarra: it in no way follows from that size doesn't matter

[08:01:48.0000] <shu>
you still want to make an effort to minimize cost so providing it is more likely

[08:02:25.0000] <Bakkot>
also we should not standardize things which no one is going to ship

[08:02:39.0000] <Bakkot>
or, worse, that they're going to ship in a form which is useless

[08:05:01.0000] <michaelficarra>
on the emoji names example, development time tooling could "support" the API and output a replacement

[08:05:13.0000] <michaelficarra>
I dunno, seems not entirely useless to standardise these things

[08:05:51.0000] <Bakkot>
standardizing a thing which has runtime implications but is only used at build time would be... strange

[08:06:25.0000] <devsnek>
there have been suggestions of having a build-time specification for js

[08:06:30.0000] <devsnek>
not sure how i feel about that but

[08:06:52.0000] <devsnek>
it would enable this sort of thing in one way

[08:08:22.0000] <Bakkot>
I generally feel like there should be implementations before a standard

[08:08:45.0000] <Bakkot>
like if webpack or whatever wants to add build-time stuff and other people want to interop with that, then it would be the appropriate time to standardize

[08:09:17.0000] <Bakkot>
but the implementations are the important part, we can't just summon them from the void by saying "wouldn't it be neat if something existed with these semantics" like happens with browsers

[08:09:46.0000] <devsnek>
yeah i think my perspective on that is that its so local that there would never be a need to standardize. you can always add `devsneks-cool-unicode-names-transform` to your package.json

[08:10:38.0000] <ystartsev>
michaelficarra: sorry my attention was split

[08:10:52.0000] <Bakkot>
sorry is this speaker "MD"? for the notes

[08:11:59.0000] <shu>
current speaker is Markus Scherer

[08:12:01.0000] <michaelficarra>
Bakkot: MWS

[08:12:10.0000] <Bakkot>
thanks

[08:12:32.0000] <michaelficarra>
other speakers in this topic are MB and MED

[08:14:44.0000] <Bakkot>
MED hasn't talked yet, right?

[08:15:29.0000] <michaelficarra>
yeah pretty sure he hasn't talked yet

[08:17:55.0000] <leobalter>
devsnek: https://gist.github.com/leobalter/16364bb167633cb3cb31e0f95e160a2a

[08:18:49.0000] <leobalter>
I had the chance to quickly discuss the topic with Rick. He did not review this gist but I believe I captured my thoughts there.

[08:19:36.0000] <devsnek>
leobalter: thanks for the writeup

[08:20:19.0000] <leobalter>
saying that, I'm sorry the discussion got heated from my side and I got off the rails yesterday. I'd appreciate to be part of the discussion, but that's not an excuse for being aggressive.

[08:24:29.0000] <devsnek>
no hard feelings... i'm grateful for your input

[08:30:13.0000] <leobalter>
devsnek: PTAL again, I included a note about coverage + engine262

[08:30:51.0000] <devsnek>
👍🏻

[08:30:52.0000] <michaelficarra>
this is along the lines of the "nothing can casefold to ASCII" guarantee

[08:31:18.0000] <michaelficarra>
we just have to trust the Unicode consortium to not do stupid things

[08:32:08.0000] <Bakkot>
well, we don't just have to trust, we can ask them to write down that they won't

[08:32:10.0000] <Bakkot>
and then trust

[08:34:14.0000] <msaboff>
Instead of having to trust, why no use syntax to denote the type of a property and with what contructs if can be used?

[08:34:34.0000] <michaelficarra>
msaboff: eh, they both work in practice though

[08:35:31.0000] <michaelficarra>
sounds like Thomas hasn't written a parser

[08:35:43.0000] <Bakkot>
who is thomas

[08:35:46.0000] <Bakkot>
for the notes

[08:35:53.0000] <michaelficarra>
we already need Unicode data for ID_Start, ID_Continue, WSP, etc

[08:36:13.0000] <michaelficarra>
Bakkot: TLY

[08:36:15.0000] <Bakkot>
thanks

[08:36:24.0000] <michaelficarra>
I don't know who they represent

[08:36:33.0000] <shu>
Evernote apparently

[08:36:36.0000] <msaboff>
We require Unicode data for all the Unicode related properties.

[08:36:52.0000] <wsdferdksl>
gibson042: Nested [ [ ] ] ] are allowed in the existing lexical grammar. Follow the productions in 12.8.5

[08:37:43.0000] <devsnek>
may we pray that 12.8.5 never changes ever

[08:52:30.0000] <gibson042>
RegularExpressionFirstChar and RegularExpressionChar don't allow unescaped `[` except as part of RegularExpressionClass `[…]`, which itself cannot contain unescaped `]`

[08:54:36.0000] <gibson042>
so I guess the tokenization doesn't follow the semantic structure, but nonetheless can work

[08:55:21.0000] <gibson042>
subject to the no-unescaped-`/` constraint

[09:03:02.0000] <wsdferdksl>
gibson042: This is exactly the reason why I had added the no-unescaped-/ constraint to the proposal here.

[09:57:51.0000] <robpalme>
we are starting up in 2 mins

[10:03:07.0000] <Bakkot>
can someone take over notes for the next 30 seconds, I want to start a cup of tea

[10:03:19.0000] <Bakkot>
won't be hard, bot likes shu

[10:05:42.0000] <Bakkot>
also someone fill in the last thirty seconds please, my network dropped

[10:20:20.0000] <Bakkot>
who is legendecas, for the notes?

[10:21:36.0000] <Bakkot>
I am having difficulty capturing this comments for the notes

[10:22:22.0000] <robpalme>
CZW

[10:23:55.0000] <rkirsling>
the example in the survey was absolutely lower case

[10:24:14.0000] <rkirsling>
because I wrote in the exact same concern, even though I don't think the quoted words were mine

[10:25:14.0000] <devsnek>
i don't think i saw the survey

[10:37:03.0000] <Bakkot>
a script could also call `Object.defineProperty(globalThis, 'GrowableSharedArrayBuffer', { value: globalThis.GrowableSharedArrayBuffer, writeable: false, configurable: false })` at the beginning of the script

[10:37:09.0000] <Bakkot>
so I am hopeful moddable can resolve this that way

[10:38:06.0000] <Bakkot>
(not saying that it needs to happen in the next thirty seconds)

[10:38:13.0000] <michaelficarra>
I just don't think it would be especially burdensome for Moddable to resolve this

[10:38:31.0000] <Bakkot>
likely not but it seems reasonable to say that they should get an opportunity to explore that

[10:40:36.0000] <michaelficarra>
sure, or at least to quantify that burden so we can better evaluate it as a committee

[10:42:06.0000] <Bakkot>
right

[10:42:51.0000] <msaboff>
I think Moddable's concern is not just this feature, but the precedent.

[10:43:19.0000] <Bakkot>
right, but if it turns out the precedent isn't actually a problem, that is ideal

[10:54:01.0000] <ystartsev>
For the record -- I didn't say this, but I support the proposal and appreciate all the work you did here to address mozilla's concerns shu

[10:54:09.0000] <Bakkot>
I would really prefer not to wake up at 6:30am if it's avoidable

[10:54:28.0000] <shu>
where was the concern with AggregateError?

[10:55:00.0000] <ystartsev>
I hope we have more time for that

[10:56:39.0000] <michaelficarra>
ugh I wish we were calling these immutable arrays and not tuples

[10:59:41.0000] <bradleymeck>
i have to go for a bit, just want to be sure I get to say I like this proposal but have concerns about conversation about the names using past forms of verbs (e.g. "I pushed 1 onto the array" .push()? or .pushed()?)

[11:00:44.0000] <ljharb>
shu: overlooked, really. i'd have brought it up then if it had occurred to me

[11:01:35.0000] <shu>
ljharb: and Realms/Compartments/whatever?

[11:01:59.0000] <ljharb>
shu: if there's a natural place to nest those, i think we should

[11:04:51.0000] <shu>
ljharb: and to clarify, your position here is purely organizational, right?

[11:05:09.0000] <ljharb>
shu: yes

[11:05:26.0000] <ljharb>
shu: it's a bit easier to polyfill etc this way also, but that's a lesser concern since it's already a thing

[11:05:42.0000] <shu>
ljharb: is it? wouldn't it be harder?

[11:05:58.0000] <shu>
what if e.g. SharedArrayBuffer didn't exist? (SABs aren't polyfillable but suppose they were)

[11:06:12.0000] <ljharb>
then i'd be able to stick it on ArrayBuffer

[11:06:22.0000] <ljharb>
as opposed to having to make a new global, which might conflict with any existing global, etc

[11:06:27.0000] <shu>
right, but what if you also needed to make the new global?

[11:06:33.0000] <ljharb>
then i'm no worse off

[11:06:39.0000] <ljharb>
(than with SAB)

[11:06:48.0000] <Bakkot>
is this rgn talking?

[11:06:49.0000] <ljharb>
i agree it's a minimal difference ofc, which is why it's very secondary to "organizational"

[11:07:02.0000] <ljharb>
Bakkot: it's rick button

[11:07:06.0000] <ljharb>
Bakkot: not sure the acronym

[11:07:10.0000] <rricard>
rbu

[11:07:10.0000] <Bakkot>
sorry, thanks

[11:07:17.0000] <shu>
ljharb: i was thinking it's worse off than existing because for 2 different globals, their polyfills would compose naturally and just work

[11:07:21.0000] <shu>
ljharb: but if they're nested, there's more coordination

[11:09:23.0000] <Bakkot>
i have to stop notes

[11:09:30.0000] <Bakkot>
poo ^

[11:09:33.0000] <ljharb>
shu: i think it's the same that way

[11:11:07.0000] <shu>
ljharb: okay, i think high order bit for me is i do not want to spend any more time on this

[11:11:55.0000] <Bakkot>
same as yesterday I gotta got AFK the rest of the meeting but will leave the bot running, sorry if it dies

[11:14:02.0000] <shu>
ljharb: i think i'll withdraw my opinion and just ask for Stage 3 with namespaced -- barring possible objections from the other side, of course

[11:14:48.0000] <ljharb>
shu: i think moddable's claim is stronger than mine; if not for that i'd be willing to go with globals. just ftr.

[11:15:12.0000] <shu>
understood

[11:15:36.0000] <rkirsling>
anybody hearing an intermittent pop on the audio?

[11:16:05.0000] <shu>
when nobody was speaking earlier i was hearing a weird warble, but it's fine when someone is speaking

[11:16:24.0000] <michaelficarra>
is this just proposing to shorten {}.hasOwnProperty.call to Object.has?

[11:16:33.0000] <shu>
michaelficarra: yeah, afaict

[11:16:51.0000] <ljharb>
yes

[11:16:54.0000] <shu>
michaelficarra: it's useful for null-proto things

[11:16:58.0000] <michaelficarra>
are we going to do Object.toString next?

[11:17:11.0000] <ljharb>
if Symbol.toStringTag hadn't made it useless, i'd say maybe :-p

[11:17:14.0000] <michaelficarra>
shu: it's not, both of those work on null-proto things

[11:17:35.0000] <devsnek>
can we get stage 2 on this

[11:17:41.0000] <devsnek>
it has spec text

[11:17:47.0000] <shu>
michaelficarra: you don't think it's useful to be able to type Object.has vs `{}.hasOwnProperty.call`?

[11:17:55.0000] <shu>
especially with understanding `call` semantics?

[11:18:08.0000] <michaelficarra>
shu: not really? they're almost identical

[11:18:20.0000] <ljharb>
also `Object.prototype.hasOwnProperty.call` versus `{}.hasOwnProperty.call` is a thing

[11:18:28.0000] <jridgewell>
I've found beginners are not comfortable (or don't know how) to do `Object.prototype.hasOwnProperty.call`

[11:18:30.0000] <ljharb>
this would provide one nice, short, static method

[11:18:38.0000] <shu>
i'm pretty positive on this despite its being an alias, yeh

[11:18:39.0000] <shu>
yeah*

[11:18:43.0000] <michaelficarra>
also, hasOwnProperty says "own" in the name, whereas I would assume Object.has had "in" semantics

[11:18:54.0000] <devsnek>
maybe we can name it hasOwn

[11:18:56.0000] <shu>
yes, i think i would prefer hasOwn vs has

[11:19:18.0000] <rbuckton>
```

[11:19:18.0000] <rbuckton>
const uncurryThis = Function.prototype.bind.bind(Function.prototype.call);

[11:19:18.0000] <rbuckton>
const hasOwn = uncurryThis(Object.prototype.hasOwnProperty);

[11:19:18.0000] <rbuckton>
hasOwn({ a: 1 }, "a"); // true

[11:19:18.0000] <rbuckton>
```

[11:19:23.0000] <ljharb>
either has or hasOwn works fine for me

[11:19:44.0000] <ljharb>
rbuckton: `Function.bind.call(Object.prototype.hasOwnProperty)` is a bit shorter :-p

[11:19:46.0000] <ystartsev>
+1 to the general discussion -- one thing we were also discussing was the proxy has trap, and reflector.hass

[11:19:51.0000] <ljharb>
rbuckton: but yes, that's exactly what the `has` package does

[11:19:59.0000] <ystartsev>
as potentially confusing bits

[11:19:59.0000] <rbuckton>
Yeah, but I use `uncurryThis` quite a bit :)

[11:20:26.0000] <ljharb>
rbuckton: https://npmjs.com/call-bind is what all my packages use for that

[11:20:47.0000] <robpalme>
we will need to educate people on Object.has vs Reflect.has

[11:20:58.0000] <ljharb>
robpalme: you're assuming anyone knows about Reflect.has

[11:21:06.0000] <michaelficarra>
does Reflect.has have `in` semantics?

[11:21:10.0000] <ystartsev>
yes

[11:21:11.0000] <rbuckton>
I think `hasOwn` is my preference, for the same reasoning as ystartsev. `Object.getOwnPropertyDescriptor -> Reflect.getOwnPropertyDescriptor` so `Object.has -> Reflect.has`. Going with `hasOwn` is less confusing.

[11:21:24.0000] <devsnek>
meanwhile in node https://gc.gy/86647883.png

[11:21:45.0000] <robpalme>
I agree with @rbuckton, but it's a mild feeling

[11:22:08.0000] <michaelficarra>
devsnek: basically the first few lines of every JS program I write

[11:22:21.0000] <devsnek>
currying > use strict

[11:22:57.0000] <rbuckton>
`Object.(keys|values|entries)` returns arrays while `(Map|Set).(keys|values|entries)` returns an iterator, so its not a 1:1 comparison.

[11:26:46.0000] <michaelficarra>
jridgewell: FWIW I pull things off Object.prototype with {}, Array.prototype with [], and Function.prototype with Date

[11:27:14.0000] <rbuckton>
"and Function.prototype with Date"... wat?

[11:27:28.0000] <devsnek>
can we ask for stage 4

[11:27:29.0000] <michaelficarra>
don't judge

[11:27:32.0000] <rbuckton>
lol

[11:27:39.0000] <ljharb>
lol

[11:27:55.0000] <devsnek>
date is always available, unlike `function() {}`

[11:28:22.0000] <rbuckton>
You can always pull `hasOwnProperty` off of `Object`, though it will do a prototype walk to get to it :)

[11:28:29.0000] <rbuckton>
`Object.hasOwnProperty.call(obj, key)`

[11:28:51.0000] <ljharb>
that's why we can't name this `Object.hasOwnProperty` :-p

[11:29:05.0000] <shu>
Object.hasOwnProperty2

[11:29:13.0000] <ljharb>
ship it

[11:29:15.0000] <ystartsev>
+1

[11:29:42.0000] <rbuckton>
Very true. Not sure I have a major preference of `has` vs `hasOwn`, but still prefer `hasOwn`.

[11:30:05.0000] <ystartsev>
if hasOwn isn't a web compat risk, i think it is a good choie

[11:30:23.0000] <shu>
i think the analogy with collections is very weak

[11:30:28.0000] <ljharb>
problem: "i need an ergonomic way to check if an object has an own property"

[11:30:29.0000] <shu>
ownness doesn't matter for collections

[11:30:32.0000] <rbuckton>
shu: +1

[11:31:03.0000] <TabAtkins>
I'm just super in favor of anything that moves these awkward Object.prototype things to less awkward locations.

[11:31:16.0000] <ljharb>
same

[11:31:16.0000] <ystartsev>
+1 to the point about the problem statement that michaelficarra just brought up

[11:32:09.0000] <rbuckton>
qq: Earlier it was mentioned that built-in modules essentially died on the vine. Was the proposal officially withdrawn, or is it just stale?

[11:32:58.0000] <bradleymeck>
rbuckton: indefinitely stalled / push back against both reserving specifiers from web and using new syntax from various

[11:33:20.0000] <bradleymeck>
likely could move somewhat if we could resolve either of those

[11:33:33.0000] <bradleymeck>
but last I heard about this was from msaboff

[11:34:04.0000] <msaboff>
Stale

[11:34:04.0000] <shu>
there's a more fundamental disagreement for built-in modules: it bifurcates the ecosystem

[11:34:41.0000] <rbuckton>
I still kind of wish we had the ability to do something like `import { Object } from <builtins>` or `import { ResizableArrayBuffer } from <collections>` from both the _Script_ and _Module_ goals.

[11:34:47.0000] <devsnek>
pattern matching woooo

[11:35:09.0000] <msaboff>
rbuckton Me too.

[11:35:18.0000] <ryzokuken>
terminator is championing this proposal

[11:35:19.0000] <devsnek>
`echo "export const Object = globalThis.object" > './<builtins>'`

[11:36:11.0000] <bradleymeck>
why don't we propose static `import` from Script like Allen said a few years ago, just ban `async` flagged graphs like service workers do

[11:36:42.0000] <ystartsev>
bradleymeck: we had some discussion about that

[11:36:42.0000] <devsnek>
i'm strongly against anything that disables async graphs

[11:36:49.0000] <rbuckton>
That's different when not in a frozen realm where someone can do `Object  = function () {}`, or as a way to avoid the concerns Moddable had about introducing new globals.

[11:36:52.0000] <devsnek>
service workers are bad enough

[11:40:00.0000] <bradleymeck>
rbuckton: node goes *REALLY* far to deal w/ doing essentially that with our `primordials`

[11:40:18.0000] <bradleymeck>
like the uncurryThis snippet devsnek pasted

[11:41:48.0000] <michaelficarra>
I smell a new protocol for matching :-)

[11:42:34.0000] <devsnek>
michaelficarra: where the first class protocols at

[11:42:34.0000] <ljharb>
michaelficarra: good nose

[11:43:12.0000] <rkirsling>
the phrase "avoiding footguns" was literally used, what

[11:43:20.0000] <rbuckton>
`Function.prototype.uncurryThis`

[11:43:24.0000] <ljharb>
i think wsdferdksl1 is reading ahead

[11:43:47.0000] <michaelficarra>
devsnek: :'( I need to spend time on it

[11:43:53.0000] <bradleymeck>
rbuckton that is infuriating

[11:44:13.0000] <littledan>
The presentation of goals here was excellent

[11:44:16.0000] <bradleymeck>
you would have to bind uncurryThis to uncurryThis

[11:44:19.0000] <devsnek>
i dislike this syntax

[11:44:24.0000] <devsnek>
but i like pattern matching

[11:44:24.0000] <rbuckton>
bradleymeck: can't tell if joking or serious? I'm joking, tbh.

[11:45:09.0000] <bradleymeck>
/me cries

[11:45:18.0000] <bradleymeck>
i do want uncurryThis tho

[11:45:29.0000] <bradleymeck>
TS does not like that fn

[11:45:35.0000] <bradleymeck>
just to get support for it

[11:45:56.0000] <rbuckton>
bradleymeck: `const uncurryThis: <T, A extends any[], R>(f: (this: T, ...args: A) => R) => (this_: T, ...args: A) => R = Function.prototype.bind.bind(Function.prototype.call);`

[11:46:09.0000] <rbuckton>
Doesn't work with overloaded signatures though.

[11:47:02.0000] <devsnek>
having to type `when (...)` makes me angry

[11:47:08.0000] <bradleymeck>
why?

[11:47:10.0000] <devsnek>
just let me type the `...`

[11:47:16.0000] <rbuckton>
bradleymeck: `Function.prototype.uncurryThis` would have been something like `const hasOwn = Object.prototype.hasOwn.uncurryThis()`, the alternative would be `const hasOwn = Function.uncurryThis(Object.prototype.hasOwnProperty)`

[11:47:28.0000] <ljharb>
devsnek: it's needed, keep watching

[11:47:51.0000] <devsnek>
ljharb: did smth change since our last convo

[11:47:58.0000] <ljharb>
devsnek: probably

[11:48:03.0000] <ljharb>
devsnek: the last month's been busy

[11:48:11.0000] <bradleymeck>
rbuckton we do a different signature that does a little better https://github.com/nodejs/node/blob/master/typings/primordials.d.ts#L1 , but yea it is still pretty unhappy usually

[11:48:21.0000] <devsnek>
i think we should ensure that the common case doesn't have extra syntax

[11:48:55.0000] <bradleymeck>
rbuckton: yea, that would let us more sanely do some stuff w/o deopts is the hope

[11:48:57.0000] <ljharb>
devsnek: that's certainly a goal

[11:49:54.0000] <rbuckton>
bradleymeck: Improving support for handling function signatures in type-space is something I'm experimenting with.

[11:51:52.0000] <rbuckton>
Do patterns allow arbitrary expressions, like `when (["go", fn()]) { ... }`? The `as` clause will be tricky for TypeScript, since we use that in expression positions to do type assertions

[11:52:02.0000] <ljharb>
rbuckton: wait a slide or two

[11:52:15.0000] <ljharb>
rbuckton: p sure it should be fine with TS

[11:52:29.0000] <devsnek>
worst case you can release typescript 3

[11:52:38.0000] <ljharb>
4?

[11:52:38.0000] <rbuckton>
We're on TS 4 already :)

[11:52:46.0000] <devsnek>
oh

[11:52:48.0000] <devsnek>
typescript 5 then

[11:53:02.0000] <michaelficarra>
regexps don't need a special case if the returned value from the protocol describes the introduced bindings

[11:53:16.0000] <ljharb>
michaelficarra: true

[11:53:19.0000] <devsnek>
michaelficarra: i don't think engines would like that

[11:53:22.0000] <bradleymeck>
no dynamic scope bindings

[11:53:22.0000] <ljharb>
michaelficarra: but in that case, the returned value would be the match object

[11:53:32.0000] <ljharb>
this isn't dynamic, the capture group names are static

[11:53:33.0000] <rbuckton>
And we've already changed our assertion syntax once. `<X>a` originally (and still), but `a as X` as well (since the `<X>a` syntax conflicted with JSX).

[11:53:41.0000] <devsnek>
ljharb: the return value is dynamic

[11:53:42.0000] <ljharb>
michaelficarra: which means you'd have to do `as { groups: { a, b } }` to get the bindings

[11:53:43.0000] <TabAtkins>
Yeah we're pretty explicitly agaisnt the user-defined stuff implicitly introducing bindings. Bindings need to be visible from source.

[11:53:50.0000] <ljharb>
devsnek: right but the literal pattern form is special, not a regex object

[11:54:05.0000] <devsnek>
agree with tab here

[11:54:11.0000] <ljharb>
rbuckton: so for this concern, it'd be `^(x as y)` and should work fine

[11:54:26.0000] <ljharb>
devsnek: with a regex object, bindings *only ever* come from an explicit `as`

[11:54:44.0000] <devsnek>
hm

[11:55:00.0000] <devsnek>
i thought they came from the group names

[11:55:12.0000] <ljharb>
devsnek: only in the literal pattern form

[11:55:23.0000] <ljharb>
in no way would we try to introduce magic implicit bindings :-)

[11:55:33.0000] <devsnek>
oh i see what you're saying

[11:55:35.0000] <rbuckton>
Also concerned about `^`, since I'm still a fan of `^x` creating an index object that can be used in arrays (which I believe was presented last meeting).

[11:55:36.0000] <ljharb>
it's an open question tho, we don't have to have that sugar for the literal pattern form.

[11:55:37.0000] <devsnek>
makes more sense now

[11:55:47.0000] <devsnek>
we should 100% have that sugar

[11:55:48.0000] <ljharb>
rbuckton: happy to bikeshed that operator

[11:55:51.0000] <michaelficarra>
this presentation is very nice :-)

[11:55:53.0000] <ljharb>
devsnek: 👍

[11:56:01.0000] <rkirsling>
michaelficarra: 🎉

[11:56:02.0000] <devsnek>
still against when() though

[11:56:03.0000] <rbuckton>
But it seems to be unique enough, though if both existed you might have a `when ^^1` :)

[11:56:19.0000] <ljharb>
rbuckton: lol true, it wouldn't conflict except conceptually. altho you'd need `^(^1)`

[11:56:37.0000] <ljharb>
rbuckton: `^` is only allowed with an identifier, or a parenthesized expression

[11:56:44.0000] <rbuckton>
I see.

[11:57:29.0000] <rkirsling>
good clarification

[11:57:42.0000] <devsnek>
ljharb: i didn't see anything saying why when has to exist

[11:57:58.0000] <devsnek>
maybe i'm horrible at listening

[11:58:17.0000] <ljharb>
devsnek: hm, i guess i was thinking the `if` and `else` headers. but since we came up with `^` i guess we could go straight into the pattern

[11:58:23.0000] <ljharb>
devsnek: it does seem nice to me to have a syntactic marker tho

[11:58:40.0000] <devsnek>
i'll put a topic

[11:58:41.0000] <ljharb>
devsnek: without that, we'd have to require `;` between clauses, or have ASI kick in

[11:58:42.0000] <rbuckton>
ljharb: In general I like this proposal. I've been thinking more about Rust-style ADT enums (I still have that `enum` proposal I may eventually bring to committee), and how that could work with pattern matching.

[11:58:59.0000] <devsnek>
multiple clauses on the same line should never exist

[11:59:16.0000] <michaelficarra>
rbuckton: I really hope that enum proposal is nothing like TypeScript enums anymore

[12:00:33.0000] <TabAtkins>
I really really hate the idea of relying on array holes to avoid the need for a nil matcher. :(

[12:00:35.0000] <michaelficarra>
I think the catch integration should be a follow-on proposal

[12:00:38.0000] <rbuckton>
michaelficarra: Anything I put together will need to support a number of scenarios, including the ones in TS. Even if the default behavior is creating symbol-valued properties for JS, I still want to be able to create number-valued properties.

[12:00:38.0000] <rkirsling>
5 minutes oof

[12:01:06.0000] <ljharb>
michaelficarra: yes, definitely

[12:01:32.0000] <devsnek>
why does logical or use `|` in patterns

[12:01:48.0000] <devsnek>
could it not just be ||

[12:01:52.0000] <rkirsling>
I do agree that ^ is the least intuitive part but I haven't thought of a better alternative

[12:02:43.0000] <michaelficarra>
the concept of pinning is pretty crucial for this proposal though so we'll need to figure out something

[12:02:48.0000] <rkirsling>
devsnek: that's the norm in other languages; it's only a "logical" OR if you analogize with an existing conditional, but here it's really a "separator for alternatively"

[12:02:53.0000] <devsnek>
i wish rust had pinning

[12:02:53.0000] <rkirsling>
*alternatives

[12:02:54.0000] <akirose>
i accidentally deleted the next person on the queue

[12:03:09.0000] <TabAtkins>
devsnek: No particular reason

[12:03:13.0000] <rkirsling>
(for that reason, I'd probably prefer that we not say "logical" OR)

[12:03:31.0000] <devsnek>
🤷🏻

[12:03:33.0000] <ljharb>
brad4d: no, absolutely not

[12:03:47.0000] <ljharb>
brad4d: if you want the brittle instanceof you have to type that yourself, or add the protocol to your class to provide it

[12:04:15.0000] <rkirsling>
words aside, `||` would be problematic precisely because the disjuncts *aren't* boolean

[12:04:41.0000] <michaelficarra>
oh the strictness with object matching seems to motivate a rest form without a binding

[12:04:50.0000] <rbuckton>
My earliest version of the `enum` proposal actually introduced a new value type that had both a name and a value (similar to C# enums), so that they are essentially unique:

[12:04:50.0000] <rbuckton>
```

[12:04:50.0000] <rbuckton>
enum Color { Red };

[12:04:50.0000] <rbuckton>
enum Animal { Dog };

[12:04:50.0000] <rbuckton>
Color.Red === Animal.Dog; // false

[12:04:50.0000] <rbuckton>
Number(Color.Red) === Number(Color.Dog); // true

[12:04:51.0000] <rbuckton>
Number(Color.Red); // 0

[12:04:51.0000] <rbuckton>
String(Color.Red); // "Red"

[12:04:51.0000] <rbuckton>
typeof Color.Red; // "enum"

[12:04:52.0000] <rbuckton>
```

[12:04:53.0000] <rbuckton>
However I was concerned introducing a new value type and typeof tag would be too difficult to advance.

[12:05:05.0000] <devsnek>
how about "or" as a keyword

[12:05:26.0000] <rkirsling>
sure, that'd be an option

[12:08:43.0000] <TabAtkins>
michaelficarra: What do you mean?

[12:14:55.0000] <brad4d>
ljharb: I asked because one of the example seemed to imply that `AggregateError` would have such a static property.

[12:15:19.0000] <rbuckton>
ljharb: `as` may be fine in that context (though possibly confusing for TS users), but I'm curious if you've considered anything like https://www.python.org/dev/peps/pep-0572/ (using the `:=` operator to introduce a binding). Granted, Python introduced `:=` because of how variables work in that language, so its not a direct comparison.

[12:16:19.0000] <rkirsling>
rbuckton: I think that's directionally problematic

[12:16:42.0000] <rbuckton>
"directionally problematic"?

[12:17:08.0000] <rkirsling>
it's an afterthought, like "and we need to be able to refer to it as"

[12:17:58.0000] <rbuckton>
Not if you reclassify it the statement to "and we need to be able to restrict it to"

[12:19:40.0000] <rbuckton>
```

[12:19:40.0000] <rbuckton>
// start with

[12:19:40.0000] <rbuckton>
when (["go", dir]) { ... } // dir in scope

[12:19:40.0000] <rbuckton>
// add restriction

[12:19:40.0000] <rbuckton>
when (["go", dir := ("N" | "S" | "E" | "W")]) { ... } // dir in scope

[12:19:41.0000] <rbuckton>
// alternative, use a keyword like 'is'

[12:19:42.0000] <rbuckton>
when (["go", dir is ("N" | "S" | "E" | "W")]) { ...  } // dir in scope

[12:19:42.0000] <rbuckton>
```

[12:21:54.0000] <rbuckton>
My concerns about `as` may be unfounded, I'll have to check the repo after the changes ljharb have mentioned are merged to reflect the current state.

[12:24:08.0000] <rbuckton>
I'm a little concerned about `match (x)` though, since you either need an NLT between `)` and `{`, or a massive cover grammar, and that pushes people towards a specific style (brace on same-line vs brace on next line). That's why I'd switched `using (x) {` to match Java's `try using (x) {`.

[12:24:15.0000] <rkirsling>
yeah, I feel like putting the binding name first makes it look like an unconditional pattern match, since the "restriction" there is just a normal pattern match and not a guard

[12:24:25.0000] <ljharb>
rbuckton: we'd use an NLT. nobody uses allman

[12:25:05.0000] <rbuckton>
I seem to recall that being a concern for `using (x) {}` a few years back.

[12:31:32.0000] <rbuckton>
If pattern matching moves forward with `match ( Expression ) [no LineTerminator here] MatchBlock`, maybe I'll switch `using` back. For `using`, there were always two cases I wanted to support. One that introduced bindings, and one that didnt.

[12:31:32.0000] <rbuckton>
I've been thinking of dropping `try using` in favor of `using const x = ...`, but haven't been happy with `using value Expression`, so maybe I just do `using const x = ...` (block scoped binding) and `using ( Expression ) [NLT] { ... }` (block-lifetime for expression).

[12:35:29.0000] <ljharb>
rbuckton: `as` is consistent with named imports/exports tho

[12:39:47.0000] <rbuckton>
But inconsistent with destructuring. I can understand `as` in imports though, since the bindings are "live", but we could have just done `import { x: y } from "foo"`. I've seen that some of the CommonJS ecosystem does `const { x: y } = require("foo")` when not using a module transpiler. Is the binding in a match "live" as well, or is it just a copy of the matched value?

[12:40:22.0000] <rbuckton>
Oh, ljharb: Any chance `browserify/resolve` will get support for NodeJS export maps? I was just moving a project over to using them but ran into Jest not supporting them because they're waiting on `resolve`. Currently I'm trying to implement my own custom resolver for Jest to work around the issue.

[12:46:38.0000] <Bakkot>
ugh I am not enthusiastic about the idea of a new cover grammar

[12:57:33.0000] <ljharb>
akirose: bnb: robpalme we forgot to get reviewers for Object.hasOwn, can we do that first thing tomorrow? i'll volunteer to be one of them

[12:57:49.0000] <ljharb>
rbuckton: tbh i think the real thing that sucks is that object destructuring used `:` instead of `as`

[12:58:00.0000] <ljharb>
rbuckton: it's not live, just like destructuring isn't

[12:58:41.0000] <ljharb>
rbuckton: as for `using` i'm personally fine with an NLT; if we decide we can't do that, then all new keywords are off limits, and the only people hurt by it are using a brace style that causes bugs in JS and that all style guides and common linters discourage

[13:01:11.0000] <rbuckton>
Bad idea: introduce a trailing `\` for anyone who *really* wants braces on a new line:

[13:01:11.0000] <rbuckton>
```

[13:01:11.0000] <rbuckton>
match (x)\

[13:01:11.0000] <rbuckton>
{

[13:01:11.0000] <rbuckton>
}

[13:01:11.0000] <rbuckton>
```

[13:01:41.0000] <TabAtkins>
yeah if object destructing used `as` it would make me much happier in match()

[13:09:57.0000] <ljharb>
rbuckton: i thought shitposts were supposed to go in tdz :-p

[13:10:10.0000] <rbuckton>
Not a shitpost, just a bad idea.

[13:10:59.0000] <ljharb>
:-p

[13:11:12.0000] <ljharb>
if they didn't need that for `return \` then they don't need it ¯\_(ツ)_/¯

[13:11:18.0000] <rbuckton>
I mean, this works:

[13:11:18.0000] <rbuckton>
```

[13:11:18.0000] <rbuckton>
let x = "a\

[13:11:18.0000] <rbuckton>
b";

[13:11:18.0000] <rbuckton>
x; // "ab"

[13:11:19.0000] <rbuckton>
x.length; // 2

[13:11:19.0000] <rbuckton>
```

[13:29:50.0000] <michaelficarra>
TabAtkins: it sounds like the object matching makes an exhaustiveness assertion which you can disable by adding a rest binding

[13:30:01.0000] <michaelficarra>
but if you don't want that, I imagine you would just add a `...`?

[13:30:03.0000] <TabAtkins>
No, object matching is explicitly non-exhaustive

[13:30:09.0000] <TabAtkins>
array matching is exhaustive

[13:30:18.0000] <michaelficarra>
oh, I misunderstood that part of the presentation then

[13:30:19.0000] <michaelficarra>
okay

[13:30:33.0000] <TabAtkins>
(exhaustive object matching would be unusable from the get-go, as you'd need to include, at minimum, all the Object.prototype properties in every pattern)

[13:30:53.0000] <michaelficarra>
or just put a … to switch the behaviour

[13:31:13.0000] <TabAtkins>
What I mean is that you'd need to put that in *every* pattern, because you'd *never* want an exhaustive match.

[13:31:25.0000] <michaelficarra>
fair

[13:56:39.0000] <mpcsh>
late to all this but yeah I think I could be swayed to have arrays be non-exhaustive for consistency's sake, but objects definitely have to be non-exhaustive

[13:56:51.0000] <mpcsh>
although I do definitely think the most intuitive version is arrays are exhaustive, objects are not

[13:57:16.0000] <mpcsh>
it's inconsistent, yes, but it best models what folks will try to do. being able to express "an array of exactly this length and give me these bindings" is very powerful

[13:59:33.0000] <ljharb>
array and object destructuring are already similarly inconsistent around trying to destructure nullish values

[13:59:43.0000] <ljharb>
and they both make perfect sense in isolation

[14:10:32.0000] <TabAtkins>
I *really* don't think we can make arrays non-exhaustive. It would clash with author's expectations *so hard*

[14:27:46.0000] <mpcsh>
I don't know if I agree that it's such a hard clash - `const [a, b] = [1, 2, 3, 4]` works. I think the better argument is the expressiveness that non-exhaustive matching enables

[14:29:06.0000] <ljharb>
i could go either way on it

[14:29:44.0000] <ljharb>
if it's non-exhaustive, you *can* do `[…rest] & { length: 2 } & [a, b]` but i don't think you can go the other way as easily?

[14:35:51.0000] <mpcsh>
eugh, that's pretty gross

[14:35:55.0000] <mpcsh>
and requires `&` at the outset

[14:36:58.0000] <rbuckton>
Could reuse tuple syntax for exhaustive arrays, since tuples have a fixed length? Unless you wanted to reserve `#[]` to explicitly match *only* tuples.

[14:37:07.0000] <rbuckton>
`when (#[a, b]) { ... }`

[14:38:13.0000] <rbuckton>
though that's only a few characters shorter than `when([a, b, ...]) { ... }`, so ¯\_(ツ)_/¯

[14:38:39.0000] <mpcsh>
we'd probably want `#[]` to only match tuples, yeah

[14:39:23.0000] <rbuckton>
Would `[]` only match arrays then? I'd want to be able to match either...

[14:42:47.0000] <mpcsh>
hm, I think that's probably a question for the record & tuple folks. my intuition would be they're both exclusive and if you want both you can do `[a, b] | #[a, b]`, or write a custom class with the match protocol method we presented

[14:44:34.0000] <ljharb>
mpcsh: indeed, it is gross. but it's at least possible.

[14:44:52.0000] <ljharb>
rbuckton: tuples are primitives, arrays aren't

[14:45:03.0000] <ljharb>
`[ ]` is destructuring. `#[]` is just like `3`

[14:45:18.0000] <ljharb>
so `#[a, b]` Just Works using `===`

[14:45:32.0000] <ljharb>
(with extra magic needed for the bindings, ofc)

[14:45:39.0000] <rbuckton>
I take it `|` shortcuts? It's odd to see the same binding identifier repeated.

[14:46:37.0000] <rbuckton>
It is a bit odd to see `|` and `&` used for this (even though its similar to how TypeScript uses them in type-space for unions/intersections).

[14:46:47.0000] <ljharb>
yes, it's "or" semantics

[14:48:16.0000] <ljharb>
how we spell the combinators or the pin operator is certainly bikesheddable

[14:48:26.0000] <ljharb>
but i haven't heard any suggestions that make _more_ sense to me yet

[14:52:49.0000] <rbuckton>
Is `^` only `Identifier` or `ParenthesizedExpression`?

[14:53:02.0000] <rbuckton>
(roughly)

[14:53:23.0000] <ljharb>
actually we'd talked about it also including chains and CallExpressions

[14:53:28.0000] <rbuckton>
I'm sure people will want to do this:

[14:53:28.0000] <rbuckton>
```

[14:53:28.0000] <rbuckton>
import * as foo from "foo";

[14:53:28.0000] <rbuckton>
match (x) {

[14:53:28.0000] <rbuckton>
  when ^foo.Class { ... }

[14:53:28.0000] <rbuckton>
}

[14:53:29.0000] <rbuckton>
```

[14:53:36.0000] <ljharb>
right, with chains that'd work fine

[14:53:51.0000] <rbuckton>
Could always use a similar restricted grammar as decorators.

[14:54:00.0000] <ljharb>
conceptually i think it should work bare with "one thing" and with parens with "multiple things"

[14:54:08.0000] <rbuckton>
Anything more complex needs `()`.

[14:54:19.0000] <ljharb>
yeah presumably pattern matching and decorators would share the same syntax limits there

[14:56:26.0000] <rbuckton>
You could also use a different clause name than `when` for expression matchers, or a keyphrase like `when is` rather than an esoteric `^`.

[14:56:51.0000] <ljharb>
the expression stuff needs to be nestable

[14:57:01.0000] <ljharb>
so if it's a keyword, you'd get into super awkward precedence/paren things like `await` has

[14:57:35.0000] <ljharb>
that's why we ended up leaning towards a sigil

[14:58:08.0000] <mpcsh>
(and just spelling `when` differently doesn't nest)

[14:58:27.0000] <rbuckton>
Isn't it `when (Pattern) {}` anyways? How would `is` have a precedence issue?

[14:58:45.0000] <ljharb>
rbuckton: a pattern has to be able to have "an expression" at any level tho

[14:58:59.0000] <ljharb>
rbuckton: like `{ a: { b: { c: [a, b, ^c] } } } }`

[14:59:17.0000] <rbuckton>
I see.

[14:59:20.0000] <ljharb>
rbuckton: that'd be `[a, b, when c]`, but if `c` is a parenthesized one, it gets weirder

[14:59:31.0000] <ljharb>
and forcing parens with a keyword is also weird.

[15:00:18.0000] <ljharb>
(open to ideas ofc, just that's the thought process e went through)

[15:00:22.0000] <ljharb>
*we

[15:01:25.0000] <rbuckton>
If expressions are nestable, why have the headless form `when ^Name {}` and not just `when (^Name) {}` for consistency?

[15:01:51.0000] <ljharb>
we could, just seemed like nice sugar

[15:02:04.0000] <ljharb>
`when (^Name)` would still work regardless

[15:02:33.0000] <ljharb>
but `when (^(…))` looks worse than `when ^(…)` ¯\_(ツ)_/¯

[15:07:10.0000] <rbuckton>
I'm a bit wary of the parenless form only because it reduces syntax space for any possible future extensions to the `when` clause (of which we may have none yet, but look at where ASI has lead us).

[15:08:14.0000] <ljharb>
devsnek suggested we get rid of the `when` entirely

[15:08:32.0000] <rbuckton>
I really like the proposal. A few things make me squeamish though (like the `with` keyword)

[15:08:44.0000] <ljharb>
so it'd just be `^Name { }` or `^(<expr>) {}` or  `(<pattern>) {}`

[15:08:52.0000] <ljharb>
rbuckton: yeah i _really_ don't like spelling it "with"

[15:09:02.0000] <rbuckton>
That's odd with the `if` and `else` clauses though

[15:09:16.0000] <ljharb>
yeah that's a reasonable counter to "remove `when`", to be sure

[15:09:34.0000] <ljharb>
i _do_ like how `when` and `else` are the same length, so they all line up in oneliners :-p

[15:10:14.0000] <ljharb>
one of the complaints i hear a lot about let/const is that they're not all 3 letters

[15:10:45.0000] <rbuckton>
Then again, PowerShell does interesting things in its `switch` clause that are similar:

[15:10:45.0000] <rbuckton>
```

[15:10:45.0000] <rbuckton>
switch ($x) {

[15:10:45.0000] <rbuckton>
  Foo { ... }    # Foo interpreted as "Foo"

[15:10:45.0000] <rbuckton>
  Bar { ... }    # Bar interpreted as "Bar"

[15:10:45.0000] <rbuckton>
  {$_ -gt 3} { ... }  # ScriptBlock with $_ topic variable

[15:10:45.0000] <rbuckton>
}

[15:10:46.0000] <rbuckton>
```

[15:13:04.0000] <rbuckton>
Almost want to use `as` instead of `with`. Or `into`.

[15:13:20.0000] <ljharb>
pretty sure we can pick anything we want since it's not an expression space

[15:14:47.0000] <rbuckton>
I was tinkering with a LINQ-like comprehension syntax for JS that used `into` as a keyword:

[15:14:47.0000] <rbuckton>
```

[15:14:47.0000] <rbuckton>
const x =

[15:14:47.0000] <rbuckton>
  from user of users

[15:14:47.0000] <rbuckton>
  select user.name into name

[15:15:44.0000] <rbuckton>
  where name !== "Bob"

[15:15:44.0000] <rbuckton>
  select name;

[15:15:44.0000] <rbuckton>
```

[15:15:44.0000] <rbuckton>
or invert the clause:

[15:15:44.0000] <rbuckton>
```

[15:15:44.0000] <rbuckton>
when [first, last] from ^Name { ... }

[15:15:44.0000] <rbuckton>
```

[15:16:36.0000] <rbuckton>
which matches the right-to-left reading-order of the underlying array destructuring :`const [first, last] = Name[Symbol.matcher](x)`

[15:18:32.0000] <rbuckton>
Or just chain whens like `when ^Name when [first, last] { ... }` (since `^Name` produces a new object to match, that you might even want to further reduce)

[15:20:37.0000] <rbuckton>
More verbose, but a deeper nesting might allow something like:

[15:20:37.0000] <rbuckton>
```

[15:20:37.0000] <rbuckton>
match (...) {

[15:20:37.0000] <rbuckton>
  when ^Name match {

[15:20:37.0000] <rbuckton>
    when (["foo", bar]) {

[15:20:37.0000] <rbuckton>
    }

[15:20:38.0000] <rbuckton>
    when ([first, last]) {

[15:20:38.0000] <rbuckton>
    }

[15:20:39.0000] <rbuckton>
  }

[15:20:39.0000] <rbuckton>
}

[15:20:40.0000] <rbuckton>
```

[15:25:09.0000] <rbuckton>
Or, if you prefer sigils, maybe use an indirection like `when ^Name -> [first, last] { }`.

[15:25:09.0000] <rbuckton>
Generally I think I like `into` since you could consider it as taking the return value of one match and passing it into another pattern:

[15:25:09.0000] <rbuckton>
```

[15:25:09.0000] <rbuckton>
match (...) {

[15:25:09.0000] <rbuckton>
  when ^Name into { firstName, lastName } { ... } // result must have `firstName` and `lastName` properties.

[15:25:09.0000] <rbuckton>
}

[15:25:10.0000] <rbuckton>
```

[15:25:11.0000] <rbuckton>
The only value `with` has is that its a keyword. Unfortunately one with a bad rep.

[15:32:40.0000] <rbuckton>
One last thought, then I'll stop bugging you about the proposal. The current explainer uses `->` into an expression context, but the new version uses "implicit 'do' blocks". That's probably fine for most expressions, but its going to be cumbersome for returning object literals:

[15:32:40.0000] <rbuckton>
```

[15:32:40.0000] <rbuckton>
const x = match(y) {

[15:32:40.0000] <rbuckton>
  when ({ z }) { [z] } // array

[15:32:40.0000] <rbuckton>
  when ({ w }) { ({ w }) } // object

[15:32:40.0000] <rbuckton>
};

[15:32:41.0000] <rbuckton>
```

[15:32:41.0000] <rbuckton>
vs.

[15:32:41.0000] <rbuckton>
```

[15:32:42.0000] <rbuckton>
const x = match (y) {

[15:33:35.0000] <rbuckton>
  when ({ z }) -> [z]

[15:33:35.0000] <rbuckton>
  when ({ w }) -> {w}

[15:33:35.0000] <rbuckton>
};

[15:33:35.0000] <rbuckton>
```

[15:36:02.0000] <rbuckton>
I think it may catch some users off-guard. Makes me feel the cost savings of `when (^Name)` vs `when ^Name` don't quite cover the complexity of `{ ({ x }) }` :/

[15:49:02.0000] <ljharb>
that's already true for `do` expressions tho, right?

[15:49:57.0000] <rbuckton>
Yeah, but `do` expressions have a specific use case, where you use them *because* you need a statement context. A lot of use cases for `match` are in expressions and you may not need a statement context, but one is forced on you.

[15:50:00.0000] <TabAtkins>
rbuckton: The `into` keyword works for me if `with` is a no-go spelling. ^_^

[15:50:21.0000] <TabAtkins>
Not happy with the inverted order of your `from` example, I think it makes things *less* clear, since execution order actually jumps around

[15:50:23.0000] <rbuckton>
`with` isn't no-go, its just... well, `with`.

[15:50:30.0000] <TabAtkins>
Right.

[15:50:45.0000] <TabAtkins>
I didn't mean no-go from a parsing standpoint, just from an acceptability standpoint.

[15:50:55.0000] <TabAtkins>
It just happens to be how I first spelled it in my proposal.

[15:51:07.0000] <TabAtkins>
But I actually kinda like the implicit meaning of `into` better

[15:51:24.0000] <TabAtkins>
for the reason you gave above

[15:51:25.0000] <rbuckton>
I wouldn't block on it using `with`, it just has that "there be dragons" feel to it

[15:52:26.0000] <TabAtkins>
also, re: your issue about returning object literals, yeah, i feel you

[15:53:10.0000] <TabAtkins>
I'd be fine with just having the RHS be an expression, and relying on literal do-blocks when you need more. That was in an earlier version, I assume Jordan/Mark swapped it out for taste earlier.

[15:53:26.0000] <rbuckton>
`match` is just a better `?:` right (/s)? why not use `:` for expression-only, and `{}` for implicit `do` :)

[15:53:57.0000] <ljharb>
rbuckton: i'll have on the repo an "enhancement" we could do where the RHS can just be a bare expression

[15:54:19.0000] <ljharb>
the reason we removed the `do` is because it would encourage people to do `async do` there, and have match expressions that only sometimes return a promise

[15:55:02.0000] <ljharb>
we could do `when (…) <expr>` and `when (…) do { … }` and then let `async match` upgrade all the `do`s to `async do`s, i suppose

[15:55:18.0000] <rbuckton>
```

[15:55:19.0000] <rbuckton>
const x = match(y) {

[15:55:19.0000] <rbuckton>
  when ({ z }): [z]

[15:55:19.0000] <rbuckton>
  when ({ w }): { w }

[15:55:19.0000] <rbuckton>
  when ({ v }) {

[15:55:19.0000] <rbuckton>
    // more complex statement-level processing

[15:55:20.0000] <rbuckton>
  }

[15:55:20.0000] <rbuckton>
}

[15:55:21.0000] <rbuckton>
```

[15:56:05.0000] <ljharb>
and for a bare `if`?

[15:56:42.0000] <rbuckton>
Heh, consider dropping blocks *and* `when` and you get this:

[15:56:43.0000] <rbuckton>
```

[15:56:43.0000] <rbuckton>
const x = match(y) {

[15:56:43.0000] <rbuckton>
  ({ z }): [z], // need terminator so as not to interpret next line as call...

[15:56:43.0000] <rbuckton>
  ({ w }): { w },

[15:56:43.0000] <rbuckton>
  ({ v }) {

[15:56:43.0000] <rbuckton>
    // statements go here

[15:56:43.0000] <rbuckton>
  }

[15:56:43.0000] <rbuckton>
}

[15:56:44.0000] <rbuckton>
```

[15:56:58.0000] <ljharb>
yeah, that seems a bit confusing with object literals

[16:02:32.0000] <rbuckton>
```

[16:02:32.0000] <rbuckton>
const x = match (obj.y) { // what if getter has side-effects

[16:02:32.0000] <rbuckton>
  if (test(obj.y)): "a",

[16:02:32.0000] <rbuckton>
  else: "b"

[16:02:32.0000] <rbuckton>
};

[16:02:33.0000] <rbuckton>
// vs

[16:02:33.0000] <rbuckton>
const x = test(y) ? "a" : "b";

[16:02:33.0000] <rbuckton>
```

[16:02:34.0000] <rbuckton>
bare `if` feels weird without a topic variable (and I'm not a fan of topic variables), since side-effects are a thing. I'd almost rather do this:

[16:02:35.0000] <rbuckton>
```

[16:02:35.0000] <rbuckton>
const x = match (obj.y) { // what if getter has side-effects

[16:02:36.0000] <rbuckton>
  when (z) if (test(z)): "a",

[16:02:36.0000] <rbuckton>
  else: "b"

[16:02:37.0000] <rbuckton>
}

[16:02:37.0000] <rbuckton>
```

[16:04:38.0000] <ljharb>
you could do `match (obj.y) as z {` and then `z` is your topic variable

[16:04:54.0000] <ljharb>
otherwise it's just "whatever you put in the matchable position", which seems fine to me

[16:05:08.0000] <rbuckton>
`match` is interesting in that you can ab^M^Muse it to introduce a temporary binding:

[16:05:08.0000] <rbuckton>
```

[16:05:08.0000] <rbuckton>
const x = match (fn()) { when (y) { y + y } };

[16:05:08.0000] <rbuckton>
// vs

[16:05:08.0000] <rbuckton>
const x = do { let y = fn(); y + y; };

[16:05:08.0000] <rbuckton>
```

[16:06:23.0000] <ljharb>
the latter seems simpler to me

[16:06:29.0000] <ljharb>
so i'm not really worried about people doing that

[16:07:49.0000] <rbuckton>
I assume each match pattern will evaluate `Get`? This introduces interesting side effects too:

[16:07:49.0000] <rbuckton>
```

[16:07:49.0000] <rbuckton>
const obj = {

[16:07:49.0000] <rbuckton>
  count: 0,

[16:07:49.0000] <rbuckton>
  get x() { return ++this.count; },

[16:07:49.0000] <rbuckton>
};

[16:07:49.0000] <rbuckton>
match (obj) {

[16:07:50.0000] <rbuckton>
  when({ x, y }) { }

[16:07:50.0000] <rbuckton>
  when({ x, count }) { console.log(count); } // prints: 2

[16:07:51.0000] <rbuckton>
}

[16:07:51.0000] <rbuckton>
```

[16:08:10.0000] <ljharb>
i don't think it has to re-evaluate it

[16:08:19.0000] <TabAtkins>
Oh yeah we didn't talk about the `as`-on-matchable part of the grammar

[16:08:21.0000] <ljharb>
each clause has to memoize any array-iterator values from the matchable already

[16:08:32.0000] <ljharb>
so it seems reasonable to me to memoize the result of the Get too

[16:08:40.0000] <ljharb>
to minimize observable operations

[16:10:43.0000] <rbuckton>
You can't memoize operations using `^` though, unless you match through a `Proxy` or something, so there's still an (albiet minor?) side-effect hazard there.

[16:11:02.0000] <ljharb>
indeed that's true. but i think that would be expected.

[16:11:03.0000] <rbuckton>
And you wouldn't want to use a `Proxy`

[16:11:13.0000] <ljharb>
most people don't have getter/proxy-based side effects in their program anyways

[16:11:18.0000] <rbuckton>
fair. And the `if` clauses can introduce side-effects anyways.

[16:11:49.0000] <TabAtkins>
Yeah, and you'd get the same side-effects there with an if-else chain

[16:13:06.0000] <rbuckton>
ahem:

[16:13:06.0000] <rbuckton>
```

[16:13:06.0000] <rbuckton>
match (x) {

[16:13:06.0000] <rbuckton>
  when(/a/) { ... }

[16:13:06.0000] <rbuckton>
  when(/b/) { ... }

[16:13:06.0000] <rbuckton>
}

[16:13:06.0000] <rbuckton>
RegExp.$_; // ?

[16:13:07.0000] <rbuckton>
```

[16:19:31.0000] <rbuckton>
Regardless, I'm looking forward to pattern matching. I really do want to spend more time on my `enum` proposal to find something that everyone could agree on, and extend it to ADT-style enums:

[16:19:31.0000] <rbuckton>
```

[16:19:31.0000] <rbuckton>
enum Foo {

[16:19:31.0000] <rbuckton>
  A, // value

[16:19:31.0000] <rbuckton>
  B(x, y), // tuple

[16:19:32.0000] <rbuckton>
  C{ x, y } // record

[16:19:32.0000] <rbuckton>
}

[16:19:32.0000] <rbuckton>
...

[16:19:32.0000] <rbuckton>
match (value) {

[16:19:33.0000] <rbuckton>
  when ^Foo.A { ... }

[16:19:33.0000] <rbuckton>
  when ^Foo.B into [x, y] { ... }

[16:19:34.0000] <rbuckton>
  when ^Foo.C into {x, y} { ... }

[16:19:34.0000] <rbuckton>
}

[16:19:35.0000] <rbuckton>
```

[16:20:53.0000] <rbuckton>
Though I would have preferred a way to do something like this:

[16:20:54.0000] <rbuckton>
```

[16:20:54.0000] <rbuckton>
match (value) {

[16:20:54.0000] <rbuckton>
  when Foo.A { ... }

[16:20:54.0000] <rbuckton>
  when Foo.B(x, y) { ... }

[16:20:54.0000] <rbuckton>
  when Foo.C{x, y} { ... }

[16:20:54.0000] <rbuckton>
}

[16:20:54.0000] <rbuckton>
```

[16:22:40.0000] <TabAtkins>
I mean, if it's a language built-in, we can talk

[16:23:07.0000] <TabAtkins>
If we've got `-Infinity` in as a literal matcher, we can do other things.

[16:24:19.0000] <TabAtkins>
It looks like that would consume the syntax space for dotted stuff, but it might be worthwhile to spend it on that.

[16:26:08.0000] <rbuckton>
The biggest complexity of the `enum` proposal is that I need to be sure it supports the constraints that ljharb and michaelficarra have brought to me, while still leaving room for the constraints that TypeScript has.

[16:26:08.0000] <rbuckton>
TypeScript needs number-valued enums, and IIRC, ljharb and michaelficarra would prefer Symbol-valued enums. I think its feasible to support both (and other kinds as well), with some kind of default behavior as long as there's a way to override it.

[16:26:36.0000] <TabAtkins>
yeah, last time i looked at the enum proposal repo i was fairly happy with the way it allowed for both

[16:27:01.0000] <TabAtkins>
iirc just by going off of the first value with an initializer, or something?

[16:27:09.0000] <TabAtkins>
or there was some syntax? i forget. it was fine either way

[16:28:12.0000] <TabAtkins>
(i know i'd prefer symbol-valued enums by default; type confusion is a hell of a drug)

[16:28:17.0000] <rbuckton>
IIRC, in my last conversation with them about the proposal they were adamantly against number-valued enums from even existing, despite the fact that most languages support them and that they have their uses.

[16:28:34.0000] <TabAtkins>
oh, we definitely need the ability to ahve them, for bitflags if nothing else

[16:28:46.0000] <rbuckton>
It was by going off of an `of` keyword, with a symbol-protocol for handling definitions.

[16:28:58.0000] <TabAtkins>
ah yeah, right

[16:35:01.0000] <rbuckton>
```

[16:35:01.0000] <rbuckton>
const enum Color of Symbol {

[16:35:01.0000] <rbuckton>
  Red, // Symbol(Color.Red)

[16:35:01.0000] <rbuckton>
  Green,

[16:35:01.0000] <rbuckton>
  Blue

[16:35:22.0000] <rbuckton>
Not sure how much of that made it through :/

[16:36:10.0000] <rbuckton>
and ignore the `const` part. Fingers on autopilot from TypeScript's `const enum` declarations :)

[16:39:47.0000] <rbuckton>
Its a bit like Python's enums, with `@@toEnum` serving as `_generate_next_value_`:

[16:39:47.0000] <rbuckton>
```

[16:39:47.0000] <rbuckton>
class Color(Enum):

[16:39:47.0000] <rbuckton>
  RED = auto()

[16:39:47.0000] <rbuckton>
  BLUE = auto()

[16:39:48.0000] <rbuckton>
  GREEN = auto()

[16:39:48.0000] <rbuckton>
```

[16:39:49.0000] <rbuckton>
(and python also has IntEnum, IntFlags)


2021-04-21
[18:20:57.0000] <ljharb>
rbuckton: re resolve, it definitely will get support for it. Just haven’t had time to finish

[21:17:20.0000] <ljharb>
Bakkot: is `async do { do { return } }` currently a syntax error? if so, do you know how to go about doing that? (i'm assuming some kind of "async do mode" something or other)

[21:17:46.0000] <Bakkot>
yes, and the way you do this is just by parsing the body of `async do` with `[~Return]`

[21:52:25.0000] <ljharb>
aha, thanks

[06:55:18.0000] <robpalme>
and the Jitsi is open for business

[07:06:44.0000] <michaelficarra>
I find the difference in behaviour from what the champions intended to be a compelling argument

[07:21:52.0000] <leobalter>
https://gist.github.com/leobalter/16364bb167633cb3cb31e0f95e160a2a

[07:27:42.0000] <ystartsev>
I feel like... it would be really interesting to merge test262 and engine262 -- when a spec is ready to go to stage 3, it can have a direct implementation in engine262 and have tests written with it

[07:27:51.0000] <ystartsev>
thinking aloud

[07:28:10.0000] <devsnek>
i'm a fan of reference impls

[07:28:14.0000] <devsnek>
we have one for wasm

[07:28:43.0000] <shu>
ystartsev: i'm... skeptical?

[07:28:53.0000] <shu>
who's reviewing the engine262 implementation?

[07:29:17.0000] <shu>
like is that another thing to slow velocity and increase burden on the committee delegates, who are already volunteers?

[07:29:18.0000] <ystartsev>
I believe at the moment it is devsnek, but this could be a shared responsibility

[07:29:27.0000] <shu>
i'd rather not have that kind of bus factor

[07:29:33.0000] <michaelficarra>
if engine262 could be generated from the spec then I would support it, otherwise it's too much of a risk for additional divergence

[07:29:38.0000] <shu>
+1

[07:29:47.0000] <ystartsev>
we had work to generate a parser from spec text in spidermonkey

[07:30:04.0000] <ystartsev>
that is paused... but there is a non-zero chance that we will continue it

[07:30:15.0000] <devsnek>
jmdyck has a number of static analysis tools for the spec

[07:30:16.0000] <michaelficarra>
we can ask the INRIA people how feasible they think it'd be at the moment

[07:30:19.0000] <devsnek>
but they aren't public

[07:30:31.0000] <shu>
ystartsev: a grammar is one thing, but the algorithm steps is another

[07:30:34.0000] <ystartsev>
in terms of implementing semantics, that will be a bit ore difficult

[07:30:40.0000] <ystartsev>
*more

[07:31:09.0000] <ystartsev>
it would also reduce how vague/general we can be in spec text. for example how we wrote the top level await spec change

[07:31:16.0000] <ystartsev>
which would not be good, imho

[07:31:44.0000] <michaelficarra>
ystartsev: doing that is already one of my top priorities as editor

[07:32:03.0000] <ystartsev>
as in, make the algorithm steps more specific?

[07:32:04.0000] <michaelficarra>
generating an impl from the spec is effectively my end goal

[07:32:09.0000] <devsnek>
would be an interesting project

[07:32:10.0000] <ystartsev>
hm, ok

[07:32:12.0000] <ljharb>
that would be amazing

[07:32:31.0000] <ljharb>
would generating test cases from the spec be harder or easier?

[07:32:38.0000] <ystartsev>
so one concern I have there is that we may lose the intention of a given segment of spec in favor of an implementation

[07:32:52.0000] <michaelficarra>
ljharb: should be just about the same, look into abstract interpretation

[07:33:14.0000] <ljharb>
k

[07:33:14.0000] <ryzokuken>
wanted to clarify that by "discussion" I mean the one Shu mentioned and that we should kick off an async thread somewhere that talks about improvements to test262

[07:33:16.0000] <ystartsev>
maybe this can be addressed through editorial notes though

[07:33:42.0000] <michaelficarra>
ystartsev: agreed, we cannot lose human-readability

[07:34:22.0000] <ystartsev>
I think this is one issue of the top level await specification right now, it is too step oriented without enough text explaining the intention of these rather long graph algorithmsm

[07:34:32.0000] <ystartsev>
we _do_ have an entire non-normative example segment of the spec

[07:34:44.0000] <ryzokuken>
ljharb: I was thinking down the spec -> tests line as well

[07:34:49.0000] <ryzokuken>
maybe not the spec itself

[07:34:50.0000] <ystartsev>
but it would be better to have something in context with the algorithm

[07:34:56.0000] <haxjs>
it seems the audio quality is not very good...

[07:35:02.0000] <ryzokuken>
but there could certainly be a test262 generator of sorts

[07:35:08.0000] <ystartsev>
haxjs: maybe try reloading?

[07:35:13.0000] <ljharb>
ystartsev: +1 that the TLA spec is almost entirely unapproachable, but i have no idea how to fix that

[07:35:27.0000] <shu>
ystartsev: yeah i don't think test262 is even going to solve that

[07:35:41.0000] <ystartsev>
ljharb: I want to go through it at some point and bring some intentional text around it, either through notes or otherwise

[07:35:42.0000] <shu>
ystartsev: it's very telling that the discrepancies came up during fuzzing, right?

[07:35:47.0000] <haxjs>
ystartsev: serveral chinese delegates report same audio issue...

[07:35:49.0000] <ystartsev>
shu:  yes

[07:36:03.0000] <leobalter>
shu: your suggestion requires browsers to commit with a interoperable runner, I believe so

[07:36:11.0000] <leobalter>
it's a chicken and egg problem

[07:36:13.0000] <devsnek>
i'm curioust

[07:36:15.0000] <ljharb>
haxjs: hm, maybe an audio latency thing

[07:36:15.0000] <devsnek>
curious*

[07:36:24.0000] <ystartsev>
i like the idea that shu brought up

[07:36:25.0000] <shu>
leobalter: no it does not

[07:36:26.0000] <devsnek>
there's currently an "implementation contributed" dir in test262

[07:36:29.0000] <devsnek>
what's the status of that

[07:36:34.0000] <ystartsev>
we have a test262->sm converter but not the other way around

[07:36:35.0000] <shu>
devsnek: no one uses it

[07:36:38.0000] <devsnek>
ah ok

[07:36:56.0000] <shu>
leobalter: everyone already has a runner shim that works for them

[07:37:21.0000] <leobalter>
shu: everyone's runner has different perks that makes it so hard to change things in test262

[07:37:54.0000] <shu>
leobalter: i disagree, they don't really matter for the tests for the vast majority of tests?

[07:37:56.0000] <ystartsev>
haxjs: is it still bad after refreshing?

[07:38:04.0000] <shu>
once in a while something comes along, like weakrefs, that require new shim things to be done

[07:38:12.0000] <ystartsev>
cc robpalme we have some issues with audio for the chinese delegates

[07:38:31.0000] <robpalme>
right now?

[07:38:35.0000] <leobalter>
the Test262 python runner used in v8 is the hardest to change any frontmatter thing today. Relaxing it would be a great start to change interoperability.

[07:38:40.0000] <leobalter>
shu ^^

[07:39:00.0000] <shu>
leobalter: could you say more?

[07:39:26.0000] <shu>
leobalter: you're talking about the copyright checker?

[07:40:09.0000] <leobalter>
the copyright is one thing, the frontmatter checker is very strict

[07:40:12.0000] <michaelficarra>
leobalter: isn't it open source? It shouldn't be that hard to suggest a change.

[07:40:22.0000] <shu>
leobalter: oh really? let's get rid of it then :)

[07:40:40.0000] <shu>
i am not exaggerating when i say i derive basically no value from that frontmatter

[07:40:45.0000] <leobalter>
michaelficarra: there is a separate python runner that is a clone-like of V8's runner

[07:41:01.0000] <robpalme>
how is the audio now?

[07:41:34.0000] <devsnek>
frontmatter = the comment at the top with the spec steps and stuff?

[07:41:46.0000] <leobalter>
IMO, verifying frontmatter should be a task from test262's lint

[07:41:58.0000] <haxjs>
ystartsev: I've reloaded but still not good, not sure about others.

[07:42:07.0000] <leobalter>
we need to make sure we have a frontmatter for things that used in tests (e.g. flags)

[07:42:15.0000] <ystartsev>
hm ... we also had the audio muted for all others

[07:42:29.0000] <leobalter>
devsnek: yes

[07:42:43.0000] <robpalme>
haxjs: can you try a different browser?  or use one of the native apps?

[07:43:33.0000] <haxjs>
Oh I don't know there is native app! Let me try :)

[07:51:10.0000] <littledan>
wsdferdksl: Can you back up that assertion about NVC? It's possible that I'm missing background here.

[07:52:56.0000] <ljharb>
flags, a description, and a link to the relevant part of the spec, seem like the only parts of the frontmatter that would be useful, but i certainly don't know everyone's use case

[07:53:16.0000] <wsdferdksl>
littledan: From cnvc.org: "I think it is important that people see that spirituality is at the base of Nonviolent Communication, and that they learn the mechanics of the process with that in mind. It's really a spiritual practice that I am trying to show as a way of life. Even though we don't mention this, people get seduced by the practice. Even

[07:53:17.0000] <wsdferdksl>
if they practice this as a mechanical technique, they start to experience things between themselves and other people they weren't able to experience before. So eventually they come to the spirituality of the process. They begin to see that it's more than a communication process and realize it's really an attempt to manifest a certain spirituality."

[07:53:31.0000] <wsdferdksl>
That's a quote from Rosenberg.

[07:54:57.0000] <ystartsev>
rosenberg is seen as a complicated figure in terms of communication theory, he is coming from a very particular history, very much based in the usa

[07:55:47.0000] <ystartsev>
I think that, yes, for him it was rooted in spirituality specifically from the 60s and 70s when it was developed

[07:56:20.0000] <ystartsev>
however, it isn't exclusively a spiritual practice, and there are no spiritual aspects to the training itself. It focuses primarily on contextualizing a situation between two people during communication

[07:56:54.0000] <ystartsev>
indeed, on cnvc, they say "NVC *can* be seen as both a spiritual practice that helps us see our common humanity, (...), *and* a concrete set of skills"

[07:57:09.0000] <michaelficarra>
it sounds like you're painting it as historical, but it's taken from the website linked to by the presented slides

[07:57:42.0000] <ystartsev>
We can look at alternative types of communication strategies, however NVC is one of the older ones and more tested. It isn't perfect so if you have alternatives to suggest, I think people would be open to that

[07:57:59.0000] <ystartsev>
michaelficarra: yes, it is taken from the website, as is the quote i added above

[07:58:17.0000] <ystartsev>
eating can also be a spiritual activity, yet we have dinners as a group.

[07:59:19.0000] <ljharb>
one of the criticisms of modern yoga practice is that it *isn't* spiritual as yoga was originally created to be; is it necessarily important what the roots of the thing are, if we're not following those roots?

[08:03:25.0000] <littledan>
Donald Knuth relates algorithms to Christianity, but we still benefit from his work

[08:04:02.0000] <shu>
whatever communication training is decided upon, the ultimate question i imagine is what % of delegates will actually be open to it

[08:04:58.0000] <rbuckton>
Is jitsi working? I've tried on two different machines and hear no sound.

[08:05:00.0000] <michaelficarra>
I'm definitely still open to it, but the mentions of spirituality on the website do make me uncomfortable

[08:05:05.0000] <michaelficarra>
rbuckton: yes

[08:05:36.0000] <ystartsev>
What i like about nvc is it might help us drill down to the invariants and values that we want to maintain about the language. I am actually not 100% behind nvc training, but individual trainers interpret the method differently

[08:08:05.0000] <leobalter>
rbuckton: I'm using the phone app for audio

[08:08:44.0000] <rbuckton>
So far I've tried two different PCs using the electron app and the web and I'm not hearing audio. :/

[08:09:19.0000] <michaelficarra>
rbuckton: did you try turning them off and then on again?

[08:09:35.0000] <rbuckton>
michaelficarra: yep, and its plugged in

[08:16:30.0000] <rbuckton>
I think I'm having local internet issues :/

[08:17:33.0000] <rbuckton>
unless tcq is also down. Guess I'll blame comcast.

[08:28:07.0000] <rbuckton>
comcast was the issue.

[08:30:49.0000] <littledan>
ljharb: Are you saying you'd block this from joining the proposals repo until it has a problem statement?

[08:30:59.0000] <ljharb>
no, i'd have used the word "block"

[08:32:11.0000] <littledan>
well, I was just confused by what you meant when you talked about how the proposals repo ties into this

[08:32:11.0000] <ljharb>
but we've discussed this in plenary before. bringing two proposals that have solutions for stage 1 doesn't match that.

[08:32:22.0000] <ljharb>
that was my primary motivation for asking

[08:32:45.0000] <ljharb>
my lack of understanding of this presentation isn't as important to me since i don't often pay attention to typed array stuff

[08:33:02.0000] <ljharb>
but it is a frequent request of proposals seeking stage 1, by many delegates, so i'm surprised by your pushback

[08:33:51.0000] <littledan>
I think I phrased my pushback poorly

[08:34:13.0000] <littledan>
the whole presentation was about the motivation, which satisfies the Stage 1 requirements

[08:34:38.0000] <ljharb>
sure. but the slide asking for stage 1, and the proposal repo name and readme title, are phrased in terms of 2 competing solutions

[08:34:57.0000] <ljharb>
i'm happy it was apparently clear to everyone else, but it wasn't to me.

[08:35:47.0000] <michaelficarra>
this is a frequently recurring problem, especially among new delegates that are less familiar with our process

[08:35:58.0000] <michaelficarra>
maybe we need to communicate our process more effectively

[08:37:27.0000] <michaelficarra>
like could the proposal template repo encourage starting with a problem statement instead of jumping into a solution, spec text, etc?

[08:37:37.0000] <littledan>
I like that suggestion

[08:38:35.0000] <Bakkot>
devsnek jmdyck's static analysis tools are in fact public: https://github.com/jmdyck/ecmaspeak-py

[08:39:04.0000] <devsnek>
oh ni

[08:39:07.0000] <devsnek>
nice

[08:39:43.0000] <Bakkot>
I had a working knowledge of it at some point though I haven't done anything recently

[08:40:44.0000] <ljharb>
michaelficarra: that sounds like a great improvement

[09:00:48.0000] <littledan>
Hmm, from the 402 notes, I do agree with Myles that we should collaborate with Open UI, even if we do this in 402

[09:02:32.0000] <littledan>
I'm having trouble finding the part of the notes where  anyone from Apple said that this proposed API didn't result in a fingerprinting vector; maybe someone can point to the exact location?

[10:01:44.0000] <shu>
sorry i joined late due to another meeting

[10:01:45.0000] <shu>
what were the options?

[10:01:54.0000] <akirose>
we'll decide after this

[10:02:04.0000] <shu>
but what were the options that yulia presented?

[10:02:06.0000] <Bakkot>
make this one 30 minutes longer or get up tomorrow morning or something else

[10:02:06.0000] <ystartsev>
shu: options are open right now

[10:02:07.0000] <akirose>
the options are going 30 min late today, or meeting for just 30 min tomorrow

[10:02:23.0000] <shu>
ah, 30 mins today preferred then

[10:02:30.0000] <ystartsev>
30 min late today, 30 min tomorrow starting at 10 am, or after lunch 30 minutes

[10:02:35.0000] <Bakkot>
I would strongly prefer not to get up in the morning again tomorrow

[10:02:45.0000] <shu>
both 30 mins w/o break or 30 minutes after lunch wfm

[10:02:46.0000] <Bakkot>
am ok with other options but prefer running over today

[10:03:39.0000] <shu>
same

[10:05:12.0000] <ryzokuken>
I did see the slides previously too...

[10:05:17.0000] <ryzokuken>
but yeah

[10:05:32.0000] <ljharb>
same

[10:05:36.0000] <ystartsev>
do we have note takers?

[10:05:59.0000] <rpamely>
I think there's a bug on the mobile app where it only shows slides if the share started while you were connected. Not sure if people not seeing it were on mobile.

[10:06:14.0000] <msaboff>
Running 30 minutes over today is preferred.

[10:07:19.0000] <ryzokuken>
+1 for running over but if we have other APAC delegates online, maybe we should confirm from them?

[10:07:45.0000] <ystartsev>
I am checking and will explicitly check before we make a decision

[10:07:57.0000] <ryzokuken>
awesome thanks

[10:08:32.0000] <ryzokuken>
it's the jitsi join/leave sound, can be disabled IIRC

[10:13:44.0000] <akirose>
hey friends when Leo is done presenting slides, we'll need another notetaker (or two)

[10:13:48.0000] <akirose>
this is your heads up

[10:14:17.0000] <rricard>
I unfortunately can't continue further today

[10:14:41.0000] <akirose>
rricard: you have done so much, thank you ♥️

[10:15:40.0000] <littledan>
apologies for the distraction before; ryzokuken found the place where Myles Maxfield of WebKit explicitly supported Mozilla's privacy analysis. Still, Apple had other ideas about how the API should be shaped, and we should probably discuss these further (in TG2).

[10:18:36.0000] <ystartsev>
should i call for notes?

[10:32:38.0000] <littledan>
let me know if anyone wants a link to the April 2021 TG2 meeting (which wasn't linked from the calendar like normal). It contains answers to a lot of the questions that I've (inappropriately) asked during this meeting about Intl proposals. Again, my apologies for the redundancy/confusion of my comments.

[10:42:13.0000] <devsnek>
i dislike that virtualization apis would be subject to seemingly random limitations

[10:42:31.0000] <devsnek>
i can always make a version of evaluate that doesn't allow objects, but i can't make something the other way around

[10:51:42.0000] <littledan>
I think Realms are quite a poor replacement for getOriginals tbh. You want originals from the same Realm!

[10:52:52.0000] <jridgewell>
Yah, I think all of the internal slots won't be accessible with the user-realm's function references

[10:52:58.0000] <Bakkot>
strong disagree; getOriginals was very bad and I am extremely glad it did not go anywhere

[10:53:36.0000] <jridgewell>
Eg, `userRealm.WeakMap.prototype.get.call(incubatorWeakMap)` is gonna throw

[10:53:49.0000] <littledan>
well, there are legitimate concerns about getOriginals, but I don't think it's a good pattern to make a new Realm to replace it.

[10:53:50.0000] <ljharb>
getOriginals as proposed was indeed very bad

[10:54:00.0000] <ljharb>
and i do not ever want originals from the same Realm, in fact.

[10:54:09.0000] <ljharb>
jridgewell: no it won't?

[10:54:13.0000] <ljharb>
jridgewell: internal slots are cross-realm

[10:55:05.0000] <shu>
littledan: strong +1

[11:00:23.0000] <devsnek>
i wish the realms proposal would be more 1:1

[11:00:45.0000] <devsnek>
let me fully virtualize js environments :(

[11:01:18.0000] <ljharb>
that's basically what it was, for years

[11:01:42.0000] <jridgewell>
ljharb: Hmm, that's surprising.

[11:02:58.0000] <jridgewell>
c

[11:03:30.0000] <ljharb>
jridgewell: it's what Array.isArray is for, because `instanceof Array` doesn't work cross-realm, but slot-checking does

[11:15:35.0000] <littledan>
jridgewell: can't you use CSP to ban that Blob API too?

[11:15:47.0000] <littledan>
I mean, blob URLs

[11:16:09.0000] <Bakkot>
no one does, though

[11:16:22.0000] <littledan>
:(

[11:16:29.0000] <Bakkot>
lot of people disable eval, and the csp spec encourages that, but no one disables blobs

[11:16:33.0000] <Bakkot>
they don't have nearly the same issues

[11:16:50.0000] <Bakkot>
(since they don't evaluate in the context of the page you're on)

[11:17:10.0000] <littledan>
well, this proposal doesn't require new CSP hooks; it should fit into the existing ones in the same way

[11:17:17.0000] <rickwaldron>
@jridgewell here's an early discussion: https://github.com/tc39/notes/blob/8711614630f631cb51dfb803caa087bedfc051a3/meetings/2013-11/nov-21.md

[11:17:51.0000] <rickwaldron>
I believe that was the first time Dave presented this: https://gist.github.com/dherman/7568885

[11:18:26.0000] <Bakkot>
oh I misunderstood, the way amp is using it would be same-realm I think

[11:19:02.0000] <ryzokuken>
ystartsev: I'll go

[11:19:24.0000] <jridgewell>
We purposefully don't ban `blob:` in CSP, to get around the fact that we ban `unsafe-eval`

[11:20:05.0000] <Bakkot>
jridgewell lol it did not even occur to me that you would be in a position to control that yourselves

[11:20:24.0000] <Bakkot>
I am so used to the CSP being owned by a different team

[11:20:32.0000] <jridgewell>
This is the reason for the AMP Cache

[11:20:35.0000] <jridgewell>
(Partly)

[11:20:41.0000] <Bakkot>
(as it is in, afaict, ~every company other than google)

[11:21:02.0000] <ystartsev>
ryzokuken: thank you

[11:21:02.0000] <Bakkot>
(which, it is definitely designed for the google approach)

[11:53:32.0000] <brad4d>
I'll volunteer to review Symbols as WeakMap keys

[11:53:34.0000] <devsnek>
🎉

[11:54:16.0000] <rickbutton>
i got kicked out of #tc39-delegates, weird

[11:54:31.0000] <ljharb>
fired, obvs

[11:54:39.0000] <rickbutton>
oh no

[12:11:55.0000] <Bakkot>
ystartsev I can do notes

[12:13:44.0000] <ystartsev>
thanks Bakkot

[12:20:40.0000] <leobalter>
are we discussing test262 today? I logged off to decompress, I'd be happy to rejoin in this case

[12:21:17.0000] <littledan>
? we discussed test262 in the morning

[12:21:29.0000] <leobalter>
it appears in the overflow list

[12:21:33.0000] <ljharb>
i think we're wrapping up overall

[12:21:35.0000] <leobalter>
I'm just checking

[12:21:40.0000] <ljharb>
if you want to talk about it for the last 9 minutes please speak up

[12:21:44.0000] <leobalter>
I don't

[12:21:49.0000] <ljharb>
kk

[12:21:49.0000] <leobalter>
I'm exhausted

[12:22:04.0000] <leobalter>
but glad, for the records

[12:22:22.0000] <littledan>
it doesn't appear in the overflow list for me

[12:22:24.0000] <robpalme>
we're not going back to test262 - that record of the queue is just for gus

[12:22:39.0000] <leobalter>
thanks for the clarification, robpalme

[12:23:48.0000] <littledan>
finally we'll adopt Ecma's practices and schedule our meetings for longer than they actually are so that we can justify travel, more time, etc

[12:24:00.0000] <akirose>
lol/wince

[12:24:51.0000] <wsdferdksl>
The General Assembly meetings are scheduled for two days but always manage to finish in one.

[12:27:08.0000] <leobalter>
I would not oppose to schedule a fifth day for socializing. It still shows in the calendar for traveling expenses but it could remain optional for individuals

[12:27:32.0000] <leobalter>
no need to lie, we could always schedule social activities

[12:30:57.0000] <akirose>
gap day like jsconfus

[12:31:06.0000] <akirose>
"everyone take a breath"

[12:31:50.0000] <ryzokuken>
anyone coming to hubs?

[12:32:49.0000] <ljharb>
free time sounds nice *cries in calendar*

[12:36:38.0000] <ryzokuken>
cries in .ics :P

[12:43:12.0000] <rickbutton>
+1 for a gap day

[12:43:24.0000] <rickbutton>
especially if we go back to hawaii ;)

[12:45:23.0000] <Bakkot>
I took a week off work after that meeting

[12:45:30.0000] <Bakkot>
was the last time I was on a plane

[12:45:34.0000] <Bakkot>
in retrospect, great timing

[12:45:42.0000] <ljharb>
sames

[13:41:10.0000] <shu>
yes that was also the last time i was on a plane

[16:10:19.0000] <TabAtkins>
I was already quarantining by then :(

[16:10:35.0000] <TabAtkins>
But my last time on a plane was in Spain the month prior, so hey, still great.

[16:14:06.0000] <rkirsling>
I deeply regret not going to hawaii


2021-04-22
[21:46:41.0000] <leobalter>
rkirsling: same


2021-04-23
[18:23:56.0000] <ljharb>
shu: re https://github.com/tc39/proposal-resizablearraybuffer/pull/42, if you add conrad explicitly to the repo with "read" access, you'll be able to add them to the reviewers column

[12:56:38.0000] <shu>
ljharb: ah thanks


2021-04-26
[14:02:26.0000] <rkirsling>
lol that thread title is so ominous

[14:02:34.0000] <rkirsling>
"I will break the web"

[14:06:15.0000] <ljharb>
melodrama, tc39 style

[14:08:18.0000] <shu>
https://imgflip.com/i/5787b4

[14:10:31.0000] <shu>
the top is the subclassing proposal, and the bottom is, like, any Array.prototype proposal

[14:15:37.0000] <rkirsling>
hahah

[14:20:14.0000] <ljharb>
i doubt anyone does `instanceof Promise` anyways

[16:08:13.0000] <Bakkot>
ljharb lol of course they do

[16:08:22.0000] <Bakkot>
I've run into literally that exact bug

[16:08:58.0000] <Bakkot>
where some code on a page my code was on was interacting poorly with my monkeypatching in a way that caused `instanceof Promise` to fail with the consequence that the application broke

[16:09:29.0000] <ljharb>
wat oof

[16:09:50.0000] <ljharb>
what code was using that and why???

[16:10:23.0000] <Bakkot>
some UI stuff, and it seemed to be a wrapper intended to handle both async and non-async functions, but frankly I didn't bother looking very hard

[16:11:19.0000] <ljharb>
given the existence of promise libraries such that that code will break on lots of stuff, i'd hope they didn't, but i guess i shouldn't be surprised

[16:11:51.0000] <Bakkot>
"I wish people would not write this code" describes a large majority of the code on websites I look at

[16:16:47.0000] <ljharb>
ha

[16:17:47.0000] <ljharb>
i'm curious what a scoreboard of "lone sites/libraries that obstructed the language" would look like


2021-04-28
[12:15:58.0000] <ljharb>
what does Zalari do? i can't get google translate to work on their site

[12:16:37.0000] <ljharb>
or wait, i got it to load, but the title says "Water bomb bomb system with cyber security" so i think maybe a native german speaker's interpretation would be helpful

[12:34:42.0000] <akirose>
:actual-lol: that's amazing

[12:34:52.0000] <akirose>
we'll have to ask tkopp when he logs back on

[13:16:29.0000] <shu>
ljharb: i'm asking v8 folks in case any german speaker's still up

[13:25:31.0000] <ljharb>
lol thanks, no rush obvs, just curious

[13:25:51.0000] <Bakkot>
google translate implies they're just a generic build-a-webapp consultancy shop

[13:26:12.0000] <Bakkot>
> We do specialized software development and develop complex web applications agile according to SCRUM and are Jira-affine. We are 7 capable developers who are always looking for new challenges. We can selectively strengthen existing teams or take on our own tasks. In our spacious office there is enough space to work with external partners.

[13:27:51.0000] <ljharb>
would it be accurate to describe our current members as either engine implementers, the openjs foundation, large companies, or companies whose business model is unique and requires careful language changes to avoid complicating those use cases? or am i missing some in that very general summary

[13:28:52.0000] <Bakkot>
also universities

[13:28:57.0000] <ljharb>
ah yes

[13:29:25.0000] <ljharb>
that would make zalari somewhat unique; i'd love to hear their motivations for joining

[13:45:31.0000] <shu>
ljharb: one answer i got back was 'They claim to have built "like a lot of" stuff for companies they can't really about due NDAs'

[13:46:23.0000] <ljharb>
hm, that sounds significantly vaguer than shape's explanation of itself :-p

[13:47:27.0000] <shu>
the most public thing seems to be they run a JS meetup in Dresden

[13:49:28.0000] <shu>
the "Wasserstoffbomben-Lenksystem mit Cyber-Sicherheitslücke" is apparently like a jokey thing with buzzwords

[13:50:40.0000] <shu>
so, seems like a small consultancy-type shop that's trying to put out a cool jokester image

[13:58:35.0000] <rkirsling>
hydrogen is literally waterstuff?

[13:58:42.0000] <rkirsling>
german is silly

[13:59:34.0000] <shu>
yeah, i guess we could've gone that way: https://en.wikipedia.org/wiki/Linguistic_purism_in_English

[13:59:46.0000] <shu>
" Dorset poet, minister, and philologist William Barnes coined several words to promote "strong old Anglo-Saxon speech", including speechcraft for grammar, birdlore for ornithology, and bendsome for flexible."

[14:02:13.0000] <rkirsling>
those are great words but german roots sound quirky so I don't think they're good _replacements_ so much as additions

[14:07:48.0000] <shu>
calls for purity is pretty silly, but yeah the words are cool

[14:10:38.0000] <shu>
oh boy

[14:11:04.0000] <shu>
this reminded me of quebecois french's insistence on purity and inventing native french words for CS stuff, so i was searching for a dictionary

[14:11:06.0000] <shu>
and stumbled upon http://gdt.oqlf.gouv.qc.ca/ficheOqlf.aspx?Id_Fiche=8353961

[14:29:51.0000] <rkirsling>
that is a very confused language description

[14:32:26.0000] <rkirsling>
I would say outdated but that doesn't really cover it


2021-04-29
[19:15:09.0000] <devsnek>
this is the content i subscribe for 🙏🏻 https://gc.gy/87367495.png

[21:54:15.0000] <ljharb>
lol neither of those seems particularly helpfu

[21:54:15.0000] <ljharb>
l

[08:20:40.0000] <shu>
who among us is not a pre-existing reversible swimmer

[09:01:58.0000] <shu>
phoddie just noticed the reflector Google meet link for today's incubator call was incorrect. i've updated it

[09:23:05.0000] <TabAtkins>
Are we actually having meetings just, like, every six weeks now?

[09:24:30.0000] <TabAtkins>
(Looking at the Agendas repo and seeing successive meetings in March, April, and May is bothering me.)

[09:25:05.0000] <TabAtkins>
Sorry, it looks like a 5-week cadence at the moment (based on a sample size of *two* separations, but still)

[09:37:32.0000] <Bakkot>
instead of every eight weeks, yeah

[09:39:10.0000] <robpalme>
52 weeks / 8 meetings = 6.5 weeks between meetings on average.  but some need to be offset by a week to avoid widely observed holidays or ecma meetings etc.

[09:40:49.0000] <robpalme>
so we can expect there to be at least two occurrences in the year when we see 3 contiguous months

[09:42:32.0000] <robpalme>
there was feedback that 6 meetings per year was not frequent enough.  so we retained the same total hours, but distributed it slightly more

[09:49:12.0000] <ryzokuken>
especially given the online format, I had the feeling that meeting for shorter spans more often was less stressful?

[15:04:19.0000] <christianulbrich>
devsnek It's my company homepage and basically it is German click-bait, because I got sick of all those repeating stock image ridden one pager consulting agency web sites promoting how ingenius and cool they all are. Although I have to admin on a textual level our site says the same, we like to talk. :D If you'd want to get a glimpse of what we do, I'd suggest https://github.com/zalari/custom-elements-loader-prototype

[15:04:19.0000] <christianulbrich>
eative CustomElement monkey-patching allowing hot-reloading WebComponents transparently.

[16:52:42.0000] <rkirsling>
I should probably unsubscribe from the pipeline repo lol

[16:53:54.0000] <rkirsling>
the threads just make me feel like

[16:56:27.0000] <rkirsling>
like it's just a bunch of children whining about what flavor dessert they'll be getting

[16:57:38.0000] <ljharb>
rkirsling: but my whole meal will be ruined if my ice cream isn't orange sherbet

[16:57:50.0000] <rkirsling>
exactly

[16:57:53.0000] <ljharb>
rkirsling: sherbet is obviously superior to ice cream


2021-04-30
[01:53:13.0000] <tkopp>
hello 👋 and thanks for having an interest in zalari; @ljharb @akirose where you able to get answers? sry for replying so late but i haven't used irc in years and forgot that the history isn't saved automatically.

[08:22:20.0000] <ljharb>
tkopp: kind of not really :-)

[08:23:01.0000] <ljharb>
tkopp: christian pointed at the custom elements loader thing, but i'm hoping to understand what you do in the context of a motivation for joining tc39

[12:19:44.0000] <tkopp>
well, for the motivation. As a company we use JS/TS and its many frameworks on a daily basis and actually advocate the use of standards and modern JS throughout our work with our clients and the wider(local) developer community. As you already know we also host the local monthly JS meetup (for the 6. year now) and talk about the language. So, we follow the standard, work with it, help to spread it and gather

[12:19:44.0000] <tkopp>
feedback from our community. As individuals we already track the work and changes of the standard and want to combine our involvement. The next logical step for us was to actually help develop the language. We also want to aggregate feedback and be a voice for likeminded developers, agencies and software companies. So, what better way to give to the community than to take part in this? :)

[12:24:16.0000] <tkopp>
And we don't have anything to do with hydrogen bombs - that't just a clickbaity title 😅

[12:27:48.0000] <ryzokuken>
tkopp: awesome! increased and more diverse community involvement is always great.

[12:31:16.0000] <tkopp>
thanks, thats something i like to hear ˆˆ

[12:37:39.0000] <ljharb>
tkopp: thanks! totes legit and there's no gatekeeping here around motivation, i was just curious since it wasn't immediately apparent to me

[12:45:37.0000] <tkopp>
hu? never thought about gatekeeping ^^ the whole getting-started-process was already more involving and hands-on than I expected 👍

[15:19:44.0000] <ljharb>
awesome

