2022-12-01
[07:03:39.0015] <Kris Kowal>
So, my big take away here is that we need a Shark Week but Modules.

[07:04:06.0365] <Kris Kowal>
And we’re back to having a lot to discuss.


2022-12-05
[13:40:59.0415] <littledan>
lol I'm going to be extremely dead at our meeting tomorrow, after a whole-day Ecma GA meeting

[13:42:04.0984] <littledan>
Anyway I'd like us to discuss this somewhat urgent issue of the relationship between import assertions and HTML--the web platform might not actually support module types in the "assertion" style we were imagining. https://github.com/tc39/proposal-import-assertions/issues/125

[13:42:29.0933] <littledan>
I've invited Anne van Kesteren as our special guest (now of WebKit, formerly Mozilla)

[13:43:07.0297] <littledan>
This is time-sensitive both because the proposal is already at Stage 3 and because it's under consideration for "Interop 2023", which would accelerate its implementation in other browsers

[13:43:41.0025] <Kris Kowal>
Always good to cross paths with Anne. Thank you for reminding me that this is an odd-numbered week.

[13:43:56.0521] <littledan>
Fundamentally, the problem is: The Web actually wants to make requests to the server in different ways depending on which kind of resource is anticipated. That changes the interpretation of the module and is not consistent with the "assertion" invariant.

[13:45:10.0093] <littledan>
I'd add: the fact that HTML folks have been discussing this idea for a year and didn't notice the mismatch is kinda a mark against the "assertion" mental model. (The initial discussion was about CSP checks on the response, but the HTML people should've been thinking about the effects on the request too, which isn't as obvious to us humble TC39 folks)

[13:45:52.0024] <Kris Kowal>
In my estimate, that will force our hand into incorporating the type in the module instance’s memo. At least we can be explicit about that in 262 now that we’ve borged the logic for loading.

[13:46:11.0578] <littledan>
well, it'd be as simple as deleting a line

[13:46:18.0190] <Kris Kowal>
And if we entertain this, I’m in favor of renaming `assert` to `with` as soon as possible.

[13:46:27.0970] <littledan>
but, we'd have to think about the implications...

[13:47:05.0280] <littledan>
yes, certainly the keyword `assert` doesn't make any sense at all if we made that simple change you're thinking of

[13:47:19.0590] <littledan>
we'll need to think about whether this is the change we want to make

[13:47:25.0986] <Kris Kowal>
It’d imply that `importHook` needs to accept the `type` as an optional argument. We would want to be very clear that this is the only additional term of the module memo keyspace we’re considering.

[13:47:34.0271] <littledan>
> <@kriskowal:matrix.org> And if we entertain this, I’m in favor of renaming `assert` to `with` as soon as possible.

 * yes, certainly the keyword `assert` doesn't make any sense at all if we made that simple change you're thinking of

[13:47:47.0707] <Kris Kowal>
 * It’d imply that `importHook` needs to accept the `type` as an optional argument. We would want to be very clear that this is the only additional term of the module memo keyspace we’re considering.

[13:48:22.0298] <Kris Kowal>
As a safety, we’d probably also want the `Module` to have a `type` so the importing `Module` can make sure it gets what it asked for.

[13:48:34.0753] <Kris Kowal>
 * As a safety, we’d probably also want the `Module` to have a `type` so the importing `Module` can make sure it gets what it asked for.

[13:48:58.0486] <Kris Kowal>
Otherwise we have a maybe-ignore-the-requested-type footgun.

[13:49:41.0119] <Kris Kowal>
It’s a considerable complication, but if it’s table stakes, we can do it.

[13:49:54.0210] <littledan>
The two things which would be strongly dispreferrable to me are:
- If HTML gets to have special rights around how to use the type (or other arguments) that  other environments/hooks don't see, assuming HTML uses them in a significant-enough way
- If HTML does a willful violation (or violates a _should_ recommendation) around how assertions are used--we're designing this largely for HTML, so everything really should match up

[13:50:09.0196] <littledan>
I actually noticed that the HTML spec says it is a willful violation when it actually isn't! I need to file an issue on that

[13:50:46.0218] <Kris Kowal>
How is it not a willful violation if the author knew to write that it was a willful violation (as opposed to accidental?)

[13:51:09.0267] <Kris Kowal>
Change of authors?

[13:51:31.0473] <littledan>
I'd categorize HTML's current use of the assertion--just to duplicate a cache entry but not to actually make the request differently--as a not-significant-enough way of using the type which makes it not so bad that it's omitted from the import hook 

[13:51:58.0870] <littledan>
it was a willful violation in a previous draft. We went out of our way to make it not a violation, but I guess that wasn't noticed by the editors of HTML.

[13:52:17.0575] <Kris Kowal>
I must have missed that gambit.

[13:52:26.0481] <littledan>
and there were lots of strong opinions flying around, including strong expectations that we wouldn't ever have alignment (from both sides!)

[13:53:22.0097] <Kris Kowal>
I agree creating a duplicate cache entry as a side-effect is expressible with an importHook without threading the `type`, and is at least required for other kinds of redirects.

[13:53:34.0153] <littledan>
oh it is?

[13:53:43.0761] <littledan>
that's not what I was saying but it's sort of a relief if so

[13:54:14.0681] <Kris Kowal>
Ah, well, maybe not so great for `type` not to be virtualizable.

[13:54:26.0863] <littledan>
> <@kriskowal:matrix.org> It’d imply that `importHook` needs to accept the `type` as an optional argument. We would want to be very clear that this is the only additional term of the module memo keyspace we’re considering.

We will need to think about whether we want to just thread through one parameter or multiple. If it's just one, maybe we should go back and think about that nice-looking `as` syntax which Guy initially used to present import reflection...

[13:54:42.0969] <littledan>
we tried to be super general with import assertions but then we don't really have enough supporting use cases

[13:54:52.0862] <Kris Kowal>
But `importHook` does need to make notes about redirects and symbolic links in some cases, so it produces consistent results for all ways to address an identical module.

[13:55:14.0173] <littledan>
I guess it just makes those notes for node-like environments. In the web it doesn't/

[13:55:27.0839] <littledan>
it just identifies them as different modules

[13:55:34.0973] <Kris Kowal>
I’m pretty sure import reflection is orthogonal.

[13:56:14.0903] <Kris Kowal>
> <@littledan:matrix.org> it just identifies them as different modules

Presumably import-map is doing the work of emulating what Node.js does for a published artifact.

[13:56:43.0609] <littledan>
> <@kriskowal:matrix.org> I’m pretty sure import reflection is orthogonal.

well, I don't want to drag import reflection down with this--if we want import reflection to create something which can be statically imported within a nested module, it is definitely a different construct. Let's focus on import assertions by themselves first and then figure out how it relates to all the other module proposals.

[13:56:59.0409] <Kris Kowal>
Aye.

[13:57:00.0723] <littledan>
> <@kriskowal:matrix.org> Presumably import-map is doing the work of emulating what Node.js does for a published artifact.

Not really... it just doesn't attempt to solve this redirect problem

[13:57:30.0905] <Kris Kowal>
That’s surprising.

[13:57:49.0161] <littledan>
I mean, native modules on the web omit solutions to lots of problems... and they aren't used so much... maybe there's a connection

[13:58:25.0901] <Kris Kowal>
There is no emoji for my face right now.

[13:59:08.0496] <Kris Kowal>
In any case, this is a good topic for the agenda and I look forward to it.

[14:02:15.0305] <Kris Kowal>
I’m also interested in discussing how we go forward given bakkot’s express desire to “not introduce another path to eval”. That’s the one piece of feedback I believe we either need to address or argue around to advance Layer 0. I think there’s a coherent thinner sliver we can bring to the next plenary, where there are module sources but no ModuleSource, where we recover Layere 0 (grammar validation) Layer 1 (binding reflection) with a `Module.parse`.

[14:03:33.0592] <Kris Kowal>
I believe that maneuver still covers most of the motivating use cases, given that we grudgingly can fall back to `Module.parse(source); (0, eval)('module {${source}}')` (note ticks to avoid confusing markdown)

[14:03:47.0303] <Kris Kowal>
 * I believe that maneuver still covers most of the motivating use cases, given that we grudgingly can fall back to `Module.parse(source); (0, eval)('module {${source}}')`

[14:04:01.0285] <Kris Kowal>
 * I believe that maneuver still covers most of the motivating use cases, given that we grudgingly can fall back to `Module.parse(source); (0, eval)('module {${source}}')` (note ticks to avoid confusing markdown)

[14:04:59.0396] <Kris Kowal>
And of course, that also allows us to revisit `ModuleSource` when less reasonable folks come out with picks and torches some years hence.

[14:06:25.0778] <littledan>
huh, I think it'd be fine to have the ModuleSource class, and just its constructor throws

[14:06:38.0560] <Kris Kowal>
And, on the other hand, to make sure we’ve communicated the mitigating nuances of our design, I think we should separate `ModuleSource` into another layer and explain its mitigating qualities for CSP, just in case that was missed.

[14:06:46.0640] <littledan>
like the whole same design, just without that part

[14:06:57.0741] <littledan>
yes the fallback would be bad due to injection...

[14:07:05.0906] <Kris Kowal>
Yeah, I’m okay with that too, though it’s not necessary.

[14:07:16.0718] <littledan>
Wait Module.parse? Wouldn't that be another path to eval?

[14:07:22.0302] <littledan>
I thought bakkot was saying we should'nt have that

[14:07:38.0629] <Kris Kowal>
Right the fallback would be bad for injection, but as long as you `Module.parse` first, safety is recoverable.

[14:07:56.0558] <littledan>
well but would bakkot be OK with Module.parse?

[14:08:17.0913] <Kris Kowal>
No, `Module.parse` gives you parse but not eval, and doesn’t provide an object you can expect to pass to `Module`, so therefore no path from arbitrary string to evaluation.

[14:08:26.0567] <littledan>
what does it return?

[14:08:28.0696] <Kris Kowal>
That’s a question I need to ask.

[14:08:43.0087] <Kris Kowal>
`Module.parse` would return `{ bindings }`.

[14:09:20.0905] <Kris Kowal>
Or throw `SyntaxError`.

[14:09:23.0185] <littledan>
I'm not really convinced... I think we should be making more of an all-or-nothing decision

[14:09:51.0980] <littledan>
(I'm open to being persuaded)

[14:10:04.0856] <Kris Kowal>
My preference is to convince all relevant parties that what we’ve already proposed is good.

[14:10:39.0278] <littledan>
Yeah I like the ModuleSource constructor

[14:11:04.0513] <Kris Kowal>
But barring that, I’d like to make monotonic incremental progress and not preclude the possibility of going back for what’s left behind.

[14:11:13.0537] <littledan>
it would certainly have to be taken seriously as another entrypoint to eval, I agree with that

[14:11:25.0767] <Kris Kowal>
Same.

[14:11:33.0613] <Kris Kowal>
I will now feed the child. Back in a bit.

[15:18:44.0175] <Kris Kowal>
And back.


2022-12-06
[10:59:52.0031] <Kris Kowal>
We conveniently forgot to record a transcript for the module harmony meeting. I would encourage participants to instead write down your key take-ways in the minutes.

[11:02:53.0379] <nicolo-ribaudo>
Have we already discussed about just recording the meeting, like we do for SES?

[11:09:24.0111] <Kris Kowal>
I of course believe that’s a better system, but when this last came up, being under the umbrella of ECMA, the same constraints apply as plenary. But, discovering whether those constraints still apply is difficult.

[11:11:09.0694] <nicolo-ribaudo>
I remember we recorded some parts (presentations?) of some plenaries after making sure that everyone in the meeting was ok with it, so I'd expect the same rule to apply

[11:14:27.0459] <Kris Kowal>
That’d be good by me.

[12:54:50.0884] <Mathieu Hofman>
I had a transcription tool running: https://docs.google.com/document/d/16Wh6xh3b1li3O1xbVL0gPYdCD5OXLLH2QAmQtxXpzqA/edit

[13:01:42.0425] <Kris Kowal>
yulia: Thanks for the ref to C4; I’ll give it a read.

[15:05:21.0202] <Kris Kowal>
Oh, resolutions from today’s meeting seemed to include “Carve out a Module Harmony Layers repository”. That sounds to me like a clone of tc39/proposal-compartments, plus layer files for expressions, declarations, and import reflection, then additional documents to contemplate intersection semantics in various ways.

[15:06:10.0794] <Kris Kowal>
Then presumably I turn tc39/proposal-compartments back into its former self, and eject the layer-0 spec text and explainer into tc39/proposal-module-class and tc39/proposal-module-source-class.

[15:07:15.0763] <Kris Kowal>
Then eject explainers for would-be tc39/proposal-module-parse (binding reflection), tc39/proposal-evaluators, tc39/proposal-module-source-protocols.

[15:08:58.0008] <Kris Kowal>
Tentatively, tc39/module-harmony, unless yulia would like to establish a precedent for a layer explainer repository naming convention.

[15:09:13.0414] <Kris Kowal>
 * Tentatively, tc39/module-harmony, unless yulia would like to establish a precedent for a layer explainer repository naming convention.

[15:13:57.0960] <littledan>
tc39/epic-module-harmony ?

[15:15:19.0280] <guybedford>
do you think of module and module source as potential separate new layers Kris Kowal?

[15:15:46.0351] <guybedford>
or perhaps we just all get behind module expressions for this progression?

[15:20:17.0645] <Kris Kowal>
> <@littledan:matrix.org> tc39/epic-module-harmony ?

Apart from my profound respect for @ljharb’s violent Jira allergy, I think this would be good. I also like `tc39/eda-`, `tc39/saga-`, `tc39/veda-`, and `tc39/book-`, but I suspect that Epic is more likely to convey the right impression.

[15:21:19.0391] <Kris Kowal>
> <@guybedford:matrix.org> do you think of module and module source as potential separate new layers Kris Kowal?

They’re separable anyway.

[15:23:56.0382] <Kris Kowal>
I like the idea of cutting features finely for reasons unrelated to bundling or unpacking proposals. Whether that means separate proposals or not is less my concern, unless they have to be separated if Module can advance but ModuleSource cannot. But again, we resolved that would be premature at this stage.

[15:25:09.0426] <guybedford>
I would prefer we structure in a way that fits the TC39 process though I think

[15:25:23.0218] <Kris Kowal>
Describing them as separate features in the Epic will allow me to draw up a couple tables, with features along one axis, motivating use cases along the other axis, and clear distinctions between necessary, sufficient, and ergonomic for various combinations of features.

[15:26:02.0089] <guybedford>
a critical path diagram for stage progressions...

[15:26:17.0164] <Kris Kowal>
Very much in favor of packing proposals around TC39 process.

[15:28:58.0586] <Kris Kowal>
And to that end, I think it makes sense for TC39 to evaluate each of the layers as separate proposals. I’m also happy with the restraint folks here have shown, generally trying to get related proposals to similar stages of advancement together.


2022-12-07
[17:45:31.0068] <littledan>
The idea of introducing the concept of epics was well received by the committee 

[17:45:53.0953] <littledan>
I agree that we shouldn’t merge these all into a single proposal that proceeds lockstep

[17:46:09.0954] <littledan>
The epic wouldn’t have a stage but be a place to document and discuss relationships 

[02:47:35.0626] <yulia>
> <@kriskowal:matrix.org> Tentatively, tc39/module-harmony, unless yulia would like to establish a precedent for a layer explainer repository naming convention.

no strong feelings from my side


2022-12-08
[09:40:36.0256] <Justin Ridgewell>
👋 just discussed module reflection, lazy, and import assertions with my team

[09:43:19.0609] <Justin Ridgewell>
A few notes we have:
- the `import module` syntax is acceptable if we can't move this into the assertions
- If we do move into assertions, we really should rename `assert` (we might need to do this anyways based on implementer feedback in https://github.com/tc39/proposal-import-assertions/issues/125)
- If we move this into assertions, we can simplify the 2nd param to dynamic import (instead of `import("", { assert: { key: value } })`, just make it `import("", { key: value })`
- The `module` in `import module` is confusingly named, I'm already importing from ES modules

[09:43:54.0882] <Justin Ridgewell>
So I'm not blocking import reflection anymore, but would still very much like to move it into assertions

[09:54:34.0826] <Justin Ridgewell>
 * So I'm not going to lone block import reflection anymore, but would still very much like to move it into assertions

[09:54:43.0815] <Kris Kowal>
At this point, I’m in favor of changing the shape of import reflection to `import example from 'example.com' with { type: 'e.g.,destination' }` and `import('example.com', { type: 'e.g.,destination' })`.

If our constituents demand that the `type` string key must be communicated to the import hook, for example to direct content-negotiation, I can be convinced on the condition that the `type` must be threaded thru `importHook`. Evidently, the web platform doesn’t wish for this to be an assertion at all, since the `type` can be ignored and the response content-type dictates what kind of module source it will produce.

I will be difficult to convince that the `with` parameters be opened up as an arbitrary key-value space that virtual modules can fiddle with because of the internal complications that implies for memoizing import. I want TC39 to curate this space and be free to extend it with other properties, like `reflect`, `lazy`, `phase` or so on, with behaviors that can’t be emulated by an `importHook`.

[09:54:47.0273] <Justin Ridgewell>
 * A few notes we have:

- the `import module` syntax is acceptable if we can't move this into the assertions
- If we do move into assertions, we really should rename `assert` (we might need to do this anyways based on implementer feedback in https://github.com/tc39/proposal-import-assertions/issues/125)
- If we move this into assertions, we can simplify the 2nd param to dynamic import (instead of `import("", { assert: { key: value } })`, just make it `import("", { key: value })`)
- The `module` in `import module` is confusingly named, I'm already importing from ES modules

[09:55:59.0634] <Kris Kowal>
 * At this point, I’m in favor of changing the shape of import reflection to `import example from 'example.com' with { reflect: true }` and `import('example', { reflect: true })`, which would imply import assertions would look like `import example from 'example.com' with { type: 'e.g.,destination' }` and `import('example.com', { type: 'e.g.,destination' })`.

If our constituents demand that the `type` string key must be communicated to the import hook, for example to direct content-negotiation, I can be convinced on the condition that the `type` must be threaded thru `importHook`. Evidently, the web platform doesn’t wish for this to be an assertion at all, since the `type` can be ignored and the response content-type dictates what kind of module source it will produce.

I will be difficult to convince that the `with` parameters be opened up as an arbitrary key-value space that virtual modules can fiddle with because of the internal complications that implies for memoizing import. I want TC39 to curate this space and be free to extend it with other properties, like `reflect`, `lazy`, `phase` or so on, with behaviors that can’t be emulated by an `importHook`.

[09:57:52.0940] <Kris Kowal>
My opinion shifted in that direction because our SES shim for “hardened JavaScript” censors dynamic import to deny guest programs an escape hatch, and for that to continue being effective going forward, `import.module`, `import.reflect`, or `import.anything` would be problematic. I don’t expect that argument to convince anyone else that we should funnel reflection through dynamic import, but I also don’t expect anyone else to need to be convinced!

[10:01:09.0123] <Kris Kowal>
In any case, the behavior of an `importHook` doesn’t depend on the `reflect` parameter, so I don’t think it should be communicated in an options bag. The behavior of `importHook` would also not vary based on yulia’s proposed `lazyInit` (by whatever name) either. There’s an implied `phase` or `goalState` parameter that currently defaults to `"loaded"` if `reflect: true` and defaults to `"evaluated"` otherwise. Neither of those should be communicated to `importHook`.

[10:02:45.0193] <Kris Kowal>
If we did expose an options bag, we’d need something analogous to HTTP cache-control headers to dictate what properties of the options bag should be incorporated in the module key and in what order. We don’t have a suitable position to stand for those to be consistent between modules or scopes of modules (like packages).

[10:04:46.0758] <Justin Ridgewell>
(Can wait till after your current thoughts are down, but I disagree with the not-being communicated to `importHook` and it not affecting the import behavior)

[10:04:48.0408] <Kris Kowal>
So, my reasoning is that we have to consider _why_ we’d want an arbitrary options bag, and if there’s a better way to solve the same problem. My reasoning is that it’s relatively straight-forward to construct Node.js-alike behavior in terms of the current harmony state, using out-of-band information (e.g., `package.json`) that keys most of these choices on the specifier, and imposes coherence across all modules in scope.

