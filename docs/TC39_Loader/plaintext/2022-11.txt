2022-11-02
[15:22:29.0025] <Kris Kowal>
nicolo-ribaudo: I got a question from guybedford and want to confirm we’re on the same page: reflective import would advance the module to loaded but not to linked and its dependencies won’t be loaded.

[15:23:24.0917] <Kris Kowal>
I can easily imagine `import(x, {reflect: true, state: 'linked'})` or some such would load transitive dependencies without initializing or executing.

[15:27:03.0806] <nicolo-ribaudo>
Right, it would not load it's dependencies.
However, I hope it will not just result in a ModuleSource but in something that contains all the info necessary to later load&link it's dependencies 

[15:30:11.0313] <nicolo-ribaudo>
"would advance the module to loaded" -> Informally yes. Formally, it doesn't advance the module's state because the first state change happens when loading all its dependencies. It just makes us go from "I have nothing" to "I have a Module/ModuleSource"

[15:30:56.0550] <Kris Kowal>
I assume it would not be an observable optimization if the Module Record was born with a null pointer to the structs needed to advance past the loaded state.

[15:34:41.0394] <Kris Kowal>
We are in agreement about having a `Module` object and not just a `ModuleSource` but guybedford would like us to at least contemplate the alternative given that deferred `await import(reflectedModule)` doesn’t go as far as yulia’s proposing for deferred execution. I don’t think our current agreement precludes going farther and I think it’s compelling for code splitting, but it wouldn’t initialize a dependency on the stack of the first access of one of its exports.

