2022-06-06
[21:18:13.0183] <Kris Kowal>
Thank you ljharb for creating this space and welcome interested parties in module loader virtualization. I‚Äôve invited as many handles as I could recognize at a glance and I will try to gather the missing champions and collaborators.

[21:24:03.0794] <Kris Kowal>
By wave of an update, I‚Äôm working with the champion group to narrow the focus of the Compartments proposal to just module loader virtualization https://github.com/tc39/proposal-compartments/pull/46

[21:26:15.0964] <Kris Kowal>
Specifically in order to present the narrowest profile to the wind. There‚Äôs enough interest in the topic and two years of experience vetting the Compartments proposal (stage 1) that it‚Äôs time to push for 2.

[21:27:46.0767] <Kris Kowal>
By which I mean I hope to present on behalf of champions and collaborators, not at this plenary, but the next one in July, resources and alignment willing.

[21:31:28.0179] <Kris Kowal>
I invite Luca Casonato and guybedford (Guy Bedford) specifically because of our mutual interest. Talking with Guy yesterday, there‚Äôs substantial overlap between the problems that import reflection seeks to solve https://github.com/tc39/proposal-import-reflection, and the solutions that Compartments provide. And, Compartments I believe solve those problems without needing new syntax (relitigating the original import assertions proposal (import as)), relaxing idempotent import, or complicating cache keys.

[21:36:03.0402] <Kris Kowal>
I invite Surma because I believe the Compartments design can help inform the conversation about module blocks. One of our goals with Compartments is to create a clear distinction between a StaticModuleRecord and a ModuleDescriptor, which 262 currently conflates. Separating those concerns makes clear to me at least that we should choose whether a module block is re√Øfied as a StaticModuleRecord or a ModuleDescriptor, the latter containing the former. If a block is a StaticModuleRecord, that suggests easy portability between workers but doesn‚Äôt imply a full module specifier or module metadata.

[21:37:03.0559] <Kris Kowal>
The Compartments API also cleanly separates module specifier namespaces from module metadata, since we find that import.meta.url in particular must be a host-specific extension, and must be omissible in some hosts.

[21:37:43.0412] <Kris Kowal>
I think that position also clarifies our feelings about some of the design tensions we see in module blocks and look forward to discussing that.

[21:40:55.0474] <Kris Kowal>
My hope is to recruit you all to our common cause üôÇ


2022-06-07
[21:29:01.0191] <Jack Works>
Hello ~

[21:53:50.0131] <Jack Works>
In the [current](https://github.com/tc39/proposal-compartments/blob/6a180313515f6faec2818dad229e6921109b50f5/README.md) `ThirdPartyStaticModuleRecord` API, the initialize function only receives a `ModuleEnvironmentRecord` (which looks like only containing `import` and `export` bindings). There is no way to access the `globalThis` of the current executing compartment.

Lacking this ability make it impossible to compile a ES Module into a `ThirdPartyStaticModuleRecord`.

[22:17:54.0323] <Kris Kowal>
For folks tuning in, Jack is trying to build a no-eval shim for Compartments that precompiles ESM into a bundle.

[22:18:25.0948] <Kris Kowal>
I assume you‚Äôre aware that third-party static-module-records can‚Äôt emulate live bindings.

[22:19:30.0107] <Kris Kowal>
Jack Works: Have you looked at https://github.com/endojs/endo/blob/master/packages/compartment-mapper/src/bundle.js

[22:20:06.0187] <Kris Kowal>
That uses the SES shim‚Äôs static module record to create a bundle. It‚Äôs not a complete implementation, but it might be similar to your approach.

[22:20:07.0298] <Jack Works>
> <@kriskowal:matrix.org> I assume you‚Äôre aware that third-party static-module-records can‚Äôt emulate live bindings.

I'm aware that it cannot get the globalThis of the current compartment (it didn't pass as an argument in the initialize function)

[22:21:41.0513] <Kris Kowal>
Yes. My point was tangential to that concern.

[22:21:57.0796] <Kris Kowal>
I imagine we could thread globalThis into the initialize options bag.

[22:22:33.0092] <Kris Kowal>
I‚Äôm not entirely sure why it‚Äôs necessary for your implementation.

[22:22:58.0425] <Jack Works>
For example, I write `Math`.

[22:22:58.0894] <Kris Kowal>
Oh, I see.

[22:23:16.0079] <Jack Works>
I need to look it up in the current compartment's globalThis 

[22:23:35.0453] <Kris Kowal>
Thanks, I understand. The crux of the issue is that static module records must be reusable between compartments, and the global environment varies from initialization to initialization.

[22:23:39.0104] <Jack Works>
And those unresolved global variable lookup should be per-compartment

[22:23:51.0651] <Kris Kowal>
So, indeed, we should thread globalThis into the initializer.

[22:25:11.0417] <Jack Works>
I previously understand ModuleRecordEnvironment as "an exotic object that is a reification of 'lexical scope(import export bindings) and dynamic scope (globalThis)" 

[22:25:43.0491] <Jack Works>
But you just clarified that Module environment record does not contain globalThis so I need a new mechanism for this

[22:26:25.0809] <Kris Kowal>
That is certainly a reasonable design and I‚Äôm open to entertaining the idea still. I will make a point to ask Moddable for a clarification about what they did in XS.

[22:27:27.0190] <Kris Kowal>
But otherwise, whether or not to have module environment record capture global environment record is something we will want engine vendors to motivate.

[22:32:39.0222] <Kris Kowal>
Oh, module environment record *mustn‚Äôt* capture global environment record, because that includes top-level declarations of Script eval. Modules aren‚Äôt supposed to see those.

[22:33:24.0040] <Kris Kowal>
So either module environment record needs to fall through to properties of globalThis, or we need to thread globalThis into the module initializer.

[22:33:55.0951] <Kris Kowal>
Again, either way is fine with me.

[22:34:10.0968] <Kris Kowal>
And I‚Äôll make a note in the proposal README refresh PR.

[22:34:11.0275] <Jack Works>
Aren't decls created in Script either eval-by-eval or on globalThis? 

[22:34:21.0744] <Jack Works>
* Aren't decls created in Script either eval-by-eval or on globalThis? 

[22:34:38.0450] <Kris Kowal>
Yes, that‚Äôs true most of the time. 262 does not currently specify the behavior of REPLs.

[22:34:49.0809] <Kris Kowal>
But REPLs persist the ‚Äúglobal contour‚Äù between evals.

[22:35:33.0686] <Jack Works>
Oh I didn't notice REPLs. Does that specified in the language? I thought it was made by implementation for debugging 

[22:35:48.0048] <Kris Kowal>
That‚Äôs not something I hope to address in Draft 1 but expressly supporting the REPL case in the language would be an obvious thing to add to Compartment.

[22:35:57.0945] <Kris Kowal>
It‚Äôs not specified in the language.

[22:38:48.0368] <Jack Works>
I'm ok with either, but in a normal ES module, if you import x, then you no longer be able to refer to the global x (globalThis.x is not a direct refer). So if we want to have binding shallow behavior, or you still want to have globalLexicals in the API, I guess making it all in one object will be easier. 

[22:42:32.0982] <Kris Kowal>
globalLexicals would be analogous to globalContour. The former applies to modules only, the latter to scripts only. I haven‚Äôt added globalLexicals to the proposal yet, and might not until we discuss the layering of Lockdown. globalLexicals have a very limited use, and we found a way to avoid it for now at Agoric. That is, metering guest code.

[22:44:09.0232] <Kris Kowal>
But your hint is good. If we did have globalLexicals, having the module environment record reflect the entire top of stack would be more desirable.

[22:45:21.0284] <Kris Kowal>
I think that convinces me that we should put the burden on the module environment record.

[09:21:57.0126] <Kris Kowal>
(Aside: Moddable‚Äôs invention of ‚Äúmodule descriptors‚Äù is truly wonderful in simplifying the Compartment API. We‚Äôve been able to remove the `compartment.module` method and the `moduleMapHook`.)


2022-06-08
[10:06:13.0502] <littledan>
Hola

[10:06:25.0430] <ryzokuken>
hola ^2

[10:06:26.0945] <Kris Kowal>
Como etc

[10:06:36.0469] <shu>
are we repurposing this room to be for all module-related proposals?

[10:06:57.0816] <shu>
(could we rename if so?)

[10:07:09.0240] <Kris Kowal>
Yes, I‚Äôm repurposing the compartments proposal for module loader proposal.

[10:07:19.0353] <shu>
what is the module loader proposal?

[10:07:50.0582] <littledan>
the non-module-related parts of compartments are being split out

[10:07:50.0653] <Kris Kowal>
Module loading was a subset of tc39/proposal-compartments. I‚Äôve an open PR to narrow the focus to modules.

[10:08:02.0793] <littledan>
I'm a huge fan of this change

[10:08:14.0414] <Kris Kowal>
https://github.com/tc39/proposal-compartments/pull/46

[10:08:16.0477] <littledan>
how about we call this room "TC39 Modules"

[10:08:25.0847] <shu>
no i was asking something else, are we repurposing this room to also include the discussion of module blocks and import reflection?

[10:08:28.0799] <shu>
if so, let's rename

[10:08:32.0963] <shu>
if not, let's make a new room called TC39 Modules, yes

[10:09:22.0757] <Jack Works>
> <@kriskowal:matrix.org> Module loading was a subset of tc39/proposal-compartments. I‚Äôve an open PR to narrow the focus to modules.

new globalThis for each compartment is a must on our needs, want to make sure it is not removed from compartment

[10:09:54.0827] <Kris Kowal>
Ah, I‚Äôm in favor of a venue called Modules since it‚Äôs not my intention to increase the scope of Compartments to close over blocks and ‚Äústatic import‚Äù

[10:10:25.0648] <Kris Kowal>
My intention is to champion both shared-global and unique-globals.

[10:10:32.0330] <Kris Kowal>
Both modes are useful.

[10:11:42.0631] <guybedford>
I guess one question is where should the new StaticModulRecord be specified?

[10:11:49.0480] <guybedford>
If we can agree that such a userland record should exist?

[10:12:40.0736] <guybedford>
not userland - user exposed

[10:12:45.0212] <Jack Works>
> <@guybedford:matrix.org> If we can agree that such a userland record should exist?

for module block proposal, it must exist

[10:14:09.0010] <shu>
i am supportive of such a thing existing and is user-exposed, yes

[10:14:31.0603] <shu>
(also let's invite the module blocks folks in here like Surma, not sure how to do that)

[10:14:37.0198] <littledan>
there's clearly going to be some design which is shared between proposals. I think we should avoid too much churn between repos/URLs as we develop this though

[10:14:52.0713] <Kris Kowal>
I invited Surma when we created the room.

[10:15:06.0487] <shu>
ah excellent

[10:15:19.0405] <littledan>
maybe we should call the intersection of things the "loader proposal" and name things around that?

[10:15:26.0177] <Jack Works>
> <@littledan:matrix.org> there's clearly going to be some design which is shared between proposals. I think we should avoid too much churn between repos/URLs as we develop this though

now we're going to have a proposal dependency graph to link üéâ

[10:15:53.0770] <shu>
The Loader of Things

[10:16:04.0686] <Kris Kowal>
I‚Äôm in favor of not thinking too hard about layering yet. We need the proposals to be cohesive and none of them can advance without a notion of StaticModuleRecord.

[10:16:41.0440] <shu>
let's talk administrative stuff, what's a cadence people are open to at first blush?

[10:16:50.0567] <shu>
1h @ monthly? too little time?

[10:17:04.0157] <littledan>
weekly or biweekly would work for me. Monthly seems too slow given the timelines that people mentioned already

[10:17:14.0121] <littledan>
we could do monthly if we do lots of async work though

[10:17:23.0036] <Kris Kowal>
> <@shuyuguo:matrix.org> The Loader of Things

I have twin dark fates: to forever toposort dependencies and be in meetings that are thinly veiled parodies of LotR. My last long standing meeting was called ‚ÄúThe Fellowship of the Hashring‚Äù

[10:17:37.0373] <shu>
yes i do think monthly is too slow, not sure why i led with that

[10:18:01.0856] <shu>
i'll put together a doodle for initial time, and lead with 1hr @ every 2 weeks

[10:18:27.0605] <Kris Kowal>
In the interest of conservation of weekly hours, I will entertain any module conversation at SES Strategy every week, probably forever.

[10:18:59.0156] <Kris Kowal>
I can participate in a supplementary meetings at a lower cadence.

[10:19:04.0768] <shu>
i'd rather we move all of it to a module call, unless the SES folks also want to repurpose the SES call to be just about modules

[10:19:28.0202] <Kris Kowal>
SES straddles Europe/Pacific. The other time should straddle Pacific/Asia

[10:20:17.0112] <Jack Works>
I can join any meetings (when I am awake), Europe/Pacific meetings usually too late for me

[10:20:28.0711] <Kris Kowal>
For a limited time, we will prioritize modules over other popular SES Strategy topics. ShadowRealms have mostly graduated. Records and Tuples can wait.

[10:20:41.0742] <shu>
i'd prefer that folks interested in the module proposals not feel pressured to attend SES calls

[10:20:47.0194] <guybedford>
Especially given the next meeting is so soon, perhaps a weekly call would be beneficial? There's a lot of material here.

[10:21:10.0266] <guybedford>
Ideally if we could work roughly to an agenda that might help too

[10:22:00.0680] <shu>
so i propose that module discussions move out of the SES calls into this new call, *or* non-module SES topics are suspended and we just have one call until the module charter runs out

[10:23:19.0064] <shu>
and given that SES calls have a set time already, i lean towards the first option

[10:23:28.0722] <guybedford>
Building cross-specification agreement seems to be the value proposition here, so having a dedicated meeting makes sense to me

[10:23:34.0057] <Kris Kowal>
Well, I can give you a meeting where SES topics that don‚Äôt overlap modules are indefinitely postponed.

[10:23:48.0001] <Kris Kowal>
 * Well, I can give you a meeting where SES topics that don‚Äôt overlap modules are indefinitely postponed.

[10:24:17.0479] <Jack Works>
do we need a new repo for the module record and all module related proposals refer to it?

[10:24:32.0413] <shu>
Kris Kowal: are you and the SES folks open to suspend the SES calls in favor of this one until the module topics runs its course in this independent call?

[10:24:36.0490] <Jack Works>
 * do we need a new repo for the module record and all module related proposals refer to it?

[10:24:40.0123] <shu>
 * Kris Kowal: are you and the SES folks open to suspend the SES calls in favor of this one until the module topics runs its course in this independent call?

[10:24:55.0918] <shu>
i really don't want multiple "rooms where it happens"

[10:24:58.0264] <Kris Kowal>
I can only say that I only have space in my workweek to run one meeting.

[10:25:12.0313] <shu>
understood, not asking you to convene

[10:25:32.0608] <Kris Kowal>
And I would be delighted to convene ;-)

[10:31:21.0353] <Kris Kowal>
shu:  But, by all means, please share a Doodle so we can find a good commons.

[10:31:35.0760] <Kris Kowal>
 * shu:  But, by all means, please share a Doodle so we can find a good commons.

[10:32:27.0254] <shu>
making a doodle as we speak

[10:50:05.0798] <Kris Kowal>
littledan: I could use your eyes on the compartments-as-loader proposal with an eye for how to fit import assertions in. That is one concern I‚Äôve not written in.

[10:51:26.0503] <Kris Kowal>
There are some obvious places to account for it, like adding an options bag to the import method. Probably also obviously necessary to thread those options into the loadHook.

[10:52:01.0103] <Kris Kowal>
But also perhaps obviously _not_ thread it into the loadHook, because that invites the virtual host to abuse it for non-assertions.

[10:53:00.0647] <Kris Kowal>
In order for us to preserve the character of import assertions, it might be necessary to add a ‚Äútype‚Äù property to module descriptors, such that the Compartment is in a position to maintain the assertion.

[10:53:31.0426] <shu>
reflector issue and doodle up: https://github.com/tc39/Reflector/issues/436

[10:53:42.0588] <shu>
i'll cross-post in TC39 Delegates for visibility

[10:53:57.0751] <Kris Kowal>
That in turn makes a case for continuing to encapsulate ‚Äúlink‚Äù

[10:57:05.0469] <Kris Kowal>
Is this intentionally Doodle with a little D, or am I looking at the spreadsheet a form reports to?

[10:59:57.0404] <Kris Kowal>
https://github.com/tc39/proposal-compartments/issues/37

[13:12:39.0202] <Kris Kowal>
I withdraw the question. This is clearly superior to Doodle with a big D regardless.

[13:14:08.0515] <Kris Kowal>
I went ahead and added a column for the 10:00 AM Pacific time slot. We can deconvene SES Strategy if that time slot is winful.

[13:43:27.0866] <shu>
it is intentionally doodle with little d

[13:43:36.0848] <shu>
but i have been incorrectly capitalizing it

[13:44:31.0870] <shu>
i stole the sheet from a PM internally, i was real tired of the huge amount of large banner ads on actual doodle

[13:46:57.0698] <guybedford>
it's incredibly impressive, certainly decapitalizing doodle there :P

[13:48:18.0545] <shu>
spreadsheets: the one true programming environment

[14:00:39.0100] <littledan>
I take it 2-weekly means "every two weeks" not "twice a week" right?

[14:05:42.0388] <shu>
that's correct

[14:13:17.0893] <littledan>
that's a relief

[14:40:30.0314] <Kris Kowal>
The CommonJS debates were about a month of continuous debate with thousands of messages. I definitely can‚Äôt sustain that kind of engagement anymore, but I certainly care enough to try üòÇ

[14:44:39.0919] <Kris Kowal>
> <@shuyuguo:matrix.org> spreadsheets: the one true programming environment

Pitch: spreadsheets but comic sans.

[14:52:58.0685] <littledan>
I feel like we don't have all that many points to actually make opinionated decisions here, that most of the API should sort of flow through "naturally"

[14:55:23.0057] <littledan>
so many things are nailed down already by the nature of modules already

[15:00:59.0070] <Kris Kowal>
Mark and I have decided to get ahead of the inevitable bikeshed and suggest renaming the Compartments proposal to merely Loader. https://github.com/tc39/proposal-compartments/pull/48

[15:01:55.0786] <littledan>
love it

[15:01:58.0508] <Kris Kowal>
It‚Äôll remain Compartment in the quiet of our hearts.

[15:02:00.0950] <littledan>
lean in

[15:02:35.0159] <littledan>
(if you want to keep it as compartments, that's fine with me)

[15:02:49.0048] <littledan>
I guess the sort of core of this being compartment-like is having its global specified

[15:02:57.0774] <littledan>
i wonder if there's some way to refer to that... I can't think of it

[15:03:04.0761] <Kris Kowal>
Further simplifications to come to court the majority.

[15:04:22.0133] <Kris Kowal>
Right, and in the majority use-case, folks will want to share the global environment record from host to guest, so we‚Äôre discussing making that the default, and keeping a carve-out for a new-global behavior. We don‚Äôt actually need much from the new-global carve-out to build Lockdown in userland.

[15:07:25.0677] <Kris Kowal>
And I would like to prepare a PR with an inside-out version of Loader like what Guy proposes, based on Compartment shim internals, to vet guybedford‚Äôs ModuleInstance by contrast. It will be interesting to see them side-by-side.

[16:54:24.0037] <Kris Kowal>
In [Guests share host by default #50](https://github.com/tc39/proposal-compartments/pull/50), I‚Äôm attempting to make the Loader proposal more juicy for SES-indifferent crowd by making Loader() as useful as possible to what I believe will be many people‚Äôs needs with no options provided.

[16:54:59.0460] <Kris Kowal>
It‚Äôs at the end of the day, just pivoting the defaults.


2022-06-09
[17:41:04.0562] <Kris Kowal>
I sketched guybedford (Guy Bedford) and Luca Casonato ‚Äôs ModuleInstance in the context of the Loader n√©e Compartments proposal https://github.com/tc39/proposal-compartments/pull/51

[17:42:06.0018] <Kris Kowal>
In short, it doesn‚Äôt obviate the need for Loader, because dynamic import has to fall through.

[17:42:55.0065] <Kris Kowal>
It may be interesting to include a `ModuleInstance` constructor regardless, but it doesn‚Äôt reduce the scope of the Loader proposal.

[18:23:32.0181] <Kris Kowal>
On further reflection (updated above PR, it‚Äôs possible to implement Loader in user code, with all of the ‚Äústatic import‚Äù part of Import Reflection, ModuleInstance, and a Global constructor for the hardened JavaScript case. The user-code Loader wouldn‚Äôt be able to do import reflection on your behalf, so you‚Äôd have to learn harder on that.

[18:24:50.0500] <Kris Kowal>
The user code loader would have to thread a dynamic import (or not).

[20:50:02.0934] <Kris Kowal>
guybedford: When you say ‚ÄúSynthetic‚Äù, as in static module record, is that equivalent to how I‚Äôve been using ‚Äúthird-party‚Äù in the Loader (n√©e Compartments) proposal? If so, I like it and would be glad to propose a change.

[21:46:08.0612] <Kris Kowal>
Oh, story checks out. You‚Äôre borrowing a term from WebIDL https://github.com/tc39/proposal-compartments/issues/36

[22:52:34.0513] <Jack Works>
can I join the zoom meeting with a web client and be able to share screen? üëÄ

[22:53:10.0633] <Jack Works>
for this event

[23:52:52.0210] <naugtur>
you definitely can join, didn't test sharing

[23:53:06.0676] <naugtur>
we can switch to something else if that's an issue


2022-06-11
[15:36:24.0203] <Kris Kowal>
Sketch for how the compartments proposal might account for import type assertions https://github.com/tc39/proposal-compartments/pull/61


2022-06-13
[11:07:53.0861] <shu>
i plan to finalize a timeslot and cadence by EOD today: https://github.com/tc39/Reflector/issues/436#issuecomment-1154186322

[11:08:09.0156] <shu>
if you haven't voted on the doodle excel that is neither Doodle nor Excel, please do so


2022-06-14
[20:04:29.0193] <shu>
call is finalized: https://github.com/tc39/Reflector/issues/436#issuecomment-1154620771

[20:04:32.0528] <shu>
check the TC39 calendar!

[20:04:40.0772] <shu>
and see you all Tuesday, Jun 21

[15:14:40.0059] <Kris Kowal>
Question for engine vendors: can we reveal the loader hooks of the host to guest code? https://github.com/tc39/proposal-compartments/issues/63

[15:16:05.0767] <Kris Kowal>
My intuition is ‚Äúmaybe?‚Äù The loadHook is basically fetch + compile.

[15:17:35.0430] <naugtur>
Some loader hooks exist in Node.js https://nodejs.org/api/esm.html#hooks

[15:48:25.0757] <Kris Kowal>
Ah, this hints at James Browning‚Äôs suggestion of passing `defaultLoadHook` as an argument.

[15:52:36.0886] <Kris Kowal>
Noted in the issue^

[15:52:56.0041] <Kris Kowal>
So the question remains but specifically for browser vendors.

[15:53:30.0853] <Kris Kowal>
I posted another motivating example, inter-compartment linkage https://github.com/tc39/proposal-compartments/pull/64/files

[16:01:57.0401] <shu>
my intuition is a strong "preferably not"

[16:13:06.0703] <Kris Kowal>
Also, looking for a temperature check for whether to share or detach compartments by default https://github.com/tc39/proposal-compartments/issues/65

[16:47:19.0475] <Kris Kowal>
Quick fix for namespace object bindings, since `*` is _not_ a reserved export name. https://github.com/tc39/proposal-compartments/pull/66

[16:56:05.0338] <Kris Kowal>
importMetaHook found to be superfluous https://github.com/tc39/proposal-compartments/pull/67


2022-06-16
[05:09:35.0906] <Jack Works>
I presented the latest updates of compartment proposal and having some question from the JSCIG

[05:11:00.0342] <Jack Works>
Why "loader" will provides the virtualization of the global object? They looks overlap with ShadowRealm

[05:13:13.0344] <Jack Works>
Actually I'm also curious about this problem. If I have Compartment proposal, ShadowRealm is useless to me. It is hard to use and not provide more abilities than compartment (when the intrinsic are froze).

[10:34:12.0435] <Kris Kowal>
There is indeed some overlap, and some of that falls out naturally from the nesting of the dolls: Every realm is among other things a loader. And there will be some subtlety to whether a Realm or a Compartment is a good fit for a particular use case.

[10:35:56.0151] <Kris Kowal>
One big difference is that a Loader-with-a-new-global comes with only three fresh intrinsics: new evaluators bound to the compartment.

[10:36:57.0181] <Kris Kowal>
Consequently, module instances can be shared between loaders, whereas module instances cannot be shared between realms.

[10:37:13.0343] <Kris Kowal>
Static module records can of course be shared in both cases.

[10:40:11.0357] <Kris Kowal>
HMR and test watchers can be done with either, but for these cases I think Compartment-with-shared-global is much lighter and can hand off state more easily.

[10:40:52.0082] <Kris Kowal>
Deferred execution can not be done by a Realm. That‚Äôs the case Guy and Luca brought to our last plenary.

[10:41:49.0114] <Kris Kowal>
This is a good question, though, and we need to document an answer in the Compartment design rationale.

[10:41:52.0385] <legendecas>
Is deferred execution related to a distinct global object?

[10:42:53.0661] <Kris Kowal>
And that is in fact issue #1 https://github.com/tc39/proposal-compartments/issues/1

[10:43:20.0559] <Kris Kowal>
No, you can defer execution with a shared global. That‚Äôs orthogonal.

[10:44:39.0776] <Kris Kowal>
One motivating case for detached global is our Hardened JavaScript isolation mechanism. That‚Äôs at least my primary motivation as a champion.

[10:46:02.0082] <Kris Kowal>
We can shim most of what we need with a very minimal carve-out for a detached global. Without that carve-out, the hardened JavaScript shim (`ses`) would continue to need to fully emulate the loader aspect.

[10:46:54.0534] <legendecas>
Thanks for the reply. I'm interested in the details about how ShadowRealm could work with Compartment/Loaders

[10:47:14.0475] <legendecas>
Wondering if that could be done with composing ShadowRealm with Compartments?

[10:48:47.0696] <Kris Kowal>
So, the way the spec text is likely to go for compartments/loaders begins with a refactoring to decouple the existing Loader from the existing Realm in the spec, such that the Realm is a Loader, but not necessarily the only loader in that realm.

[10:50:09.0486] <Kris Kowal>
So, as a consequence of the factoring, ShadowRealm and Compartment can be used in tandem. But, I suspect you have something else in mind.

[10:51:34.0809] <legendecas>
Well, the question about why we need a "detached global" just come up to my mind when I find that the proposal is going to be renamed as Loader, which sounds to me has nothing to do with globals at the first place

[10:52:15.0316] <Kris Kowal>
One *interesting* motivating use case that would rely on both ShadowRealm and Compartment would be creating a Compartment inside a ShadowRealm with different hooks. That is to say, constructing a ShadowRealm and then bootstrapping a non-host module-loader.

[10:52:50.0336] <Kris Kowal>
That‚Äôs a good argument to continue calling it Compartment, but the substance of the proposal would be identical regardless.

[10:52:52.0616] <legendecas>
> <@kriskowal:matrix.org> One *interesting* motivating use case that would rely on both ShadowRealm and Compartment would be creating a Compartment inside a ShadowRealm with different hooks. That is to say, constructing a ShadowRealm and then bootstrapping a non-host module-loader.

Yeah, this is what I have in my mind too

[10:53:47.0426] <Kris Kowal>
As a champion, I‚Äôm eager to de√´mphasize the detached global feature, but not remove it.

[10:54:20.0142] <Kris Kowal>
Because there are so many cases where a Compartment with a shared global is useful, I imagine that will be the primary usage.

[10:55:58.0819] <legendecas>
I would be happy to see the works going on to elaborate the design rationale in the repo on this :D

[10:56:04.0244] <Kris Kowal>
A Compartment with a detached global is necessary for other single-realm isolation motivating cases.

[10:56:29.0957] <Kris Kowal>
Yes, for sure.


2022-06-21
[09:02:24.0834] <littledan>
hi all

[09:02:26.0969] <Kris Kowal>
I‚Äôm in the lobby https://meet.google.com/row-whjm-rpn

[09:02:39.0701] <Jack Works>
+1

[09:02:42.0646] <Kris Kowal>
Not sure whether this is the venue, shu 

[09:02:49.0657] <littledan>
me too, waiting to get in

[09:02:53.0974] <naugtur>
I'm in there too

[09:03:01.0739] <littledan>
Kris, excellent slides

[09:03:23.0791] <Mathieu Hofman>
I'm still waiting to be let in

[09:03:27.0684] <Kris Kowal>
Great, fi was shooting for ‚Äúbad‚Äù

[09:03:35.0507] <shu>
sorry, previous meeting ran over, omw

[09:09:42.0250] <Luca Casonato>
If you are in the waiting room, maybe try rejoin?

[10:25:52.0616] <shu>
yulia: still around?

[10:26:21.0141] <shu>
can you join the meet again rq? i can't add a co-host via the calendar configuration dialogs for some reason, i wonder if i need to do it within the call itself

[10:26:29.0823] <yulia>
yes

[10:27:24.0283] <shu>
okay, i'm off the call now, see if you can rejoin without me being there

[10:27:30.0758] <yulia>
it forces me to request again

[10:27:33.0857] <yulia>
so i can't enter without you

[10:27:34.0365] <shu>
hmm

[10:28:49.0131] <nicolo-ribaudo>
If I remember correctly, people invited to the calendar event can join without permission. It's not ideal, but we can start by inviting all the people that were present today

[10:29:23.0790] <littledan>
leo reported being able to join without waiting in the lobby

[10:29:57.0751] <nicolo-ribaudo>
Leo was one of the people invited on calendar

[10:30:08.0436] <yulia>
uhhhh

[10:30:10.0888] <yulia>
it still doesnt work

[10:30:11.0613] <shu>
oops, forgot to save

[10:30:15.0004] <shu>
sorry try again

[10:30:16.0162] <yulia>
ahaha

[10:30:30.0929] <yulia>
\o/ it works

[10:30:52.0929] <shu>
okay great, it should also let you admit other people next time

[10:30:54.0874] <shu>
thanks for testing

[10:32:44.0795] <shu>
for next time: Yulia, Kris, Dan, and Jack Works are co-hosts and can admit other folks

[10:33:43.0745] <shu>
also, just realized, next meeting falls on US 4th of July holiday

[10:33:56.0488] <shu>
any conflicts for same time on Wed, Jul 6?

[10:34:56.0651] <nicolo-ribaudo>
There is the SES meeting that starts one hour after te modules one, it might be a problem if we do 1:30h

[10:35:35.0672] <shu>
i see that, yes, though given all the SES folks are here and this is also top-of-mind for them, perhaps it'd be fine

[10:36:09.0686] <guybedford>
You mean 5th of July right?

[10:36:38.0923] <shu>
i mean 6th of July

[10:36:42.0621] <shu>
4th and 5th are both holidays

[10:37:01.0438] <shu>
at least it is at Google

[10:37:06.0041] <guybedford>
ah gotcha, consolidating may well be an option for that one then

[10:37:08.0947] <shu>
if it's just me i can just skip the next call, Yulia is running it anyhow

[10:37:24.0063] <yulia>
sure

[10:40:31.0463] <guybedford>
Your call - not sure how many people won't be able to make the 5th? I can do either day.

[10:45:30.0073] <shu>
i'd like to not create any pressure for US-based folks so i'd prefer moving it to the 6th

[10:49:16.0339] <Kris Kowal>
> <@nicolo-ribaudo:matrix.org> There is the SES meeting that starts one hour after te modules one, it might be a problem if we do 1:30h

We‚Äôll deconvene the SES meeting if a Compartments meeting overlaps.

[10:49:22.0078] <Kris Kowal>
That is actually our preference.

[10:51:49.0690] <Kris Kowal>
Speaking of which, we‚Äôd previously built a SES meeting agenda tomorrow for guybedford to join us and hash out what a VirtualStaticModuleRecord for WASM would concretely look like. The artifact would be an example PR for the Compartment proposal. I‚Äôm inclined to keep that on the docket and use the PR to sync with this interest group, if there are no objections.

[11:58:46.0903] <Kris Kowal>
Daniel Ehrenberg: Regarding carrying import.meta and the referrer specifier for a module to another compartment and the importance or non-importance of the identity of a module block https://docs.google.com/document/d/1CD5lIBZLl24XBWbQhokqBdt4Zl7wPAcFJKJrgePr9HU/edit#bookmark=id.o21po234q3z

[11:59:56.0140] <Kris Kowal>
If a module block is reified as a ‚Äúmodule descriptor‚Äù ~ {record, specifier, importMeta}, the identity of the object still doesn‚Äôt matter. The specifier matters because that is the key in the module memo.

[12:00:38.0403] <Kris Kowal>
That is to say, a map of module descriptors could be transported to another worker without losing any of the relationships between modules.

[14:04:08.0734] <littledan>
about layering, I want to push back on the idea that was raised in the meeting today about all proposals depending on compartments or some reduction of it. I'd prefer that we focus on figuring out what the big picture API is, and then it will be more clear which pieces we can ship; I think there are lots of orderings that would work, and we shouldn't focus too excessively on working out one factoring or another. For example, I think it'd be OK to ship module reflection or module blocks before we have an imperative API to provide the way that modules link to each other.

[14:09:35.0454] <shu>
+1

[14:09:56.0479] <shu>
that is the conclusion i personally would be happier with and we should give it a full discussion next call

[14:10:07.0744] <shu>
i wanted to explicitly surface the question which i felt was implicit in Kris's presentation

[14:12:48.0861] <littledan>
I really liked Kris's presentation. It brought together a bunch of ideas really well. I think it's important that we maintain a unified model for how modules work, and the compartments proposal stands out as it exposes so much

[14:14:04.0852] <shu>
also agree

[14:55:52.0308] <Kris Kowal>
To be clear, I also consider the question of ordering and layering an open question and I don‚Äôt have a preference toward shipping compartments first. I just do not, from where I‚Äôm sitting right now, see a way to do that in a way that doesn‚Äôt hobble the proposal that lands first.

[14:57:43.0983] <Kris Kowal>
For example, suppose we land module blocks first? There needs to exist some mechanism for instantiating the block. For deferred execution, same issue. Import reflection could be exposed, but none of the motivating use cases work without a loader.

[14:58:53.0009] <Kris Kowal>
ShadowRealm may give us a degree of freedom in that regard.

[15:00:30.0103] <Kris Kowal>
To the extent that ShadowRealm encapsulates a loader. But even then, the result differs in name only from the part we later factor out of realm. So, big +1 to littledan‚Äôs point about getting a holistic view before figuring out layering.

[15:01:01.0250] <Kris Kowal>
 * To be clear, I also consider the question of ordering and layering open and I don‚Äôt have a preference toward shipping compartments first. I just do not, from where I‚Äôm sitting right now, see a way to do that in a way that doesn‚Äôt hobble the proposal that lands first.

[15:01:26.0186] <Kris Kowal>
 * For example, suppose we land module blocks first. There needs to exist some mechanism for instantiating the block. For deferred execution, same issue. Import reflection could be exposed, but none of the motivating use cases work without a loader.

[15:04:47.0186] <Kris Kowal>
Also, ShadowRealm and workers of every kind should probably be born with host-defined loader hooks, since serializing a loadHook fraught in the former and dubious in the latter. But in combination with a compartment, having a realm bootstrap off of the host-defined loader and constructing a Compartment with a user-defined loader opens up options.

[15:17:09.0158] <littledan>
the main mechanism for instantiating module blocks is import()

[15:17:35.0809] <littledan>
the proposal stands on its own without further control, IMO

[15:18:03.0198] <littledan>
I agree that ShadowRealm should probably take a LoaderOptions bag as an argument

[15:18:20.0533] <littledan>
but, also there, ShadowRealm is useful without that

[15:18:22.0714] <Kris Kowal>
So, assuming that, then Compartments would have import and loadHook competing to register module descriptors.

[15:18:51.0990] <littledan>
huh?

[15:19:01.0431] <littledan>
I meant the already-existing dynamic import()

[15:19:12.0650] <littledan>
as well as passing the module block to structured clone

[15:19:43.0258] <Kris Kowal>
Understood. I propose that a desirable invariant is for dynamic import and compartment import be nearly the same.

[15:19:48.0109] <littledan>
I agree that we shouldn't have competing hooks. Surma and I proposed module block without hooks.

[15:19:53.0189] <littledan>
yes, definitely they should be the same

[15:20:14.0099] <littledan>
so, sure, you can pass a module block to compartment import once there are compartments

[15:20:15.0333] <Kris Kowal>
Consider: `import(module { import 'x.js'; })`

[15:21:20.0420] <Kris Kowal>
Followed by (approximately) `import({ specifier: 'x.js', ...module { } })`

[15:21:35.0271] <Kris Kowal>
And let‚Äôs assume that module blocks correspond to module descriptors.

[15:22:03.0310] <Kris Kowal>
The behavior of this example is order dependent (even without the introduction of compartment).

[15:22:12.0584] <Kris Kowal>
Because there already is a host loader in play.

[15:22:54.0719] <Kris Kowal>
In the former case, you push a module into the module map, but in order for its dependencies to be satisfied, the loader must pull them in.

[15:23:43.0977] <Kris Kowal>
So you‚Äôd have to take care to push your dependencies into the loader from leaf to root. Which is fine, but fragile.

[15:23:55.0994] <Kris Kowal>
I contend that it‚Äôs fragile enough that it is inadvisable.

[15:25:55.0027] <Kris Kowal>
When compartments get reified, then there‚Äôs a missed opportunity for the compartment to represent a capability to induce a module to be loaded, not to determine what is loaded.

[15:26:55.0939] <Kris Kowal>
That is to say, a loadHook provides a coherent top-down view of how to construct a coherent module graph. Providing a way to inject modules into that graph from *within* the compartment allows a module to interfere with the linkage of its peers.

[15:27:25.0371] <Kris Kowal>
And that hazard exists regardless of whether or when we reify the Compartment/Loader object.

[15:31:31.0664] <Kris Kowal>
Inevitable bike shed from which there is no escape: ‚Äúspecifier‚Äù is heavy. Maybe this should be ‚Äúto‚Äù, the dual of ‚Äúfrom‚Äù.

[15:41:59.0216] <littledan>
yeah, I'd say that when there's a host loader, you shouldn't be able to just push a specifier into the module map

[15:42:20.0259] <littledan>
so I don't understand the second line of your example

[15:42:49.0829] <littledan>
(I don't really understand how it works even if you have a custom loader)

[15:43:37.0620] <littledan>
I haven't done as detailed a look at the current state of the compartments proposal as I should

[15:44:02.0933] <littledan>
isn't there the same order dependency as if you did `import('x.js')`?

[15:48:20.0185] <Kris Kowal>
Yeah, let me just excerpt the relevant bit of the proposal.

[15:48:38.0663] <Kris Kowal>
A module descriptor is shaped like {record, specifier, importMeta}.

[15:48:57.0144] <Kris Kowal>
Where record is a static module record, or by any other name just as sweet.

[15:49:14.0982] <littledan>
(is this written somewhere, or is it from discussion after writing took place?)

[15:49:34.0473] <Kris Kowal>
Module descriptors are landed in the proposal README, yes.

[15:50:30.0123] <Kris Kowal>
That is, {record, specifier, importMeta} is one of the shapes in the union, and it‚Äôs the one I think most sensibly corresponds to a module block after our meeting this morning.

[15:51:34.0194] <Kris Kowal>
I was of the opinion that blocks might better correspond to static module records, but let‚Äôs say I‚Äôm tentatively convinced that module descriptors are more useful and do not preclude other motivations I‚Äôd had in mind.

[15:51:40.0872] <littledan>
personally I didn't come to a clear conclusion on what module blocks would correspond to after the meeting

[15:52:01.0040] <Kris Kowal>
Sure, tentative opinion. Let‚Äôs assume for purposes of discussion.

[15:52:04.0031] <littledan>
also I'm having trouble finding that shape in the union, or maybe I'm looking at the wrong union

[15:52:22.0661] <littledan>
is "instance" a name for specifier?

[15:53:02.0515] <Kris Kowal>
Take the first shape in the union.

[15:53:23.0000] <Kris Kowal>
Then add `"specifier"` ad hoc since module blocks would need that. There‚Äôs a PR that would add it for other reasons.

[15:54:02.0223] <Kris Kowal>
Elsewhere the specifier is implied because the descriptor is value side of a key value pair.

[15:54:24.0878] <littledan>
which PR should I be looking at?

[15:54:37.0547] <littledan>
I'm still not sure what the specifier should be for a module block with no explicit name

[15:54:40.0625] <Kris Kowal>
Or in the case of a loadHook(Specifier) => Promise<ModuleDescriptor>, implied by the argument

[15:54:56.0889] <Kris Kowal>
_that_ is a good point.

[15:55:45.0888] <littledan>
I think we run into funny cases if you're allowed to go and claim a specifier and then imperatively insert that into the module map from inside the compartment. I don't think you should be allowed to do that.

[15:56:00.0931] <Kris Kowal>
I concur.

[15:56:23.0176] <Kris Kowal>
And that actually sums up the argument I‚Äôm clumsily building.

[15:57:36.0346] <Kris Kowal>
And sways me back to `module {} instanceof StaticModuleRecord`

[15:58:20.0808] <Kris Kowal>
 * And that actually sums up the argument I‚Äôm clumsily building.

[16:00:02.0381] <littledan>
OK, well, if module blocks were to be added first, we'd have to think about what's observable

[16:00:23.0176] <littledan>
and the two observable things I can think of are 1) import.meta, and 2) what happens when you import() the same module block twice

[16:00:43.0919] <littledan>
I think module blocks have a name, but it's a gensym

[16:01:03.0172] <Kris Kowal>
Right, and gensyms don‚Äôt transport.

[16:01:19.0377] <littledan>
yeah, over transport it makes a new one

[16:01:27.0615] <littledan>
so structured clone is approximate

[16:01:36.0440] <littledan>
and each time you postMessage a module block, you get a new copy on the other hand

[16:01:42.0390] <Kris Kowal>
Which means different invariants locally and remotely. That‚Äôs a footgun.

[16:01:44.0425] <littledan>
but, import.meta on the web *does* transport, and it should for this case

[16:02:04.0156] <Kris Kowal>
import.meta is host-defined and doesn‚Äôt transport *reliably*.

[16:02:34.0827] <littledan>
> <@kriskowal:matrix.org> Which means different invariants locally and remotely. That‚Äôs a footgun.

we're trying to make design tradeoffs; I'm not really interested in trading jabs of reductio ad absurdum

[16:02:43.0351] <Kris Kowal>
Also, `import.meta` tends to be a function of host-defined behavior that could vary between the sender and receiver.

[16:02:46.0867] <littledan>
> <@kriskowal:matrix.org> import.meta is host-defined and doesn‚Äôt transport *reliably*.

we're talking about what structured clone does, which is also host-defined

[16:03:36.0856] <littledan>
> <@kriskowal:matrix.org> Also, `import.meta` tends to be a function of host-defined behavior that could vary between the sender and receiver.

hmm, could you say more about this scenario?

[16:03:40.0635] <Kris Kowal>
Pardon, no jab intended.

[16:04:48.0625] <littledan>
in my mind, preserving the base address for relative specifier resolution is essential for module blocks

[16:04:54.0317] <Kris Kowal>
I should say, I personally value the avoidance of that particular footgun over the convenience of pushing a module block over import, and that is partially informed because I think the same ends can be achieved by other means.

[16:05:07.0844] <littledan>
Oh, let's go into discussing those other means

[16:07:45.0316] <Kris Kowal>
So, I would concede that it is both possible and convenient in some cases to be able to rely on the assumption that a pair of module loaders have the same resolution semantics. In that situation, the pair of loaders can reliably arrive at equivalent import.meta for the same specifier, except when the specifier is a gensym.

[16:09:56.0430] <Kris Kowal>
Taking that thought a little farther, I also think having gensyms for module specifiers is not dangerous unless module blocks can be imported, though I‚Äôll grant that module fragments attempt to cross that bridge.

