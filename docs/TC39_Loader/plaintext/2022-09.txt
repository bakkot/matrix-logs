2022-09-02
[07:07:39.0107] <nicolo-ribaudo>
If anyone is interested to see how the hooks change looks on the HTML side: https://github.com/whatwg/html/pull/8253


2022-09-23
[17:23:31.0116] <Kris Kowal>
yulia | OOO until sept 26th: I’ve started working on a Module Harmony tech tree, arrows from motivating uses cases to features. To get there, I’m starting with a sketch of the graph, instead of starting with prose. I’m this far: https://gist.github.com/kriskowal/268d46617cd68015b811a2f5fdaf3217


2022-09-24
[00:09:44.0032] <Jack Works>
https://github.com/tc39/proposal-compartments/pull/78/

I tried to implement this change but I found it is invalid

[00:10:00.0188] <Jack Works>
the referral parts goes away

[08:20:45.0763] <Kris Kowal>
At the last SES meeting, we agreed that I’d add a non-normative note that the "options bag" is passed as `this` to the hooks, so you can use `this.referrer` in an `importHook`.

[08:24:34.0417] <Jack Works>
> <@kriskowal:matrix.org> At the last SES meeting, we agreed that I’d add a non-normative note that the "options bag" is passed as `this` to the hooks, so you can use `this.referrer` in an `importHook`.

That's very unintuitive 

[08:24:58.0459] <Jack Works>
Proxy handler supports sharing between multiple proxy

[08:25:13.0607] <Jack Works>
And it's real target is given by the first argument 

[08:25:48.0100] <Jack Works>
If this design requires different object instance for each module, it will be a performance cliff 

[08:52:30.0456] <Kris Kowal>
I’ve been unable to convince Caridy that referrer should be explicitly mentioned. He’s quite adamant about leaving it to user code.

[08:52:53.0666] <Kris Kowal>
Caridy does accept that the hooks themselves cannot be per-module closures.

[08:54:38.0427] <Kris Kowal>
In any case, Caridy is the one among us who needs to be convinced. In our last SES call, Caridy convinced Mark and me at least that his design does not limit expressivity.

[09:09:10.0530] <nicolo-ribaudo>
The middle ground between Caridy's and Jack's positions is to use `new Module(source, handler, thisArg/context)`, rather than mixing the handler and the thisArg in the same parameter. This also feels cleaner, since we have a clearly separation between "an object with clearly defined properties" and "something that the user can use as they wish"

[09:10:11.0204] <nicolo-ribaudo>
(I propose it as a middle ground to not mention the referrer while still reusing the same handler object every time, but it also happens to be my favourite design)

[12:31:34.0780] <littledan>
If we go that way, my bikeshed on top of that would be to pass context as an argument rather than `this`.

[12:32:20.0210] <littledan>
reusing handlers seems useful, though I can accept that it's less clean in some sense or other than making different closures each time


2022-09-26
[19:22:36.0449] <Kris Kowal>
The combined effect of your preferences would be to rename `referrer` to `context`, and if that is what it takes to satisfy Caridy, I’m all for it.

[19:23:31.0172] <Kris Kowal>
That is, new Module(source, sharedHandler, context) where sharedHandler = { importHook(specifier, context) => Module }

[19:25:14.0164] <Kris Kowal>
And from a performance perspective, it doesn’t reduce allocations, but the handler object can be an ephemeral options object, which would presumably go into the nursery and get collected cheaply, instead of being retained for the lifetime of the Module.

[02:48:17.0879] <yulia | OOO until sept 26th>
the graph looks great! that was what i was thinking of doing but it looks like it helped you organize your thoughts. I'll read through

[07:52:44.0141] <yulia>
compartments layers 1,2,3 seem to have no dependencies, putting them at what I would imagine to be the same layer. Any reason they cannot be done concurrently?

[14:51:56.0254] <Kris Kowal>
They can certainly be done concurrently.

[14:54:13.0844] <Kris Kowal>
Reminder: Module Harmony meeting tomorrow. I’m hoping to share this Module Harmony Graph.

[14:56:16.0562] <Kris Kowal>
Putting this together has helped me tease apart some of the finer layers, which are academically interesting at least: Like, having ModuleSource instances is useful even even without a ModuleSource constructor.

[14:57:17.0207] <Kris Kowal>
And there are cases where the constructor might be omitted but instances would still be present, like some configurations of XS that don’t include the JS parser but would have use for  import module syntax.

[14:58:13.0287] <Kris Kowal>
And cases where a ModuleSource instance would have CSP origin information in the underlying host data, which would not be possible to construct with the ModuleSource constructor (unless generalized to thread trusted types)


2022-09-27
[05:08:54.0301] <littledan>
I will probably miss the call today since I am a bit sick 

