2022-07-01
[13:50:10.0331] <Kris Kowal>
Caridy (and by association Daniel) have convinced me that we can use `importMeta` as in `new Module(source, importHook, importMeta)` and in `importHook(importSpecifier, importMeta)` to stand in for a ‚Äúreferrer‚Äù and that every host environment would still be able to emulate every other host environment. The key is that `importMeta` is object identical in these cases so can be used to carry a gensym or as a key in a WeakMap, even though it‚Äôs not identical to the `import.meta` that the evaluated module sees (unless we change that in ecma262 too!).

[13:52:49.0047] <Kris Kowal>
Caridy and I have also come to an agreement that the next revision of the compartments proposal will reify the constructor named `Module` since we believe module harmony will likely mean `module {} instanceof Module`, where `Module(source, importHook, importMeta)` generates unlinked, linkable, initializable instances of modules.

[13:56:37.0723] <Kris Kowal>
I‚Äôve also agreed that there‚Äôs no need for the module constructor to _ever_ have an option to override the execution context of the module instances it creates. We can carve out a supplemental proposal for a reified `new ExecutionContext()` that would carry new evaluators `eval`, `Function`, and `Module` bound to the same \[\[Realm\]\]. Between `Module`, `ModuleSource`, and `ExecutionContext`, we would have everything we need to build compartments in user code. We could still go on to provide a `Compartment` constructor in the language, but the motivation would be ergonomics and performance, and would be entirely orthogonal to these primitives, which we agree ought to be exposed.

[13:58:01.0090] <Kris Kowal>
 * I‚Äôve also agreed that there‚Äôs no need for the module constructor to _ever_ have an option to override the execution context of the module instances it creates. We can carve out a supplemental proposal for a reified `new ExecutionContext()` that would carry new evaluators `eval`, `Function`, and `Module` bound to the same \[\[Realm\]\]. Between `Module`, `ModuleSource`, and `ExecutionContext`, we would have everything we need to build compartments in user code. We could still go on to provide a `Compartment` constructor in the language, but the motivation would be ergonomics and performance, and would be entirely orthogonal to these primitives, which we agree ought to be exposed.

[14:10:33.0757] <Kris Kowal>
I‚Äôve also convinced myself that, if module instances locally memoize the results of their `importHook` for both static and dynamic import, and since the import hook returns module instances, we can induce that import is sufficiently idempotent in aggregate to prevent all useful surprises. Compartments allow for those memos to be slightly more economical with memory, but probably not in any meaningful way in practice. Again, no reason we couldn‚Äôt have both in the fullness of time, but I‚Äôm convinced we should focus on the `Module` and `ModuleSource` primitives.

[14:12:03.0687] <Kris Kowal>
 * I‚Äôve also convinced myself that, if module instances locally memoize the results of their `importHook` for both static and dynamic import, and since the import hook returns module instances, we can induce that import is sufficiently idempotent in aggregate to prevent all useful surprises. Compartments allow for those memos to be slightly more economical with memory, but probably not in any meaningful way in practice. Again, no reason we couldn‚Äôt have both in the fullness of time, but I‚Äôm convinced we should focus on the `Module` and `ModuleSource` primitives.

[14:13:44.0585] <Kris Kowal>
I also believe that there is no better contender for the enormously self-assured name `Module`. My expectation is that `Module` will be backed by the Last Module Record type we ever need and that all meaningful extensions to the module system are different kinds of module source, not new kinds of module instance.

[14:19:03.0641] <Kris Kowal>
Caridy is focusing on a minimal layer that achieves parity with the current behaviors of ecma262, just reifying these two functions. I propose, in addition, that the `Module` constructor receives a ***Module Source Protocol*** implementation object, like `{bindings?, initialize?, needsDynamicImport?, needsImportMeta?}` which instances of `ModuleSource` happen to provide. This would be sufficient to define JSON, CommonJS, WASM, &c module sources in user code. However, that protocol would not be adequate to carry CSP information for vetted module sources and would not preclude the introduction of other host-defined module source classes. I expect only host-defined module source classes would be transmissible via structured clone and cary host-vetted origin metadata.

[14:21:24.0122] <Kris Kowal>
I‚Äôve also been convinced that the first argument to `initialize` should be called a ***Module Imports Namespace Exotic Object*** (not a reification of the entire definition of ***Module Environment Record***, just an exotic object that can be used to get and set the import and export bindings of the module, in its internal namespace.


2022-07-02
[19:45:36.0664] <Kris Kowal>
yulia: Goal: The ability to evaluate modules in isolated execution contexts and shared frozen intrinsics, or rather, a foundation on which that can be built.

[19:48:54.0163] <Kris Kowal>
That‚Äôs at least the pretext on which I can conscionably work on this as an Agoric delegate! As a JavaScript user, though, eval-but-for-modules has been a personal goal for a long while now. I proposed a `Module` constructor to TC39 in January of 2010!

[00:27:28.0346] <nicolo-ribaudo>
Kris Kowal I really like this new direction üëÄ


2022-07-03
[09:29:53.0611] <Jack Works>
> <@kriskowal:matrix.org> In any case, I sketched this, borrowing as much as possible from the Compartments proposal https://gist.github.com/kriskowal/288d38e62e55e09685bf62c3a3c25565

> The compartment will leave that promise to dangle, so an eventual rejection will necessarily go unhandled.

I don't agree with this part. If the module throws sync, it will become a sync error that can be caught, but if the promise dangles, I cannot handle it. This creates inconsistency in if module uses TLA or not

[09:35:26.0826] <Kris Kowal>
I also don‚Äôt like it, but couldn‚Äôt think of an alternative behavior. Answering that point consistently with the current host behavior would be ideal.

[09:36:05.0725] <Kris Kowal>
But also, if we reduce the scope to `Module` and `ModuleSource` constructors, I don‚Äôt believe we have to answer the question in our proposal.

[09:36:13.0433] <Jack Works>
Can't it spread to where the import happens? 

[09:36:52.0936] <Kris Kowal>
Is that the behavior of dynamic import for a module and its transitive dependencies when any of them contains top-level-await?

[09:37:05.0742] <Kris Kowal>
Genuinely, not an expert on TLA.

[09:38:03.0609] <Kris Kowal>
That is, does the promise returned by dynamic import settle only when all of the transitive dependencies settle for TLA?

[09:38:48.0534] <Jack Works>
And I wonder how much code I need to write in the user land for the housekeeping work (e.g. module caching stuff), so I can emulate a normal ES module environment (with some built-in modules and a relative path module resolution)? I would like to see an example. 

[09:39:35.0561] <Jack Works>
> <@kriskowal:matrix.org> Is that the behavior of dynamic import for a module and its transitive dependencies when any of them contains top-level-await?

I believe so, otherwise what should be the result of that dynamic import? 

[09:40:15.0764] <Kris Kowal>
The promise returned by dynamic import could settle after all first turns are completed.

[09:40:31.0928] <Kris Kowal>
Not that I think that‚Äôs sensible, but I don‚Äôt assume.

[09:40:43.0435] <Kris Kowal>
And I haven‚Äôt yet read :-)

[09:41:43.0331] <Kris Kowal>
In any case, I think it will be sufficient to fix that text to match whatever already exists, or delete it if we don‚Äôt have to specify the behavior in the module loader / compartments proposal.

[09:42:15.0129] <Kris Kowal>
As for how much needs to be done in user code, I need to write a sketch of implementing Compartment in user code, in terms of Module, ModuleSource, and ExecutionContext constructors.

[09:42:25.0313] <Kris Kowal>
I‚Äôm expecting to write a couple hundred lines.

[09:46:22.0302] <Kris Kowal>
Again, I know almost nothing about top-level-await, having not used it nor watched the proposal develop. Very much dependent on an expert to call out the right answer for sinking promises.


2022-07-04
[01:09:09.0166] <yulia | Out of Office until July 11th>
I am -sick as heck- y'all

[01:09:20.0802] <yulia | Out of Office until July 11th>
I will not be able to run the meeting on wednesday, or attend at all 

[01:09:31.0140] <yulia | Out of Office until July 11th>
shu: do we have an alternative facilitator?


2022-07-05
[02:27:08.0275] <Surma>
Can someone add surma@shopify.com to the calendar invite for the recurring Loader meeting?

[02:27:14.0599] <Surma>
yulia | Out of Office until July 11th: Hope you feel better soon!

[09:51:11.0876] <littledan>
Surma: Note that you may be able to add the whole TC39 calendar for yourself from https://calendar.google.com/calendar/u/0/embed?src=mozilla.com_l7b50itpaa9bnrvr61nebqrne8@group.calendar.google.com&ctz=America/Los_Angeles

[10:19:53.0276] <Surma>
> <@littledan:matrix.org> Surma: Note that you may be able to add the whole TC39 calendar for yourself from https://calendar.google.com/calendar/u/0/embed?src=mozilla.com_l7b50itpaa9bnrvr61nebqrne8@group.calendar.google.com&ctz=America/Los_Angeles

Yeah i did do that! Thank you! I'm just keen to get a reminder for this specific one ;)

[10:49:30.0117] <Kris Kowal>
> <@yulia:mozilla.org> shu: do we have an alternative facilitator?

I believe I should shadow a facilitator before I volunteer for that role, but if nobody steps up, I will definitely do my best impression. My understanding is that this mostly involves making sure agenda and minutes get captured, in addition to shepherding the meeting.

[10:53:22.0418] <Kris Kowal>
I‚Äôve sketched an agenda:
1. Overflow from my kick-off on Module Harmony thru the Compartments lens
2. nicolo-ribaudo on Module Harmony thru the lens of Module Blocks‚Äôs emerging spec text
3. caridy on minimum-viable first-class Module and ModuleSource

[10:57:36.0591] <Kris Kowal>
I believe yulia | Out of Office until July 11th had in mind some important front-matter to get us all on the same page for each other‚Äôs hopes and expectations from module harmony, which I think we ought to pursue as early as possible. I can also attempt to facilitate that, though I‚Äôm also not confident I can fill Yulia‚Äôs shoes.

[10:58:01.0167] <Kris Kowal>
That is, in fact, probably more important to articulate than any of the above.

[10:59:09.0463] <Kris Kowal>
To that end, please give me a thumbs up here if you‚Äôre prepared to speak to your own hopes and expectations of Module Harmony tomorrow.

[10:59:25.0990] <Kris Kowal>
Perhaps we can do a round-the-room.

[11:02:57.0355] <Kris Kowal>
(And of course, I hope any other convener can lead this conversation since I don‚Äôt expect anyone to trust my impartiality!)

[11:56:22.0627] <littledan>
I can help with convening if Yulia is out but at the same time maybe we should just wait until she gets back?

[13:27:00.0177] <Kris Kowal>
> <@littledan:matrix.org> I can help with convening if Yulia is out but at the same time maybe we should just wait until she gets back?

This would probably be wise, as the premise of this harmony group is to keep all stakeholders on the same page.

[13:28:38.0262] <littledan>
I'd like to propose, for an upcoming meeting, a discussion of how we've figured out how a lot of the space factors into three mostly orthogonal proposals (module reflection, module blocks/fragments, and the loader) since I think we made a lot of progress on that in the past couple weeks

[13:29:53.0281] <Kris Kowal>
Agreed. I‚Äôd also like to focus on how the points of intersection appear to be coherent.

[13:30:11.0313] <littledan>
top agenda item: How do we name ModuleInstance/ModuleBlock :)

[13:30:49.0793] <Kris Kowal>
I think with some effort over the next week, we could arrive at the harmonious conclusion: `Module`.

[13:31:44.0081] <Kris Kowal>
And the desugarring of `module {}` to `new Module()`.

[13:32:24.0406] <littledan>
hmm, maybe. I feel suspicious but I'm fine with that as a working title

[13:32:28.0927] <Kris Kowal>
It seems likely to me that, even if the notion of a `Compartment` survives, the notion of a module descriptor probably merges into `Module` instances.

[13:32:38.0358] <littledan>
(basically for the reasons you gave in your last presentation)

[13:32:45.0697] <Kris Kowal>
Yes, rightly suspicious.

[13:33:39.0187] <Kris Kowal>
Some of my thinking, chronicled above, has changed over the last couple weeks.

[13:35:00.0192] <Kris Kowal>
Since Caridy‚Äôs been challenging my assumption that 262 would need to subsume module maps. Nicol√≤ has also been moving in the direction of subsuming module maps. Not sure whether we‚Äôve crossed positions, but that would be funny.

[13:35:28.0963] <littledan>
huh, what do you mean by subsuming module maps?

[13:39:39.0171] <Kris Kowal>
And Nicol√≤ also learned this morning that HTML anchors module maps in an unexpected place: on module instances. That‚Äôs surprisingly consistent with what Caridy is proposing.

[13:41:30.0314] <Kris Kowal>
I mean that module maps are currently implied into existence by 262, through host behaviors. There isn‚Äôt a [[ModuleMap]], say, on a Realm record. (Qualifier: this is hearsay. I‚Äôm not sufficiently intimate with 262 to purport the non-existence of anything within its pages.)

[13:43:58.0724] <Kris Kowal>
Caridy‚Äôs driving toward a simplification of the compartment proposal that notably omits Compartment. I‚Äôm convinced that it‚Äôs functionally equivalent, even up to preserving all useful idempotence invariants and compatibility with our hardened JavaScript objectives. Omitting compartments effectively moves all module memoization behavior to a new kind of concrete Module Record, say, Virtual Module Record, which would be re√Øfied by a `new Module` constructor.

[13:45:11.0180] <nicolo-ribaudo>
(note: the specific word in html for module instances is "module scripts")

[13:45:16.0041] <Kris Kowal>
And I understand that you, Daniel Ehrenberg , provided the useful insight that the `importMeta` is sufficient to imply a referrer without having a dedicated referrer argument on a `Module` constructor.

[13:47:45.0526] <nicolo-ribaudo>
I have to think about this more, but after I talked with you (Kris) I'm convinced that my direction and how I understood Caridy's direction from you are not inconciliabile 

[13:48:14.0732] <nicolo-ribaudo>
Always assuming that compartments/"reified modules" are exactly as much powerful as hosts

[13:48:40.0726] <nicolo-ribaudo>
* Always assuming that compartments/"reified modules" are exactly as much powerful as hosts

[13:48:47.0516] <Kris Kowal>
My opinion is that, to use the name `Module`, it must be exceedingly worthy. That is to say, there must never come a time in the evolution of 262 that we reify an object that is worthier of the title or create a class where this particular kind of module is no more special that the others. I believe it meets that criterion iff it turns out that all specialization of modules going forward is sufficiently addressed with new types of Static Module Record.

[13:49:24.0368] <Kris Kowal>
> <@nicolo-ribaudo:matrix.org> I have to think about this more, but after I talked with you (Kris) I'm convinced that my direction and how I understood Caridy's direction from you are not inconciliabile

Is this to say, you believe these directions are compatible?

[13:50:26.0173] <Kris Kowal>
I‚Äôm hopeful that they are.

[13:50:27.0693] <nicolo-ribaudo>
Yes. The things I added in the modules block spec are all "spec internals", and they shouldn't affect the exposed API in any way

[13:51:09.0487] <littledan>
> <@kriskowal:matrix.org> And I understand that you, Daniel Ehrenberg , provided the useful insight that the `importMeta` is sufficient to imply a referrer without having a dedicated referrer argument on a `Module` constructor.

Caridy seems to have run with this further than I thought possible

[13:51:36.0108] <Kris Kowal>
We may have run together.

[13:51:45.0350] <Kris Kowal>
So I‚Äôll unpack what we learned.

[13:52:22.0681] <littledan>
> <@nicolo-ribaudo:matrix.org> (note: the specific word in html for module instances is "module scripts")

Can I also say that I don't like this name either? :)

[13:52:46.0362] <nicolo-ribaudo>
Yes, it's the most confusing name possible 

[13:52:59.0510] <Kris Kowal>
Assuming `new Module(source, importHook, importMeta)` is sufficient, `importMeta` is _not_ identical to `import.meta` as seen by the source, but _is_ identical to the object received by `importHook` to address the referrer, as in `importHook(importSpecifier, importMeta) => Promise<Module>`.

[13:53:54.0579] <Kris Kowal>
That is to say, that in user code, one can arrange a side table from `importMeta` to `referrer` and it‚Äôs sufficient that import hooks know about it.

[13:54:20.0126] <littledan>
I was thinking about it and... I'm not sure if importHook is at the same level as importMeta. At least, when serializing and deserializing a Module, you'll often preserve the importMeta and swap in a new importHook

[13:54:31.0417] <littledan>
(along with giving it a new identity)

[13:54:34.0452] <Kris Kowal>
That allows for the possibility, as is necessarily the case for some environments, that neither `import.meta.url` and `import.meta.resolve` are available for an `importHook` to use, much less necessarily trust.

[13:54:55.0388] <littledan>
"preserve" importMeta in an abstract sense, though--it will surely be a different object identity

[13:55:16.0374] <littledan>
> <@kriskowal:matrix.org> That allows for the possibility, as is necessarily the case for some environments, that neither `import.meta.url` and `import.meta.resolve` are available for an `importHook` to use, much less necessarily trust.

hmm, why?

[13:55:19.0284] <Kris Kowal>
Yes, `importMeta !=== import.meta`.

[13:55:29.0659] <littledan>
oh! really?

[13:56:07.0098] <Kris Kowal>
I should say, not necessarily ===.

[13:56:41.0635] <littledan>
now I'm even more confused

[13:57:15.0681] <Kris Kowal>
What i‚Äôm saying is that, for the purposes of this side table, importMeta as given to the constructor may be copied over an Object with a null prototype and all useful properties of import hooks are preserved.

[13:58:20.0869] <Kris Kowal>
I‚Äôm not saying that they can‚Äôt be identical. It probably wouldn‚Äôt be useful to create a new mechanism that allows `import.meta` to be a number or a proxy.

[13:58:43.0908] <Kris Kowal>
One way to do that would be copying properties. Another would just be to assert its nature. Asserting it‚Äôs not a proxy is somewhat hard.

[14:01:36.0314] <Kris Kowal>
> <@littledan:matrix.org> hmm, why?

Continuity with the past. The alternative is to suggest that this virtualization be limited to situations where `import.meta.url`, `import.meta.resolve`, or some other property carries the referrer in another host-defined sort of way. Not all existing environments meet that bar. I‚Äôm not suggesting this is a blocker. I‚Äôm suggesting that it‚Äôs definitely not a blocker. Those environments can be emulated with a side table keyed on `importMeta`, regardless of whether that‚Äôs identical to `import.meta`.

[14:03:00.0044] <Kris Kowal>
Which is to say, the problem I imagined with not enshrining `referrer` in the `Module` constructor, turns out to be imaginary.

[14:03:57.0442] <Kris Kowal>
Now, whether the same reasoning applies to module blocks remains mysterious to me.

[14:04:57.0207] <Kris Kowal>
That is, whether it is sufficient to serialize `import.meta` when reconstructing an equivalent module in another worker, as opposed to serializing a [[Referrer]] internal slot.

[14:05:20.0154] <Kris Kowal>
(To the extent that import.meta is serializable!)

[14:05:32.0049] <nicolo-ribaudo>
But isn't `import.meta` lazily-initialized (on first access), so potentially not available when transferring a module block?

[14:05:49.0158] <Kris Kowal>
As written today, yes.

[14:06:17.0434] <Kris Kowal>
Lazy initialization of `import.meta` could be copying properties from `importMeta`.

[14:06:38.0746] <Kris Kowal>
Regardless, if we relaxed the verbiage around lazy initialization of `import.meta`, the change wouldn‚Äôt be observable.

[14:13:34.0385] <Kris Kowal>
Bradley related to us at a SES call of yore that Node.js depends on this laziness to avoid instantiating an `import.meta.resolve` closure for every module. That gets created lazily on the first evaluation of `import.meta`. In the Compartments proposal, we solved that problem by adding a `needsImportMeta` property to `ModuleSource / StaticModuleRecord` instances such that a `loadHook / importHook` can avoid building an `importMeta` except for modules that are likely to need it, by reflecting static analysis.

[14:14:00.0523] <Kris Kowal>
Caridy‚Äôs direction preserves that solution.

[14:14:07.0004] <littledan>
> <@kriskowal:matrix.org> Regardless, if we relaxed the verbiage around lazy initialization of `import.meta`, the change wouldn‚Äôt be observable.

yeah it only seems observable given a sufficiently visible host

[14:14:12.0168] <littledan>
which, probably doesn't exist right now

[14:14:25.0545] <Kris Kowal>
It might with the experimental Node.js Loader.

[14:14:42.0819] <Kris Kowal>
I‚Äôm inclined to hope that we get ahead of that here.

[14:15:37.0886] <Kris Kowal>
And if a host virtualization hook is running synchronously during the first evaluation of `import.meta`, that seems needlessly foot-gunny.

[14:19:31.0752] <Kris Kowal>
shu, littledan We probably ought to decide and communicate a cancellation for tomorrow‚Äôs meeting. Are either of you positioned to reach all participants?

[14:20:50.0157] <guybedford>
FYI I posted https://github.com/whatwg/html/issues/8077 for making `import.meta.resolve` a generic resolver

[14:20:58.0108] <guybedford>
which might be a useful technique for loaders to get access to the global resolver

[14:21:39.0369] <guybedford>
Kris Kowal: are you referring to the SES or modules meeting tomorrow? Is this because we don't have someone to run it?

[14:22:46.0533] <Kris Kowal>
Yulia being absent leaves us without a convener, but more importantly, leaves us without an important stakeholder.

[14:23:08.0782] <Kris Kowal>
 * Yulia being absent leaves us without a convener, but more importantly, leaves us without an important stakeholder.

[14:23:19.0958] <guybedford>
It may still be useful to have the discussion if we can

[14:23:41.0109] <guybedford>
Didn't shu give host credentials to others as well?

[14:23:57.0164] <guybedford>
Has no one else come forward to assist with convening?

[14:23:59.0999] <Kris Kowal>
Yes, others can open the meeting.

[14:24:10.0675] <Kris Kowal>
Dan has come forward to assist with convening if we convene.

[14:24:40.0664] <guybedford>
Even if we don't have all stakeholders, we should still have notes to share and can continue to build some shared understanding on the matters

[14:25:01.0961] <littledan>
> <@guybedford:matrix.org> Didn't shu give host credentials to others as well?

Yes, I should have credentials in theory

[14:25:25.0512] <Kris Kowal>
I think there‚Äôs a hope that we move forward together. Discussions are obviously great, but we don‚Äôt want to assume that the shared context has advanced.

[14:26:26.0815] <Kris Kowal>
That is, if we have any module harmony conversations outside of these ‚Äúincubator‚Äù calls, we need to expect to present our findings again on the call.

[14:27:12.0793] <guybedford>
I think we are still very much in a phase of discovery here

[14:27:20.0939] <Kris Kowal>
This is true.

[14:27:30.0151] <guybedford>
so that it's less about decisions and more about continuing the conversations

[14:27:44.0755] <guybedford>
there's still a lot to discuss!

[14:27:49.0175] <Kris Kowal>
I read you‚Äôre in favor of having a conversation.

[14:27:59.0253] <Kris Kowal>
I‚Äôm also very aware that we have two weeks to plenary.

[14:28:15.0846] <Kris Kowal>
And that I have put my foot into the agenda.

[14:29:02.0790] <guybedford>
Myself and Luca at least would value giving a 10 minute update on where we would like to take import reflection, and before plenary, to ensure we don't step on any toes

[14:29:49.0113] <guybedford>
we want to ensure we're getting the cross-concerns right

[14:30:21.0675] <Kris Kowal>
One option is that I can reconvene the SES meeting.

[14:30:47.0953] <guybedford>
the hope for these meetings, at least for myself, was to be able to see how the pieces of the puzzle can fit together to form a wholistic picture

[14:30:57.0521] <Kris Kowal>
Same, agreed.

[14:31:14.0688] <nicolo-ribaudo>
> <@kriskowal:matrix.org> One option is that I can reconvene the SES meeting.

Aren't "SES meeting and let's talk about modules" and "Modules meeting" effectively the same thing?

[14:32:10.0259] <Kris Kowal>
No, we have an agreement that any findings from the SES meeting will be reprised at the Module Harmony group so that the broader group of stakeholders can stay in sync.

[14:32:41.0301] <nicolo-ribaudo>
Ok right, it would be good then. I don't think we should come to a "group decision" without all the important stakeholders

[14:32:42.0190] <Kris Kowal>
We can of course retcon our findings so we‚Äôre not presenting the incoherent ideas!

[14:33:19.0561] <littledan>
Not sure what you mean by "reprised" but yeah as Nicolo says the important thing is that we don't think of anything from SES as having reached a group decision, but instead having had some interesting discovery-oriented discussions

[14:34:02.0457] <Kris Kowal>
It‚Äôs also important that group decisions don‚Äôt come out of the modules harmony calls, but I think we‚Äôre mostly on the same page üòâ

[14:36:12.0614] <Kris Kowal>
In any case, I‚Äôm going to continue making slides and will expect to share them in one venue or another.

[14:36:41.0264] <Kris Kowal>
And it would be good for us to communicate a decision.

[14:40:08.0934] <guybedford>
It would be good to work through the slides further, it would also be good to have a few mins for us each to share our respective updates

[14:40:59.0020] <guybedford>
we could probably present the current import reflection thinking in about 5 - 10 mins

[14:41:18.0964] <guybedford>
we are actively seeking feedback

[14:42:04.0035] <guybedford>
would it be possible to complete the slides in 30-40 mins?

[14:42:19.0273] <guybedford>
would definitely be useful to continue building out the shared context

[14:42:39.0573] <guybedford>
or is the problem Kris Kowal that you would prefer to have Yulia present for that?

[14:43:55.0557] <Kris Kowal>
I intend to present an abbreviated deck from the overflow from the prior meeting.

[14:44:31.0470] <Kris Kowal>
I think Yulia would have kicked this meeting off with an around-the-room of each of our goals.

[14:45:03.0559] <Kris Kowal>
I‚Äôve asked Nicol√≤ to show what he‚Äôs learned over the last two weeks from writing up spec text for module blocks.

[14:45:40.0429] <Kris Kowal>
I‚Äôd be elated to give you guybedford the floor to sync up on import reflection.

[14:46:20.0478] <Kris Kowal>
Caridy will miss the first 20', but I‚Äôm hoping he gets a chance to share his vision for `Module` and `ModuleSource`.

[14:47:47.0291] <Kris Kowal>
And I think it‚Äôs not too premature to share his sketch (cc nicolo-ribaudo) https://gist.github.com/caridy/98f61cf6100243c3cecef5c16a4eff2d

[15:12:39.0329] <littledan>
Yeah well I'm up to convene/facilitate a discovery-oriented discussion as long as we plan to come back and reconsider things when stakeholders are available

[15:13:06.0684] <littledan>
so we can do this tomorrow at the time in the calendar if people want to

[15:24:42.0969] <Kris Kowal>
That at least has the virtue of not requiring last minute comms.

[15:24:54.0334] <Kris Kowal>
And also an extra half hour of talk time.

[15:38:20.0134] <Luca Casonato>
I will have to drop off at the top of the hour unfortunately, so it‚Äôd be great if we can cover import reflection some time in the first half of the meeting

[15:41:33.0124] <Kris Kowal>
I‚Äôm going to defer my overflow deck to a subsequent meeting. I‚Äôm writing Luca Casonato and guybedford into the agenda as the opening act.

[15:42:02.0314] <Kris Kowal>
Also moved Goals to the next meeting for Yulia.

[15:43:12.0521] <Kris Kowal>
The agenda is a writable link off the TC39 calendar invitation.

[15:45:07.0670] <Luca Casonato>
Thanks Kris


2022-07-06
[18:07:06.0251] <Kris Kowal>
I‚Äôve finished a deck for tomorrow, should time permit. I added this to the end of the meeting as it shows where I think we‚Äôre converging. https://drive.google.com/file/d/1_juf8l8PCrVHA4iA1G4BwQ1JsuXMjOVa/view

[23:53:28.0016] <Jack Works>
> <@kriskowal:matrix.org> I‚Äôve finished a deck for tomorrow, should time permit. I added this to the end of the meeting as it shows where I think we‚Äôre converging. https://drive.google.com/file/d/1_juf8l8PCrVHA4iA1G4BwQ1JsuXMjOVa/view

I like this. Where does the module descriptor go? 

[00:11:22.0336] <Kris Kowal>
Module descriptors cease to be necessary. When implementing a Compartment in user code, module instances replace module descriptors. User-mode Compartments aren‚Äôt able to address modules from the host compartment by name, but import reflection replaces that role.

[00:13:56.0058] <Kris Kowal>
e.g., `defer import fs from 'fs'; new Compartment{{ modules: { fs } }).import('fs')` is a possible solution with a user-code Compartment implementation.

[00:14:57.0283] <Kris Kowal>
(where `defer import` is import reflection. I haven‚Äôt seen a syntax I like for that yet, so just riffing here.)

[00:23:06.0820] <Kris Kowal>
Actually, for inter-compartment linkage, we would have to implement module-descriptors in user code.

[12:29:40.0452] <Kris Kowal>
Are any champions going to seek advancement for module proposals at the next plenary?

[12:30:40.0510] <Luca Casonato>
We are planning to seek stage 2

[12:32:21.0263] <Kris Kowal>
I propose that I repurpose the slot I‚Äôve reserved for compartments to deliver a module harmony, based on where we are as of this morning. My impression is that we need more work on module harmony before we have a proposal that can advance to Stage 2.

[12:33:30.0932] <Kris Kowal>
In my opinion, none of our proposals should advance until we have a shared foundation, and as far as I‚Äôm concerned, that shared foundation could be bundled into any proposal seeking stage 2 or greater.

[12:34:27.0119] <Kris Kowal>
By the shared foundation, I mean the modifications to the abstract module record hierarchy on which we all likely depend.

[12:35:22.0467] <Kris Kowal>
 * I propose that I repurpose the slot I‚Äôve reserved for compartments to deliver a module harmony report, based on where we are as of this morning. My impression is that we need more work on module harmony before we have a proposal that can advance to Stage 2.

[12:36:24.0472] <Kris Kowal>
 * By the shared foundation, I mean the additions to the abstract module record hierarchy on which we all likely depend.

[12:37:32.0950] <guybedford>
Kris Kowal: I'm not sure we should let specification editorial details block individual proposals. As long as each proposal is semantically sound, and we are tackling the shared interaction problems, I don't think we need to converge on sharing exact spec text between proposals especially at this stage.

[12:38:25.0970] <Kris Kowal>
For import reflection, I think the syntax pivot is good. I can see `import module` and `import static module`. I would be okay with `import static module` reifying the literal WASM `Module` object provided that it can be passed to a `new Module(wasmSource, importHook, importMeta)` when first-class modules come.

[12:40:00.0590] <Kris Kowal>
My understanding is that stage 2 requires tentative spec text. I‚Äôm asking that any proposal that advances have tentative spec text that is sufficient for any other module proposal to build upon.

[12:40:25.0575] <Kris Kowal>
I could be wrong. This is my first stage advancement rodeo.

[12:41:11.0948] <Kris Kowal>
But I believe the guiding principle is right: we should not paint ourselves into a corner that would preclude advancement of other proposals, or produce avoidable scar tissue.

[12:41:18.0814] <Kris Kowal>
 * But I believe the guiding principle is right: we should not paint ourselves into a corner that would preclude advancement of other proposals, or produce avoidable scar tissue.

[12:41:42.0719] <Kris Kowal>
But I‚Äôll qualify that: spec text scar tissue does not bother me. Reified object scar tissue does.

[12:42:10.0007] <guybedford>
Right, although Stage 2 is not an implementation stage

[12:42:24.0275] <guybedford>
Only at Stage 3 does scarring start to occur!

[12:43:10.0411] <guybedford>
In our current specification we defined the mechanics of the reflection, but we have left the actual reflection object being returned to be entirely defined by the host for now

[12:43:22.0001] <guybedford>
through a HostResolveModuleReflection hook

[12:43:36.0348] <guybedford>
our hope is that this is clear enough for stage 2, without being too prescriptive yet

[12:43:54.0298] <guybedford>
we would hope to refine for stage 3 some further invariants around the resolution and exact JS reflection object

[12:44:02.0690] <guybedford>
but for now we just treat it as host defined

[12:44:35.0315] <guybedford>
I would be interested to hear if that mitigates your concerns, the spec text PR is up at https://github.com/tc39/proposal-import-reflection/pull/21 and should be landing soon

[12:44:47.0021] <Kris Kowal>
I‚Äôll give it a read.

[12:45:26.0526] <Kris Kowal>
The invariant I would hope to preserve would be `new Module(x, ‚Ä¶rest)` would work for any `x` reflected by `import static module ...`.

[12:45:53.0729] <Kris Kowal>
And I would cut it as fine as differentiating `import module` from `import module static`.

[12:47:09.0639] <Kris Kowal>
I think it is important that `import module x from 'x.any'` should always produce `x instanceof Module` whereas there‚Äôre more degrees of freedom for `import static module x from 'x.any'`.

[12:47:26.0843] <guybedford>
as mentioned in the meeting, we are only interested in the `import module` being the `import static module` case you describe

[12:47:41.0074] <Kris Kowal>
I‚Äôm interested in both existing.

[12:47:41.0815] <guybedford>
we don't have a use case for the module instance reflection

[12:47:57.0458] <Kris Kowal>
Deferred execution is the motivating case for module instance reflection.

[12:48:05.0160] <guybedford>
specifically - what would the import hook be for an implicit instance reflection?

[12:48:39.0833] <guybedford>
deferred execution is not a use case of reflection either, and we have mentioned before this is separate specification work

[12:48:51.0661] <Kris Kowal>
import instance reflection would inherit the surrounding module instance‚Äôs import hook.

[12:49:37.0897] <Kris Kowal>
In my current mental model, these occupy overlapping syntactic space that should be coherent when we have solutions to both problems.

[12:49:47.0079] <guybedford>
it sounds very much like a deferred import

[12:49:51.0555] <Kris Kowal>
It is.

[12:49:58.0888] <guybedford>
That is Yulias area not ours

[12:50:24.0947] <guybedford>
I think it can be achieved but it is a separate specification to what we are working on with module reflection

[12:50:32.0196] <guybedford>
"reflection" by its nature is about a higher order import

[12:50:34.0997] <guybedford>
not an instance import

[12:50:52.0573] <Kris Kowal>
I do not mean to suggest that your proposal should solve both motivating use cases.

[12:51:07.0454] <Kris Kowal>
I do suggest that we are responsible for ensuring that these merge without conflict.

[12:51:36.0073] <guybedford>
it is our collective responsibility to not conflict eachother yes :)

[12:51:37.0690] <Kris Kowal>
I suggest that in the end we should have syntax for both cases.

[12:52:03.0680] <guybedford>
that's fine, and nothing is precluded

[12:52:25.0221] <guybedford>
specifically we have further constrained import reflection to module import reflection

[12:52:51.0516] <guybedford>
other proposals for other types of imports like assets or deferred execution can easily coexist

[12:52:54.0094] <Kris Kowal>
`import module x from 'x.js'` meaning x instanceof `WASM.Module` would preclude `import module x from 'x.js'` alternately meaning `x instanceof Module`.

[12:53:07.0575] <guybedford>
right but it doesn't preclude `import defer x from 'x.js'`

[12:53:22.0366] <Kris Kowal>
I agree that is possible.

[12:53:51.0490] <Kris Kowal>
In a universe with both, are we creating another footnote in WAT.js?

[12:54:11.0585] <guybedford>
if there is issue with the `module` term not being clear enough, we can consider other options

[12:54:19.0362] <guybedford>
the hope was too avoid too much of a bikeshed of course

[12:54:19.0804] <Kris Kowal>
```
import module x from 'x.wasm';
x instanceof Module; // false WAT?
```

[12:54:31.0687] <guybedford>
I hope we could consider this mostly aesthetic as opposed to a primary stage 2 concern

[12:55:14.0000] <Kris Kowal>
I‚Äôll grant this is aesthetic. What stage do aesthetics become a concern?

[12:55:48.0931] <Kris Kowal>
Soft concern for 2, hard concern for 3?

[12:58:46.0093] <guybedford>
From what I believe, stage 2 is expected to be complete specification but can still have open questions

[12:58:58.0353] <Kris Kowal>
I‚Äôll also grant that `import defer x from 'x.any'` has a nice ring to it.

[12:59:39.0632] <guybedford>
we'll make sure to highlight these points, this has been useful

[13:35:46.0505] <littledan>
I think we still have a number of foundational questions to answer, for all of the proposals we're discussing. A number of unresolved points of disagreement just came up in that meeting. I'm fine with things moving to Stage 2 as long as this is to be interpreted explicitly as "we agree that we want to move forward as a committee in this area, and have one concrete idea of how it might work, but we're still open to resolving these foundational questions in multiple ways"

[13:36:18.0817] <nicolo-ribaudo>
> <@guybedford:matrix.org> From what I believe, stage 2 is expected to be complete specification but can still have open questions

Stage 3 is complete specification, for stage 2 you need a draft 

[13:36:41.0320] <littledan>
I mean, module blocks seems to be one of these proposals which has these unresolved foundational questions, and it's already at Stage 2! But this is largely because it hadn't yet occurred to us that module blocks might be referrer-less, which Caridy is now advocating

[13:37:35.0721] <littledan>
I don't tend to agree with people who insist that all foundational questions be addressed by Stage 2. It's just too common for us to find that we need to revisit foundational issues during Stage 2. I think it's more that, Stage 2 indicates a level of interest/resolve to work things out, together with concreteness on *some* possibility

[13:37:51.0214] <littledan>
the bikeshed is definitely not a Stage 2 blocker

[13:39:02.0468] <littledan>
I think we should at least wait until Yulia is back to conclude that deferred module evaluation is separate from Guy's and Luca's proposal. I've heard multiple suggestions that these are really the same space. So if Stage 2 were to be taken to mean, "these are definitely separate"... I wouldn't be ready to say that yet.

[13:41:05.0854] <littledan>
Concretely, I hope we can all get more space to decide whether module blocks and reflective modules are ModuleSource or Module values. My expectation was that they were both Module, but Guy was proposing that reflective modules be ModuleSource, and Caridy was proposing that module blocks be ModuleSource

[13:41:17.0273] <littledan>
I think we can iterate on this question after Stage 2 but before Stage 3

[13:41:27.0307] <littledan>
 * I think we can iterate on this question after Stage 2 but before Stage 3

[13:43:17.0831] <littledan>
I was disappointed that asset references fell out of what Guy and Luca are proposing initially. I'd be interested in hearing more about what's behind that decision, and how soon you'd like to follow up with asset references, since they seem quite useful.

[13:52:14.0399] <littledan>
guybedford: Luca Casonato I'd be happy to have a call with you some time soon to discuss all this more if you're interested

[14:55:26.0362] <Kris Kowal>
Same

[14:56:06.0763] <Kris Kowal>
And I‚Äôm putting together a review to call out at least where I think we‚Äôre headed tentatively where it doesn‚Äôt match. Emphasis on tentative.

[14:56:52.0905] <Kris Kowal>
If I read the room right, I should hurry up and put together some spec text for first class modules (Module and ModuleSource) and shoot for the two.

[15:02:23.0610] <Kris Kowal>
And I think Caridy and I both suggest `module {} instanceof Module` and `static module {} instanceof ModuleSource`. Serializing ModuleSource is uncontroversial. Serializing Module is controversial. By the end of the call, I think we had agreement that Module, if serializable, is intentionally cherry picking the serializable subset of the instance. However, Caridy, Guy, Shu, and I all have misgivings. I have made peace with my misgivings.

[15:05:08.0714] <Kris Kowal>
My feeling is that trusting the sender and receiver to have identical importHook behavior is possible but fragile. But, if we have blocks, static blocks, `Module` and `ModuleSource` to work with, I think that the ecosystem will have everything it needs to come up with more sensible protocols for sending modules to workers.

[15:07:19.0410] <Kris Kowal>
That is to say, I predict that `worker.import(module {})` will look good in examples but will otherwise have limited utility. But, that‚Äôs okay with me.

[15:39:02.0649] <guybedford>
@littledan thanks for the feedback, we see module reflection as laying down an approach that asset reflection and deferred execution can follow in, as opposed to the original more abstract view of a generical mechanic. Trying to be practical and use case focused while treating generalization as a possibility but not to over-generalize. We are keen to see asset references and deferred module loading move forward, we are just trying to focus our efforts in a way that keeps scope clear in the staging process. We currently are underspecifying what exactly the shape of the reflection object is though, and treating this as a detail to be refined as opposed to prescribing it at this point. The way we do this for now is to entirely delegate it to a host hook, then the hope for Stage 3 would be to follow-up with an exact definition for JS that will hopefully have progressed by then. We need the host hook regardless for Wasm though.

[15:39:29.0094] <guybedford>
all good points, will do our best to address the various nuances!

[15:39:52.0568] <guybedford>
Definitely agreed feedback from Yulia is needed to progress in many of these discussions at this point

[15:43:55.0520] <Kris Kowal>
guybedford Am I correct that `new Module(wasmModule, importHook, importMeta)` where `wasmModule instanceof WebAssembly.Module` is a sensible way import reflection for WASM and first-class modules would compose?

[15:44:16.0523] <Kris Kowal>
That implies that the WASM module can both import and export.

[15:44:42.0370] <Kris Kowal>
Or is it only sensible to link WASM modules manually?

[15:44:44.0384] <guybedford>
Kris Kowal: that is definitely an option, and something to be discussed further

[15:45:09.0999] <guybedford>
We don't currently have a strong opinion on this

[15:45:16.0105] <guybedford>
definitely keen for more feedback

[15:45:35.0338] <Kris Kowal>
I would say that is less an option and more a requirement, in my opinion.

[15:46:01.0337] <Kris Kowal>
Unless web assembly modules are indeed merely resources.

[15:47:12.0831] <Kris Kowal>
And I think that decision pivots on whether there‚Äôs one or more sensible ways to interpret WASM as a participant in a module graph.

[15:48:56.0629] <Kris Kowal>
If there‚Äôs more than one way, I would lean more in the ‚Äúweb assembly modules are assets / resources that we want vetted for CSP, but require further programming to participate in a JS module graph‚Äù direction.

[15:49:51.0672] <Kris Kowal>
But if there‚Äôs one way that always works, I‚Äôd lean more toward putting them on equal footing with *static* module blocks and `ModuleSource` instances.

[15:53:05.0573] <guybedford>
From a loader perspective - if we used synthetic module wrappers that would involve using dynamic import to reentrantly load the dependencies. By making Wasm first-class module records they could participate in the module graph equally in the same execution algorithm as opposed to being treated as having reentrant dependencies which would otherwise deadlock for cycles

[15:53:44.0050] <guybedford>
Wasm doesn't strictly need cycles, but the point stands that it would involve user instrumentation for loader support using reentrant dynamic imports that could deadlock

[15:54:15.0961] <guybedford>
a lot of the questions are about expectations and how much work they will be to support in loaders certainly

[15:54:26.0104] <Kris Kowal>
That‚Äôs a lot to unpack.

[15:54:59.0450] <Kris Kowal>
I don‚Äôt think literal deadlock is on the table in any framing.

[15:55:39.0944] <Kris Kowal>
I also don‚Äôt think reentrance is on the table.

[15:57:03.0419] <Kris Kowal>
importHooks are recursive but non-reentrant. They would only run under dynamic import during the load phase, for growing the working set of module records.

[15:58:16.0596] <Kris Kowal>
I think WASM modules being inherently acyclic is handy, but I also think it‚Äôs possible to fully virtualize even ESM, including cycles.

[16:01:39.0273] <guybedford>
There are a bunch of complexities making them first class to delve into, perhaps we can go through the exercise some time

[16:01:39.0824] <Kris Kowal>
I think we agree actually that WASM modules _ideally_ participate in module graphs on equal footing with module sources. But, if there‚Äôs no sensible default behavior, virtualized module sources are certainly option. Caridy would point out though that virtual module sources don‚Äôt serialize and probably would also lose their CSP metadata.

[16:02:14.0310] <guybedford>
definitely could workshop some example workflows around loader instrumentation and Wasm

[16:02:18.0796] <Kris Kowal>
So ideally we find a good default behavior.

[16:02:20.0143] <guybedford>
and work through tradeoffs

[16:02:32.0466] <guybedford>
ideally having Dan and Caridy present for that would help

[16:02:49.0024] <Kris Kowal>
That would be a good exercise.

[16:04:59.0719] <guybedford>
I don't get the feeling it is too pressing right now

[16:05:09.0646] <guybedford>
or needed before this coming meeting

[16:05:31.0439] <guybedford>
but if it's something on your critical path there happy to arrange anytime

[16:08:33.0187] <Kris Kowal>
I think that‚Äôs necessary to answer the question of whether `WebAssembly.Module` should be reified as a module source or a resource. I‚Äôm pretty sure we need to know the answer before stage 2 since that constitutes a big difference in what you‚Äôd be proposing.

[16:09:15.0100] <Kris Kowal>
 * I think that‚Äôs necessary to answer the question of whether `WebAssembly.Module` should be reified as a module source or a resource. I‚Äôm pretty sure we need to know the answer before stage 2 since that constitutes a big difference in what you‚Äôd be proposing.

[16:11:05.0010] <Kris Kowal>
That is, if import reflection is `import module x from 'x.wasm'`, that‚Äôs only coherent if `x` is a module source and requires no further programming to participate in a module graph.

[16:19:19.0948] <Kris Kowal>
Follow-up question: Is this example coherent in your mental model:
```
import module x from 'x.wasm';
await import(x);
```

[16:20:06.0477] <Kris Kowal>
Oh, I know the answer already. That depends on the same exercise.

[16:22:52.0741] <guybedford>
yes exactly that is the question I think

[16:22:57.0208] <Kris Kowal>
(I don‚Äôt think the example is coherent, but if your answer is yes, that _would_ put WASM modules on equal footing with module blocks and imply that a WebAssembly.Module is linkable without further programming.)

[16:23:04.0894] <guybedford>
coherency is exactly the question there

[16:23:10.0071] <guybedford>
if we want Wasm and JS to work the same

[16:23:14.0078] <guybedford>
or if there will be this difference

[16:24:44.0550] <Kris Kowal>
I‚Äôm sure that your motivating use case is adequately addressed just by carrying CSP into WebAssembly.Module and never incorporating it in a JS module graph.

[16:26:09.0061] <Kris Kowal>
I guess it would be gross but not broken if `import module x from 'x.wasm'` was completely different than `import module y from 'y.js'`.

[16:27:31.0277] <Kris Kowal>
But if that‚Äôs the case and a WASM module can‚Äôt participate in a JS graph, you wouldn‚Äôt need anything from 262. WASM could just as well be a module that exports a CSP vetted default WebAssembly.Module.

[16:44:58.0503] <guybedford>
the problem is how you obtain the `WebAssembly.Module`, also this is a feature Wasm modules themselves in the ESM integration want to be able to get ahold of

[16:45:09.0674] <guybedford>
Wasm wants to be able to import its own records

[16:45:25.0845] <guybedford>
that's an important aspect of the component model

[16:46:15.0210] <guybedford>
there are also further static benefits and static security benefits over arbitrary URL fetching

[16:46:33.0378] <Kris Kowal>
I‚Äôm reading https://github.com/WebAssembly/esm-integration/tree/main/proposals/esm-integration

[16:47:05.0478] <guybedford>
See also https://github.com/WebAssembly/component-model/blob/main/design/mvp/Explainer.md#ESM-integration

[16:48:00.0866] <Kris Kowal>
Oh, wow. This depends on `as` notation.

[16:48:33.0999] <Kris Kowal>
Oh, I‚Äôm going to assume this just isn‚Äôt synced with your most recent work.

[16:49:53.0818] <guybedford>
yes exactly

[16:50:31.0405] <Kris Kowal>
Am I right that `esm-integration` answers the question that WASM does have a sensible way to integrate in a JS graph?

[16:51:19.0338] <Kris Kowal>
I‚Äôm reviewing your draft rn, and I noticed that your primary motivating case is the cases where the default integration isn‚Äôt sufficient.

[16:51:24.0734] <guybedford>
yes although the esm integration is currently awaiting our progress on reflection to move forward

[16:51:39.0009] <Kris Kowal>
Is it dependent?

[16:52:05.0868] <guybedford>
in some sense the solution space is dependent in that this is what is needed ergonomically right now

[16:56:52.0306] <Kris Kowal>
Well, I understand your conundrum better now.

[16:58:27.0491] <Kris Kowal>
Let‚Äôs assume `import module x from 'x.any'` produces `x` such that `x instanceof ModuleSource` and `import defer x from 'x.any'` produces `x` such that `x instanceof Module`.

[16:58:41.0822] <shu>
there is an inferior solution the wasm folks can choose without our involvement at all, by making the default kind of thing returned by `import 'x.wasm'` a `WebAssembly.Module` instead of an instance

[16:58:47.0025] <shu>
it breaks symmetry down the road, however

[16:59:36.0333] <Kris Kowal>
Right, I was about to propose that strawman until I started reading esm-integration, which suggests there is a reasonable default interpretation of a WASM module as it participates in a JS graph, importing and exporting.


2022-07-07
[17:00:13.0649] <shu>
i'm not sure it's reasonable, more that it's the path of least resistance

[17:00:15.0471] <Kris Kowal>
And taking esm-integration at face value, and stated assumption, there‚Äôs already a reasonable interpretation.

[17:01:37.0916] <Kris Kowal>
So, the question is whether it can be simultaneously true that `x instanceof ModuleSource` and `x instanceof WebAssembly.Module`, such that the former could be fed back into the JS module graph, and the latter could be used for manual instantiation.

[17:02:19.0603] <shu>
i don't think that can be done for the existing `WebAssembly.Module`

[17:02:34.0327] <Kris Kowal>
That seems like a problem.

[17:03:21.0839] <shu>
there are solutions the acceptability of which i'm unsure

[17:03:27.0906] <shu>
WebAssembly.Module.fromModuleSource

[17:03:36.0657] <shu>
WebAssembly.Module2

[17:04:12.0709] <shu>
WebAssembly.Instance.instantiateFromModuleSource

[17:04:15.0353] <guybedford>
this was where I was wondering if we might be able to define an internal slot on `WebAssembly.Module` that provided this relation in an internal way to 262

[17:04:21.0465] <guybedford>
that could then be incorporated into the esm integration

[17:04:41.0138] <shu>
yeah, where does the `instanceof` requirement come from

[17:04:48.0536] <shu>
it could be a deep-ish sense of duck typing

[17:04:51.0203] <guybedford>
or the wasm js api

[17:05:48.0139] <Kris Kowal>
Yeah, I was not precise. I specifically mean that x be a ‚Äúmodule source‚Äù if it could later be passed to `new Module(source, ...rest)` and the prototype chain is not material.

[17:06:23.0132] <shu>
ah, then i think that is possible

[17:06:29.0256] <Kris Kowal>
And I‚Äôve got slides in the overflow that `source` should fall through to a protocol.

[17:07:12.0854] <Kris Kowal>
For user virtualized module sources. That‚Äôs the escape hatch for defining bindings for, say, CommonJS in userspace.

[17:07:54.0722] <Kris Kowal>
So, yeah, stuffing an internal slot on `WebAssembly.Module` such that it could be digested by `new Module()` is acceptable to me.

[17:08:17.0024] <Kris Kowal>
Not just acceptable, a condition of my acceptance.

[17:08:59.0370] <Kris Kowal>
And guybedford we can punt on how to link ESM into a JS graph. That‚Äôs answered https://github.com/WebAssembly/esm-integration/tree/main/proposals/esm-integration

[17:10:13.0036] <Kris Kowal>
At least, I trust it does.

[17:10:19.0486] <guybedford>
my hope was not to have to flesh out such a protocol as a stage 2 requirement here by treating it as somewhat under-specified for now

[17:10:29.0690] <guybedford>
but if the feedback is to more clearly work this through we can investigate options

[17:10:59.0984] <guybedford>
I think the protocol likely belongs in the spec for the module source object

[17:11:22.0187] <Kris Kowal>
For stage 2, I can be satisfied if we know we‚Äôre not painting ourself into a corner, regardless of what‚Äôs captured in the proposal text.

[17:12:01.0916] <Kris Kowal>
The protocol for virtual modules is orthogonal and I only point it out because I expect the Module constructor to have overloads on its `source` argument.

[17:12:49.0858] <Kris Kowal>
Which is to say that it can brand check for `ModuleSource`, then brand check for `WebAssembly.Module`, then fall through to a virtualized module protocol.

[17:14:27.0968] <Kris Kowal>
The other wrinkle is that implementing a bundler or file watcher for all this is substantially easier of all ‚Äúmodule source‚Äù types have a uniform way to access the module source‚Äôs list of import specifiers.

[17:15:11.0898] <Kris Kowal>
As currently sketched, `moduleSource.bindings` is the same shape for `ModuleSource` and the protocol for virtual module sources.

[17:21:15.0699] <Kris Kowal>
> <@kriskowal:matrix.org> Which is to say that it can brand check for `ModuleSource`, then brand check for `WebAssembly.Module`, then fall through to a virtualized module protocol.

Or rather, check for [[StaticModuleRecord]] internal slot, which the former two would have.

[17:21:44.0096] <guybedford>
Yeah so the WebAssembly way of doing this is quite unique - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module/imports

[17:22:24.0495] <Kris Kowal>
Yeah, we‚Äôve discussed a protocol oriented around `source.constructor.imports(source)`, which we agreed would be Special‚Ñ¢.

[17:22:35.0365] <Kris Kowal>
 * Yeah, we‚Äôve discussed a protocol oriented around `source.constructor.imports(source)`, which we agreed would be Special‚Ñ¢.

[17:26:08.0919] <Kris Kowal>
Is there a reason that `WebAssembly.Module.prototype` couldn‚Äôt have a `bindings` accessor to throw bundlers a bone?

[17:28:02.0228] <guybedford>
I don't know, if we're adding branding in theory we could add other things, Dan might know more about what's involved here since he did a lot of the JS API spec work I believe

[17:29:38.0267] <Kris Kowal>
Well, I owe you a review, and I‚Äôm at least oriented. I can leave a note.

[17:30:02.0060] <Kris Kowal>
Thanks for playing Wheel of Spec Fiction‚Ñ¢.

[17:31:35.0134] <guybedford>
haha sure we've covered a lot! will take the winnings for now indeed

[17:33:21.0310] <Kris Kowal>
I have just noticed the pun in spec fiction. Who‚Äôs responsible for this!)/

[17:37:01.0485] <guybedford>
well we just call it specification I guess to begin with :P

[18:00:57.0227] <Kris Kowal>
I mean, this is clearly a pun on SpecFic, the category containing both Fantasy and SciFi https://en.wikipedia.org/wiki/Speculative_fiction

[19:50:17.0083] <Kris Kowal>
guybedford Luca Casonato I provided a review. I think it would be good to settle the question before plenary, whether a reflected module captures a module instance or a module source instance. I am pretty sure it must be the latter and the front matter for the proposal states the former. https://github.com/tc39/proposal-import-reflection/pull/21#pullrequestreview-1030806802

[21:28:50.0814] <guybedford>
Kris Kowal: I think it would align with Wasm better if the JS reflection can be treated as supporting arbitrary linkage as opposed to only host linkage

[21:29:06.0503] <guybedford>
Since that is effectively what you get with `WebAssembly.Module` so that would be the symmetric choice

[21:29:13.0708] <guybedford>
I'm open to the representation options though

[21:29:23.0378] <guybedford>
at the moment that object is still a big `?`

[21:29:43.0083] <guybedford>
thanks for the review, I've pushed some updated, do take another look if you have a moment

[21:33:39.0750] <Kris Kowal>
> <@guybedford:matrix.org> Kris Kowal: I think it would align with Wasm better if the JS reflection can be treated as supporting arbitrary linkage as opposed to only host linkage

I‚Äôm not sure what this means. What‚Äôs the limitation of what?

[21:34:18.0272] <guybedford>
Kris Kowal: a `WebAssembly.Module` has imports in its binary

[21:34:26.0928] <guybedford>
which are not yet satisfied and can be linked against arbitrary dependencies

[21:34:33.0746] <guybedford>
 * which are not yet satisfied and can be linked against arbitrary dependencies

[21:34:52.0421] <guybedford>
So the natural choice would be to aim for symmetry on that with the JS side

[21:35:13.0654] <guybedford>
That a JS reflection would not resolve its imports yet, but could still be instrumented against arbitrary dependencies

[21:35:25.0803] <guybedford>
depending on what hook is passed

[21:35:38.0493] <guybedford>
we could of course break that symmetry

[22:00:26.0122] <Kris Kowal>
That‚Äôs consistent with my interpretation of a module source.

[22:02:04.0874] <Kris Kowal>
That multiple `Module` instances can use a common source and link in different ways according to the provided `importHook`.

[22:03:30.0067] <Kris Kowal>
Caridy‚Äôs `Module` object is very similar to the `ModuleInstance` you proposed at the last plenary. The big difference is that dynamic import kicks off the loader / linker, and that uses the import hook to discover the linkage. It has the nice property that a single hook can be used for both static and dynamic import.

[22:04:06.0503] <Kris Kowal>
So instead of having to provide an `importHook` for dynamic import and a `link` method for static import, you just have `importHook`.

[22:04:47.0754] <Kris Kowal>
And the small difference is that each `Module` instance has an independent memo for the results of `importHook`.

[22:05:20.0978] <Kris Kowal>
It doesn‚Äôt account for assets and module reflection though, so I imagine we‚Äôll have to revisit that.

[22:09:33.0902] <guybedford>
one step at a time I guess

[22:10:06.0596] <Kris Kowal>
Yeah, assets and import reflection imply a different design for virtualized host hooks on `Module`. More like `fetchHook(specifier, importMeta) => Promise<TypedArray>` followed by `reflectHook(bytes, reflectionType) => unknown`

[22:10:42.0325] <guybedford>
right, I want to put some more thought to the cache questions in due course as well around this for reflection

[22:10:59.0231] <guybedford>
for now it's explicitly flagged as a spec todo to define the exact cache behaviours

[22:11:50.0395] <Kris Kowal>
I must say in the quiet of my heart that I‚Äôd hoped that virtualized module sources and externalizing the concern of interpretation such that each module has exactly one reification would put the issue of assets to bed.

[22:13:17.0413] <Kris Kowal>
And this wakes the old MIME-type / extension mismatch issue that drove import assertions into its current shape.

[22:13:46.0930] <Kris Kowal>
So, perhaps reification of module source is special and not general.

[22:14:35.0488] <Kris Kowal>
But even then, the host hooks have to separate loading from instantiation.

[22:16:18.0084] <Kris Kowal>
e.g., `loadHook(specifier, importMeta) => Promise<AbstractModuleSource>` and `importHook(source, importMeta) => Module`.

[22:22:08.0732] <guybedford>
the hope is to leave the internal invariants and host hooks in a better state that we found them

[22:22:18.0549] <guybedford>
I think between the specs that is achievable

[22:22:25.0939] <guybedford>
but it will take some formalizing yet

[04:29:46.0215] <littledan>
> <@guybedford:matrix.org> @littledan thanks for the feedback, we see module reflection as laying down an approach that asset reflection and deferred execution can follow in, as opposed to the original more abstract view of a generical mechanic. Trying to be practical and use case focused while treating generalization as a possibility but not to over-generalize. We are keen to see asset references and deferred module loading move forward, we are just trying to focus our efforts in a way that keeps scope clear in the staging process. We currently are underspecifying what exactly the shape of the reflection object is though, and treating this as a detail to be refined as opposed to prescribing it at this point. The way we do this for now is to entirely delegate it to a host hook, then the hope for Stage 3 would be to follow-up with an exact definition for JS that will hopefully have progressed by then. We need the host hook regardless for Wasm though.

Yes, going incrementally via the stage process seems generally good, but could you say more about why you decided to make the cut here exactly? I mean, presumably the host hook underspecification approach you describe would work just as well for asset references. Are there particular anticipated sources of complexity from asset references that you see as simpler for module reflection?

[04:32:16.0793] <littledan>
> <@kriskowal:matrix.org> My feeling is that trusting the sender and receiver to have identical importHook behavior is possible but fragile. But, if we have blocks, static blocks, `Module` and `ModuleSource` to work with, I think that the ecosystem will have everything it needs to come up with more sensible protocols for sending modules to workers.

In the web, I‚Äôm not sure if we need any ‚Äútrusting‚Äù here: the hooks simply are the same for native modules, and maybe we should just throw a DataCloneError if you try to serialize a Module with any other importHook

[04:34:44.0785] <littledan>
> <@kriskowal:matrix.org> That is to say, I predict that `worker.import(module {})` will look good in examples but will otherwise have limited utility. But, that‚Äôs okay with me.

Well‚Ä¶ this is much of the stated motivation of the proposal that Surma and I presented to committee and that the committee agreed to Stage 2 on. I am surprised to see so much skepticism on this point and interesting in understanding more about why you feel this way; I wonder what went wrong in communication that we didn‚Äôt uncover this disagreement sooner.

[04:37:51.0190] <littledan>
Wasm itself prohibits module import cycles, but the Wasm ESM integration proposal is designed to permit them between JS and Wasm‚Ä¶ but maybe it does so in too flaky of a way

[05:01:05.0384] <littledan>
I guess now that I hear more about how the caching for the import happens within the Module, rather than a single Module producing a separate instance somewhere else‚Ä¶ I understand why you all have been calling this construct ModuleInstance over the years 

[07:44:03.0294] <nicolo-ribaudo>
I'm re-reading the slides Kris Kowal presented yesterday, and I have a question.

In the example with a custom module source, I see that the `initialize` method receives `importMeta`. Does it also receive `importHook`? I'm trying do understand if/how Source Text Static Module Records could be expressed in terms of Virtual Static Module Records. For example, how could I create a custom module source that uses my own ecmascript engine and delegates module loading to the ecmascript host it's running in?

[07:59:24.0905] <Kris Kowal>
I think the answer is yes. JavaScript module sources can be virtualized. It‚Äôs also possible to implement `ModuleSource` as an object that satisfies the virtual module source protocol. But, I imagine that would come at a performance cost that isn‚Äôt acceptable.

[08:01:31.0444] <Kris Kowal>
For JavaScript to JavaScript bindings, I think engines are free to implement linkage as literal pointers to shared slots. Through the virtual module source protocol, reading and writing bindings would have to pass through the module imports namespace exotic object, which would be slow on top of slow.

[08:02:16.0958] <nicolo-ribaudo>
> But, I imagine that would come at a performance cost that isn‚Äôt acceptable.

Yes, I was thinking about something like eshost rather than a production thing.

[08:02:31.0070] <Kris Kowal>
You‚Äôre right that `initialize` needs to receive a dynamic import function. It would also have to be the one bound to the module instance‚Äôs memo.

[08:03:19.0416] <Kris Kowal>
And providing either `importMeta` or `dynamicImport` can be contingent on whether the module declares that it needs them with `needsImport` and `needsImportMeta` on its module source object.

[08:03:28.0278] <Kris Kowal>
So, an options bag.

[08:03:54.0227] <Kris Kowal>
I believe they can also participate in cycles.

[08:04:18.0938] <Kris Kowal>
The module imports namespace object was an idea that the folks on XS came up with.

[08:04:22.0468] <Kris Kowal>
It‚Äôs quite clever.

[08:04:50.0694] <Kris Kowal>
And they implemented it, and it works, so my confidence in the idea is pretty high.

[08:04:54.0138] <nicolo-ribaudo>
I guess my custom module source would also have to know how the import hook works, because it might need to pass a custom `importMeta` object when calling `importHook` to make sure that the "base URL" is correct and not the one of the entrypoint module.

[08:05:55.0890] <nicolo-ribaudo>
Ok well no, because `importHook` would return a _new_ module instance

[08:06:01.0463] <Kris Kowal>
Yes.

[08:14:22.0641] <littledan>
I'd like to invite Rob Palmer here, but I don't seem to have permission to invite people here

[08:15:02.0158] <nicolo-ribaudo>
Isn't this room public? So Rob just needs the link

[10:11:05.0184] <guybedford>
littledan: it's more about handling the consensus process itself, we don't want to try to do more than absolutely necessary to avoid unnecessary frictions. But yes asset references themselves should be relatively simple to spec and we are aiming to design host invariants that can work with that as well. The shape of the asset object may or may not be specified in ECMA-262, I'd personally like to see it in EMCA-262.

[10:18:21.0393] <littledan>
OK, I'd prefer to err on the side of trying to understand the full solution we're going after, even if having the design discussion risks some friction. I'm looking forward to hearing more of your thoughts on how asset references should work.

[10:19:38.0221] <littledan>
 * OK, I'd prefer to err on the side of trying to understand the full solution we're going after, even if having the design discussion risks some friction. I'm looking forward to hearing more of your thoughts on how asset references should work.

[10:22:15.0048] <littledan>
Once we understand that, it will help us prioritize what to push forward in the stage process and ship

[10:22:47.0861] <littledan>
I'm fine with Stage 2 for a bunch of this work while we're still in an undetermined state, though

[10:39:21.0649] <Kris Kowal>
> <@littledan:matrix.org> Well‚Ä¶ this is much of the stated motivation of the proposal that Surma and I presented to committee and that the committee agreed to Stage 2 on. I am surprised to see so much skepticism on this point and interesting in understanding more about why you feel this way; I wonder what went wrong in communication that we didn‚Äôt uncover this disagreement sooner.

importHooks are not equivalent between workers if they have either different import maps or service workers. Could even vary based on differences in local DNS.

[10:41:23.0428] <Kris Kowal>
However, consider the possibility that the receiver can create an importHook that calls back to the sender.

[10:59:16.0631] <Kris Kowal>
Daniel Ehrenberg: I don‚Äôt mean to communicate an absolutist stance. Even locally, there‚Äôs no guarantee that a module graph is consistent over time. But, on one extreme, sending a module to a worker is maximally fragile and on the other minimally fragile. I believe you and I agree that we‚Äôre converging on a foundation that is sufficient for implementing either extreme. And I think that we also agree that sending a worker and depending on out-of-band coordination of importHooks is a maximally fragile solution on that spectrum. And emphatically, I personally don‚Äôt object.

[11:00:24.0764] <Kris Kowal>
 * Daniel Ehrenberg: I don‚Äôt mean to communicate an absolutist stance. Even locally, there‚Äôs no guarantee that a module graph is consistent over time. But, on one extreme, sending a module to a worker is maximally fragile and on the other (sending a module with an RPC/IPC handle to the original loader) minimally fragile. I believe you and I agree that we‚Äôre converging on a foundation that is sufficient for implementing either extreme. And I think that we also agree that sending a worker and depending on out-of-band coordination of importHooks is a maximally fragile solution on that spectrum. And emphatically, I personally don‚Äôt object.

[11:01:56.0082] <Kris Kowal>
It‚Äôs also possible to have a sender and receiver with different but equivalent import maps, another case in which just sending the source and meta would work fine.

[11:08:23.0081] <shu>
what you call fragility i just think of "misconfiguration"?

[11:10:01.0795] <shu>
> <@littledan:matrix.org> In the web, I‚Äôm not sure if we need any ‚Äútrusting‚Äù here: the hooks simply are the same for native modules, and maybe we should just throw a DataCloneError if you try to serialize a Module with any other importHook

throwing seems good to me

[11:11:07.0019] <shu>
maximal virtualization is an explicit non-goal for me

[11:12:03.0011] <shu>
experience has shown me here that those APIs are a world of pain for implementation complexity and security

[11:52:52.0426] <littledan>
It's a bit hard to think about this problem space while generalizing over all well-behaved importHooks since we don't really have much of a definition for well-behaved here, but I'd venture: any well-behaved mechanism for serializing a ModuleInstance will need to be somewhat tightly coupled with the importHook

[11:54:34.0154] <littledan>
Although we'll be able to enforce some invariants by construction or through checks: if we ship a loader API, it will be possible to use importHook badly/confusingly, just as it is possible to use Proxy and even Object.defineProperty badly/confusingly today. These misuses would lack some desired properties but still be deemed OK by the system. I don't think that's fatal.

[11:55:09.0354] <littledan>
for the import map case: yes, I think the import maps would need to be sent "as part of" importMeta conceptually

[11:56:26.0763] <Kris Kowal>
I agree about the limitations of enforcing good behavior of import hooks. For every behavior we would want to prevent there is an equal but opposite valid use.

[11:56:56.0661] <littledan>
(well, the other case for import maps is to consider that they are closed over by the importHooks, i.e. just interpreted from what's loaded on the other side, since importHooks would not be part of HTML serialization. This is also coherent but I don't like it as much.)

[11:57:01.0404] <Kris Kowal>
I think it‚Äôs reasonable to fall back to local consistency per-instance.

[11:57:16.0868] <littledan>
 * (well, the other case for import maps is to consider that they are closed over by the importHooks, i.e. just interpreted from what's loaded on the other side, since importHooks would not be part of HTML serialization. This is also coherent but I don't like it as much.)

[11:58:47.0274] <Kris Kowal>
> <@littledan:matrix.org> for the import map case: yes, I think the import maps would need to be sent "as part of" importMeta conceptually

Hanging a reference to an import map on importMeta so the receiver can construct the appropriate importHook is a nice idea.

[11:59:01.0877] <littledan>
well, it can be an internal slot...

[11:59:09.0734] <littledan>
I dunno how much introspection we want to provide

[11:59:22.0688] <Kris Kowal>
Same.

[12:55:36.0331] <littledan>
Given the light TC39 agenda, I wonder if we should have an hybrid modules breakout session

[13:10:26.0597] <Kris Kowal>
I have a 90' slot to talk about compartments that I was thinking to repurpose as a Module Harmony preso, in the same vein as the last two presentations, if folks here are alright with me representing us collectively.

[13:11:07.0710] <Kris Kowal>
That is, here‚Äôs a strawman / holistic vision and here are some of the open questions.

[13:12:31.0383] <Kris Kowal>
I think that leaves a decent chunk of time for discussion, but it‚Äôs not like I‚Äôve ever finished a preso.

[13:13:02.0555] <littledan>
I think that, in this upcoming meeting, we aren't yet ready to present ourselves as a group beyond "we've been meeting and discussing these proposals"; it's premature to announce a holistic vision of the group, as opposed to just certain members of the group

[13:13:27.0695] <Kris Kowal>
Sure, so I should stick to, here‚Äôs where I think we‚Äôre headed with compartments.

[13:14:49.0351] <Kris Kowal>
I don‚Äôt think that precludes ‚Äúhow this might relate to blocks, deferred execution, and module reflection‚Äù but I agree that it‚Äôs too early to claim I‚Äôve internalized all the champions‚Äô perspectives.

[13:14:56.0870] <littledan>
yes, let's leave it to proposal champions to decide which open questions they want to bring to the committee. For example, I'd be a little uncomfortable having an all-committee debate on whether module blocks are ModuleSource or Module, at least just right now

[13:15:10.0142] <Kris Kowal>
I don‚Äôt feel like I‚Äôm far off, but I wouldn‚Äôt presume.

[13:15:55.0228] <Kris Kowal>
Oh, indeed. That would not be a fun conversation.

[13:16:10.0671] <littledan>
yeah I trust that you have a good understanding of at least Caridy's and my views on that particular question, but it's more that, we can let the individual champion decide when to encourage a large group discussion to draw a conclusion.

[13:18:38.0561] <Kris Kowal>
Caridy has a good intuition about what plays well at plenary, I think. I‚Äôll listen harder for the next couple weeks.

[13:19:30.0218] <shu>
simply, there is no agreement on the foundations yet, so i agree with dan's intuition to not present as a group nor open the floor to questions like "is this (e.g. ModuleSource) a good foundation"

[13:19:30.0990] <Kris Kowal>
For example, Caridy‚Äôs intuition for this last presentation was that we should only cover the first half üòâ Timing worked out, there.

[13:20:52.0479] <shu>
IME committee, or any gathering of strong technical folks, will have a tendency to engage on technical grounds if you lay out a technical question in front of them

[13:21:06.0361] <shu>
you should do that if you think you'll get good signals from it

[13:21:45.0703] <shu>
but it feels premature in that the signals you want are from the other champions right now

[13:21:56.0112] <Kris Kowal>
I‚Äôm pretty confident that we don‚Äôt need to discuss that particular question at plenary.

[13:22:09.0278] <shu>
 * you should do that if you think you'll get good signals from it

[13:22:47.0070] <shu>
that said there are larger motivation questions i would like plenary feedback on

[13:23:31.0109] <Kris Kowal>
Pray tell, and I‚Äôd be glad to ask.

[13:24:01.0006] <Kris Kowal>
Also will circulate a deck among folks here.

[13:24:11.0894] <shu>
1) is it a shared goal among us that we want ESM to be the graph that ties together disparate resources in a JS app?

[13:24:29.0911] <shu>
2) how widely shared a goal is virtualization, given standing disagreement from myself

[13:28:12.0659] <littledan>
this sounds more like a breakout session than a presentation

[13:28:40.0025] <shu>
fair

[13:29:15.0298] <shu>
for 1) especially, i only have a mild position

[13:29:16.0700] <littledan>
they do sound like very important questions to discuss, but it also sounds very complicated to run the discussion in a productive way

[13:30:00.0123] <littledan>
I think for 1) we could get a good read if someone presented on asset declarations and what they would mean for applications and tooling...

[13:30:05.0923] <shu>
 * for 1) especially, i only have a mild position

[13:30:14.0716] <shu>
i wish some of the MSFT folks would come

[13:30:17.0742] <shu>
they care so much about this i feel like

[13:30:28.0101] <littledan>
you mean the edge people working on html modules and such?

[13:30:30.0314] <littledan>
or which ones?

[13:30:33.0604] <shu>
yes, i mean those

[13:30:36.0777] <shu>
and constructable css whatevers

[13:30:51.0763] <littledan>
maybe we can get Dan Clark to come to this chatroom at least?

[13:31:01.0765] <shu>
indeed i'd love his opinions

[13:31:22.0497] <shu>
but it is also not clear to me who at MSFT is driving that programme

[13:31:27.0731] <littledan>
2) might come out in discussion on compartments... I guess none of the other proposals really get into virtualization, do they?

[13:31:31.0775] <shu>
is it dan? 

[13:32:32.0068] <shu>
i think currently that is correct, no other proposals really get into virtualization. there are one-off discussions of hooking points here and there

[13:44:51.0897] <Kris Kowal>
The compartments proposal does have an answer for virtualization that could be served a la carte.

[13:45:16.0432] <Kris Kowal>
Caridy‚Äôs subset does not include virtualization at all, and I think we will want to lead with that.

[13:46:43.0170] <Kris Kowal>
But module source virtualization is the key to unlocking many experiments in user code. Currently, we use this feature in Endo to create a bridge back to CommonJS that is coherent with bundling and other tools.

[13:47:45.0609] <Kris Kowal>
Reifying execution contexts can also be served a la carte.

[13:51:10.0206] <littledan>
importHook is exactly what you might call "virtualization"

[13:51:25.0057] <littledan>
like, it's more virtualized than what some hosts provide now

[13:55:41.0598] <Kris Kowal>
Pardon, yes, that is one of the two kinds of virtualization on the table.

[13:55:44.0072] <Kris Kowal>
 * Pardon, yes, that is one of the two kinds of virtualization on the table.

[13:56:15.0989] <Kris Kowal>
importHook virtualizes load and link. Virtual module sources virtualize initialization.

[13:56:20.0458] <littledan>
sorry, what is module source virtualization?

[13:56:58.0340] <Kris Kowal>
Module source virtualization is a module source protocol that allows a Module to be constructed from arbitrary other module types, e.g., CommonJS or assets.

[13:57:53.0693] <Kris Kowal>
`new Module({ bindings: [{export: 'default'}], initialize(namespace) { namespace.default = 42 }})`

[13:58:48.0036] <Kris Kowal>
That is separable if there‚Äôs appetite for one kind of virtualization but not the other.

[14:00:00.0117] <Kris Kowal>
Probably should be separated simply because it is separable and has different motivating use cases.

[14:02:45.0022] <littledan>
hmm should that be `new ModuleSource`?

[14:03:22.0765] <Kris Kowal>
No. The argument is a module source protocol.

[14:03:42.0147] <littledan>
oh I see

[14:03:42.0424] <Kris Kowal>
But I can see that being a valid interpretation.

[14:03:53.0358] <littledan>
yeah I like the idea of separating these two types of virtualization

[14:03:58.0987] <Kris Kowal>
In Endo, we borrowed Guy Bedford‚Äôs heuristic module exports lexer which is part of Node.js and trained it to also analyze imports. It generates a bindings array and we construct a function body wrapper.

[14:04:03.0532] <littledan>
they should hopefully be orthogonal, right?

[14:04:13.0662] <Kris Kowal>
They are fully orthogonal.

[14:04:14.0062] <littledan>
well, I guess you need importHook to tie them together

[14:04:17.0470] <Kris Kowal>
And fully coherent.

[14:04:32.0199] <Kris Kowal>
Pardon, module source virtualization does depend on module virtualization.

[14:04:33.0960] <littledan>
I mean, this is fully "step 2", you can't start with module source virtualization

[14:04:38.0465] <Kris Kowal>
But not the other way around.

[14:04:43.0899] <littledan>
right OK I think I get it

[14:05:29.0842] <Kris Kowal>
And execution context depends on step 1 but not step 2.

[14:06:12.0818] <Kris Kowal>
With reification of execution context and module link and load virtualization, we can build an ESM-only Compartment in user code.

[14:06:35.0247] <Kris Kowal>
 * With reification of execution context and module link and load virtualization, we can build an ESM-only Compartment in user code.

[14:07:36.0915] <Kris Kowal>
A reified execution context is just `new ExecutionContext(globalThis, importHook)` and has `{eval, Function, Module}`.

[14:08:52.0287] <Kris Kowal>
 * A reified execution context is just `new ExecutionContext(globalThis, importHook)` and has `{eval, Function, Module}`.

[14:09:31.0874] <Kris Kowal>
The `importHook` being for dynamic import in scripts.


2022-07-08
[07:56:33.0048] <nicolo-ribaudo>
I have a question that came up when thinking about module blocks, and maybe you already thought about it for the `Module` class. When importing in realm B a `Module` created in realm A, do you think that it should be evaluated in realm A or in realm B?
With cloning (or re-wrapping its `ModuleSource` in a new `Module`) it's obviously in realm B, but with same-domain iframes you can pass an object to another realm without cloning it.

[07:56:48.0498] <nicolo-ribaudo>
 * I have a question that came up when thinking about module blocks, and maybe you already thought about it for the `Module` class. When importing in realm B a `Module` created in realm A, do you think that it should be evaluated in realm A or in realm B?
With cloning (or re-wrapping its `ModuleSource` in a new `Module`) it's obviously in realm B, but with same-domain iframes you can pass an object to another realm without cloning it.

[08:19:44.0197] <Kris Kowal>
The module constructor should have a [[Context]] execution context internal slot that binds it to a realm.

[08:20:09.0166] <Kris Kowal>
That would be how we recover the isolation feature for compartments, which are also many-per-realm.

[08:20:32.0959] <Kris Kowal>
I believe this is analogous to `Function` constructor.

[08:20:50.0691] <nicolo-ribaudo>
Ok yes, thanks üëç It's exactly how functions work.

[08:21:25.0730] <Kris Kowal>
Our hope is to carve out a proposal for `ExecutionContext(globalThis, importHook)` that would yield a new set of evaluators, `eval`, `Function`, and `Module`.

[08:21:43.0107] <Kris Kowal>
Since that‚Äôs the last bit that makes it possible to implement compartments.


2022-07-09
[17:45:22.0808] <Kris Kowal>
I‚Äôm working on a sketch of what a user code Compartment looks like through the lens of Module, ModuleSource, and ExecutionContext https://gist.github.com/kriskowal/f48fb0c68a70ccbde7cd32c85cddc63c

[17:45:29.0908] <Kris Kowal>
 * I‚Äôm working on a sketch of what a user code Compartment looks like through the lens of Module, ModuleSource, and ExecutionContext https://gist.github.com/kriskowal/f48fb0c68a70ccbde7cd32c85cddc63c

[20:21:58.0290] <Jack Works>
Have a question

[20:22:26.0025] <Jack Works>
for example, I have a `const a = new Module(source, hook, meta)`

[20:23:20.0646] <Jack Works>
in which level it will execute twice? in different Realm? or in different `Module` constructor?

[20:23:27.0237] <Jack Works>
 * in which level it will execute twice? in different Realm? or in different `Module` constructor?

[20:35:48.0302] <Kris Kowal>
Once per object identity.

[20:58:39.0318] <Jack Works>
even it is used in multiple realms?

[20:58:52.0904] <Kris Kowal>
That is my understanding.

[20:59:37.0752] <Kris Kowal>
My understanding at the moment is that a module block corresponds to a `Module` instance, so locally it will only initialize once. But, every time a `Module` gets serialized and deserialized, it emerges as a new `Module` instance on the far side. The only parts of the module instance that are serialized are the `source` and `importMeta`, to the extent that `importMeta` is serializable, and the module instance is not memoized by the receiver.

[21:00:22.0038] <Kris Kowal>
The new `Module` instance would inherit the receiver execution environment‚Äôs import hook.

[21:01:40.0369] <Kris Kowal>
The module instance also has the [[Context]] internal slot that binds it to the original realm, so the namespace‚Äôs objects are guaranteed to be from the originating realm.

[21:02:31.0719] <Kris Kowal>
If we‚Äôre talking about same-origin `<iframe>` realms, still once because single identity.

[21:02:49.0600] <Kris Kowal>
If we‚Äôre talking about shadow realms, once per transit.

[21:04:21.0313] <Kris Kowal>
Though with shadow realms, assuming Static Module Records are treated as immutable after construction, transmitting between shadow realms or even between threads of the same process can be optimized. You still get fresh instances of the `Module` object, though.

[21:06:16.0688] <Kris Kowal>
And the reasoning for module fragments is that every module fragment has a unique `ModuleSource` consisting of the fragment and all the fragments it transitively depends upon, so each fragment is effectively equivalent to a single module block.

[21:08:59.0418] <Kris Kowal>
I think there are still open questions about the local semantics, like whether each evaluation of a module fragment produces a new `Module` instance, thus a new identity, thus a new namespace instance.

[21:09:58.0745] <Kris Kowal>
I suspect that‚Äôs the only reasonable answer, since module instances are superficially mutable. Having a singleton would create a covert communication channel.

[21:11:22.0226] <Kris Kowal>
The one hard rule is that a module block can‚Äôt write itself into the remote module map using the local key.

[22:08:40.0977] <littledan>
> <@jackworks:matrix.org> even it is used in multiple realms?

I can‚Äôt understand a case where multiple realms would permit importing the same Module. It seems like it should typically throw.

[22:13:43.0928] <Jack Works>
> <@littledan:matrix.org> I can‚Äôt understand a case where multiple realms would permit importing the same Module. It seems like it should typically throw.

Create 2 modules in 2 realms, and the import hook returns the same module object, does that module return by the import hook evaluate twice? 

[22:19:57.0822] <littledan>
My contention is that a well-behaved importHook would not do that 

[22:21:27.0898] <Jack Works>
But it is possible 

[22:22:25.0490] <littledan>
It simplifies a lot of things to have each Module run at most once

[22:23:22.0802] <littledan>
It is possible to use a Proxy in a poorly behaved way. We will need to define some kind of semantics for this case, but it doesn‚Äôt need to be pretty/perfect IMO

[22:23:27.0089] <littledan>
* It is possible to use a Proxy in a poorly behaved way. We will need to define some kind of semantics for this case, but it doesn‚Äôt need to be pretty/perfect IMO

[22:23:45.0079] <littledan>
* It simplifies a lot of things to have each Module run at most once

[22:24:34.0714] <Kris Kowal>
You‚Äôre suggesting that the dynamic import from one realm would fail to import a module from a realm with the wrong [[Context]]? (This seems fine to me.)

[22:25:51.0976] <Kris Kowal>
I too am fine with rough edges for same-origin-iframes. The language doesn‚Äôt set a high bar for sensible interactions with mixed intrinsics.

[22:27:38.0092] <littledan>
+10000

[22:28:26.0338] <littledan>
We may want to think about if we want a generic mechanism to serialize a Module over a ShadowRealm boundary but the answer isn‚Äôt ‚Äúit‚Äôs the same one‚Äù

[22:29:59.0705] <Kris Kowal>
I‚Äôm also not sure that there‚Äôs any meaningful way to distinguish dynamic import of a module from one realm to another. My impression is that using dynamic import to kick off the module system is not much more than a cute way to spell `Module.prototype.importMe`. The module object is important, the `import` ‚Äúfunction‚Äù doesn‚Äôt exist.

[22:31:09.0612] <littledan>
Right, since this is done by the importHook

[22:31:59.0249] <Kris Kowal>
Caridy did pass an idea in my direction that the `import` syntax _could_ convey a referrer. I think we both realized that it shouldn‚Äôt.

[22:32:36.0431] <Kris Kowal>
There‚Äôs just no need since the module has an associated importMeta, and it would cause more problems than it would solve.

[22:33:22.0977] <littledan>
As much as I love dynamic scoping, this situation calls for lexical 

[22:33:43.0723] <Kris Kowal>
Can‚Äôt tell if joke, but I‚Äôll chuckle anyway.

[22:34:14.0621] <littledan>
I do love dynamic scoping‚Ä¶ I don‚Äôt imagine I have many allies here in that

[22:35:07.0693] <Kris Kowal>
I might have been at some point. Maybe when I‚Äôm writing `bash`. I‚Äôd like to think I‚Äôd enjoy abusing gensyms and dynamic scope in Lisp.

[22:35:55.0671] <Kris Kowal>
Good feature for doing donuts in the parking lot and feeling clever.

[22:37:32.0541] <littledan>
Well it‚Äôs kinda what react-redux is based on, and I can‚Äôt think of a better design

[22:37:58.0477] <littledan>
Factor makes heavy use of dynamic scoping too‚Ä¶ helps when you have a stack-based language 

[22:38:56.0580] <Kris Kowal>
What the hell, I‚Äôll join you deep off-topic‚Ä¶

[22:39:36.0660] <Kris Kowal>
At some point when I was between jobs, I did an experimental component-based web framework I called Guten Tags.

[22:40:24.0029] <Kris Kowal>
It‚Äôs sort of a ‚ÄúWhat if HTML smelled more like Lisp‚Äù

[22:41:07.0910] <Kris Kowal>
So a tag on one level was effectively a function application that produced a component at that position in the surrounding context.

[22:41:24.0686] <Kris Kowal>
And on the level below that, tags were arguments, which would produce fragments.

[22:42:05.0727] <Kris Kowal>
And you‚Äôd just import tags from other Guten Tag modules, which of course also looked like HTML.

[22:42:56.0882] <Kris Kowal>
But it had a sort of hybrid of lexical and dynamic scoping inspired by CSS selectors like `:hover`.

[22:43:29.0926] <Kris Kowal>
So, imagine that HTML element id‚Äôs are lexically scoped.

[22:44:21.0272] <Kris Kowal>
But HTML elements are just instances of fragments from a different lexical closure that has its own id namespace.

[22:44:55.0199] <Kris Kowal>
So, it had this notation that was like `lexicalId:dynamicId`

[22:47:29.0908] <Kris Kowal>
Was sort-of like `<repeat id=loop value=todos><input type="text" value=todos:iteration></repeat>`, where `iteration` was a name identified in the lexical scope of the repetition.

[22:49:46.0694] <Kris Kowal>
That‚Äôd project into the real DOM as just a reactive sequence of inputs with their value reactively bound to the their respective iterand.

[06:41:21.0406] <Jack Works>
oh, looks like 3rd party SMR cannot fully emulate ES Module?

[06:42:24.0235] <Jack Works>
consider this code:

```js
// a
import { f_b } from 'b'
console.log(f_b)
export function f_a() {}

// b
import { f_a } from 'a'
console.log(f_a)
export function f_b() {}
```

[06:45:02.0908] <Jack Works>
It will be converted to:

```js
const a = {
    bindings: [{ export: "f_a" }, { import: "f_b", from: "b" }],
    initialize(env) {
        function f_a() {}
        env.f_a = f_a
        console.log(env.f_b)
    }
}

const b = {
    bindings: [{ export: "f_b" }, { import: "f_a", from: "a" }],
    initialize(env) {
        function f_b() {}
        env.f_b = f_b
        console.log(env.f_a)
    }
}
```

[06:47:23.0413] <Jack Works>
 * The best I can do using the ThirdPartyModuleRecord is this:

```js
const a = {
    bindings: [{ export: "f_a" }, { import: "f_b", from: "b" }],
    initialize(env) {
        function f_a() {}
        env.f_a = f_a
        console.log(env.f_b)
    }
}

const b = {
    bindings: [{ export: "f_b" }, { import: "f_a", from: "a" }],
    initialize(env) {
        function f_b() {}
        env.f_b = f_b
        console.log(env.f_a)
    }
}
```

[06:49:09.0048] <Jack Works>
> <@jackworks:matrix.org> The best I can do using the ThirdPartyModuleRecord is this:
> 
> ```js
> const a = {
>     bindings: [{ export: "f_a" }, { import: "f_b", from: "b" }],
>     initialize(env) {
>         function f_a() {}
>         env.f_a = f_a
>         console.log(env.f_b)
>     }
> }
> 
> const b = {
>     bindings: [{ export: "f_b" }, { import: "f_a", from: "a" }],
>     initialize(env) {
>         function f_b() {}
>         env.f_b = f_b
>         console.log(env.f_a)
>     }
> }
> ```

This cannot emulate the ES Module above, because it is basically the equivalent of `export let f_a = ...` instead of `export function f_a() ...`

[06:50:47.0856] <Jack Works>
And SystemJS format can emulate this behavior:

```js
System.register([
    "b"
], function(_export, _context) {
    "use strict";
    var f_b;
    function f_a() {}
    _export("f_a", f_a);
    return {
        setters: [
            function(_b) {
                f_b = _b.f_b;
            }
        ],
        execute: function() {
            console.log(f_b);
        }
    };
});
```

There are 2 stages in system js, the hoisted function declaration is set in stage 1, and the actual runtime code is run in stage 2 (`execute`).

[06:51:49.0057] <Jack Works>
I wonder if we can solve this problem in ThirdPartyModuleRecord (or it's new name `VirtualModule`?)

[06:59:47.0523] <Jack Works>
Also, I cannot emulate both `export var` (No TDZ) and `export let` (TDZ) without 2 stage initialization

[06:59:57.0951] <Jack Works>
 * Also, I cannot emulate both `export var` (No TDZ) and `export let` (TDZ) without 2 stage initialization

[13:23:36.0287] <Kris Kowal>
It looks like this could be addressed by having virtual module sources expose an object analogous to the SystemJS `setters`.

[13:25:43.0637] <Kris Kowal>
That is, `{ bindings: Bindings, initialize(readFromHere, {import, importMeta}) => void, writeToHere }`, by whatever names.

[13:26:33.0092] <Kris Kowal>
(formally ignoring optionality and the needs* properties)

[14:57:34.0491] <Kris Kowal>
Hm, that‚Äôs not quite right. The writer can‚Äôt be a property of the static module record.

[14:58:03.0584] <Kris Kowal>
But, for one, being able to emulate ESM is a stretch goal for the virtual module record. The subset is sufficient for most cases.

[14:58:43.0787] <Kris Kowal>
The SES shim has a protocol analogous to SystemJS, though, but calls the setters notifiers.

[15:30:36.0298] <Kris Kowal>
Ah, I see. The trick to supporting ESM with the virtual source module protocol is that all access and mutation to variables in the ‚Äúimports namespace‚Äù needs to be rewritten to properties of the the environment object. I haven‚Äôt checked into how realistic that is, but it likely means that all var and function hoisting would have to be physically hoisted.

[15:31:18.0256] <Kris Kowal>
I think it‚Äôs possible but not clean.

[15:33:12.0751] <Kris Kowal>
In SES, we have a self-imposed requirement that ESM sources need to be debuggable without source maps, with preservation of line numbers and, as often as possible, column numbers. That simply wouldn‚Äôt be possible with the virtual source protocol and requires write barriers / notifiers.


2022-07-10
[20:42:25.0111] <Jack Works>
there are 2 things in the language have this property, `export function` and `export var`.

[20:42:48.0901] <Jack Works>
I can see two way to solve this problem but they all have their own problems

[20:46:35.0513] <Jack Works>
 * I can see ~~two way~~ only one way to solve this problem but they all have their own problems

[20:46:44.0933] <Jack Works>
 * I can see <del>two way</del> only one way to solve this problem but they all have their own problems

[20:49:10.0706] <Jack Works>
having two stage initialization for virtual modules, just like systemjs

```js
const record = static module {
    export function a() {}
    console.log(a)
}
```

becomes

```js
const record = {
    bindings: [{export: "a"}],
    initialize(env, context) {
        function a() {}
        env.a = a
        return () => {
            console.log(a)
        }
    }
}
```

[20:50:55.0395] <Jack Works>
but the problem is, it is allowing the virtual module to run some arbitrary code _before_ the evaluation stage

[20:59:30.0439] <guybedford>
That's correct about the emulation. But SystemJS has very different contraints of course, and yes likely doesn't fit this model. If needing this level of parity you might be better off just using a static record from a string source to do the emulation I think, then passing bindings through import.meta or custom imports?

[21:02:19.0314] <Jack Works>
I'm considering (and my use case need) an eval-free version of downlevel compiling module blocks, so I hope the Virtual Module can do the full emulation

[21:06:16.0606] <Kris Kowal>
What if `a` is rewritten to `env.a` at every mention?

[21:07:03.0799] <Jack Works>
> <@kriskowal:matrix.org> What if `a` is rewritten to `env.a` at every mention?

The problem is circular reference + function hoist

[21:07:29.0385] <Jack Works>
Consider these two modules compiled into Virtual module:


```js
import {b} from './b'
export function a() {}
console.log(b)
```

```js
import {a} from './a'
export function b() {}
console.log(a)
```

[21:08:12.0959] <Jack Works>
 * Consider these two modules compiled into Virtual module:


```js
import {b} from './b'
export function a() {}
console.log(b)
```

```js
import {a} from './a'
export function b() {}
console.log(a)
```

[21:11:05.0939] <Jack Works>
oh wait, this works. let me consider that again

[22:06:46.0741] <Jack Works>
 * <del>oh wait, this works. let me consider that again</del>

[22:08:31.0525] <Jack Works>
I compared it with CommonJS (because the code above works after being compiled into CommonJS).

[22:10:49.0976] <Jack Works>
```js
const record = {
    bindings: [],
    async initialize(env, context) {
        function a() {}
        env.a = a
        
        const mod = await context.import("./b")
        console.log(mod.b)
    }
}
```

[22:13:00.0626] <Jack Works>
So CommonJS behave more like this. They also have a "pre-evaluation" to setup those bindings (before and after `require` calls)

[22:16:02.0380] <Jack Works>
 * So CommonJS behave more like this. They also have a "pre-evaluation" to setup those bindings (before and after `require` calls)

```js
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "b", {
    enumerable: true,
    get: ()=>b
});
const _a = require("./a");
console.log(_a.a);
function b() {}
```

[22:17:07.0974] <Jack Works>
 * ```js
const record = {
    bindings: [],
    async initialize(env, context) {
        function a() {}
        env.a = a
        
        const mod = await context.import("./b")
        console.log(mod.b)
    }
}
```

But this is problematic because of then-able

[00:04:55.0963] <Jack Works>
I can think of some way to alleviate this problem, to make `env` and `context` in some kind of dead zone in this pre-evaluation stage, which means

```js
    initialize(env, context) {
        // when in here, context is an empty object with no "meta" or "import" property on it
        // when in here, any other property access than "a" throws a TDZ error
        function a() {}
        env.a = a
        return () => {
            // now access env and context is ok
            env.console.log(a)
        }
    }
```

Construct all assets => Link stage => Pre-evaluation (run all `initialize` function with TDZ `env` and `context` and collect the return closure) => `env` and `context` out of TDZ => Evaluation


2022-07-11
[08:05:08.0596] <Kris Kowal>
yulia: Welcome back. Hope you‚Äôre feeling better.

[08:05:18.0996] <yulia>
thank you!

[08:05:25.0003] <yulia>
i am still catching up on things

[08:05:50.0615] <yulia>
i did see the mention regarding whether or not the lazy loader case is subsumed by exposing the loader internals. it is something i've thought of a lot myself

[08:06:55.0634] <yulia>
I had some feedback from developers recently, who are concerned that things are about to get a lot more complicated, and also that `lazy` doesn't mean much to them. It is more of a hint for engines. People however resonated with something like `pure` or `library`. These terms may be more meaningful from a developer perspective than exposing low level blocks (which are independently useful), or something to oriented towards engines like `lazyInit`

[08:07:20.0389] <yulia>
so, I think there is still a reason to explore a higher level, opinionated api -- it may communicate programmer intention better

[08:07:58.0835] <yulia>
i need to catch up on the discussions that happened here more first, before anything

[08:13:01.0063] <yulia>
 * I had some feedback from developers recently, who are concerned that things are about to get a lot more complicated, and also that `lazy` doesn't mean much to them. It is more of a hint for engines. People however resonated with something like `pure` or `library`. These terms may be more meaningful from a developer perspective than exposing low level blocks (which are independently useful), or something to oriented towards engines like `lazyInit`. This achieves the same goal as `lazyInit`, but is meaningful for both engines and developers on the same rubric. No global state modification, safe to defer, etc. 

[11:47:53.0090] <Kris Kowal>
Having both high and low level APIs sounds reasonable to me. That reasoning might apply to compartments, though the low-level design would certainly inform the high-level design. I sketched high-level Compartment in terms of low-level Module and ModuleSource. https://gist.github.com/kriskowal/f48fb0c68a70ccbde7cd32c85cddc63c

[11:51:26.0822] <Kris Kowal>
I think low-level import reflection or deferred import do obviate one complication of the Compartment design (as written right now), regarding how to communicate a module source or module instance from a host compartment to a child compartment. That isn‚Äôt possible to express in terms of the low-level parts, which compels the developer to use import reflection or deferred import explicitly. That might be a good outcome, even for XS. Currently XS depends on a manifest to express the full working set, but these features together would allow tooling to take over more of the tedium.

[11:55:23.0751] <Kris Kowal>
In any case, for plenary, I hope to have a deck ready tomorrow that shares an update on the evolution of the compartments proposal over the last couple of years that decomposes it into smaller proposals, starting with low-level first-class Module and ModuleSource and ending in Compartment.

[11:55:50.0821] <Kris Kowal>
There appear to be four separable layers.

[14:14:19.0645] <shu>
btw could we get a volunteer to run the next call?

[14:37:34.0376] <littledan>
by "run the next call" do you mean what I did in the last call or something else?

[14:37:39.0525] <littledan>
I'm fine repeating what I did

[14:46:13.0494] <shu>
i mean what you did last call, yes

[14:46:16.0417] <shu>
excellent


2022-07-12
[22:47:05.0201] <Jack Works>
where is the module instance cache stored? ExecutionContext? Realm?

```js
const mod = module { console.log('run') }
const mod2 = static module { import 'mod' }

await import(new Module(mod2, async () => mod), {})
await import(new ExecutionContext.Module(mod2, async () => mod, {}))
```

[22:47:15.0269] <Jack Works>
how many time `mod` is executed?

[23:41:59.0001] <nicolo-ribaudo>
I would expect it to only be executed once in the original execution context (the one where the module block expression was evaluated).

[23:42:26.0208] <nicolo-ribaudo>
The cache could be a [[ModuleRecord]] internal slot on the Module object 

[01:03:47.0345] <Jack Works>
ok thanks!

[02:02:20.0578] <yulia>
> <@kriskowal:matrix.org> I think low-level import reflection or deferred import do obviate one complication of the Compartment design (as written right now), regarding how to communicate a module source or module instance from a host compartment to a child compartment. That isn‚Äôt possible to express in terms of the low-level parts, which compels the developer to use import reflection or deferred import explicitly. That might be a good outcome, even for XS. Currently XS depends on a manifest to express the full working set, but these features together would allow tooling to take over more of the tedium.

Yes, it feels like import reflection and deferred import evaluation are both doing the same thing in that they hide some of the complexity that a full-access low level api would give. Module loading is quite complex, so choosing what should be hidden and how is probably a good idea. I do worry though that we will add a lot of things to the static import statement / dynamic import options bag, and that will confuse people (as i've already had feedback on that). But this is a concern for later. 

[03:29:09.0525] <Jack Works>
I found we need a `isAsync` property on the Virtual Module.

[03:29:56.0412] <Jack Works>
`Cyclic Module Records` requires [[isAsync]] which is not possible for Virtual Module because it does not have a source text to be parsed.

[05:55:27.0999] <Jack Works>
I'm working on a polyfill for `Module`

https://github.com/DimensionDev/aot-secure-ecmascript/blob/2e45ecaf9d45efce1661b8df106ba421817f0fa5/packages/compartment/src/Module.ts

[07:53:27.0740] <Kris Kowal>
I had wondered about that and XS managed to make it work without it. Very good to know.

[07:53:38.0009] <Kris Kowal>
It might be a spec bug. ü§∑‚Äç‚ôÇÔ∏è

[08:39:48.0197] <Jack Works>
> <@kriskowal:matrix.org> I had wondered about that and XS managed to make it work without it. Very good to know.

XS have JS source at build time, they can know if the module has TLA or not.
We need to manually mark it for virtual modules (like `needsImportMeta`), otherwise I guess we need to rewrite the spec a lot.

[10:05:47.0191] <Kris Kowal>
XS also implemented a draft of the virtual module source protocol.

[10:06:24.0910] <Kris Kowal>
And they are of the opinion that the virtual module source doesn‚Äôt have to reveal whether initialize() returns a promise or not.

[10:06:45.0875] <Kris Kowal>
Though, if it is necessary, it is not a problem to require it to be reflected on the virtual module source object.

[10:07:31.0494] <Kris Kowal>
Just might be worth inquiring with vendors whether the spec can be relaxed. Module records capture a lot of details from multiple conflated layers that get initialized at different stages.

[10:16:55.0026] <Kris Kowal>
Clarification:

```js
const mod1 = module { console.log('run') };
const src2 = static module { import 'mod' };
const ctx2 = new ExecutionContext(globalThis);
const mod2 = new ctx2.Module(src2, async () => mod1);
await import(mod1);
await import(mod2);
```

I expect this to log run once from the host execution context.

[10:17:24.0848] <Kris Kowal>
 * Clarification:

```js
const mod1 = module { console.log('run') };
const src2 = static module { import 'mod' };
const ctx2 = new ExecutionContext(globalThis);
const mod2 = new ctx2.Module(src2, async () => mod1);
await import(mod1);
await import(mod2);
```

I expect this to log run once from the host execution context.

[10:18:17.0045] <Kris Kowal>
Linking modules between independent execution contexts is an explicit goal out to full Compartment parity, for supply chain isolation.

[10:18:35.0517] <Kris Kowal>
And notably, shared intrinsics between separate execution contexts.

[15:04:12.0889] <Kris Kowal>
262 lawyer question: Is it already the case that there can be multiple execution contexts in a single realm? https://tc39.es/ecma262/#sec-execution-contexts

[15:04:51.0005] <Kris Kowal>
I suppose the answer might lie in the details of generator, async, async generator functions.

[15:06:10.0570] <littledan>
isn't the callstack a stack of execution contexts?

[15:06:11.0155] <Kris Kowal>
(Trying to discover whether ‚Äúreify execution context‚Äù is the right title for the end boss for compartments.)

[15:06:56.0596] <littledan>
there's always one active execution context within a Realm, and you keep switching between them

[15:07:08.0252] <littledan>
at most, one active

[15:07:08.0974] <Kris Kowal>
Got it.

[15:08:05.0604] <Kris Kowal>
So, ‚Äúreify execution context‚Äù is not yet disqualified.

[15:08:17.0584] <littledan>
well, I'm not sure what you mean

[15:08:19.0568] <shu>
whoa, reify execution contexts?

[15:08:31.0456] <shu>
what information are you trying to surface? that seems like not a good idea

[15:08:33.0471] <Kris Kowal>
Yeah, so that‚Äôs a hint I‚Äôve got the wrong word.

[15:08:34.0172] <littledan>
isn't "reify local scope" really the final boss?

[15:08:45.0660] <shu>
`localThis`

[15:08:56.0476] <Kris Kowal>
That‚Äôs definitely not what we‚Äôre looking for.

[15:09:52.0557] <Kris Kowal>
Though, when I was young and silly, I used to think that‚Äôs exactly what I wanted from my programming language.

[15:10:15.0009] <Kris Kowal>
‚ÄúPrototype chains and scope chains are basically the same thing. Let‚Äôs just have one of those.‚Äù

[15:10:20.0263] <Kris Kowal>
I got better.

[15:10:46.0994] <littledan>
too bad you missed out on Io in your youth

[15:10:54.0846] <littledan>
that's what I played around with before I found Factor

[15:11:34.0179] <littledan>
arguments can be sent to functions un-evaluated, and then the function can evaluate them in the context of the calling lexical scope!!! and it's all prototypes

[15:11:35.0741] <Kris Kowal>
My youth was pretty mundane in terms of PLT, except for the bit with church numerals in DOS 6.2 BAT files.

[15:11:40.0663] <Kris Kowal>
 * My youth was pretty mundane in terms of PLT, except for the bit with church numerals in DOS 6.2 BAT files.

[15:11:49.0098] <littledan>
was Tcl around then?

[15:12:10.0222] <Kris Kowal>
Hey, that‚Äôs what Guten Tags does :-)

[15:12:16.0362] <littledan>
Io makes the scope chain *literally* a prototype chain

[15:12:23.0791] <Kris Kowal>
Tcl was definitely on my tour of programming languages.

[15:12:37.0817] <Kris Kowal>
> <@littledan:matrix.org> Io makes the scope chain *literally* a prototype chain

I would have enjoyed that, indeed.

[15:12:54.0291] <littledan>
see, Tcl isn't as general as Io since the subexpressions just evaluate

[15:17:27.0051] <Kris Kowal>
In any case, resisting digression. The last bit of compartments is being able to isolate modules and scripts such that they execute with a global environment record or module environment record that closes over a particular global object, eval behavior, and dynamic import behavior. Every instance of `Function`, `Module`, and `eval` object has an internal slot that points to whatever this is.

[15:18:19.0908] <Kris Kowal>
And we conceive that whatever this is many-to-1 Realm.

[15:18:27.0958] <Kris Kowal>
Which presumably isn‚Äôt possible yet.

[15:18:42.0610] <littledan>
I don't get it, but looking forward to hearing more/why

[15:19:38.0063] <Kris Kowal>
Yeah, this is the final building block that would let us use `Module` as part of the implementation of a Lava Moat / hardened JavaScript.

[15:20:33.0149] <Kris Kowal>
That is, isolating third-party dependencies and preventing prototype-pollution.

[15:21:03.0657] <Kris Kowal>
That is to say, isolating libraries in a shared realm.

[15:25:36.0300] <Kris Kowal>
With SES, we‚Äôre already able to do this with a module-to-program transform, some overly constrained-limitations on what programs are valid, and by pitting all of JavaScript‚Äôs sharpest edges against each other.

[15:27:29.0037] <Kris Kowal>
The caveats go away if we have `Module` and something else that needs a name, like `new Thing(globalThis, importHook) => {eval, Function, Module}`.

[15:28:38.0811] <Kris Kowal>
Obligatory sketch of a functionally-equivalent isolated `Compartment` based on these building blocks: https://gist.github.com/kriskowal/f48fb0c68a70ccbde7cd32c85cddc63c

[15:30:04.0075] <Kris Kowal>
`new (new Thing(global, {importHook})).Module(source, {importHook})` ensures that module sees only the globals on `global` and modules through `importHook`.

[15:31:01.0584] <Kris Kowal>
All the way through machinations like `eval('import("module"))` in the module source.

[15:31:52.0549] <Kris Kowal>
`Script`? Don‚Äôt know. Suggestion box is open.


2022-07-13
[19:11:11.0799] <Kris Kowal>
Maybe should call it `Compartment` and build up from there.

[02:02:44.0567] <Kris Kowal>
`new Evaluators({globalThis, importHook}) => {eval, Function, Module}` seems good.

[02:05:33.0005] <Kris Kowal>
It‚Äôs certainly better than Shire or Fiefdom.

[02:06:44.0277] <Kris Kowal>
The latter should obviously be reserved: ‚ÄùFiefdom: A Realm that has -DOM‚Äù.

[02:07:38.0795] <Kris Kowal>
Oh, silly me. That joke works just as well with Kingdom.

[06:21:56.0061] <littledan>
What is the purpose of the eval and function hooks? Is this about them leaking the global object?

[06:22:24.0634] <littledan>
I guess if we're not allowing arbitrary hookability, but just making sure they are hooked up to the right global, then the Thing interface you describe above seems fine to me

[06:24:28.0211] <littledan>
I'm trying to understand whether the importHook that you pass into Thing is the same as the one you pass into Module

[06:48:21.0472] <Jack Works>
I implemented `ExecutionContext` and `Module` in`@masknet/compartment` `0.2.0`.

No `eval` `Function` or `ModuleSource` support, only support Virtual Module

[06:48:36.0629] <Jack Works>
plz play around and it will be good to have some feedback

[07:27:31.0167] <Kris Kowal>
littledan The new `eval` executes in a scope that ends with the given global object and in which dynamic import is virtualized by the given `importHook`, just like modules. The new `Function` creates function instances that also execute in a script context captured by the given global and import behavior. The new `Module` constructor creates modules that are captured by the given global, and could conceivably use the given import hook as a default. That would imply that the intrinsic `Module` constructor would by default have the host-defined import behavior.

[07:30:18.0493] <Kris Kowal>
An Evaluators constructor would be necessary and not sufficient to isolate dependencies. Evaluator, Module, and ModuleSource together are sufficient to reconstruct a  much smaller and more perfect SES shim (hardened JavaScript)

[07:30:49.0902] <Kris Kowal>
 * An Evaluators constructor would be necessary and not sufficient to isolate dependencies. Evaluator, Module, and ModuleSource together are sufficient to reconstruct a  much smaller and more perfect SES shim (hardened JavaScript)

[07:31:09.0444] <Kris Kowal>
Lockdown and Compartment can be shimmed from those components.

[07:31:46.0190] <Kris Kowal>
And notably, with module blocks or import-module-source syntax, that would even play well with CSP.

[07:33:26.0151] <Kris Kowal>
Currently, as Jack Works can testify, isolating dependencies in a no-unsafe-eval environment requires a much larger trusted-compute-base, one that goes out to the bundle generator and its transitive dependencies, naturally including a JavaScript parser and generator framework. Much greater exposure to supply chain attacks.

[08:18:59.0068] <Jack Works>
ü§î actually if we runs in no-unsafe-eval, the runtime will be much simpler because no evaluator is allowed. my trusted base only includes swc (a JS compiler written in Rust)

[11:17:43.0142] <nicolo-ribaudo>
Do `eval`/`Module`/`Function` on `new Evaluators()` get their intrinsics from the `globalThis` parameter? For example
```js
function MyArray() {}
const myGlobalThis = { Array: MyArray };
new Evaluators(myGlobalThis, importHook).eval("[]") instanceof MyArray; // ?
```

[12:20:44.0465] <Kris Kowal>
No, they get the intrinsics of the realm, except for `eval`, `Function`, and `Module`.

[12:21:45.0729] <Kris Kowal>
Another way of framing it is that `eval`, `Function`, and `Module` are intrinsic to the evaluator and all others are intrinsic to the realm.

[12:22:43.0272] <Kris Kowal>
I imagine this works by changing \[\[Realm\]\] on Execution Context to point to \[\[Evaluators\]\] and Evaluator Record to point to \[\[Realm\]\].

[12:22:55.0029] <Kris Kowal>
 * I imagine this works by changing \[\[Realm\]\] on Execution Context to point to \[\[Evaluators\]\] and Evaluator Record to point to \[\[Realm\]\].


2022-07-15
[16:42:21.0537] <Kris Kowal>
Some time, guybedford, I would like to internalize the expectations for the module instrumentation motivating case and document them.

[16:42:47.0319] <Kris Kowal>
In order to uncover any behavior not already supported.


2022-07-16
[17:05:22.0271] <Kris Kowal>
I‚Äôve put together a PR that would put the Compartments proposal in sync with the low-level Module, ModuleSource, and Evaluators narrative we‚Äôve built here. https://github.com/tc39/proposal-compartments/pull/71

[17:05:39.0367] <Kris Kowal>
This is the basis of the compartments update I intend to give at plenary. PTAL.

[17:07:19.0073] <Kris Kowal>
Probably better to start on the first page https://github.com/tc39/proposal-compartments/blob/c8032d7fdc8b16e7b11105596cd461f5cfbaf9b9/README.md


2022-07-18
[09:17:13.0063] <Jack Works>
https://github.com/codehag/pattern-matching-epic
cc Kris Kowal this repo introduce a new proposal process called Epic, it looks very like what you did in #71

[09:57:55.0831] <Kris Kowal>
Convergent evolution in the wild.

[10:00:42.0953] <Kris Kowal>
yulia: as Jack Works points out, we have jinxed each other. I have a PR open that breaks Compartments into layers https://github.com/tc39/proposal-compartments/blob/fc3e8e0a6c1af7ffb09f111d9ddd9328aed09cf0/README.md

[10:01:13.0163] <Kris Kowal>
Which is to say, I support this potential new evolution in proposal design.

[15:55:57.0850] <Kris Kowal>
littledan, nicolo-ribaudo Had a conversation with Mark Miller and Peter Hoddie in which I managed fall back to my earlier position that `Module` needs to take a referrer and that the arguments of `importHook` need to be `(specifier, referrer)`, but now with a compelling argument: It should not be possible for the referrer to vary between calls to the `importHook`, and that‚Äôs best guaranteed if we capture the `referrer` given to the `Module` constructor in an internal slot that the module instance feeds back to `importHook`.

[15:57:20.0415] <Kris Kowal>
I may or may not successfully edit my way to that state before I present, and obviously, my goal is to reach a consistent snapshot before plenary, not to have a final answer to the design question.

[15:57:37.0905] <littledan>
Wait, I had a conversation with guybedford where he managed to convince me that a ModuleSource should have a referrer

[15:57:52.0691] <littledan>
This is all consistent though 

[15:58:24.0936] <Kris Kowal>
Yeah, we‚Äôre likely to have conversations like that until we either get tired or separate all three layers.

[15:59:26.0044] <Kris Kowal>
That being: {text, bindings}, {{text, bindings}, referrer}, {{{text, bindings}, referrer}, memo, meta, state, &c}

[15:59:26.0472] <littledan>
The thing is, Module (and maybe also ModuleSource) also may need to close over the import map

[16:00:00.0442] <littledan>
Ah yes Nicolo and I have been talking about where memoization happens‚Ä¶ also confusing

[16:00:38.0597] <Kris Kowal>
I think there are coherent stances on module blocks where `Module` instances have [[HostData]] that leads back to the host‚Äôs module map, as would be necessary to mitigate certain configuration errors, but also coherent stances where it does not.

[16:01:24.0134] <Kris Kowal>
But, `ModuleSource` should just close over source. I‚Äôm open to adding layers and moving state around, but it would be not good to have state with the source.

[16:01:55.0207] <littledan>
My intuition is that module blocks and module reflection probably give you the same thing. They both need a referrer, and module reflection needs multiple instantiation (which is optional for module blocks IMO)

[16:02:35.0463] <Kris Kowal>
Interesting.

[16:02:38.0552] <littledan>
> <@kriskowal:matrix.org> But, `ModuleSource` should just close over source. I‚Äôm open to adding layers and moving state around, but it would be not good to have state with the source.

OK, then, we probably need a third class which is ModuleSource + referrer, which can be instantiated multiple times, and module reflection and blocks should be this

[16:02:57.0146] <Kris Kowal>
`WebAssembly.Module` definitely maps to `ModuleSource`. Those do not have referrers.

[16:03:23.0452] <littledan>
Guy‚Äôs proposal definitely returns something with a referrer for Wasm

[16:03:31.0542] <littledan>
Otherwise csp doesn‚Äôt work

[16:03:33.0696] <Kris Kowal>
But I agree there might be an intermediate, or that `Module` in its initial state can serve as the intermediate.

[16:03:59.0190] <Kris Kowal>
Guy‚Äôs position is consistent with annotating module sources with origin information in their host data.

[16:04:10.0019] <littledan>
I think we could say, WebAssembly.Module has a new internal slot, which might be empty, which is the referrer

[16:04:34.0906] <littledan>
And we can apply this to ModuleSource generally, or make it a separate class if needed

[16:04:57.0569] <littledan>
Doe‚Äôs ModuleSource have host data?

[16:05:09.0861] <Kris Kowal>
I would like to think of CSP origin as orthogonal to referrer.

[16:06:01.0896] <Kris Kowal>
My mental model at the moment is that ModuleSource instances have an internal slot \[\[ModuleSource\]\] for an abstract Module Source.

[16:06:14.0464] <Kris Kowal>
 * My mental model at the moment is that ModuleSource has an internal slot \[\[ModuleSource\]\] for an abstract Module Source.

[16:06:32.0280] <Kris Kowal>
 * My mental model at the moment is that ModuleSource instances have an internal slot \[\[ModuleSource\]\] for an abstract Module Source.

[16:06:52.0023] <Kris Kowal>
More than a mental model, I should say, that made it into my current PR.

[16:07:08.0204] <littledan>
In general, I think it would be nice if import module gave you something you could do import() on. This requires a referrer. Otoh a core goal of Guy‚Äôs proposal is that import module gives you something which can be multiply instantiated 

[16:07:31.0991] <Kris Kowal>
262 needs to mention referrer, but does not need to couple it to CSP.

[16:07:34.0858] <littledan>
So this means, a class which has a referrer but is not an instance, if we want to meet those goals 

[16:08:00.0525] <littledan>
Referrer is sufficient for csp, and necessary for other reasons

[16:08:22.0545] <littledan>
I don‚Äôt mind thinking of that as coincidental 

[16:08:24.0245] <Kris Kowal>
Referrer on Module is sufficient, and referrer on ModuleSource is not necessary.

[16:08:45.0976] <littledan>
I explained a separate reason why it is necessary above

[16:08:50.0024] <Kris Kowal>
Though origin on ModuleSource is necessary for CSP.

[16:09:06.0354] <Kris Kowal>
I would like to think of these as different even if coincidental.

[16:09:13.0952] <littledan>
Sure

[16:09:47.0725] <Kris Kowal>
Going back to your conversation with Guy‚Ä¶

[16:10:40.0167] <Kris Kowal>
I think all motivating cases are handled if `Module` captures a referrer and if there‚Äôs a way to obtain a `Module` in an uninitialized state. That‚Äôs the deferred execution proposal.

[16:11:02.0183] <Kris Kowal>
And I‚Äôm open to deferred execution subsuming import reflection to that end.

[16:11:10.0472] <littledan>
It would be pretty cool if these could be unified somehow 

[16:11:28.0095] <littledan>
And I think giving it an instance which has a referrer but no instance would do it

[16:11:35.0273] <Kris Kowal>
If `import module x from 'x.wasm'` came up as a `Module`:

[16:13:28.0649] <Kris Kowal>
1. it would have a `referrer`
2. wouldn't be evaluated yet
3. could be duplicated for multiple instantiation: `new Module(x.source, x.referrer, etc)`
4. `x.source instanceof WebAssembly.Module`
5. `WebAssembly.Module` and `ModuleSource` can either have \[\[HostData\]\] or host-dependent variations of the Module Source Record abstract type such that they have a CSP origin
6. Could be executed with just `import(x)`

[16:13:56.0082] <Kris Kowal>
 * 1. it would have a `referrer`
2. wouldn't be evaluated yet
3. could be duplicated for multiple instantiation: `new Module(x.source, x.referrer, etc)`
4. `x.source instanceof WebAssembly.Module`
5. `WebAssembly.Module` and `ModuleSource` can either have \[\[HostData\]\] or host-dependent variations of the Module Source Record abstract type such that they have a CSP origin
6. Could be executed with just `import(x)`

[16:14:46.0634] <Kris Kowal>
Notably, in the multiple instantiation case, `referrer` can and must be differentiated from `source.[[HostData]].[[Origin]]`. Spoofing origin is no-go.

[16:15:38.0290] <Kris Kowal>
That‚Äôs me convincing myself that `referrer` and `origin` may coincidentally be the same value, but must be orthogonal.

[16:16:29.0319] <Kris Kowal>
Similarly, `new ModuleSource(text)` from a trusted type can also produce a Module Source Record with an associated \[\[Origin\]\].

[16:16:36.0901] <Kris Kowal>
 * Similarly, `new ModuleSource(text)` from a trusted type can also produce a Module Source Record with an associated \[\[Origin\]\].

[16:43:15.0420] <Kris Kowal>
Would someone here kindly verify that they can open this slide deck link? https://drive.google.com/file/d/1NJWRBZJBP25uoyLXYDQVU5uG7YVZD4M9/view?usp=sharing

[16:55:07.0069] <littledan>
Yes I can open it

[16:55:42.0255] <Kris Kowal>
I‚Äôll get them added to the agenda.

[16:55:50.0663] <littledan>
I am fine with considering csp layered to be orthogonal to referrer but it really is two copies of the same information. Csp can be more specific about paths than just origin 

[16:56:23.0677] <Kris Kowal>
I think they‚Äôre not necessarily the same since referrer can be virtualized but origin cannot.

[16:56:26.0961] <littledan>
And the idea of TT is because it is too hard to apply that specific of a csp policy

[16:56:38.0761] <littledan>
Oh! Ok

[16:56:46.0330] <littledan>
When is referrer virtualized?

[16:56:55.0208] <littledan>
I guess import maps?

[16:57:03.0966] <Kris Kowal>
Whenever you construct a `Module`, you may choose any referrer.

[16:57:24.0665] <Kris Kowal>
Up to an including `{ importMeta: { url: "üí©" } }`

[16:58:34.0536] <Kris Kowal>
Or rather, assuming a new `referrer` argument, `new Module(originalSource, "ü§•", { etc })`.

[16:59:22.0269] <Kris Kowal>
In which case the `originalSource` would have an associated origin by which CSP would be enforced, but a referrer that need only be useful to the extent that you can use it to resolve an importSpecifier in an importHook.


2022-07-19
[17:01:05.0941] <Kris Kowal>
That in turn is important because one of the things you can do with a module source is relocate it, e.g., from the file system to a bundle, or a zip file.

[17:01:17.0480] <littledan>
Oh I see

[17:01:22.0478] <Kris Kowal>
In which case the `import.meta.url` is not applicable.

[17:01:36.0306] <littledan>
And this is supposed to be the resolved specifier?

[17:01:41.0119] <littledan>
Not a relative one

[17:01:57.0070] <Kris Kowal>
Yeah, referrers need to be fully resolved. What that means can vary as well.

[17:02:42.0776] <Kris Kowal>
e.g., if you have an `importHook` per scope, `./src/main.js` is a very reasonable fully-resolved specifier, where `./` just distinguishes a module in scope from one that‚Äôs from another scope.

[17:03:03.0942] <littledan>
OK, then I agree that this is orthogonal. Then, WebAssembly.Module needs a referrer as well as host data

[17:03:40.0442] <littledan>
Since, when used in import, it needs to resolve relative references 

[17:03:41.0867] <Kris Kowal>
My position remains that `Module` needs a referrer and import reflection can produce a `Module` that contains a `WebAssembly.Module` as its source.

[17:04:09.0842] <littledan>
That would mean that it can‚Äôt be multiply instantiated, going against one of the core goals

[17:04:27.0247] <Kris Kowal>
It can be multiply instantiated.

[17:04:27.0808] <littledan>
That goal is higher priority than my import() one

[17:04:40.0182] <littledan>
How can a Module be multiply instantiated?

[17:05:02.0764] <Kris Kowal>
`await import(new Module(module.source, module.referrer, etc.))`

[17:05:12.0800] <littledan>
OK, by cloning it

[17:05:17.0619] <Kris Kowal>
Effectively, yes.

[17:05:27.0444] <littledan>
By projecting away some of the stuff 

[17:05:52.0726] <littledan>
Well, these are two coherent points in the design space to consider

[17:06:03.0339] <Kris Kowal>
Aye.

[17:06:41.0069] <Kris Kowal>
I‚Äôm just strongly against adding the referrer to the source. There are other coherent ways to meet that criterion too.

[17:07:01.0047] <littledan>
Can you say more about why?

[17:07:08.0303] <Kris Kowal>
Including an intermediate layer between source and instance. I‚Äôm weary of that though. Not a naming problem I want to get into.

[17:07:34.0319] <Kris Kowal>
Yeah, sources are highly reusable.

[17:08:12.0862] <Kris Kowal>
They can be backed by an immutable record that can be safely shared throughout an agent cluster without synchronization.

[17:08:35.0581] <Kris Kowal>
And they represent no authority.

[17:09:22.0943] <Kris Kowal>
Taking referrer onto that does not add authority, but it does make it less clear exactly how cache and share friendly they are.

[04:18:15.0625] <Jack Works>
I feel good with no referrer (current PR design). Is there a summary of why we want to add it back again?

[04:21:56.0675] <Jack Works>
is this a feature or a bug?

[04:23:50.0244] <nicolo-ribaudo>
A feature! The exact code does not matter, but the amounts does. It's to show that compartments a small implementation on top of all the building blocks (or at least, that's what I remember from when I saw that slide!)

[05:45:14.0705] <Kris Kowal>
> <@jackworks:matrix.org> is this a feature or a bug?

Intentional. I don‚Äôt want people to read the whole slide, but I do want to give people an idea about how much code it takes to implement compartment in user code. Whether this is  okay or too much is actually quite subjective. For an inline implementation of import map that gets written into a large portion of the web, might be too much. But, on the other hand, might not be.

[05:47:31.0083] <Kris Kowal>
> <@jackworks:matrix.org> I feel good with no referrer (current PR design). Is there a summary of why we want to add it back again?

Yes, importMeta is mutable and referrer should not be. This is a soft requirement. If we also make importMeta === import.meta, that requirement becomes harder: a module should not be able to alter its own referrer between dynamic imports. I‚Äôm leaving these all as open questions for us to settle amongst us and am not going to broach the topic at plenary.

[05:48:56.0918] <nicolo-ribaudo>
Could the referrer be in a provate field of importMeta not visible from inside the module?

[06:26:25.0682] <nicolo-ribaudo>
* Could the referrer be in a private field of importMeta not visible from inside the module?

[06:36:30.0043] <Kris Kowal>
It could be. The other way of looking at this, though, is, "what among the properties of import.meta are useful to an importHook", and the answer is, "only the referrer".

[06:37:03.0564] <Kris Kowal>
And another way to look at it is, "what does one need to construct an import.meta for a particular module", and the answer is, "only the referrer".

[06:37:26.0623] <nicolo-ribaudo>
> <@kriskowal:matrix.org> It could be. The other way of looking at this, though, is, "what among the properties of import.meta are useful to an importHook", and the answer is, "only the referrer".

Well, you have an example with import.meta.resolve

[06:38:42.0001] <nicolo-ribaudo>
I can answer to myself üòÇ
With Guy's proposal of passing a baseURL parameter, you don't need to get .resolve from the module's import.meta

[06:38:47.0773] <Kris Kowal>
And another overlapping design question remains open: can we thread `importMeta` such that `import.meta === importMeta` and cause less confusion?

[06:39:14.0240] <Kris Kowal>
Where is Guy proposing the passage of a baseURL?

[06:39:16.0641] <nicolo-ribaudo>
> <@kriskowal:matrix.org> And another overlapping design question remains open: can we thread `importMeta` such that `import.meta === importMeta` and cause less confusion?

I agree that it's confusing 

[06:39:23.0607] <Kris Kowal>
Is this different than `import.meta.url`?

[06:40:51.0929] <nicolo-ribaudo>
> <@kriskowal:matrix.org> Where is Guy proposing the passage of a baseURL?

Adding a baseURL parameter to import.meta.resolve, so that it can be reused across modules: https://github.com/whatwg/html/issues/8077

[06:42:12.0709] <Kris Kowal>
Oh, indeed. I think that‚Äôs orthogonal too. The baseURL is presumably optional and defaults to import.meta.url, such that resolve still closes over import.meta.url?

[06:42:39.0745] <Kris Kowal>
Basically revealing the underlying uncurried form of resolve.

[06:43:19.0765] <Kris Kowal>
There are some tangles there. I know that we can‚Äôt do that in Endo, since there isn‚Äôt a URL and each package has an isolated namespace.

[06:50:26.0566] <Jack Works>
> <@kriskowal:matrix.org> It could be. The other way of looking at this, though, is, "what among the properties of import.meta are useful to an importHook", and the answer is, "only the referrer".

import.meta.hot

[06:52:40.0893] <Luca Casonato>
We‚Äôre skipping the loader meeting this week, right?

[06:52:51.0470] <Luca Casonato>
(Because plenary)

[06:53:25.0887] <littledan>
yes

[13:25:50.0802] <yulia>
Kris Kowal: i didn't realize you would be going last today. I will probably fade before then

[13:26:14.0567] <yulia>
are you expecting any major decisions made on your proposal today? or is this primarily an update?

[13:26:46.0176] <Kris Kowal>
this is an update and we're not calling for decisions yulia 

[13:26:53.0156] <Kris Kowal>
 * this is an update and we're not calling for decisions yulia 

[13:27:12.0821] <Kris Kowal>
we are looking for whether the motivating cases are well-supported for each layer

[13:27:24.0315] <yulia>
ok, I will review the notes after

[13:27:35.0778] <yulia>
interesting discussion to have though

[13:27:40.0406] <Kris Kowal>
you'll be missed and thanks

[13:28:38.0350] <yulia>
one comment on the repo so far -- i think the one thing i am missing is a motivation

[13:28:52.0347] <littledan>
maybe we can rearrange the presentation to come in a future day?

[13:28:58.0310] <littledan>
it'd be nice to have you present

[13:29:15.0507] <littledan>
(unless you prefer to be absent)

[13:29:26.0362] <Luca Casonato>
I think it's locked to today because constraints for Shu & Nicol√≤

[13:29:33.0738] <littledan>
I see

[13:30:00.0293] <yulia>
I think it may be useful to have one line. for example: https://github.com/tc39/proposal-compartments/blob/master/0-module-and-module-source.md -- the motivation here might be: "currently we have a conflation of two concepts in module records. This makes it difficult to work with these separately. By separating them, we unlock the following use cases"

[13:30:04.0251] <Luca Casonato>
 * I think it's locked to today because constraints for Shu & Nicol√≤

[13:30:49.0628] <yulia>
its *kind* of like the synopsis, but it frames the layer in terms of what it is solving. that may help with establishing motivating cases

[13:31:18.0403] <yulia>
I would prefer to be present -- the problem is that i didn't really sleep last night. I don't think i am critical though

[13:31:30.0109] <yulia>
i probably am for import reflection so i will be here for that

[13:33:36.0689] <yulia>
my audio is messed up anyway

[13:33:44.0531] <yulia>
ill go through the other layers now and mention what i find

[13:34:09.0526] <Kris Kowal>
> <@yulia:mozilla.org> I think it may be useful to have one line. for example: https://github.com/tc39/proposal-compartments/blob/master/0-module-and-module-source.md -- the motivation here might be: "currently we have a conflation of two concepts in module records. This makes it difficult to work with these separately. By separating them, we unlock the following use cases"

i will have to touch on this, though i probably could not stop on just the division of source and instance.

[13:35:04.0564] <yulia>
i think setting up the problem statement in the clearest possible way would be great -- even if its more than what i described there. That was just my naive starting point!

[13:35:10.0204] <Kris Kowal>
thank you for pointing that out though. it is a blind spot for me.

[13:45:14.0480] <yulia>
for this one, the motivation works as a problem statement: https://github.com/tc39/proposal-compartments/blob/master/2-virtual-module-source.md#motivation -- it states what can not be done today and why we want to do it. 

[13:47:27.0464] <yulia>
this one is a little hard to understand: https://github.com/tc39/proposal-compartments/blob/master/1-static-analysis.md#motivation -- in particular, i start to get confused at "The weight and performance of a JavaScript meta-parser (about 1MB) often precludes production use-cases that make direct use of JavaScript module source. " -- by meta-parser what do you mean? Like syntax only parser? something else? 

[13:50:09.0320] <yulia>
this one, i need to spend with more time but on first read it looks fine: https://github.com/tc39/proposal-compartments/blob/master/3-evaluator.md#motivation

[13:51:37.0088] <yulia>
and, my attention is fading -- so i don't think i can do any more

[13:51:51.0669] <yulia>
ill come back to it at a later point, id like to spend more time with this in general

[13:52:46.0106] <Kris Kowal>
ty!

[14:31:50.0699] <yulia>
I think, `module <identifier> from "xyz";` might be interesting?

[14:32:16.0770] <yulia>
with `module <identifier> { ....} ` and `const <identifier> = module { ... }`

[14:32:41.0691] <yulia>
but then if `assert` is in the same position its a little weird

[14:32:50.0991] <yulia>
cc guybedford (Guy Bedford) 

[14:32:53.0299] <littledan>
this conflicts a lot wiht module fragments

[14:32:59.0905] <littledan>
which use `module identifier { }`

[14:33:05.0404] <littledan>
I think we should use the import keyword here

[14:33:27.0938] <yulia>
module reflection: module <identifier> from "xyz";
module fragments: module <identifier> { ....}

[14:33:33.0747] <nicolo-ribaudo>
I like "import" because we are still "loading something external", but this doesn't conflict: it aligns well

[14:33:45.0274] <yulia>
so we will have

[14:34:12.0167] <yulia>
```
import module <identifier> from "xyz"
const whatever = import(<identifier>)
```

[14:34:24.0264] <yulia>
and these two will mean very different things

[14:34:29.0428] <littledan>
here's another possible interaction point between `import module` and module fragments:
```js
import module foo from "./foo.js";

module bar {
  import foo;
}
```
I like it!

[14:35:54.0062] <Jack Works>
import foo from "spec" as module? 

[14:38:52.0349] <yulia>
I was additionally thinking of how to handle the dynamic import case, which could be (if there is flexibility to consider other approaches) `module(<url-specifier>)` followed by `import(<module>)`

[14:39:53.0817] <yulia>
or, `module import(...)` and `module import x from "xyz"`

[14:41:19.0442] <nicolo-ribaudo>
`module(<url-specifier>)` is already valid syntax, and `module import(...)` feels weird to me because the space has an higher precedence than `(...)` (reading it as a function call) üò¨

[14:41:30.0961] <nicolo-ribaudo>
I think using the options bag would be fine

[14:41:36.0357] <yulia>
yeah, the import statement is a bit weird

[14:42:02.0157] <yulia>
I find the new syntax confusing though. 

[14:42:23.0356] <yulia>
I wouldn't know, as a developer, how this "module" is different than what i already imported

[14:43:38.0910] <yulia>
from what i was already importing with the regular import statement rather

[14:44:46.0645] <littledan>
I like the `import(..., {xyzkey: "module"})` syntax presented; I think we could use some bikeshedding on the key

[14:45:04.0261] <littledan>
I mean, we designed import assertions specifically to enable this case

[14:45:09.0996] <littledan>
the second argument design, I mean

[14:46:58.0116] <nicolo-ribaudo>
> <@yulia:mozilla.org> I wouldn't know, as a developer, how this "module" is different than what i already imported

I think that the compartments proposal reifying `Module`/`ModuleSource` will help with that confusion, because "module" becomes a real word of the language

[14:47:11.0955] <nicolo-ribaudo>
We must make sure that they don't mean incompatible things

[14:48:28.0883] <yulia>
Fair, I‚Äôm still working through that proposal. I‚Äôll return to this later

[14:48:31.0748] <yulia>
Night all

[14:48:57.0955] <nicolo-ribaudo>
Have a good night!

[15:36:01.0148] <littledan>
Maybe there is some sort of more restricted form of evaluators that could meet Shu's concerns. I'm not sure what that would look like, though.

[15:39:08.0160] <Jack Works>
how you can restrict it? I think it's already a minimal one

[15:40:07.0781] <littledan>
I'm not sure; one option is what Kris is saying

[15:40:44.0439] <littledan>
I suspect there are multiple options that meet these goals


2022-07-20
[10:52:44.0859] <Kris Kowal>
> <@littledan:matrix.org> I like the `import(..., {xyzkey: "module"})` syntax presented; I think we could use some bikeshedding on the key

I suspect that ljharb‚Äôs objection could be resolved by changing the form to `import(string, {module: true})` (the name in syntax appears in the options bag)

[10:53:17.0051] <littledan>
ah I like that option

[10:53:20.0246] <Kris Kowal>
And I would be fine with that. `reflect` is hedging on coherence with assets, which is unknown.

[10:53:33.0553] <littledan>
well, assets could just be a separate key

[10:53:41.0089] <Kris Kowal>
And I‚Äôm fine with that too.

[10:53:57.0010] <nicolo-ribaudo>
Or `import.module(string)`, so that the words are also in the same order

[10:54:02.0214] <ljharb>
both of those would address my mirroring constraint yes

[10:54:11.0251] <ljharb>
there's tons of ways to do so; i have no strong opinion on the best way

[10:54:18.0926] <ljharb>
 * both of those would address my mirroring constraint yes

[10:54:39.0422] <Kris Kowal>
Your constraint is valid.

[11:10:04.0365] <Kris Kowal>
> <@nicolo-ribaudo:matrix.org> Or `import.module(string)`, so that the words are also in the same order

I would want `const myImport = async (...rest) => import(...rest)` to be sufficient to drop import from 2nd to 1st class and handle all the things import does, so I‚Äôm leaning away from a syntactic solution.


2022-07-22
[12:45:49.0712] <Kris Kowal>
nicolo-ribaudo: Caridy is working on First-class Modules spec text. It might be good for you to connect.

[12:46:56.0835] <Kris Kowal>
One thing we can‚Äôt do Right Now‚Ñ¢ is have `importHook` and `importMeta` fall through to defaults in the realm. I presume this is because we don‚Äôt have [[ImportHook]] or [[ImportMeta]] on the realm record Yet‚Ñ¢.

[12:47:21.0011] <Kris Kowal>
And if we had them, they‚Äôd have to be host-defined.

[12:47:45.0627] <Kris Kowal>
Maybe we have them but they have other names or forms that obscure them?

[12:51:47.0204] <guybedford>
Kris Kowal: great to hear progress is coming along! Happy to assist where I can as well. I wonder if the `importHook` could be treated as an internal operation to start to avoid the realm issues? As in, a spec function doesn't need to have context? Eg paramaterize `HostResolveImportedModule` by the realm (as it likely should be), and have import hook delegate to that? Then refactor outwards from there? Thinking aloud... not sure if something like that makes sense.

[12:52:26.0117] <Kris Kowal>
I think that makes sense.

[12:52:44.0992] <Kris Kowal>
Something very much like that in any case.

[12:53:19.0011] <guybedford>
Do you plan to put time to these discussions in SES meetings? Or can we resume in our modules meetings?

[12:53:40.0837] <guybedford>
I can also reach out to caridy as well / or just copy in on anything for feedback too

[12:54:39.0554] <Kris Kowal>
I would like to get crackin‚Äô on nitty gritty as soon as possible and SES meetings will help with that. The contract with Module Harmony calls remains the same, though. When we get together with the stakeholders, have to present from where the group left off.

[12:55:16.0687] <Kris Kowal>
But just putting heads together with Caridy, Nicolo, you, and me to puzzle out what‚Äôs possible also makes sense to me.

[12:55:52.0868] <guybedford>
yeah I'd be happy to put some time into the direct spec questions

[12:56:08.0030] <guybedford>
I'm still very hopeful we can improve the modules spec as we do this work

[12:56:21.0997] <guybedford>
and actually make it more capable and more well-defined in the process

[12:57:18.0645] <Kris Kowal>
Yeah, on the one hand Caridy wants to have the lightest touch possible so the proposal is provably free of surprises.

[12:57:52.0280] <Kris Kowal>
But I think setting up for a non-normative refactor should be part of the plan.

[12:57:59.0720] <guybedford>
If there's room for some refactoring, like working on any old codebase hopefully we can leave it better than we found it :)

[12:58:27.0482] <Kris Kowal>
Or preceding with a non-normative refactor would work for me too.

[12:59:03.0296] <Kris Kowal>
Are you familiar with Chesterton‚Äôs Fence?

[13:04:20.0709] <Richard Gibson>
I always dismiss Chesterton's fence discussions because I don't see their purpose

[13:07:49.0609] <Kris Kowal>
Yeah, so relatedly, I suspect that Cyclic Module Record only exists because Module Source Record doesn‚Äôt exist yet.

[13:08:41.0030] <Kris Kowal>
But I don‚Äôt *know* *know* whether there are any concrete Module Record types that *don‚Äôt* include the abstract Cyclic Module Record.

[13:08:59.0532] <Kris Kowal>
So I‚Äôm approaching that particular Chesterton‚Äôs Fence as if it might be electrified.

[13:09:08.0016] <Kris Kowal>
 * So I‚Äôm approaching that particular Chesterton‚Äôs Fence as if it might be electrified.

[13:09:54.0409] <Kris Kowal>
That kind of uncertainty is a good reason to refactor it out of existence, _if_ we can.

[13:13:01.0570] <Kris Kowal>
So I think the way we set the stage for that refactor is to create a new concrete Module Record that embeds Cyclic Module Record and refers to a Module Source Record. This would be the last concrete Module Record we would ever need, and in a refactor, we could circle back and replace the Module Record abstract type hierarchy with the single, concrete Module Record and rely on the abstract Module Source Record for extensibility.

[13:13:50.0303] <Kris Kowal>
In that refactor, Cyclic Module Record squashes into Module Record.

[13:14:22.0673] <Kris Kowal>
But, again, weary that might not be possible and is also not necessary to make progress on ‚ÄúVirtual Module Record‚Äù.

[13:14:45.0645] <Kris Kowal>
And very very weary of signaling that the refactor is necessary, given that it might not be possible.

[13:24:24.0884] <Kris Kowal>
guybedford (Guy Bedford):  And I‚Äôm sure that‚Äôs the least of the refactoring you have in mind. üòÇ

[13:45:54.0387] <guybedford>
interesting!

[13:46:02.0476] <guybedford>
I wonder if we could do such a refactoring as a non-normative PR?

[13:46:26.0033] <guybedford>
perhaps write our respective specs, then work out a refactoring to write our respective specs against, then PR that first...?

[13:48:04.0039] <Kris Kowal>
I think any refactoring is by definition non-normative.

[13:49:52.0600] <guybedford>
yeah I guess its more likely, let's get this spec feedback going on see where it ends up though

[13:50:33.0325] <guybedford>
I also think we could generalize CyclicModuleRecord istead of AbstractModuleRecord being separated

[13:50:57.0406] <guybedford>
Then having ModuleSourceRecord v ModuleInstanceRecord

[13:51:26.0470] <guybedford>
In theory SyntheticModules could just be a CyclicModuleRecord with no dependencies

[13:51:35.0358] <guybedford>
and that leaves the door open to a form of Synthetic with dependencies anyway

[13:51:46.0555] <Kris Kowal>
A thing I could use help explaining is why we should separate source from instance.

[13:52:09.0181] <guybedford>
I guess the new constraint is the same source record can now have multiple instances under module blocks

[13:52:28.0295] <Kris Kowal>
that‚Äôs certainly true

[13:52:51.0044] <Kris Kowal>
multiple instantiation is the crux, and multiple motivating cases require multiple instantiation

[13:53:36.0907] <Kris Kowal>
there‚Äôs also transferability between agents of the same cluster. I think James Browning (@?) would be very interested in that dimension.

[13:54:20.0643] <Kris Kowal>
toll-free transfer between realms too

[13:55:08.0041] <Kris Kowal>
i suppose it‚Äôs incidental is that it fixes the encapsulation boundary

[13:55:18.0344] <Kris Kowal>
‚Äúencapsulate the thing that varies‚Äù

[13:55:20.0955] <guybedford>
yeah these seem to be the main points I think? - cyclic / abstract unification, instance / source separation, multi agent / realm usage

[13:55:33.0111] <Kris Kowal>
source types vary, module lifecycle management does not

[13:56:07.0422] <guybedford>
then cache semantics and host hook modifications I guess

[13:58:23.0347] <littledan>
yeah I agree that you can just use CyclicModuleRecord for more things

[13:58:32.0042] <littledan>
it doesn't hurt to have that logic around

[13:58:43.0762] <littledan>
(or maybe that's not what you're saying?)

[13:58:53.0989] <Kris Kowal>
It‚Äôs one of the things I‚Äôm saying.

[14:01:21.0610] <Kris Kowal>
Separating module source from instance moves the abstraction boundary to a better place than where it is at the moment

[14:02:13.0080] <Kris Kowal>
Some of the concerns of Source Text Module Record belong on the Source side and others on the Instance side.

[14:02:30.0958] <Kris Kowal>
But all of the concerns of Cyclic Module Record belong on the Instance side.

[14:03:52.0182] <Kris Kowal>
When the Instance side has all the right concerns, it becomes clear that you only need one concrete Instance type and many derived Source types.

[14:04:46.0539] <Kris Kowal>
But, again, a refactor is _not_ necessary to make progress.

[14:06:13.0335] <Kris Kowal>
I‚Äôm proposing that we just make a new Virtual Module Record type that embeds Cyclic Module Record and borrows some properties of Source Text Module Record (everything but the Source!), then makes a reference to a Module Source Record that keeps the remaining bits of Source Text Module Record.

[14:07:01.0450] <Kris Kowal>
We‚Äôd leave the existing Module Record hierarchy in tact, maybe circle back clean it up later.

[14:09:41.0556] <guybedford>
I guess one of the difficulties is that because SourceTextModule extends CyclicModule extends AbstractModule, having parts of SourceTextModule refactored into a ModuleSource, doesn't mean all abstract modules have a ModuleSource?

[14:10:16.0217] <Kris Kowal>
Correct.

[14:10:29.0630] <Kris Kowal>
And when you put it that way, maybe a refactor is necessary.

[14:11:51.0554] <Kris Kowal>
Or `Module` instances could end up with a null `source`, and that‚Äôs not good for business.

[14:12:30.0861] <guybedford>
Right, so how to define `source` in cases where it's under-specified?

[14:12:42.0831] <guybedford>
short of just having a bunch of null entries on a record

[14:13:00.0794] <Kris Kowal>
Refactor is getting compelling.

[14:13:05.0479] <guybedford>
I think realistically we only have to handle SyntheticModule and CyclicModule

[14:13:22.0202] <guybedford>
but even JSON as a SyntheticModule could in theory associate with its source

[14:13:46.0698] <Kris Kowal>
Yes.

[14:14:31.0174] <guybedford>
I'd be very keen to be involved in a refactoring effort, and will gladly sling some PRs on a shared repo

[14:15:00.0831] <Kris Kowal>
Dan made a point to me on the way out of plenary yesterday, that module fragments might not be able to have a source. So nullable source might be on the table, but I would like to avoid that.

[14:15:02.0747] <guybedford>
if it's better to do under the compartments umbrella for now happy to do that as well

[14:15:23.0345] <guybedford>
if you have a link to what Caridy is working on please do share

[14:15:39.0835] <guybedford>
yes Dan explicitly mentioned for import reflection he wants to see the fragments etc use cases worked out at a spec level

[14:15:45.0059] <guybedford>
we can certainly do that

[14:16:37.0313] <Kris Kowal>
I‚Äôll pass Caridy‚Äôs work along when I get it.

[14:17:28.0028] <Kris Kowal>
TBD on making a new proposal repo for each layer of a ‚Äúmodules epic‚Äù. Going to put that on agendas.


2022-07-23
[17:49:18.0726] <nicolo-ribaudo>
> <@kriskowal:matrix.org> nicolo-ribaudo: Caridy is working on First-class Modules spec text. It might be good for you to connect.

Awesome! This week I started refactoring the `HostResolveImportedModule` and `HostImportModuleDynamically` host hooks, because I didn't want to go through host-defined behavior when importing module blocks/fragments (until they import external modules).

I now have a single `HostLoadImportedModule` hook, used both for static and dynamic imports, that "returns" an unlinked Module Record. ECMA-262 takes care of iterating through its dependencies, and it recursively calls `HostLoadImportedModule` to visit the whole graph (cc guybedford: this matches your intuition in https://github.com/tc39/proposal-js-module-blocks/pull/65#discussion_r912412376 !).

This is my proposed refactor: https://nicolo-ribaudo.github.io/modules-import-hooks-refactor/
If you are curious, this is how the module blocks spec looks like on top of that refactor: https://nicolo-ribaudo.github.io/modules-import-hooks-refactor/proposals/module-blocks - the updates to `import()` are relevant for "layer 0", because they show how to import a "module object".

I believe that the new logic closely resembles the loading logic introduced by "layer 0": we could probably just add a step tocheck to 2.d.ii of InnerModuleLoading that calls a `module.[[ImportHook]]` function, rather than always delegating to `HostLoadImportedModule`.

It would probably also help with module reflection: assuming that `WebAssembly.Module` will be a module source, the proposal could use `HostLoadImportedModule(...).[[ModuleSource]]` instead of introducing a new `HostResolveModuleReflection` AO. This would also guarantee that `import module x from "x.wasm"` and `import * as ns from "x.wasm"` import the same module, even if they do two different things with it (probably we could guarantee `ns === await import(x)`).

I would love to hear your thoughts on this üôÇ

[17:53:05.0179] <Kris Kowal>
Your description matches my intuition.

[17:54:20.0093] <Kris Kowal>
Though, it would be nice if we could always route through module.[[ImportHook]], even when that is just a thunk for HostLoadImportedModule.

[17:55:07.0149] <littledan>
I reviewed this refactor earlier today and it looks great to me.

[17:55:22.0182] <Kris Kowal>
And I think this generally closes the gap with Caridy‚Äôs upcoming changes, which had no reasonable default importHook.

[17:58:57.0680] <littledan>
This refactor is great because it makes it clear exactly where importHook is called; it is not too often as currently 

[18:00:04.0773] <littledan>
IMO it would make sense to land separately in HTML and JS already, since it is a significant cleanup, or at least put out for review as a separated item

[18:05:29.0611] <Kris Kowal>
Would it be reasonable for HostLoadImportedModule to be the default [[ImportHook]] of a Realm, such that `Module` instances and module blocks can pick it up from their execution context?

[18:05:51.0063] <Kris Kowal>
That should be behaviorally equivalent, I think.

[18:06:57.0548] <Kris Kowal>
Or rather, in the case of the `Module` constructor, picked up from the ModuleConstructor.[[Context]].[[Realm]].[[ImportHook]]

[18:07:47.0637] <nicolo-ribaudo>
> <@kriskowal:matrix.org> Though, it would be nice if we could always route through module.[[ImportHook]], even when that is just a thunk for HostLoadImportedModule.

I thought about that, but it has a problem: I expect that we will always call `Promise.resolve` on `[[ImportHook]]()`'s result, because its an user-exposed API. This forces a microtask for every imported module, while the old `HostResolveImportedModule` allowed everything to be synchronous (the new `.LoadRequiredModule` always returns a promise, but hosts can implement a sync `HostLoadImportedModule` and then `.LoadRequiredModule` always returns an _already resolved_ promise)

[18:08:12.0808] <Kris Kowal>
I see.

[18:09:05.0678] <Kris Kowal>
I think the ends I‚Äôm looking for could be accomplished another way, then‚Ä¶

[18:09:52.0964] <nicolo-ribaudo>
I know that Bun (a new experimental JS runtime) allows `require()` of ESM, and throws if it uses TLA. So there is at least one project that depends on modules loadnig being mostly synchroous (without TLA, `.Evaluate()` returns an already resolved promise)

[18:09:57.0923] <Kris Kowal>
That is, for there to be a slot that the HostLoadImportedModule fits into, which a VirtualHostLoadImportedModule would fit in.

[18:10:32.0986] <nicolo-ribaudo>
> <@kriskowal:matrix.org> That is, for there to be a slot that the HostLoadImportedModule fits into, which a VirtualHostLoadImportedModule would fit in.

That would work, instead of the user function we would store an abstract closure that wraps the user function

[18:10:38.0086] <Kris Kowal>
Yeah, I‚Äôm familiar with Bun. It makes some similar architectural choices to Endo.

[18:11:34.0739] <Kris Kowal>
Or rather is born from similar requirements: All things must bundle.

[18:15:54.0808] <nicolo-ribaudo>
Kris Kowal Do you know what's the best way to share my refactor with Caridy? I see that he's not in this room.

[20:36:10.0917] <Jack Works>
Did a quick scan over the refactor spec:

1. `ContinueDynamicImport` should not try to `Link()` / `Evaluate()` multiple times.
2. Should `[[LoadedModules]]` be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.
3. `InnerModuleLoading` is it a normative change? Say, today loading a module can be unordered (as I can recall)

Module block spec:

1. Why disallow import a module block from another realm? (13.3.10.1, step 6.a)
2. Looks like you're not using the building layers from the compartments? (`Module` and `ModuleSource` class)
3. IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)

[20:36:31.0641] <Jack Works>
 * Did a quick scan over the refactor spec:

1. `ContinueDynamicImport` should not try to `Link()` / `Evaluate()` multiple times.
2. Should `[[LoadedModules]]` be added in Abstract Module Record instead of Cyclic Module Record? A non-cyclic-able module type can also have dependencies.
3. `InnerModuleLoading` is it a normative change? Say, today loading a module can be unordered (as I can recall)

Module block spec:

1. Why disallow import a module block from another realm? (13.3.10.1, step 6.a)
2. Looks like you're not using the building layers from the compartments? (`Module` and `ModuleSource` class)
3. IIRC we may want to hide the source of a module. Source may not always be available on some platform, like embedding JS engine. (21.6.2.1, step 2.a)

[22:02:20.0595] <littledan>
To review these PRs, understand the ModuleBlock class to stand for Module/ModuleInstance

[22:03:58.0293] <littledan>
Since we are talking about instances, they exist just within one module graph and therefore one realm. You can make a different module instance (eg with structured clone) to get something similar but within another module graph

[22:06:10.0295] <littledan>
Yes, this change is normative, since it makes all environments follow some of the logic that is currently in HTML. I think this logic is pretty reasonable and makes sense to apply universally but we should be careful to examine the various environments that we have to make sure that is appropriate.

[22:07:20.0128] <littledan>
How does ContinueDynamicImport Link/Evaluate the same thing multiple times? I agree that it shouldn‚Äôt do that

[22:08:25.0789] <littledan>
I agree that the source might not always be visible to JS code. How does that relate to these patches?

[22:10:10.0106] <littledan>
About AbstractModuleRecord vs CyclicModuleRecord: currently, the notion of an import/dependency is all in CyclicModuleRecord. We could generalize this but I think it would help to have a driving use case where we don‚Äôt want to use CyclicModuleRecord, which I can‚Äôt think of. This refactoring seems orthogonal to the current PR.

[00:15:00.0758] <guybedford>
nicolo-ribaudo: great to see! Will review further over the weekend. Did you mean to also include the updates to HostResolveImportedModule calls in InnerModuleLinking and InnerModuleEvaluation? I didn't see those included.

[03:45:07.0672] <nicolo-ribaudo>
Thanks or the review!

1. Both `Link()` and `Evaluate()` are idempotent operations: calling them multiple times has no effect. They are the "public interface" of module records, and we shold use them rather than checking the `[[Status]]` (which is an "implementation detail" of Cyclic Module Records). It already happens that they are called multiple times:
    - ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated
    - HTML always calls them even for all module records imported either with a `<script>` tag or with dynamic import, even if they have already been linked/evaluated
2. ECMA-262 never fiddles with the internals of non-cyclic module records, for example the `.Link()` and `.Evaluate()` implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move `LoadRequestedModules` to Abstract Module Record, where we have `Link` and `Evaluate`.
3. Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make `HostLoadImportedModule` behave just like `HostLoadResolvedModule`/`HostImportModuleDynamically` depending on where it's called from. I don't think this refatoring is necessarily normative.

Regarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.

[03:45:26.0385] <nicolo-ribaudo>
> <@guybedford:matrix.org> nicolo-ribaudo: great to see! Will review further over the weekend. Did you mean to also include the updates to HostResolveImportedModule calls in InnerModuleLinking and InnerModuleEvaluation? I didn't see those included.

There is an editorial note that says "update all the examples of HostResolveImportedModules"

[03:46:03.0883] <nicolo-ribaudo>
 * Thanks or the review!

1. Both `Link()` and `Evaluate()` are idempotent operations: calling them multiple times has no effect. They are the "public interface" of module records, and we shold use them rather than checking the `[[Status]]` (which is an "implementation detail" of Cyclic Module Records). It already happens that they are called multiple times:
    - ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated
    - HTML always calls them even for all module records imported wither with a `<script>` tag or with dynamic import, even if they have already been linked/evaluated

2. ECMA-262 never fiddles with the internals of non-cyclic module records, for example the `.Link()` and `.Evaluate()` implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move `LoadRequestedModules` to Abstract Module Record, where we have `Link` and `Evaluate`.
3. Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make `HostLoadImportedModule` behave just like `HostLoadResolvedModule`/`HostImportModuleDynamically` depending on where it's called from. I don't think this refatoring is necessarily normative.

Regarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.

[03:46:19.0675] <nicolo-ribaudo>
 * Thanks or the review!

1. Both `Link()` and `Evaluate()` are idempotent operations: calling them multiple times has no effect. They are the "public interface" of module records, and we shold use them rather than checking the `[[Status]]` (which is an "implementation detail" of Cyclic Module Records). It already happens that they are called multiple times:
    - ECMA-262 always calls them for non-cyclic module records, even if they have already been linked/evaluated
    - HTML always calls them even for all module records imported either with a `<script>` tag or with dynamic import, even if they have already been linked/evaluated
2. ECMA-262 never fiddles with the internals of non-cyclic module records, for example the `.Link()` and `.Evaluate()` implementations are only given for cyclic module records. From its point of view, that they are terminal nodes of the dependencies graph and they have to handle their own dependencies opaquely. However, it makes sense to move `LoadRequestedModules` to Abstract Module Record, where we have `Link` and `Evaluate`.
3. Hosts can still load dependencies in the order they want: they can continue pre-fetching them as they currently do, and make `HostLoadImportedModule` behave just like `HostLoadResolvedModule`/`HostImportModuleDynamically` depending on where it's called from. I don't think this refatoring is necessarily normative.

Regarding module blocks: yes, the spec still needs to be updated after the harmony discussions in the last week, I only rewrote the current state of the proposal.

[16:36:54.0637] <guybedford>
Okay, I just would have thought that the InnerModuleLinking logic repeats a lot of the payload logic you have.


2022-07-24
[08:40:36.0134] <littledan>
> <@kriskowal:matrix.org> I think the ends I‚Äôm looking for could be accomplished another way, then‚Ä¶

maybe through a callback that can be invoked synchronously?

[08:40:55.0154] <littledan>
> <@guybedford:matrix.org> Okay, I just would have thought that the InnerModuleLinking logic repeats a lot of the payload logic you have.

what do you mean by this?

[12:19:37.0337] <guybedford>
Usually when writing a module loader, you only need to do two passes over the graph

[12:19:45.0433] <guybedford>
one pass to load the modules, and another pass to execute them

[12:19:52.0189] <guybedford>
the specification currently already has two passes

[12:19:54.0887] <guybedford>
you're adding a third

[12:19:59.0472] <guybedford>
just wondering if we can condense that

[12:20:32.0619] <littledan>
it'd be nice if we could, but the three passes existed in ES+HTML before, didn't they?

[12:20:49.0055] <guybedford>
Yeah I guess once you add HTML that's three certainly

[12:21:03.0982] <littledan>
this patch is all about just moving the logic from HTML to ES without changing semantics

[12:21:41.0141] <littledan>
I honestly don't know how we could move linking to be on-line during fetching and parsing, but maybe you see a way

[12:22:18.0713] <guybedford>
that makes sense, I guess the distinction in the iteration approach is based on that async / sync difference as well

[12:22:44.0258] <littledan>
what do you mean by that?

[12:24:13.0445] <guybedford>
the InnerModuleLinking algorithm is a recursive functional approach, while the new logic carries a payload state and a continuation system. They're two ways of doing the same thing it seems?

[12:24:31.0848] <littledan>
oh, yes, that's related to being async

[12:24:59.0353] <littledan>
and the logic is really cribbed from HTML IIRC

[12:25:26.0084] <guybedford>
ah I see, didn't realise that

[12:26:31.0658] <guybedford>
This makes sense then! I wasn't suggesting anything major, was also just interested if there were other simplifications which result for InnerModuleLinking as we do this

[12:26:43.0382] <guybedford>
eg if parts of what is doing in InnerModuleLinking could be brought into the loading

[12:26:54.0088] <littledan>
maybe there are! I feel like getting all this in one place gives us more of an opportunity for that.


2022-07-25
[01:01:42.0114] <Rob Palmer>
Good morning, all. I wanted to reiterate a bit on what I said in plenary and also afterwards direct to Kris last week.

The layered modules APIs that Kris presented are great at permitting a bunch of use-cases. In particular I like the idea of using them for achieving mocking in a test runner (avoiding the need for code to use DI patterns or custom host hooks).

The bigger win (value proposition) is if we can identify features that will allow the wider ecosystem to adopt ES modules. npm & Node mostly ship and execute CommonJS. No one has provided a compelling or easy migration story. So we have a situation that may even be worse than the Python 2/3 switchover.

A key specific use-case that CJS still beats ESM on is the ability to ergonomically/quickly achieve fast load times via lazy loading. Meaning the Babel option "lazy" on the ESM->CJS transform that injects conditional synchronous requires to defer loading static imports to instead be just-in-time.

ESM has no ergonomic way to achieve this. Instead users are forced to rewrite their app to become async and use dynamic `import() `. Because switching sync->async functions have ripple effects back to the caller.

Originally Yulia's defer-eval proposal looked like it might solve this problem. But I understand the sync part of that proposal is now under debate.

My purpose in conveying this is not to demand sync loading. It is to highlight that, if you can make migration from CJS to ESM easier, then (1) the community/ecosystem will love you and see the value of your work, and (2) it will be easier to fund this work stream.

[05:56:46.0979] <littledan>
I really like Rob's idea in the abstract, but I'm having trouble understanding what it means concretely. Would we ask people to write app-specific compartment adapters? Or would there be one in the ecosystem that catches on?

[12:29:37.0825] <Kris Kowal>
I read the request as one to find a solution to the problem that named imports can‚Äôt trigger an export accessor, the way destructuring a module.exports can.

[12:30:30.0417] <Kris Kowal>
Or to find a different way to solve the problem that export accessors currently do, in a way that helps existing CommonJS code lift into ESM.

[12:31:08.0703] <Kris Kowal>
Which will be hard and I imagine most solutions to be worse than the problem, but it‚Äôs very fair to ask us to think about it.

[12:32:34.0697] <Kris Kowal>
I personally find it appetizing to force that particular kind of CommonJS to be rewritten into patterns more amenable to tree shaking in ESM, but that‚Äôs contrary to the goal of easing adoption.

[12:44:12.0168] <littledan>
I'm not sure if accessors are the goal here, though they would actually help us with something else! namely the goal of deferred module evaluation, where the module body is only run on the first access of one of the exports

[12:44:43.0900] <littledan>
(TLA would be handled by running the async subgraph eagerly, and only being lazy about the stuff on top of that)

[12:45:32.0598] <Kris Kowal>
Sure, that sounds like a similar solution to the same problem.

[13:23:56.0096] <nicolo-ribaudo>
Wasn't there a proposal for export accessors a few years ago?

[13:27:57.0987] <guybedford>
Thanks Rob Palmer for the input, very good points raised. My personal take on this perspective would be to ensure we have lazy execution and sync execution as a possibility of the "epiche" (in the spirit of continued mutation of the word). I completely get that these CJS -> ESM scenarios are causing friction for adoption, although a concern here is that this is a Node.js-specific issue that even with a spec unlock won't guarantee progress. Unfortunately Node.js is now caught up in a bind with its own loader system causing asynchronous loading requirements, although there are people actively working on making hooks sync by moving them off thread. Funding on the Node.js side may well speed things up there as well. On the ECMA-262 side, I could imagine a follow-up or new iteration of Yulia's proposal that tackles lazy execution and sync execution to fit into this story and I'd be more than happy to be involved in discussions here. From my perspective I don't see any frictions or concerns regarding the overall picture, short of more features just being more complexity, but I don't personally see an issue with adding complexity to the module system since it also means more control over performance and loading in the hands of users.

[14:09:24.0751] <Kris Kowal>
Soon: quiche.


2022-07-26
[01:36:39.0659] <yulia>
> <@guybedford:matrix.org> Thanks Rob Palmer for the input, very good points raised. My personal take on this perspective would be to ensure we have lazy execution and sync execution as a possibility of the "epiche" (in the spirit of continued mutation of the word). I completely get that these CJS -> ESM scenarios are causing friction for adoption, although a concern here is that this is a Node.js-specific issue that even with a spec unlock won't guarantee progress. Unfortunately Node.js is now caught up in a bind with its own loader system causing asynchronous loading requirements, although there are people actively working on making hooks sync by moving them off thread. Funding on the Node.js side may well speed things up there as well. On the ECMA-262 side, I could imagine a follow-up or new iteration of Yulia's proposal that tackles lazy execution and sync execution to fit into this story and I'd be more than happy to be involved in discussions here. From my perspective I don't see any frictions or concerns regarding the overall picture, short of more features just being more complexity, but I don't personally see an issue with adding complexity to the module system since it also means more control over performance and loading in the hands of users.

from my perspective, and also from hearing from developers -- we may want to provide a high level construct that allows sync loading depending on the environment, but which is independently useful

[01:37:06.0511] <yulia>
This would require loosening early error restrictions, maybe only for modules

[03:53:26.0654] <Rob Palmer>
>depending on the environment

Please could you expand on what this means, Yulia

[03:55:27.0444] <yulia>
> <@robpalme:matrix.org> >depending on the environment
> 
> Please could you expand on what this means, Yulia

for example, the browser may want to implement something like a library module in an async fashion, while node may want to do that in a sync fashion

[03:56:12.0337] <yulia>
the idea is to make the only observable difference be time

[04:02:44.0272] <Rob Palmer>
I can understand that the host-provided loader could differ.  What about virtualized environments?  I was assuming a user-hosted virtualized module graph could/would be as identical as possible - and therefore if sync loading were possible, that would be achievable in a virtualized environment running in a browser.

[04:16:55.0059] <yulia>
yes, if i understand things correctly, virtualized environments would allow this. Maybe i don't understand where the confusion is?

[04:23:21.0454] <Rob Palmer>
IIUC it sounds like Node could offer sync loading, browsers would not, and virtualized environments on both could

[06:15:06.0747] <nicolo-ribaudo>
Sync loading would also solve the concern that some delegates have with the stdlib modules that some delegates have, that they wouldn't be synchronously available in scripts 

[06:18:25.0639] <yulia>
just so we are clear... there isn't a disagreement here?

[06:24:20.0319] <nicolo-ribaudo>
^ temperature check üòâ
‚ûï, üü∞, and ‚ûñ

[06:43:36.0008] <Rob Palmer>
> <@yulia:mozilla.org> just so we are clear... there isn't a disagreement here?

correct - only refinement of understanding

[06:44:02.0073] <littledan>
Moddable has also brought up sync loading as an important concern for them

[06:44:12.0058] <littledan>
Promises often have too much overhead

[06:44:32.0910] <littledan>
At the same time, TC39 has so far come down hard on the side of async loading

[06:44:39.0447] <yulia>
yes -- I think my goal would be to provide a way of restricting modules to a subset where differences in loading are undetectable. 

[06:44:53.0260] <littledan>
There was a big debate at the point of introducing dynamic import, for example.

[06:44:59.0655] <yulia>
so, they can be shared across different loading strategies and work roughly the same way

[06:45:33.0066] <yulia>
> <@littledan:matrix.org> There was a big debate at the point of introducing dynamic import, for example.

yes... i recall this one and reading through it. Dynamic import was initially introduced to allow something like cjs loading iirc

[06:46:04.0040] <littledan>
> <@littledan:matrix.org> (TLA would be handled by running the async subgraph eagerly, and only being lazy about the stuff on top of that)

I think this approach would be more general than restricting to just things which are only undetectable

[06:46:15.0408] <littledan>
JS doesn't have much of a pure subset--just function declarations basically

[06:46:43.0473] <littledan>
Deferred module evaluation, in how I pictured it, would be observable but well-defined

[06:46:51.0879] <yulia>
My view is: we have a low level utility for customizing loading however necessary. In addition, we have a "programmer mental model assisting" way of writing moduels -- where the module is written in a way that it doesn't expose some behaviors. I think we are all discussing the same thing: no TLA. In addition, no modification of globals in my view

[06:47:07.0095] <yulia>
yep, there is an observable aspect to it

[06:47:29.0888] <littledan>
> <@yulia:mozilla.org> yes... i recall this one and reading through it. Dynamic import was initially introduced to allow something like cjs loading iirc

What do you mean by this comment on motivation? I thought code splitting was always part of the goal.

[06:47:31.0201] <yulia>
ideally, its "just" timing. in practice -- early errors, and impacts on the module itself would be observable

[06:48:43.0051] <littledan>
> <@yulia:mozilla.org> yes -- I think my goal would be to provide a way of restricting modules to a subset where differences in loading are undetectable.

What did you mean by this comment?

[06:48:59.0063] <yulia>
> <@littledan:matrix.org> What do you mean by this comment on motivation? I thought code splitting was always part of the goal.

I would have to dig it up. But there were multiple goals. One stated by the original proposer was cjs

[06:49:33.0643] <littledan>
Yeah no disagreement that something analogous to require was *one* of the goals

[06:56:41.0171] <Jack Works>
> <@yulia:mozilla.org> yes... i recall this one and reading through it. Dynamic import was initially introduced to allow something like cjs loading iirc

And now it gets reversed, people use it to load esm from cjs ü§î


2022-07-27
[15:50:01.0224] <Kris Kowal>
nicolo-ribaudo: In the extra time on the SES call, caridy agreed to add referrer, so new Module(source, referrer, ‚Ä¶) and we are still working on the importMeta and importHook order/optionality. But, among us, we‚Äôve arrived at importHook(specifier, referrer) for the hook signature. 

[15:51:01.0212] <Kris Kowal>
I still need to integrate your insights for import assertions, and I think that means we need an options bag. 

[16:00:02.0292] <Kris Kowal>
@yulia In the Moddable notion of sync modules is that a module graph that is already loaded can be synchronously executed, specifically. They don‚Äôt do sync load per se. 

[16:00:14.0380] <Kris Kowal>
* @yulia The Moddable notion of sync modules is that a module graph that is already loaded can be synchronously executed, specifically. They don‚Äôt do sync load per se. 

[16:01:25.0992] <Kris Kowal>
It would be like: import(module) would be equivalent to await load(module); importNow(module)

[16:02:20.0823] <Kris Kowal>
And that clearly looks better as methods of Module.prototype, rather than overloading dynamic import, but that‚Äôs for the bike shed

[16:02:25.0531] <Kris Kowal>
* And that clearly looks better as methods of Module.prototype, rather than overloading dynamic import, but that‚Äôs for the bike shed


2022-07-28
[23:09:59.0941] <nicolo-ribaudo>
> <@kriskowal:matrix.org> nicolo-ribaudo: In the extra time on the SES call, caridy agreed to add referrer, so new Module(source, referrer, ‚Ä¶) and we are still working on the importMeta and importHook order/optionality. But, among us, we‚Äôve arrived at importHook(specifier, referrer) for the hook signature.

I've got some ideas when I left the SES call too üòõ I'll post them on GitHub so that Caridy can see them.

[05:59:59.0190] <littledan>
what happened in that call? Sorry I missed it

[06:33:23.0544] <nicolo-ribaudo>
We reviewed Caridy's proposed spec for Layer 0 of compartments, and my host hooks refactor. Then they had the discussion about referrer vs importMeta.

[07:40:13.0243] <littledan>
how do people feel about the host hooks refactor?

[07:48:58.0350] <nicolo-ribaudo>
Yesterday there were no negative comments! We were unsure if it's editorial or normative, but it's something that we can figure out. I believe that the only potentially observable change from user code is that if you import the same module dynamically twice in the same file, the number of promise ticks needed to "call" the second import is now spec-defined rather than host-defined.

[07:49:23.0962] <littledan>
I think we'll continue to disagree on whether such a change is normative, but that shouldn't block it from landing :)

[07:50:42.0220] <littledan>
there's the argument that "layering" changes are not normative but just editorial refactoring, and there are people who see the host hooks as a critical layer with normative semantics. Either way, it should be reviewed in plenary since it's a big change.

[07:52:11.0000] <nicolo-ribaudo>
Yes I agree that we should not do this "silently" just with the editors

[07:52:21.0798] <littledan>
Has there been any more discussion on whether import reflection should give you a Module or ModuleSource/WebAssembly.Module?

[07:52:34.0373] <nicolo-ribaudo>
Nope

[07:52:51.0667] <littledan>
maybe we can put this on our modules call agenda next time?

[07:52:57.0459] <littledan>
 * maybe we can put this on our modules call agenda next time?

[07:53:26.0863] <littledan>
 * there's the argument that "layering" changes are not normative but just editorial refactoring, and there are people who see the host hooks as a critical layer with normative semantics. Either way, it should be reviewed in plenary since it's a big change.

[07:54:54.0916] <littledan>
one detail which we haven't explicitly discussed is that, if we go the Module way, we should allow people to ship this *while initially rejecting if you directly import() a Wasm module*. This is because implementing Wasm/ESM integration is a lot of work, not so useful yet, and it shouldn't block getting access to the WebAssembly.Module

[07:55:21.0214] <littledan>
 * one detail which we haven't explicitly discussed is that, if we go the Module way, we should allow people to ship this _while initially rejecting if you directly import() a Wasm module_. This is because implementing Wasm/ESM integration for instances is a lot of work, not so useful yet, and it shouldn't block getting access to the WebAssembly.Module

[10:45:01.0525] <Kris Kowal>
Would be weird if we get stuck in the intermediate state, where you can import the source but not the instance, indefinitely. But, I assume there‚Äôs not much risk of that.

[10:46:12.0547] <Kris Kowal>
> <@littledan:matrix.org> I think we'll continue to disagree on whether such a change is normative, but that shouldn't block it from landing :)

Yeah, the only reason to even answer the question is if we wanted to land before plenary, and we don‚Äôt need to. Plenaries are frequent.

[10:46:58.0169] <littledan>
> <@kriskowal:matrix.org> Would be weird if we get stuck in the intermediate state, where you can import the source but not the instance, indefinitely. But, I assume there‚Äôs not much risk of that.

Eh, IMO we should evaluate how weird this is and whether we're OK with it. The next browser winter may come at any moment!

[10:49:01.0963] <Kris Kowal>
We should definitely think that through. The alternate future is one where web assembly modules are just asset modules that default export WebAssembly.Module that somehow is blessed with an origin like a trusted type.

[10:49:58.0978] <Kris Kowal>
But even in that alternate future, we would want to have module source objects for ESM. The various futures might be equally weird.

[10:50:35.0675] <Kris Kowal>
I think I would prefer to gamble that WebAssembly be able to participate in the JS module graph eventually.

[10:50:46.0797] <Kris Kowal>
Because, it clearly can.

[10:50:56.0609] <Kris Kowal>
Perhaps not without compromise, but it can.


2022-07-29
[20:23:30.0212] <sis3020>
Come play the top mmorpg https://feetporn.win/ dmcbqw play soon

[21:57:47.0589] <Jack Works>
> <@kriskowal:matrix.org> I read the request as one to find a solution to the problem that named imports can‚Äôt trigger an export accessor, the way destructuring a module.exports can.

I don't think access a named import _should_ trigger any kind of user code. That's not a good idea.

[22:04:49.0073] <Jack Works>
> <@littledan:matrix.org> Moddable has also brought up sync loading as an important concern for them

I think maybe XS can implement `Promise` and dynamic `import()` in a way that, 

- Promise constructor is not constructable
- No Async Function
- dynamic `import` or `Module#import()` will resolve the Promise in sync.
- Promise.then/catch/finally is not callable

For the given constraint above, the top level await `await import("./some-file.js")` will looks almost sync (maybe there is some ticking problem?)

[23:37:18.0906] <Kris Kowal>
Perhaps I can ask naugtur to put together an example cjs virtual module source. I believe he may have adequately addressed Rob‚Äôs request in Endo by linking CJS on the plane of default exports, which allows for lazy accessors

[00:04:28.0245] <Kris Kowal>
> <@jackworks:matrix.org> I think maybe XS can implement `Promise` and dynamic `import()` in a way that, 
> 
> - Promise constructor is not constructable
> - No Async Function
> - dynamic `import` or `Module#import()` will resolve the Promise in sync.
> - Promise.then/catch/finally is not callable
> 
> For the given constraint above, the top level await `await import("./some-file.js")` will looks almost sync (maybe there is some ticking problem?)

I think this will look more like `Module#importNow()` for Moddable. It is possible to have both `Module#import()` and `Module#importNow()`, where the latter just throws if the transitive dependencies have not yet been loaded. For parity with Compartment, that would entail having `Module#load()`, which would just do the load phase, driving the `importHook` but not linking, initializing, or executing, such that `Module.prototype.import = async () => { await this.load(); return this.importNow(); }`

[04:16:15.0277] <naugtur>
I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  `require`d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.

[04:17:10.0059] <naugtur>
> <@kriskowal:matrix.org> Perhaps I can ask naugtur to put together an example cjs virtual module source. I believe he may have adequately addressed Rob‚Äôs request in Endo by linking CJS on the plane of default exports, which allows for lazy accessors

 * I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  `require`d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.

[04:27:42.0798] <naugtur>
 * I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  `require`d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.





[04:31:44.0383] <naugtur>
 * I've checked the current state of Endo and the act of creating a module instance doesn't trigger the getters. They're not triggered if the module is  `require`d either. Importing anything does trigger all the getters. But it looks like an oversight that needs a fix in layers above.

[edit] Looks like the above was interference from the testing method. I'm looking at an example of a getter on cjs `exports` that doesn't trigger the getter when default is imported. 
It's not accessible as a named export though, which might be the whole point here.

[07:34:20.0040] <Kris Kowal>
I think it would be at least partially satisfying if CJS to CJS laziness were preserved. Lazy CJS to ESM would be at least possible if ESM just grabs the default. ESM to ESM laziness would be possible too, on the default. But lazy named imports are probably not in the cards. I think sync execution is a different kind of laziness that might give us parity for ESM but with a different mechanism. Deferred execution yet another. 

[07:38:13.0588] <Kris Kowal>
And of course code splitting and tree shaking are both ESM native solutions in the same space. I‚Äôm a fan of linear progressive bundles: where the bundle has disjoint sub-bundles from a sequence of entrypoints.

[07:40:03.0871] <Kris Kowal>
Ten years ago, FaceBook did something similar for code delivery, but non-linearly. Their bundles attempted to predict common combinations, with minimal but nonzero overlap


2022-07-31
[02:25:32.0785] <ljharb>
> <@kriskowal:matrix.org> And of course code splitting and tree shaking are both ESM native solutions in the same space. I‚Äôm a fan of linear progressive bundles: where the bundle has disjoint sub-bundles from a sequence of entrypoints.

treeshaking works just fine for CJS as well - identically well as for ESM - but the only implementation I‚Äôm aware of is for browserify; the others haven‚Äôt bothered.

[02:28:31.0515] <naugtur>
> <@ljharb:matrix.org> treeshaking works just fine for CJS as well - identically well as for ESM - but the only implementation I‚Äôm aware of is for browserify; the others haven‚Äôt bothered.

We tried to use it at MetaMask and it was not effective. @kumavis started one with a different approach to eliminating unused exports. 

[02:29:27.0639] <ljharb>
that‚Äôs good to know; I‚Äôm still not convinced tho since none of the bundlers have seemingly tried.

[02:29:32.0272] <naugtur>
For now there's no cjs treeshaking we could get to work and provide noticable results 

[02:29:41.0042] <ljharb>
to be fair ESM treeshaking doesn‚Äôt work that well either

[02:29:58.0933] <ljharb>
at Coinbase, we banned re-exporting in favor of deep importing and the RN app‚Äôs size dropped like 20% instantly

[02:30:59.0363] <ljharb>
so i still think the best approach is always ‚Äúonly importing what you need in the first place‚Äù, and then you don‚Äôt need the crutch of treeshaking at all :-)

[02:34:05.0916] <naugtur>
Own code is less of an issue. Libraries tend to bundle a bunch of related functionality where you only need a small subset (esp. tools like cryptography libs or lodash). These are treeshakeable but a lot of work goes into correctly detecting unreachable code

[02:34:39.0738] <naugtur>
* Own code is less of an issue. Libraries tend to bundle a bunch of related functionality where you only need a small subset (esp. tools like cryptography libs or lodash). These are treeshakeable but a lot of work goes into correctly detecting unreachable code

[02:36:20.0162] <naugtur>
And that's what failed with browserify treeshaking. It disconnects unused export and then leaves deleting code to minification step. 

[02:37:08.0508] <naugtur>
Meanwhile the way cjs exports tend to be defined they're reachable from module scope and therefore never eliminated by dead code elimination

[02:37:44.0488] <naugtur>
I doubt it's possible to address with anything we do here though.

[02:39:12.0935] <naugtur>
* I doubt it's possible to address with anything we do here though.

[05:22:32.0049] <Jack Works>
<del>we don't use minifier in our production because it is delivered by zip file, and we want better debugibility</del>

[05:45:30.0296] <Jack Works>
> <@naugtur:matrix.org> Own code is less of an issue. Libraries tend to bundle a bunch of related functionality where you only need a small subset (esp. tools like cryptography libs or lodash). These are treeshakeable but a lot of work goes into correctly detecting unreachable code

Some code bundles outdated polyfills (especially regenerator-runtime), that bring a lot of problems when we want to adopt SES lockdown

[07:57:03.0148] <naugtur>
This is headed off topic real fast, but maybe we could put noop setters on existing fields we want to protect

