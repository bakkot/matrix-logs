2022-07-01
[13:50:10.0331] <Kris Kowal>
Caridy (and by association Daniel) have convinced me that we can use `importMeta` as in `new Module(source, importHook, importMeta)` and in `importHook(importSpecifier, importMeta)` to stand in for a ‚Äúreferrer‚Äù and that every host environment would still be able to emulate every other host environment. The key is that `importMeta` is object identical in these cases so can be used to carry a gensym or as a key in a WeakMap, even though it‚Äôs not identical to the `import.meta` that the evaluated module sees (unless we change that in ecma262 too!).

[13:52:49.0047] <Kris Kowal>
Caridy and I have also come to an agreement that the next revision of the compartments proposal will reify the constructor named `Module` since we believe module harmony will likely mean `module {} instanceof Module`, where `Module(source, importHook, importMeta)` generates unlinked, linkable, initializable instances of modules.

[13:56:37.0723] <Kris Kowal>
I‚Äôve also agreed that there‚Äôs no need for the module constructor to _ever_ have an option to override the execution context of the module instances it creates. We can carve out a supplemental proposal for a reified `new ExecutionContext()` that would carry new evaluators `eval`, `Function`, and `Module` bound to the same \[\[Realm\]\]. Between `Module`, `ModuleSource`, and `ExecutionContext`, we would have everything we need to build compartments in user code. We could still go on to provide a `Compartment` constructor in the language, but the motivation would be ergonomics and performance, and would be entirely orthogonal to these primitives, which we agree ought to be exposed.

[13:58:01.0090] <Kris Kowal>
 * I‚Äôve also agreed that there‚Äôs no need for the module constructor to _ever_ have an option to override the execution context of the module instances it creates. We can carve out a supplemental proposal for a reified `new ExecutionContext()` that would carry new evaluators `eval`, `Function`, and `Module` bound to the same \[\[Realm\]\]. Between `Module`, `ModuleSource`, and `ExecutionContext`, we would have everything we need to build compartments in user code. We could still go on to provide a `Compartment` constructor in the language, but the motivation would be ergonomics and performance, and would be entirely orthogonal to these primitives, which we agree ought to be exposed.

[14:10:33.0757] <Kris Kowal>
I‚Äôve also convinced myself that, if module instances locally memoize the results of their `importHook` for both static and dynamic import, and since the import hook returns module instances, we can induce that import is sufficiently idempotent in aggregate to prevent all useful surprises. Compartments allow for those memos to be slightly more economical with memory, but probably not in any meaningful way in practice. Again, no reason we couldn‚Äôt have both in the fullness of time, but I‚Äôm convinced we should focus on the `Module` and `ModuleSource` primitives.

[14:12:03.0687] <Kris Kowal>
 * I‚Äôve also convinced myself that, if module instances locally memoize the results of their `importHook` for both static and dynamic import, and since the import hook returns module instances, we can induce that import is sufficiently idempotent in aggregate to prevent all useful surprises. Compartments allow for those memos to be slightly more economical with memory, but probably not in any meaningful way in practice. Again, no reason we couldn‚Äôt have both in the fullness of time, but I‚Äôm convinced we should focus on the `Module` and `ModuleSource` primitives.

[14:13:44.0585] <Kris Kowal>
I also believe that there is no better contender for the enormously self-assured name `Module`. My expectation is that `Module` will be backed by the Last Module Record type we ever need and that all meaningful extensions to the module system are different kinds of module source, not new kinds of module instance.

[14:19:03.0641] <Kris Kowal>
Caridy is focusing on a minimal layer that achieves parity with the current behaviors of ecma262, just reifying these two functions. I propose, in addition, that the `Module` constructor receives a ***Module Source Protocol*** implementation object, like `{bindings?, initialize?, needsDynamicImport?, needsImportMeta?}` which instances of `ModuleSource` happen to provide. This would be sufficient to define JSON, CommonJS, WASM, &c module sources in user code. However, that protocol would not be adequate to carry CSP information for vetted module sources and would not preclude the introduction of other host-defined module source classes. I expect only host-defined module source classes would be transmissible via structured clone and cary host-vetted origin metadata.

[14:21:24.0122] <Kris Kowal>
I‚Äôve also been convinced that the first argument to `initialize` should be called a ***Module Imports Namespace Exotic Object*** (not a reification of the entire definition of ***Module Environment Record***, just an exotic object that can be used to get and set the import and export bindings of the module, in its internal namespace.


2022-07-02
[19:45:36.0664] <Kris Kowal>
yulia: Goal: The ability to evaluate modules in isolated execution contexts and shared frozen intrinsics, or rather, a foundation on which that can be built.

[19:48:54.0163] <Kris Kowal>
That‚Äôs at least the pretext on which I can conscionably work on this as an Agoric delegate! As a JavaScript user, though, eval-but-for-modules has been a personal goal for a long while now. I proposed a `Module` constructor to TC39 in January of 2010!

[00:27:28.0346] <nicolo-ribaudo>
Kris Kowal I really like this new direction üëÄ


2022-07-03
[09:29:53.0611] <Jack Works>
> <@kriskowal:matrix.org> In any case, I sketched this, borrowing as much as possible from the Compartments proposal https://gist.github.com/kriskowal/288d38e62e55e09685bf62c3a3c25565

> The compartment will leave that promise to dangle, so an eventual rejection will necessarily go unhandled.

I don't agree with this part. If the module throws sync, it will become a sync error that can be caught, but if the promise dangles, I cannot handle it. This creates inconsistency in if module uses TLA or not

[09:35:26.0826] <Kris Kowal>
I also don‚Äôt like it, but couldn‚Äôt think of an alternative behavior. Answering that point consistently with the current host behavior would be ideal.

[09:36:05.0725] <Kris Kowal>
But also, if we reduce the scope to `Module` and `ModuleSource` constructors, I don‚Äôt believe we have to answer the question in our proposal.

[09:36:13.0433] <Jack Works>
Can't it spread to where the import happens? 

[09:36:52.0936] <Kris Kowal>
Is that the behavior of dynamic import for a module and its transitive dependencies when any of them contains top-level-await?

[09:37:05.0742] <Kris Kowal>
Genuinely, not an expert on TLA.

[09:38:03.0609] <Kris Kowal>
That is, does the promise returned by dynamic import settle only when all of the transitive dependencies settle for TLA?

[09:38:48.0534] <Jack Works>
And I wonder how much code I need to write in the user land for the housekeeping work (e.g. module caching stuff), so I can emulate a normal ES module environment (with some built-in modules and a relative path module resolution)? I would like to see an example. 

[09:39:35.0561] <Jack Works>
> <@kriskowal:matrix.org> Is that the behavior of dynamic import for a module and its transitive dependencies when any of them contains top-level-await?

I believe so, otherwise what should be the result of that dynamic import? 

[09:40:15.0764] <Kris Kowal>
The promise returned by dynamic import could settle after all first turns are completed.

[09:40:31.0928] <Kris Kowal>
Not that I think that‚Äôs sensible, but I don‚Äôt assume.

[09:40:43.0435] <Kris Kowal>
And I haven‚Äôt yet read :-)

[09:41:43.0331] <Kris Kowal>
In any case, I think it will be sufficient to fix that text to match whatever already exists, or delete it if we don‚Äôt have to specify the behavior in the module loader / compartments proposal.

[09:42:15.0129] <Kris Kowal>
As for how much needs to be done in user code, I need to write a sketch of implementing Compartment in user code, in terms of Module, ModuleSource, and ExecutionContext constructors.

[09:42:25.0313] <Kris Kowal>
I‚Äôm expecting to write a couple hundred lines.

[09:46:22.0302] <Kris Kowal>
Again, I know almost nothing about top-level-await, having not used it nor watched the proposal develop. Very much dependent on an expert to call out the right answer for sinking promises.


2022-07-04
[01:09:09.0166] <yulia | Out of Office until July 11th>
I am -sick as heck- y'all

[01:09:20.0802] <yulia | Out of Office until July 11th>
I will not be able to run the meeting on wednesday, or attend at all 

[01:09:31.0140] <yulia | Out of Office until July 11th>
shu: do we have an alternative facilitator?


2022-07-05
[02:27:08.0275] <Surma>
Can someone add surma@shopify.com to the calendar invite for the recurring Loader meeting?

[02:27:14.0599] <Surma>
yulia | Out of Office until July 11th: Hope you feel better soon!

[09:51:11.0876] <littledan>
Surma: Note that you may be able to add the whole TC39 calendar for yourself from https://calendar.google.com/calendar/u/0/embed?src=mozilla.com_l7b50itpaa9bnrvr61nebqrne8@group.calendar.google.com&ctz=America/Los_Angeles

[10:19:53.0276] <Surma>
> <@littledan:matrix.org> Surma: Note that you may be able to add the whole TC39 calendar for yourself from https://calendar.google.com/calendar/u/0/embed?src=mozilla.com_l7b50itpaa9bnrvr61nebqrne8@group.calendar.google.com&ctz=America/Los_Angeles

Yeah i did do that! Thank you! I'm just keen to get a reminder for this specific one ;)

[10:49:30.0117] <Kris Kowal>
> <@yulia:mozilla.org> shu: do we have an alternative facilitator?

I believe I should shadow a facilitator before I volunteer for that role, but if nobody steps up, I will definitely do my best impression. My understanding is that this mostly involves making sure agenda and minutes get captured, in addition to shepherding the meeting.

[10:53:22.0418] <Kris Kowal>
I‚Äôve sketched an agenda:
1. Overflow from my kick-off on Module Harmony thru the Compartments lens
2. nicolo-ribaudo on Module Harmony thru the lens of Module Blocks‚Äôs emerging spec text
3. caridy on minimum-viable first-class Module and ModuleSource

[10:57:36.0591] <Kris Kowal>
I believe yulia | Out of Office until July 11th had in mind some important front-matter to get us all on the same page for each other‚Äôs hopes and expectations from module harmony, which I think we ought to pursue as early as possible. I can also attempt to facilitate that, though I‚Äôm also not confident I can fill Yulia‚Äôs shoes.

[10:58:01.0167] <Kris Kowal>
That is, in fact, probably more important to articulate than any of the above.

[10:59:09.0463] <Kris Kowal>
To that end, please give me a thumbs up here if you‚Äôre prepared to speak to your own hopes and expectations of Module Harmony tomorrow.

[10:59:25.0990] <Kris Kowal>
Perhaps we can do a round-the-room.

[11:02:57.0355] <Kris Kowal>
(And of course, I hope any other convener can lead this conversation since I don‚Äôt expect anyone to trust my impartiality!)

[11:56:22.0627] <littledan>
I can help with convening if Yulia is out but at the same time maybe we should just wait until she gets back?

[13:27:00.0177] <Kris Kowal>
> <@littledan:matrix.org> I can help with convening if Yulia is out but at the same time maybe we should just wait until she gets back?

This would probably be wise, as the premise of this harmony group is to keep all stakeholders on the same page.

[13:28:38.0262] <littledan>
I'd like to propose, for an upcoming meeting, a discussion of how we've figured out how a lot of the space factors into three mostly orthogonal proposals (module reflection, module blocks/fragments, and the loader) since I think we made a lot of progress on that in the past couple weeks

[13:29:53.0281] <Kris Kowal>
Agreed. I‚Äôd also like to focus on how the points of intersection appear to be coherent.

[13:30:11.0313] <littledan>
top agenda item: How do we name ModuleInstance/ModuleBlock :)

[13:30:49.0793] <Kris Kowal>
I think with some effort over the next week, we could arrive at the harmonious conclusion: `Module`.

[13:31:44.0081] <Kris Kowal>
And the desugarring of `module {}` to `new Module()`.

[13:32:24.0406] <littledan>
hmm, maybe. I feel suspicious but I'm fine with that as a working title

[13:32:28.0927] <Kris Kowal>
It seems likely to me that, even if the notion of a `Compartment` survives, the notion of a module descriptor probably merges into `Module` instances.

[13:32:38.0358] <littledan>
(basically for the reasons you gave in your last presentation)

[13:32:45.0697] <Kris Kowal>
Yes, rightly suspicious.

[13:33:39.0187] <Kris Kowal>
Some of my thinking, chronicled above, has changed over the last couple weeks.

[13:35:00.0192] <Kris Kowal>
Since Caridy‚Äôs been challenging my assumption that 262 would need to subsume module maps. Nicol√≤ has also been moving in the direction of subsuming module maps. Not sure whether we‚Äôve crossed positions, but that would be funny.

[13:35:28.0963] <littledan>
huh, what do you mean by subsuming module maps?

[13:39:39.0171] <Kris Kowal>
And Nicol√≤ also learned this morning that HTML anchors module maps in an unexpected place: on module instances. That‚Äôs surprisingly consistent with what Caridy is proposing.

[13:41:30.0314] <Kris Kowal>
I mean that module maps are currently implied into existence by 262, through host behaviors. There isn‚Äôt a [[ModuleMap]], say, on a Realm record. (Qualifier: this is hearsay. I‚Äôm not sufficiently intimate with 262 to purport the non-existence of anything within its pages.)

[13:43:58.0724] <Kris Kowal>
Caridy‚Äôs driving toward a simplification of the compartment proposal that notably omits Compartment. I‚Äôm convinced that it‚Äôs functionally equivalent, even up to preserving all useful idempotence invariants and compatibility with our hardened JavaScript objectives. Omitting compartments effectively moves all module memoization behavior to a new kind of concrete Module Record, say, Virtual Module Record, which would be re√Øfied by a `new Module` constructor.

[13:45:11.0180] <nicolo-ribaudo>
(note: the specific word in html for module instances is "module scripts")

[13:45:16.0041] <Kris Kowal>
And I understand that you, Daniel Ehrenberg , provided the useful insight that the `importMeta` is sufficient to imply a referrer without having a dedicated referrer argument on a `Module` constructor.

[13:47:45.0526] <nicolo-ribaudo>
I have to think about this more, but after I talked with you (Kris) I'm convinced that my direction and how I understood Caridy's direction from you are not inconciliabile 

[13:48:14.0732] <nicolo-ribaudo>
Always assuming that compartments/"reified modules" are exactly as much powerful as hosts

[13:48:40.0726] <nicolo-ribaudo>
* Always assuming that compartments/"reified modules" are exactly as much powerful as hosts

[13:48:47.0516] <Kris Kowal>
My opinion is that, to use the name `Module`, it must be exceedingly worthy. That is to say, there must never come a time in the evolution of 262 that we reify an object that is worthier of the title or create a class where this particular kind of module is no more special that the others. I believe it meets that criterion iff it turns out that all specialization of modules going forward is sufficiently addressed with new types of Static Module Record.

[13:49:24.0368] <Kris Kowal>
> <@nicolo-ribaudo:matrix.org> I have to think about this more, but after I talked with you (Kris) I'm convinced that my direction and how I understood Caridy's direction from you are not inconciliabile

Is this to say, you believe these directions are compatible?

[13:50:26.0173] <Kris Kowal>
I‚Äôm hopeful that they are.

[13:50:27.0693] <nicolo-ribaudo>
Yes. The things I added in the modules block spec are all "spec internals", and they shouldn't affect the exposed API in any way

[13:51:09.0487] <littledan>
> <@kriskowal:matrix.org> And I understand that you, Daniel Ehrenberg , provided the useful insight that the `importMeta` is sufficient to imply a referrer without having a dedicated referrer argument on a `Module` constructor.

Caridy seems to have run with this further than I thought possible

[13:51:36.0108] <Kris Kowal>
We may have run together.

[13:51:45.0350] <Kris Kowal>
So I‚Äôll unpack what we learned.

[13:52:22.0681] <littledan>
> <@nicolo-ribaudo:matrix.org> (note: the specific word in html for module instances is "module scripts")

Can I also say that I don't like this name either? :)

[13:52:46.0362] <nicolo-ribaudo>
Yes, it's the most confusing name possible 

[13:52:59.0510] <Kris Kowal>
Assuming `new Module(source, importHook, importMeta)` is sufficient, `importMeta` is _not_ identical to `import.meta` as seen by the source, but _is_ identical to the object received by `importHook` to address the referrer, as in `importHook(importSpecifier, importMeta) => Promise<Module>`.

[13:53:54.0579] <Kris Kowal>
That is to say, that in user code, one can arrange a side table from `importMeta` to `referrer` and it‚Äôs sufficient that import hooks know about it.

[13:54:20.0126] <littledan>
I was thinking about it and... I'm not sure if importHook is at the same level as importMeta. At least, when serializing and deserializing a Module, you'll often preserve the importMeta and swap in a new importHook

[13:54:31.0417] <littledan>
(along with giving it a new identity)

[13:54:34.0452] <Kris Kowal>
That allows for the possibility, as is necessarily the case for some environments, that neither `import.meta.url` and `import.meta.resolve` are available for an `importHook` to use, much less necessarily trust.

[13:54:55.0388] <littledan>
"preserve" importMeta in an abstract sense, though--it will surely be a different object identity

[13:55:16.0374] <littledan>
> <@kriskowal:matrix.org> That allows for the possibility, as is necessarily the case for some environments, that neither `import.meta.url` and `import.meta.resolve` are available for an `importHook` to use, much less necessarily trust.

hmm, why?

[13:55:19.0284] <Kris Kowal>
Yes, `importMeta !=== import.meta`.

[13:55:29.0659] <littledan>
oh! really?

[13:56:07.0098] <Kris Kowal>
I should say, not necessarily ===.

[13:56:41.0635] <littledan>
now I'm even more confused

[13:57:15.0681] <Kris Kowal>
What i‚Äôm saying is that, for the purposes of this side table, importMeta as given to the constructor may be copied over an Object with a null prototype and all useful properties of import hooks are preserved.

[13:58:20.0869] <Kris Kowal>
I‚Äôm not saying that they can‚Äôt be identical. It probably wouldn‚Äôt be useful to create a new mechanism that allows `import.meta` to be a number or a proxy.

[13:58:43.0908] <Kris Kowal>
One way to do that would be copying properties. Another would just be to assert its nature. Asserting it‚Äôs not a proxy is somewhat hard.

[14:01:36.0314] <Kris Kowal>
> <@littledan:matrix.org> hmm, why?

Continuity with the past. The alternative is to suggest that this virtualization be limited to situations where `import.meta.url`, `import.meta.resolve`, or some other property carries the referrer in another host-defined sort of way. Not all existing environments meet that bar. I‚Äôm not suggesting this is a blocker. I‚Äôm suggesting that it‚Äôs definitely not a blocker. Those environments can be emulated with a side table keyed on `importMeta`, regardless of whether that‚Äôs identical to `import.meta`.

[14:03:00.0044] <Kris Kowal>
Which is to say, the problem I imagined with not enshrining `referrer` in the `Module` constructor, turns out to be imaginary.

[14:03:57.0442] <Kris Kowal>
Now, whether the same reasoning applies to module blocks remains mysterious to me.

[14:04:57.0207] <Kris Kowal>
That is, whether it is sufficient to serialize `import.meta` when reconstructing an equivalent module in another worker, as opposed to serializing a [[Referrer]] internal slot.

[14:05:20.0154] <Kris Kowal>
(To the extent that import.meta is serializable!)

[14:05:32.0049] <nicolo-ribaudo>
But isn't `import.meta` lazily-initialized (on first access), so potentially not available when transferring a module block?

[14:05:49.0158] <Kris Kowal>
As written today, yes.

[14:06:17.0434] <Kris Kowal>
Lazy initialization of `import.meta` could be copying properties from `importMeta`.

[14:06:38.0746] <Kris Kowal>
Regardless, if we relaxed the verbiage around lazy initialization of `import.meta`, the change wouldn‚Äôt be observable.

[14:13:34.0385] <Kris Kowal>
Bradley related to us at a SES call of yore that Node.js depends on this laziness to avoid instantiating an `import.meta.resolve` closure for every module. That gets created lazily on the first evaluation of `import.meta`. In the Compartments proposal, we solved that problem by adding a `needsImportMeta` property to `ModuleSource / StaticModuleRecord` instances such that a `loadHook / importHook` can avoid building an `importMeta` except for modules that are likely to need it, by reflecting static analysis.

[14:14:00.0523] <Kris Kowal>
Caridy‚Äôs direction preserves that solution.

[14:14:07.0004] <littledan>
> <@kriskowal:matrix.org> Regardless, if we relaxed the verbiage around lazy initialization of `import.meta`, the change wouldn‚Äôt be observable.

yeah it only seems observable given a sufficiently visible host

[14:14:12.0168] <littledan>
which, probably doesn't exist right now

[14:14:25.0545] <Kris Kowal>
It might with the experimental Node.js Loader.

[14:14:42.0819] <Kris Kowal>
I‚Äôm inclined to hope that we get ahead of that here.

[14:15:37.0886] <Kris Kowal>
And if a host virtualization hook is running synchronously during the first evaluation of `import.meta`, that seems needlessly foot-gunny.

[14:19:31.0752] <Kris Kowal>
shu, littledan We probably ought to decide and communicate a cancellation for tomorrow‚Äôs meeting. Are either of you positioned to reach all participants?

[14:20:50.0157] <guybedford>
FYI I posted https://github.com/whatwg/html/issues/8077 for making `import.meta.resolve` a generic resolver

[14:20:58.0108] <guybedford>
which might be a useful technique for loaders to get access to the global resolver

[14:21:39.0369] <guybedford>
Kris Kowal: are you referring to the SES or modules meeting tomorrow? Is this because we don't have someone to run it?

[14:22:46.0533] <Kris Kowal>
Yulia being absent leaves us without a convener, but more importantly, leaves us without an important stakeholder.

[14:23:08.0782] <Kris Kowal>
 * Yulia being absent leaves us without a convener, but more importantly, leaves us without an important stakeholder.

[14:23:19.0958] <guybedford>
It may still be useful to have the discussion if we can

[14:23:41.0109] <guybedford>
Didn't shu give host credentials to others as well?

[14:23:57.0164] <guybedford>
Has no one else come forward to assist with convening?

[14:23:59.0999] <Kris Kowal>
Yes, others can open the meeting.

[14:24:10.0675] <Kris Kowal>
Dan has come forward to assist with convening if we convene.

[14:24:40.0664] <guybedford>
Even if we don't have all stakeholders, we should still have notes to share and can continue to build some shared understanding on the matters

[14:25:01.0961] <littledan>
> <@guybedford:matrix.org> Didn't shu give host credentials to others as well?

Yes, I should have credentials in theory

[14:25:25.0512] <Kris Kowal>
I think there‚Äôs a hope that we move forward together. Discussions are obviously great, but we don‚Äôt want to assume that the shared context has advanced.

[14:26:26.0815] <Kris Kowal>
That is, if we have any module harmony conversations outside of these ‚Äúincubator‚Äù calls, we need to expect to present our findings again on the call.

[14:27:12.0793] <guybedford>
I think we are still very much in a phase of discovery here

[14:27:20.0939] <Kris Kowal>
This is true.

[14:27:30.0151] <guybedford>
so that it's less about decisions and more about continuing the conversations

[14:27:44.0755] <guybedford>
there's still a lot to discuss!

[14:27:49.0175] <Kris Kowal>
I read you‚Äôre in favor of having a conversation.

[14:27:59.0253] <Kris Kowal>
I‚Äôm also very aware that we have two weeks to plenary.

[14:28:15.0846] <Kris Kowal>
And that I have put my foot into the agenda.

[14:29:02.0790] <guybedford>
Myself and Luca at least would value giving a 10 minute update on where we would like to take import reflection, and before plenary, to ensure we don't step on any toes

[14:29:49.0113] <guybedford>
we want to ensure we're getting the cross-concerns right

[14:30:21.0675] <Kris Kowal>
One option is that I can reconvene the SES meeting.

[14:30:47.0953] <guybedford>
the hope for these meetings, at least for myself, was to be able to see how the pieces of the puzzle can fit together to form a wholistic picture

[14:30:57.0521] <Kris Kowal>
Same, agreed.

[14:31:14.0688] <nicolo-ribaudo>
> <@kriskowal:matrix.org> One option is that I can reconvene the SES meeting.

Aren't "SES meeting and let's talk about modules" and "Modules meeting" effectively the same thing?

[14:32:10.0259] <Kris Kowal>
No, we have an agreement that any findings from the SES meeting will be reprised at the Module Harmony group so that the broader group of stakeholders can stay in sync.

[14:32:41.0301] <nicolo-ribaudo>
Ok right, it would be good then. I don't think we should come to a "group decision" without all the important stakeholders

[14:32:42.0190] <Kris Kowal>
We can of course retcon our findings so we‚Äôre not presenting the incoherent ideas!

[14:33:19.0561] <littledan>
Not sure what you mean by "reprised" but yeah as Nicolo says the important thing is that we don't think of anything from SES as having reached a group decision, but instead having had some interesting discovery-oriented discussions

[14:34:02.0457] <Kris Kowal>
It‚Äôs also important that group decisions don‚Äôt come out of the modules harmony calls, but I think we‚Äôre mostly on the same page üòâ

[14:36:12.0614] <Kris Kowal>
In any case, I‚Äôm going to continue making slides and will expect to share them in one venue or another.

[14:36:41.0264] <Kris Kowal>
And it would be good for us to communicate a decision.

[14:40:08.0934] <guybedford>
It would be good to work through the slides further, it would also be good to have a few mins for us each to share our respective updates

[14:40:59.0020] <guybedford>
we could probably present the current import reflection thinking in about 5 - 10 mins

[14:41:18.0964] <guybedford>
we are actively seeking feedback

[14:42:04.0035] <guybedford>
would it be possible to complete the slides in 30-40 mins?

[14:42:19.0273] <guybedford>
would definitely be useful to continue building out the shared context

[14:42:39.0573] <guybedford>
or is the problem Kris Kowal that you would prefer to have Yulia present for that?

[14:43:55.0557] <Kris Kowal>
I intend to present an abbreviated deck from the overflow from the prior meeting.

[14:44:31.0470] <Kris Kowal>
I think Yulia would have kicked this meeting off with an around-the-room of each of our goals.

[14:45:03.0559] <Kris Kowal>
I‚Äôve asked Nicol√≤ to show what he‚Äôs learned over the last two weeks from writing up spec text for module blocks.

[14:45:40.0429] <Kris Kowal>
I‚Äôd be elated to give you guybedford the floor to sync up on import reflection.

[14:46:20.0478] <Kris Kowal>
Caridy will miss the first 20', but I‚Äôm hoping he gets a chance to share his vision for `Module` and `ModuleSource`.

[14:47:47.0291] <Kris Kowal>
And I think it‚Äôs not too premature to share his sketch (cc nicolo-ribaudo) https://gist.github.com/caridy/98f61cf6100243c3cecef5c16a4eff2d

[15:12:39.0329] <littledan>
Yeah well I'm up to convene/facilitate a discovery-oriented discussion as long as we plan to come back and reconsider things when stakeholders are available

[15:13:06.0684] <littledan>
so we can do this tomorrow at the time in the calendar if people want to

[15:24:42.0969] <Kris Kowal>
That at least has the virtue of not requiring last minute comms.

[15:24:54.0334] <Kris Kowal>
And also an extra half hour of talk time.

[15:38:20.0134] <Luca Casonato>
I will have to drop off at the top of the hour unfortunately, so it‚Äôd be great if we can cover import reflection some time in the first half of the meeting

[15:41:33.0124] <Kris Kowal>
I‚Äôm going to defer my overflow deck to a subsequent meeting. I‚Äôm writing Luca Casonato and guybedford into the agenda as the opening act.

[15:42:02.0314] <Kris Kowal>
Also moved Goals to the next meeting for Yulia.

[15:43:12.0521] <Kris Kowal>
The agenda is a writable link off the TC39 calendar invitation.

[15:45:07.0670] <Luca Casonato>
Thanks Kris


2022-07-06
[18:07:06.0251] <Kris Kowal>
I‚Äôve finished a deck for tomorrow, should time permit. I added this to the end of the meeting as it shows where I think we‚Äôre converging. https://drive.google.com/file/d/1_juf8l8PCrVHA4iA1G4BwQ1JsuXMjOVa/view

[23:53:28.0016] <Jack Works>
> <@kriskowal:matrix.org> I‚Äôve finished a deck for tomorrow, should time permit. I added this to the end of the meeting as it shows where I think we‚Äôre converging. https://drive.google.com/file/d/1_juf8l8PCrVHA4iA1G4BwQ1JsuXMjOVa/view

I like this. Where does the module descriptor go? 

[00:11:22.0336] <Kris Kowal>
Module descriptors cease to be necessary. When implementing a Compartment in user code, module instances replace module descriptors. User-mode Compartments aren‚Äôt able to address modules from the host compartment by name, but import reflection replaces that role.

[00:13:56.0058] <Kris Kowal>
e.g., `defer import fs from 'fs'; new Compartment{{ modules: { fs } }).import('fs')` is a possible solution with a user-code Compartment implementation.

[00:14:57.0283] <Kris Kowal>
(where `defer import` is import reflection. I haven‚Äôt seen a syntax I like for that yet, so just riffing here.)

[00:23:06.0820] <Kris Kowal>
Actually, for inter-compartment linkage, we would have to implement module-descriptors in user code.

[12:29:40.0452] <Kris Kowal>
Are any champions going to seek advancement for module proposals at the next plenary?

[12:30:40.0510] <Luca Casonato>
We are planning to seek stage 2

[12:32:21.0263] <Kris Kowal>
I propose that I repurpose the slot I‚Äôve reserved for compartments to deliver a module harmony, based on where we are as of this morning. My impression is that we need more work on module harmony before we have a proposal that can advance to Stage 2.

[12:33:30.0932] <Kris Kowal>
In my opinion, none of our proposals should advance until we have a shared foundation, and as far as I‚Äôm concerned, that shared foundation could be bundled into any proposal seeking stage 2 or greater.

[12:34:27.0119] <Kris Kowal>
By the shared foundation, I mean the modifications to the abstract module record hierarchy on which we all likely depend.

[12:35:22.0467] <Kris Kowal>
 * I propose that I repurpose the slot I‚Äôve reserved for compartments to deliver a module harmony report, based on where we are as of this morning. My impression is that we need more work on module harmony before we have a proposal that can advance to Stage 2.

[12:36:24.0472] <Kris Kowal>
 * By the shared foundation, I mean the additions to the abstract module record hierarchy on which we all likely depend.

[12:37:32.0950] <guybedford>
Kris Kowal: I'm not sure we should let specification editorial details block individual proposals. As long as each proposal is semantically sound, and we are tackling the shared interaction problems, I don't think we need to converge on sharing exact spec text between proposals especially at this stage.

[12:38:25.0970] <Kris Kowal>
For import reflection, I think the syntax pivot is good. I can see `import module` and `import static module`. I would be okay with `import static module` reifying the literal WASM `Module` object provided that it can be passed to a `new Module(wasmSource, importHook, importMeta)` when first-class modules come.

[12:40:00.0590] <Kris Kowal>
My understanding is that stage 2 requires tentative spec text. I‚Äôm asking that any proposal that advances have tentative spec text that is sufficient for any other module proposal to build upon.

[12:40:25.0575] <Kris Kowal>
I could be wrong. This is my first stage advancement rodeo.

[12:41:11.0948] <Kris Kowal>
But I believe the guiding principle is right: we should not paint ourselves into a corner that would preclude advancement of other proposals, or produce avoidable scar tissue.

[12:41:18.0814] <Kris Kowal>
 * But I believe the guiding principle is right: we should not paint ourselves into a corner that would preclude advancement of other proposals, or produce avoidable scar tissue.

[12:41:42.0719] <Kris Kowal>
But I‚Äôll qualify that: spec text scar tissue does not bother me. Reified object scar tissue does.

[12:42:10.0007] <guybedford>
Right, although Stage 2 is not an implementation stage

[12:42:24.0275] <guybedford>
Only at Stage 3 does scarring start to occur!

[12:43:10.0411] <guybedford>
In our current specification we defined the mechanics of the reflection, but we have left the actual reflection object being returned to be entirely defined by the host for now

[12:43:22.0001] <guybedford>
through a HostResolveModuleReflection hook

[12:43:36.0348] <guybedford>
our hope is that this is clear enough for stage 2, without being too prescriptive yet

[12:43:54.0298] <guybedford>
we would hope to refine for stage 3 some further invariants around the resolution and exact JS reflection object

[12:44:02.0690] <guybedford>
but for now we just treat it as host defined

[12:44:35.0315] <guybedford>
I would be interested to hear if that mitigates your concerns, the spec text PR is up at https://github.com/tc39/proposal-import-reflection/pull/21 and should be landing soon

[12:44:47.0021] <Kris Kowal>
I‚Äôll give it a read.

[12:45:26.0526] <Kris Kowal>
The invariant I would hope to preserve would be `new Module(x, ‚Ä¶rest)` would work for any `x` reflected by `import static module ...`.

[12:45:53.0729] <Kris Kowal>
And I would cut it as fine as differentiating `import module` from `import module static`.

[12:47:09.0639] <Kris Kowal>
I think it is important that `import module x from 'x.any'` should always produce `x instanceof Module` whereas there‚Äôre more degrees of freedom for `import static module x from 'x.any'`.

[12:47:26.0843] <guybedford>
as mentioned in the meeting, we are only interested in the `import module` being the `import static module` case you describe

[12:47:41.0074] <Kris Kowal>
I‚Äôm interested in both existing.

[12:47:41.0815] <guybedford>
we don't have a use case for the module instance reflection

[12:47:57.0458] <Kris Kowal>
Deferred execution is the motivating case for module instance reflection.

[12:48:05.0160] <guybedford>
specifically - what would the import hook be for an implicit instance reflection?

[12:48:39.0833] <guybedford>
deferred execution is not a use case of reflection either, and we have mentioned before this is separate specification work

[12:48:51.0661] <Kris Kowal>
import instance reflection would inherit the surrounding module instance‚Äôs import hook.

[12:49:37.0897] <Kris Kowal>
In my current mental model, these occupy overlapping syntactic space that should be coherent when we have solutions to both problems.

[12:49:47.0079] <guybedford>
it sounds very much like a deferred import

[12:49:51.0555] <Kris Kowal>
It is.

[12:49:58.0888] <guybedford>
That is Yulias area not ours

[12:50:24.0947] <guybedford>
I think it can be achieved but it is a separate specification to what we are working on with module reflection

[12:50:32.0196] <guybedford>
"reflection" by its nature is about a higher order import

[12:50:34.0997] <guybedford>
not an instance import

[12:50:52.0573] <Kris Kowal>
I do not mean to suggest that your proposal should solve both motivating use cases.

[12:51:07.0454] <Kris Kowal>
I do suggest that we are responsible for ensuring that these merge without conflict.

[12:51:36.0073] <guybedford>
it is our collective responsibility to not conflict eachother yes :)

[12:51:37.0690] <Kris Kowal>
I suggest that in the end we should have syntax for both cases.

[12:52:03.0680] <guybedford>
that's fine, and nothing is precluded

[12:52:25.0221] <guybedford>
specifically we have further constrained import reflection to module import reflection

[12:52:51.0516] <guybedford>
other proposals for other types of imports like assets or deferred execution can easily coexist

[12:52:54.0094] <Kris Kowal>
`import module x from 'x.js'` meaning x instanceof `WASM.Module` would preclude `import module x from 'x.js'` alternately meaning `x instanceof Module`.

[12:53:07.0575] <guybedford>
right but it doesn't preclude `import defer x from 'x.js'`

[12:53:22.0366] <Kris Kowal>
I agree that is possible.

[12:53:51.0490] <Kris Kowal>
In a universe with both, are we creating another footnote in WAT.js?

[12:54:11.0585] <guybedford>
if there is issue with the `module` term not being clear enough, we can consider other options

[12:54:19.0362] <guybedford>
the hope was too avoid too much of a bikeshed of course

[12:54:19.0804] <Kris Kowal>
```
import module x from 'x.wasm';
x instanceof Module; // false WAT?
```

[12:54:31.0687] <guybedford>
I hope we could consider this mostly aesthetic as opposed to a primary stage 2 concern

[12:55:14.0000] <Kris Kowal>
I‚Äôll grant this is aesthetic. What stage do aesthetics become a concern?

[12:55:48.0931] <Kris Kowal>
Soft concern for 2, hard concern for 3?

[12:58:46.0093] <guybedford>
From what I believe, stage 2 is expected to be complete specification but can still have open questions

[12:58:58.0353] <Kris Kowal>
I‚Äôll also grant that `import defer x from 'x.any'` has a nice ring to it.

[12:59:39.0632] <guybedford>
we'll make sure to highlight these points, this has been useful

[13:35:46.0505] <littledan>
I think we still have a number of foundational questions to answer, for all of the proposals we're discussing. A number of unresolved points of disagreement just came up in that meeting. I'm fine with things moving to Stage 2 as long as this is to be interpreted explicitly as "we agree that we want to move forward as a committee in this area, and have one concrete idea of how it might work, but we're still open to resolving these foundational questions in multiple ways"

[13:36:18.0817] <nicolo-ribaudo>
> <@guybedford:matrix.org> From what I believe, stage 2 is expected to be complete specification but can still have open questions

Stage 3 is complete specification, for stage 2 you need a draft 

[13:36:41.0320] <littledan>
I mean, module blocks seems to be one of these proposals which has these unresolved foundational questions, and it's already at Stage 2! But this is largely because it hadn't yet occurred to us that module blocks might be referrer-less, which Caridy is now advocating

[13:37:35.0721] <littledan>
I don't tend to agree with people who insist that all foundational questions be addressed by Stage 2. It's just too common for us to find that we need to revisit foundational issues during Stage 2. I think it's more that, Stage 2 indicates a level of interest/resolve to work things out, together with concreteness on *some* possibility

[13:37:51.0214] <littledan>
the bikeshed is definitely not a Stage 2 blocker

[13:39:02.0468] <littledan>
I think we should at least wait until Yulia is back to conclude that deferred module evaluation is separate from Guy's and Luca's proposal. I've heard multiple suggestions that these are really the same space. So if Stage 2 were to be taken to mean, "these are definitely separate"... I wouldn't be ready to say that yet.

[13:41:05.0854] <littledan>
Concretely, I hope we can all get more space to decide whether module blocks and reflective modules are ModuleSource or Module values. My expectation was that they were both Module, but Guy was proposing that reflective modules be ModuleSource, and Caridy was proposing that module blocks be ModuleSource

[13:41:17.0273] <littledan>
I think we can iterate on this question after Stage 2 but before Stage 3

[13:41:27.0307] <littledan>
 * I think we can iterate on this question after Stage 2 but before Stage 3

[13:43:17.0831] <littledan>
I was disappointed that asset references fell out of what Guy and Luca are proposing initially. I'd be interested in hearing more about what's behind that decision, and how soon you'd like to follow up with asset references, since they seem quite useful.

[13:52:14.0399] <littledan>
guybedford: Luca Casonato I'd be happy to have a call with you some time soon to discuss all this more if you're interested

[14:55:26.0362] <Kris Kowal>
Same

[14:56:06.0763] <Kris Kowal>
And I‚Äôm putting together a review to call out at least where I think we‚Äôre headed tentatively where it doesn‚Äôt match. Emphasis on tentative.

[14:56:52.0905] <Kris Kowal>
If I read the room right, I should hurry up and put together some spec text for first class modules (Module and ModuleSource) and shoot for the two.

[15:02:23.0610] <Kris Kowal>
And I think Caridy and I both suggest `module {} instanceof Module` and `static module {} instanceof ModuleSource`. Serializing ModuleSource is uncontroversial. Serializing Module is controversial. By the end of the call, I think we had agreement that Module, if serializable, is intentionally cherry picking the serializable subset of the instance. However, Caridy, Guy, Shu, and I all have misgivings. I have made peace with my misgivings.

[15:05:08.0714] <Kris Kowal>
My feeling is that trusting the sender and receiver to have identical importHook behavior is possible but fragile. But, if we have blocks, static blocks, `Module` and `ModuleSource` to work with, I think that the ecosystem will have everything it needs to come up with more sensible protocols for sending modules to workers.

[15:07:19.0410] <Kris Kowal>
That is to say, I predict that `worker.import(module {})` will look good in examples but will otherwise have limited utility. But, that‚Äôs okay with me.

