2022-07-01
[13:50:10.0331] <Kris Kowal>
Caridy (and by association Daniel) have convinced me that we can use `importMeta` as in `new Module(source, importHook, importMeta)` and in `importHook(importSpecifier, importMeta)` to stand in for a ‚Äúreferrer‚Äù and that every host environment would still be able to emulate every other host environment. The key is that `importMeta` is object identical in these cases so can be used to carry a gensym or as a key in a WeakMap, even though it‚Äôs not identical to the `import.meta` that the evaluated module sees (unless we change that in ecma262 too!).

[13:52:49.0047] <Kris Kowal>
Caridy and I have also come to an agreement that the next revision of the compartments proposal will reify the constructor named `Module` since we believe module harmony will likely mean `module {} instanceof Module`, where `Module(source, importHook, importMeta)` generates unlinked, linkable, initializable instances of modules.

[13:56:37.0723] <Kris Kowal>
I‚Äôve also agreed that there‚Äôs no need for the module constructor to _ever_ have an option to override the execution context of the module instances it creates. We can carve out a supplemental proposal for a reified `new ExecutionContext()` that would carry new evaluators `eval`, `Function`, and `Module` bound to the same \[\[Realm\]\]. Between `Module`, `ModuleSource`, and `ExecutionContext`, we would have everything we need to build compartments in user code. We could still go on to provide a `Compartment` constructor in the language, but the motivation would be ergonomics and performance, and would be entirely orthogonal to these primitives, which we agree ought to be exposed.

[13:58:01.0090] <Kris Kowal>
 * I‚Äôve also agreed that there‚Äôs no need for the module constructor to _ever_ have an option to override the execution context of the module instances it creates. We can carve out a supplemental proposal for a reified `new ExecutionContext()` that would carry new evaluators `eval`, `Function`, and `Module` bound to the same \[\[Realm\]\]. Between `Module`, `ModuleSource`, and `ExecutionContext`, we would have everything we need to build compartments in user code. We could still go on to provide a `Compartment` constructor in the language, but the motivation would be ergonomics and performance, and would be entirely orthogonal to these primitives, which we agree ought to be exposed.

[14:10:33.0757] <Kris Kowal>
I‚Äôve also convinced myself that, if module instances locally memoize the results of their `importHook` for both static and dynamic import, and since the import hook returns module instances, we can induce that import is sufficiently idempotent in aggregate to prevent all useful surprises. Compartments allow for those memos to be slightly more economical with memory, but probably not in any meaningful way in practice. Again, no reason we couldn‚Äôt have both in the fullness of time, but I‚Äôm convinced we should focus on the `Module` and `ModuleSource` primitives.

[14:12:03.0687] <Kris Kowal>
 * I‚Äôve also convinced myself that, if module instances locally memoize the results of their `importHook` for both static and dynamic import, and since the import hook returns module instances, we can induce that import is sufficiently idempotent in aggregate to prevent all useful surprises. Compartments allow for those memos to be slightly more economical with memory, but probably not in any meaningful way in practice. Again, no reason we couldn‚Äôt have both in the fullness of time, but I‚Äôm convinced we should focus on the `Module` and `ModuleSource` primitives.

[14:13:44.0585] <Kris Kowal>
I also believe that there is no better contender for the enormously self-assured name `Module`. My expectation is that `Module` will be backed by the Last Module Record type we ever need and that all meaningful extensions to the module system are different kinds of module source, not new kinds of module instance.

[14:19:03.0641] <Kris Kowal>
Caridy is focusing on a minimal layer that achieves parity with the current behaviors of ecma262, just reifying these two functions. I propose, in addition, that the `Module` constructor receives a ***Module Source Protocol*** implementation object, like `{bindings?, initialize?, needsDynamicImport?, needsImportMeta?}` which instances of `ModuleSource` happen to provide. This would be sufficient to define JSON, CommonJS, WASM, &c module sources in user code. However, that protocol would not be adequate to carry CSP information for vetted module sources and would not preclude the introduction of other host-defined module source classes. I expect only host-defined module source classes would be transmissible via structured clone and cary host-vetted origin metadata.

[14:21:24.0122] <Kris Kowal>
I‚Äôve also been convinced that the first argument to `initialize` should be called a ***Module Imports Namespace Exotic Object*** (not a reification of the entire definition of ***Module Environment Record***, just an exotic object that can be used to get and set the import and export bindings of the module, in its internal namespace.


2022-07-02
[19:45:36.0664] <Kris Kowal>
yulia: Goal: The ability to evaluate modules in isolated execution contexts and shared frozen intrinsics, or rather, a foundation on which that can be built.

[19:48:54.0163] <Kris Kowal>
That‚Äôs at least the pretext on which I can conscionably work on this as an Agoric delegate! As a JavaScript user, though, eval-but-for-modules has been a personal goal for a long while now. I proposed a `Module` constructor to TC39 in January of 2010!

[00:27:28.0346] <nicolo-ribaudo>
Kris Kowal I really like this new direction üëÄ


2022-07-03
[09:29:53.0611] <Jack Works>
> <@kriskowal:matrix.org> In any case, I sketched this, borrowing as much as possible from the Compartments proposal https://gist.github.com/kriskowal/288d38e62e55e09685bf62c3a3c25565

> The compartment will leave that promise to dangle, so an eventual rejection will necessarily go unhandled.

I don't agree with this part. If the module throws sync, it will become a sync error that can be caught, but if the promise dangles, I cannot handle it. This creates inconsistency in if module uses TLA or not

[09:35:26.0826] <Kris Kowal>
I also don‚Äôt like it, but couldn‚Äôt think of an alternative behavior. Answering that point consistently with the current host behavior would be ideal.

[09:36:05.0725] <Kris Kowal>
But also, if we reduce the scope to `Module` and `ModuleSource` constructors, I don‚Äôt believe we have to answer the question in our proposal.

[09:36:13.0433] <Jack Works>
Can't it spread to where the import happens? 

[09:36:52.0936] <Kris Kowal>
Is that the behavior of dynamic import for a module and its transitive dependencies when any of them contains top-level-await?

[09:37:05.0742] <Kris Kowal>
Genuinely, not an expert on TLA.

[09:38:03.0609] <Kris Kowal>
That is, does the promise returned by dynamic import settle only when all of the transitive dependencies settle for TLA?

[09:38:48.0534] <Jack Works>
And I wonder how much code I need to write in the user land for the housekeeping work (e.g. module caching stuff), so I can emulate a normal ES module environment (with some built-in modules and a relative path module resolution)? I would like to see an example. 

[09:39:35.0561] <Jack Works>
> <@kriskowal:matrix.org> Is that the behavior of dynamic import for a module and its transitive dependencies when any of them contains top-level-await?

I believe so, otherwise what should be the result of that dynamic import? 

[09:40:15.0764] <Kris Kowal>
The promise returned by dynamic import could settle after all first turns are completed.

[09:40:31.0928] <Kris Kowal>
Not that I think that‚Äôs sensible, but I don‚Äôt assume.

[09:40:43.0435] <Kris Kowal>
And I haven‚Äôt yet read :-)

[09:41:43.0331] <Kris Kowal>
In any case, I think it will be sufficient to fix that text to match whatever already exists, or delete it if we don‚Äôt have to specify the behavior in the module loader / compartments proposal.

[09:42:15.0129] <Kris Kowal>
As for how much needs to be done in user code, I need to write a sketch of implementing Compartment in user code, in terms of Module, ModuleSource, and ExecutionContext constructors.

[09:42:25.0313] <Kris Kowal>
I‚Äôm expecting to write a couple hundred lines.

[09:46:22.0302] <Kris Kowal>
Again, I know almost nothing about top-level-await, having not used it nor watched the proposal develop. Very much dependent on an expert to call out the right answer for sinking promises.


2022-07-04
[01:09:09.0166] <yulia | Out of Office until July 11th>
I am -sick as heck- y'all

[01:09:20.0802] <yulia | Out of Office until July 11th>
I will not be able to run the meeting on wednesday, or attend at all 

[01:09:31.0140] <yulia | Out of Office until July 11th>
shu: do we have an alternative facilitator?


2022-07-05
[02:27:08.0275] <Surma>
Can someone add surma@shopify.com to the calendar invite for the recurring Loader meeting?

[02:27:14.0599] <Surma>
yulia | Out of Office until July 11th: Hope you feel better soon!

[09:51:11.0876] <littledan>
Surma: Note that you may be able to add the whole TC39 calendar for yourself from https://calendar.google.com/calendar/u/0/embed?src=mozilla.com_l7b50itpaa9bnrvr61nebqrne8@group.calendar.google.com&ctz=America/Los_Angeles

[10:19:53.0276] <Surma>
> <@littledan:matrix.org> Surma: Note that you may be able to add the whole TC39 calendar for yourself from https://calendar.google.com/calendar/u/0/embed?src=mozilla.com_l7b50itpaa9bnrvr61nebqrne8@group.calendar.google.com&ctz=America/Los_Angeles

Yeah i did do that! Thank you! I'm just keen to get a reminder for this specific one ;)

[10:49:30.0117] <Kris Kowal>
> <@yulia:mozilla.org> shu: do we have an alternative facilitator?

I believe I should shadow a facilitator before I volunteer for that role, but if nobody steps up, I will definitely do my best impression. My understanding is that this mostly involves making sure agenda and minutes get captured, in addition to shepherding the meeting.

[10:53:22.0418] <Kris Kowal>
I‚Äôve sketched an agenda:
1. Overflow from my kick-off on Module Harmony thru the Compartments lens
2. nicolo-ribaudo on Module Harmony thru the lens of Module Blocks‚Äôs emerging spec text
3. caridy on minimum-viable first-class Module and ModuleSource

