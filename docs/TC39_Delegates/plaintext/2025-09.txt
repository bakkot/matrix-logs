2025-09-01
[05:19:53.0600] <Lea Verou>
Curious what folks may think about this: https://es.discourse.group/t/text-modules/1031/8

[05:20:39.0493] <Lea Verou>
* Curious what folks may think about this: https://es.discourse.group/t/text-modules/1031/8 (`import with { type: 'text' }`)

[05:21:04.0628] <Lea Verou>
* Curious what folks may think about `import ... with { type: 'text' }` (context: https://es.discourse.group/t/text-modules/1031/8 )

[06:22:36.0742] <Chengzhong Wu>
With https://github.com/tc39/proposal-import-bytes, it can be done like `import ... with { type: 'bytes' }` + `textDecoder.decode(buffer)`

[06:27:26.0271] <nicolo-ribaudo>
There was some appetite for it in the last meeting, strongly pushed for by eemeli

[10:16:14.0066] <bakkot>
yeah I think if someone champions it people are in favor

[11:15:21.0081] <eemeli>
I don't think I've the bandwidth for putting together an import-text proposal for the next plenary, but in case no-one else does, I can try to do so for Tokyo.

[13:07:15.0493] <Michael Ficarra>
@leaverou:matrix.org you can see the notes from the related discussion here: https://github.com/tc39/notes/pull/379/files#diff-16e44c4f2f7e8f811605c9425be9e53906830267d08666efe463e866801d96f7R355-R501

[13:50:21.0141] <eemeli>
Here's a slightly easier and more targeted link for the above: https://github.com/tc39/notes/blob/bcdb104c5783f2d2eca39b31a1d9ab42a3aa3df0/meetings/2025-07/july-30.md#import-buffer-for-stage-1


2025-09-02
[02:17:11.0812] <eemeli>
Back in 2021, when `Object.hasOwn()` raced all the way to Stage 4 in four months, was something like `Object.getOwn()` considered at all? I can't find any reference to such in the notes or the proposal repo.

I'm currently needing to write this repeatedly in a project, and it feels a bit repetitive:
```
let x = Object.hasOwn(obj, name) ? obj[name] : undefined;
```

[02:55:52.0752] <Lea Verou>
When is the Tokyo plenary? There's TPAC in Japan this year so if they're close I may be able to join too!

[03:00:17.0278] <eemeli>
It's the week after TPAC. The meeting schedule is available here: https://github.com/tc39/agendas

[05:39:07.0556] <Michael Ficarra>
Lea Verou: https://github.com/tc39/Reflector/issues/567

[08:26:42.0289] <Chengzhong Wu>
https://github.com/tc39/agendas it seems like the Sept agenda page is not created yet..


2025-09-03
[10:02:38.0156] <ljharb>
sorry about that, i'll make it today

[15:41:34.0595] <Rob Palmer>
I created the agenda earlier today and was going to highlight here, but alas Matrix had an outage so could not.

[15:42:02.0326] <Rob Palmer>
Anyway, the agenda is naturally fresh and light, so please add content! 


2025-09-09
[12:40:37.0569] <bakkot>
so I don't think it's anyone's specific job to merge the notes PRs to https://github.com/tc39/notes/pulls that Aki opens

[12:40:42.0910] <bakkot>
but it would be good to get those merged

[12:40:56.0126] <bakkot>
can we just auto-merge those after a couple of weeks?

[12:40:57.0581] <Aki>
Chairs

[12:41:09.0286] <bakkot>
ok cc chairs


2025-09-10
[08:58:07.0517] <mgaudet>
So uh, is there a policy of cancelling a plenary if the agenda is empty? (Or empty by some point?) 

[08:59:47.0254] <bakkot>
People always put stuff on last minute so I don't think it has (or is likely to) come up

[09:00:12.0758] <bakkot>
But for remote plenary we definitely skip the last day or two if possible

[09:11:27.0204] <Michael Ficarra>
I'm sure there will be more added (I intend to add something myself), but this is by far the lightest agenda we've ever had this close to the deadline.

[09:27:24.0333] <Rob Palmer>
Please don't wait to add things to the schedule.  It's better for everyone to see what's coming earlier - even if your materials are not ready yet.

[09:59:54.0278] <eemeli>
Going forward, I think we could drop one of the online plenaries from our annual cycle, and have 3 in-person/hybrid + 2 online.

[10:11:42.0332] <Chris de Almeida>
please add your input to the plenary survey if you have not already done so:

https://github.com/tc39/Reflector/issues/560

[10:11:43.0886] <dminor>
There's an opportunity cost associated with reserving four days for something that ends up only taking one or two. This time around, there was a conference I would have liked to attend, but couldn't, because it would have overlapped with the Wednesday and Thursday plenary days.

[10:15:52.0922] <Chris de Almeida>
is said conference something that could be a conflict for other delegates?  want to make sure it's on the constraints survey if so. (https://github.com/tc39/Reflector/issues/559)

[10:17:40.0756] <dminor>
I don't think so, so I haven't included it in the constraints in the past or for the coming year. It's https://nerdear.la/, I'd be happily surprised if someone else was interested :)

[11:32:05.0625] <Rob Palmer>
> <@softwarechris:matrix.org> please add your input to the plenary survey if you have not already done so:
> 
> https://github.com/tc39/Reflector/issues/560

Everyone is equally welcome to update their own answers if opinions have changed over time.

(Perhaps also write a note to say why in this case.)

[12:24:51.0614] <Ashley Claymore>
> <@dminor:mozilla.org> I don't think so, so I haven't included it in the constraints in the past or for the coming year. It's https://nerdear.la/, I'd be happily surprised if someone else was interested :)

Knuth and Tanenbaum as speakers! 

[13:56:24.0121] <bakkot>
Does anyone have further comments on https://github.com/tc39/how-we-work/pull/164? Can we land it? Who needs to press the button?

[14:09:43.0861] <Chris de Almeida>
there appear to be unresolved comments

[15:07:01.0126] <bakkot>
Chris de Almeida: Responded to the two editorial ones; the other two are basically disagreeing with the policy which we got consensus on.

[15:07:15.0502] <bakkot>
I personally think it's good to go now and people can add further refinements in follow-ups.


2025-09-11
[21:50:20.0188] <Mathieu Hofman>
Are PR previews broken ? Looks like the upload job has been broken for a few months

[21:50:38.0546] <Mathieu Hofman>
* Are PR previews broken ? Looks like the upload job has been failing for a few months

[21:50:47.0035] <bakkot>
yes

[21:51:00.0350] <bakkot>
I have a PR fixing it which is ready to go https://github.com/tc39/ecma262/pull/3679

[21:51:06.0696] <bakkot>
cc ljharb 

[21:52:41.0559] <Mathieu Hofman>
I might rebase my PR on that :p

[21:53:10.0703] <bakkot>
won't work

[21:53:43.0239] <Mathieu Hofman>
ah yeah it's using `pull_reqest_target`, oh well

[21:53:49.0871] <Mathieu Hofman>
* ah yeah it's using `pull_request_target`, oh well


2025-09-12
[00:04:31.0295] <Rob Palmer>
Hello all,

The stage advancement deadline for the September plenary is eight hours away. There is now a decent amount of agenda content.

https://github.com/tc39/agendas/blob/main/2025/09.md

[11:43:35.0772] <eemeli>
The agenda looks to be about 8h in total. Could we already now cancel the last day of the plenary? Or alternatively, cancel all/some of the "afternoon sessions"? I have some personal interest here, as in my timezone that would mean we'd finish at 8pm rather than 11pm.

[11:43:53.0225] <eemeli>
* The agenda looks to be about 8h in total. Could we already now cancel the last day of the plenary? Or alternatively, cancel all/some of the "afternoon" sessions? I have some personal interest here, as in my timezone that would mean we'd finish at 8pm rather than 11pm.

[12:15:43.0763] <Chris de Almeida>
We are not going to signal any cancellation of sessions until and unless we are absolutely certain that we won't need the time. There are several days remaining for folks to add topics and constraints, but you're right -- as of now the agenda is looking relatively light.

In the recent past when we have signaled that we MIGHT be ending early, some folks interpreted that as a strong signal and made their plans accordingly. This resulted in the absence of some folks during part of plenary -- a situation we are keen to avoid in the future.


2025-09-15
[08:55:24.0218] <Michael Ficarra>
I am concerned about some proposals going for Stage 1 at the upcoming meeting with a particular API name as the proposal name. *Please* don't do this. Proposals should be named after the problem they're solving, not the champion's assumed or preferred solution at the time of presenting for Stage 1.

[14:19:22.0709] <dminor>
As the "upsert" champion, I strongly second this :)

[14:36:40.0412] <bakkot>
Documenting that strings-as-enums are kebab-case: https://github.com/tc39/how-we-work/pull/165


2025-09-16
[23:46:37.0410] <nicolo-ribaudo>
And then Intl comes, using both "camelCase" and "with spaces" in the options bag of a single function üòÖ

[00:20:59.0308] <eemeli>
Where's the "with spaces" style used? I thought Intl was pretty consistently camelCase.

[00:21:40.0047] <nicolo-ribaudo>
For localeMatcher

[00:22:33.0798] <eemeli>
Ah, true. And then of course we also have "2-digit" in a few places as well.

[00:23:45.0010] <eemeli>
Thankfully "best fit" is the localeMatcher default, so it ~never shows up in real code.


2025-09-17
[17:29:21.0745] <styfle>
I don't think anyone will ever be able to top `XMLHttpRequest`. It has uppercase and pascal case. Not to mention its not related to XML at all. üòÇ

[20:19:39.0607] <kriskowal>
Ah, so you have not heard of SpOnGebObcAsE.

[20:20:13.0254] <kriskowal>
Ah, well, an argument can be made that XMLHttpRequest is worse.

[00:28:17.0287] <Mathieu Hofman>
> <@michaelficarra:matrix.org> I am concerned about some proposals going for Stage 1 at the upcoming meeting with a particular API name as the proposal name. *Please* don't do this. Proposals should be named after the problem they're solving, not the champion's assumed or preferred solution at the time of presenting for Stage 1.

I have one of those, but I really can't imagine another name given the isError and isArray precedent. 

[00:29:01.0335] <Mathieu Hofman>
I guess promise predicate would be another option.

[00:30:15.0663] <Mathieu Hofman>
* I guess promise predicate would be an option for the proposal name

[05:32:10.0308] <Michael Ficarra>
> <@mhofman:matrix.org> I have one of those, but I really can't imagine another name given the isError and isArray precedent. 

I suggested some names in the issue I opened https://github.com/mhofman/proposal-is-promise/issues/4

[07:02:14.0450] <Michael Ficarra>
I also opened an issue about how I think isPromise isn't actually the best name for the API, which reinforces my point about the proposal name https://github.com/mhofman/proposal-is-promise/issues/3

[09:09:49.0490] <TabAtkins>
I mean, I'm not sure how much more generic one would have been able to make a proposal that was initially about whether or not something was a promise. If the proposal ends up significantly genericizing, that's just something unpredictable.

[09:18:21.0407] <Michael Ficarra>
Read the motivation for the proposal in the README. It's about detecting whether the value is treated specially by `await`. `isPromise` is clearly an assumption about how we would do that.

[09:18:53.0502] <TabAtkins>
I mean, sure, but also I think it's a *very* reasonable assumption that "`await` cares about promises"

[09:18:57.0407] <TabAtkins>
(in some way)

[09:19:10.0641] <Michael Ficarra>
I'm also not trying to pick on @mhofman:matrix.org or this proposal in particular. At the time of writing my original complaint, I hadn't even read the proposal.


2025-09-18
[00:14:34.0886] <Mathieu Hofman>
I did consider picking another name for the proposal (which I've now updated) but originally chose proposal-is-promise since I believe any solution is basically gonna be a variation of this. Anyway, I guess we'll be debating this next week. 

[13:26:54.0097] <Chris de Almeida>
draft schedule link is up on the Reflector:  https://github.com/tc39/Reflector/issues/568

[13:27:08.0754] <Chris de Almeida>
* üì¢  draft schedule link is up on the Reflector:  https://github.com/tc39/Reflector/issues/568


2025-09-20
[17:56:19.0381] <Mathieu Hofman>
Something is confusing me about AsyncGeneratorStart / AsyncGeneratorCompleteStep. Is the return value of an async generator not awaited? Does that mean the final iterator result may have a promise as its `value` ? From my testing that doesn't seem to be the case, but I don't see how that's happening in the spec.
```
(async function * () { return Promise.resolve(42); })().next().then(x => console.log(x)); // { value: 42, done: true }
```

[18:21:55.0198] <bakkot>
awaiting of `return` values actually happens as part of the evaluation of the `return` itself

[18:22:02.0510] <bakkot>
https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-return-statement-runtime-semantics-evaluation 

[18:24:48.0381] <Mathieu Hofman>
Oh that is wild!

[18:32:01.0010] <bakkot>
This way it triggers finally statements 

[18:32:05.0803] <bakkot>
Which, also kinda weird

[19:59:07.0594] <Mathieu Hofman>
I'm not sure I understand, `finally` always executes if a `return` is in a `try`. Internally awaiting the return expression shouldn't change that. And if there was a `catch` it shouldn't trigger it, in the same way `yield`ing a rejected promise only triggers a `catch` if the consumer of the iterator called `throw`. (I might have gotten myself confused again with generator behaviors and afk so can't easily double check)

[21:08:16.0729] <bakkot>
sorry, I meant `catch` not `finally`

[21:08:21.0429] <bakkot>
and it doe trigger a `catch`

[21:08:37.0974] <bakkot>
```
(async function*(){ try { return Promise.reject('hi'); } catch (e) { console.log('caught', e); } })().next()
// caught hi
```

[21:09:13.0006] <bakkot>
this is in contrast to async functions
```
(async function(){ try { return Promise.reject('hi'); } catch (e) { console.log('caught', e); } })().catch(e => console.log('did not catch', e))
// did not catch hi
```

[21:09:53.0187] <bakkot>
yielding a rejected promise does also trigger a `catch` incidentally

[21:10:18.0504] <bakkot>
which I am pretty sure is why `return` works that way in async generators

[00:20:21.0718] <Mathieu Hofman>
Well at least it's consistent. And now that you mention it, I think I knew that and just forgot about that oddity. 


2025-09-22
[08:10:25.0008] <Chris de Almeida>
looking for someone to help with notes please!  üôè

[08:10:39.0424] <Aki>
Helping out with notes is so much more low-key than it used to be

[08:10:44.0870] <Aki>
way easier

[08:10:53.0527] <Aki>
just sayin

[08:12:32.0128] <ljharb>
(yay for CLE)

[08:18:31.0638] <eemeli>
https://fosdem.org/2026/news/2025-09-18-fosdem-2026/

[08:18:33.0995] <Andreu Botella>
The dates are now published: Jan 31, Feb 1

[08:18:42.0082] <Aki>
YAY

[08:18:46.0999] <Aki>
finally

[08:21:40.0957] <rbuckton>
Regarding Invited Expert status, there's an open issue in Admin-and-Business to transition me back to delegate status that is awaiting action.

[08:32:05.0185] <ljharb>
sorry for the delay on that; i've been out of the country

[08:42:09.0327] <bakkot>
last call for comments on https://github.com/tc39/how-we-work/pull/164

[09:03:11.0569] <Ben Allen>
Seems like we've lost the transcriptionist

[09:04:50.0600] <Chris de Almeida>
we have not.  refresh?

[09:05:55.0970] <Michael Ficarra>
people should not be doing anything with string enums other than `===`

[09:06:36.0979] <eemeli>
I've now filled out the missing parts of my comment.

[09:07:31.0362] <rbuckton>
while I'm not a fan of the idea of ignoring case on input for string enums, imo kebab case is better for readability if we do. that said ignoring input case has a number of concerns, including performance and readability (inputs could be all uppercase or all lowercase and can make words run together).

[09:10:02.0498] <Michael Ficarra>
out of curiosity, where are we on time?

[09:10:10.0518] <Chris de Almeida>
few mins remain

[09:10:12.0117] <Michael Ficarra>
(this is a feature I wish was part of TCQ)

[09:10:25.0570] <Chris de Almeida>
we can start posting the end times ITC if people want

[09:11:07.0452] <Michael Ficarra>
I want to make sure we have enough time at the end to clearly state a coherent proposal that we can accept/decline

[09:11:21.0509] <Chris de Almeida>
might need a continuation

[09:12:02.0983] <nicolo-ribaudo>
I'm hoping we are not not cancelling the last day for continuing this ü§û

[09:12:21.0354] <rbuckton>
that said, string enums based on existing names (i.e., identifiers, well-known OS-specific constant names from C++ headers, etc.) are a reasonable exception

[09:13:02.0172] <rbuckton>
* that said, string enums based on existing names (i.e., identifiers, well-known OS-specific constant names from C++ headers, etc.) are a reasonable exception, mostly to take advantage of prior knowledge and make discovery easier

[09:13:21.0966] <Michael Ficarra>
I'm hoping this remaining an open issue doesn't block iterator chunking

[09:13:35.0746] <nicolo-ribaudo>
Getting myself off the queue to not waste time, but just for context: the thing about Mark mentioned comes from Unicode, that defines some base units and then combines them with modifiers like `-per-`. Amount didn't design it, it does not actually enforce it (but unit-conversion methods will, in a separate proposal, will)

[09:13:48.0717] <Chris de Almeida>
I captured the queue before everyone removed items

[09:14:07.0427] <Michael Ficarra>
if we're fine going forward with kebab case and possibly adding an accept-both across a large swath of APIs at a later time, I'm good

[09:17:09.0593] <rbuckton>
Enum _members_ are generally expected to be camel/pascal-cased, though it _is_ possible to use any string as a member name. Avoiding non-identifier characters in an enum member name makes auto-complete easier. Enum member _values_, however, have no such requirement. So `enum E { FooBar = "foo-bar" }` is perfectly reasonable, while `enum E { "foo-bar" = "foo-bar" }` is possible but discouraged.

[09:18:33.0970] <Andreu Botella>
is this about millions in Spanish?

[09:19:53.0906] <nicolo-ribaudo>
In italian too, I _think_. 1M kebab vs 1 millione di kebab

[09:19:59.0610] <nicolo-ribaudo>
Or at least that's how I'd write it

[09:20:06.0112] <nicolo-ribaudo>
* In italian too, I _think_. 1M kebab vs 1 millione **di** kebab

[09:21:09.0956] <eemeli>
Ok, that makes sense.

[09:51:38.0752] <eemeli>
In Intl we have this:
```
new Intl.NumberFormat('en', { minimumSignificantDigits: 3, maximumSignificantDigits: 3 }).format(0)
// "0.00"
```

[09:54:27.0080] <bakkot>
I did not understand dminor if that was intended to be a comment

[09:54:37.0567] <dminor>
Sorry, I was asking for the next speaker.

[09:54:49.0487] <dminor>
My dog is causing a lot of noise due to a delivery.

[09:55:18.0044] <Zb Tenerowicz (ZTZ/naugtur)>
You were not legible now and previously. 

[09:55:41.0837] <Zb Tenerowicz (ZTZ/naugtur)>
Do a mic check before you speak next 

[10:01:39.0864] <Zb Tenerowicz (ZTZ/naugtur)>
Sounded distorted, might be configured too loud or googlmeet needs a second to stabilize

[10:02:58.0958] <dminor>
Just did an os update right before the call :( Hopefully it will be better after a restart.

[10:04:46.0579] <waldemar>
`new Intl.NumberFormat('en', { minimumSignificantDigits: 3, maximumSignificantDigits: 3 }).format(0.03)
// "0.0300"`

[10:05:07.0880] <waldemar>
It's not "0.03"

[10:11:20.0682] <waldemar>
Just tried the example I gave at the meeting. `new Intl.NumberFormat('en', { minimumSignificantDigits: 2, maximumSignificantDigits: 2 }).format(0.03)` produces the value I'd expect: `"0.030"`. It's not `"0.0"`.

[10:20:49.0093] <ptomato>
right, I have never heard leading zeroes counted as significant digits, except in 0 itself

[10:30:17.0871] <eemeli>
Huh, you're right, I should've checked this more thoroughly. My position here is that the understanding of "significant digits" in Amount should match the existing understanding that's in Intl.NumberFormat and in Number.p.toPrecision(), whatever that might be.

[10:54:25.0408] <Richard Gibson>
I belive that is inconsistent, e.g. `(450).toPrecision(2)` is "4.5e+2" while `new Intl.NumberFormat('en', { minimumSignificantDigits: 2, maximumSignificantDigits: 2 }).format(450)` is "450"

[11:00:22.0189] <Aki>
Remember, notetaking way chill now

[11:00:26.0917] <Aki>
you just have to make corrections

[11:02:21.0412] <Michael Ficarra>
üôè please take notes, I have to catch a flight!

[11:03:28.0307] <Justin Ridgewell>
Joke joke joke!

[11:04:31.0088] <nicolo-ribaudo>
Rob Palmer: I see TCQ on "lunch"

[11:05:08.0003] <Rob Palmer>
There was a setTimeout on the joke. The offer expired.  It may return at a future call for notetakers.

[11:06:20.0623] <eemeli>
I don't see an inconsistency here, as Intl.NumberFormat only formats with exponential notation if you ask for it:
```
new Intl.NumberFormat('en', { notation: 'scientific', minimumSignificantDigits: 2, maximumSignificantDigits: 2 }).format(450)
// "4.5E2"
```

[11:06:44.0493] <nicolo-ribaudo>
Lol I thought MF picked space case just to cause controversy, while waiting for us to decide on the only two possible reasonable options

[11:07:06.0630] <waldemar>
kebab-case outbreak?

[11:12:42.0138] <Michael Ficarra>
use cases include running/continuous computations, pairwise comparisons, carousels, ...

[11:13:28.0424] <bakkot>
carousels want undersized but the others mostly want only-full

[11:13:49.0917] <bakkot>
and a "real" carousel is usually infinite so it ends up not mattering

[11:14:06.0311] <bakkot>
also reminder to everyone to fill out summary / conclusion

[11:14:19.0315] <bakkot>
also also good job Michael Ficarra doing that fast despite attempts at more bikeshedding

[11:17:00.0288] <Zb Tenerowicz (ZTZ/naugtur)>
.concat? 

[11:17:13.0484] <nicolo-ribaudo>
concat always gives you a new array though

[11:17:20.0359] <nicolo-ribaudo>
Sometimes I want to mutate (often)

[11:18:01.0759] <bakkot>
I suspect the quadratic behavior is not actually plausible; every impl I have seen doubles the size when it hits capacity which keeps overhead at most log (or constant I forget)

[11:18:21.0859] <Zb Tenerowicz (ZTZ/naugtur)>
let + .concat is what I used to do

[11:19:23.0133] <Zb Tenerowicz (ZTZ/naugtur)>
It is horribly easy to forget to reassign tho

[11:19:29.0957] <bakkot>
* I suspect the quadratic behavior is not actually plausible; every impl I have seen doubles the size when it hits capacity which keeps overhead at most ~~log~~ constant

[11:19:33.0752] <bakkot>
* I suspect the quadratic behavior is not actually plausible; every impl I have seen doubles the size when it hits capacity which keeps overhead at most ~log~ constant

[11:21:42.0260] <Ryan Cavanaugh>
"it runs fine in JSC" -> speaks to the criticality of it, right? You can run your tests in one runtime and then crash in a user browser

[11:22:15.0544] <Ryan Cavanaugh>
Re Jordan, not all data processing occurs over a network

[11:22:19.0809] <bakkot>
"I am skeptical that large arrays are common" is... a claim

[11:23:48.0969] <Richard Gibson>
ljharb this also came up in jQuery DOM manipulation, in which there is no "wire"

[11:24:08.0054] <rbuckton>
At one point in the array slice notation proposal, I'd suggested a slice mechanism as well, i.e.: 
```js
ar[^1] = x; // set at ar.length-1
ar[^0] = x; // set at ar.length (i.e., push)
ar[^1:]; // get slice from ar.length-1 to end
ar[^0:]; // get slice from ar.length to end (e.g., empty)

ar[^0:] = ar2; // splice ar2 into ar at ar.length
ar[^1:] = ar2; // splice ar2 into ar at ar.length - 1
// etc.
```

[11:24:20.0791] <rbuckton>
* At one point in the array slice notation proposal, I'd suggested a splice mechanism as well, i.e.:

```js
ar[^1] = x; // set at ar.length-1
ar[^0] = x; // set at ar.length (i.e., push)
ar[^1:]; // get slice from ar.length-1 to end
ar[^0:]; // get slice from ar.length to end (e.g., empty)

ar[^0:] = ar2; // splice ar2 into ar at ar.length
ar[^1:] = ar2; // splice ar2 into ar at ar.length - 1
// etc.
```

[11:24:43.0941] <nicolo-ribaudo>
I like .splice üò¨

[11:24:53.0699] <nicolo-ribaudo>
(but yeah we don't need the other ones)

[11:24:57.0950] <bakkot>
it's awkward to use but it does a specific thing which needs to be done

[11:25:11.0621] <bakkot>
it's true that if we have `spliceFrom` then we don't need `pushFrom`

[11:26:10.0250] <kriskowal>
It‚Äôs true that `spliceFrom` is the only mutative method an array ever needs. Everything else is for ergonomics.

[11:26:29.0594] <ljharb>
sure, but i'd say the same applies with a filesystem or IPC wrt sharding. are there others i'm unaware of?

[11:26:56.0804] <rbuckton>
Not being add prototype methods to array is constantly frustrating. Maybe we need a new `List` type we can use in place of `Array` 

[11:26:58.0044] <ljharb>
* sure, but i'd say the same applies with a filesystem or IPC wrt sharding. are there other mechanisms i'm unaware of?

[11:27:15.0488] <kriskowal>
Though arguably, only `applyOperationalTransform` would be more general than `spliceFrom`.

[11:27:27.0387] <Ryan Cavanaugh>
I've written a lot of code that operates in the range where sharding is not needed but `.push(...arg)` fails

[11:28:00.0776] <nicolo-ribaudo>
We added the .to* ones. It's difficult  but possible

[11:28:23.0045] <Ruben>
I think the problem is that it happens in production when it causes actual issues that are difficult to forsee.
No matter that I agree that it's better to chunk, I think this is going to prevent applications from crashing badly.

[11:28:24.0481] <Michael Ficarra>
sorry, I pressed the done speaking button!

[11:29:09.0892] <kriskowal>
I had to rewrite a binding library to compensate for RangeError over `splice` in terms of a userspace `spliceFrom` in order to propagate changes that included initialization from as few as 10k values, about ten years ago.

[11:29:27.0577] <kriskowal>
(I called userspace `spliceFrom` `swap`)

[11:29:32.0441] <Ryan Cavanaugh>
Like would anyone *support* saying that we should throw if `push(...args)` has args.length >= 10? No, right? But we're saying throwing at a nebulous unspecified number is fine

[11:31:19.0277] <bakkot>
the example from the slides fails for me in Safari

[11:31:27.0261] <bakkot>
I guess maybe there's an optimization which I don't have yet?

[11:31:54.0501] <Michael Ficarra>
@searyanc:matrix.org the spec assumes unlimited resources, there's violations like this all over the place

[11:32:22.0558] <rbuckton>
While its not necessary to tie to this proposal, I'd love to see a `Set.prototype.addAll` (or `.addRange`), i.e., a mutating `union`, in the same fashion as `pushAll`

[11:32:44.0692] <Zb Tenerowicz (ZTZ/naugtur)>
.conpcat would be consistent with splice üôà

[11:32:45.0605] <bakkot>
(instead of specifying Array specially here we should just freeze ArrayIterator :D )

[11:34:59.0308] <keith_miller>
Oh I ran it in our CLI. Maybe it's different in the browser

[11:35:39.0686] <bakkot>
the current state of the art is people getting RangeErrors in production

[11:36:43.0829] <Michael Ficarra>
@eemeli:mozilla.org https://github.com/DanielRosenwasser/proposal-array-push-all/issues/5

[11:37:18.0497] <Michael Ficarra>
they'll still do that, there's just an ergonomic way to do the right thing that their editor will suggest to them

[11:38:01.0672] <bakkot>
I'm on 17.6, which is quite old, because I refuse to update my computer because Apple keeps making the OS worse every time I update it

[11:38:19.0927] <bakkot>
so it's reasonably likely there's a new optimization I'm missing

[11:39:20.0498] <nicolo-ribaudo>
An infinite array!

[11:40:42.0167] <bakkot>
fwiw I would guess `pushFrom` would be web-compat, https://github.com/search?q=%28language%3Ajs+OR+language%3Ats%29+%22.pushFrom%28%22&type=code

`group` had a conflict because it was a name you might put on other objects, and `flatten` had a conflict because it was an obvious name to use, but `pushFrom` is a pretty weird name to use unless you are following our language convention of "from = iterable"

[11:40:57.0064] <rbuckton>
If we optimize `ar.push(...ar2)`, we still have the issue with `ar.push(...ar2.values())` (or any other iterator generated over a large array)

[11:41:36.0907] <Michael Ficarra>
I'm sure the spec already answers the question of mutating an array as it is iterated

[11:41:56.0062] <rbuckton>
That wasn't what my comment was about.

[11:42:21.0373] <Ryan Cavanaugh>
".push(...arr) crashes but only on Suchandsuch browser" is the worst-case scenario

[11:42:44.0211] <rbuckton>
I'm more stating that having engines work around `ar.push(...otherArray)` only solves the problem for arrays, not for arbitrary iterators.

[11:42:47.0326] <keith_miller>
I can't think of any optimizations that would have changed the behavior here remotely recently but maybe there's something

[11:42:54.0587] <ljharb>
* (ignore, matrix blip)

[11:43:16.0032] <keith_miller>
It's version 26 now so you're way behind :P

[11:45:33.0073] <nicolo-ribaudo>
Note that whether ... work doesn't depend only on which engine you are in, but also on how deep you are on the call stack

[11:45:38.0951] <nicolo-ribaudo>
* Note that whether ... works doesn't depend only on which engine you are in, but also on how deep you are on the call stack

[11:45:42.0442] <Ruben>
Would it be a better idea to change the spec that the limit for .push(...array) is removed or defined to a specific upper bound?

[11:45:43.0385] <Ryan Cavanaugh>
"It should be straightforward and safe to add a large number of elements to an existing target array"

[11:45:57.0963] <bakkot>
there is no limit in the spec

[11:46:05.0908] <Ryan Cavanaugh>
* "It should be straightforward and safe to add elements to an existing target array"

[11:46:07.0156] <bakkot>
spec does not believe in stack size limitations

[11:46:23.0516] <Ruben>
> <@bakkot:matrix.org> there is no limit in the spec

I meant to make it explicit that this should not happen in the spec

[11:46:43.0860] <Michael Ficarra>
‚ûïÔ∏è also change the proposal name to reflect the problem statement before transferring to tc39-transfer

[11:46:44.0598] <rbuckton>
As far as how to handle `ar.push(...ar)` (or `ar.push(...ar.values())`), I would support that just exhausting resources and throwing rather than special casing, considering we also do that for `for (const e of ar) ar.push(e);`

[11:46:46.0701] <bakkot>
you can write down whatever you want but implementations are unlikely to start requiring unbounded hardware to run

[11:47:11.0957] <bakkot>
that is: there will always be a limit

[11:47:53.0089] <kriskowal>
And there will never be a limit that is the right size for every job

[11:50:08.0511] <Ruben>
> <@bakkot:matrix.org> that is: there will always be a limit

It could be the array bound. That way, it would be consistent (while having an issue if the array already contains elements and would therefore overflow)

[11:52:29.0036] <bakkot>
there's lots of JS implementations which run on less than 4gb of memory, so even that would be violated in practice

[11:52:43.0808] <bakkot>
but yes, we could. in practice I suspect implementations would not want to rewrite their calling conventions to make that work

[11:52:53.0703] <nicolo-ribaudo>
Zb Tenerowicz (ZTZ/naugtur): I think you have some option that turns `aaa` into monospace aaa. Could you try disabling it?

[11:58:01.0206] <bakkot>
https://github.com/microsoft/TypeScript/issues/8240

[12:03:14.0538] <nicolo-ribaudo>
Rob Palmer (I had an <EOM> point of order). Can you ask for new note takers? Or, I see maybe it's not needed?

[12:11:03.0458] <iain>
For the record, this is false in SM. We collect spread-called arguments into an array (with a fast-path for spreading an existing dense array) before pushing them onto the stack. If we optimized Array.push to avoid stack overflow (which we already to with Math.min/max), that would fix the problem for arbitrary iterators, not just arrays.

[12:11:28.0909] <iain>
* For the record, this is false in SM. We collect spread-called arguments into an array (with a fast-path for spreading an existing dense array) before pushing them onto the stack. If we optimized Array.push to avoid stack overflow (which we already do with Math.min/max), that would fix the problem for arbitrary iterators, not just arrays.

[12:20:09.0890] <iain>
There are other builtins (Math.min/max, String.fromCharCode, ...) where similar problems arise. Adding a new variant for each of those seems unwieldy. I wonder if it would be sufficient to have a note listing specific functions that are expected to take a large number of arguments, with a Strong Recommendation that engines should consider optimizing them to avoid stack overflow.

[12:21:18.0486] <bakkot>
fwiw I have actually been intending to pursue adding new variants for at least those specific functions

[12:21:59.0207] <keith_miller>
FWIW, this does throw if you change it to 200_000_000

[12:22:08.0840] <keith_miller>
* FWIW, this does throw if you change it to 200\_000\_000 for me too

[12:23:22.0040] <bakkot>
not Object.assign or the Function constructor or .bind, probably not String.prototype.concat, and I think that's the whole list?

[12:23:32.0741] <bakkot>
* not Object.assign or the Function constructor or .bind/etc, probably not String.prototype.concat, and I think that's the whole list?

[12:24:01.0252] <bakkot>
undecided on Math.hypot

[12:27:20.0006] <mgaudet>
Mathieu Hofman: I'll need your help to validate if we're capturing what you are looking for, but we have [thenable instrumentation already](https://searchfox.org/firefox-main/rev/767c44c1cde821258288378998f4bb481bec8908/js/src/builtin/Promise.cpp#1416-1422,1480); -- the basic gist here being that -when- we look for "then" we track where the thenable came from; was it an own property, on a standard prototype, or on object.proto. Notably we [don't report for Promise.prototype.then](https://searchfox.org/firefox-main/source/js/src/builtin/Promise.cpp#1319-1351) 

[12:30:30.0697] <mgaudet>
Reflect.ObjectIsNativePromise

[12:30:43.0587] <iain>
I can't speak for other vendors, but from SM's point of view, if it's just this handful of functions, it would be a day or two of work to implement.

[12:31:42.0879] <Olivier Fl√ºckiger>
I am actually not sure if we have precedent for such an optimization or if it would be a larger change to calling conventions in v8.

[12:32:45.0809] <Olivier Fl√ºckiger>
But in general it seems more invasive to add this as a blanket capability.

[12:33:29.0270] <Olivier Fl√ºckiger>
given thus far stack overflow is purely implementation defined

[12:33:30.0192] <hax (HE Shi-Jun)>
What isThenable should be? just typeof p.then == "function" ?

[12:33:40.0280] <ljharb>
`p &&`, but yes

[12:33:41.0257] <kriskowal>
You mean it would be invasive in general to divert large variadic arguments to the heap? (I would assume so)

[12:34:33.0894] <kriskowal>
Though, I suppose you might mean that in some specific cases, just not copying to the stack _or_ heap is an optimization that might work.

[12:34:51.0725] <bakkot>
`typeof p === object && p !== null && typeof p.then == "function"`, primitives aren't thenable 

[12:35:30.0597] <bakkot>
(this assumes that if someone puts `.then` on `document.all` then the computer will set itself on fire in self defense)

[12:36:08.0136] <Olivier Fl√ºckiger>
that is a possible implementation strategy, but I guess we would not spec it with these words. but rather something like "should not fail if creating such an array does not fail".

[12:36:38.0264] <Olivier Fl√ºckiger>
but if you add that as a "capability" for calls it essentially means that every engine needs a generic implementation that can support that

[12:36:51.0423] <Andreu Botella>
can we specify this?

[12:37:13.0780] <Olivier Fl√ºckiger>
* but if you add that as a "capability" for calls it essentially means that every engine needs a generic implementation that can support that. (and that is what I meant by invasive)

[12:37:34.0754] <Justin Ridgewell>
:halt-and-catch-fire:

[12:37:51.0279] <bakkot>
* `(typeof p === "object" || typeof === "function") && p !== null && typeof p.then == "function"`, primitives aren't thenable

[12:38:04.0975] <ljharb>
sure - items with the isHTMLDDA internal slot can have a custom internal [[DefineOwnProperty]] that normatively requires the program to terminate if the key is "then", right?

[12:38:33.0089] <ljharb>
* sure - items with the isHTMLDDA internal slot can have a custom internal \[\[DefineOwnProperty\]\] that normatively requires the program to terminate if the key is "then", right? :-p

[12:43:57.0032] <Olivier Fl√ºckiger>
personally I actually like the idea of making `push(...x)` "just work". but I need to figure out if we would want the implementation.

[12:48:38.0777] <Mathieu Hofman>
I believe this is necessary but not sufficient. The case we're concerned about is when the `resolution` is a native promise. So basically we need the existing `GetThenValue` instrumentation, but also add a check after `.then` is found whether `IsPromise(resolution)` is true.  Only on those native promises, we're concerned with `.then` found that comes from an unexpected place.

[12:49:42.0830] <mgaudet>
Ok. Let me open a bug -- I can't promise I'll get to this _shortly_ but we'll see if someone else (perhaps a volunteer) can do so

[12:51:38.0318] <Mathieu Hofman>
Happy to add details to the issue. I assume we need new instrumentation for the `.constructor` check in `PromiseResolve` too

[12:53:14.0929] <mgaudet>
I actually have to run unexpectedly, so I just dumped what I had here: if you could expand, we can see who can maybe pick this up: https://bugzilla.mozilla.org/show_bug.cgi?id=1990075 

[12:53:25.0852] <mgaudet>
Thank you very much! 

[13:08:36.0785] <bakkot>
unrelated to the meeting today, I suspect many here will be interested in this project, an object-capabilities-based RPC library for the web, including in particular pipelining https://blog.cloudflare.com/capnweb-javascript-rpc-library/

> When you start an RPC, you get back a promise. Instead of awaiting it, you can immediately use the promise in dependent RPCs, thus performing a chain of calls in a single network round trip.

which rhymes with https://github.com/tc39/proposal-wavy-dot

[13:44:10.0724] <Richard Gibson>
this came up in real time as well, but isThenable in general is ill-advised because Promises/A+ requires a single Get of "then". So really you'd need something else anyway, e.g.
```
const snapshotThenable = value => {
  const then = !isPrimitive(value) && value.then;
  if (typeof then !== "function") return undefined;
  return { then: (...args) => Reflect.apply(then, value, args) };
};
```

[13:44:25.0189] <Richard Gibson>
* this came up in real time as well, but `isThenable` in general is ill-advised because Promises/A+ requires a single Get of "then". So really you'd need something else anyway, e.g.

```
const snapshotThenable = value => {
  const then = !isPrimitive(value) && value.then;
  if (typeof then !== "function") return undefined;
  return { then: (...args) => Reflect.apply(then, value, args) };
};
```


2025-09-23
[20:14:50.0736] <James M Snell>
Promise pipelining is definitely something I'd like to explore further if there's interest. Right now we're accomplishing it using Proxy objects in which every property on the object is mapped as a promise. It's fairly elegant but does have it's own challenges. 

[20:46:13.0970] <Mathieu Hofman>
I definitely would like to have an extended conversation on this, having built a system where we extensively do RPC and pipelining.

Notably, we prefer keeping explicit async operations (avoid `.` notation for eventual sends).

We have also effectively given up on using native promises for eventual results for now as it's not currently feasible to track promise adoption. I do however have some ideas around a proposal for an API that could be used by RPC libraries to detect when a promise it created adopts the state of another promise it has access to. Unsurprisingly this requires that the engine performs native promise adoption, and changes how reactions are handled (similar to some of the faster promise adoption proposal approaches)

[22:35:36.0579] <Mathieu Hofman>
Is there any preliminary idea of the schedule for next year's plenaries? Mostly looking whether there will be any January meeting

[22:51:19.0527] <ljharb>
there's usually a meeting in every odd month

[02:58:29.0794] <Rob Palmer>
I'll try to get you an answer by the end of this week, Mathieu. 

[08:11:46.0911] <nicolo-ribaudo>
I don't know much about this topic so maybe it's a weird question, but is this observable in any way from JS code? Or is it just about providing guidance to implementations about some semantics that are already defined?

[08:13:34.0400] <bakkot>
I appreciate the clarity of this presentation for those of us who do not have the knowledge of other calendar systems

[08:20:14.0871] <Aki>
Don't forget your summary/conclusion and also if you dictate it, make sure to check it for clarity afterward like you would any other transcription 

[08:41:13.0976] <Richard Gibson>
it is observable at least in serialization of Temporal.MonthDay instances: https://tc39.es/proposal-temporal/#sec-temporal-temporalmonthdaytostring

for example, visit https://tc39.es/proposal-temporal/docs/ and see the varying reference years for Hebrew calendar month‚Äìdays:
```
["M05", "M05L"].map(monthCode => Temporal.PlainMonthDay.from({
  calendar: "hebrew", 
  monthCode, 
  day: 1,
}).toString())
// => ['1972-01-17[u-ca=hebrew]', '1970-02-07[u-ca=hebrew]']
```

[08:41:47.0366] <nicolo-ribaudo>
ty :)

[08:50:45.0708] <nicolo-ribaudo>
Nobody Promise.anyKeyed/Promise.racedKeyed right? Since Promise.any(Object.values(..)) is not bad to write

[08:50:52.0844] <nicolo-ribaudo>
* Nobody Promise.anyKeyed/Promise.raceKeyed right? Since Promise.any(Object.values(..)) is not bad to write

[08:51:02.0578] <nicolo-ribaudo>
* Nobody wants Promise.anyKeyed/Promise.raceKeyed right? Since Promise.any(Object.values(..)) is not bad to write

[08:51:26.0653] <ljharb>
if it's not producing multiple results then there'd be no value in a keyed variant, yes

[08:51:42.0457] <ptomato>
yes, the reference year is serialized in toString

[08:52:09.0735] <nicolo-ribaudo>
A Promise.raceKeyed method that returns an object with one property that has the resolved value, and all the other are still set to pending promises! :P

[08:52:53.0610] <Chengzhong Wu>
are these pending promises handled? or unhandled?

[08:53:11.0426] <bakkot>
I have unironically wanted this very often

[08:53:36.0994] <bakkot>
though the shape I want is something like, `select(arrayOfPromises)` which returns the first to settle and removes it from the array

[08:55:36.0351] <bakkot>
(in practice I think this is best done as an AsyncIterator, [https://github.com/tc39/proposal-async-iterator-helpers/issues/15)](https://github.com/tc39/proposal-async-iterator-helpers/issues/21)

[09:01:02.0868] <kriskowal>
Also noteworthy that, to reduce attack surface, not every JavaScript environment *should* provide a file or HTTP I/O capability to every module, but should be able to import static assets from its own package.

[09:01:37.0773] <kriskowal>
Ah, heck, I‚Äôll put that on the record.

[09:16:52.0612] <nicolo-ribaudo>
Chris de Almeida Kevin clarified the " NRO: I proposed "accept both in existing cases" thinking of ecma402 but we are actually only deciding for 262? " question

[09:17:09.0561] <nicolo-ribaudo>
It can be deleted :)

[09:24:47.0468] <bakkot>
can I get a stamp/merge on https://github.com/tc39/how-we-work/pull/165 ?

[09:28:33.0447] <nicolo-ribaudo>
Fun fact: I once had to explain to a bank that "you released a bug in Babel, and it immediately broke our frontend because it was in out dependency range" is not exactly something that they should say without being ashamed

[09:28:45.0890] <nicolo-ribaudo>
* Fun fact: I once had to explain to a bank that "you released a bug in Babel, and it immediately broke our frontend because it was in our semver range" is not exactly something that they should say without being ashamed

[09:38:28.0516] <bakkot>
re: js has the best sandbox of any language: wasm is much more sandboxed! depends on what you mean by "language" though I guess

[09:38:53.0710] <Chengzhong Wu>
human writable language

[09:39:12.0766] <Andreu Botella>
i've known people who write WAT

[09:39:32.0395] <bakkot>
I write WAT...

[09:45:56.0943] <Ryan Cavanaugh>
Why does it matter if code can detect if it's in the sandbox?

[09:49:28.0253] <Ashley Claymore>
is it the VW issue? car passes during tests. fails on the road.

[09:51:52.0228] <nicolo-ribaudo>
I feel like we'll need a continuation for this topic

[09:53:25.0181] <bakkot>
I think a good rule of thumb is that your timebox should have more minutes than you do slides

[09:53:44.0866] <nicolo-ribaudo>
I usually do 2x of the slides time

[09:53:58.0049] <Zb Tenerowicz (ZTZ/naugtur)>
detecting the sandbox and changing behavior is a minor issue, but the main issue Kris was talking about is sniffing what the host on the outside is

[09:54:50.0740] <Zb Tenerowicz (ZTZ/naugtur)>
We did that last time and still ran out :) 
This one is an update and an invitation to talk a lot more under less strict time constraints

[09:55:13.0515] <Zb Tenerowicz (ZTZ/naugtur)>
We'll want to make time for all of the feedback and questions. the more the better

[09:55:30.0463] <nicolo-ribaudo>
You are already past the timebox

[09:55:34.0199] <nicolo-ribaudo>
It was 30 min

[09:56:06.0600] <Zb Tenerowicz (ZTZ/naugtur)>
yup, not enough rehearsing

[10:03:38.0979] <dminor>
Kris Kowal: please add a summary / conclusion to the notes.

[10:07:47.0874] <Olivier Fl√ºckiger>
Another meta comment for the presentation: I had Compartments not paged in and no access to the slides beforehand, so I could not follow the second part.

[10:32:36.0938] <kriskowal>
Also, at the risk of missing the spot right between tedious and respectful, I think many voices have been using Lawrence Olivier as our reference for your name, but for the final -R should we be shooting for a German or a French R?

[10:33:28.0834] <kriskowal>
As for rushing the finale, I expect to be better prepared for next plenary. Apologies for the sudden appearance of slides and the explainer that has not yet caught up.

[10:42:31.0811] <Olivier Fl√ºckiger>
No worries, use the R that's easy for you :) Or call me Oli, as many people do

[11:01:16.0009] <Chris de Almeida>
please help with notes üôè

[11:04:09.0619] <Rob Palmer>
Chris is bringing out the big guns here to get notetakers üò∫

[11:07:06.0895] <Chris de Almeida>
he is misbehaving...scratching on doors

[11:07:09.0170] <ljharb>
wait, what's the german R?

[11:07:10.0242] <Chris de Almeida>
the perils of a new felie

[11:07:13.0292] <Chris de Almeida>
* the perils of a new feline

[11:07:54.0594] <waldemar>
Is there something going on with the github spec change previews? I keep getting reviews where the preview generated for a PR shows unrelated changes as differences but doesn't highlight the changes made in the PR I'm reviewing.

[11:08:20.0543] <ljharb>
we just merged what was supposed to be a fix; but it's possible that it's still not working correctly

[11:09:09.0140] <bakkot>
by "the preview generated" do you mean the diff in github or the rendered specification?

[11:09:36.0887] <waldemar>
The rendered spec. It seems unrelated to the diff.

[11:10:16.0906] <waldemar>
Here's an example: https://github.com/tc39/proposal-amount/pull/69

[11:10:57.0169] <bakkot>
That's a rendering of the full spec including the diff, not of the diff itself.

[11:11:10.0502] <Jesse>
ah, that's not using the official spec generator thing; that's something specific to amount (cobbled together from various bits and pieces I found)

[11:11:30.0485] <Jesse>
(my understanding is that we're working on having an "official" solution to generate PR spec previews)

[11:20:53.0715] <ljharb>
i'm not sure if anyone's working on anything for proposals, to be clear

[11:23:40.0243] <Jesse>
oh, my misunderstanding, sorry

[11:23:54.0710] <bakkot>
https://github.com/tc39/template-for-proposals has a thing for generating previews; I don't think there's a plan to do anything else

[11:23:56.0003] <Jesse>
(might be cool to work on something like that and add it to the proposal templte fwiw)

[11:24:18.0359] <Jesse>
ah maybe I just wasn't using the tools in front of me 

[11:24:45.0261] <Richard Gibson>
you probably cloned template-for-proposals before that was merged

[11:24:59.0328] <Richard Gibson>
but you can just copy it directly, as was done for e.g. https://github.com/tc39/proposal-immutable-arraybuffer

[11:25:36.0255] <bakkot>
Mathieu Hofman: re "compartments does give you that property when coupled with lockdown" - only if you carefully remove all the powerful globals from the compartment, right? because my understanding was that the default was to copy all of them

[11:25:49.0779] <Richard Gibson>
example result: https://github.com/tc39/proposal-immutable-arraybuffer/pull/58#issuecomment-3303583355

[11:26:57.0368] <nicolo-ribaudo>
The question is not how to see the rendered PR as a diff on top of ecma262, but how to see the rendered PR as a diff on top of the `main` version of the proposal

[11:28:48.0331] <Richard Gibson>
I wonder if you can use https://github.com/tc39/ecma262/issues/1891

[11:31:34.0068] <Richard Gibson>
I also wrote https://gist.github.com/gibson042/180b7147f84e17e4d55d2893f28719a2 in response to a comment from eemeli , which is heuristic rather than formally sound but can be used for arbitrary a/b ecmarkup diffs

[11:41:46.0346] <Mathieu Hofman>
I think what is included in the compartment's global by default is up to debate. I actually believe one the latest idea is to only include the undeniable global intrinsics by default.

[11:42:50.0796] <bakkot>
So... then you can't really run ~any third-party dependency, right? Most of those are going to use Map or whatever.

[11:52:23.0286] <keith_miller>
Chris de Almeida: I have to go to another meeting in 12 minutes is there any chance I can move my topic up?

[11:53:52.0806] <Chris de Almeida>
best I can do is ask the presenters if they want to prioritize any topics. we only have 6 mins left

[11:54:36.0062] <keith_miller>
Ah, ok I didn't realize there were only 6 minutes left

[11:56:05.0010] <kriskowal>
Regardless of whether you come up, we want to hear from you and will reach out.

[12:07:18.0945] <Mathieu Hofman>
What I referenced were the potential minimal default globals of a new Compartment. A system to handle and isolate dependencies built with compartments can rely on analysis to generate a policy listing which globals that particular dependency might need. As the creator of the compartment, its own default logic might be to always endow globals like Map and Set (even if not explicitly listed in the policy)

[12:11:50.0091] <Chris de Almeida>
we need a volunteer to help w/ notes for the rest of this session: <49 mins remaining

[12:14:58.0543] <Chris de Almeida>
* we need a volunteer to help w/ notes for the rest of this session: \<45 mins remaining

[12:22:12.0487] <Chris de Almeida>
* we need a volunteer to help w/ notes for the rest of this session: \<38 mins remaining

[12:32:27.0596] <nicolo-ribaudo>
Could a large website still adopt lockdown, if inside a shadowrealm?

[12:33:19.0248] <Zb Tenerowicz (ZTZ/naugtur)>
it sure could

[12:34:48.0784] <Rob Palmer>
I don't think anyone has countered the use of global coordination within isolated/modular containers

[12:41:25.0725] <Mathieu Hofman>
I don't think anyone has countered the use of global coordination (lockdown) in newly built applications either.

[12:42:37.0898] <ljharb>
what a spicy question mathieu

[12:42:55.0790] <rekmarks>
ljharb: to your reply to my topic, I'm not at all expecting "the way things are done" to go away, and essentially agree with your comment as captured in the notes:
> If we make something good enough, then certainly the preponderance of users might migrate to it or use it for old things and the old things will never go away and humans don‚Äôt seem to have a great track record with migrating en masse from the crappy thing to the better thing.


[12:43:35.0451] <kriskowal>
I think the implied reach of this presentation greatly exceeds the specific complaint. If we frame this as a question about whether we have a choice between solving a specific problem with or without a mode-switch, we should make it work without the mode-switch so that the top 10k can benefit, and for that I agree. As a matter of opinion, I reject the literal interpretation categorically.

[12:43:42.0061] <ljharb>
my reply was more to the notion that "in 30 years surely everyone will have moved to the better thing", since reality largely disproves that on any reasonable timescale

[12:44:23.0574] <rekmarks>
What I meant to say was that "the preponderance of users might migrate to it, even though the old thing still exists and can't be ignored" üòõ

[12:46:51.0934] <Rob Palmer>
https://almanac.httparchive.org/en/2024/javascript

4% of sites use the `module` script tag, 3.7% use dynamic `import()`

[12:47:37.0045] <Mathieu Hofman>
But the ecosystem has greatly benefited from this system existing. All new code is effectively authored with modules

[12:47:44.0018] <kriskowal>
Yes, and this statistic isn‚Äôt weighted by downloads.

[12:47:47.0589] <Rob Palmer>
Steve Jobs triggered a phase shift for Flash.

[12:47:54.0075] <ljharb>
it didn't need to exist as a runtime feature to provide an authoring benefit tho

[12:48:17.0106] <ljharb>
* it didn't need to exist as a runtime feature to provide an authoring benefit tho (which is why most of the people who author with ESM still transpile it to CJS for production)

[12:48:54.0698] <Mathieu Hofman>
they bundle to scripts. A lot of code is running native esm in Node.js today

[12:49:02.0369] <Mathieu Hofman>
* they bundle to scripts for the web. A lot of code is running native esm in Node.js today

[12:49:34.0052] <Mathieu Hofman>
The web and Node.js benefit from running on a common authoring foundation

[12:55:49.0025] <ljharb>
maybe, but loading ESM in node is slower than loading CJS is, so in a perf-sensitive app they're likely to be building for node too.

[13:06:18.0299] <Mathieu Hofman>
is that an intrinsic limitation of ESM parsing ?

[13:07:25.0995] <bakkot>
I think if we were designing a system optimized for bundling and running in Node and similar runtimes we might well have made a number of different decisions (like making cjs interop easier) and that would have been better

[13:08:05.0900] <ljharb>
time will tell if it's intrinsic, but people worked really hard to make a fast implementation and this is the best we've got

[13:09:12.0466] <Andreu Botella>
I don't think there's anything about the way these large sites are developed that's intrinsic to the web ‚Äì it's just large development teams and organizational boundaries

[13:09:45.0843] <bakkot>
and: I think if the purpose of the system was bundling and running in Node, we were the wrong body to be designing it (as evidenced by our failure to make the decisions optimized for those cases)

[13:09:53.0635] <Andreu Botella>
Rob was saying they made it work in Bloomberg with a large development team ‚Äì sure, it's not the web, but that's not the part that matters

[13:11:14.0178] <bakkot>
as such, I think if in 2012 we had known that the ES module system was not going to be widely used on the web (which is not a foregone conclusion, even now, but supposing it was), then it would have been better for us not to build it, and to have it designed by different people who were better positioned to do that for the needs it would actually serve

[13:21:17.0745] <Zb Tenerowicz (ZTZ/naugtur)>
Apologies for taking more time than necessary with my last question. As a non-native speaker at 10PM I was doing my best to clarify what I mean and that's hard when my point starts with "I don't understand why"

[13:22:23.0470] <Mathieu Hofman>
I still believe that something needed to be done for the language itself, and that the ecosystem has benefited from having a solution specified at the language level as a coordination point so that most code is compatible with both web and non-web environments

[13:26:39.0450] <kriskowal>
We can be friends.

[13:30:02.0024] <kriskowal>
bakkot: I believe that at the heart of your talk, there is a very specific thing that you want that you can get without resistance: If there is a feature that is needed and beneficial to the most widely used websites in the world, that we should not entertain an implementation that is predicated on a lockdown-like mode-switch.

[13:35:50.0433] <Rob Palmer>
> <@ljharb:matrix.org> maybe, but loading ESM in node is slower than loading CJS is, so in a perf-sensitive app they're likely to be building for node too.

There's a chance import/export defer might change the balance for cases that use them. Because the module graph is explorable earlier than is possible with CJS, e.g. allowing concurrent parsing or proactive bytecode caching. 

[13:36:06.0904] <ljharb>
that's a nice maybe :-)

[13:46:44.0814] <bakkot>
sorry for rushing you!

[15:33:37.0597] <James M Snell>
> <@ljharb:matrix.org> time will tell if it's intrinsic, but people worked really hard to make a fast implementation and this is the best we've got

Don't forget that there's a lot of backwards compat stuff in the mix there around the actual loading step in node. We run everything as esm in workers and don't see the same performance profile. It's not the best it could be but runtime cruft does add a fair amount of it's own overhead

[15:34:13.0433] <ljharb>
yeah in no way was i putting shade on node with that one; many aspects of the ESM design make it difficult to do performantly.

[15:35:32.0585] <James M Snell>
Heh, sometimes node needs shade


2025-09-24
[17:30:41.0789] <joyee>
I am fairly certain ESM in Node.js just isn‚Äôt optimized enough because [even require(esm) was 1.2x faster than import esm when it came out](https://github.com/nodejs/node/pull/51977#issuecomment-1995209126) ü§∑‚Äç‚ôÄÔ∏è

[08:06:06.0592] <Ryan Cavanaugh>
TCQ isn't showing a Queue for me

[08:06:43.0247] <Ryan Cavanaugh>
oh, because the tab is too narrow.n m

[08:06:46.0733] <Ryan Cavanaugh>
* oh, because the tab is too narrow. nm

[08:08:54.0352] <Jesse>
I'll add this to the agenda, but here are Ben's slides for the amount continuation: https://notes.igalia.com/p/2025-09-tc39-plenary-amount-continuation#/

[08:10:09.0288] <bakkot>
Ryan Cavanaugh: can you comment on https://github.com/tc39/notes/pull/382

[08:10:18.0453] <bakkot>
we don't have an alias for you in the notes yet

[08:11:01.0424] <Ryan Cavanaugh>
Yeah I approved that earlier

[08:11:17.0822] <bakkot>
sorry, I mean, Rob had a comment about the choice of alias

[08:11:24.0016] <Ryan Cavanaugh>
oh

[08:12:48.0777] <Ryan Cavanaugh>
done thanks

[08:13:38.0412] <Ashley Claymore>
I've been wondering. Was the J a middle name? My money's on 'John'?

[08:14:02.0876] <Ryan Cavanaugh>
yep

[08:15:06.0567] <nicolo-ribaudo>
Missed opportunity for your parents to call you Ryan JavaScript Cavanaugh

[08:16:21.0216] <kriskowal>
I am just going to say that technicalities did not stop Kim Dot Com.

[08:22:53.0045] <keith_miller>
Where can I find the HTML amount proposal?

[08:26:09.0137] <bakkot>
"there's a unit on the end so you need to strip out the unit before converting to a string" hahaha if only our parseFloat actually worked like that

[08:26:45.0341] <Ryan Cavanaugh>
Making a unit called "e3" just for funsies

[08:27:57.0830] <Chris de Almeida>
there is no such proposal AFAIK

[08:31:12.0600] <keith_miller>
Oh maybe I misunderstood. Is there a an HML amount that's going to proposed? What was the context here?

[08:31:55.0371] <bakkot>
it was definitely good that BigInt was correctly pigeonholed by the name, people adopting it as a generic Integer would have been much much worse

[08:33:53.0676] <ljharb>
that's fair, but since then we got complaints about a lack of adoption‚Ä¶

[08:34:13.0406] <ljharb>
* that's fair, but since then we got complaints about a lack of adoption, perhaps we shouldn't have added it at all

[08:34:16.0509] <bakkot>
Lack of adoption was because the use cases it was for didn't actually end up happening that much, not because of the name

[08:34:28.0811] <bakkot>
engines would not have been happier if people started using it for the things they're currently doing, that would be worse

[08:34:40.0635] <ljharb>
i'll agree it's not the best example here

[08:34:42.0163] <nicolo-ribaudo>
https://github.com/mozilla/explainers/blob/main/amount.md

[08:35:04.0079] <bakkot>
(that said, it _is_ extremely useful for wasm interop so I'm still very glad we have it.)

[08:35:11.0774] <nicolo-ribaudo>
Right now the idea is that you hover over it, and it shows a localized popup

[08:35:22.0306] <nicolo-ribaudo>
Kind of like `<span title=...>...</span>`

[08:36:22.0557] <James M Snell>
> <@ljharb:matrix.org> that's fair, but since then we got complaints about a lack of adoption, perhaps we shouldn't have added it at all

Eh, even with minimal adoption it's still a good primitive to have available. For the use cases it is used for it's very useful

[08:36:26.0333] <Ryan Cavanaugh>
It seems like you would only ever construct an `Amount` *right* before formatting a `number`

[08:36:45.0964] <nicolo-ribaudo>
No, as soon as you want to add information to that number, so that you pass them around as a single unit

[08:36:52.0093] <nicolo-ribaudo>
* No, as soon as you want to add information to that number, so that you pass them around as a single "thing"

[08:37:01.0100] <ljharb>
that's also fine. but browsers have blocked decimal primitives (and record and tuple primitives) because bigint didn't get enough adoption

[08:37:24.0301] <nicolo-ribaudo>
If it's right before, you can just pass the number to Intl as-is

[08:37:45.0828] <bakkot>
oh jeeze the idea of people using this for representing JSON output from other languages which can represent values not representable by double or BigInt is... not appealing to me

[08:38:06.0805] <Ryan Cavanaugh>
How do you write code that handles an arbitrary Amount?

[08:39:45.0523] <nicolo-ribaudo>
Mostly passes it around as-is, as an opaque set of information

[08:40:54.0412] <James M Snell>
> <@ljharb:matrix.org> that's also fine. but browsers have blocked decimal primitives (and record and tuple primitives) because bigint didn't get enough adoption

For decimal I can see that argument. Blocking things like record/tuple because of bigint adoption is like saying we won't sell oranges because no one eats the apples

[08:41:14.0312] <Ryan Cavanaugh>
We already have a type that represents a value with an encoded number of significant digits and unit which you shouldn't do math on, it's `string`. Unless this can be sent natively over the wire it doesn't even help the case where you have a server "Amount" that the client should render in its own locale

[08:41:49.0160] <ljharb>
that type represents many other things too tho, this would basically be a structured subset of what strings can do

[08:42:09.0080] <Ryan Cavanaugh>
The "other things" are what though?

[08:42:19.0024] <James M Snell>
But even decimal and bigint serve a sufficiently different use cases from each other that even that argument is tenuous. There are more use cases for decimal than bigint. I'm far less convinced about Amount

[08:42:58.0769] <ljharb>
prose/poetry, bytes, anything that's not a value?

[08:43:59.0836] <Ryan Cavanaugh>
oh I thought "that type" referred to Amount

[08:45:31.0435] <ljharb>
sorry for the confusion

[08:51:42.0865] <nicolo-ribaudo>
Fwiw even with `.toNumber()` math is terrible to do.

```js
new Amount(amount1.toNumber() + amount2.toNumber(), { unit: amount1.unit })
```
+ checking that the units match

[08:51:47.0492] <nicolo-ribaudo>
* Fwiw even with `.toNumber()` math is terrible to do.

```js
new Amount(amount1.toNumber() + amount2.toNumber(), { unit: amount1.unit })
```

\ + checking that the units match

[08:52:21.0027] <nicolo-ribaudo>
* Fwiw even with `.toNumber()` math is terrible to do.

```js
new Amount(amount1.toNumber() + amount2.toNumber(), { unit: amount1.unit, fractionDigits: Math.min(amount1.fractionDigits, amount2.fractionDigits) })
```

\\ + checking that the units match

[08:53:05.0451] <nicolo-ribaudo>
* Fwiw even with `.toNumber()` math is terrible to do.

```js
new Amount(amount1.toNumber() + amount2.toNumber(), 
  unit: amount1.unit,
  fractionDigits: Math.min(amount1.fractionDigits, amount2.fractionDigits)
})
```

\\ + checking that the units match

[08:53:13.0727] <nicolo-ribaudo>
* Fwiw even with `.toNumber()` math is terrible to do.

```js
new Amount(amount1.toNumber() + amount2.toNumber(), {
  unit: amount1.unit,
  fractionDigits: Math.min(amount1.fractionDigits, amount2.fractionDigits)
})
```

\\ + checking that the units match

[08:53:43.0405] <ljharb>
so then why bother removing it

[08:54:15.0099] <nicolo-ribaudo>
That message was directed to those that prefer to remove it. I'm neutral

[08:55:37.0054] <nicolo-ribaudo>
waldemar Do you think we could finish the 0.00&co discussion on GitHub?

[08:55:43.0512] <nicolo-ribaudo>
* waldemar Do you think we could finish the 0.00&co discussion on GitHub rather than now?

[08:58:25.0471] <Ryan Cavanaugh>
This feels like we're trying to create a new Array type that encodes which delimiter you should use when `toString`ing it (comma-separated, semicolon-separated, newline-terminated, etc).

That's not a new noun, it's just metadata attached to an existing primitivelike. Combining those into one new object isn't precedented in the language AFAICT?

[09:00:49.0910] <bakkot>
MDN has a page for the duck-type Iterator incidentally: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator

[09:05:07.0529] <eemeli>
One difference cf. the given examples of protocol objects is that Amounts are more likely to persist, i.e. be stored by a user and used in potentially multiplayer places. So if we go that way, should we provide an `isAmount()` function somewhere?

[09:05:48.0777] <ljharb>
i'd prefer yes, but we don't have an "is iterator result" function or "is regexp match object", so there's not much precedent

[09:07:18.0559] <eemeli>
Are either of those commonly stored, or just immediately used?

[09:08:27.0072] <nicolo-ribaudo>
I think there is a difference in that those two things are just a work-around because we don't support multiple return values from functions

[09:08:33.0470] <nicolo-ribaudo>
* I think there is a difference in that those two things are just a workaround because we don't support multiple return values from functions

[09:08:47.0033] <nicolo-ribaudo>
If we did those two object shapes would not exist

[09:08:52.0475] <nicolo-ribaudo>
But we'd still have this proposal

[09:16:41.0987] <bakkot>
iterables, and to a lesser extent iterators, are very likely to be stored by a user and passed around

[09:20:22.0194] <bakkot>
one difference with iterables is that you often (usually, in fact) want other behavior too when making an iterable, e.g. you're making a Map and it just happens to also be iterable

[09:20:34.0789] <nicolo-ribaudo>
And users very rarely write iterators by hand

[09:20:40.0946] <nicolo-ribaudo>
* And users very rarely write iterators by hand, we provide utilities for that

[09:20:46.0741] <nicolo-ribaudo>
* And users very rarely write iterators by hand, we provide utilities/factories for that

[09:21:09.0751] <bakkot>
this is probably less true for Amount. On the other hand, maybe it is not that rare? if you're representing some type of data, you might well want to e.g. provide arithmetic functions for that data.

[09:21:30.0328] <bakkot>
If this is a protocol you might want to implement on other objects, that would be a strong reason not to have a constructor.

[09:21:58.0406] <bakkot>
i'm guessing that is rare though

[09:24:01.0770] <nicolo-ribaudo>
If it was a protocol, do you think there should no built-in utility to make it more reachable? e.g. `Number.prototype.toAmount(unit) = return { value: this, unit }`, without it being a class

[09:25:53.0216] <bakkot>
`return foo.toAmount('kg')` is about the same as `return { value: foo, unit: kg }` IMO, and the latter is easier to learn

[09:26:20.0682] <bakkot>
* `return foo.toAmount('kg')` is about the same as `return { value: foo, unit: 'kg' }` IMO, and the latter is easier to learn

[09:27:21.0518] <bakkot>
so, probably no. but this opinion is not strongly held; if there's cases where making it more reachable actually does significantly improve usability I'm open to that

[09:28:11.0158] <eemeli>
To me, `isAmount` seems like a much more important function than `toAmount`, if going the protocol route.

[09:28:24.0698] <bakkot>
I cannot imagine when you would want an `isAmount` function

[09:28:56.0072] <nicolo-ribaudo>
If we had this being just a protocol, the main reason to have this be very easily reachable is that it needs to be easier for people to create these objects rather than to separately pass the precision and the values to Intl formatters

[09:29:00.0390] <nicolo-ribaudo>
Since that's a common source of bugs

[09:30:21.0433] <eemeli>
> <@bakkot:matrix.org> I cannot imagine when you would want an `isAmount` function

How else could I know that a string value of { value } is a numerical string?

[09:30:51.0659] <bakkot>
why do you have a string value of `{ value }` whose provenance is not known to you?

[09:43:25.0874] <eemeli>
> <@bakkot:matrix.org> why do you have a string value of `{ value }` whose provenance is not known to you?

Because of the interchange uses for Amount, when the value has come from elsewhere and I'd like to retain and represent it in a lossless way.

[09:44:10.0398] <bakkot>
in my experience interchange protocols are always either tagged with types or have out-of-band schemas

[09:45:02.0977] <bakkot>
you're not just taking an arbitrary collection of values and trying to interpret them

[09:45:05.0217] <bakkot>
that doesn't really work

[09:58:14.0612] <bakkot>
ljharb: as far as I am aware you are literally the only person in the world who is of the opinion that the point of having a class in general is that other things can't pretend to be that thing

[09:58:41.0503] <bakkot>
that is a valid opinion but other people aren't generally going to assume that reason without you making the case for it

[09:58:44.0493] <ljharb>
i mean, everything with internal slots and everything with private fields qualifies

[09:59:00.0536] <ljharb>
that's how every builtin in this language works, with a very short list of exceptions

[09:59:31.0601] <bakkot>
there is a massive distinction between "that is how it works" and "that is the point of it"

[10:01:13.0324] <ljharb>
fair enough

[10:01:30.0989] <ljharb>
that's something that comes with "having a class", regardless of hte point

[10:01:44.0320] <ljharb>
if we're not using internal slots at all then there's no point having anything but a plain object, like an iterator result

[10:03:59.0397] <bakkot>
the Iterator class doesn't use internal slots at all and is nevertheless extremely useful

[10:06:41.0251] <ljharb>
fair, it's IteratorHelper that has the internal slots, but iterator's a bit of a special case in lots of ways

[10:09:18.0816] <ljharb>
notably we don't have an IteratorResult class tho, and if there's no internal slots or helper methods, then Amount seems more like that than an iterator

[10:09:29.0511] <ljharb>
* notably we don't have an IteratorResult class tho, and if there's no internal slots or helper methods, then Amount seems more like that than a stateful iterator

[11:04:48.0212] <bakkot>
ok JS developers do often have lots of dependencies but hundreds of thousands of dependencies is probably not actually a thing

[11:08:08.0266] <Chris de Almeida>
perhaps worth noting, many (most?) are transitive and unshipped

[11:08:26.0309] <bakkot>
transitive I buy, unshipped I don't buy

[11:08:41.0860] <bakkot>
the static analysis developers are using is, unfortunately, still terrible

[11:09:00.0082] <Chris de Almeida>
one of our applications, out of thousands of deps, only like 30 have code that actually end up in the shipped bundle

[11:09:19.0542] <bakkot>
I'm assuming we're only talking about actual deps, not dev deps

[11:09:43.0626] <bakkot>
certainly most dev deps do not end up contributing shipping code, with exception of like babel or webpack

[11:13:13.0290] <Chris de Almeida>
yes, the actual deps. esp when using batteries-included libraries/frameworks, a lot of unused stuff gets shaken out

[11:14:44.0694] <bakkot>
huh, that is very much not my experience

[11:15:33.0618] <keith_miller>
Even if it's only on the order of hundreds, it still seems like an intractable problem to vet all of them for transitive problems.

[11:15:33.0829] <kriskowal>
That was certainly the least opportune moment for Google to insist I reauthenticate.

[11:15:47.0858] <Chris de Almeida>
bold of you to authenticate in the first place

[11:17:31.0218] <keith_miller>
The usefulness of Compartments also seems to depend on frozen globals. Does anyone deploy that at scale with lots of dependencies?

[11:18:35.0998] <Rob Palmer>
I thought V8 had a bunch of optimizations for proxies.  Would love to hear for sure if this include JITing across the boundary.

[11:21:43.0658] <rekmarks>
The dependencies can still collude to e.g. exfiltrate data, but preventing single dependencies from exceeding their authority eliminates an entire class of attacks, e.g. the event-stream incident. Compromising multiple dependencies and shepherding them to conduct an attack is a higher bar that makes a practical difference for the security of applications with many dependencies (i.e. the common case).

[11:25:31.0426] <mgaudet>
Yeah -- I appreciate Kris's comment -- particularly the "unknown" aspect; 

[11:26:43.0311] <keith_miller>
I guess I'd propose an alternative question. The approach that's becoming increasingly common on the web is that the core web process is assumed to be compromised. Instead privileged things are isolated from everything else.

[11:27:12.0797] <keith_miller>
* I guess I'd propose an alternative question. The approach that's becoming increasingly common on the web is that the core web process is assumed to be compromised. Instead privileged things are isolated from the core web process and are hardened.

[11:27:23.0795] <keith_miller>
* I guess I'd propose an alternative question. The approach that's becoming increasingly common on the web is that the core web process is assumed to be compromised. Instead privileged things are isolated from the core web process and are hardened much more aggressively.

[11:27:36.0579] <rekmarks>
What's the "core web process"?

[11:27:41.0490] <keith_miller>
* I guess I'd propose an alternative question. The approach that's becoming increasingly common on the web is that the core web process is assumed to be compromised. Instead privileged things are isolated from the core web process and are hardened much more aggressively. Why is that insufficient or intractable here?

[11:27:58.0012] <keith_miller>
The rendering process (JS/DOM)

[11:28:13.0418] <bakkot>
because the bank login runs in the core web process

[11:28:20.0318] <bakkot>
inherently

[11:28:24.0360] <Olivier Fl√ºckiger>
or even just JS, V8 has a heap sandbox now within the renderer...

[11:28:46.0802] <keith_miller>
I'm saying the same approach in JS. Not at the C++ layer

[11:29:37.0092] <bakkot>
I kind of doubt that you can feasibly move "access to the DOM" out of the root JS process

[11:30:46.0381] <keith_miller>
That's an analogy not what I'm actually proposing for sites. Although one could do it by origin isolating them.

[11:31:50.0400] <mgaudet>
This is just a small factoid, but hints at some of my personal worries: At least in SpiderMonkey we already have "oops wrong realm" objects that we're aware of, but have never fixed because it's been too low in our priority list (usually errors thrown that are from the wrong realm). 

I say this not yet really having made the conceptual leap from the previous module-global propsal to the current more compartment like yet. 

[11:32:00.0112] <mgaudet>
* This is just a small factoid, but hints at some of my personal worries: At least in SpiderMonkey we already have "oops wrong realm" objects that we're aware of, but have never fixed because it's been too low in our priority list (usually errors thrown that are from the wrong realm). 

I say this not yet really having made the conceptual leap from the previous module-global propsal to the current more compartment like one

[11:32:46.0666] <bakkot>
I know at least some engines had some inconsistencies about the realms of iterator result objects at some point, possibly also the realms of promises for certain kinds of async functions

[11:33:25.0957] <bakkot>
which, yes, I have usually avoided adding tests for these because I don't think we should usually care

[11:33:35.0880] <mgaudet>
(And to colour in the rest of my allusion -- if we make mistakes around this, it turns into compartment violation security bug) 

[11:34:05.0713] <bakkot>
the current proposal does not involve having separate versions of Error or Promise or anything, so I don't think it ends up really mattering directly

[11:34:23.0735] <bakkot>
it's only Function (and friends) specifically which are different. not even their prototypes, just the ctor itself.

[11:34:52.0501] <bakkot>
the reason this is thought to be OK is because it is assumed that all the intrinsics are frozen (by something)

[11:35:06.0532] <bakkot>
and also that any powerful intrinsics have not been provided to the compartment

[11:35:34.0258] <mgaudet>
That's nice at least. I'll be excited to read the updated readme so I can try to piece it together

[11:35:45.0652] <Ashley Claymore>
Yeah. Language level values like iterations and RangeError don't change 

[11:35:57.0585] <Ashley Claymore>
* Yeah. Language level values like Iterators and RangeError don't change

[11:37:10.0029] <Ashley Claymore>
Compartments: `with {}` done right 

[11:43:49.0144] <bakkot>
I should say part of my previous topic is that wasm is increasingly moving in the direction of exposing information about modules to runtime: https://github.com/WebAssembly/js-types/blob/main/proposals/js-types/Overview.md

[11:43:59.0119] <bakkot>
and this is good and allows you to do lots of useful things

[11:48:01.0707] <kriskowal>
We are very much in favor of also exposing more information on ModuleSource instances, like all the externally visible bindings.

[11:49:00.0079] <kriskowal>
Like, writing a bundler that uses ModuleSource to gather the static transitive dependencies of a module graph would greatly benefit from that analysis. Last updated 3 years ago https://github.com/tc39/proposal-compartments/blob/master/1-static-analysis.md

[11:50:49.0739] <bakkot>
re: LLMs writing attacks: there's also the "just have an LLM do the attack at runtime" approach https://www.anthropic.com/news/detecting-countering-misuse-aug-2025#vibe-hacking-how-cybercriminals-used-claude-code-to-scale-a-data-extortion-operation

[11:54:58.0483] <Chris de Almeida>
link to "w3c amount" ?

[11:55:39.0801] <keith_miller>
You mean https://github.com/mozilla/explainers/blob/main/amount.md?

[11:56:51.0628] <Chris de Almeida>
looks like it

[12:03:31.0787] <Mathieu Hofman>
I think this is really the crux of it. The way I see it, it's mostly adding a "terminating scope" before evaluating code (including modules). We already have all the logic around to evaluate code in an existing scope stack.

[12:04:00.0199] <Bradford Smith>
bakkot: in my personal notes from the very end of the previous Amount continuation I have "KG: In order to maintain invariants, it will be necessary to use internal slots." Did I misunderstand you there? Isn't that a clear indicator that a class is needed?

[12:05:07.0555] <bakkot>
That is a claim WH made, not a position I advocate

[12:05:39.0593] <bakkot>
it is not clear to me which invariants exist or whether consumers actually need to be able to rely on them; my inclination would be to answer the latter question in the negative

[12:06:33.0301] <ljharb>
i am very skeptical that this is good; it can make things about the way you wrote the code be part of your observable API :-/

[12:06:52.0996] <bakkot>
the exports of code is always part of its observable API

[12:07:06.0946] <ljharb>
oh sure, exposing metadata about existing observable things is great!

[12:07:09.0929] <bakkot>
the imports less directly so but they're still pretty observable in practice

[12:07:27.0676] <ljharb>
i'm not super clear on how one would do that

[12:07:36.0847] <ljharb>
* i'm not super clear on how one would do that (from code, obv you can do it from dev tools etc)

[12:07:58.0723] <bakkot>
and with Compartments as proposed imports would be very observable anyway because there is an `importHook`

[12:08:35.0790] <ljharb>
that is true, and that is a concern i have for that part of the proposal

[12:10:16.0809] <kriskowal>
There are some funny things about ESM that bindings reflection does need to hide. You can‚Äôt just ship the import and export statements, because they entrain too many implementation details. We‚Äôve discussed this pretty hard at Module Harmony.

[12:11:51.0479] <kriskowal>
It also has the downside that you cannot trivially create a proxy for another module by copying all the bindings from a module source to the virtual module source. But, that‚Äôs just a reality we have to live with.

[12:12:15.0605] <kriskowal>
(Or not pursue virtual modules sources at all, to be clear, but they‚Äôd be useful for CJS migration, for one.)

[12:12:35.0727] <ljharb>
couldn't that be enabled without actually exposing the list? like, provide an opaque identifier that just represents the list

[12:14:22.0824] <waldemar>
An Amount is not like a tuple. When receiving an Amount it would be problematic if the various fields such as digit counts and stored value were inconsistent with each other. So you don't want to do duck typing. There are various other ways to ensure the invariants.

[14:09:08.0626] <Chris de Almeida>
the agenda for the next meeting is available and ready for your topics to be added!  üòÄ

https://github.com/tc39/agendas/blob/main/2025/11.md

we currently have ~15 hours of time available

