2025-09-01
[05:19:53.0600] <Lea Verou>
Curious what folks may think about this: https://es.discourse.group/t/text-modules/1031/8

[05:20:39.0493] <Lea Verou>
* Curious what folks may think about this: https://es.discourse.group/t/text-modules/1031/8 (`import with { type: 'text' }`)

[05:21:04.0628] <Lea Verou>
* Curious what folks may think about `import ... with { type: 'text' }` (context: https://es.discourse.group/t/text-modules/1031/8 )

[06:22:36.0742] <Chengzhong Wu>
With https://github.com/tc39/proposal-import-bytes, it can be done like `import ... with { type: 'bytes' }` + `textDecoder.decode(buffer)`

[06:27:26.0271] <nicolo-ribaudo>
There was some appetite for it in the last meeting, strongly pushed for by eemeli

[10:16:14.0066] <bakkot>
yeah I think if someone champions it people are in favor

[11:15:21.0081] <eemeli>
I don't think I've the bandwidth for putting together an import-text proposal for the next plenary, but in case no-one else does, I can try to do so for Tokyo.

[13:07:15.0493] <Michael Ficarra>
@leaverou:matrix.org you can see the notes from the related discussion here: https://github.com/tc39/notes/pull/379/files#diff-16e44c4f2f7e8f811605c9425be9e53906830267d08666efe463e866801d96f7R355-R501

[13:50:21.0141] <eemeli>
Here's a slightly easier and more targeted link for the above: https://github.com/tc39/notes/blob/bcdb104c5783f2d2eca39b31a1d9ab42a3aa3df0/meetings/2025-07/july-30.md#import-buffer-for-stage-1


2025-09-02
[02:17:11.0812] <eemeli>
Back in 2021, when `Object.hasOwn()` raced all the way to Stage 4 in four months, was something like `Object.getOwn()` considered at all? I can't find any reference to such in the notes or the proposal repo.

I'm currently needing to write this repeatedly in a project, and it feels a bit repetitive:
```
let x = Object.hasOwn(obj, name) ? obj[name] : undefined;
```

[02:55:52.0752] <Lea Verou>
When is the Tokyo plenary? There's TPAC in Japan this year so if they're close I may be able to join too!

[03:00:17.0278] <eemeli>
It's the week after TPAC. The meeting schedule is available here: https://github.com/tc39/agendas

[05:39:07.0556] <Michael Ficarra>
Lea Verou: https://github.com/tc39/Reflector/issues/567

[08:26:42.0289] <Chengzhong Wu>
https://github.com/tc39/agendas it seems like the Sept agenda page is not created yet..


2025-09-03
[10:02:38.0156] <ljharb>
sorry about that, i'll make it today

[15:41:34.0595] <Rob Palmer>
I created the agenda earlier today and was going to highlight here, but alas Matrix had an outage so could not.

[15:42:02.0326] <Rob Palmer>
Anyway, the agenda is naturally fresh and light, so please add content! 


2025-09-09
[12:40:37.0569] <bakkot>
so I don't think it's anyone's specific job to merge the notes PRs to https://github.com/tc39/notes/pulls that Aki opens

[12:40:42.0910] <bakkot>
but it would be good to get those merged

[12:40:56.0126] <bakkot>
can we just auto-merge those after a couple of weeks?

[12:40:57.0581] <Aki>
Chairs

[12:41:09.0286] <bakkot>
ok cc chairs


2025-09-10
[08:58:07.0517] <mgaudet>
So uh, is there a policy of cancelling a plenary if the agenda is empty? (Or empty by some point?) 

[08:59:47.0254] <bakkot>
People always put stuff on last minute so I don't think it has (or is likely to) come up

[09:00:12.0758] <bakkot>
But for remote plenary we definitely skip the last day or two if possible

[09:11:27.0204] <Michael Ficarra>
I'm sure there will be more added (I intend to add something myself), but this is by far the lightest agenda we've ever had this close to the deadline.

[09:27:24.0333] <Rob Palmer>
Please don't wait to add things to the schedule.  It's better for everyone to see what's coming earlier - even if your materials are not ready yet.

[09:59:54.0278] <eemeli>
Going forward, I think we could drop one of the online plenaries from our annual cycle, and have 3 in-person/hybrid + 2 online.

[10:11:42.0332] <Chris de Almeida>
please add your input to the plenary survey if you have not already done so:

https://github.com/tc39/Reflector/issues/560

[10:11:43.0886] <dminor>
There's an opportunity cost associated with reserving four days for something that ends up only taking one or two. This time around, there was a conference I would have liked to attend, but couldn't, because it would have overlapped with the Wednesday and Thursday plenary days.

[10:15:52.0922] <Chris de Almeida>
is said conference something that could be a conflict for other delegates?  want to make sure it's on the constraints survey if so. (https://github.com/tc39/Reflector/issues/559)

[10:17:40.0756] <dminor>
I don't think so, so I haven't included it in the constraints in the past or for the coming year. It's https://nerdear.la/, I'd be happily surprised if someone else was interested :)

[11:32:05.0625] <Rob Palmer>
> <@softwarechris:matrix.org> please add your input to the plenary survey if you have not already done so:
> 
> https://github.com/tc39/Reflector/issues/560

Everyone is equally welcome to update their own answers if opinions have changed over time.

(Perhaps also write a note to say why in this case.)

[12:24:51.0614] <Ashley Claymore>
> <@dminor:mozilla.org> I don't think so, so I haven't included it in the constraints in the past or for the coming year. It's https://nerdear.la/, I'd be happily surprised if someone else was interested :)

Knuth and Tanenbaum as speakers! 

[13:56:24.0121] <bakkot>
Does anyone have further comments on https://github.com/tc39/how-we-work/pull/164? Can we land it? Who needs to press the button?

[14:09:43.0861] <Chris de Almeida>
there appear to be unresolved comments

[15:07:01.0126] <bakkot>
Chris de Almeida: Responded to the two editorial ones; the other two are basically disagreeing with the policy which we got consensus on.

[15:07:15.0502] <bakkot>
I personally think it's good to go now and people can add further refinements in follow-ups.


2025-09-11
[21:50:20.0188] <Mathieu Hofman>
Are PR previews broken ? Looks like the upload job has been broken for a few months

[21:50:38.0546] <Mathieu Hofman>
* Are PR previews broken ? Looks like the upload job has been failing for a few months

[21:50:47.0035] <bakkot>
yes

[21:51:00.0350] <bakkot>
I have a PR fixing it which is ready to go https://github.com/tc39/ecma262/pull/3679

[21:51:06.0696] <bakkot>
cc ljharb 

[21:52:41.0559] <Mathieu Hofman>
I might rebase my PR on that :p

[21:53:10.0703] <bakkot>
won't work

[21:53:43.0239] <Mathieu Hofman>
ah yeah it's using `pull_reqest_target`, oh well

[21:53:49.0871] <Mathieu Hofman>
* ah yeah it's using `pull_request_target`, oh well


2025-09-12
[00:04:31.0295] <Rob Palmer>
Hello all,

The stage advancement deadline for the September plenary is eight hours away. There is now a decent amount of agenda content.

https://github.com/tc39/agendas/blob/main/2025/09.md

[11:43:35.0772] <eemeli>
The agenda looks to be about 8h in total. Could we already now cancel the last day of the plenary? Or alternatively, cancel all/some of the "afternoon sessions"? I have some personal interest here, as in my timezone that would mean we'd finish at 8pm rather than 11pm.

[11:43:53.0225] <eemeli>
* The agenda looks to be about 8h in total. Could we already now cancel the last day of the plenary? Or alternatively, cancel all/some of the "afternoon" sessions? I have some personal interest here, as in my timezone that would mean we'd finish at 8pm rather than 11pm.

[12:15:43.0763] <Chris de Almeida>
We are not going to signal any cancellation of sessions until and unless we are absolutely certain that we won't need the time. There are several days remaining for folks to add topics and constraints, but you're right -- as of now the agenda is looking relatively light.

In the recent past when we have signaled that we MIGHT be ending early, some folks interpreted that as a strong signal and made their plans accordingly. This resulted in the absence of some folks during part of plenary -- a situation we are keen to avoid in the future.


2025-09-15
[08:55:24.0218] <Michael Ficarra>
I am concerned about some proposals going for Stage 1 at the upcoming meeting with a particular API name as the proposal name. *Please* don't do this. Proposals should be named after the problem they're solving, not the champion's assumed or preferred solution at the time of presenting for Stage 1.

[14:19:22.0709] <dminor>
As the "upsert" champion, I strongly second this :)

[14:36:40.0412] <bakkot>
Documenting that strings-as-enums are kebab-case: https://github.com/tc39/how-we-work/pull/165


2025-09-16
[23:46:37.0410] <nicolo-ribaudo>
And then Intl comes, using both "camelCase" and "with spaces" in the options bag of a single function üòÖ

[00:20:59.0308] <eemeli>
Where's the "with spaces" style used? I thought Intl was pretty consistently camelCase.

[00:21:40.0047] <nicolo-ribaudo>
For localeMatcher

[00:22:33.0798] <eemeli>
Ah, true. And then of course we also have "2-digit" in a few places as well.

[00:23:45.0010] <eemeli>
Thankfully "best fit" is the localeMatcher default, so it ~never shows up in real code.


2025-09-17
[17:29:21.0745] <styfle>
I don't think anyone will ever be able to top `XMLHttpRequest`. It has uppercase and pascal case. Not to mention its not related to XML at all. üòÇ

[20:19:39.0607] <kriskowal>
Ah, so you have not heard of SpOnGebObcAsE.

[20:20:13.0254] <kriskowal>
Ah, well, an argument can be made that XMLHttpRequest is worse.

[00:28:17.0287] <Mathieu Hofman>
> <@michaelficarra:matrix.org> I am concerned about some proposals going for Stage 1 at the upcoming meeting with a particular API name as the proposal name. *Please* don't do this. Proposals should be named after the problem they're solving, not the champion's assumed or preferred solution at the time of presenting for Stage 1.

I have one of those, but I really can't imagine another name given the isError and isArray precedent. 

[00:29:01.0335] <Mathieu Hofman>
I guess promise predicate would be another option.

[00:30:15.0663] <Mathieu Hofman>
* I guess promise predicate would be an option for the proposal name

[05:32:10.0308] <Michael Ficarra>
> <@mhofman:matrix.org> I have one of those, but I really can't imagine another name given the isError and isArray precedent. 

I suggested some names in the issue I opened https://github.com/mhofman/proposal-is-promise/issues/4

[07:02:14.0450] <Michael Ficarra>
I also opened an issue about how I think isPromise isn't actually the best name for the API, which reinforces my point about the proposal name https://github.com/mhofman/proposal-is-promise/issues/3

[09:09:49.0490] <TabAtkins>
I mean, I'm not sure how much more generic one would have been able to make a proposal that was initially about whether or not something was a promise. If the proposal ends up significantly genericizing, that's just something unpredictable.

[09:18:21.0407] <Michael Ficarra>
Read the motivation for the proposal in the README. It's about detecting whether the value is treated specially by `await`. `isPromise` is clearly an assumption about how we would do that.

[09:18:53.0502] <TabAtkins>
I mean, sure, but also I think it's a *very* reasonable assumption that "`await` cares about promises"

[09:18:57.0407] <TabAtkins>
(in some way)

[09:19:10.0641] <Michael Ficarra>
I'm also not trying to pick on @mhofman:matrix.org or this proposal in particular. At the time of writing my original complaint, I hadn't even read the proposal.


2025-09-18
[00:14:34.0886] <Mathieu Hofman>
I did consider picking another name for the proposal (which I've now updated) but originally chose proposal-is-promise since I believe any solution is basically gonna be a variation of this. Anyway, I guess we'll be debating this next week. 

[13:26:54.0097] <Chris de Almeida>
draft schedule link is up on the Reflector:  https://github.com/tc39/Reflector/issues/568

[13:27:08.0754] <Chris de Almeida>
* üì¢  draft schedule link is up on the Reflector:  https://github.com/tc39/Reflector/issues/568


2025-09-20
[17:56:19.0381] <Mathieu Hofman>
Something is confusing me about AsyncGeneratorStart / AsyncGeneratorCompleteStep. Is the return value of an async generator not awaited? Does that mean the final iterator result may have a promise as its `value` ? From my testing that doesn't seem to be the case, but I don't see how that's happening in the spec.
```
(async function * () { return Promise.resolve(42); })().next().then(x => console.log(x)); // { value: 42, done: true }
```

[18:21:55.0198] <bakkot>
awaiting of `return` values actually happens as part of the evaluation of the `return` itself

[18:22:02.0510] <bakkot>
https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-return-statement-runtime-semantics-evaluation 

[18:24:48.0381] <Mathieu Hofman>
Oh that is wild!

[18:32:01.0010] <bakkot>
This way it triggers finally statements 

[18:32:05.0803] <bakkot>
Which, also kinda weird

[19:59:07.0594] <Mathieu Hofman>
I'm not sure I understand, `finally` always executes if a `return` is in a `try`. Internally awaiting the return expression shouldn't change that. And if there was a `catch` it shouldn't trigger it, in the same way `yield`ing a rejected promise only triggers a `catch` if the consumer of the iterator called `throw`. (I might have gotten myself confused again with generator behaviors and afk so can't easily double check)

[21:08:16.0729] <bakkot>
sorry, I meant `catch` not `finally`

[21:08:21.0429] <bakkot>
and it doe trigger a `catch`

[21:08:37.0974] <bakkot>
```
(async function*(){ try { return Promise.reject('hi'); } catch (e) { console.log('caught', e); } })().next()
// caught hi
```

[21:09:13.0006] <bakkot>
this is in contrast to async functions
```
(async function(){ try { return Promise.reject('hi'); } catch (e) { console.log('caught', e); } })().catch(e => console.log('did not catch', e))
// did not catch hi
```

[21:09:53.0187] <bakkot>
yielding a rejected promise does also trigger a `catch` incidentally

[21:10:18.0504] <bakkot>
which I am pretty sure is why `return` works that way in async generators

[00:20:21.0718] <Mathieu Hofman>
Well at least it's consistent. And now that you mention it, I think I knew that and just forgot about that oddity. 


2025-09-22
[08:10:25.0008] <Chris de Almeida>
looking for someone to help with notes please!  üôè

[08:10:39.0424] <Aki>
Helping out with notes is so much more low-key than it used to be

[08:10:44.0870] <Aki>
way easier

[08:10:53.0527] <Aki>
just sayin

[08:12:32.0128] <ljharb>
(yay for CLE)

[08:18:31.0638] <eemeli>
https://fosdem.org/2026/news/2025-09-18-fosdem-2026/

[08:18:33.0995] <Andreu Botella>
The dates are now published: Jan 31, Feb 1

[08:18:42.0082] <Aki>
YAY

[08:18:46.0999] <Aki>
finally

[08:21:40.0957] <rbuckton>
Regarding Invited Expert status, there's an open issue in Admin-and-Business to transition me back to delegate status that is awaiting action.

[08:32:05.0185] <ljharb>
sorry for the delay on that; i've been out of the country

[08:42:09.0327] <bakkot>
last call for comments on https://github.com/tc39/how-we-work/pull/164

[09:03:11.0569] <Ben Allen>
Seems like we've lost the transcriptionist

[09:04:50.0600] <Chris de Almeida>
we have not.  refresh?

[09:05:55.0970] <Michael Ficarra>
people should not be doing anything with string enums other than `===`

[09:06:36.0979] <eemeli>
I've now filled out the missing parts of my comment.

[09:07:31.0362] <rbuckton>
while I'm not a fan of the idea of ignoring case on input for string enums, imo kebab case is better for readability if we do. that said ignoring input case has a number of concerns, including performance and readability (inputs could be all uppercase or all lowercase and can make words run together).

[09:10:02.0498] <Michael Ficarra>
out of curiosity, where are we on time?

[09:10:10.0518] <Chris de Almeida>
few mins remain

[09:10:12.0117] <Michael Ficarra>
(this is a feature I wish was part of TCQ)

[09:10:25.0570] <Chris de Almeida>
we can start posting the end times ITC if people want

[09:11:07.0452] <Michael Ficarra>
I want to make sure we have enough time at the end to clearly state a coherent proposal that we can accept/decline

[09:11:21.0509] <Chris de Almeida>
might need a continuation

[09:12:02.0983] <nicolo-ribaudo>
I'm hoping we are not not cancelling the last day for continuing this ü§û

[09:12:21.0354] <rbuckton>
that said, string enums based on existing names (i.e., identifiers, well-known OS-specific constant names from C++ headers, etc.) are a reasonable exception

[09:13:02.0172] <rbuckton>
* that said, string enums based on existing names (i.e., identifiers, well-known OS-specific constant names from C++ headers, etc.) are a reasonable exception, mostly to take advantage of prior knowledge and make discovery easier

[09:13:21.0966] <Michael Ficarra>
I'm hoping this remaining an open issue doesn't block iterator chunking

[09:13:35.0746] <nicolo-ribaudo>
Getting myself off the queue to not waste time, but just for context: the thing about Mark mentioned comes from Unicode, that defines some base units and then combines them with modifiers like `-per-`. Amount didn't design it, it does not actually enforce it (but unit-conversion methods will, in a separate proposal, will)

[09:13:48.0717] <Chris de Almeida>
I captured the queue before everyone removed items

[09:14:07.0427] <Michael Ficarra>
if we're fine going forward with kebab case and possibly adding an accept-both across a large swath of APIs at a later time, I'm good

[09:17:09.0593] <rbuckton>
Enum _members_ are generally expected to be camel/pascal-cased, though it _is_ possible to use any string as a member name. Avoiding non-identifier characters in an enum member name makes auto-complete easier. Enum member _values_, however, have no such requirement. So `enum E { FooBar = "foo-bar" }` is perfectly reasonable, while `enum E { "foo-bar" = "foo-bar" }` is possible but discouraged.

[09:18:33.0970] <Andreu Botella>
is this about millions in Spanish?

[09:19:53.0906] <nicolo-ribaudo>
In italian too, I _think_. 1M kebab vs 1 millione di kebab

[09:19:59.0610] <nicolo-ribaudo>
Or at least that's how I'd write it

[09:20:06.0112] <nicolo-ribaudo>
* In italian too, I _think_. 1M kebab vs 1 millione **di** kebab

[09:21:09.0956] <eemeli>
Ok, that makes sense.

[09:51:38.0752] <eemeli>
In Intl we have this:
```
new Intl.NumberFormat('en', { minimumSignificantDigits: 3, maximumSignificantDigits: 3 }).format(0)
// "0.00"
```

[09:54:27.0080] <bakkot>
I did not understand dminor if that was intended to be a comment

[09:54:37.0567] <dminor>
Sorry, I was asking for the next speaker.

[09:54:49.0487] <dminor>
My dog is causing a lot of noise due to a delivery.

[09:55:18.0044] <Zb Tenerowicz (ZTZ/naugtur)>
You were not legible now and previously. 

[09:55:41.0837] <Zb Tenerowicz (ZTZ/naugtur)>
Do a mic check before you speak next 

[10:01:39.0864] <Zb Tenerowicz (ZTZ/naugtur)>
Sounded distorted, might be configured too loud or googlmeet needs a second to stabilize

[10:02:58.0958] <dminor>
Just did an os update right before the call :( Hopefully it will be better after a restart.

[10:04:46.0579] <waldemar>
`new Intl.NumberFormat('en', { minimumSignificantDigits: 3, maximumSignificantDigits: 3 }).format(0.03)
// "0.0300"`

[10:05:07.0880] <waldemar>
It's not "0.03"

[10:11:20.0682] <waldemar>
Just tried the example I gave at the meeting. `new Intl.NumberFormat('en', { minimumSignificantDigits: 2, maximumSignificantDigits: 2 }).format(0.03)` produces the value I'd expect: `"0.030"`. It's not `"0.0"`.

[10:20:49.0093] <ptomato>
right, I have never heard leading zeroes counted as significant digits, except in 0 itself

[10:30:17.0871] <eemeli>
Huh, you're right, I should've checked this more thoroughly. My position here is that the understanding of "significant digits" in Amount should match the existing understanding that's in Intl.NumberFormat and in Number.p.toPrecision(), whatever that might be.

[10:54:25.0408] <Richard Gibson>
I belive that is inconsistent, e.g. `(450).toPrecision(2)` is "4.5e+2" while `new Intl.NumberFormat('en', { minimumSignificantDigits: 2, maximumSignificantDigits: 2 }).format(450)` is "450"

[11:00:22.0189] <Aki>
Remember, notetaking way chill now

[11:00:26.0917] <Aki>
you just have to make corrections

[11:02:21.0412] <Michael Ficarra>
üôè please take notes, I have to catch a flight!

[11:03:28.0307] <Justin Ridgewell>
Joke joke joke!

[11:04:31.0088] <nicolo-ribaudo>
Rob Palmer: I see TCQ on "lunch"

[11:05:08.0003] <Rob Palmer>
There was a setTimeout on the joke. The offer expired.  It may return at a future call for notetakers.

[11:06:20.0623] <eemeli>
I don't see an inconsistency here, as Intl.NumberFormat only formats with exponential notation if you ask for it:
```
new Intl.NumberFormat('en', { notation: 'scientific', minimumSignificantDigits: 2, maximumSignificantDigits: 2 }).format(450)
// "4.5E2"
```

[11:06:44.0493] <nicolo-ribaudo>
Lol I thought MF picked space case just to cause controversy, while waiting for us to decide on the only two possible reasonable options

[11:07:06.0630] <waldemar>
kebab-case outbreak?

[11:12:42.0138] <Michael Ficarra>
use cases include running/continuous computations, pairwise comparisons, carousels, ...

[11:13:28.0424] <bakkot>
carousels want undersized but the others mostly want only-full

[11:13:49.0917] <bakkot>
and a "real" carousel is usually infinite so it ends up not mattering

[11:14:06.0311] <bakkot>
also reminder to everyone to fill out summary / conclusion

[11:14:19.0315] <bakkot>
also also good job Michael Ficarra doing that fast despite attempts at more bikeshedding

[11:17:00.0288] <Zb Tenerowicz (ZTZ/naugtur)>
.concat? 

[11:17:13.0484] <nicolo-ribaudo>
concat always gives you a new array though

[11:17:20.0359] <nicolo-ribaudo>
Sometimes I want to mutate (often)

[11:18:01.0759] <bakkot>
I suspect the quadratic behavior is not actually plausible; every impl I have seen doubles the size when it hits capacity which keeps overhead at most log (or constant I forget)

[11:18:21.0859] <Zb Tenerowicz (ZTZ/naugtur)>
let + .concat is what I used to do

[11:19:23.0133] <Zb Tenerowicz (ZTZ/naugtur)>
It is horribly easy to forget to reassign tho

[11:19:29.0957] <bakkot>
* I suspect the quadratic behavior is not actually plausible; every impl I have seen doubles the size when it hits capacity which keeps overhead at most ~~log~~ constant

[11:19:33.0752] <bakkot>
* I suspect the quadratic behavior is not actually plausible; every impl I have seen doubles the size when it hits capacity which keeps overhead at most ~log~ constant

[11:21:42.0260] <Ryan Cavanaugh>
"it runs fine in JSC" -> speaks to the criticality of it, right? You can run your tests in one runtime and then crash in a user browser

[11:22:15.0544] <Ryan Cavanaugh>
Re Jordan, not all data processing occurs over a network

[11:22:19.0809] <bakkot>
"I am skeptical that large arrays are common" is... a claim

[11:23:48.0969] <Richard Gibson>
ljharb this also came up in jQuery DOM manipulation, in which there is no "wire"

[11:24:08.0054] <rbuckton>
At one point in the array slice notation proposal, I'd suggested a slice mechanism as well, i.e.: 
```js
ar[^1] = x; // set at ar.length-1
ar[^0] = x; // set at ar.length (i.e., push)
ar[^1:]; // get slice from ar.length-1 to end
ar[^0:]; // get slice from ar.length to end (e.g., empty)

ar[^0:] = ar2; // splice ar2 into ar at ar.length
ar[^1:] = ar2; // splice ar2 into ar at ar.length - 1
// etc.
```

[11:24:20.0791] <rbuckton>
* At one point in the array slice notation proposal, I'd suggested a splice mechanism as well, i.e.:

```js
ar[^1] = x; // set at ar.length-1
ar[^0] = x; // set at ar.length (i.e., push)
ar[^1:]; // get slice from ar.length-1 to end
ar[^0:]; // get slice from ar.length to end (e.g., empty)

ar[^0:] = ar2; // splice ar2 into ar at ar.length
ar[^1:] = ar2; // splice ar2 into ar at ar.length - 1
// etc.
```

[11:24:43.0941] <nicolo-ribaudo>
I like .splice üò¨

[11:24:53.0699] <nicolo-ribaudo>
(but yeah we don't need the other ones)

[11:24:57.0950] <bakkot>
it's awkward to use but it does a specific thing which needs to be done

[11:25:11.0621] <bakkot>
it's true that if we have `spliceFrom` then we don't need `pushFrom`

[11:26:10.0250] <kriskowal>
It‚Äôs true that `spliceFrom` is the only mutative method an array ever needs. Everything else is for ergonomics.

[11:26:29.0594] <ljharb>
sure, but i'd say the same applies with a filesystem or IPC wrt sharding. are there others i'm unaware of?

[11:26:56.0804] <rbuckton>
Not being add prototype methods to array is constantly frustrating. Maybe we need a new `List` type we can use in place of `Array` 

[11:26:58.0044] <ljharb>
* sure, but i'd say the same applies with a filesystem or IPC wrt sharding. are there other mechanisms i'm unaware of?

[11:27:15.0488] <kriskowal>
Though arguably, only `applyOperationalTransform` would be more general than `spliceFrom`.

[11:27:27.0387] <Ryan Cavanaugh>
I've written a lot of code that operates in the range where sharding is not needed but `.push(...arg)` fails

[11:28:00.0776] <nicolo-ribaudo>
We added the .to* ones. It's difficult  but possible

[11:28:23.0045] <Ruben>
I think the problem is that it happens in production when it causes actual issues that are difficult to forsee.
No matter that I agree that it's better to chunk, I think this is going to prevent applications from crashing badly.

[11:28:24.0481] <Michael Ficarra>
sorry, I pressed the done speaking button!

[11:29:09.0892] <kriskowal>
I had to rewrite a binding library to compensate for RangeError over `splice` in terms of a userspace `spliceFrom` in order to propagate changes that included initialization from as few as 10k values, about ten years ago.

[11:29:27.0577] <kriskowal>
(I called userspace `spliceFrom` `swap`)

[11:29:32.0441] <Ryan Cavanaugh>
Like would anyone *support* saying that we should throw if `push(...args)` has args.length >= 10? No, right? But we're saying throwing at a nebulous unspecified number is fine

[11:31:19.0277] <bakkot>
the example from the slides fails for me in Safari

[11:31:27.0261] <bakkot>
I guess maybe there's an optimization which I don't have yet?

[11:31:54.0501] <Michael Ficarra>
@searyanc:matrix.org the spec assumes unlimited resources, there's violations like this all over the place

[11:32:22.0558] <rbuckton>
While its not necessary to tie to this proposal, I'd love to see a `Set.prototype.addAll` (or `.addRange`), i.e., a mutating `union`, in the same fashion as `pushAll`

[11:32:44.0692] <Zb Tenerowicz (ZTZ/naugtur)>
.conpcat would be consistent with splice üôà

[11:32:45.0605] <bakkot>
(instead of specifying Array specially here we should just freeze ArrayIterator :D )

[11:34:59.0308] <keith_miller>
Oh I ran it in our CLI. Maybe it's different in the browser

[11:35:39.0686] <bakkot>
the current state of the art is people getting RangeErrors in production

[11:36:43.0829] <Michael Ficarra>
@eemeli:mozilla.org https://github.com/DanielRosenwasser/proposal-array-push-all/issues/5

[11:37:18.0497] <Michael Ficarra>
they'll still do that, there's just an ergonomic way to do the right thing that their editor will suggest to them

[11:38:01.0672] <bakkot>
I'm on 17.6, which is quite old, because I refuse to update my computer because Apple keeps making the OS worse every time I update it

[11:38:19.0927] <bakkot>
so it's reasonably likely there's a new optimization I'm missing

[11:39:20.0498] <nicolo-ribaudo>
An infinite array!

[11:40:42.0167] <bakkot>
fwiw I would guess `pushFrom` would be web-compat, https://github.com/search?q=%28language%3Ajs+OR+language%3Ats%29+%22.pushFrom%28%22&type=code

`group` had a conflict because it was a name you might put on other objects, and `flatten` had a conflict because it was an obvious name to use, but `pushFrom` is a pretty weird name to use unless you are following our language convention of "from = iterable"

[11:40:57.0064] <rbuckton>
If we optimize `ar.push(...ar2)`, we still have the issue with `ar.push(...ar2.values())` (or any other iterator generated over a large array)

[11:41:36.0907] <Michael Ficarra>
I'm sure the spec already answers the question of mutating an array as it is iterated

[11:41:56.0062] <rbuckton>
That wasn't what my comment was about.

[11:42:21.0373] <Ryan Cavanaugh>
".push(...arr) crashes but only on Suchandsuch browser" is the worst-case scenario

[11:42:44.0211] <rbuckton>
I'm more stating that having engines work around `ar.push(...otherArray)` only solves the problem for arrays, not for arbitrary iterators.

[11:42:47.0326] <keith_miller>
I can't think of any optimizations that would have changed the behavior here remotely recently but maybe there's something

[11:42:54.0587] <ljharb>
* (ignore, matrix blip)

[11:43:16.0032] <keith_miller>
It's version 26 now so you're way behind :P

[11:45:33.0073] <nicolo-ribaudo>
Note that whether ... work doesn't depend only on which engine you are in, but also on how deep you are on the call stack

[11:45:38.0951] <nicolo-ribaudo>
* Note that whether ... works doesn't depend only on which engine you are in, but also on how deep you are on the call stack

[11:45:42.0442] <Ruben>
Would it be a better idea to change the spec that the limit for .push(...array) is removed or defined to a specific upper bound?

[11:45:43.0385] <Ryan Cavanaugh>
"It should be straightforward and safe to add a large number of elements to an existing target array"

[11:45:57.0963] <bakkot>
there is no limit in the spec

[11:46:05.0908] <Ryan Cavanaugh>
* "It should be straightforward and safe to add elements to an existing target array"

[11:46:07.0156] <bakkot>
spec does not believe in stack size limitations

[11:46:23.0516] <Ruben>
> <@bakkot:matrix.org> there is no limit in the spec

I meant to make it explicit that this should not happen in the spec

[11:46:43.0860] <Michael Ficarra>
‚ûïÔ∏è also change the proposal name to reflect the problem statement before transferring to tc39-transfer

[11:46:44.0598] <rbuckton>
As far as how to handle `ar.push(...ar)` (or `ar.push(...ar.values())`), I would support that just exhausting resources and throwing rather than special casing, considering we also do that for `for (const e of ar) ar.push(e);`

[11:46:46.0701] <bakkot>
you can write down whatever you want but implementations are unlikely to start requiring unbounded hardware to run

[11:47:11.0957] <bakkot>
that is: there will always be a limit

[11:47:53.0089] <kriskowal>
And there will never be a limit that is the right size for every job

[11:50:08.0511] <Ruben>
> <@bakkot:matrix.org> that is: there will always be a limit

It could be the array bound. That way, it would be consistent (while having an issue if the array already contains elements and would therefore overflow)

[11:52:29.0036] <bakkot>
there's lots of JS implementations which run on less than 4gb of memory, so even that would be violated in practice

[11:52:43.0808] <bakkot>
but yes, we could. in practice I suspect implementations would not want to rewrite their calling conventions to make that work

[11:52:53.0703] <nicolo-ribaudo>
Zb Tenerowicz (ZTZ/naugtur): I think you have some option that turns `aaa` into monospace aaa. Could you try disabling it?

[11:58:01.0206] <bakkot>
https://github.com/microsoft/TypeScript/issues/8240

[12:03:14.0538] <nicolo-ribaudo>
Rob Palmer (I had an <EOM> point of order). Can you ask for new note takers? Or, I see maybe it's not needed?

[12:11:03.0458] <iain>
For the record, this is false in SM. We collect spread-called arguments into an array (with a fast-path for spreading an existing dense array) before pushing them onto the stack. If we optimized Array.push to avoid stack overflow (which we already to with Math.min/max), that would fix the problem for arbitrary iterators, not just arrays.

[12:11:28.0909] <iain>
* For the record, this is false in SM. We collect spread-called arguments into an array (with a fast-path for spreading an existing dense array) before pushing them onto the stack. If we optimized Array.push to avoid stack overflow (which we already do with Math.min/max), that would fix the problem for arbitrary iterators, not just arrays.

[12:20:09.0890] <iain>
There are other builtins (Math.min/max, String.fromCharCode, ...) where similar problems arise. Adding a new variant for each of those seems unwieldy. I wonder if it would be sufficient to have a note listing specific functions that are expected to take a large number of arguments, with a Strong Recommendation that engines should consider optimizing them to avoid stack overflow.

[12:21:18.0486] <bakkot>
fwiw I have actually been intending to pursue adding new variants for at least those specific functions

[12:21:59.0207] <keith_miller>
FWIW, this does throw if you change it to 200_000_000

[12:22:08.0840] <keith_miller>
* FWIW, this does throw if you change it to 200\_000\_000 for me too

[12:23:22.0040] <bakkot>
not Object.assign or the Function constructor or .bind, probably not String.prototype.concat, and I think that's the whole list?

[12:23:32.0741] <bakkot>
* not Object.assign or the Function constructor or .bind/etc, probably not String.prototype.concat, and I think that's the whole list?

[12:24:01.0252] <bakkot>
undecided on Math.hypot

[12:27:20.0006] <mgaudet>
Mathieu Hofman: I'll need your help to validate if we're capturing what you are looking for, but we have [thenable instrumentation already](https://searchfox.org/firefox-main/rev/767c44c1cde821258288378998f4bb481bec8908/js/src/builtin/Promise.cpp#1416-1422,1480); -- the basic gist here being that -when- we look for "then" we track where the thenable came from; was it an own property, on a standard prototype, or on object.proto. Notably we [don't report for Promise.prototype.then](https://searchfox.org/firefox-main/source/js/src/builtin/Promise.cpp#1319-1351) 

[12:30:30.0697] <mgaudet>
Reflect.ObjectIsNativePromise

[12:30:43.0587] <iain>
I can't speak for other vendors, but from SM's point of view, if it's just this handful of functions, it would be a day or two of work to implement.

[12:31:42.0879] <Olivier Fl√ºckiger>
I am actually not sure if we have precedent for such an optimization or if it would be a larger change to calling conventions in v8.

[12:32:45.0809] <Olivier Fl√ºckiger>
But in general it seems more invasive to add this as a blanket capability.

[12:33:29.0270] <Olivier Fl√ºckiger>
given thus far stack overflow is purely implementation defined

[12:33:30.0192] <hax (HE Shi-Jun)>
What isThenable should be? just typeof p.then == "function" ?

[12:33:40.0280] <ljharb>
`p &&`, but yes

[12:33:41.0257] <kriskowal>
You mean it would be invasive in general to divert large variadic arguments to the heap? (I would assume so)

[12:34:33.0894] <kriskowal>
Though, I suppose you might mean that in some specific cases, just not copying to the stack _or_ heap is an optimization that might work.

[12:34:51.0725] <bakkot>
`typeof p === object && p !== null && typeof p.then == "function"`, primitives aren't thenable 

[12:35:30.0597] <bakkot>
(this assumes that if someone puts `.then` on `document.all` then the computer will set itself on fire in self defense)

[12:36:08.0136] <Olivier Fl√ºckiger>
that is a possible implementation strategy, but I guess we would not spec it with these words. but rather something like "should not fail if creating such an array does not fail".

[12:36:38.0264] <Olivier Fl√ºckiger>
but if you add that as a "capability" for calls it essentially means that every engine needs a generic implementation that can support that

[12:36:51.0423] <Andreu Botella>
can we specify this?

[12:37:13.0780] <Olivier Fl√ºckiger>
* but if you add that as a "capability" for calls it essentially means that every engine needs a generic implementation that can support that. (and that is what I meant by invasive)

[12:37:34.0754] <Justin Ridgewell>
:halt-and-catch-fire:

[12:37:51.0279] <bakkot>
* `(typeof p === "object" || typeof === "function") && p !== null && typeof p.then == "function"`, primitives aren't thenable

[12:38:04.0975] <ljharb>
sure - items with the isHTMLDDA internal slot can have a custom internal [[DefineOwnProperty]] that normatively requires the program to terminate if the key is "then", right?

[12:38:33.0089] <ljharb>
* sure - items with the isHTMLDDA internal slot can have a custom internal \[\[DefineOwnProperty\]\] that normatively requires the program to terminate if the key is "then", right? :-p

[12:43:57.0032] <Olivier Fl√ºckiger>
personally I actually like the idea of making `push(...x)` "just work". but I need to figure out if we would want the implementation.

[12:48:38.0777] <Mathieu Hofman>
I believe this is necessary but not sufficient. The case we're concerned about is when the `resolution` is a native promise. So basically we need the existing `GetThenValue` instrumentation, but also add a check after `.then` is found whether `IsPromise(resolution)` is true.  Only on those native promises, we're concerned with `.then` found that comes from an unexpected place.

[12:49:42.0830] <mgaudet>
Ok. Let me open a bug -- I can't promise I'll get to this _shortly_ but we'll see if someone else (perhaps a volunteer) can do so

[12:51:38.0318] <Mathieu Hofman>
Happy to add details to the issue. I assume we need new instrumentation for the `.constructor` check in `PromiseResolve` too

[12:53:14.0929] <mgaudet>
I actually have to run unexpectedly, so I just dumped what I had here: if you could expand, we can see who can maybe pick this up: https://bugzilla.mozilla.org/show_bug.cgi?id=1990075 

[12:53:25.0852] <mgaudet>
Thank you very much! 

[13:08:36.0785] <bakkot>
unrelated to the meeting today, I suspect many here will be interested in this project, an object-capabilities-based RPC library for the web, including in particular pipelining https://blog.cloudflare.com/capnweb-javascript-rpc-library/

> When you start an RPC, you get back a promise. Instead of awaiting it, you can immediately use the promise in dependent RPCs, thus performing a chain of calls in a single network round trip.

which rhymes with https://github.com/tc39/proposal-wavy-dot

[13:44:10.0724] <Richard Gibson>
this came up in real time as well, but isThenable in general is ill-advised because Promises/A+ requires a single Get of "then". So really you'd need something else anyway, e.g.
```
const snapshotThenable = value => {
  const then = !isPrimitive(value) && value.then;
  if (typeof then !== "function") return undefined;
  return { then: (...args) => Reflect.apply(then, value, args) };
};
```

[13:44:25.0189] <Richard Gibson>
* this came up in real time as well, but `isThenable` in general is ill-advised because Promises/A+ requires a single Get of "then". So really you'd need something else anyway, e.g.

```
const snapshotThenable = value => {
  const then = !isPrimitive(value) && value.then;
  if (typeof then !== "function") return undefined;
  return { then: (...args) => Reflect.apply(then, value, args) };
};
```


2025-09-23
[20:14:50.0736] <James M Snell>
Promise pipelining is definitely something I'd like to explore further if there's interest. Right now we're accomplishing it using Proxy objects in which every property on the object is mapped as a promise. It's fairly elegant but does have it's own challenges. 

[20:46:13.0970] <Mathieu Hofman>
I definitely would like to have an extended conversation on this, having built a system where we extensively do RPC and pipelining.

Notably, we prefer keeping explicit async operations (avoid `.` notation for eventual sends).

We have also effectively given up on using native promises for eventual results for now as it's not currently feasible to track promise adoption. I do however have some ideas around a proposal for an API that could be used by RPC libraries to detect when a promise it created adopts the state of another promise it has access to. Unsurprisingly this requires that the engine performs native promise adoption, and changes how reactions are handled (similar to some of the faster promise adoption proposal approaches)

[22:35:36.0579] <Mathieu Hofman>
Is there any preliminary idea of the schedule for next year's plenaries? Mostly looking whether there will be any January meeting

[22:51:19.0527] <ljharb>
there's usually a meeting in every odd month

[02:58:29.0794] <Rob Palmer>
I'll try to get you an answer by the end of this week, Mathieu. 

