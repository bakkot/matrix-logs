2022-03-01
[14:22:36.0271] <mgaudet>
Hey; I've got [a bug](https://bugzilla.mozilla.org/show_bug.cgi?id=1757162) which essentially boils down to this little test case

```
class A {
    #x = "hello";
    constructor(o = this.#x) {
        this.value = o;
    }
};

var a = new A;
// Does new A throw? if not, does a.value have the value of `hello`?
```


[14:22:48.0705] <mgaudet>
I'm trying to figure out what the spec says and got a little confused

[14:24:02.0915] <mgaudet>
https://tc39.es/ecma262/#sec-evaluatenew says that ArgumentListEvaluation happens before the constructor is invoked; but AFAICT it's the constructor that actually allocates the object... 

[14:24:35.0604] <mgaudet>
does ArgumentListEvaluation not actually... evaluate the arguments? ie, is the processing of the default argument deferred until later? 

[14:31:39.0687] <bakkot>
`ArgumentListEvaluation` evaluates _the arguments_, not the parameters

[14:32:16.0995] <bakkot>
it's the thing which would trigger the `console.log` in `f(console.log(0));`, not the thing which would trigger the `console.log` in `function f(x = console.log(0)) {}; f()`

[14:32:59.0899] <mgaudet>
yeah; I think I've got the latter traced down further into https://tc39.es/ecma262/#sec-functiondeclarationinstantiation 

[14:33:32.0804] <mgaudet>
(which seems to imply that the answer is that private fields ought to be available in that parameter expression) 

[14:33:55.0892] <mgaudet>
(I always get bit when coming back to arguments/formals/parameters) 

[14:36:38.0597] <bakkot>
yeah

[14:37:36.0990] <bakkot>
specifically, for base classes, class fields are created/installed by [[construct]] step 6.b: https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ecmascript-function-objects-construct-argumentslist-newtarget

[14:38:04.0399] <bakkot>
 * specifically, for base classes, class fields are created/installed by [[construct]] step 6.b: https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ecmascript-function-objects-construct-argumentslist-newtarget

[14:39:12.0103] <bakkot>
and parameter defaults (and other expressions) are evaluated later, in [[construct]] step 8, via OrdinaryCallEvaluateBody -> EvaluateBody -> EvaluateFunctionBody -> FunctionDeclarationInstantiation -> IteratorBindingInitialization

[14:40:11.0699] <bakkot>
so private fields (and all other fields) are available (for base classes) by the time the parameter list is evaluated

[14:40:28.0166] <mgaudet>
Yep :) Was writing that out... less nicely than you in the bug :P 


2022-03-02
[12:11:07.0493] <bakkot>
the snippet of code for getting the time is wrong on the agenda; can someone fix it? https://github.com/tc39/agendas/blob/main/2022/03.md

[12:11:33.0045] <bakkot>
I can do it if I remember next time I have an opportunity

[12:12:01.0489] <bakkot>
(it has the wrong date)


2022-03-03
[16:06:48.0051] <ljharb>
done


2022-03-07
[10:13:38.0587] <jschoi>
A friendly reminder to delegates that thereâ€™s an incubator meeting about `Function` helper functions tomorrow! Hope to see you there. https://github.com/tc39/incubator-agendas/blob/master/2022/03-08.md


2022-03-08
[08:03:53.0082] <shu>
ljharb: incubator call?

[08:05:00.0615] <ljharb>
Iâ€™ll be a few late, but Iâ€™m coming

[08:25:12.0906] <ljharb>
jschoi: "demethodize" is pretty gross imo, ftr :-p

[09:01:10.0789] <shu>
it sounds like a surgical procedure

[11:51:46.0153] <ljharb>
so, we have `x?.(y)`, where it doesn't call `x` unless `x` is non-nullish; is there no simple way to do `x(y)` when _y_ is non-nullish? (obv i can do `y == null ? y : x(y)` but that means i have to repeat the `y` expression more than once, or store it in a var)

[12:01:17.0935] <Ashley Claymore>
sounds like you want optional pipeline ðŸ˜‰

[12:01:34.0057] <Ashley Claymore>
 * sounds like you want optional pipeline ðŸ˜‰

[12:02:10.0572] <Ashley Claymore>
`y ?> x(<sigil>)`

[12:02:26.0534] <bakkot>
optional pipeline :(

[12:02:49.0120] <bakkot>
we could just have do-notation, like a real language

[12:03:07.0046] <Ashley Claymore>
ðŸ”¥

[12:04:40.0003] <shu>
real languages are statement based, only acceptable expressions are immediates and registers and addresses

[12:04:46.0945] <shu>
and immediates can't be too big

[12:04:52.0405] <shu>
and it'll be an awkward number of bits, like 21

[12:06:00.0164] <Ashley Claymore>
all logic is ternary. true/false/unknown 

[12:11:13.0038] <jschoi>
> <@aclaymore:matrix.org> sounds like you want optional pipeline ðŸ˜‰

Thereâ€™s going to be a bikeshed around whether to use falsey or nullish for optional pipes. ðŸ¤” 

[12:12:08.0125] <bakkot>
nullish is the only reasonable choice for optional pipes

[12:12:11.0812] <bakkot>
also I don't want optional pipes

[12:12:17.0408] <bakkot>
but it's the only reasonable choice if we have to have them

[12:22:57.0854] <jschoi>
> <@aclaymore:matrix.org> all logic is ternary. true/false/unknown 

Also, we both have null and undefined. We can go further. https://www.computer.org/csdl/proceedings-article/glsv/1991/00143992/12OmNzzxusf

Quaternary logic. We have the technology. Do we have the courage? [joke]

[12:23:35.0286] <jschoi>
* > <@aclaymore:matrix.org> all logic is ternary. true/false/unknown 

Also, we have null and undefined. We can go further. https://www.computer.org/csdl/proceedings-article/glsv/1991/00143992/12OmNzzxusf

Quaternary logic. We have the technology. Do we have the courage?

[12:24:22.0159] <jschoi>
* > <@aclaymore:matrix.org> all logic is ternary. true/false/unknown 

Also, we both have null and undefined. We can go further. https://www.computer.org/csdl/proceedings-article/glsv/1991/00143992/12OmNzzxusf

Quaternary logic. We have the technology. Do we have the courage? [joke]

[12:30:58.0308] <bakkot>
we have gone further

[12:31:07.0359] <bakkot>
we have an infinite number of `document.all`s available to us

[12:31:18.0811] <bakkot>
for as many non-null/undef nullish values as you want

[12:46:45.0073] <TabAtkins>
> <@jschoi:matrix.org> Thereâ€™s going to be a bikeshed around whether to use falsey or nullish for optional pipes. ðŸ¤”

? It would use the same rules as optional-call and ??; anything else would be a profound mistake.

[13:59:53.0261] <jschoi>
Yeah, I had thought there would be some disagreement on this, but it looks like everyone (including me) agrees with nullishness.

[14:46:24.0173] <TabAtkins>
I don't think it's *particularly* that everyone agrees on nullishness (tho maybe people do), it's just that it's extremely clear that all the things doing optionality with the same syntax pattern need to act the same.

[15:39:44.0342] <Michael Ficarra>
> <@bakkot:matrix.org> we have an infinite number of `document.all`s available to us

not even limited to `document.all`, hosts can put `[[IsHTMLDDA]]` on any objects they choose

[15:40:28.0658] <shu>
owo

[15:41:41.0154] <bakkot>
"can", but "should" not

[15:41:56.0611] <bakkot>
"implementations should not create any with the exception of document.all"

[15:42:00.0633] <bakkot>
should've said "must"

[15:42:22.0916] <ljharb>
still could

[15:43:09.0856] <Michael Ficarra>
^

[15:43:12.0141] <bakkot>
with consensus, which, I definitely do not care enough about this to spend committee time on it

[15:43:24.0213] <Michael Ficarra>
also, now I've noticed that there's an issue with B.3.6.3 https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-typeof

[15:44:17.0740] <bakkot>
what's the issue?

[15:44:41.0610] <Michael Ficarra>
the left column of that table should separate all language values unambiguously

[15:45:01.0817] <Michael Ficarra>
an object with `[[IsHTMLDDA]]` will always fall into two rows

[15:45:10.0479] <Michael Ficarra>
either it has `[[Call]]` or it doesn't

[15:48:45.0981] <Michael Ficarra>
we should just have it insert a step into 13.5.3.1 instead of a row into the table

[15:53:31.0030] <Michael Ficarra>
https://github.com/tc39/ecma262/issues/2685


2022-03-09
[15:15:34.0307] <bakkot>
262 editors are planning on changing out `the result of evaluating |Whatever|` with `Evaluation of |Whatever|`, to better match other SDOs (`NamedEvaluation of |Whatever|`, etc)

this makes it more consistent with the rest of the spec and also works better with tooling

if anyone strongly objects to this change, speak now


2022-03-10
[16:16:36.0822] <shu>
so many editors in agreement

[16:32:50.0575] <bakkot>
shu: array find-from-last shipped unflagged in M97, right?

[16:32:55.0964] <bakkot>
should probably close https://bugs.chromium.org/p/v8/issues/detail?id=11990 if that's so

[16:33:25.0691] <bakkot>
 * shu: array find-from-last shipped unflagged in M97, right?

[16:33:56.0690] <shu>
good call, done

[02:57:54.0594] <Jack Works>
can anyone access https://jschoi.org/21/es-dataflow/map/ ?

[02:59:06.0403] <nicolo-ribaudo>
No

[02:59:37.0342] <nicolo-ribaudo>
I get an error even on your homepage

[03:44:48.0507] <legendecas>
> <@jackworks:matrix.org> can anyone access https://jschoi.org/21/es-dataflow/map/ ?

Not sure if jschoi removed it intentionally. I'm assuming it's not since the whole site is down. You can try https://web.archive.org/web/20220121194801if_/https://cdn.glitch.me/fce49fe7-f83b-4170-90d5-ab11ebc3ff25/21--es-dataflow--map.png

[06:21:47.0649] <jschoi>
Jack Works, legendecas, nicolo-ribaudo: Thanks for letting me know. My website hostâ€™s DNS settings had changed for some reason. I just updated them, so the website including the dataflow article should work now (though it might take up to several hours for the new DNS records to propagate).

[06:22:38.0994] <jschoi>
 * Jack Works, legendecas, nicolo-ribaudo: Thanks for letting me know. My website hostâ€™s DNS settings had changed for some reason. I just updated them, so the website including the dataflow article should work now (though it might take up to several hours for the new DNS records to propagate).

[13:24:55.0557] <rkirsling>
wait what's this about an in-person meeting?

[13:25:12.0402] <rkirsling>
first I'm catching wind of that

[13:27:45.0069] <Rob Palmer>
It was announced as part of the 2022 schedule last year. And in the last meeting I said I would give an update in the next plenary to confirm the details. 

I shall be sending out a Reflector post soon to collect numbers and feedback. It is hosted by OpenJS in Austin, Texas. The OpenJS organisers themselves plan to make a call on whether to proceed in just over a week. So it will also depend on their stance. 

[13:29:20.0726] <Rob Palmer>
We will still have dial in as always and there will be no pressure to attend in person. 

[13:41:17.0336] <devsnek>
i hope they cancel it

[13:43:45.0962] <shu>
austin in summer is not the kind of weather i'd travel for

[13:45:41.0319] <devsnek>
erights phoddie do you have any additional info on this weakmap implementation ðŸ‘€

[13:49:59.0146] <Luca Casonato>
These recent Texas news are also not really making me super enthused about traveling there anymore

[14:23:18.0209] <rkirsling>
true, I think I would wait yet

[14:44:52.0042] <ljharb>
(both June and September are loosely planned to be in-person, as i understand it)

[14:45:41.0082] <ljharb>
 * (both June and September are loosely planned to be in-person, as i understand it, in Austin and Tokyo respectively)


2022-03-11
[09:33:02.0704] <bterlson>
Do we have a release candidate for 2022 yet?

[09:33:40.0566] <bakkot>
Not yet, we want to get one or two more things in

[09:33:58.0614] <bakkot>
but we'll be cutting it shortly (should be within a week) and will announce it on the reflector

[09:34:52.0313] <bterlson>
Awesome, thanks for the update! (just calling this out in the chair report)

[11:09:06.0942] <Michael Ficarra>
FYI for anyone who was unable to access the slides for the upcoming "extending built-ins" discussion linked from the March agenda: we were having IT issues with sharing, but they should be fixed now and the slides should be accessible again

[11:09:19.0041] <Michael Ficarra>
slides link for convenience: https://docs.google.com/presentation/d/1toEo_vh-UMqnaiQrj-gl3gWtvC34zzsraHnlIKouBtQ

[11:09:39.0286] <Michael Ficarra>
please let me know ASAP if the issue crops up again


2022-03-12
[16:42:49.0792] <jschoi>
> Should Symbol.species continue to be an extension affordance generally?

Remind me in case my memory is bad, but Everyone in TC39 agrees that Symbol.species was a Bad Idea that Should Be Removed If Possible, right?

[16:55:38.0314] <bakkot>
lotta people dislike it in the places it currently gets used - arrays, typed arrays, promises, regexes - but it is much less obviously a bad idea for Map and Set, even though those have no methods which use it

[01:44:14.0519] <Jack Works>
ðŸ‘€ does anyone know what's the status of iterator helper?


2022-03-13
[19:28:33.0647] <ljharb>
cc Michael Ficarra; i'm not sure what's holding it back from seeking stage 3

[21:06:42.0466] <bakkot>
the current binding constraint is the champions having time to pursue it, I am pretty sure


2022-03-14
[10:08:30.0630] <Michael Ficarra>
ljharb: Yulia had done a lot of work on it in a time when I was very busy and couldn't follow, so she would be the best person to ask about what remains

[10:09:26.0395] <yulia>
Right, there are a few small unresolved topics that i need to get to

[10:09:57.0175] <yulia>
the major one is this: https://github.com/tc39/proposal-iterator-helpers/issues/122

[10:10:04.0193] <yulia>
i haven't had time to dig into this properly due to other priorities

[10:10:13.0141] <Michael Ficarra>
yulia: welcome back!

[10:10:37.0450] <yulia>
Thanks

[10:10:52.0887] <yulia>
I am happy to sit down with folks and hammer this out + update firefox's implementation to match

[10:11:15.0194] <yulia>
the other issues in the repo, last i checked, were less significant

[10:11:56.0993] <yulia>
I can see about getting it done by the end of the week, its been on my list for way too long

[10:12:26.0563] <yulia>
Though, feedback / opinions would be very welcome... 

[10:12:47.0281] <yulia>
maybe, Michael Ficarra -- I summarize the proposed change, bring it to committee, and then the following meeting we try to advance?

[10:13:33.0540] <Michael Ficarra>
the following meeting isn't until June, so I think that gives us plenty of time, yes

[10:26:10.0692] <ljharb>
the issue title still confuses me, i continue to have no idea what "passing the protocol" means

[10:42:41.0454] <Michael Ficarra>
ljharb: it's just whether `return`/`throw` on an iterator produced by iterator helpers behave the same as if they were called on the original iterator

[10:43:18.0128] <Michael Ficarra>
see https://github.com/tc39/proposal-iterator-helpers/issues/122#issuecomment-909432348

[10:43:21.0343] <ljharb>
ah k, thanks

[10:43:59.0651] <ljharb>
so like, forwarding the full iterator API (ie, return/throw)?

[10:44:14.0011] <Michael Ficarra>
yep

[10:44:32.0996] <Michael Ficarra>
it's harder to do than just making `next` work

[10:44:57.0265] <Michael Ficarra>
the unfortunate bit is that a whole class of usages only care that `next` works

[10:45:59.0064] <yulia>
the argument against passing the full iterator api is that most of these methods are not intended to be communicating generators, and in this case does it make sense to pass return and throw

[10:48:12.0720] <ljharb>
ugh, `return` and `throw` are gross

[10:52:15.0761] <Michael Ficarra>
archival footage of TC39 adding generators to the language

[10:54:30.0592] <ljharb>
please don't besmirch the good name of shoehorns

[11:00:09.0527] <yulia>
hm, it may get tricky in relation to the other issues like this one: https://github.com/tc39/proposal-iterator-helpers/issues/174

[11:00:17.0302] <yulia>
I'll do a more detailed review later this week

[12:10:36.0275] <bakkot>
Michael Ficarra: I think we were all agreed that `return` and `throw` should get forwarded and the remaining question is whether `.next` forwards its argument

[12:10:52.0785] <bakkot>
`return` needs to get forwarded so that the underlying iterator is properly closed

[12:11:06.0938] <bakkot>
(and `throw` doesn't really matter because nothing in the language calls it)

[12:23:59.0786] <Mathieu Hofman>
> <@yulia:mozilla.org> hm, it may get tricky in relation to the other issues like this one: https://github.com/tc39/proposal-iterator-helpers/issues/174

Yeah I haven't had time to continue on this, and I had noticed that iterator helpers had some similar issues. Happy to chat since I did a deep dive on the return/throw behavior, especially in the erroneous cases.

[12:47:52.0699] <yulia>
Mathieu Hofman: great, i will take you up on that

[12:48:11.0284] <yulia>
maybe this won't make it to the end of the week, it is hairier than i remember

[12:48:33.0287] <yulia>
but if you have time maybe we can sit down towards thursday/fri?

[12:48:48.0779] <yulia>
or early next week

[12:48:57.0250] <yulia>
i guess i can put a discussion item on the agenda anyway


2022-03-15
[18:00:00.0913] <bakkot>
shu: re https://github.com/tc39/ecma262/pull/2646, did you know that TA.prototype.sort _also_ has a per-iteration detachedness check?

[18:02:50.0433] <bakkot>
it doesn't even get you anything because you have to read all of the values out of the buffer before the loop anyway, since `compareFn` can write to the buffer

[04:35:29.0761] <Ashley Claymore>
My guess is this was missed when https://github.com/tc39/ecma262/pull/1585 landed? Before es2021 the order of calls to [get] and `comparefn` was implementation defined. From es6 onwards there has always been that detached check

[04:36:24.0254] <Ashley Claymore>
 * My guess is this was missed when https://github.com/tc39/ecma262/pull/1585 landed? Before es2021 the order of calls to [get] and `comparefn` was implementation defined. From es6 onwards there has always been that detached check

[11:27:08.0357] <shu>
bakkot: lol i did not


2022-03-16
[04:16:24.0786] <yulia | sick>
I am unlikely to get anything done this week.

[04:17:05.0658] <yulia | sick>
ill try to post the issue for discussion though

[07:40:46.0824] <annevk>
yulia | sick: take care and I hope you recover quickly (and please remember that almost nothing in standards is time-sensitive)

[07:56:43.0027] <Rob Palmer>
best wishes for a speedy recovery, Yulia


2022-03-17
[10:21:14.0556] <jschoi>
HE Shi-Jun: You had mentioned, in the ad-hoc dataflow meeting after last plenary, that you were planning to give an update on the Extensions proposal at the upcoming plenary. Are you still planning to give an update on Extensions?

[10:40:30.0680] <jschoi>
* HE Shi-Jun: You had mentioned, in the ad-hoc dataflow meeting after last plenary, that you were planning to give an update on the Extensions proposal at the upcoming plenary. Are you still planning to give an update on Extensions? (Iâ€™m planning to give an update on the bind-this/call-this and pipe operators.)


2022-03-21
[13:42:01.0463] <Rob Palmer>
Hello all, I've posted a request for feedback on the Reflector for the upcoming **real-life** June plenary in Austin as part of OpenJS World conference.

https://github.com/tc39/Reflector/issues/423


2022-03-22
[20:33:48.0310] <ljharb>
psyched for a nonfictional plenary

[09:55:08.0824] <bakkot>
could we add a blocking version of await, only available off the main thread

[09:55:16.0580] <bakkot>
we already have atomics.wait

[09:55:28.0698] <bakkot>
 * could we add a blocking version of await, only available off the main thread

[09:55:32.0090] <bakkot>
is this a terrible idea

[09:57:17.0446] <Ashley Claymore>
the win being not worrying about red/blue functions? Or could there also be performance wins to blocking over using await mechanics ?

[10:00:47.0793] <shu>
bakkot: probably?

[10:01:46.0968] <shu>
what are the proposed semantics? remember `Atomics.wait` only gets woken up by another thread or timeout

[10:01:51.0270] <shu>
i don't think `await`s are like that

[10:05:05.0658] <legendecas>
IIUC we can not resolve a promise off the thread, so blocking version of `await` sounds like a deadlock.

[10:06:33.0056] <shu>
it doesn't have to be, but you'd have to invent a radically different set of event loop semantics

[10:06:42.0873] <shu>
which makes me think it is probably an infeasible idea

[10:07:40.0336] <shu>
 * bakkot: probably a terrible idea?

[15:58:46.0113] <Richard Gibson>
GetSuperBase makes a supposedly fallible call `? _home_.[[GetPrototypeOf]]()`, but AFAICT every [[HomeObject]] is a code-inaccessible built-in object created by either ClassDefinitionEvaluation step 14â€“15 or Â§13.2.5.4 Evaluation of |ObjectLiteral|, in either case with an infallible (and ordinary) [[GetPrototypeOf]]. Can someone check me here, providing example source text where it failsâ€”or even where GetSuperBase observes an undefined [[HomeObject]]?

MakeMethod($f, _object_) sets $f.[[HomeObject]] to _object_ and is called from only
* DefineMethod with argument _object_
* MethodDefinitionEvaluation with argument _object_

MakeMethod($f, _homeObject_) sets $f.[[HomeObject]] to _object_ and is called from only
* ClassFieldDefinitionEvaluation with argument _homeObject_
* ClassStaticBlockDefinitionEvaluation with argument _homeObject_


DefineMethod is called with argument _object_ from only
* MethodDefinitionEvaluation with argument _object_

DefineMethod is called with argument _proto_ from only
* ClassDefinitionEvaluation
  * for the ConstructorMethod of the class body
  * where _proto_ is OrdinaryObjectCreate(_protoParent_), exposed as the "prototype" property of the returned class constructor
  * where _protoParent_ is `null` for `extends null`, x.prototype for `extends x` where it is `null` or an object, and %Object.prototype% for missing `extends`

MethodDefinitionEvaluation is called with argument _object_ from only
* PropertyDefinitionEvaluation with argument _object_
* ClassElementEvaluation with argument _object_

ClassFieldDefinitionEvaluation is called with argument _object_ from only
* ClassElementEvaluation with argument _object_

ClassStaticBlockDefinitionEvaluation is called with argument _object_ from only
* ClassElementEvaluation with argument _object_


ClassElementEvaluation is called with argument _proto_ from only
* ClassDefinitionEvaluation
  * for non-static class elements
  * where _proto_ is OrdinaryObjectCreate(_protoParent_), exposed as the "prototype" property of the returned class constructor
  * where _protoParent_ is `null` for `extends null`, x.prototype for `extends x` where it is `null` or an object, and %Object.prototype% for missing `extends`

ClassElementEvaluation is called with argument _F_ from only
* ClassDefinitionEvaluation
  * for static class elements
  * where _F_ is the returned class constructor (and subject to later prototype mutation)

PropertyDefinitionEvaluation is called with argument _obj_ from only
* Evaluation of |ObjectLiteral|
  * where _obj_ is OrdinaryObjectCreate(%Object.prototype%)
  * where _obj_ is returned (and subject to later prototype mutation)

[16:04:21.0348] <bakkot>
Richard Gibson: your analysis sounds right to me

[16:05:43.0662] <bakkot>
I strongly suspect there's a number of remaining cases where there's a `!` which should be a `?`

[16:05:57.0158] <bakkot>
or, I should say the non-throwy-ness sounds right; I haven't looked for how it might be `undefined`


2022-03-23
[00:44:34.0978] <Jesse>
> <@bakkot:matrix.org> I strongly suspect there's a number of remaining cases where there's a `!` which should be a `?`

might be a dumb question, but why do we even annotate uses of AOs with `?` and `!`? If the AO is fallible, then probably *every* use of it should be flagged with `?`. Flagging a use of a fallible AO with `!`, to be meaningful, would require a proof that the use of the AO in that case (or cases) can never fail. If an AO is, on the other hand, infallible, then *every* use of it should be marked with `!`. Marking a use of an infallible AO with `?` would be an editorial mistake, and flagging the use as `!` would be redundant. So the only informative case I can see is (1) fallible AO, (2) used in an infallible way

[01:16:40.0990] <annevk>
Historically at least the ? took care of unwrapping the return value, but I'm not really sure what the state of play is these days as there has been some refactoring

[04:32:04.0748] <Ashley Claymore>
> Flagging a use of a fallible AO with !, to be meaningful, would require a proof that the use of the AO in that case (or cases) can never fail

While I like the rigidity of having a proof with each assertion in the spec, that sounds easiest said than done. Maybe one day, as the spec becomes more and more machine understandable?
I do think there is still value in the assertions, when reading the spec it is very help to immediately see that we believe a certain AO call will not fail. But yes this is done on trust of the spec authors

[04:32:19.0233] <Ashley Claymore>
 * > Flagging a use of a fallible AO with !, to be meaningful, would require a proof that the use of the AO in that case (or cases) can never fail

While I like the rigidity of having a proof with each assertion in the spec, that sounds easiest said than done. Maybe one day, as the spec becomes more and more machine understandable?
I do think there is still value in the assertions, when reading the spec it is very help to immediately see that we believe a certain AO call will not fail. But yes this is done on trust of the spec authors

[04:48:15.0477] <annevk>
It's not like removing the assertions would magically make it more correct either. ðŸ™‚

[05:59:42.0504] <Ashley Claymore>
 * > Flagging a use of a fallible AO with !, to be meaningful, would require a proof that the use of the AO in that case (or cases) can never fail

While I like the <del>rigidity</del><ins>safety</ins> of having a proof with each assertion in the spec, that sounds easiest said than done. Maybe one day, as the spec becomes more and more machine understandable?
I do think there is still value in the assertions, when reading the spec it is very help to immediately see that we believe a certain AO call will not fail. But yes this is done on trust of the spec authors

[06:00:06.0998] <Ashley Claymore>
 * > Flagging a use of a fallible AO with !, to be meaningful, would require a proof that the use of the AO in that case (or cases) can never fail

While I like the <del>rigidity</del><ins>safety</ins> of having a proof with each assertion in the spec, that sounds easier said than done. Maybe one day, as the spec becomes more and more machine understandable?
I do think there is still value in the assertions, when reading the spec it is very help to immediately see that we believe a certain AO call will not fail. But yes this is done on trust of the spec authors

[06:00:49.0194] <Ashley Claymore>
 * > Flagging a use of a fallible AO with !, to be meaningful, would require a proof that the use of the AO in that case (or cases) can never fail

While I like the <del>rigidity</del><ins>safety</ins> of having a proof with each assertion in the spec, that sounds easier said than done. Maybe one day, as the spec becomes more and more machine understandable?
I do think there is still value in the assertions, when reading the spec I have found it very helpful to immediately see that we believe a certain AO call will not fail. But yes this is done on trust of the spec authors

[06:34:06.0820] <bakkot>
Jesse: turns out there are a _lot_ of places where there is a fallible AO used in an infallible way

[06:34:16.0989] <bakkot>
that is, in fact, every use of `!` in the spec now

[06:34:30.0225] <bakkot>
(infallible AOs are not called with either `?` or `!`)

[07:52:40.0397] <Richard Gibson>
> <@bakkot:matrix.org> or, I should say the non-throwy-ness sounds right; I haven't looked for how it might be `undefined`

I came back to this today, and the only use of GetSuperBase() (step 3 of MakeSuperPropertyReference) is immediately preceded by an "_env_.HasSuperBinding() is *true*" assertion, which confirms that [[HomeObject]] is not undefined (the only location I found where it _could_ be is prevented by step 10.f of PerformEval; all others seem to be prevented by "â€¦ Contains |SuperProperty|" early errors). So GetSuperBase step 2 can be removed, and there is arbitrary flexibility between it and MakeSuperPropertyReference.

[08:53:48.0414] <Rob Palmer>
**Reminder:**  There is a request for feedback on the Reflector for the upcoming real-life June plenary in Austin as part of OpenJS World conference.  Please respond by Friday 25 March.

https://github.com/tc39/Reflector/issues/423


2022-03-24
[18:38:21.0538] <bakkot>
ljharb or any other github admin: I dunno what's going on with this account but it is not... coherent; can y'all remove it? https://github.com/tc39/ecmarkup/pull/424#pullrequestreview-919612651

[18:38:46.0064] <bakkot>
I don't know what our policy is for banning people for incoherence rather than actual CoC violations

[18:38:49.0561] <ljharb>
Not the review - github reviews canâ€™t be moderated. I can hide the other one tho

[18:39:02.0374] <bakkot>
I meant like preventing them from commenting on tc39 repos

[18:39:07.0639] <ljharb>
oh theyâ€™re both reviews

[18:39:27.0845] <ljharb>
yeah, I could block them - but usually we donâ€™t do that for 2 incoherent posts

[18:40:09.0574] <ljharb>
if it keeps happening Iâ€™ll be happy to do it tho

[18:41:00.0888] <bakkot>
there was also https://github.com/tc39/ecmarkup/pull/423#pullrequestreview-919592133

[18:41:10.0797] <bakkot>
but yeah I guess may as well wait to see if there's more tomorrow

[20:40:32.0587] <Jack Works>
cannot feel the hostility from the comment as a non-native speaker, maybe it's just inappropriate words from non-native speakers?

