2022-03-01
[14:22:36.0271] <mgaudet>
Hey; I've got [a bug](https://bugzilla.mozilla.org/show_bug.cgi?id=1757162) which essentially boils down to this little test case

```
class A {
    #x = "hello";
    constructor(o = this.#x) {
        this.value = o;
    }
};

var a = new A;
// Does new A throw? if not, does a.value have the value of `hello`?
```


[14:22:48.0705] <mgaudet>
I'm trying to figure out what the spec says and got a little confused

[14:24:02.0915] <mgaudet>
https://tc39.es/ecma262/#sec-evaluatenew says that ArgumentListEvaluation happens before the constructor is invoked; but AFAICT it's the constructor that actually allocates the object... 

[14:24:35.0604] <mgaudet>
does ArgumentListEvaluation not actually... evaluate the arguments? ie, is the processing of the default argument deferred until later? 

[14:31:39.0687] <bakkot>
`ArgumentListEvaluation` evaluates _the arguments_, not the parameters

[14:32:16.0995] <bakkot>
it's the thing which would trigger the `console.log` in `f(console.log(0));`, not the thing which would trigger the `console.log` in `function f(x = console.log(0)) {}; f()`

[14:32:59.0899] <mgaudet>
yeah; I think I've got the latter traced down further into https://tc39.es/ecma262/#sec-functiondeclarationinstantiation 

[14:33:32.0804] <mgaudet>
(which seems to imply that the answer is that private fields ought to be available in that parameter expression) 

[14:33:55.0892] <mgaudet>
(I always get bit when coming back to arguments/formals/parameters) 

[14:36:38.0597] <bakkot>
yeah

[14:37:36.0990] <bakkot>
specifically, for base classes, class fields are created/installed by [[construct]] step 6.b: https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ecmascript-function-objects-construct-argumentslist-newtarget

[14:38:04.0399] <bakkot>
 * specifically, for base classes, class fields are created/installed by [[construct]] step 6.b: https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ecmascript-function-objects-construct-argumentslist-newtarget

[14:39:12.0103] <bakkot>
and parameter defaults (and other expressions) are evaluated later, in [[construct]] step 8, via OrdinaryCallEvaluateBody -> EvaluateBody -> EvaluateFunctionBody -> FunctionDeclarationInstantiation -> IteratorBindingInitialization

[14:40:11.0699] <bakkot>
so private fields (and all other fields) are available (for base classes) by the time the parameter list is evaluated

[14:40:28.0166] <mgaudet>
Yep :) Was writing that out... less nicely than you in the bug :P 


2022-03-02
[12:11:07.0493] <bakkot>
the snippet of code for getting the time is wrong on the agenda; can someone fix it? https://github.com/tc39/agendas/blob/main/2022/03.md

[12:11:33.0045] <bakkot>
I can do it if I remember next time I have an opportunity

[12:12:01.0489] <bakkot>
(it has the wrong date)


2022-03-03
[16:06:48.0051] <ljharb>
done


2022-03-07
[10:13:38.0587] <jschoi>
A friendly reminder to delegates that thereâ€™s an incubator meeting about `Function` helper functions tomorrow! Hope to see you there. https://github.com/tc39/incubator-agendas/blob/master/2022/03-08.md


2022-03-08
[08:03:53.0082] <shu>
ljharb: incubator call?

[08:05:00.0615] <ljharb>
Iâ€™ll be a few late, but Iâ€™m coming

[08:25:12.0906] <ljharb>
jschoi: "demethodize" is pretty gross imo, ftr :-p

[09:01:10.0789] <shu>
it sounds like a surgical procedure

[11:51:46.0153] <ljharb>
so, we have `x?.(y)`, where it doesn't call `x` unless `x` is non-nullish; is there no simple way to do `x(y)` when _y_ is non-nullish? (obv i can do `y == null ? y : x(y)` but that means i have to repeat the `y` expression more than once, or store it in a var)

[12:01:17.0935] <Ashley Claymore>
sounds like you want optional pipeline ðŸ˜‰

[12:01:34.0057] <Ashley Claymore>
 * sounds like you want optional pipeline ðŸ˜‰

[12:02:10.0572] <Ashley Claymore>
`y ?> x(<sigil>)`

[12:02:26.0534] <bakkot>
optional pipeline :(

[12:02:49.0120] <bakkot>
we could just have do-notation, like a real language

[12:03:07.0046] <Ashley Claymore>
ðŸ”¥

[12:04:40.0003] <shu>
real languages are statement based, only acceptable expressions are immediates and registers and addresses

[12:04:46.0945] <shu>
and immediates can't be too big

[12:04:52.0405] <shu>
and it'll be an awkward number of bits, like 21

[12:06:00.0164] <Ashley Claymore>
all logic is ternary. true/false/unknown 

