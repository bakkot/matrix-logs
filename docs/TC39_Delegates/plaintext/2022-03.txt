2022-03-01
[14:22:36.0271] <mgaudet>
Hey; I've got [a bug](https://bugzilla.mozilla.org/show_bug.cgi?id=1757162) which essentially boils down to this little test case

```
class A {
    #x = "hello";
    constructor(o = this.#x) {
        this.value = o;
    }
};

var a = new A;
// Does new A throw? if not, does a.value have the value of `hello`?
```


[14:22:48.0705] <mgaudet>
I'm trying to figure out what the spec says and got a little confused

[14:24:02.0915] <mgaudet>
https://tc39.es/ecma262/#sec-evaluatenew says that ArgumentListEvaluation happens before the constructor is invoked; but AFAICT it's the constructor that actually allocates the object... 

[14:24:35.0604] <mgaudet>
does ArgumentListEvaluation not actually... evaluate the arguments? ie, is the processing of the default argument deferred until later? 

[14:31:39.0687] <bakkot>
`ArgumentListEvaluation` evaluates _the arguments_, not the parameters

[14:32:16.0995] <bakkot>
it's the thing which would trigger the `console.log` in `f(console.log(0));`, not the thing which would trigger the `console.log` in `function f(x = console.log(0)) {}; f()`

[14:32:59.0899] <mgaudet>
yeah; I think I've got the latter traced down further into https://tc39.es/ecma262/#sec-functiondeclarationinstantiation 

[14:33:32.0804] <mgaudet>
(which seems to imply that the answer is that private fields ought to be available in that parameter expression) 

[14:33:55.0892] <mgaudet>
(I always get bit when coming back to arguments/formals/parameters) 

[14:36:38.0597] <bakkot>
yeah

[14:37:36.0990] <bakkot>
specifically, for base classes, class fields are created/installed by [[construct]] step 6.b: https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ecmascript-function-objects-construct-argumentslist-newtarget

[14:38:04.0399] <bakkot>
 * specifically, for base classes, class fields are created/installed by [[construct]] step 6.b: https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ecmascript-function-objects-construct-argumentslist-newtarget

[14:39:12.0103] <bakkot>
and parameter defaults (and other expressions) are evaluated later, in [[construct]] step 8, via OrdinaryCallEvaluateBody -> EvaluateBody -> EvaluateFunctionBody -> FunctionDeclarationInstantiation -> IteratorBindingInitialization

[14:40:11.0699] <bakkot>
so private fields (and all other fields) are available (for base classes) by the time the parameter list is evaluated

[14:40:28.0166] <mgaudet>
Yep :) Was writing that out... less nicely than you in the bug :P 


2022-03-02
[12:11:07.0493] <bakkot>
the snippet of code for getting the time is wrong on the agenda; can someone fix it? https://github.com/tc39/agendas/blob/main/2022/03.md

[12:11:33.0045] <bakkot>
I can do it if I remember next time I have an opportunity

[12:12:01.0489] <bakkot>
(it has the wrong date)


2022-03-03
[16:06:48.0051] <ljharb>
done


2022-03-07
[10:13:38.0587] <jschoi>
A friendly reminder to delegates that there’s an incubator meeting about `Function` helper functions tomorrow! Hope to see you there. https://github.com/tc39/incubator-agendas/blob/master/2022/03-08.md


2022-03-08
[08:03:53.0082] <shu>
ljharb: incubator call?

[08:05:00.0615] <ljharb>
I’ll be a few late, but I’m coming

[08:25:12.0906] <ljharb>
jschoi: "demethodize" is pretty gross imo, ftr :-p

[09:01:10.0789] <shu>
it sounds like a surgical procedure

[11:51:46.0153] <ljharb>
so, we have `x?.(y)`, where it doesn't call `x` unless `x` is non-nullish; is there no simple way to do `x(y)` when _y_ is non-nullish? (obv i can do `y == null ? y : x(y)` but that means i have to repeat the `y` expression more than once, or store it in a var)

[12:01:17.0935] <Ashley Claymore>
sounds like you want optional pipeline 😉

[12:01:34.0057] <Ashley Claymore>
 * sounds like you want optional pipeline 😉

[12:02:10.0572] <Ashley Claymore>
`y ?> x(<sigil>)`

[12:02:26.0534] <bakkot>
optional pipeline :(

[12:02:49.0120] <bakkot>
we could just have do-notation, like a real language

[12:03:07.0046] <Ashley Claymore>
🔥

[12:04:40.0003] <shu>
real languages are statement based, only acceptable expressions are immediates and registers and addresses

[12:04:46.0945] <shu>
and immediates can't be too big

[12:04:52.0405] <shu>
and it'll be an awkward number of bits, like 21

[12:06:00.0164] <Ashley Claymore>
all logic is ternary. true/false/unknown 

[12:11:13.0038] <jschoi>
> <@aclaymore:matrix.org> sounds like you want optional pipeline 😉

There’s going to be a bikeshed around whether to use falsey or nullish for optional pipes. 🤔 

[12:12:08.0125] <bakkot>
nullish is the only reasonable choice for optional pipes

[12:12:11.0812] <bakkot>
also I don't want optional pipes

[12:12:17.0408] <bakkot>
but it's the only reasonable choice if we have to have them

[12:22:57.0854] <jschoi>
> <@aclaymore:matrix.org> all logic is ternary. true/false/unknown 

Also, we both have null and undefined. We can go further. https://www.computer.org/csdl/proceedings-article/glsv/1991/00143992/12OmNzzxusf

Quaternary logic. We have the technology. Do we have the courage? [joke]

[12:23:35.0286] <jschoi>
* > <@aclaymore:matrix.org> all logic is ternary. true/false/unknown 

Also, we have null and undefined. We can go further. https://www.computer.org/csdl/proceedings-article/glsv/1991/00143992/12OmNzzxusf

Quaternary logic. We have the technology. Do we have the courage?

[12:24:22.0159] <jschoi>
* > <@aclaymore:matrix.org> all logic is ternary. true/false/unknown 

Also, we both have null and undefined. We can go further. https://www.computer.org/csdl/proceedings-article/glsv/1991/00143992/12OmNzzxusf

Quaternary logic. We have the technology. Do we have the courage? [joke]

[12:30:58.0308] <bakkot>
we have gone further

[12:31:07.0359] <bakkot>
we have an infinite number of `document.all`s available to us

[12:31:18.0811] <bakkot>
for as many non-null/undef nullish values as you want

[12:46:45.0073] <TabAtkins>
> <@jschoi:matrix.org> There’s going to be a bikeshed around whether to use falsey or nullish for optional pipes. 🤔

? It would use the same rules as optional-call and ??; anything else would be a profound mistake.

[13:59:53.0261] <jschoi>
Yeah, I had thought there would be some disagreement on this, but it looks like everyone (including me) agrees with nullishness.

[14:46:24.0173] <TabAtkins>
I don't think it's *particularly* that everyone agrees on nullishness (tho maybe people do), it's just that it's extremely clear that all the things doing optionality with the same syntax pattern need to act the same.

[15:39:44.0342] <Michael Ficarra>
> <@bakkot:matrix.org> we have an infinite number of `document.all`s available to us

not even limited to `document.all`, hosts can put `[[IsHTMLDDA]]` on any objects they choose

[15:40:28.0658] <shu>
owo

[15:41:41.0154] <bakkot>
"can", but "should" not

[15:41:56.0611] <bakkot>
"implementations should not create any with the exception of document.all"

[15:42:00.0633] <bakkot>
should've said "must"

[15:42:22.0916] <ljharb>
still could

[15:43:09.0856] <Michael Ficarra>
^

[15:43:12.0141] <bakkot>
with consensus, which, I definitely do not care enough about this to spend committee time on it

[15:43:24.0213] <Michael Ficarra>
also, now I've noticed that there's an issue with B.3.6.3 https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-typeof

[15:44:17.0740] <bakkot>
what's the issue?

[15:44:41.0610] <Michael Ficarra>
the left column of that table should separate all language values unambiguously

[15:45:01.0817] <Michael Ficarra>
an object with `[[IsHTMLDDA]]` will always fall into two rows

[15:45:10.0479] <Michael Ficarra>
either it has `[[Call]]` or it doesn't

[15:48:45.0981] <Michael Ficarra>
we should just have it insert a step into 13.5.3.1 instead of a row into the table

[15:53:31.0030] <Michael Ficarra>
https://github.com/tc39/ecma262/issues/2685


2022-03-09
[15:15:34.0307] <bakkot>
262 editors are planning on changing out `the result of evaluating |Whatever|` with `Evaluation of |Whatever|`, to better match other SDOs (`NamedEvaluation of |Whatever|`, etc)

this makes it more consistent with the rest of the spec and also works better with tooling

if anyone strongly objects to this change, speak now


2022-03-10
[16:16:36.0822] <shu>
so many editors in agreement

[16:32:50.0575] <bakkot>
shu: array find-from-last shipped unflagged in M97, right?

[16:32:55.0964] <bakkot>
should probably close https://bugs.chromium.org/p/v8/issues/detail?id=11990 if that's so

[16:33:25.0691] <bakkot>
 * shu: array find-from-last shipped unflagged in M97, right?

[16:33:56.0690] <shu>
good call, done

[02:57:54.0594] <Jack Works>
can anyone access https://jschoi.org/21/es-dataflow/map/ ?

[02:59:06.0403] <nicolo-ribaudo>
No

[02:59:37.0342] <nicolo-ribaudo>
I get an error even on your homepage

[03:44:48.0507] <legendecas>
> <@jackworks:matrix.org> can anyone access https://jschoi.org/21/es-dataflow/map/ ?

Not sure if jschoi removed it intentionally. I'm assuming it's not since the whole site is down. You can try https://web.archive.org/web/20220121194801if_/https://cdn.glitch.me/fce49fe7-f83b-4170-90d5-ab11ebc3ff25/21--es-dataflow--map.png

[06:21:47.0649] <jschoi>
Jack Works, legendecas, nicolo-ribaudo: Thanks for letting me know. My website host’s DNS settings had changed for some reason. I just updated them, so the website including the dataflow article should work now (though it might take up to several hours for the new DNS records to propagate).

[06:22:38.0994] <jschoi>
 * Jack Works, legendecas, nicolo-ribaudo: Thanks for letting me know. My website host’s DNS settings had changed for some reason. I just updated them, so the website including the dataflow article should work now (though it might take up to several hours for the new DNS records to propagate).

[13:24:55.0557] <rkirsling>
wait what's this about an in-person meeting?

[13:25:12.0402] <rkirsling>
first I'm catching wind of that

[13:27:45.0069] <Rob Palmer>
It was announced as part of the 2022 schedule last year. And in the last meeting I said I would give an update in the next plenary to confirm the details. 

I shall be sending out a Reflector post soon to collect numbers and feedback. It is hosted by OpenJS in Austin, Texas. The OpenJS organisers themselves plan to make a call on whether to proceed in just over a week. So it will also depend on their stance. 

[13:29:20.0726] <Rob Palmer>
We will still have dial in as always and there will be no pressure to attend in person. 

[13:41:17.0336] <devsnek>
i hope they cancel it

[13:43:45.0962] <shu>
austin in summer is not the kind of weather i'd travel for

[13:45:41.0319] <devsnek>
erights phoddie do you have any additional info on this weakmap implementation 👀

[13:49:59.0146] <Luca Casonato>
These recent Texas news are also not really making me super enthused about traveling there anymore

[14:23:18.0209] <rkirsling>
true, I think I would wait yet

[14:44:52.0042] <ljharb>
(both June and September are loosely planned to be in-person, as i understand it)

[14:45:41.0082] <ljharb>
 * (both June and September are loosely planned to be in-person, as i understand it, in Austin and Tokyo respectively)


2022-03-11
[09:33:02.0704] <bterlson>
Do we have a release candidate for 2022 yet?

[09:33:40.0566] <bakkot>
Not yet, we want to get one or two more things in

[09:33:58.0614] <bakkot>
but we'll be cutting it shortly (should be within a week) and will announce it on the reflector

[09:34:52.0313] <bterlson>
Awesome, thanks for the update! (just calling this out in the chair report)

[11:09:06.0942] <Michael Ficarra>
FYI for anyone who was unable to access the slides for the upcoming "extending built-ins" discussion linked from the March agenda: we were having IT issues with sharing, but they should be fixed now and the slides should be accessible again

[11:09:19.0041] <Michael Ficarra>
slides link for convenience: https://docs.google.com/presentation/d/1toEo_vh-UMqnaiQrj-gl3gWtvC34zzsraHnlIKouBtQ

[11:09:39.0286] <Michael Ficarra>
please let me know ASAP if the issue crops up again


2022-03-12
[16:42:49.0792] <jschoi>
> Should Symbol.species continue to be an extension affordance generally?

Remind me in case my memory is bad, but Everyone in TC39 agrees that Symbol.species was a Bad Idea that Should Be Removed If Possible, right?

[16:55:38.0314] <bakkot>
lotta people dislike it in the places it currently gets used - arrays, typed arrays, promises, regexes - but it is much less obviously a bad idea for Map and Set, even though those have no methods which use it

[01:44:14.0519] <Jack Works>
👀 does anyone know what's the status of iterator helper?


2022-03-13
[19:28:33.0647] <ljharb>
cc Michael Ficarra; i'm not sure what's holding it back from seeking stage 3

[21:06:42.0466] <bakkot>
the current binding constraint is the champions having time to pursue it, I am pretty sure


2022-03-14
[10:08:30.0630] <Michael Ficarra>
ljharb: Yulia had done a lot of work on it in a time when I was very busy and couldn't follow, so she would be the best person to ask about what remains

[10:09:26.0395] <yulia>
Right, there are a few small unresolved topics that i need to get to

[10:09:57.0175] <yulia>
the major one is this: https://github.com/tc39/proposal-iterator-helpers/issues/122

[10:10:04.0193] <yulia>
i haven't had time to dig into this properly due to other priorities

[10:10:13.0141] <Michael Ficarra>
yulia: welcome back!

[10:10:37.0450] <yulia>
Thanks

[10:10:52.0887] <yulia>
I am happy to sit down with folks and hammer this out + update firefox's implementation to match

[10:11:15.0194] <yulia>
the other issues in the repo, last i checked, were less significant

[10:11:56.0993] <yulia>
I can see about getting it done by the end of the week, its been on my list for way too long

[10:12:26.0563] <yulia>
Though, feedback / opinions would be very welcome... 

[10:12:47.0281] <yulia>
maybe, Michael Ficarra -- I summarize the proposed change, bring it to committee, and then the following meeting we try to advance?

[10:13:33.0540] <Michael Ficarra>
the following meeting isn't until June, so I think that gives us plenty of time, yes

[10:26:10.0692] <ljharb>
the issue title still confuses me, i continue to have no idea what "passing the protocol" means

[10:42:41.0454] <Michael Ficarra>
ljharb: it's just whether `return`/`throw` on an iterator produced by iterator helpers behave the same as if they were called on the original iterator

[10:43:18.0128] <Michael Ficarra>
see https://github.com/tc39/proposal-iterator-helpers/issues/122#issuecomment-909432348

[10:43:21.0343] <ljharb>
ah k, thanks

[10:43:59.0651] <ljharb>
so like, forwarding the full iterator API (ie, return/throw)?

[10:44:14.0011] <Michael Ficarra>
yep

[10:44:32.0996] <Michael Ficarra>
it's harder to do than just making `next` work

[10:44:57.0265] <Michael Ficarra>
the unfortunate bit is that a whole class of usages only care that `next` works

[10:45:59.0064] <yulia>
the argument against passing the full iterator api is that most of these methods are not intended to be communicating generators, and in this case does it make sense to pass return and throw

[10:48:12.0720] <ljharb>
ugh, `return` and `throw` are gross

[10:52:15.0761] <Michael Ficarra>
archival footage of TC39 adding generators to the language

[10:54:30.0592] <ljharb>
please don't besmirch the good name of shoehorns

[11:00:09.0527] <yulia>
hm, it may get tricky in relation to the other issues like this one: https://github.com/tc39/proposal-iterator-helpers/issues/174

[11:00:17.0302] <yulia>
I'll do a more detailed review later this week

[12:10:36.0275] <bakkot>
Michael Ficarra: I think we were all agreed that `return` and `throw` should get forwarded and the remaining question is whether `.next` forwards its argument

[12:10:52.0785] <bakkot>
`return` needs to get forwarded so that the underlying iterator is properly closed

[12:11:06.0938] <bakkot>
(and `throw` doesn't really matter because nothing in the language calls it)

[12:23:59.0786] <Mathieu Hofman>
> <@yulia:mozilla.org> hm, it may get tricky in relation to the other issues like this one: https://github.com/tc39/proposal-iterator-helpers/issues/174

Yeah I haven't had time to continue on this, and I had noticed that iterator helpers had some similar issues. Happy to chat since I did a deep dive on the return/throw behavior, especially in the erroneous cases.

[12:47:52.0699] <yulia>
Mathieu Hofman: great, i will take you up on that

[12:48:11.0284] <yulia>
maybe this won't make it to the end of the week, it is hairier than i remember

[12:48:33.0287] <yulia>
but if you have time maybe we can sit down towards thursday/fri?

[12:48:48.0779] <yulia>
or early next week

[12:48:57.0250] <yulia>
i guess i can put a discussion item on the agenda anyway


2022-03-15
[18:00:00.0913] <bakkot>
shu: re https://github.com/tc39/ecma262/pull/2646, did you know that TA.prototype.sort _also_ has a per-iteration detachedness check?

[18:02:50.0433] <bakkot>
it doesn't even get you anything because you have to read all of the values out of the buffer before the loop anyway, since `compareFn` can write to the buffer

[04:35:29.0761] <Ashley Claymore>
My guess is this was missed when https://github.com/tc39/ecma262/pull/1585 landed? Before es2021 the order of calls to [get] and `comparefn` was implementation defined. From es6 onwards there has always been that detached check

[04:36:24.0254] <Ashley Claymore>
 * My guess is this was missed when https://github.com/tc39/ecma262/pull/1585 landed? Before es2021 the order of calls to [get] and `comparefn` was implementation defined. From es6 onwards there has always been that detached check

[11:27:08.0357] <shu>
bakkot: lol i did not


2022-03-16
[04:16:24.0786] <yulia | sick>
I am unlikely to get anything done this week.

[04:17:05.0658] <yulia | sick>
ill try to post the issue for discussion though

[07:40:46.0824] <annevk>
yulia | sick: take care and I hope you recover quickly (and please remember that almost nothing in standards is time-sensitive)

[07:56:43.0027] <Rob Palmer>
best wishes for a speedy recovery, Yulia


2022-03-17
[10:21:14.0556] <jschoi>
HE Shi-Jun: You had mentioned, in the ad-hoc dataflow meeting after last plenary, that you were planning to give an update on the Extensions proposal at the upcoming plenary. Are you still planning to give an update on Extensions?

[10:40:30.0680] <jschoi>
* HE Shi-Jun: You had mentioned, in the ad-hoc dataflow meeting after last plenary, that you were planning to give an update on the Extensions proposal at the upcoming plenary. Are you still planning to give an update on Extensions? (I’m planning to give an update on the bind-this/call-this and pipe operators.)


2022-03-21
[13:42:01.0463] <Rob Palmer>
Hello all, I've posted a request for feedback on the Reflector for the upcoming **real-life** June plenary in Austin as part of OpenJS World conference.

https://github.com/tc39/Reflector/issues/423


2022-03-22
[20:33:48.0310] <ljharb>
psyched for a nonfictional plenary

[09:55:08.0824] <bakkot>
could we add a blocking version of await, only available off the main thread

[09:55:16.0580] <bakkot>
we already have atomics.wait

[09:55:28.0698] <bakkot>
 * could we add a blocking version of await, only available off the main thread

[09:55:32.0090] <bakkot>
is this a terrible idea

[09:57:17.0446] <Ashley Claymore>
the win being not worrying about red/blue functions? Or could there also be performance wins to blocking over using await mechanics ?

[10:00:47.0793] <shu>
bakkot: probably?

[10:01:46.0968] <shu>
what are the proposed semantics? remember `Atomics.wait` only gets woken up by another thread or timeout

[10:01:51.0270] <shu>
i don't think `await`s are like that

[10:05:05.0658] <legendecas>
IIUC we can not resolve a promise off the thread, so blocking version of `await` sounds like a deadlock.

[10:06:33.0056] <shu>
it doesn't have to be, but you'd have to invent a radically different set of event loop semantics

[10:06:42.0873] <shu>
which makes me think it is probably an infeasible idea

[10:07:40.0336] <shu>
 * bakkot: probably a terrible idea?

[15:58:46.0113] <Richard Gibson>
GetSuperBase makes a supposedly fallible call `? _home_.[[GetPrototypeOf]]()`, but AFAICT every [[HomeObject]] is a code-inaccessible built-in object created by either ClassDefinitionEvaluation step 14–15 or §13.2.5.4 Evaluation of |ObjectLiteral|, in either case with an infallible (and ordinary) [[GetPrototypeOf]]. Can someone check me here, providing example source text where it fails—or even where GetSuperBase observes an undefined [[HomeObject]]?

MakeMethod($f, _object_) sets $f.[[HomeObject]] to _object_ and is called from only
* DefineMethod with argument _object_
* MethodDefinitionEvaluation with argument _object_

MakeMethod($f, _homeObject_) sets $f.[[HomeObject]] to _object_ and is called from only
* ClassFieldDefinitionEvaluation with argument _homeObject_
* ClassStaticBlockDefinitionEvaluation with argument _homeObject_


DefineMethod is called with argument _object_ from only
* MethodDefinitionEvaluation with argument _object_

DefineMethod is called with argument _proto_ from only
* ClassDefinitionEvaluation
  * for the ConstructorMethod of the class body
  * where _proto_ is OrdinaryObjectCreate(_protoParent_), exposed as the "prototype" property of the returned class constructor
  * where _protoParent_ is `null` for `extends null`, x.prototype for `extends x` where it is `null` or an object, and %Object.prototype% for missing `extends`

MethodDefinitionEvaluation is called with argument _object_ from only
* PropertyDefinitionEvaluation with argument _object_
* ClassElementEvaluation with argument _object_

ClassFieldDefinitionEvaluation is called with argument _object_ from only
* ClassElementEvaluation with argument _object_

ClassStaticBlockDefinitionEvaluation is called with argument _object_ from only
* ClassElementEvaluation with argument _object_


ClassElementEvaluation is called with argument _proto_ from only
* ClassDefinitionEvaluation
  * for non-static class elements
  * where _proto_ is OrdinaryObjectCreate(_protoParent_), exposed as the "prototype" property of the returned class constructor
  * where _protoParent_ is `null` for `extends null`, x.prototype for `extends x` where it is `null` or an object, and %Object.prototype% for missing `extends`

ClassElementEvaluation is called with argument _F_ from only
* ClassDefinitionEvaluation
  * for static class elements
  * where _F_ is the returned class constructor (and subject to later prototype mutation)

PropertyDefinitionEvaluation is called with argument _obj_ from only
* Evaluation of |ObjectLiteral|
  * where _obj_ is OrdinaryObjectCreate(%Object.prototype%)
  * where _obj_ is returned (and subject to later prototype mutation)

[16:04:21.0348] <bakkot>
Richard Gibson: your analysis sounds right to me

[16:05:43.0662] <bakkot>
I strongly suspect there's a number of remaining cases where there's a `!` which should be a `?`

[16:05:57.0158] <bakkot>
or, I should say the non-throwy-ness sounds right; I haven't looked for how it might be `undefined`


2022-03-23
[00:44:34.0978] <Jesse>
> <@bakkot:matrix.org> I strongly suspect there's a number of remaining cases where there's a `!` which should be a `?`

might be a dumb question, but why do we even annotate uses of AOs with `?` and `!`? If the AO is fallible, then probably *every* use of it should be flagged with `?`. Flagging a use of a fallible AO with `!`, to be meaningful, would require a proof that the use of the AO in that case (or cases) can never fail. If an AO is, on the other hand, infallible, then *every* use of it should be marked with `!`. Marking a use of an infallible AO with `?` would be an editorial mistake, and flagging the use as `!` would be redundant. So the only informative case I can see is (1) fallible AO, (2) used in an infallible way

[01:16:40.0990] <annevk>
Historically at least the ? took care of unwrapping the return value, but I'm not really sure what the state of play is these days as there has been some refactoring

[04:32:04.0748] <Ashley Claymore>
> Flagging a use of a fallible AO with !, to be meaningful, would require a proof that the use of the AO in that case (or cases) can never fail

While I like the rigidity of having a proof with each assertion in the spec, that sounds easiest said than done. Maybe one day, as the spec becomes more and more machine understandable?
I do think there is still value in the assertions, when reading the spec it is very help to immediately see that we believe a certain AO call will not fail. But yes this is done on trust of the spec authors

[04:32:19.0233] <Ashley Claymore>
 * > Flagging a use of a fallible AO with !, to be meaningful, would require a proof that the use of the AO in that case (or cases) can never fail

While I like the rigidity of having a proof with each assertion in the spec, that sounds easiest said than done. Maybe one day, as the spec becomes more and more machine understandable?
I do think there is still value in the assertions, when reading the spec it is very help to immediately see that we believe a certain AO call will not fail. But yes this is done on trust of the spec authors

[04:48:15.0477] <annevk>
It's not like removing the assertions would magically make it more correct either. 🙂

[05:59:42.0504] <Ashley Claymore>
 * > Flagging a use of a fallible AO with !, to be meaningful, would require a proof that the use of the AO in that case (or cases) can never fail

While I like the <del>rigidity</del><ins>safety</ins> of having a proof with each assertion in the spec, that sounds easiest said than done. Maybe one day, as the spec becomes more and more machine understandable?
I do think there is still value in the assertions, when reading the spec it is very help to immediately see that we believe a certain AO call will not fail. But yes this is done on trust of the spec authors

[06:00:06.0998] <Ashley Claymore>
 * > Flagging a use of a fallible AO with !, to be meaningful, would require a proof that the use of the AO in that case (or cases) can never fail

While I like the <del>rigidity</del><ins>safety</ins> of having a proof with each assertion in the spec, that sounds easier said than done. Maybe one day, as the spec becomes more and more machine understandable?
I do think there is still value in the assertions, when reading the spec it is very help to immediately see that we believe a certain AO call will not fail. But yes this is done on trust of the spec authors

[06:00:49.0194] <Ashley Claymore>
 * > Flagging a use of a fallible AO with !, to be meaningful, would require a proof that the use of the AO in that case (or cases) can never fail

While I like the <del>rigidity</del><ins>safety</ins> of having a proof with each assertion in the spec, that sounds easier said than done. Maybe one day, as the spec becomes more and more machine understandable?
I do think there is still value in the assertions, when reading the spec I have found it very helpful to immediately see that we believe a certain AO call will not fail. But yes this is done on trust of the spec authors

[06:34:06.0820] <bakkot>
Jesse: turns out there are a _lot_ of places where there is a fallible AO used in an infallible way

[06:34:16.0989] <bakkot>
that is, in fact, every use of `!` in the spec now

[06:34:30.0225] <bakkot>
(infallible AOs are not called with either `?` or `!`)

[07:52:40.0397] <Richard Gibson>
> <@bakkot:matrix.org> or, I should say the non-throwy-ness sounds right; I haven't looked for how it might be `undefined`

I came back to this today, and the only use of GetSuperBase() (step 3 of MakeSuperPropertyReference) is immediately preceded by an "_env_.HasSuperBinding() is *true*" assertion, which confirms that [[HomeObject]] is not undefined (the only location I found where it _could_ be is prevented by step 10.f of PerformEval; all others seem to be prevented by "… Contains |SuperProperty|" early errors). So GetSuperBase step 2 can be removed, and there is arbitrary flexibility between it and MakeSuperPropertyReference.

[08:53:48.0414] <Rob Palmer>
**Reminder:**  There is a request for feedback on the Reflector for the upcoming real-life June plenary in Austin as part of OpenJS World conference.  Please respond by Friday 25 March.

https://github.com/tc39/Reflector/issues/423


2022-03-24
[18:38:21.0538] <bakkot>
ljharb or any other github admin: I dunno what's going on with this account but it is not... coherent; can y'all remove it? https://github.com/tc39/ecmarkup/pull/424#pullrequestreview-919612651

[18:38:46.0064] <bakkot>
I don't know what our policy is for banning people for incoherence rather than actual CoC violations

[18:38:49.0561] <ljharb>
Not the review - github reviews can’t be moderated. I can hide the other one tho

[18:39:02.0374] <bakkot>
I meant like preventing them from commenting on tc39 repos

[18:39:07.0639] <ljharb>
oh they’re both reviews

[18:39:27.0845] <ljharb>
yeah, I could block them - but usually we don’t do that for 2 incoherent posts

[18:40:09.0574] <ljharb>
if it keeps happening I’ll be happy to do it tho

[18:41:00.0888] <bakkot>
there was also https://github.com/tc39/ecmarkup/pull/423#pullrequestreview-919592133

[18:41:10.0797] <bakkot>
but yeah I guess may as well wait to see if there's more tomorrow

[20:40:32.0587] <Jack Works>
cannot feel the hostility from the comment as a non-native speaker, maybe it's just inappropriate words from non-native speakers?

[09:43:37.0860] <Rob Palmer>
**Reminder**: There is a request for feedback on the Reflector for the upcoming real-life June plenary in Austin as part of OpenJS World conference. Please respond by **tomorrow.**

https://github.com/tc39/Reflector/issues/423

(and thanks all for the replies so far!)


2022-03-25
[12:54:17.0836] <jschoi>
Would it be okay if, in the plenary agenda, I asked to move 15 minutes from one of my agenda items to another one of my agenda items?

[12:55:59.0411] <Rob Palmer>
Please raise the PR now. The agenda gets adopted at the start of the meeting. 

[12:56:33.0252] <Rob Palmer>
And chairs are doing the scheduling right now. So we need the info ASAP. 

[12:57:43.0065] <Rob Palmer>
And a reminder to all delegates, if you have personal scheduling constraints, put them on the agenda ahead of time (or now). Otherwise we have very little wiggle room. 

[13:08:17.0084] <jschoi>
Rob Palmer: Done, thank you.

[13:18:05.0147] <Justin Ridgewell>
ljharb: Can you give magic powers to pzuraq?

[14:47:18.0781] <ljharb>
if i can find their full user id, yes :-) on mobile rn tho


2022-03-26
[17:03:41.0958] <jschoi>
In https://github.com/tc39/proposal-decorators/issues/442#issuecomment-1079520819, Shu refers to new editorial conventions in Ecma262. Is this the recently added abstract-operation structured-data stuff, or is there anything else that’s new?

[17:16:31.0962] <shu>
i was specifically referring to completion reform

[17:17:21.0295] <shu>
we'll talk about it next week, in the meantime see https://docs.google.com/presentation/d/1h3SiBX5fGeu9RDKo88j8MSEsTe4DHtbgybhW02n5mGk/edit#slide=id.g11ede54a62a_4_0

[17:38:10.0080] <Michael Ficarra>
if they've upgraded ecmarkup recently, it's not hard to follow the new conventions, as ecmarkup has many associated checks

[17:40:27.0247] <Michael Ficarra>
err, more like it's hard not to

[18:33:15.0684] <bakkot>
assuming you're using structured headers anyway

[18:33:27.0703] <bakkot>
with return types


2022-03-27
[12:20:17.0815] <nicolo-ribaudo>
Chairs, any chance of having the "draft schedule" hackmd? 🙏


2022-03-28
[20:30:17.0137] <jschoi>
My sincere apologies for the late notice, but I’ve opened an agenda pull request for a 1.5-hour constraint tomorrow.

[21:47:51.0324] <ljharb>
ES2022 candidate: https://github.com/tc39/Reflector/issues/424

[21:53:06.0546] <waldemar>
Are we having the meeting tomorrow morning? I can't find the logistics anywhere: a schedule or a video link.

[22:09:47.0560] <ljharb>
usually the sign-in form is added an hour or so before the meeting, and that form's thank you page has the jitsi details

[22:09:56.0057] <ljharb>
(the draft schedule indeed doesn't seem to be up yet)

[23:06:18.0745] <Rob Palmer>
We'll be updating the Reflector post details shortly. 

[01:36:23.0275] <Rob Palmer>
Draft schedule is nearly ready.  I will say this meeting we receive a large volume of constraints, which makes catering to all folks tricky.

[02:20:36.0810] <Rob Palmer>
Ujjwal has now prepared the draft schedule.  Please see [the Reflector Post](https://github.com/tc39/Reflector/issues/420)

[06:15:54.0853] <Rob Palmer>
Hope everyone is feeling full of energy.  Plenary begins in 45mins!

[06:36:49.0454] <Rob Palmer>
I have opened the video call.  Whoever makes it through first, please say here so we know the passcode is working.

[06:38:52.0640] <Rob Palmer>
Ok, we are confirmed good on the passcode.

[06:55:05.0608] <Rick Waldron>
Good morning. I'm not going to be available until around noon, so if someone else from the Test262 Maintainer Group would like to give the update, that would be great!


[06:58:10.0125] <Rob Palmer>
*** Plenary starts in 2 mins! *** 🎉

[07:20:17.0819] <ljharb>
Rob Palmer: bterlson there's a few welcome emails waiting to be sent, eg https://github.com/tc39/Admin-and-Business/issues/209

[07:25:35.0797] <bakkot>
is IS talking about the JSON standard

[07:26:25.0784] <Tierney Cyren>
I don't believe so

[07:30:06.0520] <ljharb>
i'm confused, isn't everything TC39 does an ecma thing?

[07:30:52.0112] <shu>
yulia: since we're over timebox i'll ask my question in here: my understanding was that whether to adopt the alternative copyright was a per-TC decision, not a per-spec decision

[07:31:04.0142] <shu>
is it in fact per-spec, and that's why we need to back to the IPR committee?

[07:31:10.0598] <yulia>
it is a per tc request for a spec

[07:31:25.0406] <shu>
right, so we shouldn't need to go back to them for 262 or 404

[07:31:28.0854] <shu>
err, 402

[07:31:34.0667] <shu>
yeah, what waldemar's saying

[07:32:42.0656] <yulia>
hm, ok something to clarify

[07:33:52.0036] <yulia>
this is what happens when you go to meetings sick

[07:33:55.0408] <yulia>
ill check the documents

[07:35:50.0628] <msaboff>
yulia: I'll check the special GA docs as well.

[07:36:21.0014] <yulia>
thanks

[07:41:59.0881] <msaboff>
GA-2022-016 states
After discussing TC39's motivation for using the alternative copyright notice there is this statement:
_The IPR Ad hoc Group suggests the GA consult with Ecma Counsel and the IPR Ad Hoc Group when considering applying an Alternative Copyright Notice to any other Ecma Standards._



[07:43:42.0523] <shu>
huh, so it _is_ per standard? that process could be streamlined certainly

[07:45:56.0648] <msaboff>
I should point out that ECMAScript is the specific standard talked about before the "_any other Ecma Standards_" comment.

Therefore one reading of that statement is the 262 can adopt the ACN, but other standards like 402 would require consultation.

[07:47:13.0861] <msaboff>
 * I should point out that ECMAScript is the specific standard talked about before the "any other Ecma Standards" comment.

Therefore one reading of that statement is the 262 can adopt the ACN, but other standards like 402 would require consultation.

[07:47:51.0350] <msaboff>
 * I should point out that ECMAScript is the specific standard talked about before the "_any other Ecma Standards_" comment.

Therefore one reading of that statement is the 262 can adopt the ACN, but other standards like 402 would require consultation.

[07:48:15.0994] <yulia>
I just found this as well -- yes this is what I was thinking of (sorry, still super foggy)

[07:48:36.0088] <yulia>
 * I just found this as well -- yes this is what I was thinking of

[07:48:43.0148] <yulia>
 * I just found this as well -- yes this is what I was thinking of (sorry, still super foggy)_

[07:48:45.0609] <yulia>
 * I just found this as well -- yes this is what I was thinking of (sorry, still super foggy)

[07:49:24.0046] <yulia>
waldemar: ^ it is in GA-2022-016

[07:49:47.0452] <Tierney Cyren>
The problem has gone unaddressed for 5 years?

[07:50:05.0025] <Tierney Cyren>
That feels... unacceptable.

[07:50:21.0116] <yulia>
sorry, which problem? 

[07:50:33.0532] <Tierney Cyren>
not being able to get information from the IT people

[07:50:59.0019] <yulia>
ah, yeah this is something we should solve. I am talking to someone about it 

[07:51:48.0006] <ljharb>
worth noting the LF IT folks are highly responsive and have an SLA measured in days instead of years :-p

[07:52:04.0413] <msaboff>
shu: Visible with sun glasses on!

[07:58:51.0376] <jschoi>
Does ecmarkup now enforce AOs always having structured headers?

[08:00:11.0271] <Michael Ficarra>
jschoi: yes, though it does not mandate that you describe parameter types or return types

[08:00:36.0189] <Michael Ficarra>
please do so as much as possible (or at least explicitly mark unknown) so ecmarkup catches these kinds of errors

[08:01:58.0346] <bakkot>
> Does ecmarkup now enforce AOs always having structured headers?

no it does not

[08:02:30.0726] <bakkot>
because "not having a structured header" is just "writing prose which happens to look like an AO"

[08:03:40.0861] <Rob Palmer>
> <@rwaldron:matrix.org> Good morning. I'm not going to be available until around noon, so if someone else from the Test262 Maintainer Group would like to give the update, that would be great!

Who will give the test262 update?

[08:04:10.0352] <shu>
sarahghp maybe? if rick isn't available

[08:04:22.0550] <sarahghp>
yes I will do it

[08:07:12.0443] <bakkot>
ljharb: can you put the names in the notes

[08:07:17.0472] <bakkot>
I couldn't catch all of them

[08:07:17.0582] <ljharb>
re CoC: https://github.com/tc39/Reflector/issues/382#issuecomment-1029240838

[08:07:22.0699] <ljharb>
> <@bakkot:matrix.org> ljharb: can you put the names in the notes

yep! doing now

[08:07:36.0482] <Michael Ficarra>
maybe we should have somebody explicitly endorse the CoC committee candidates?

[08:09:24.0973] <ljharb>
Michael Ficarra: oh sorry, i should have mentioned that; by presenting them to plenary the CoC committee has implicitly endorsed them

[08:20:42.0846] <Jack Works>
this is surprising

[08:21:00.0866] <Jack Works>
I though it should work, so what I just said is wrong

[08:22:21.0405] <shu>
bakkot: is that really what we say about the current Realm for %name%s?

[08:22:27.0249] <shu>
bakkot: https://tc39.es/ecma262/#sec-well-known-intrinsic-objects isn't super clear

[08:23:02.0376] <shu>
i think the operative sentence is "before any code is evaluated"

[08:30:28.0114] <Michael Ficarra>
test262 relies on `@@species` in the runner?

[08:31:38.0448] <yulia>
yes, this came up when we proposed restriction of species generally

[08:31:58.0642] <yulia>
and i was afraid that what kevin found was related to that, to which i think the response would be -- can we do something that is test runner specific

[08:32:09.0331] <yulia>
there are other blockers to general removal/restriction, this isn't the only one 

[08:32:17.0067] <yulia>
 * there are other blockers to general removal/restriction, this isn't the only one 

[08:32:57.0272] <yulia>
this is another thing on the ever growing pile that grew ever higher while i was sick

[08:33:42.0341] <Rick Waldron>
Michael Ficarra yulia hold on, that's not quite true. The runner does not rely on @@species. There are tests that test for @@species 

[08:33:55.0029] <yulia>
oh, i may have misremembered

[08:34:15.0514] <Rick Waldron>
No problem, just clarifying 👍️

[08:34:29.0821] <Michael Ficarra>
yeah, okay, that's what I would've expected

[08:34:30.0996] <yulia>
Rick Waldron: it was a comment you made in relation to https://github.com/tc39/proposal-rm-builtin-subclassing and i think i just linked it wrong

[08:34:53.0913] <yulia>
maybe it was related to type 2 subclassing which won't happen

[08:38:36.0235] <Rick Waldron>
> <@yulia:mozilla.org> Rick Waldron: it was a comment you made in relation to https://github.com/tc39/proposal-rm-builtin-subclassing and i think i just linked it wrong

I'm having trouble finding the discussion in the notes

[08:39:29.0953] <yulia>
Rick Waldron: 

RW: So you were asking for examples of Type III. In Test262, we use Type III extensively for testing the behavior of built-ins across realms. We are heavily reliant on setting the species with a cross realm copy of the constructor to make sure the lookup chain of the constructor is preserved correctly. To make sure that the lookup chain is preserved correctly. If you look at it, I don’t want to rathole into that, we can look at it together offline. But that’s a pretty substantial example of where it’s being used in the wild. And I don’t know how else we would test cross realm behavior which is important to the language cause we have access to multiple realms in any given runtime. So I just wanted to put that on the board and say let’s chat about it offline.

[08:39:45.0680] <yulia>
is that still true?

[08:39:54.0820] <yulia>
maybe this changed

[08:40:00.0366] <Rick Waldron>
Oh right, that makes sense. I was describing what we do when we test Symbol.species. 

[08:40:34.0868] <Rick Waldron>
Let check one other thing

[08:40:42.0669] <yulia>
ok, yeah that was what i was worried kevin found

[08:40:50.0673] <yulia>
but it wasn't fortunately

[08:41:09.0355] <yulia>
I am super foggy today, so sorry if i am being confusing

[08:41:18.0248] <Rick Waldron>
Ok, confirmed: we do not rely on Symbol.species in eshost or test262-harness. 

[08:41:40.0941] <shu>
correction: Chrome never shipped and unshipped grouping because we saw this before we could ship

[08:41:51.0770] <Rick Waldron>
Symbol.species is used in test262's harness files and tests themselves, for cross realm testing. That could be changed. 

[08:42:43.0827] <yulia>
> <@rwaldron:matrix.org> Ok, confirmed: we do not rely on Symbol.species in eshost or test262-harness.

sweet!

[08:43:07.0369] <yulia>
> <@rwaldron:matrix.org> Symbol.species is used in test262's harness files and tests themselves, for cross realm testing. That could be changed.

ok, cool , this is what i thought and expressed poorly

[08:43:29.0988] <Rick Waldron>
I think I may have expressed it poorly myself

[08:44:02.0458] <Michael Ficarra>
if we don't know what versions the websites use, can't we just do a functional test?

[08:44:26.0177] <Rick Waldron>
My description above explain how its being used in the wild, but wasn't clear at which level

[08:45:09.0764] <devsnek>
groupedByTo doesn't compute in my brain

[08:46:07.0222] <TabAtkins>
yeah it feels bad

[08:47:54.0262] <devsnek>
groupMap

[08:48:39.0743] <legendecas>
groupedXX series sounds like what the array change by copy proposal is doing

[08:49:23.0908] <ljharb>
we could also go with `Object.group` and `Map.group` /ducks

[08:50:23.0601] <bakkot>
sadness

[08:50:47.0547] <bakkot>
i liked `groupBy`

[08:51:04.0180] <ljharb>
as much as i think it makes sense on Array.prototype, that does make the naming simpler, and opens up `Set.group` and friends in the future.

i also prefer `groupBy` :-/

[08:51:15.0151] <Michael Ficarra>
I feel like we gave up on `groupBy` way too easily, personally

[08:52:11.0317] <ljharb>
i mean, someone could still go evangelize

[08:53:04.0103] <Kris Kowal>
As long as we don’t break Roll20 😉

[08:57:43.0538] <bakkot>
I'm more worried about all the `.gov.br` sites

[08:57:49.0232] <bakkot>
breaking government services seems bad

[08:57:56.0642] <bakkot>
though I didn't actually check what they're hosting

[09:00:21.0413] <Kris Kowal>
Facetious wink. 👆

[09:35:00.0386] <TabAtkins>
I'm gonna verify I can project to the jitsi in one sec

[09:35:49.0718] <TabAtkins>
okay, looks good

[09:35:56.0811] <TabAtkins>
can someone verify?

[09:36:24.0542] <Sergey Rubanov>
it works

[09:37:02.0217] <TabAtkins>
cool, thanks

[09:42:51.0576] <Robert Pamely>
Are we starting again on the hour?

[09:44:05.0777] <Ashley Claymore>
yep!

[09:45:09.0363] <Ashley Claymore>
Really cool topics being discussed this afternoon!

[09:46:04.0450] <Kris Kowal>
What are the reasons Promise.resolve(promise) consults promise.constructor for promises that pass the brand check? It would be useful for us in the hardened JavaScript community if Promise.resolve(promise) could be guaranteed to give control to the provider of the promise only in subsequent events.

[09:46:53.0582] <Ashley Claymore>
does it subclass?

[09:47:19.0370] <Kris Kowal>
 * What are the reasons Promise.resolve(promise) consults promise.constructor for promises that pass the brand check? It would be useful for us at Agoric if Promise.resolve(promise) could be guaranteed to give control to the provider of the promise only in subsequent events.

[09:48:13.0283] <Kris Kowal>
I believe Promise was one of the first proposals to account for Symbol.species, so I assume so, but also assume that’s not useful.

[09:48:48.0516] <Kris Kowal>
 * What are the reasons Promise.resolve(promise) consults promise.constructor for promises that pass the brand check? It would be useful for us in the hardened JavaScript community if Promise.resolve(promise) could be guaranteed to give control to the provider of the promise only in subsequent events.

[09:50:38.0966] <Ashley Claymore>

```
class P2 extends Promise {}
let x = P2.resolve(1);
P2.resolve(x) === x;
Promise.resolve(x) !== x;
```

[09:50:42.0963] <Ashley Claymore>
Maybe because of that?

[09:50:52.0183] <Ashley Claymore>
I should probably check the spec instead of guessing...

[09:51:55.0223] <Kris Kowal>
That story checks out.

[09:54:00.0396] <bakkot>
that is almost certainly the reason, yes

[09:54:07.0429] <bakkot>
subclassing: it's bad

[09:55:42.0556] <Kris Kowal>
In a way this is good news. That means that in a SES proposal, we can change the behavior of `Promise.resolve()` such that subclassing no longer works, but our delegation invariant is preserved (after the host program opts-in by calling `lockdown()`)

[09:56:08.0292] <Kris Kowal>
 * In a way this is good news. That means that in a SES proposal, we can change the behavior of `Promise.resolve()` such that subclassing no longer works, but our delegation invariant is preserved (after the host program opts-in by calling `lockdown()`)

[09:56:32.0713] <Rob Palmer>
We start in 4 mins!

[10:03:22.0009] <bakkot>
why does this proposal allow `default`, instead of just `when(unused)`?

[10:03:38.0481] <bakkot>
or even just a bare `when {`, to go with `catch {`

[10:04:13.0255] <ljharb>
it allows either, but not both

[10:04:16.0168] <ljharb>
 * it allows either, but not both

[10:04:30.0351] <ljharb>
we could use a bare `when` instead of `default`, sure, that's just bikeshedding

[10:04:51.0759] <ljharb>
but `when (unused)` has to be allowed for consistency with the way irrefutable patterns work

[10:05:03.0510] <Tierney Cyren>
TIL 0 can have a sign

[10:05:16.0163] <ryzokuken>
is there anyplace else in JavaScript where these sematics hold? 

[10:05:22.0948] <ljharb>
ryzokuken: which?

[10:05:45.0174] <ryzokuken>
`0` matching both `+0` and `-0`

[10:05:45.0432] <bakkot>
I have no problem with `when (unused)`, I just don't see a use for `default` if you already have that

[10:05:48.0926] <bakkot>
 * I have no problem with `when (unused)`, I just don't see a use for `default` if you already have that

[10:05:49.0369] <ryzokuken>
 * `0` matching both `+0` and `-0`

[10:05:52.0899] <ljharb>
yes, `0 === -0`

[10:05:56.0278] <bakkot>
`===`

[10:05:59.0289] <ljharb>
 * yes, `0 === -0`

[10:06:00.0373] <bakkot>
also sets and maps

[10:06:08.0046] <ryzokuken>
ah, okay, thanks

[10:06:31.0611] <ljharb>
bakkot: the use is that it's confusing and gross to have to write a binding when you don't want one, and `when {` i'd argue doesn't convey that it's the "everything else" category very clearly.

[10:06:35.0869] <legendecas>
does `match(expr) { if (bool): expr }` mean matching against constant bools?

[10:06:56.0396] <ljharb>
legendecas: against an expression that resolves to a truthy or falsy value, yes

[10:06:59.0286] <ljharb>
like any other `if`

[10:07:25.0597] <bakkot>
also what's the use case for the bare `if` one

[10:07:27.0788] <bakkot>
it seems like

[10:07:29.0279] <bakkot>
not so useful

[10:07:44.0284] <bakkot>
I have a hard time seeing a case where you don't also need to name the match-ee

[10:07:46.0260] <legendecas>
> <@ljharb:matrix.org> like any other `if`

thank you. well, in the context of slides, i'm confused that why it isn't `match(expr) { if(expr): expr }`

[10:07:46.0396] <ljharb>
it's cleaner than `when (unused) if (condition)`

[10:07:48.0069] <Kris Kowal>
> <@ljharb:matrix.org> yes, `0 === -0`

Wrt differences between +0 and -0, `1/-0 === -Infinity` vs `1/0 === Infinity`.

[10:07:54.0715] <bakkot>
ljharb: does that ever happen

[10:07:59.0428] <ljharb>
> <@legendecas:matrix.org> thank you. well, in the context of slides, i'm confused that why it isn't `match(expr) { if(expr): expr }`

yeah fair, it's a confusing example

[10:08:05.0573] <ljharb>
bakkot: yes, there's examples in the readme.

[10:08:43.0836] <legendecas>
> <@ljharb:matrix.org> yeah fair, it's a confusing example

looks like this part is not in the spec, yet.

[10:08:59.0180] <ryzokuken>
so to match an array with holes I'd need to do `[undefined, undefined, "foo"]`?

[10:09:00.0406] <ljharb>
legendecas: most things aren't in the spec; it's only going for stage 2, where only an initial spec is required.

[10:09:03.0504] <ljharb>
the readme is what you want

[10:09:10.0701] <bakkot>
ljharb: the example in the readme is `match (res) {  if (isEmpty(res))` but that's still naming the matchee

[10:09:12.0512] <ljharb>
> <@usharma:igalia.com> so to match an array with holes I'd need to do `[undefined, undefined, "foo"]`?

or `[,, 'foo']`, yes

[10:09:14.0478] <bakkot>
it's just repeating the expression

[10:09:15.0404] <bakkot>
seems bad

[10:09:24.0790] <ljharb>
why?

[10:09:36.0314] <ljharb>
i see what you mean, that a bare `if` would still need to reference the matchable

[10:09:58.0631] <ljharb>
but why would it be bad to not be forced to create a new binding just to reference it, via `when (res) if (isEmpty(res))`?

[10:10:21.0693] <Jack Works>
> <@bakkot:matrix.org> I have no problem with `when (unused)`, I just don't see a use for `default` if you already have that

yeah. `default` just make it easier to read

[10:10:22.0790] <bakkot>
I'd just write `when (_) if (whatever)`

[10:10:25.0651] <bakkot>
so you don't have to learn a new form

[10:10:38.0000] <bakkot>
or `default if (whatever)`, maybe

[10:10:41.0018] <ljharb>
having to write the underscore is gross

[10:10:55.0116] <ljharb>
and `default` has to be last - it'd be confusing to have `default if` be allowed all over the place

[10:11:17.0321] <bakkot>
hm

[10:11:19.0480] <bakkot>
not sure I agree

[10:11:34.0695] <ljharb>
having a bare `when` would be alright, but then you have `when {` and `when if (x) {` and that reads odd to me

[10:11:48.0799] <Jack Works>
> <@bakkot:matrix.org> also what's the use case for the bare `if` one

`if (isSomethingWeWant(expr)): `
an escape path when pattern is not expressive enough and you want to do a complex check

[10:11:49.0455] <bakkot>
maybe actually the thing I want is to be able to bind the name in the `match (e)` part

[10:11:53.0836] <bakkot>
`match (e as x)`, maybe

[10:11:59.0167] <ljharb>
you can, just like that. specifically so you can name the matchable when it's complex expression

[10:12:05.0957] <Tierney Cyren>
imo `default` is also nice because it's a structure that feels not dissimilar from other uses of `default` in the language

[10:12:13.0387] <ljharb>
 * you can, just like that. specifically so you can name the matchable when it's complex expression

[10:12:13.0453] <bakkot>
wait, then there should not be `when (identifier)`

[10:12:26.0142] <ljharb>
it falls out of the ability to do `when ([identifier])`

[10:12:29.0943] <bakkot>
that's just `match (e as x) default`

[10:12:34.0738] <devsnek>
what's the case for `when (unused) {}`

[10:12:40.0708] <ljharb>
an irrefutable pattern works everywhere, and not being able to use it at the top-level is an inconsistency

[10:12:45.0000] <devsnek>
not in the video call atm

[10:12:57.0656] <ljharb>
> <@devsnek:matrix.org> what's the case for `when (unused) {}`

like switch `default`, or an "else" - it's the last uber-catch-all match clause.

[10:13:04.0834] <bakkot>
not being able to mix irrefutable patterns and a default is also inconsistent

[10:13:07.0258] <bakkot>
but that's fine

[10:13:12.0651] <devsnek>
oh right

[10:13:15.0434] <devsnek>
its when not match

[10:13:16.0574] <bakkot>
I prefer the inconsistency of not allowing both `match (e as x)` and `when(x)`

[10:13:18.0525] <devsnek>
i am caught up now

[10:13:22.0012] <ljharb>
you can, with `when (foo)` as the last clause

[10:13:27.0847] <devsnek>
i think eliding makes sense

[10:13:36.0172] <devsnek>
`when {}`

[10:14:26.0259] <ljharb>
`when {` is a reasonable alternative spelling for `default {`, and that can and should be bikeshedded during stage 2

[10:14:31.0107] <Jack Works>
> <@bakkot:matrix.org> I'd just write `when (_) if (whatever)`

yeah `when(_) if (expr)` give you a temporally binding of the matched expression when it is not a simple identifier. 👀 this is an interesting case

[10:14:32.0402] <ljharb>
 * `when {` is a reasonable alternative spelling for `default {`, and that can and should be bikeshedded during stage 2

[10:15:31.0203] <bakkot>
oh god are we going to have both `Symbol.match` and `Symbol.matcher`

[10:15:35.0545] <bakkot>
`Symbol.match` was a mistake

[10:15:40.0014] <Michael Ficarra>
are these slides on the protocol new? I didn't see these

[10:15:47.0649] <ljharb>
> <@bakkot:matrix.org> `Symbol.match` was a mistake

yes it was

[10:15:50.0604] <Jack Works>
> <@bakkot:matrix.org> `match (e as x)`, maybe

we have that in previous design. we think it's useful but can also be added in the future `match (e) as x {}`

[10:15:55.0956] <ljharb>
> <@bakkot:matrix.org> oh god are we going to have both `Symbol.match` and `Symbol.matcher`

happy to bikeshed the symbol name; the overlap sucks

[10:16:31.0369] <ljharb>
> <@jackworks:matrix.org> we have that in previous design. we think it's useful but can also be added in the future `match (e) as x {}`

i think we have `match (e) as x {` in the current proposal (or maybe `match (e as x) {`, i forget which we agreed on)

[10:16:47.0244] <devsnek>
excited for us to say Symbol.matcher was a mistake in 6 years

[10:17:26.0347] <legendecas>
> <@devsnek:matrix.org> excited for us to say Symbol.matcher was a mistake in 6 years

Symbol.match

[10:17:44.0241] <bakkot>
`Symbol.decons`

[10:18:05.0120] <Michael Ficarra>
do any of the built-in prototypes implement the matcher protocol?

[10:18:17.0161] <Jack Works>
> <@bakkot:matrix.org> oh god are we going to have both `Symbol.match` and `Symbol.matcher`

😂 yeah and we cannot bikeshedding on this because people will always try `Symbol.match` whatever we named `Symbol.matcher` to

[10:18:25.0661] <bakkot>
I dislike this brand checking part more than any other part of the proposal

[10:18:27.0396] <ljharb>
> <@michaelficarra:matrix.org> do any of the built-in prototypes implement the matcher protocol?

imo many of them will, as part of this proposal

[10:18:32.0544] <ljharb>
per this slide

[10:18:43.0698] <bakkot>
these are constructors, not prototypes

[10:18:47.0850] <Michael Ficarra>
ljharb: that's on the constructor, not prototype

[10:18:56.0561] <ljharb>
oh sorry

[10:19:03.0228] <ljharb>
no, i wouldn't expect builtin prototypes to have it

[10:19:06.0955] <ljharb>
 * no, i wouldn't expect builtin prototypes to have it

[10:19:10.0941] <ljharb>
do you have something in mind?

[10:19:20.0004] <Michael Ficarra>
yeah, what if I put a regexp in there?

[10:19:28.0830] <bakkot>
I claim `and` and `or` have an obvious precedence relationship

[10:19:33.0308] <bakkot>
or at least a very well-precedented one

[10:19:37.0681] <ljharb>
ah right. yes, regexes definitely do implement it (with the same logic the literal patterns apply)

[10:19:54.0461] <Michael Ficarra>
where do I find the information on what does and what doesn't?

[10:19:55.0657] <ljharb>
> <@michaelficarra:matrix.org> yeah, what if I put a regexp in there?

 * ah right. yes, regexes definitely do implement it (with the same logic the literal patterns apply)

[10:20:03.0379] <ljharb>
in theory it's all in the readme

[10:20:17.0919] <ljharb>
during stage 2 it'll all end up in the spec

[10:20:47.0996] <Jack Works>
> <@bakkot:matrix.org> `Symbol.decons`

If we take rbuckton 's unapply proposal to replace the custom matcher

```js
const Some(x) = val

match (val) {
    when (Some(x)): x
}
```
and we first teach people this feature in the deconstructing instead of pattern matching, we can be a little confortable than let people figuring out `match` vs `matcher` which is the symbol they need🤔

[10:21:05.0428] <ljharb>
Michael Ficarra:  https://github.com/tc39/proposal-pattern-matching#regex-pattern is the literal pattern; https://github.com/tc39/proposal-pattern-matching#bindings-from-regex-patterns-with-named-capture-groups says "Regexes (both literals and references inside interpolation patterns) implement the custom matcher protocol"

[10:21:19.0874] <bakkot>
wait, are these actually _stacked_ bindings

[10:21:27.0962] <bakkot>
like if I leak one with an arrow in a `${}` does that refer to the outer one

[10:21:35.0021] <bakkot>
 * like if I leak one with an arrow in a `${}` does that refer to the outer one

[10:22:20.0884] <bakkot>
after `match ([0, 1, 2]) when `([a, ${(probe = () => a, 1)}, a]) {}`: if I call `probe`, does it see `0` or `1`

[10:22:41.0544] <Michael Ficarra>
ljharb: okay that answers the question for `RegExp.prototype`, am I to assume that no other built-in prototypes implement it?

[10:22:48.0570] <ljharb>
yes, if you have others in mind, please file an issue

[10:22:59.0365] <ljharb>
 * yes, if you have others in mind, please file an issue

[10:24:00.0479] <Jack Works>
hmm Isn't tagged template pattern are banned?

[10:24:10.0358] <Jack Works>
```js
when (tag`x`): expr
```

[10:24:16.0932] <Jack Works>
i remember this is invalid

[10:24:18.0097] <ljharb>
currently yes

[10:25:34.0074] <bakkot>
bindings should be reusable across `or` alternatives, definitely

[10:25:48.0177] <bakkot>
but that does not mean they need to be reusable not across `or` alternatives

[10:27:37.0730] <bakkot>
related: https://github.com/bakkot/proposal-duplicate-named-capturing-groups

[10:35:12.0509] <bakkot>
calling this "initial spec text" is somewhat generous

[10:35:39.0855] <Michael Ficarra>
our bar for initial spec text is historically VERY low, and I'm okay with that

[10:35:53.0699] <Michael Ficarra>
as long as the explainer is fleshed out enough, of course

[10:35:54.0357] <bakkot>
I think it is higher than this

[10:36:20.0895] <ljharb>
the process document is very not clear on this

[10:36:27.0850] <ljharb>
if there's a higher bar then it should be codified there.

[10:36:32.0813] <Jack Works>
https://github.com/tc39/proposal-pattern-matching/pull/251
NOTE: Part 1 (adding interpolation pattern back to deconstruction) is NOT a nececssary part of the proposal

[10:36:50.0398] <Michael Ficarra>
we've talked about it in plenary before and opted not to set a minimum

[10:38:19.0942] <ljharb>
waldemar: reviewing spec text isn't necessary for stage 2. it's necessary for stage 3.

[10:38:29.0114] <leobalter>
ljharb shu TabAtkins I think we can have a direction to achieve consensus for the current direction this proposal is leading towards and come back in the next meeting with the spec draft updated.

[10:38:48.0222] <leobalter>
setting the direction is not exactly a stage advancement but we can agree with the current direction, right?

[10:39:05.0459] <ljharb>
sure. and the process issue waldemar is bringing up is only really relevant if that's the only potential "blocker" for stage 2

[10:39:10.0400] <Michael Ficarra>
I oppose asking the champions to write complete spec text for this proposal before it reaches stage 2

[10:39:18.0488] <Jack Works>
 * https://github.com/tc39/proposal-pattern-matching/pull/251
NOTE: Part 1 (adding interpolation pattern back to deconstruction) is NOT a nececssary part of the proposal

[10:39:25.0738] <shu>
i don't think complete spec text is being asked for

[10:39:28.0047] <Michael Ficarra>
the explainer is detailed enough

[10:39:51.0373] <shu>
i think there's value in the exercise of writing out a grammar for a very syntax-heavy proposal

[10:40:00.0159] <shu>
the fact that it hasn't been done is a fair objection imo

[10:40:40.0486] <Michael Ficarra>
I also still have open questions about things, but they will not torpedo the proposal, so they can be figured out during stage 2

[10:41:05.0721] <Michael Ficarra>
if you think the general direction of the proposal is wrong, fair, object to advancement

[10:41:15.0589] <Michael Ficarra>
but details are meant to be figured out and codified during stage 2

[10:41:31.0169] <shu>
i also reject the notion that "initial spec text" means any text document that's published as a spec draft

[10:41:35.0067] <Jack Works>
> <@shuyuguo:matrix.org> i think there's value in the exercise of writing out a grammar for a very syntax-heavy proposal

yeah we have a spec syntax PR 😂 i think it's already covered the current shape of proposal

[10:41:57.0610] <shu>
it should've been merged for general review before the plenary, then?

[10:42:08.0861] <ljharb>
> <@shuyuguo:matrix.org> i also reject the notion that "initial spec text" means any text document that's published as a spec draft

i agree with that. i think the current text still somewhat applies - it's just the parts inside `match (…) { … }` that need lots of work

[10:42:34.0397] <Jack Works>
hax is talking about:

he think

```when (${String} with s): expr``` to check if it is a string is wordy

[10:42:34.0447] <ljharb>
maybe it doesn't feel "enough" for some, but applying vague adhoc requirements seems undesirable compared to having more specific wording in the process doc

[10:42:42.0639] <shu>
part of the pushback i'm hearing is that there's no sensible intermediate state to have an initial spec text that's not a complete grammar working out

[10:42:43.0869] <Jack Works>
 * hax is talking about:

he think

```when (${String} with s): expr``` to check if it is a string is wordy

[10:42:46.0096] <leobalter>
I think it's fair to have minimal matching specs. People can consume the proposal by the explainer, other people do it better from the specs, as waldemar pointed out. I might disagree with the heated parts, but asking for some basic specs seems pretty fair and I'd stick to that committed to present something at the next TC39 meeting.

[10:42:47.0220] <bakkot>
Jack Works: I think if your PR landed that would definitely meet the bar

[10:42:49.0908] <bakkot>
but I didn't know to look for it

[10:42:51.0471] <shu>
i also don't think that's true, but it might be in this particular case?

[10:42:59.0910] <ljharb>
> <@jackworks:matrix.org> hax is talking about:
> 
> he think
> 
> ```when (${String} with s): expr``` to check if it is a string is wordy

to check if something's a string you'd do `if (typeof x === 'string')`, no?

[10:43:21.0086] <shu>
leobalter: no, the point is that explainers are precisely *not* substitutes for specs

[10:43:40.0731] <bakkot>
`when (x) if (typeof x === 'string')` is the obvious way to write this

[10:43:46.0932] <bakkot>
(this particular thing)

[10:43:47.0627] <Jack Works>
> <@ljharb:matrix.org> to check if something's a string you'd do `if (typeof x === 'string')`, no?

oh yeah, it's another case for bare `if` 😂

[10:44:06.0431] <leobalter>
shu: I agree with that, my opinion is that both explainer and specs should have some minimal content for everyone to understand the direction for Stage 2.



[10:44:13.0210] <bakkot>
it's not a use for bare `if` because you need to refer to the match-ee

[10:44:14.0635] <leobalter>
One doesn't replace the other

[10:44:20.0443] <bakkot>
which requires you to name the thing being matched

[10:44:23.0039] <Jack Works>
> <@bakkot:matrix.org> `when (x) if (typeof x === 'string')` is the obvious way to write this

but it's more wordy than `when (${String} with x)`

[10:44:28.0359] <ljharb>
> <@bakkot:matrix.org> it's not a use for bare `if` because you need to refer to the match-ee

`when (blah) as S {` lets you refer to it

[10:44:32.0565] <bakkot>
Jack Works: but less clear

[10:44:44.0805] <bakkot>
this is a good reason to not allow the `when (${String} with x)`

[10:44:53.0374] <bakkot>
which I also want to get rid of for other reasons

[10:45:14.0567] <waldemar>
@ljharb: Process requires "all major semantics, syntax and API are covered, but TODOs, placeholders and editorial issues are expected" for entry to stage 2. Process also states that changes during stage 2 are expected to be incremental.

[10:45:16.0790] <ljharb>
`when (${String} and x)` is shorter :-p

[10:45:23.0845] <legendecas>
Can `when (${String} with x)` match String wrapper object?

[10:45:39.0588] <ljharb>
waldemar: that column describes the spec quality WITHIN stage 2, not for entering it. the only cell on the stage 2 row that applies to proposals *entering* stage 2 is "Entrance Criteria"

[10:45:46.0024] <ljharb>
 * waldemar: that column describes the spec quality WITHIN stage 2, not for entering it.

[10:46:11.0181] <legendecas>
`if (typeof x === 'string')` is very clear that it can not match string wrapper object

[10:46:23.0659] <ljharb>
 * waldemar: that column describes the spec quality WITHIN stage 2, not for entering it. the only cell on the stage 2 row that applies to proposals *entering* stage 2 is "Entrance Criteria"

[10:46:30.0165] <ljharb>
> <@legendecas:matrix.org> Can `when (${String} with x)` match String wrapper object?

yes.

[10:46:59.0344] <leobalter>
ljharb: I have to disagree. My understanding is that fundamental spec quality should also match entrance for Stage 2.

[10:47:04.0762] <Jack Works>
> <@legendecas:matrix.org> Can `when (${String} with x)` match String wrapper object?

Yes

[10:47:20.0810] <ljharb>
> <@leobalter:matrix.org> ljharb: I have to disagree. My understanding is that fundamental spec quality should also match entrance for Stage 2.

then the process document should be refined; thats not the bar i've seen previous proposals held to.

[10:47:28.0810] <waldemar>
ljharb: The entrance criteria require a spec text, and the spec quality column describes the quality of that spec text.

[10:48:23.0381] <bakkot>
yeah

[10:48:28.0023] <bakkot>
stage 3 requires complete text

[10:48:29.0241] <leobalter>
ljharb waldemar we may schedule a proper venue to discuss this. I don't think this chat will be super productive. We have to agree there is a diversity in interpretations here.

[10:48:33.0670] <bakkot>
that's not something you do during stage 3

[10:49:02.0014] <leobalter>
bakkot: I believe @waldemar is never saying complete spec text.

[10:49:22.0201] <ljharb>
i can certainly see that interpretation - that "spec quality" is an entrance criteria. but that's not how i read it, or have read it in the past, nor is it clear to me from the table.

[10:49:26.0540] <bakkot>
leobalter: sorry, I was just saying I agree with waldemar's intepretation of the "spec quality" column

[10:49:33.0185] <waldemar>
I think some are just misreading the process document.

[10:49:45.0582] <ljharb>
if that's what we all want, maybe we should add some clarification to the "entrance criteria" cell so it references the "spec quality" cell

[10:49:56.0587] <bakkot>
which is that stage 3 requires "Complete: all semantics, syntax and API are completely described", which means that stage 2 requires "Draft: all major semantics, syntax and API are covered, but TODOs, placeholders and editorial issues are expected"

[10:50:02.0355] <shu>
leo, this isn't about a diversity of interpretations, i think it's just misreading?

[10:50:06.0309] <leobalter>
waldemar: if we interpret the document differently, one has to be wrong.

[10:50:37.0175] <shu>
yes, and what bakkot said has to be correct

[10:50:49.0242] <shu>
unless we have disagreement that stage 3 can be obtained without a complete spec text, which i really hope not

[10:50:59.0238] <leobalter>
shu: I read basic specs as entrance criteria for Stage 2, not only as a expectancy for during Stage 2

[10:51:33.0848] <leobalter>
and I'd be supportive for all proposals to go through the same criteria.

[10:51:41.0759] <Michael Ficarra>
we have accepted thorough explainer docs as "spec text" for stage 2 many times in the past

[10:51:52.0460] <bakkot>
have we?

[10:52:04.0121] <shu>
and for something that is super syntax heavy?

[10:52:10.0362] <shu>
like if it's for one array method, sure

[10:52:14.0562] <shu>
with a pseudocode implementation, even

[10:52:24.0150] <ljharb>
for something this big, probably not. but for multiple things, certainly

[10:52:35.0476] <Michael Ficarra>
few proposals are as big as this one, so I don't know what your bar is

[10:53:32.0573] <shu>
i have said my bar: for syntax-heavy proposals, major syntax should be spelled out in the spec text, which it isn't currently because it's in an unmerged PR

[10:54:04.0527] <Michael Ficarra>
shu: fair, at least that gives the champions clear guidance on expectations

[10:54:04.0874] <bakkot>
array grouping had fairly complete text at stage 2: https://github.com/tc39/proposal-array-grouping/blob/6c1e6880eeb58a2f2cae3a0763c884821f730893/spec.emu

[10:54:13.0951] <bakkot>
I'm trying to think of other examples

[10:54:21.0938] <bakkot>
where there might not have been

[10:54:24.0266] <ljharb>
tbf API proposals are the easiest ones to make complete spec text for

[10:54:37.0323] <shu>
please stop with the "complete" strawperson

[10:54:43.0005] <shu>
nobody is asking for complete for entrance to stage 2

[10:54:49.0125] <ljharb>
oh i don't mean that's what's being asked for

[10:55:06.0416] <ljharb>
i'm saying that API proposals are much easier to hit even the stage *3* requirement, far earlier

[10:55:09.0808] <bakkot>
re: ysv's point, I definitely like having large proposals like this presented multiple times before we agree to the major semantics

[10:55:12.0416] <bakkot>
temporal did that IIRC

[10:55:17.0539] <bakkot>
though, maybe that was during stage 2

[10:55:37.0966] <Michael Ficarra>
yeah, that was at a later stage

[10:56:15.0403] <ptomato>
I think this is a good discussion to have, but I do want to say that to demand that Tab put the stub spec text up on the screen for it to be criticized, is both a waste of committee time, and condescending towards the champions. I think that kind of thing is not befitting of a healthy collaboration in the committee

[10:58:07.0359] <yulia>
i feel like there are benefits to both sides, but we are running into issues with the fear that -- if we don't get everything in then we will have classes again (or, maybe i misunderstood -- do you mean, this should be shown multiple times before advancement to grok all the details? with this i agree)

[10:58:24.0531] <Jack Works>
hax's meaning:

he think `if` is `else if`, and is not the necessary part of MVP

[10:58:47.0795] <yulia>
> <@bakkot:matrix.org> re: ysv's point, I definitely like having large proposals like this presented multiple times before we agree to the major semantics

 * i feel like there are benefits to both sides, but we are running into issues with the fear that -- if we don't get everything in then we will have classes again (or, maybe i misunderstood -- do you mean, this should be shown multiple times before advancement to grok all the details? with this i agree)

[10:58:48.0728] <Jack Works>
and he think `when (_) if (expr)` can replace the bare if

[10:59:05.0939] <shu>
yulia: the spicy take is that this is a committee, we're not going to get cohesive big ideas through

[10:59:25.0415] <yulia>
as you know, i am a fan of process ;)

[10:59:37.0077] <shu>
we're going to get things that hopefully aren't too far off course from what any individual delegate's cohesive big idea is

[10:59:45.0891] <ljharb>
> <@jackworks:matrix.org> and he think `when (_) if (expr)` can replace the bare if

it totally can. it's just that then you're forcing people to type that extra boilerplate when they don't conceptually need it

[10:59:53.0239] <Jack Works>
OK my last concern for short:

[11:00:09.0701] <Jack Works>
I prefer an alternative syntax for the custom matcher.

Current:

```js
when (${Some} with x): expr
when (${None}): expr
```

rbuckton 's unapply
```js
when (Some(x)): expr
when (None()): expr
// also works in deconstruction
const RGB(r, g, b) = "#001234"
```

[11:00:15.0020] <yulia>
> <@shuyuguo:matrix.org> we're going to get things that hopefully aren't too far off course from what any individual delegate's cohesive big idea is

so, my thinking is -- we could do what class fields did, which is that it had several proposals that eventually were merged

[11:00:24.0374] <bakkot>
> or, maybe i misunderstood -- do you mean, this should be shown multiple times before advancement to grok all the details? with this i agree

that is the thing I mean, yes

[11:00:29.0421] <yulia>
but do this more intentionally

[11:00:44.0186] <bakkot>
I don't have a problem with large proposals if they are presented a few times, so we have time to think about the whole thing

[11:00:51.0587] <bakkot>
and talk about all the details

[11:01:07.0014] <shu>
yulia: that might work, sure. the biggest hurdle i think is to get enough of committee continuity, well beyond just the champion group, to have the whole space be paged in

[11:01:13.0447] <yulia>
yeah also, splitting it up is just a mechanism for doing precisely that -- but splitting it up also makes parts of it optional which may not be optional (so, why not introduce a construct for that)

[11:01:18.0660] <sarahghp>
yes, I agree with yulia; or rather, I could live with an epic-type approach

[11:01:19.0347] <Michael Ficarra>
pattern matching and decorators as our first 2 proposal topics? time constraints must've been rough this time around

[11:01:33.0871] <sarahghp>
though I would still rather my own weird simple + wacky breakdown :D

[11:01:36.0410] <Jack Works>
> <@michaelficarra:matrix.org> pattern matching and decorators as our first 2 proposal topics? time constraints must've been rough this time around

decorator is for stage 3

[11:01:42.0668] <yulia>
 * yeah also, splitting it up is just a mechanism for doing precisely that -- but splitting it up also makes parts of it optional which may not be optional (so, why not introduce a construct for that)

[11:01:49.0967] <bakkot>
TabAtkins: just to say, because everyone including me was talking about their concerns (which is reasonable), I think pattern matching as presented is pretty rad

[11:01:57.0656] <Michael Ficarra>
Jack Works: decorators is 9th in order on the agenda though lol

[11:02:04.0871] <bakkot>
I have quibbles with details but do support the proposal

[11:02:56.0321] <Jack Works>
I support the current decorator proposal, but the metadata part is sus and need more discussion

[11:03:05.0457] <shu>
yulia: because at the end of the day, as people have said before, we're mostly volunteering our time here, and the biggest problem is unless we're in the champion group, people are paging in a lot of stuff at possibly multi-month intervals. and unless you're already super sold on the motivation, that kind of working mode is going to prime you against large proposals

[11:03:13.0630] <yulia>
> <@jackworks:matrix.org> I support the current decorator proposal, but the metadata part is sus and need more discussion

same, also some concerns about the accessor keyword

[11:03:22.0165] <shu>
how would "epics" help this? genuinely asking, no idea what those are

[11:03:38.0030] <TabAtkins>
> <@bakkot:matrix.org> also what's the use case for the bare `if` one

I'ts a minor case, but sometimes when figuring out how to produce a given value, you in fact don't need to worry about the structure of the matchable.

[11:04:13.0656] <Jack Works>
> <@yulia:mozilla.org> same, also some concerns about the accessor keyword

they say the `accessor` keyword is necessary and not blocking the future extension of the Grouping accessor proposal so I guess it is ok for me

[11:04:17.0909] <bakkot>
TabAtkins: that use case doesn't seem worth its own syntactic form, I guess is my feeling

[11:04:26.0397] <yulia>
> <@shuyuguo:matrix.org> how would "epics" help this? genuinely asking, no idea what those are

often, when something like temporal has been presented i found myself checking out because i didn't have focus for the whole proposal. if we had a process that was like. Here is the big proposal and what it is trying to do, and it is composed of these parts. we are talking about part 1, which has it's own design concerns -- i would find this easier to think about

[11:04:28.0117] <bakkot>
 * TabAtkins: that use case doesn't seem worth its own syntactic form, I guess is my feeling

[11:04:32.0605] <TabAtkins>
If it required more than just "don't put the when()" in, I'd agree.

[11:04:50.0037] <shu>
yulia: okay i see. i support that

[11:05:07.0463] <yulia>
> <@jackworks:matrix.org> they say the `accessor` keyword is necessary and not blocking the future extension of the Grouping accessor proposal so I guess it is ok for me

yeah we were looking into the requirements there, we will have a discussion with that. I think Iain may have posted an issue (lemme check)

[11:05:09.0539] <TabAtkins>
But requiring `when (_) if(something)` is awkward when the shorter syntax form is *right there* and totally unambiguous

[11:05:21.0332] <bakkot>
that's fair

[11:05:25.0102] <ryzokuken>
> <@yulia:mozilla.org> often, when something like temporal has been presented i found myself checking out because i didn't have focus for the whole proposal. if we had a process that was like. Here is the big proposal and what it is trying to do, and it is composed of these parts. we are talking about part 1, which has it's own design concerns -- i would find this easier to think about

I think such a process change would be really useful, thanks

[11:05:38.0397] <shu>
(so what's the "epic" part referring to?)

[11:05:52.0799] <yulia>
the epic is the overall feature (like pattern matching)

[11:06:00.0061] <bakkot>
"this is useful for dependency injection" produces in me an immediate "kill it with fire" reaction

[11:06:05.0928] <bakkot>
perhaps that is not everyone's reaction to dependency injection

[11:06:26.0470] <yulia>
we can say that, when a proposal is large and consists of many components, but they cannot be broken up without compromising the goal of the proposal, it should be treated as an epic (or maybe we can call it a modular proposal or whatever)

[11:06:26.0893] <ljharb>
it's certainly my reaction too

[11:06:31.0365] <shu>
it usually is, but my first reaction is always "what is dependency injection again"

[11:06:32.0374] <ljharb>
 * it's certainly my reaction too

[11:06:40.0942] <ljharb>
function arguments, but implicit and magic

[11:06:41.0336] <shu>
and when i re-learn it as argument passing, then your reaction is my following one

[11:06:50.0173] <TabAtkins>
> <@ljharb:matrix.org> i think we have `match (e) as x {` in the current proposal (or maybe `match (e as x) {`, i forget which we agreed on)

Nah we dropped the `as x` stuff entirely, in favor of using `x and ...` matchers.

[11:07:51.0721] <bakkot>
TabAtkins: ok so my feeling is that it would be very useful to bind the name at the top level of the match, because otherwise there's going to be a bunch of `match (expr) when (x) if (f(x)) ...; when (x) if (g(x)) ...;` etc

[11:08:14.0774] <bakkot>
 * TabAtkins: ok so my feeling is that it would be very useful to bind the name at the top level of the match, because otherwise there's going to be a bunch of `match (expr) when (x) if (f(x)) ...; when (x) if (g(x)) ...;` etc

[11:08:34.0554] <bakkot>
maybe do-exprs are the fix for that though

[11:08:42.0390] <TabAtkins>
> <@bakkot:matrix.org> I claim `and` and `or` have an obvious precedence relationship

I know the &&/|| precedence is *well-established*, I strongly object that it's *obvious*; I've been programming for 20 years and I still always parenthesize when I'm mixing those, because I never remember what the precedence is.

[11:08:43.0654] <bakkot>
`do { let x = expr; match(x) {...} }`

[11:08:54.0562] <Jack Works>
so for the decorator, I guess the `metadata` part will be the hardest push at this meeting, maybe they will seek a conditional advancement (once the metadata problem is resolved, it will automatically advance to stage 3)?

[11:09:00.0779] <bakkot>
TabAtkins: that's fair but I stand by "well precedented"

[11:09:03.0385] <iain>
yulia: Reading through old issues I found this, which convinced me that there are good reasons for `accessor` to exist as a keyword (instead of making decorated fields into accessors by default): https://github.com/tc39/proposal-decorators/issues/348#issuecomment-736889352

[11:09:13.0951] <bakkot>
people who don't know the relationship are already going to be struggling with the `&&` and `||` cases

[11:09:22.0475] <bakkot>
people who do are going to be annoyed every single time they use `and` with `or`

[11:09:32.0307] <ljharb>
which is why common linter rules/styleguides force parens around mixed && and ||, because it's so frequently confusing

[11:09:37.0897] <ljharb>
 * which is why common linter rules/styleguides force parens around mixed && and ||, because it's so frequently confusing

[11:09:44.0990] <yulia>
> <@iain:mozilla.org> yulia: Reading through old issues I found this, which convinced me that there are good reasons for `accessor` to exist as a keyword (instead of making decorated fields into accessors by default): https://github.com/tc39/proposal-decorators/issues/348#issuecomment-736889352

oh, great! thanks -- that comment is retracted then

[11:09:51.0471] <yulia>
i was just going to ask

