2022-03-01
[14:22:36.0271] <mgaudet>
Hey; I've got [a bug](https://bugzilla.mozilla.org/show_bug.cgi?id=1757162) which essentially boils down to this little test case

```
class A {
    #x = "hello";
    constructor(o = this.#x) {
        this.value = o;
    }
};

var a = new A;
// Does new A throw? if not, does a.value have the value of `hello`?
```


[14:22:48.0705] <mgaudet>
I'm trying to figure out what the spec says and got a little confused

[14:24:02.0915] <mgaudet>
https://tc39.es/ecma262/#sec-evaluatenew says that ArgumentListEvaluation happens before the constructor is invoked; but AFAICT it's the constructor that actually allocates the object... 

[14:24:35.0604] <mgaudet>
does ArgumentListEvaluation not actually... evaluate the arguments? ie, is the processing of the default argument deferred until later? 

[14:31:39.0687] <bakkot>
`ArgumentListEvaluation` evaluates _the arguments_, not the parameters

[14:32:16.0995] <bakkot>
it's the thing which would trigger the `console.log` in `f(console.log(0));`, not the thing which would trigger the `console.log` in `function f(x = console.log(0)) {}; f()`

[14:32:59.0899] <mgaudet>
yeah; I think I've got the latter traced down further into https://tc39.es/ecma262/#sec-functiondeclarationinstantiation 

[14:33:32.0804] <mgaudet>
(which seems to imply that the answer is that private fields ought to be available in that parameter expression) 

[14:33:55.0892] <mgaudet>
(I always get bit when coming back to arguments/formals/parameters) 

[14:36:38.0597] <bakkot>
yeah

[14:37:36.0990] <bakkot>
specifically, for base classes, class fields are created/installed by [[construct]] step 6.b: https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ecmascript-function-objects-construct-argumentslist-newtarget

[14:38:04.0399] <bakkot>
 * specifically, for base classes, class fields are created/installed by [[construct]] step 6.b: https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ecmascript-function-objects-construct-argumentslist-newtarget

[14:39:12.0103] <bakkot>
and parameter defaults (and other expressions) are evaluated later, in [[construct]] step 8, via OrdinaryCallEvaluateBody -> EvaluateBody -> EvaluateFunctionBody -> FunctionDeclarationInstantiation -> IteratorBindingInitialization

[14:40:11.0699] <bakkot>
so private fields (and all other fields) are available (for base classes) by the time the parameter list is evaluated

[14:40:28.0166] <mgaudet>
Yep :) Was writing that out... less nicely than you in the bug :P 


2022-03-02
[12:11:07.0493] <bakkot>
the snippet of code for getting the time is wrong on the agenda; can someone fix it? https://github.com/tc39/agendas/blob/main/2022/03.md

[12:11:33.0045] <bakkot>
I can do it if I remember next time I have an opportunity

[12:12:01.0489] <bakkot>
(it has the wrong date)


2022-03-03
[16:06:48.0051] <ljharb>
done


2022-03-07
[10:13:38.0587] <jschoi>
A friendly reminder to delegates that thereâ€™s an incubator meeting about `Function` helper functions tomorrow! Hope to see you there. https://github.com/tc39/incubator-agendas/blob/master/2022/03-08.md


2022-03-08
[08:03:53.0082] <shu>
ljharb: incubator call?

[08:05:00.0615] <ljharb>
Iâ€™ll be a few late, but Iâ€™m coming

[08:25:12.0906] <ljharb>
jschoi: "demethodize" is pretty gross imo, ftr :-p

[09:01:10.0789] <shu>
it sounds like a surgical procedure

[11:51:46.0153] <ljharb>
so, we have `x?.(y)`, where it doesn't call `x` unless `x` is non-nullish; is there no simple way to do `x(y)` when _y_ is non-nullish? (obv i can do `y == null ? y : x(y)` but that means i have to repeat the `y` expression more than once, or store it in a var)

[12:01:17.0935] <Ashley Claymore>
sounds like you want optional pipeline ðŸ˜‰

[12:01:34.0057] <Ashley Claymore>
 * sounds like you want optional pipeline ðŸ˜‰

[12:02:10.0572] <Ashley Claymore>
`y ?> x(<sigil>)`

[12:02:26.0534] <bakkot>
optional pipeline :(

[12:02:49.0120] <bakkot>
we could just have do-notation, like a real language

[12:03:07.0046] <Ashley Claymore>
ðŸ”¥

[12:04:40.0003] <shu>
real languages are statement based, only acceptable expressions are immediates and registers and addresses

[12:04:46.0945] <shu>
and immediates can't be too big

[12:04:52.0405] <shu>
and it'll be an awkward number of bits, like 21

[12:06:00.0164] <Ashley Claymore>
all logic is ternary. true/false/unknown 

[12:11:13.0038] <jschoi>
> <@aclaymore:matrix.org> sounds like you want optional pipeline ðŸ˜‰

Thereâ€™s going to be a bikeshed around whether to use falsey or nullish for optional pipes. ðŸ¤” 

[12:12:08.0125] <bakkot>
nullish is the only reasonable choice for optional pipes

[12:12:11.0812] <bakkot>
also I don't want optional pipes

[12:12:17.0408] <bakkot>
but it's the only reasonable choice if we have to have them

[12:22:57.0854] <jschoi>
> <@aclaymore:matrix.org> all logic is ternary. true/false/unknown 

Also, we both have null and undefined. We can go further. https://www.computer.org/csdl/proceedings-article/glsv/1991/00143992/12OmNzzxusf

Quaternary logic. We have the technology. Do we have the courage? [joke]

[12:23:35.0286] <jschoi>
* > <@aclaymore:matrix.org> all logic is ternary. true/false/unknown 

Also, we have null and undefined. We can go further. https://www.computer.org/csdl/proceedings-article/glsv/1991/00143992/12OmNzzxusf

Quaternary logic. We have the technology. Do we have the courage?

[12:24:22.0159] <jschoi>
* > <@aclaymore:matrix.org> all logic is ternary. true/false/unknown 

Also, we both have null and undefined. We can go further. https://www.computer.org/csdl/proceedings-article/glsv/1991/00143992/12OmNzzxusf

Quaternary logic. We have the technology. Do we have the courage? [joke]

[12:30:58.0308] <bakkot>
we have gone further

[12:31:07.0359] <bakkot>
we have an infinite number of `document.all`s available to us

[12:31:18.0811] <bakkot>
for as many non-null/undef nullish values as you want

[12:46:45.0073] <TabAtkins>
> <@jschoi:matrix.org> Thereâ€™s going to be a bikeshed around whether to use falsey or nullish for optional pipes. ðŸ¤”

? It would use the same rules as optional-call and ??; anything else would be a profound mistake.

[13:59:53.0261] <jschoi>
Yeah, I had thought there would be some disagreement on this, but it looks like everyone (including me) agrees with nullishness.

[14:46:24.0173] <TabAtkins>
I don't think it's *particularly* that everyone agrees on nullishness (tho maybe people do), it's just that it's extremely clear that all the things doing optionality with the same syntax pattern need to act the same.

