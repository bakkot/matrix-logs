2025-11-03
[14:27:20.0064] <bakkot>
nicolo-ribaudo: re https://bugzilla.mozilla.org/show_bug.cgi?id=1950211, the "Don't call well-known Symbol methods for RegExp on primitive values", I'm having trouble inferring the status from the bug tracker. Did FF ship? Or just ship telemetry? And is there telemetry?

[14:27:40.0138] <bakkot>
Looks like V8 implemented without a flag and will just ship it whenever main makes it up to stable for them

[14:27:52.0235] <bakkot>
same in webkit

[14:28:01.0474] <bakkot>
not sure if this means we should land the PR or wait for FF

[14:34:14.0067] <nicolo-ribaudo>
I don't remember, I'll get an answer in the next days

[15:20:58.0959] <nicolo-ribaudo>
* I don't remember, I'll get you an answer in the next days


2025-11-04
[06:38:54.0687] <dminor>
It looks like we just shipped the telemetry. I think at this point if webkit and v8 are shipping, we should just remove the telemetry and ship the change.
nicolo-ribaudo do you want to make the updates, or would you like me to take it over?

[06:44:47.0645] <bakkot>
I don't know if either of the other browsers are shipping to stable, to be clear

[06:47:08.0460] <nicolo-ribaudo>
> <@dminor:mozilla.org> It looks like we just shipped the telemetry. I think at this point if webkit and v8 are shipping, we should just remove the telemetry and ship the change.
> nicolo-ribaudo do you want to make the updates, or would you like me to take it over?

Mh yeah it looks like I ended up not finishing that patch because somebody was refactoring the same code at the same time üòÖ

I am not able to type for a few weeks, please go ahead :) I'd be curious to see the telemetry data we have so far

[07:12:02.0835] <dminor>
bakkot: do you have links handy for the webkit and v8 changes? It would be helpful for coordinating shipping.

[07:13:36.0272] <bakkot>
Linked from the ecma262 issue iirc, I can dig them up when I'm at a computer next

[07:13:49.0298] <bakkot>
Or the pr rather 

[07:16:42.0512] <dminor>
Got them, thanks!

[09:02:09.0545] <guybedford>
There's an interesting discussion here on native error objects in Wasm - https://github.com/WebAssembly/custom-descriptors/issues/80.

The driving motivation is Wasm GC objects being used as throwable errors, by being able to somehow relate the Wasm GC error object's descriptor to make it a real error object. This discussion comes under the proposal umbrella of turning "opaque" GC objects into real objects with descriptors.

In particular the `Symbol.underlyingError` could be interesting to get feedback for from a TC39 perspective.

[09:10:06.0769] <Michael Ficarra>
@guybedford:matrix.org There's still time to add discussion items to the agenda for the next TC39 meeting.

[09:10:51.0781] <guybedford>
I'm not personally involved in the above discussion, I'm posting here in the hopes more folks can take these discussions on!

[09:15:56.0262] <Michael Ficarra>
my reading of this is that it would only affect debugger behaviour, which 262 does not constrain

[09:16:38.0684] <bakkot>
It is an interesting question how hosts should expose their own well known symbols though

[09:18:03.0749] <Michael Ficarra>
TG4 probably has a lot of the interested parties. This person may want to make a presentation to them. Not sure what TC39 could do about it though.

[10:57:20.0741] <guybedford>
The root problem is basically subclassing Error for Wasm GC objects, which is currently off the table as something in Wasm explicitly.

[10:57:39.0297] <guybedford>
so if non-Error objects might be able to define a symbol or otherwise to get error-level treatment

[11:37:31.0123] <Mathieu Hofman>
Haven't read the thread yet, but why not create an Error at the wasm boundary, with a `cause` being the wasm opaque object ?

[14:27:17.0261] <bakkot>
Wasm GC objects can be passed around to and from JS FFIs. Is the idea that you'd wrap every FFI call which involved a Wasm GC object to inspect the object and determine if you should substitute a wrapper?

[14:27:26.0678] <bakkot>
I think that would work but it's probably prohibitively expensive

[14:27:37.0964] <bakkot>
(possibly I am not understanding the suggestion)


2025-11-05
[18:00:52.0180] <Mathieu Hofman>
are wasm opaque objects exposed directly to JS code? My impression was that there is currently glue code to wrap those. Now of course we could ask the question for when wasm objects are no longer opaque and gain prototypes, and possibly own props. My concern is that I don't want to introduce yet another "kind" of Error that all error aware code out there needs to recognize (not just debuggers). We have Error instances, and I guess we're also getting objects extended with `Error.captureStackTrace`.

[18:03:20.0600] <Mathieu Hofman>
especially now that we have `Error.isError`, I think it'd be a mistake to introduce something that isn't an error but behaves like one. It's already unfortunate enough we have to standardize captureStackTrace

[18:19:01.0275] <guybedford>
Mathieu Hofman: the wasm custom descriptors proposal turns the opaque objects directly into objects with descriptors allowing getters and setters etc.

[18:19:34.0448] <guybedford>
they thus effectively become resource types, backed by a wasm gc managed struct or array

[18:23:15.0327] <guybedford>
I'd have thought the solution though would be to call out to `wrapErr(scalaErr) => Object.assign(new Error(), { gcError: scalaErr })` through to JS when there is an error to have a JS error type wrapping a scala error type instead of the converse, but I haven't thought about it deeply enough to have a strong opinion

[18:32:22.0332] <Mathieu Hofman>
Right, even with custom descriptors support, this is effectively purpose built glue code creating JS objects to expose wasm things. In that case, I would find it natural to create a `new Error()` and define on it a `cause: wasmThrowable` property.


2025-11-10
[11:47:37.0414] <rbuckton>
Would it be possible to get some folks from the runtimes that have implemented Explicit Resource Management to help finish the reviews on the remaining Test262 PRs? I've been trying to get some eyes on these three PRs for a few months, but the Test262 maintainers seem to be spread very thin:
- https://github.com/tc39/test262/pull/4482
- https://github.com/tc39/test262/pull/4480
- https://github.com/tc39/test262/pull/4478



2025-11-11
[18:41:01.0566] <bakkot>
nicolo-ribaudo: thanks for putting together slides for the export-\*-as PR. while we're here, I noticed in https://tc39.es/ecma262/multipage/ecmascript-language-scripts-and-modules.html#sec-resolveexport step 9.e.iii.1 that it says "Assert: There is more than one \* import that includes the requested name". That should be "\* _export_", surely, yes?

[19:16:06.0464] <nicolo-ribaudo>
Yep you are right

[19:57:03.0310] <arai>
I'm testing on SpiderMonkey.  there's some issue with the expectation around how "asyncTest" should interact with "negative".  not yet sure if it's on our side or in the test side

[19:58:41.0470] <arai>
also there are 3 tests that expects behavior before https://github.com/rbuckton/ecma262/pull/14 , for using in switch

[20:03:05.0224] <bakkot>
ljharb: I am confused by https://github.com/tc39/agendas/commit/61962210dd2547d194eae2bb9cdf8669421a4f98; when did this get stage 2.7 and where are the tests for it?

[20:04:18.0749] <rbuckton>
Thanks, I'll take a look tomorrow

[20:21:14.0703] <arai>
added comments to the PRs

[20:23:09.0662] <ljharb>
Oh you‚Äôre right, my bad. I‚Äôll revert that commit. It‚Äôs 2 and I‚Äôm going for 2.7

[20:24:08.0211] <ljharb>
not sure why i got confused there

[09:58:59.0418] <Ashley Claymore>
If anyone wanted to ask questions about Composites ahead of plenary I'll be dialed into the legacy "R&T Monthly" zoom call on the [TC39 events calendar](https://github.com/tc39/Reflector/issues/290) that starts in one hour from now (19:00 UTC)

[14:28:37.0062] <rbuckton>
Thanks. These should all be addressed now


2025-11-12
[01:20:39.0089] <nicolo-ribaudo>
ljharb It was MF from my laptop :)


2025-11-16
[17:49:16.0609] <Chris de Almeida>
draft schedule is up!  see Reflector issue for link:  https://github.com/tc39/Reflector/issues/564

[17:56:23.0320] <nicolo-ribaudo>
Day 1 afternoon there are a bunch of stage 4 advancements and my low priority topic. I wonder if we could squeeze some time off the advancements (that tend to be very quick), and replace my low priority topic with a different 30 min one?

I'm very happy to present, but I'm feeling a bit like I'm wasting time by presenting it when there are things currently scheduled to overflow üòÖ

[18:04:26.0957] <Chris de Almeida>
sounds like you are volunteering to move your topic to the bottom of schedule priority.  we can certainly do that 

[18:04:46.0391] <nicolo-ribaudo>
Well it was already marked as low priority in the agenda

[18:04:53.0948] <nicolo-ribaudo>
I mean the one about other module stuff on the web

[18:05:12.0855] <nicolo-ribaudo>
Which is just an informative topic, not something for our specs

[21:48:54.0041] <Christian Ulbrich>
Is https://tcq.app working for anyone? It seems to be _broken on my side of the internet_ 

[21:51:06.0919] <Chris de Almeida>
internal server error  üò≠

[21:56:30.0700] <Chris de Almeida>
`/summon` bterlson 

[22:18:04.0512] <Christian Ulbrich>
Chris de Almeida: Didn't know you were here in person. :)

[22:29:50.0706] <nicolo-ribaudo>
Can we try with the V2 this time? üòÖ

[22:37:50.0011] <Chris de Almeida>
we just might!  Christian and I are trying to reproduce the bugs we found from using it last time and we can't reproduce...  

[23:49:04.0085] <Rob Palmer>
Brian is also debugging TCQ: Legendary Edition

[23:54:24.0546] <Christian Ulbrich>
Rob Palmer: If you could get him, to give away the stats of his setup (VM cpu cores, ram size), I could reproduce this at least as an approximation. I very very highly assume, that there are various race conditions in his original code (that TCQ reloaded, simply re-uses) - having an environment that is more close to his original, might "solve" the currently reported bugs for TCQ reloaded, which we could not reproduce now.

[02:41:38.0295] <Rob Palmer>
It's hosted on app service D1 plan, 1GB ram, some slice of a vcpu not sure if multicore


2025-11-17
[23:41:50.0160] <Christian Ulbrich>
Rob Palmer: <del>I quadrupled</del> (always wanted use that word) QUAD DAMAGE  the resources for https://staging.tcq-reloaded.com and after some small tests, I will deploy prod too this evening (during the Karaoke night, when I know you are not needing TCQ :D).

[00:50:06.0889] <Justin Ridgewell>
Ashley Claymore: https://github.com/tc39/proposal-string-dedent/issues/75

[13:16:31.0949] <shu>
> Now of course we could ask the question for when wasm objects are no longer opaque and gain prototypes
that would be with https://github.com/WebAssembly/custom-descriptors

[15:27:20.0905] <bakkot>
Chris de Almeida: I am on the agenda as the last slot for today; per my schedule constraints I can't be present after 1600 (ideally 1500). could I be moved to a later day?

[15:27:32.0393] <bakkot>
if not it's not an urgent item and can get removed

[15:28:35.0360] <nicolo-ribaudo>
If you want we can swap our slots

[15:29:08.0745] <nicolo-ribaudo>
(the export defer one)

[15:30:10.0253] <bakkot>
I'm hoping a later day works anyway because I am sick today and may not be up to presenting that item today


2025-11-18
[16:47:36.0895] <snek>
is tcq still dead?

[16:47:58.0216] <snek>
i guess the website is still intermittent 

[16:49:22.0385] <snek>
ah i see a link was posted mere moments ago

[17:00:59.0720] <bakkot>
meeting is starting, for anyone else who is remote and not paying enough attention to the clock

[17:02:13.0249] <ptomato>
I must be blind, but I can't find the google form to get the video chat link?

[17:02:38.0885] <ryzokuken>
https://github.com/tc39/Reflector/issues/564

[17:03:03.0170] <nicolo-ribaudo>
You are the second person asking, we should make it more visible in the issue 

[17:03:06.0529] <bakkot>
it is under the "Video Conference" heading

[17:03:11.0683] <bakkot>
in said thread

[17:04:00.0376] <rkirsling>
woot woot another japan meeting begins

[17:04:43.0570] <Michael Ficarra>
break at 10:00?

[17:06:30.0628] <rkirsling>
who doesn't love starting with a break

[17:22:15.0555] <Chris de Almeida>
sorry about that, I will fix

[17:23:11.0808] <Chris de Almeida>
TCQ is buggy af.. I am struggling

[17:23:51.0431] <Chris de Almeida>
1. move agenda topic
2. wait
3. reload page
4. hope the item is where it's supposed to be
5. GOTO 1

[17:29:16.0764] <Michael Ficarra>
lol `[[IsLockFree1]]` would be a little silly

[17:29:40.0335] <Justin Ridgewell>
What was the change in the copyright?

[17:29:57.0062] <Justin Ridgewell>
Comparing 262‚Äôs and 426‚Äôs copyright text, it looks the same.

[17:30:00.0940] <Michael Ficarra>
the copyright notice was just some random copyright text that we have no idea where it came from

[17:30:04.0573] <ryzokuken>
we hadn't used the alternate copyright for either standard

[17:30:20.0025] <Michael Ficarra>
@justingrant:matrix.org are you comparing the yearly releases or the editors' drafts?

[17:30:39.0391] <Michael Ficarra>
we've already updated the editors' drafts

[17:30:51.0542] <nicolo-ribaudo>
Shhhh we are dealing with it, Aki noticed one second after saying yes

[17:30:55.0423] <jkup>
426 is also incorrect 

[17:31:00.0478] <Justin Ridgewell>
Comparing the published specs

[17:31:07.0701] <Justin Ridgewell>
@nicol

[17:31:16.0808] <Justin Ridgewell>
* @nicolo-ribaudo:matrix.org just said it was already correct

[17:31:56.0662] <Aki>
https://github.com/tc39/agendas/blob/main/2025/tc39-2025-049-Rev1.pdf

[17:31:59.0106] <Aki>
I was wrong

[17:32:02.0648] <Aki>
it's is wrong

[17:33:00.0886] <Rob Palmer>
You are welcome to prepare another vote.  I think we could get through it very quickly.

[17:33:03.0964] <Aki>
that's the wrong link

[17:33:09.0547] <Aki>
https://github.com/tc39/ecma426/pull/237

[17:33:57.0452] <rkirsling>
if my work focus hadn't changed, I would be likely interested in editor group :-/ (but then timezones would also be messy)

[17:35:44.0764] <bakkot>
https://github.com/tc39/ecma262/pull/3701

[17:35:51.0752] <Justin Ridgewell>
Diff:

[17:39:10.0485] <nicolo-ribaudo>
It would be a very uncontroversial vote, but given it's not urgent maybe we should wait until next time? I assume the same things I said about stage advancement materials also apply to votes materials

[17:39:46.0810] <nicolo-ribaudo>
(I would be happy to "vote" yes now though)

[17:40:28.0128] <Aki>
I actually just turned the PR to a draft bc I want Samina's eyes on it before I change anything formal.

[17:42:06.0436] <Ashley Claymore>
`[[IsLockFreeToo]]`

[17:56:00.0761] <danielrosenwasser>
Is this only an error if a named export is requested, or if the module in question is imported?

[17:56:30.0647] <danielrosenwasser>
* Is this only an error if there's an ambiguous named import, or if the module in question imports two conflicting bindings?

[17:56:43.0969] <bakkot>
only if you actually request the name

[17:56:57.0196] <rkirsling>
ruh roh engine262

[17:56:58.0239] <danielrosenwasser>
This is actually news to me

[17:57:37.0446] <bakkot>
ambiguous exports like this are actually stripped from namespace exports, which is fun too

[17:58:44.0108] <bakkot>
ljharb: note the `export * from` in `//library`

[17:58:50.0003] <bakkot>
it is exporting all bindings from both left and right

[17:58:58.0238] <bakkot>
but both of those export a `ns` binding

[18:00:31.0556] <Ashley Claymore>
I'm pleased we at least chose to drop clashing export * rather than something more fun like "first one wins"

[18:01:56.0656] <eemeli>
Do I understand right that we have yet another concept of equality defined by multi-path-importability?

[18:02:48.0444] <bakkot>
sort of! but it applies only to bindings, not to values

[18:04:12.0601] <eemeli>
So like, _really_ equal.

[18:04:13.0894] <nicolo-ribaudo>
What if it exported a live array of all the values

[18:05:20.0888] <Andreu Botella (üïë JST, at TC39)>
cue adding quadruple equals to the language for stage 1

[18:05:39.0199] <eemeli>
Hey, you said it, I only thought about it.

[18:08:14.0706] <ljharb>
there's lots of equality symbols we could add! `‚âÖ ‚âå ‚âî` etc

[18:09:13.0958] <rkirsling>
puttin' the https://en.wikipedia.org/wiki/J_(programming_language) in JS

[18:09:22.0476] <Andreu Botella (üïë JST, at TC39)>
hamburger operator

[18:09:28.0368] <Andreu Botella (üïë JST, at TC39)>
oh, forgot this wasn't the temporal dead zone

[18:09:38.0086] <ljharb>
‚ò∞ ftw

[18:09:49.0156] <ljharb>
* ‚ò∞ ftw (i have that one on autocomplete)

[18:09:51.0792] <rkirsling>
oh wait J is APL-like but ASCII

[18:09:56.0686] <rkirsling>
RIP my joke

[18:09:59.0576] <ljharb>
* ‚ò∞ ftw (i have that one on autocomplete, i'm incapable of typing the name of that sandwich now)

[18:12:59.0565] <Chris de Almeida>
it's do be like the sometimes

[18:13:11.0818] <Chris de Almeida>
* it's do be like that sometimes

[18:13:19.0567] <James M Snell>
Unicode U+2630 ... so close ... if only it had been U+2620

[18:13:27.0388] <bakkot>
is the thing being described here fuzzing or something else?

[18:14:20.0050] <bakkot>
I guess it's not quite fuzzing in that there is no randomness?

[18:14:24.0385] <nicolo-ribaudo>
If I understand correctly it's doing all possible combinations of some things, deterministically 

[18:15:46.0672] <Richard Gibson>
are you really into the I Ching?

[18:16:31.0077] <ljharb>
lol nah it's the trendy menu icon on mobile apps before it was a grid of 9 squares

[18:18:19.0600] <bakkot>
we are very efficient this morning

[18:19:31.0751] <Richard Gibson>
right, I would describe it as a kind of metamorphic testing

[18:21:32.0520] <ptomato>
agreed, not fuzzing, though related I guess?

[18:27:18.0242] <bakkot>
return override does not add internal slots

[18:27:25.0690] <bakkot>
and cannot be used to add internal slots

[18:27:34.0745] <bakkot>
it can be used to add private fields, but those are slightly different

[18:28:36.0356] <bakkot>
all objects are created with an internal slot which stores a list of their private fields; that list is what gets updated when fields are added to an object, rather than the object itself getting a new slot

[18:30:25.0421] <Michael Ficarra>
thank you, I was trying to look through the spec to confirm that claim

[18:34:15.0293] <Michael Ficarra>
I think it's just editorial though and we would just stick the slot on every object in MakeBasicObject

[18:34:47.0525] <Michael Ficarra>
we wouldn't do a new thing (adding an internal slot to an object after its creation) unless we really had to

[18:43:09.0578] <Jake Archibald>
The title of this is incorrect on https://github.com/tc39/agendas/blob/main/2025/11.md "Into Locale Info API for Stage 4" - it made it hard for me to find

[18:43:52.0849] <Jake Archibald>
https://github.com/tc39/agendas/pull/2011

[18:46:09.0397] <rkirsling>
Frank's art is very intimidating

[18:46:17.0646] <rkirsling>
* Frank's art is very intimidating :D

[18:50:28.0516] <Christian Ulbrich>
Clearly van gogh.

[18:51:41.0162] <Mathieu Hofman>
Just reviewing the note, the transcription today is missing quite a bit.

[18:52:03.0166] <jkup>
Does it require a point of order or is it ok now?

[18:53:33.0449] <Mathieu Hofman>
I'm not paying close attention  enough, was just reviewing what I had said

[18:55:21.0517] <rkirsling>
tfw _too_ efficient

[19:38:24.0837] <Chris de Almeida>
we are making good time thus far and have already been able to move some overflow topics into the schedule

consequently, topics have been shuffled around quite a bit, so please consult for the latest information

[20:13:09.0081] <Aki>
I have been wondering what the use case is here

[20:14:59.0575] <Richard Gibson>
for `maximumFractionDigits`?

[20:17:53.0171] <Mathieu Hofman>
Not plenary related. Is there a way we could set proposal repos so that any tc39 member could create and push to branches (and probably branch protection to only allow direct push to main for champions). Would really love to avoid forking for simple contributions.

[20:19:04.0647] <Aki>
no sorry I think i was lagging a bit behind, it was a curiosity around trailing zeroes from the user code perspective. not meaningful for this technical discussion.

[20:21:37.0761] <Chris de Almeida>
gentle reminder: please do not tap on the microphones.  üôè

[20:33:01.0388] <rkirsling>
remind me whether we've discussed Array#zip before

[20:33:12.0489] <Ashley Claymore>
we have

[20:33:17.0812] <rkirsling>
* remind me whether we've discussed Array.zip before

[20:33:32.0493] <bakkot>
https://github.com/tc39/proposal-array-zip

[20:33:53.0385] <rkirsling>
excellent, thanks

[20:34:00.0044] <bakkot>
I personally can't actually imagine a use case for it though

[20:34:26.0421] <rkirsling>
in the sense that zip kind of implies you're gonna iterate?

[20:34:32.0690] <bakkot>
exactly once, yes

[20:34:48.0858] <rkirsling>
true that I can't think of a case where that wouldn't be so

[20:35:03.0850] <rkirsling>
* true that I can't think of a case where that wouldn't be so, offhand

[20:35:34.0432] <ptomato>
ljharb: Richard Gibson: I mean, we could just merge it literally now if you two are okay with it üòÑ

[20:35:42.0088] <ljharb>
go for it :-)

[20:36:36.0831] <eemeli>
Not supporting trailing zeros is the only blocker for a digit string representation of a number to be able to fully represent a numeric value together with a precision. Effectively we're trying to fix a small overlooked formatting bug here.

[20:36:51.0702] <Richard Gibson>
I'd like to give it one more look, but let's set a timeout for the end of this meeting

[20:38:34.0427] <Michael Ficarra>
oh god, who did this?

[20:39:17.0134] <ljharb>
(oh also, belated, for Joint Iteration, https://npmjs.com/es-iterator-helpers also implements it in quasi-spec text and it passes all tests)

[20:39:28.0819] <Chris de Almeida>
no snitching in plenary

[20:40:11.0309] <Michael Ficarra>
you should mention that in the test262 PR

[20:40:41.0445] <ptomato>
yes please do, I find that helpful at least

[20:47:44.0277] <Michael Ficarra>
certainly Guy's concerns would not affect Stage 3, they would be Stage 2.7

[20:48:12.0538] <Michael Ficarra>
I think he's maybe just not familiar with our process

[20:49:16.0091] <Michael Ficarra>
if anything, they sound more like concerns for which we'd consider reverting to Stage 1 to me

[20:56:04.0453] <bakkot>
the proposal is moving way from the thing on the screen

[20:56:10.0925] <rkirsling>
TIL "barrel file"

[20:56:32.0677] <bakkot>
iow I am confused by the observation that barrel files are bad for performance, given that the point of this proposal is, now they would not be bad for performance?

[20:57:12.0555] <bakkot>
if your problem with barrel files is that they have bad performance, making them not have bad performance seems like... it solves the problem?

[20:57:24.0766] <ljharb>
only if they were all created with defers all the way down

[20:57:33.0030] <ljharb>
which i think is a pretty big presumption

[20:58:02.0289] <ljharb>
iow, someone who's that vigilant would in theory be avoiding barrel files in the first place.

[21:02:02.0636] <Justin Ridgewell>
Barrel files are good for DX, bad for perf. Let's fix perf

[21:07:34.0385] <ljharb>
i don't agree they're good for DX

[21:07:56.0041] <snek>
i mean people using them in spite of the performance issues kind of proves the dx, no?

[21:08:54.0744] <eemeli>
Why do we have two @erights Mark Miller (Agoric) MMs on the Zoom call?

[21:09:06.0520] <Christian Ulbrich>
Second that. We can argue all the way about them, being devilish, fact is they are used pretty often.

[21:10:12.0467] <Chris de Almeida>
he likes to join via phone as well

[21:11:25.0374] <Christian Ulbrich>
eemeli: I think that has to do with space time.

[21:13:07.0783] <eemeli>
... and not e.g. with "them, being devilish"?

[21:14:11.0465] <Christian Ulbrich>
devilish referred to barrels and space time to two marks.

[21:20:47.0580] <Michael Ficarra>
agreed with @bakkot:matrix.org, in a vacuum we would treat it as if undefined was passed, not throw

[21:21:12.0552] <Michael Ficarra>
so diverging just to do the not-ideal thing seems not good

[21:21:25.0647] <rkirsling>
I too agree

[21:21:27.0086] <bakkot>
if we are branching on presence anyway I guess I don't really care about throw vs no-op

[21:21:41.0869] <ljharb>
it could also mean they're an attractive nuisance.

[21:22:32.0285] <Mathieu Hofman>
I thought most IsObject check for receiver was because some later operation was relying on looking up slots or similar on an object

[21:22:49.0272] <Mathieu Hofman>
* I thought most IsObject check for receiver were because some later steps are relying on looking up slots or similar on an object

[21:25:15.0877] <ljharb>
indeed

[21:26:11.0031] <snek>
idk what this means

[21:28:14.0586] <ljharb>
it means they're something people _think_ they want but has subtle or unknown consequences they aren't aware of but wouldn't like

[21:28:30.0497] <ljharb>
iow, "choice" shouldn't ever be conflated with "informed choice"

[21:28:36.0628] <Michael Ficarra>
wait wtf there's slides now?

[21:29:15.0797] <bakkot>
not on the agenda there's not

[21:29:58.0939] <rbuckton>
```js
{
  let bar = foo.bar;
  if (bar) { ... }
}
```

[21:30:21.0803] <snek>
but those consequences are not to the developer, they're to the user. 

[21:30:31.0889] <Michael Ficarra>
yes I literally do that because I hate having my bindings visible outside where they should be used

[21:30:32.0063] <Justin Ridgewell>
I wonder if V8 implemented during-function GC‚Ä¶

[21:30:37.0547] <rbuckton>
* ```js
{
  let bar = foo1.bar;
  if (bar) { ... }
}
{
  let bar = foo2.bar;
  if (bar) { ... }
}
```

[21:30:52.0468] <hax (HE Shi-Jun)>
It seems Decl in cond proposal doesn't change anything compare to the version 5 years ago?

[21:30:59.0017] <snek>
depends on the function

[21:30:59.0377] <ljharb>
which is *worse* because in the priority of constituencies, users rank higher :-) also because the dev is even less aware of the harm they cause

[21:31:20.0611] <snek>
sure, i'm just clarifying that its still good DX, even if the UX is bad

[21:31:50.0602] <snek>
(and ideally, DX and UX should be aligned, but obviously that is not always the case)

[21:33:18.0359] <ljharb>
fair clarification

[21:33:33.0861] <ljharb>
i'd stretch to say that good DX that leads to bad UX is itself bad DX, because it begets angry users later

[21:35:33.0383] <Justin Ridgewell>
But we can make good DX also good UX

[21:35:54.0920] <snek>
i am absolutely shocked that anyone would want them to bind in other branches

[21:37:02.0650] <bakkot>
snek: I think this presentation didn't really cover all the contours. it's relevant that the proposal also includes an expression form:

```
if (let x = foo; condition(x)) {

} else {

}
```

[21:37:15.0908] <bakkot>
there's a lot more reason for `x` to be visible in the `else` here

[21:37:19.0328] <bakkot>
that said I still think it should not

[21:37:19.0484] <Justin Ridgewell>
I have certainly wanted to access the binding in the `catch { }` block

[21:37:27.0276] <snek>
no that should just be declared above if statement

[21:37:29.0605] <ptomato>
I think Devin's `a && b` example is a convincing example why someone might want that

[21:37:31.0382] <bakkot>
also the fact that this is included is not at all obvious from the state of the proposal repo

[21:37:32.0525] <snek>
* no that should just be declared above the if statement

[21:37:37.0656] <bakkot>
what if it's a `using`

[21:37:50.0556] <bakkot>
in fact the specific ability to put `using` here is the main reason I want this proposal at all

[21:38:00.0097] <rkirsling>
yeah I didn't realize the `;` addition was coming

[21:38:01.0857] <snek>
then wrap it in a block

[21:38:07.0101] <snek>
that seems way simpler to understand 

[21:38:10.0774] <bakkot>
do the wrapping

[21:38:13.0076] <bakkot>
it's not trivial at all

[21:38:16.0985] <bakkot>
you want disposal before the `else`

[21:38:31.0177] <Justin Ridgewell>
`let foo = maybeThrows(); try { ‚Ä¶ } catch { }` is a non-starter.

[21:38:32.0404] <snek>
no i mean if you want to use it in both branches

[21:38:34.0831] <snek>
it should be above the else

[21:38:39.0811] <bakkot>
oh!

[21:38:40.0415] <bakkot>
yeah

[21:38:41.0206] <bakkot>
agreed

[21:38:42.0765] <bakkot>
strongly

[21:38:51.0672] <snek>
cool

[21:38:52.0282] <Justin Ridgewell>
I want `try (let foo = maybeThrows()) { ‚Ä¶ } catch { }`

[21:39:07.0927] <rkirsling>
I'm fine with or without the `;` but I feel strongly about the non-exposure to `else`

[21:39:27.0285] <Justin Ridgewell>
Doing `let foo; try { foo = maybeThrows(); ‚Ä¶ } catch { }` feels ikcy

[21:39:30.0489] <Justin Ridgewell>
* Doing `let foo; try { foo = maybeThrows(); ‚Ä¶ } catch { }` feels icky

[21:39:58.0054] <Justin Ridgewell>
* I want `try (let foo = maybeThrows()) { ‚Ä¶ } catch { console.log(foo) }`

[21:40:05.0281] <Justin Ridgewell>
* Doing `let foo; try { foo = maybeThrows(); ‚Ä¶ } catch { console.log(foo) }` feels icky

[21:40:13.0899] <Justin Ridgewell>
* `let foo = maybeThrows(); try { ‚Ä¶ } catch { console.log(foo) }` is a non-starter.

[21:41:12.0907] <nicolo-ribaudo>
The spec is only missing entering/exiting a new block scope right?

[21:41:20.0918] <nicolo-ribaudo>
Because right now the variables leak outside of the if/loop

[21:41:27.0601] <nicolo-ribaudo>
Even if they are defined in the head

[21:42:14.0643] <bakkot>
well, and like

[21:42:16.0714] <bakkot>
semantics for the if

[21:42:31.0537] <bakkot>
* semantics for the `if`

[21:42:33.0477] <nicolo-ribaudo>
Oh right the semicolon version

[21:42:42.0114] <bakkot>
either version

[21:42:51.0911] <bakkot>
declaration have empty completion values

[21:42:57.0356] <hax (HE Shi-Jun)>
I agree with bakkot , for `if (decl; cond)` there are too many use cases require decl is availabe. But if no cond, there is no use case. This is the bad smell for the design.

[21:43:01.0115] <waldemar>
None of the new forms have semantics in the spec

[21:43:10.0146] <danielrosenwasser>
```
if (let { data, error } = ...; data) {
  // use data 
}
else {
  // use error
}
```

[21:43:35.0061] <bakkot>
danielrosenwasser: just put the declaration above the `if` in that case

[21:43:37.0146] <rkirsling>
wait what, analogous to `for`?

[21:43:44.0685] <snek>
this seems like a better motivation for the pattern matching proposal

[21:43:48.0492] <danielrosenwasser>
I was *very* surprised about `else` scope, but have written a good amount of code that uses it

[21:43:49.0287] <snek>
than trying to shove that into this

[21:43:49.0477] <rkirsling>
that's actually more of a head-scratching statement to me

[21:44:04.0416] <danielrosenwasser>
* I was _very_ surprised about `else` scope, but have written a good amount of code that uses it. It's nice.

[21:44:08.0247] <bakkot>
a `for` is an initialization which runs first, then a test, which runs second. this is the same pretty much! except the init has to be a declaration, but whatever

[21:44:22.0813] <danielrosenwasser>
The point is to avoid 2-3 `data` and `error`s :D

[21:44:45.0114] <bakkot>
... I don't understand? the obvious rewrite where you put it above doesn't have any more

[21:45:02.0464] <bakkot>
```
let { data, error } = ...;
if (data) {
  // use data 
}
else {
  // use error
}
```

[21:45:17.0402] <bakkot>
or if you really care about scope,

```
{
let { data, error } = ...;
if (data) {
  // use data 
}
else {
  // use error
}
}
```

[21:45:19.0878] <Mathieu Hofman>
are we talking about only have a single `;` permissible. Because if you have multiple `;` it gets confusing again compared to `for` 

[21:45:21.0014] <hax (HE Shi-Jun)>
And I also think if we introduce such syntax, we should not copy c++, but swift/rust instead.

[21:45:29.0418] <danielrosenwasser>
I don't understand why the two have to be at odds?

[21:46:00.0513] <danielrosenwasser>
* I don't understand why the two (pattern matching and variable-scoped `if`) have to be at odds with each other

[21:46:18.0507] <bakkot>
yes, zero or one

[21:46:33.0629] <snek>
i'm fine with conditional declarations and pattern matching both existing 

[21:46:49.0608] <snek>
just no conditional declarations being visible in alternatives. i am strongly against that.

[21:46:51.0413] <rkirsling>
I don't think it's fair to block this on a controversial sub-proposal of a Stage 1 proposal; even within the pattern matching space, I have _very_ mixed feelings about `is`

[21:47:01.0435] <rkirsling>
this proposal is way more basic than pattern matching

[21:47:29.0902] <hax (HE Shi-Jun)>
I don't like the proposal in current form, but I will offline soon. If it was asked to enter stage 2, i will vote for no. I think we should wait for pattern match proposal.

[21:48:21.0003] <snek>
switch head visible to bodies is fine, that block encloses the cases

[21:48:23.0687] <bakkot>
 I used to not really have an opinion on visibility, but with the inclusion of `using` I now feel strongly that the `using` binding must be disposed before the `else`, which implies the binding should not be visible in the `else`. rust actually changed their behavior to make disposal happen before the `else`! https://github.com/tc39/proposal-Declarations-in-Conditionals/issues/3#issuecomment-3458395454

[21:48:39.0207] <Michael Ficarra>
+1 Ron, I want to see the significant cross-cutting concerns fully explored before this proposal moves to Stage 2

[21:48:40.0250] <bakkot>
rust does not like to change things but this repeatedly caused nasty bugs in production

[21:49:52.0998] <rkirsling>
wasn't expecting a `switch` discussion ü§î feel like ljharb would have some strong opinions

[21:50:24.0355] <rkirsling>
there it is

[21:51:11.0608] <rkirsling>
actually droppable braces is another argument against propagation to else

[21:51:24.0629] <rkirsling>
* actually droppable braces is another argument against propagation to else, confusability-wise

[21:51:41.0244] <waldemar>
We should also add this to `with` statements. /s

[21:53:15.0992] <Christian Ulbrich>
I think the curly braces is a good argument, can't come up with an example, because I do not do my if-clauses w/o curlies. Hold on!

[21:53:58.0975] <Mathieu Hofman>
I find extra curly a visual nuisance, and avoid them unless really necessary

[21:54:10.0247] <Mathieu Hofman>
* I find extra curly / blocks a visual nuisance, and avoid them unless really necessary

[21:54:23.0345] <rkirsling>
fwiw JSC has a hard "_never_ braces for a one-line body", just so that we're clear on that being an intentional styleguide option

[21:55:11.0467] <snek>
is the queue advancing broken?

[21:55:21.0502] <ljharb>
i'll only grumble quietly as long as a consistent linter-enforced decision is made, but omitting braces - that's how you get [gotofail](https://www.blackduck.com/blog/understanding-apple-goto-fail-vulnerability-2.html)

[21:55:36.0463] <Michael Ficarra>
no? there's just a lot of stuff on the queue

[21:56:22.0600] <snek>
oh i see, olivier started with the other topic

[21:56:30.0882] <snek>
i got confused and thought daniel was talking

[21:58:12.0936] <Christian Ulbrich>
For me it is about visual pattern recognition, whenever I see an if without curlies, I have to adjust and I do not want to that. I prefer solutions, that always work‚Ñ¢. 

[21:58:38.0117] <ljharb>
it also means more diff churn when converting between 1 and 1+ statement constructs

[21:58:46.0047] <Michael Ficarra>
@devsnek:matrix.org never misses

[21:58:48.0181] <ljharb>
same reason why arrow function args always have parens in the airbnb styleguide

[21:58:54.0786] <ljharb>
* same reason why arrow function args always have parens in the airbnb styleguide, even single-arg ones

[21:58:55.0068] <Christian Ulbrich>
This brings up another question, is there short-circuiting?

[21:59:38.0683] <bakkot>
dunno if Ben Lickly is in the chat, but the answer to the question is,

```
while ((match = tokenRegex.exec(input)) !== null) {
  // ...
}
```
vs
```
while (const match = tokenRegex.exec(input)) {
  // ...
}
```

[21:59:55.0726] <Christian Ulbrich>
I mean, what Gus said, is supposed to be the other way around... the condition must come after the declaration...

[22:00:11.0233] <Mathieu Hofman>
To clear up my statement, I don't want to add free-standing blocks inside/outside other blocks that are attached to statements

[22:00:27.0352] <bakkot>
* dunno if Ben Lickly is in the chat, but the answer to the question is,

```
let match;
while ((match = tokenRegex.exec(input)) !== null) {
  // ...
}
```

vs

```
while (const match = tokenRegex.exec(input)) {
  // ...
}
```

[22:00:45.0555] <Mathieu Hofman>
definitely dislike optional blocks, except for arrow functions

[22:00:49.0465] <ljharb>
sure, but that's an aesthetic preference that presumably is more important to you than the lexical availability of bindings?

[22:01:21.0104] <Andreu Botella (üïë JST, at TC39)>
if it was something like a TDZ, it couldn't even be anything like a regular TDZ

[22:01:22.0004] <Aki>
No path to stage 2 right now but that felt like a good plenary conversation? 

[22:01:34.0581] <Andreu Botella (üïë JST, at TC39)>
because you'd have to somehow undeclare the value 

[22:01:38.0246] <nicolo-ribaudo>
Putting curly braces is bad because it increases file size, making websites slower for users

[22:01:44.0835] <Jake Archibald>
Ashley Claymore: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_tdz

[22:01:47.0867] <Mathieu Hofman>
The reason I dislike is because I associate blocks to control flow, and free standing blocks do not contribute to control flow (if you ignore labels)

[22:02:26.0625] <blickly>
That makes sense. Thanks for the example

[22:02:35.0334] <nicolo-ribaudo>
Re tdz: I think we should be careful with new TDZ after V8's feedback a whole ago 

[22:02:37.0317] <Olivier Fl√ºckiger>
Ok, I did not think about the `if (...; cond)` syntax. In my mind the binding was just `false` in the `else` case. So with that I see the appeal of not having it in else....

[22:03:30.0535] <Olivier Fl√ºckiger>
but yeah, I am still worried about more TDZ

[22:03:35.0270] <Steve Hicks>
I'm confused, the `if (...; cond)` is exactly why it's useful to have the binding in the else - as in the better diagnostics example of _why_ did the condition fail?

[22:04:34.0287] <Jake Archibald>
Steve Hicks: maybe `if (const response = await response; response?.ok)`?

[22:04:45.0750] <Jake Archibald>
* Steve Hicks: maybe `if (const response = await fetch(‚Ä¶); response?.ok)`?

[22:05:32.0312] <snek>
i think this motivates pattern matching, not having the binding available outside the consequent 

[22:06:03.0378] <Jake Archibald>
* Steve Hicks: <del>maybe `if (const response = await fetch(‚Ä¶); response?.ok)`?</del> ignore me, I'm tired

[22:06:34.0885] <danielrosenwasser>
Pattern matching is cool, but other languages have this feature with no pattern matching as well. There are plenty of times you want to bind a variable and check some specific condition that has nothing to do with truthiness

[22:06:36.0484] <bakkot>
better diagnostics argues for, but `using` argues against, and I think is much stronger (since for diagnostics you can of course just put the binding outside). I want to be able to write this, and have the resource be disposed before the `else`. I invite you to rewrite it assuming that the binding lives through the `else`. I can't make it pretty!

```
if (using resource = getResource(); resource.needsUpdate) {
  resource.update();
} else {
  await postMessage('no updates required');
}
```

[22:06:36.0951] <Michael Ficarra>
I really hope the champion understands the breadth of work required to actually prepare this proposal for Stage 2. It's a lot.

[22:06:48.0968] <danielrosenwasser>
* Pattern matching is cool, but other languages have this feature independent of pattern matching. There are plenty of times you want to bind a variable and check some specific condition that has nothing to do with truthiness

[22:06:54.0494] <bakkot>
best I've got is this:
```
let neededUpdate;
{
  using resource = getResource();
  if (resource.needsUpdate) {
    neededUpdate = true;
    resource.update();
  }
}
if (!neededUpdate) {
  await postMessage('no updates required');
}
```

[22:06:58.0026] <danielrosenwasser>
* Pattern matching is cool, but other languages have this feature independent of pattern matching. There are plenty of times you want to bind a variable and check some specific condition that has nothing to do with truthiness or a type check.

[22:06:58.0511] <rbuckton>
We discussed scoping awhile back in the pattern matching meetings with respect to `is` and `let` patterns. One of the problems with not having the binding be visible to an `else` has to do with inverting a condition, i.e., if you start with `if (x) A else B` and refactor to `if (!x) B else A`, you have to completely change how you write the code to bind the value

[22:10:49.0524] <danielrosenwasser>
It is a little funny that we might say "this thing can't be seen in an `else` but it's fine to see it in the `default` of a `switch`"

[22:11:36.0908] <bakkot>
I really think the argument from `using` against having the binding visible in the `else` is extremely strong, such that I would be opposed to the proposal going forward if the binding is visible in the `else`. Does anyone who thinks it should be visible in the `else` have thoughts on that specific topic?

[22:11:54.0229] <snek>
they're all standing in a circle talking rn

[22:12:31.0218] <danielrosenwasser>
I think I would have to do some reading on your concern there - is [this comment](https://github.com/tc39/proposal-Declarations-in-Conditionals/issues/3#issuecomment-3458395454) the right starting pint?

[22:12:33.0797] <danielrosenwasser>
* I think I would have to do some reading on your concern there - is [this comment](https://github.com/tc39/proposal-Declarations-in-Conditionals/issues/3#issuecomment-3458395454) the right starting point?

[22:12:48.0556] <bakkot>
the one above that, really, yes

[22:12:55.0875] <bakkot>
also https://github.com/tc39/proposal-Declarations-in-Conditionals/issues/12#issuecomment-3517821049

[22:13:02.0901] <rbuckton>
Or with a helper function:
```
function getResourceIfNeedsUpdate() {
  using stack = new DisposableStack();
  const resource = stack.use(getResource());
  if (resource.needsUpdate) {
     stack.move();
     return resource;
  }
  return null;
}

if (using resource = getResourceIfNeedsUpdate()) {
  resource.update();
} else {
  await postMessage('no updates required');
}
```

[22:14:35.0010] <rbuckton>
Or more generalized:
```
function holdResourceIf(acquire, test) {
  using stack = new DisposableStack();
  const resource = stack.use(acquire());
  if (test(resource)) {
    stack.move();
    return resource;
  }
  return null;
}

if (using resource = holdResourceIf(() => getResource(), res => res.needsUpdate)) {
  ...
} else {
  ...
}
```

[22:15:00.0344] <Ashley Claymore>
I shouldn't have said TDZ, really my Q should have been:  would it be a syntax error to access the binding in the else? Or are the use cases conditional-shadowing-within-true-branch

[22:15:19.0916] <bakkot>
yeah, I think those examples make it very clear why it's better for the syntax to help out here

[22:15:21.0668] <Steve Hicks>
Ron mentioned pattern matching not supporting using - maybe this is where the two don't overlap?  I assume pattern matching would allow scoping something to the entire block, so if you wanted access in both branches you could use that, and if you need `using`, you use this?

[22:16:27.0949] <rbuckton>
And that generalized form is not unlike what a condition variable might do.

[22:16:30.0949] <snek>
i don't think its ever a syntax error to reference an undefined variable.

[22:16:47.0709] <snek>
* i don't think its ever a syntax error to reference an undeclared variable. it would be a reference error, unless something above the if had declared it.

[22:18:40.0515] <rbuckton>
IMO if you introduced bindings in `if` they would be similar to per-iteration bindings in a `for` loop, so scoped to the `if` statement (which might be considered to include the `else` clause)

[22:19:30.0621] <snek>
maybe `if (var)` can be the escape hatch for people who want the variable in their else branches

[22:19:34.0442] <snek>
* maybe `if (var x = ...)` can be the escape hatch for people who want the variable in their else branches

[22:19:37.0402] <bakkot>
I don't think there's good use cases but personally I would not make it a syntax error; just leave it to linters. I can imagine someone wanting to write

```
let data = whatever;
if (let data = updateOrNull()) {
  console.log('updated', data);
} else {
  console.log('not updated', data);
}
```
or something. probably they shouldn't but I don't think it's the language's place to forbid this

[22:20:08.0637] <danielrosenwasser>
It's a good point, it's a huge pain to make that resource dispose early. Definitely frustrating that the two use-cases are at odds.

[22:20:50.0480] <bakkot>
yeah but the use case when you want the binding visible is much, much easier to solve

[22:20:54.0557] <bakkot>
you just do the thing you'd do today

[22:21:08.0519] <bakkot>
whereas it's an actual significant upgrade on the use case where you want the binding not visible

[22:21:37.0609] <snek>
i don't understand why you would use a conditional binding but also want it to not be conditional. its not even the clearest way to write that code

[22:23:40.0151] <Olivier Fl√ºckiger>
```
let x = true;
if (let x = false) {} else {log(x)}
```

[22:25:35.0661] <rkirsling>
that is some yucky code

[22:26:18.0090] <snek>
you can write `let i = 4; for (let i = 0; i < 10; i++) {}`

[22:27:16.0584] <bakkot>
```
let e = 0;
try { throw 1; } catch (e) { console.log(e) } finally { console.log(e) }
```
that's just how bindings work!

[22:27:56.0238] <Olivier Fl√ºckiger>
sure, I am saying that it is easier to understand visually where you refer to which binding...

[22:28:01.0245] <eemeli>
Why are we _still_ doing paper attendance sheets?

[22:28:04.0425] <Olivier Fl√ºckiger>
(if it exists in the else)

[22:28:23.0186] <nicolo-ribaudo>
Programmers are known for making computers not work

[22:29:00.0434] <Olivier Fl√ºckiger>
Btw. we have a similar case in for. If the following was valid syntax: `for (let x = false; x; false) { } else { x }`, then `x` would be out of scope in the `else` case. But it is not valid syntax...

[22:29:27.0906] <waldemar>
How did I get onto the queue twice?

[22:29:42.0156] <Christian Ulbrich>
twitchy fingers!

[22:29:44.0649] <snek>
probably request retry with no protection for that

[22:29:57.0237] <Christian Ulbrich>
or - highly unlikely - a race condition in TCQ.

[22:29:57.0656] <waldemar>
I'm not that fast at typing.

[22:32:24.0062] <Christian Ulbrich>
FWIW if you accidentally double-clicked the submit, it gets send twice, because there is no logic in TCQ preventing that.

[22:33:17.0065] <rkirsling>
ooh

[22:33:24.0555] <rkirsling>
see now that deserves a bug report

[22:34:00.0183] <Chris de Almeida>
because Ecma, that's why. do not question the Ways of the Ancients

[22:34:22.0127] <eemeli>
Oh, but I do.

[22:34:29.0165] <Chris de Almeida>
over-eager web sockets

[22:34:57.0311] <Aki>
Samina and I are choosing our modernisation battles carefully. Neither of us cares to die on the hill of paper sign-in sheet.

[22:35:24.0477] <Chris de Almeida>
what's crazy is that the paper sheet gets mailed out to all remote attendees to sign and send back to Ecma

[22:36:24.0140] <snek>
and they don't even include postage 

[22:39:50.0739] <Christian Ulbrich>
Ugh. Never got them.

[22:39:56.0537] <Rob Palmer>
also it helps me get accurate numbers for the social dinner

[22:41:24.0938] <eemeli>
At least one physical sheet is now filled out completely next to Shane.

[22:44:55.0030] <rbuckton>
> <@olivf.o1o.ch:immer.chat> Btw. we have a similar case in for. If the following was valid syntax: `for (let x = false; x; false) { } else { x }`, then `x` would be out of scope in the `else` case. But it is not valid syntax...

Since that syntax doesn't exist, it's arguable in either direction. 

[22:46:00.0389] <Ashley Claymore>
https://es.discourse.group/t/proposal-for-else-also-while-else-statement/934

[22:46:12.0309] <rbuckton>
The only other statement with split syntax like this is `do...while`, but there's no variable scoping involved

[22:46:24.0782] <ljharb>
there would be with the relevant proposal, tho

[22:46:55.0216] <bakkot>
`try {} catch (e) {} finally {}`

[22:47:14.0591] <ljharb>
`try {} catch (e) {} finally {} andthen {}`

[22:48:15.0962] <rkirsling>
`finallyer`

[22:48:19.0223] <rbuckton>
IMO, `catch` is a bit of a weird case, and `finally` is executed in *both* branches so it's not indicative 

[22:48:52.0738] <Ashley Claymore>
```
for x in range(3):
    print(x)
else:
    print('Final x = %d' % (x))
```

[22:49:14.0429] <Ashley Claymore>
TIL

[22:49:32.0800] <Ashley Claymore>
(I've done almost zero python dev)

[22:50:16.0356] <Olivier Fl√ºckiger>
haha, as I C programmer I was expecting it to print final = 3

[22:50:26.0213] <Olivier Fl√ºckiger>
* haha, as a C programmer I was expecting it to print final = 3

[22:51:10.0547] <rkirsling>
I did not realize that was in Python

[22:51:31.0260] <Ashley Claymore>
I wasn't expecting the else to run at all. I thought `for-else` would be _for_ when the loop block never runs

[22:52:09.0711] <rkirsling>
oh wow yeah

[22:52:17.0469] <nicolo-ribaudo>
"Do this in an infinite loop, or else if you cannot go forever do this"

[22:52:20.0425] <rkirsling>
that's a broken use of a keyword if it doesn't mean that

[22:53:08.0540] <Ashley Claymore>
halt-or-else

[22:53:31.0816] <Michael Ficarra>
that would be identical to just putting it after the loop?

[22:53:56.0506] <rkirsling>
yeah but it's less a utility question and more a "what does the word else mean" question

[22:54:00.0211] <rbuckton>
if `using` had stuck with Java's `try`-with-resources then we might have a case. IIRC, In Java:
```java
try (FileReader r = new FileReader(...)) {
}
catch (IOException e) {
  // r is not reachable
}
```
But control-flow based on exceptions isn't quite the same as `if...else`

[22:54:03.0456] <rkirsling>
they should've chosen a different word

[22:54:16.0008] <rbuckton>
* if `using` had stuck with Java's `try`-with-resources then we might have a case. IIRC, In Java:

```java
try (FileReader r = new FileReader(...)) {
  ...
}
catch (IOException e) {
  // r is not reachable
}
```

But control-flow based on exceptions isn't quite the same as `if...else`

[22:54:23.0694] <rkirsling>
namely finally

[22:55:10.0161] <bakkot>
it only runs if the loop does _not_ early exit

[22:55:13.0983] <bakkot>
it's for searching

[22:55:53.0723] <Ashley Claymore>
ah thanks. so `break` would skip the else

[22:56:10.0982] <bakkot>
```
for x in range(3):
  if x == 2: break
else
  print('not found')
```

[22:56:12.0126] <bakkot>
yeah

[22:56:19.0232] <bakkot>
it make sense in this context and only this context

[22:56:24.0486] <bakkot>
it's a bad choice of keyword though

[23:08:53.0921] <Chengzhong Wu>
should the tcq be advanced/

[23:08:59.0990] <Chengzhong Wu>
* should the tcq be advanced?

[23:11:28.0759] <Michael Ficarra>
"some files don't use UTF-8" is extra relevant at the Japan meeting

[23:16:05.0326] <Justin Ridgewell>
I think we should just assume UTF-8, and let `import bytes` to get a different encoding.

[23:21:26.0519] <Michael Ficarra>
consider windows-1252 @sffc:mozilla.org

[23:28:23.0090] <nicolo-ribaudo>
Would it be simpler to merge the proposals at some point?


[23:28:25.0353] <nicolo-ribaudo>
To have a single PR

[23:28:39.0696] <nicolo-ribaudo>
The implementation would probably also be done at the same time

[23:29:01.0328] <ljharb>
i don't think "one PR" is of much value personally

[23:29:13.0678] <nicolo-ribaudo>
It's for the champions, they will conflict in half of their changes

[23:29:26.0316] <nicolo-ribaudo>
And they are both incredibly small, reviewing them together would not be a burden

[23:29:27.0480] <ljharb>
i'm happy to do the rebasing, nbd

[23:29:31.0291] <ljharb>
either way

[23:30:57.0244] <Olivier Fl√ºckiger>
Hmm, ok, I am confused about the import text proposal I think. A string can only contain utf-8 chars right now, right? at least string literals. So what would happen if you create a string with non utf-8 chars with import text?

[23:31:19.0151] <snek>
no, string literals in javascript are not limited to utf8

[23:31:41.0173] <nicolo-ribaudo>
String literals allow unpaired UTF-16 surrogate pairs

[23:31:48.0423] <nicolo-ribaudo>
But I think that's beyond the point of the discussion

[23:31:55.0028] <ljharb>
`'\xc3\x28'` is not UTF8 and is a valid JS string, eg

[23:31:59.0046] <ljharb>
* `'\xc3\x28'` is not UTF8 and is a valid JS string, eg (i believe)

[23:32:31.0645] <Michael Ficarra>
JavaScript strings are sequences of UTF-16 code units (numbers between 0 and 65535, inclusive)

[23:32:39.0445] <nicolo-ribaudo>
The question is: given some bytes, do we extract the charcodes out of them with UTF-8 rules, or do we allow following multiple encoding rules?

[23:32:41.0099] <Michael Ficarra>
I'm surprised more people don't think of them this way

[23:32:44.0602] <nicolo-ribaudo>
* The question is: given some bytes, do we extract the code units out of them with UTF-8 rules, or do we allow following multiple encoding rules?

[23:33:21.0502] <Michael Ficarra>
That's not the question though? It's just up to the host.

[23:33:41.0813] <Olivier Fl√ºckiger>
https://tc39.es/ecma262/#sec-literals-string-literals

[23:33:42.0782] <nicolo-ribaudo>
The question was whether we want to give host guidance for these imports, no?

[23:34:00.0155] <Olivier Fl√ºckiger>
"A string literal is 0 or more Unicode code points enclosed in single or double quotes. Unicode code points may also be represented by an escape sequence."

[23:34:02.0357] <ljharb>
they already have to do that for modules, no?

[23:34:35.0266] <snek>
the normative requirement should be exactly "construct a javascript string". how the host implements such a construction is out of scope for ecma262 itself

[23:34:41.0612] <jkup>
the transcription quality is struggling.. not sure if that's worth stopping or just finish the rest of today?

[23:34:46.0164] <nicolo-ribaudo>
Let's say you have an encoding where A is 0x00, B is 0x01, ..., and you import a file that contains 0x00-0x01 that has that encoding. Is it fine if it results in the string "\u0000\u0001", even though it was meant to contain the string "AB"?

[23:34:49.0577] <Michael Ficarra>
Who is asking that question?

[23:34:54.0329] <nicolo-ribaudo>
That's what I understood the question to be

[23:34:55.0324] <nicolo-ribaudo>
Shane?

[23:35:08.0948] <nicolo-ribaudo>
If not, I did not understand what Shane was saying

[23:35:39.0099] <ljharb>
of course, you made your own homegrown encoding. you read it as text or bytes and interpret it yourself in that case, no?

[23:35:43.0331] <Michael Ficarra>
you and I both know literals are not the only way to construct strings

[23:36:00.0349] <nicolo-ribaudo>
It was for an example, assume it's some other known encoding

[23:36:10.0422] <nicolo-ribaudo>
To be clear, I want it to be UTF-8 only. I'm not representing my opinion

[23:36:14.0158] <nicolo-ribaudo>
It's what I got from the discussion

[23:37:31.0027] <Michael Ficarra>
I think the question was more like "is there something better we can do when the host uses the wrong encoding to decode the text?" and the answer is pretty easily "no", right?

[23:38:52.0702] <sffc>
If what people are saying about JSON imports being required to be UTF-8 is true, then a JSON file that is encoded on disk as UTF-16 BE will start with a NUL byte (or perhaps a BOM), which is invalid JSON, so the error happens early. But with import text, the conformant behavior would be to convert those bytes to replacement characters, and developers won't find out that there was an encoding problem. Implicit wrong encoding problems cause errors across many generations. Everyone here has seen garbled text on websites that results from the wrong encoding being used when reading bytes from a database or data file.

[23:39:37.0562] <nicolo-ribaudo>
CSS imports also assume UTF-8, but CSS is much more lenient and doesn't throw an error as far as I know

[23:39:58.0690] <nicolo-ribaudo>
I mean `type: "css"`

[23:40:10.0956] <Michael Ficarra>
@sffc:mozilla.org that's specifically with a mix-up between UTF-16LE and UTF-16BE, but there are many other encoding mixups that will cause mojibake in your string but overall still be valid JSON

[23:40:36.0569] <snek>
i'm very confused about where utf-8 is coming into this conversation for type text, is it because of type json?

[23:40:51.0634] <Michael Ficarra>
that's why I said consider windows-1252 and code points between 0x80 and 0xFF above

[23:41:27.0358] <sffc>
JSON is itself a text-based encoding. The first code point is { or [ or " or another syntax character, and it has the same encoding as the string values contained inside the JSON. This is different from binary encodings.

[23:42:03.0031] <nicolo-ribaudo>
But you need to first get that text from some bytes, no?

[23:42:36.0713] <nicolo-ribaudo>
It's bytes->text->json. You are saying "it's fine if bytes->text does the wrong thing because you are catching it at the next step", but MF pointed out that you won't always catch it at the next step

[23:44:02.0466] <Michael Ficarra>
yes and some encodings encode `{` and `[` and `"` the same as another encoding but encode `¬£` and `√¶` the same

[23:44:40.0572] <sffc>
Yeah, like Latin-1, but not UTF-16

[23:44:43.0534] <Michael Ficarra>
so it's still valid JSON but the string data of the string that's encoded in the JSON is different because the wrong encoding was used to decode the JSON

[23:45:21.0215] <Michael Ficarra>
no, a latin-1 and UTF-16 mixup would not have this kind of behaviour

[23:45:25.0998] <Chris de Almeida>
we have been doing so well on time and have had to move a lot of topics up.  the downside is at this time, the day 2 and day 3 schedules are in rough shape.  we will update, but please be patient

[23:45:35.0707] <snek>
i feel like this conversation is being confused by the difference between abstract strings and utf8/utf16/etc strings

[23:46:01.0522] <Michael Ficarra>
wtf is an abstract string

[23:46:19.0945] <sffc>
A UTF-8 JSON parser might not fail on JSON stored as Latin-1. It should fail on JSON stored as UTF-16

[23:46:57.0736] <Michael Ficarra>
agreed, and?

[23:47:30.0382] <sffc>
And, then if the JSON file is encoded as UTF-16, then the error happens early

[23:47:34.0868] <Michael Ficarra>
a windows-1252 JSON parser will accept all JSON stored as latin-1 but some of it will have strings in the result that *are different*

[23:47:51.0855] <snek>
its not a thing in computer memory, its the theoretical characters. like the mathematical concept of numbers vs the concrete implementation of floating point.

[23:47:56.0850] <Michael Ficarra>
meaning there are no early errors

[23:47:57.0595] <snek>
idk if there's a better term

[23:48:06.0030] <Michael Ficarra>
it's just as fraught as text

[23:48:38.0654] <Michael Ficarra>
USV strings, or sequences of code points (ish)

[23:48:48.0865] <ljharb>
(ps, "the iterator protocol is crazy slow" is a strong use case for Array.zip)

[23:49:13.0328] <Michael Ficarra>
compelling case for engines to actually optimise their impleentations

[23:49:29.0694] <snek>
sequences of infinitely large code points, i guess? its not just restricted to how many characters there are in utf32 for example

[23:50:00.0903] <Michael Ficarra>
Unicode only defines 0x110000 code points

[23:50:12.0161] <snek>
i wouldn't think about it in terms of computer memory 

[23:50:22.0323] <snek>
* i wouldn't think about it in terms of computer memory or numbering characters

[23:50:35.0681] <Michael Ficarra>
so you mean... text?

[23:50:59.0043] <sffc>
You're saying that, since Windows-1252 encodes JSON syntax characters the same as UTF-8, then import type JSON gets a late error, which is the same as what will happen with import type Text. I agree that this is a true statement

[23:50:59.0886] <snek>
if that's the term for it

[23:51:53.0672] <Justin Ridgewell>
OMG byte offset is awful

[23:52:06.0700] <ljharb>
i'm not gonna hold my breath

[23:52:14.0978] <nicolo-ribaudo>
Process-wise, sffc is there any change you _maybe_ would want to see in the proposal itself, or is this about guiding the HTML integration?

[23:53:32.0301] <sffc>
The "true statement" above doesn't address my concern, other than asserting that one of the most likely environments where there would be an error (reading text files on Windows) already has this behavior with other import types

[23:54:50.0976] <Michael Ficarra>
@sffc:mozilla.org can you state your concern? @nicolo-ribaudo:matrix.org and I were unsure about what it was

[23:56:06.0228] <sffc>
In plenary, I made an assertion that import type text has error cases that other import types don't have. The statement about Windows-1252 reduces the number of cases where this happens, but it is still happens for encodings like UTF-16 BE.

[23:56:19.0006] <sffc>
* In plenary, I made an assertion that import type text has late-error cases that other import types don't have. The statement about Windows-1252 reduces the number of cases where this happens, but it is still happens for encodings like UTF-16 BE.

[23:58:37.0838] <Michael Ficarra>
if something "sometimes has a problem", it means we always need to consider the problem if we want to do it right

[23:59:03.0700] <Michael Ficarra>
so given there exists at least one pair of encodings where this problem could happen, it's just as important of a problem as the text mixup

[07:40:41.0895] <bakkot>
I really do not understand the conversation above. There's no requirements that hosts even represent modules as bytes at any point. It would be perfectly valid for a host to allow importing you to do `import text from 'my sample text' as { type: 'text' }` and have that result in the text `'my sample text'`, for example.

[07:41:19.0488] <bakkot>
Some hosts do represent modules as bytes, in a variety of ways, but that's entirely out of our scope

[07:41:29.0927] <bakkot>
* I really do not understand the conversation above. There's no requirements that hosts even represent modules as bytes at any point. It would be perfectly valid for a host to allow you to do `import text from 'my sample text' as { type: 'text' }` and have that result in the text `'my sample text'`, for example.

[07:42:48.0651] <bakkot>
* I really do not understand the conversation above. There's no requirements that hosts even represent importable resources as bytes at any point. It would be perfectly valid for a host to allow you to do `import text from 'my sample text' as { type: 'text' }` and have that result in the text `'my sample text'`, for example.

[07:42:55.0138] <bakkot>
* Some hosts do represent resources as bytes, in a variety of ways, but that's entirely out of our scope

[09:39:32.0917] <bakkot>
* I really do not understand the conversation above. There's no requirements that hosts even represent importable resources as bytes at any point. It would be perfectly valid for a host to allow you to do `import text from 'my sample text' with { type: 'text' }` and have that result in the text `'my sample text'`, for example.

[09:46:43.0781] <bakkot>
More realistically, something like Graal or other cross-language interop runtimes could allow consumers to define text to be importable from JS, and these would be presumably defined in terms of strings, not bytes. Compartments could be extended to do something similar. There's just no relevant notion of "encoding" a string to be imported from the perspective of these sorts of things. It doesn't make sense for the ES spec to concern it with the subset which happen to have the host doing translation from bytes.

[09:47:27.0035] <bakkot>
I'm sure HTML will specify how bytes from the network are translated to text to be imported, because it's a host, which is the appropriate layer to define those semantics.


2025-11-19
[17:00:06.0885] <Rob Palmer>
And we begin day 2!

[17:11:05.0305] <Michael Ficarra>
I think array iterators not closing when you call `return` was a mistake

[17:12:12.0280] <ljharb>
i think `return` was a mistake

[17:13:05.0488] <Michael Ficarra>
the generator protocol maybe, but return is fine

[17:16:30.0970] <ljharb>
separately, i'm not actually sure when you'd want to close the database connection - in most apps i've worked in, the database stays open and the connection is shared/pooled, and times out eventually

[17:33:20.0602] <dminor>
Michael Ficarra: Sorry, accidentally deleted your topic while clearing the +1s

[17:33:30.0752] <rkirsling>
these 1 or 2 or 2.7 presentations are a pretty amusing modern TC39 phenomenon

[17:35:03.0850] <snek>
that and conditional consensus 

[17:35:17.0941] <snek>
its nice we have ways to speed things up though

[17:35:28.0462] <rkirsling>
conditional consensus is good efficiency

[17:37:05.0789] <Justin Ridgewell>
@bakkot:matrix.org Can you link your async iterator slides when you‚Äôre done

[17:38:28.0996] <mgaudet|travelling>
Dumb question: Where is  CreateAsyncIteratorFromClosure defined? (re: async interator helpers-- it links to the main spec where I can't find it) 

[17:39:56.0646] <Michael Ficarra>
@mgaudet:mozilla.org https://github.com/tc39/ecma262/pull/3628

[17:40:47.0896] <mgaudet|travelling>
thanks :) 

[17:44:15.0644] <waldemar>
What happens if you get an infinite loop inside a spec function? Is there any defined behavior?

[17:45:38.0058] <Richard Gibson>
I guess the algorithm would just never terminate until the host process does

[17:46:22.0979] <snek>
i don't think any spec function current or proposed lets you get into a true infinite loop, they all dispatch on user code

[17:46:55.0166] <snek>
* i don't think any spec function current or proposed lets you get into a true infinite loop, they all predicate on user code

[17:51:30.0069] <bakkot>
sorry the async iterators item was so incoherent, I'd meant to do prep this weekend but I was/am down with some sort of horrible virus and am not able to think clearly enough for reasoning about concurrency code

[17:51:53.0723] <bakkot>
No special casing for infinite loops; the spec technically just says you have to keep doing it forever

[17:52:03.0160] <bakkot>
this is part of its general refusal to admit any resource constraints

[17:52:07.0014] <Richard Gibson>
maybe, but not if we introduce a built-in infinite iterator

[18:03:19.0015] <Christian Ulbrich>
forgive me for my naiivety (or for the lack of knowing the proper spelling), but composites are tought to be immutable, aren't they?

[18:03:48.0170] <nicolo-ribaudo>
Yes

[18:03:50.0957] <nicolo-ribaudo>
Shallowly 

[18:04:09.0848] <Christian Ulbrich>
Shallowly?

[18:04:22.0673] <nicolo-ribaudo>
They can contain mutable stuff

[18:04:25.0776] <snek>
is implementation concern the only factor for interned vs unique? or are there other constraints?

[18:04:27.0069] <Christian Ulbrich>
c1.wallet.amount is not immutable?

[18:04:33.0249] <bakkot>
correct

[18:04:36.0331] <Christian Ulbrich>
* `c1.wallet.amount` is not immutable?

[18:04:51.0889] <nicolo-ribaudo>
You can make wallet a composite too 

[18:05:27.0023] <bakkot>
can but shouldn't, wallets have identity

[18:05:36.0503] <bakkot>
my wallet is not your wallet just because we both have no money

[18:05:59.0863] <Justin Ridgewell>
@keith_miller:matrix.org Is spec convienence causing real slowdowns for TAs?

[18:07:02.0320] <Christian Ulbrich>
so `let c1 = Composite({wallet: amount: 20}); 
let c2 = Composite({wallet: amount: 20});
c1 === c2; // true
c1.wallet.amount+=20;
c1 === c2 // ??
`

[18:07:25.0289] <snek>
i would hope that composites are never mutable

[18:07:28.0772] <snek>
in either case

[18:07:33.0260] <nicolo-ribaudo>
No, those two wallets are different objects, so the composites are different

[18:07:36.0007] <Justin Ridgewell>
You need nested composites, right?

[18:07:38.0167] <Christian Ulbrich>
* so ```
let c1 = Composite({wallet: amount: 20});  
let c2 = Composite({wallet: amount: 20}); 
c1 === c2; // true 
c1.wallet.amount+=20;
 c1 === c2 // ?? 
```

[18:07:59.0060] <nicolo-ribaudo>
But these would be the same:
```
let wallet = Composite({ amount: 20 });
let c1 = Composite({ wallet });
let c2 = Composite({ wallet });
```

[18:08:05.0991] <nicolo-ribaudo>
* But these would be the same:

```
let wallet =({ amount: 20 });
let c1 = Composite({ wallet });
let c2 = Composite({ wallet });
```

[18:08:09.0414] <Justin Ridgewell>
The alternative is `wallet = { amount: 20 }; c1 = Composite({ `‚Ä¶ Nicolo beat me to it.

[18:08:23.0104] <nicolo-ribaudo>
* But these would be the same:

```
let wallet = { amount: 20 };
let c1 = Composite({ wallet });
let c2 = Composite({ wallet });
```

[18:12:11.0659] <keith_miller>
Yeah, 100%

[18:12:22.0238] <Christian Ulbrich>
Mathieu Hofman: We also have current _custom Iterability_ with `Symbol.iterator`.

[18:12:22.0939] <bakkot>
please do not look at the current spec, it means nothing

[18:12:24.0510] <bakkot>
I should remove it

[18:12:38.0595] <Justin Ridgewell>
@olivf.o1o.ch:immer.chat Does V8 have this same problem?

[18:12:38.0871] <keith_miller>
In particular because you have to do n shape checks for each of the different views

[18:12:59.0092] <Justin Ridgewell>
Should we be splitting the methods onto the sepcific TA subtype classes?

[18:13:01.0315] <Mathieu Hofman>
That is ok-ish. The place it shows up in syntax (array spread) was a mistake

[18:13:44.0628] <keith_miller>
Sometimes it will get inlined enough that we can prove only one shape shows up but there's many examples I've seen where that doesn't happen

[18:14:34.0186] <snek>
my memory of v8 is that it generally does a switch over different object kinds. i guess that could be compiled to a bunch of if/else branches but hopefully it does better than 

[18:14:39.0613] <snek>
* my memory of v8 is that it generally does a switch over different object kinds. i guess that could be compiled to a bunch of if/else branches but hopefully it does better than that

[18:15:12.0352] <snek>
which is certainly still some overhead, but its not a function of the number of things you're switching over

[18:15:37.0047] <Christian Ulbrich>
Mathieu Hofman: `Array.prototype[Symbol.iterator] = function* () { yield 2; yield 3; }`

[18:15:45.0211] <keith_miller>
The problem is that you also need to make the index access polymorphic

[18:15:58.0442] <keith_miller>
So it's not just a check you're in bounds and load

[18:16:13.0541] <keith_miller>
It's a switch over the element size then pick the right load for the active size

[18:16:24.0872] <snek>
yeah it remains polymorphic until it can be found to be exactly 1 kind

[18:16:49.0387] <keith_miller>
Right but that wouldn't be a problem if each of the views had their own copy of the various methods

[18:17:35.0801] <Christian Ulbrich>
Mathieu Hofman: What I am trying to say, and I am leaning towards some, what I think Ron said, custom equality is not a bad thing per s√®. We already have so many things in the language, that are powerful.

[18:17:38.0873] <Justin Ridgewell>
Let‚Äôs fix that. Doing something for convenience in the spec is much less important that actual impl difficulties.

[18:18:01.0386] <snek>
its definitely web reality at this point

[18:18:02.0863] <keith_miller>
There's some compatibility risk although I don't know how high it is in practice

[18:18:32.0867] <snek>
i've seen code in the wild using TypedArray.prototype.foo.call

[18:18:53.0340] <snek>
actually i guess that doesn't actually preclude adding more methods

[18:19:04.0110] <keith_miller>
Maybe you could just shadow the current one

[18:19:05.0199] <snek>
* actually i guess that doesn't actually preclude adding more methods on the subclasses

[18:19:19.0585] <keith_miller>
It would be weird but I doubt anyone would really know

[18:20:03.0225] <snek>
we did a similar change moving around where some error properties were located in webkit and chrome and no one noticed

[18:20:16.0293] <Mathieu Hofman>
That's just prototype pollution. Which is a much more general problem. But yeah you could have an array instance with an shadowed Symbol.iterator that does something weird, and I don't like that array spread would be affected by that.

[18:21:29.0626] <bakkot>
I think it is not weird to get custom behavior when spreading an object which happens to be IsArray but which has a custom `Symbol.iterator`

[18:21:58.0076] <bakkot>
as to the Array prototype Symbol.iterator pollution problem, I have a proposal for fixing that!

[18:22:19.0247] <snek>
ah actually it was the opposite direction https://github.com/WebKit/WebKit/commit/96efcf1f1c011efd5946d053272581e0a3d6c3b2 (my only webkit commit üòÑ)

[18:35:35.0208] <Olivier Fl√ºckiger>
What exactly is the spec convenience we are talking about? That they all share a common proto?

[18:35:42.0722] <Christian Ulbrich>
Looks like, _native equality_ comes quite at some cost, of those _interned objects_ not being so _native_ anymore...

[18:39:03.0574] <Justin Ridgewell>
Yah, and the methods are defined on the common proto

[18:40:00.0351] <Justin Ridgewell>
Though apparently index access is also slower than it should be

[18:43:44.0648] <Christian Ulbrich>
Would this be a first for the language? Is there any object, that is specially handled somewhere, somehow, besides being an object, I mean apart from `null`?

[18:43:47.0103] <Olivier Fl√ºckiger>
It's probably not our main worry for TA... But in principle all for not doing convenience in the spec if it makes implementation harder.

[18:46:24.0613] <snek>
also worth mentioning that a lot of TA baggage comes from khronos :P

[18:46:41.0338] <snek>
* also worth mentioning that a lot of TA baggage comes from khronos, not necessarily people making convenient spec decisions :P

[18:48:41.0342] <ljharb>
`document.all`

[18:49:06.0689] <Justin Ridgewell>
khronos?

[18:49:46.0648] <ljharb>
> "Khronos typed arrays" refers to the JavaScript Typed Arrays specification, which was originally developed under the Khronos Group for use in its graphics APIs like WebGL

(google ai summary)

[18:50:20.0258] <snek>
yes they were developed for webgl and later merged into ecma262

[18:50:45.0597] <rkirsling>
that's the origin of all the detachedness f-ery

[18:51:08.0187] <Christian Ulbrich>
ljharb: In what context? This is a DOM API.

[18:52:14.0000] <Justin Ridgewell>
https://tc39.es/ecma262/multipage/additional-ecmascript-features-for-web-browsers.html#sec-IsHTMLDDA-internal-slot

[18:52:28.0207] <Justin Ridgewell>
‚ÄúIs HTML Document Dot All"

[18:52:47.0122] <bakkot>
In the case ljharb describes, where developers know about weirdness or already have something wrong, throwing seems better?

[18:53:07.0883] <snek>
throw as early as possible

[18:53:08.0357] <bakkot>
Like I cannot imagine wanting to leak here, on purpose

[18:53:25.0636] <bakkot>
If someone doesn't know about this they should learn by the language telling them

[18:53:51.0643] <bakkot>
Not by mysterious leaks

[18:53:54.0232] <ljharb>
i mean an alternative would just be, require composites to have at least 1 object

[18:54:03.0957] <bakkot>
That is also terrible 

[18:54:07.0761] <ljharb>
why?

[18:54:17.0964] <snek>
because it breaks them

[18:54:29.0777] <ljharb>
no existing code uses composites, how does that break anything

[18:54:30.0907] <bakkot>
Because you want to be able to use them for, like, pairs of numbers

[18:54:33.0217] <snek>
if you want a composite of primitive types you then need to keep around some special identity object to put in them

[18:54:39.0861] <bakkot>
Coordinates in a map, eg 

[18:54:58.0266] <ljharb>
make one symbol and stick it in every composite

[18:55:31.0744] <bakkot>
That is so bad

[18:55:44.0215] <Christian Ulbrich>
I find waldemar argument convincing. If we have _prior art_ of handling something specifically (although I think the `document.all` to be very _exotic_ (hihi)), then I'd rather prefer a _fail-fast_ approach, then having to accept memory leaks.

[18:55:53.0504] <ljharb>
imo it's far less bad than making some objects not be weakable

[18:56:01.0666] <bakkot>
The benefit of keeping the consistency for weak maps is so, so far from being with the cost of having to do that

[18:56:32.0147] <rkirsling>
IsHTMLDDA is like, one of the most horrifying things in the web platform, to be certain

[18:56:34.0431] <bakkot>
As you already pointed out, weak maps are super niche!

[18:56:34.0566] <ljharb>
to me this all seems to lead back to "they need to be primitives or they shouldn't exist in the language"

[18:56:53.0170] <bakkot>
* The benefit of keeping the consistency for weak maps is so, so far from being worth the cost of having to do that

[18:56:54.0161] <rkirsling>
* document.all is like, one of the most horrifying things in the web platform, to be certain; that's why [[IsHTMLDDA]] is a sort of resentment-coded name

[18:57:20.0219] <ljharb>
we shouldn't commit minor crimes just because the thing we want to add shouldn't be an object but is forced to be one

[18:57:57.0540] <bakkot>
Ok that is a position you could have, but at that point this question does not matter

[18:58:03.0732] <snek>
i don't find weakmaps to be the fundamental primitive by which i decide what a value is. rather weakmap is a somewhat strange api that exposes the reality of values.

[18:58:09.0687] <snek>
* i don't find weakmaps to be the fundamental primitive by which i decide what a value is. rather weakmap is a somewhat strange api /becausae/ it exposes the reality of values.

[18:58:12.0277] <bakkot>
We are talking about what happens assuming that isn't the world we're in

[18:58:42.0597] <Christian Ulbrich>
I have a feeling, that the discussion is very academic. What would be a real-world library using WeakSets that would be easily affected by this?

[18:58:48.0398] <snek>
* i don't find weakmaps to be the fundamental primitive by which i decide what a value is. rather weakmap is a somewhat strange api /because/ it exposes the reality of values.

[18:59:13.0838] <ljharb>
also what would be a real-world application where this would be the biggest memory leak in the app

[18:59:14.0517] <rkirsling>
kinda feel sorry for Yusuke's queue item getting shoved to the bottom

[18:59:18.0284] <snek>
fwiw most use of weak apis do not deal with arbitrary values

[18:59:28.0308] <snek>
* fwiw most use of weak apis do not deal with arbitrary values, they are almost always contained within a single layer of an application

[18:59:33.0609] <snek>
* fwiw most use of weak apis do not deal with arbitrary values, they are almost always contained within a single layer of a codebase

[18:59:43.0473] <Chengzhong Wu>
why is Yusuke's topic kept pushing down the queue?

[19:00:41.0633] <Chengzhong Wu>
* why is Yusuke's topic kept pushing down the queue? feel like new topics are added before Yusuke's

[19:00:53.0411] <bakkot>
Next time we talk about this I vote implementations get priority 

[19:01:22.0684] <Olivier Fl√ºckiger>
We should really not add objects that cannot be collected. Websites running out of memory is really a terrible issue to debug for all parties involved.

[19:01:29.0317] <bakkot>
I care a lot more about what is implementable than about our design opinions unconstrained by implementation reality

[19:07:40.0496] <bakkot>
it is easy to imagine, for example, something which is serializing values to be passed to and from a worker, and uses a WeakMap to cache the serialization, with the serializations happening very frequently (it's a common pattern when splitting some computations to be done off the main thread, for example), and then it starts passing Composites some of the time, and now it is leaking a lot

[19:08:11.0003] <bakkot>
that is an unusually _easy_ example of a leak to track down, and is also very much a thing which would happen with totally normal use of WeakMaps

[19:08:29.0061] <bakkot>
throwing is much, much better here, so that the developer learns that actually WeakMaps do not work for Composites.

[19:41:36.0343] <Aki>
Congratulations to eemeli and Ashley Claymore for being the only speakers yesterday‚Äîincluding myself‚Äîwho made sure the appropriate info was recorded in the notes.

[19:43:52.0368] <Aki>
bakkot, ryzokuken , ptomato , Mikhail Barash , FYT, nicolo-ribaudo , Richard Gibson , dminor , Michael Ficarra , ljharb , and James M Snell : here's what's missing https://kdrive.infomaniak.com/app/share/1777368/c4d6dca3-6847-4674-bf1d-87d2d0370871

[19:45:58.0760] <bakkot>
fwiw speakers generally aren't the ones who add the link to the slides, I don't typically check for that after having done my presentation

[19:46:04.0405] <bakkot>
(usually note takers do)

[19:46:19.0010] <Aki>
Yeah the notes are in _really_ rough shape this meeting. 

[19:46:36.0645] <bakkot>
anyway added slides link to editor update item

[19:47:40.0087] <Chengzhong Wu>
sometimes an agenda item was added without a link to slides. In this case, note takers are not able to add the link for the speakers. Please add the link after done the presentation

[19:48:04.0261] <Chengzhong Wu>
* sometimes an agenda item was added without a link to slides. In this case, note takers are not able to add the link for the speakers in the notes. Please add the link after done the presentation

[19:54:06.0436] <ljharb>
what on earth is kdrive, i was so confused when i wasn't logged in to google sheets and then i realized it wasn't sheets

[20:04:45.0801] <Ashley Claymore>
it jumps to labels: https://github.com/v8/v8/blob/638e32793f854790284bf613eca204550e1c8e56/src/builtins/builtins-collections-gen.cc#L211-L215

[20:06:19.0207] <snek>
that's just an if/else though. i was referring to these more: https://github.com/v8/v8/blob/638e32793f854790284bf613eca204550e1c8e56/src/builtins/builtins-typed-array-gen.cc#L546-L601

[20:06:39.0687] <Mathieu Hofman>
One motivation for them to be objects is to allow them to contain mutable objects. That is not acceptable as primitives

[20:07:52.0078] <Ashley Claymore>
that leaks in a worse and more subtle way. Which is why I don't want the answer to be: every composite must contain something non-forgable

[20:08:27.0687] <Mathieu Hofman>
Membrane style libraries that keep an association from any object to another object they created. We also have a classification library where we'll check the shape of a deeply frozen object and remember the classification.

[20:08:41.0937] <snek>
* that's just a single branch though. i was referring to these more: https://github.com/v8/v8/blob/638e32793f854790284bf613eca204550e1c8e56/src/builtins/builtins-typed-array-gen.cc#L546-L601

[20:09:53.0238] <Ashley Claymore>
I requested during my presentation that we keep the conversation to the slides, and not extend the conversation to a wider conversation. I would rather do that in a separate meeting that specifically talks about that - with prepared slides to reference.

[20:12:08.0479] <bakkot>
it should still be called Semaphore üí¢

[20:13:05.0258] <rkirsling>
it seems like Governor would be a confusingly disconnected name if it's located right on globalThis but not sure whether that's the intent

[20:14:10.0642] <rbuckton>
I think `Semaphore` is the right name, but only if its API is usable both for async coordination and thread coordination (with shared structs), which is certainly feasible.

[20:20:58.0944] <bakkot>
I _think_ the only thing necessary to make it work for thread coordination is for it to be structured-cloneable?

[20:21:11.0570] <bakkot>
with the internal state not being shared not cloned, obviously

[20:21:24.0776] <bakkot>
I guess the spec would require some atomics stuff, probably

[20:21:43.0270] <rbuckton>
No, it wouldn't be structured clonable, it would be shared (just like Mutex, Condition)

[20:21:58.0846] <rbuckton>
Structured cloneable isn't shareable

[20:24:24.0102] <rbuckton>
Ideally it would be the same kind of object as we want Mutex to be (shared with a per-realm prototype). 

[20:24:42.0727] <snek>
structured cloneable includes shared values 

[20:25:21.0912] <rbuckton>
Structured clone requires postmessage. Shareable only requires assignment

[20:25:59.0478] <rbuckton>
You can't assign a structured clonable object to a property on a shared struct, only primitive and shareable values

[20:26:29.0432] <snek>
oh you are referring to a new category of value based on shared struct ok

[20:26:33.0803] <rbuckton>
Yes.

[20:27:03.0417] <bakkot>
sorry, I meant prior to shared structs existing

[20:27:04.0685] <Mathieu Hofman>
You could make it structure clonable, and when we have shared struct redefine is as a shared object, the distinction is not observable without shared structs anyway

[20:27:08.0608] <rbuckton>
Mutex and Condition both fall under this category and are essentially shared structs.

[20:27:12.0469] <bakkot>
we need inter-thread coordination even without shared structs

[20:27:24.0906] <bakkot>
and this proposal will probably go forward before that one

[20:27:32.0378] <rkirsling>
oh, I see "resource governor" is a SQL thing, so that must be the origin of this terminology?

[20:28:08.0117] <rbuckton>
IMO we shouldn't make it structured clonable, we should make it frozen and specially handled in postMessage.

[20:28:10.0624] <snek>
fwiw structured cloneable is a superset of basically everything, except host resources that explicitly can't support it

[20:28:16.0738] <rbuckton>
That would allow us to hedge 

[20:28:58.0859] <rbuckton>
The difference is that something structured clonable will create a *new* instance in another worker thread. A shared thing is the *same* instance in another thread.

[20:29:53.0039] <Ashley Claymore>
https://github.com/v8/v8/blob/638e32793f854790284bf613eca204550e1c8e56/src/builtins/builtins-collections-gen.cc#L1887-L1898 has more branches - haven't looked at exactly what this compiles to - if it's a jump table

[20:29:54.0029] <snek>
is SharedArrayBuffer a sharable value?

[20:30:14.0017] <rbuckton>
No

[20:30:23.0962] <rbuckton>
Unfortunately

[20:30:27.0862] <Andreu Botella (üïë JST, at TC39)>
SharedArrayBuffer is cloned, i.e. posting it back and forth doesn't preserve equality, but it points to a shared internal thing

[20:30:47.0754] <snek>
well then we can make up whatever rules we want in the structured clone algo for "shared" values

[20:31:01.0513] <snek>
but yeah i see your point

[20:32:33.0609] <rbuckton>
Also, Shared Structs is already at Stage 2. Its delays have been mostly been as a result of both champions having major job changes in the past few months.

[20:33:02.0025] <Mathieu Hofman>
Again I maintain that having an object being sharable over postMessage doesn't prevent it from also becoming directly a shared object

[20:33:46.0588] <rbuckton>
I'm hoping to dedicate more time to getting it to Stage 2.7 in the coming year, though ideally I would like someone from V8 to take on @syg's co-champion role as he's indicated he is unable to participate regularly going forward.

[20:33:49.0619] <Mathieu Hofman>
(except maybe for all the exotic SAB stuff)

[20:34:33.0984] <Mathieu Hofman>
rbuckton: you might want to chat with Olivier Fl√ºckiger 

[20:35:54.0151] <rbuckton>
Minor point: The audio coming from the room is very quiet compared to those joining remotely, so I either can barely hear the room or my speakers are blown out by remote attendees depending on who I adjust the audio for. 

[20:36:40.0792] <bakkot>
... huh, audio's fine for me

[20:37:03.0696] <rbuckton>
The issue with structured clone is that a value going from thread A to thread B and back to thread A will not produce the same instance.

[20:37:20.0809] <bakkot>
Seems fine?

[20:37:29.0075] <bakkot>
I don't actually see a reason why that would matter for this.

[20:37:33.0052] <rbuckton>
That isn't what happens for shared structs.

[20:37:37.0989] <bakkot>
... OK?

[20:37:47.0591] <rbuckton>
So if you change it from being cloneable to shareable, that's an observable change

[20:37:50.0700] <snek>
i don't particularly care what structured clone does as long as i get some sort of native shared state out of it, like SAB

[20:38:02.0541] <Rob Palmer>
New topic:  how is the quality of the original transcription for the notes today?  We had quality drop-off at 16:15 yesterday.

[20:38:14.0717] <Mathieu Hofman>
how ?

[20:38:44.0048] <bakkot>
doing fine so far

[20:39:45.0648] <rbuckton>
Correct me if I'm wrong, but you can't currently rely on reference equality for something like SAB bouncing between two threads, can you? \

[20:39:47.0930] <rbuckton>
* Correct me if I'm wrong, but you can't currently rely on reference equality for something like SAB bouncing between two threads, can you?

[20:39:52.0998] <snek>
you can not

[20:40:05.0684] <snek>
and i don't care about it maintaining reference equality

[20:40:08.0857] <rbuckton>
You can rely on reference equality for this case with Shared Structs

[20:40:21.0006] <snek>
i care about it for shared structs, sure

[20:40:48.0547] <rbuckton>
I care about something like `Semaphore` behaving like a shared struct, so maintaining reference  equality.

[20:41:23.0917] <rbuckton>
If it starts out behaving like SAB, we have to be ok with changing that behavior later.

[20:41:46.0405] <snek>
yeah i have no strong opinion over whether it behaves like a shared struct or not

[20:42:11.0854] <snek>
either way it can be shared between threads somehow

[20:42:15.0958] <snek>
that's good enough for me

[20:42:33.0417] <rbuckton>
I think we can work out a solution that hedges towards availability of shared structs.

[20:42:43.0835] <Mathieu Hofman>
right but if you admit there can be multiple objects identities that are back by the same internal thing, all these objects could be shared, it's just you cannot rely on identity to differentiate them, which I don't think is a requirement?

[20:42:52.0554] <Mathieu Hofman>
* right but if you admit there can be multiple objects identities that are backed by the same internal thing, all these objects could be shared, it's just you cannot rely on identity to differentiate them, which I don't think is a requirement?

[20:43:23.0472] <rbuckton>
I think you need to be able to rely on identity.

[20:43:34.0465] <Mathieu Hofman>
what's the use case?

[20:43:38.0570] <rbuckton>
We can't do SAB because it has quirks like this.

[20:43:56.0341] <bakkot>
sorry, who's talking? for the notes

[20:44:05.0045] <Chris de Almeida>
Oli

[20:44:10.0349] <James M Snell>
bakkot: +1 on everything there with AbortSignal... if you want some help on getting that proposal going in WHATWG, I'm more than happy to help

[20:44:19.0042] <rbuckton>
Not having `Semaphore` behave differently than `Mutex` when writing code. It's a major quirk that you would run into regularly.

[20:44:36.0445] <bakkot>
note, thanks, will probably take you up on that

[20:45:35.0612] <rbuckton>
IMO, with structs at Stage 2 we should renew the effort to get that proposal to Stage 2.7 and perhaps we won't run into a timing issue. 

[20:45:49.0594] <jkup>
I'm missing the context around the can of worms / current issues with the state of AbortSignal, is there anything good I can read to get up to speed?

[20:46:14.0889] <rbuckton>
Or we ship this proposal without `CountingGovernor` since it can be implemented in userland until such time as both proposals have hit stage 4.

[20:46:53.0591] <bakkot>
there's a bunch of things, some of it here: https://matrixlogs.bakkot.com/WHATWG/2025-09-25#L18

[20:47:04.0597] <rbuckton>
I can discuss some of my concerns at length after the plenary, if you'd like.

[20:47:10.0294] <bakkot>
just negate all of those bullets and that's how it currently works

[20:47:17.0222] <danielrosenwasser>
Is it just me or do people have wildly different mic volumes today?

[20:47:26.0081] <rkirsling>
that was blastingly loud, yeah

[20:47:33.0892] <Chris de Almeida>
not just you

[20:47:54.0784] <Mathieu Hofman>
rbuckton: I understand how identity preservations is important for actors, but these seem like very specialized tools purely meant to implement low level synchronization, and I fail to understand the use case where identity preservation matters here. I do understand it may be beneficial to in the future share these tools over existing shared object instead of postMessage 

[20:47:55.0486] <danielrosenwasser>
yeah, but a lot of the presenters have had extremely low mics today

[20:47:58.0118] <rbuckton>
bakkot: How is your audio OK? I can barely hear michael with my audio set to a level where Steve Hick's audio doesn't make my ears bleed.

[20:48:14.0704] <bakkot>
maybe my computer or browser is doing some equalization? idk

[20:48:16.0580] <snek>
can you adjust audio per-person?

[20:48:25.0243] <rbuckton>
Not that I can find

[20:49:20.0093] <James M Snell>
I think there's a fair number of folks potentially interested in this discussion. Maybe organizing a call would be worthwhile?

[20:50:59.0299] <Jake Archibald>
bakkot: I'm interested in the abort controller stuff

[20:51:20.0953] <Jake Archibald>
(I'm the original author of the abort controller spec. pls don't hate me)

[20:51:25.0900] <nicolo-ribaudo>
Me too

[20:52:19.0567] <bakkot>
I don't hate you, I just wish you'd given userland the nice behavior that the web platform gets, is all

[20:52:32.0125] <bakkot>
users deserve nice things too

[20:52:36.0204] <Mathieu Hofman>
Kris Kowal has opinions too

[20:53:06.0405] <Jake Archibald>
bakkot: is the behaviour gap documented anywhere?

[20:53:28.0422] <Ashley Claymore>
I just wish AbortSignal wasn't an EventTarget.

[20:53:46.0713] <Ashley Claymore>
But I also use it on the web all the time and thanks Jake Archibald for adding it!

[20:53:50.0765] <bakkot>
lots of random griping on the web, but the best place I've got to hand is https://matrixlogs.bakkot.com/WHATWG/2025-09-25#L18

[20:54:17.0106] <bakkot>
specifically, for the web, you have these things:

- someone manually doing a dispatchEvent on the signal won't trigger your callback
- another listener doing stopImmediatePropagation won't prevent your callback from being triggered
- the callback is automatically released once the signal is aborted
- adding a callback after the signal is already aborted won't do anything (and in particular won't hold a reference to your callback)

users consumers of AbortSignal don't get any of those

[20:54:31.0161] <James M Snell>
Grab the pitchforks everyone... we know who to chase down

[20:54:31.0988] <rbuckton>
I'll admit I've had a number of gripes (some vocal, some not so) with the `AbortController` API, but my biggest frustration was that it felt very rushed out while I was in the middle of trying to get cancellation into the core language.

[20:54:41.0283] <bakkot>
* specifically, for abort listeners added from web machinery instead of userland, you have these things:

- someone manually doing a dispatchEvent on the signal won't trigger your callback
- another listener doing stopImmediatePropagation won't prevent your callback from being triggered
- the callback is automatically released once the signal is aborted
- adding a callback after the signal is already aborted won't do anything (and in particular won't hold a reference to your callback)

users consumers of AbortSignal don't get any of those

[20:55:01.0038] <James M Snell>
I'll put together a doodle poll early next week and post it to get a call set up

[20:55:03.0523] <snek>
if we add EventTarget and DOMException to 262 this becomes a very simple problem to solve

[20:55:09.0885] <ljharb>
what i wish is that abortsignal hadn't been shipped before notifying TC39 that it was happening :-/

[20:55:24.0113] <Michael Ficarra>
https://en.wikipedia.org/wiki/Governor_(device)

[20:55:39.0759] <rkirsling>
whoa

[20:55:48.0307] <rbuckton>
That's precisely one of my gripes.

[20:56:41.0763] <Jake Archibald>
rbuckton: interesting. I was told at the time that cancellation primitives has been abandoned in TC39. Hm.

[20:56:51.0871] <bakkot>
I refuse to write a standard library function which has as one if its steps "and then call `.addEventListener('abort', fn)`"

[20:57:01.0008] <bakkot>
even DOM consumers of AbortSignal don't stoop to that

[20:57:22.0943] <bakkot>
* I refuse to write a standard library function which has as one of its steps "and then call `.addEventListener('abort', fn)`"

[20:57:26.0475] <rbuckton>
Certainly not. See https://github.com/tc39/proposal-cancellation

[20:58:06.0905] <danielrosenwasser>
I feel like `keyCount` reads less awkwardly than `keysLength`.

[20:59:00.0481] <ljharb>
that's a reasonable thing to bikeshed within stage 2 :-)

[20:59:02.0976] <rkirsling>
or generally xsLength -> xCount

[20:59:24.0072] <ptomato>
sign me up for the abort call plz üòÑ

[20:59:37.0898] <Justin Ridgewell>
Promise cancellation as a 3rd state was abandoned, not cancellation

[21:00:35.0179] <Ashley Claymore>
do web-machinery things also remove their listener once their task has finished?
A thing I've come across is: long lived abortSignal with lots of shortLived user tasks and it leaks listeners

[21:00:42.0714] <bakkot>
yes

[21:00:53.0850] <danielrosenwasser>
I think `getOwnPropertyNameCount` is actually worse üòÖ

[21:00:54.0984] <rbuckton>
My major concerns with AbortController were:
- Dependence on DOM-specific eventing/exceptions.
- DOM APIs privileged over user code
- Poor separation of concerns (user listeners for `abort` can be fooled by `.dispatchEvent`)
- No single use `abort` for user code (again, due to `dispatchEvent`)
- No cancellation graphs (somewhat addressed over the years, but not well), so memory leaks abound

[21:00:58.0611] <bakkot>
see https://dom.spec.whatwg.org/#run-the-abort-steps

[21:01:04.0791] <rbuckton>
* My major concerns with AbortController are:

- Dependence on DOM-specific eventing/exceptions.
- DOM APIs privileged over user code
- Poor separation of concerns (user listeners for `abort` can be fooled by `.dispatchEvent`)
- No single use `abort` for user code (again, due to `dispatchEvent`)
- No cancellation graphs (somewhat addressed over the years, but not well), so memory leaks abound

[21:01:11.0602] <James M Snell>
I'm gonna totally lose track of everyone interested in this chat. I'll post the doodle link likely on monday and will send invites to anyone who responds

[21:01:15.0859] <bakkot>
"Empty signal‚Äôs abort algorithms." is the bit which removes existing web-machinery listeners

[21:01:18.0509] <Jake Archibald>
bakkot: The reason AbortSignal uses events is just because that's kinda the standard on the web platform for callbacks. But given there are other benefits to avoiding events, your proposal seems reasonable

[21:01:46.0720] <eemeli>
Almost always when I find a need to call `Object.keys(...).length`, all I really want to know is whether I have an empty `{}` object, or something else.

[21:01:49.0290] <bakkot>
or, wait, I think I read your question backwards?

[21:02:07.0023] <bakkot>
I don't actually know but I don't think it's observable, because the listeners are purely internal

[21:02:33.0546] <rbuckton>
Can you imagine if DOM shipped `Future` using DOM events instead of `then`? IIRC, that wasn't even on the table for `Future` before it was adopted by 262 as `Promise`.

[21:02:54.0133] <Christian Ulbrich>
What is there to be gained? Is this really totally un-optimizable for implementers, if it such a common pattern?

[21:03:05.0424] <Ashley Claymore>
I kinda want abortSignal listener add to have Symbol.dispose 

[21:03:23.0135] <Mathieu Hofman>
TCQ doesn't let me add a reply 

[21:03:42.0111] <jkup>
see Nic's clarifying Q :)

[21:03:46.0757] <ptomato>
hey! I hoist the options bags

[21:03:49.0774] <Michael Ficarra>
yeah this completely perplexes me

[21:04:08.0706] <Michael Ficarra>
refresh? I had to re-auth recently

[21:05:34.0776] <Ashley Claymore>
static interned inline composites could be safely hoisted by tools üòé

[21:05:44.0792] <Jake Archibald>
bakkot: 
> I don't understand why the web platform uses a completely different set of infrastructure for abortables

Web specs never use events internally.

[21:05:49.0979] <Christian Ulbrich>
I mean apart from a theoretical point of view, how often is this used in critical paths?

[21:06:04.0383] <Jake Archibald>
* bakkot:

> I don't understand why the web platform uses a completely different set of infrastructure for abortables

Web specs never listen to events internally.

[21:06:06.0526] <bakkot>
well... but like... why

[21:06:27.0709] <bakkot>
like if it's recognized that web platform should get to use better infrastructure... why doesn't userland get to use better infrastructure?

[21:06:38.0648] <Chris de Almeida>
reply button is back!  üéâ

[21:06:50.0174] <rbuckton>
My proposal originally had something like:
```
class CancelSource {
  constructor(...linkedTokens: CancelToken[]);
  token: CancelToken;
  cancel(): void;
  close(): void;
}
class CancelToken {
  static canceled: CancelToken;
  static none: CancelToken;
  subscribe(cb): CancelSubscription; // disposable
  get canceled(): boolean;
  get canBeCanceled(): boolean;
}
```

[21:06:50.0667] <ljharb>
the many many use cases that ruben and i looked over were definitely not just needing that simple a semantic

[21:07:24.0873] <Jake Archibald>
bakkot: it's not a better vs worse thing. It's the same reason why internal methods are called rather than directly calling exposed interfaces.

[21:08:08.0871] <rkirsling>
this discussion as a whole feels very like, supportive of a problem statement and not a solution, hm

[21:08:25.0153] <bakkot>
it could be using entirely internal methods and still same the same machinery, though

[21:08:29.0101] <snek>
keith_miller: what was that 40% metric specifically?

[21:08:32.0403] <Christian Ulbrich>
so it is about counting keys, properties or symbols and wether they are enumerable or not, how about them configurable? :D

[21:08:35.0345] <eemeli>
Any idea what sort of percentage is testing the value against 0, vs. doing somethign else?

[21:08:56.0519] <bakkot>
there's no reason that AbortController needs to have a separate privileged list of web-platform things to trigger on abort, instead of just adding web-level things to the existing list of callbacks to call

[21:09:00.0528] <Jake Archibald>
bakkot: similar to JS, if you override `globalThis.Array`, that isn't called by internal JS things that create arrays

[21:09:05.0105] <ljharb>
the vast vast majority where it's just counting care about enumerable properties and/or symbols

[21:10:04.0926] <nicolo-ribaudo>
Code that goes through the optimizing compiler

[21:10:05.0873] <bakkot>
I'm not asking about literally doing `.addEventListener`, just about having only a single internal list of things to trigger on abort, instead of having two lists

[21:10:14.0398] <Ashley Claymore>
the one place this does happen (which is evil) is `Array.prototype.toString` dynamically looks up `Array.prototype.join` - not the original.

[21:10:17.0437] <Jake Archibald>
bakkot: basically, it isn't a deliberate choice to give web devs something bad and retain something good for internal use - and taking it to the WHATWG with that as an immutable assumption will get in the way of progress

[21:10:30.0449] <Michael Ficarra>
tip for newcomers: some people find it a bit rude to look ahead on the queue and make assumptions about what somebody is going to say (and pre-reply, putting words in their mouth)

[21:10:38.0728] <keith_miller>
40% of code on internal page loads or Speedometer get to optimizing tiers yeah

[21:10:58.0802] <rbuckton>
* My proposal originally had something like:

```
class CancelSource {
  constructor(...linkedTokens: CancelToken[]);
  token: CancelToken;
  cancel(): void;
  close(): void;
}
class CancelToken {
  static canceled: CancelToken;
  static none: CancelToken;
  get canceled(): boolean;
  get canBeCanceled(): boolean;
  get reason(): unknown;
  subscribe(cb): CancelSubscription; // disposable
  throwIfCanceled(): void;
}
```

[21:11:23.0746] <Jake Archibald>
bakkot: otherwise I understand your proposal and it seems reasonable. I'm just giving context for why things were designed as they were

[21:11:31.0513] <bakkot>
sorry, to be clear I didn't think it was deliberately good for web and bad for users! just that the actual effect of splitting the machinery is that it has had the consequence that the user things are stuck with something with a bunch of bad properties which the web gets to avoid

[21:11:45.0223] <bakkot>
yes, thank you, I appreciate the context

[21:12:01.0399] <Aki>
Infomaniak, swiss hosting

[21:16:44.0564] <rbuckton>
I ended up implementing something like this (`@esfx/canceltoken`, docs here: https://esfx.js.org/esfx/api/canceltoken/canceltoken.html#_esfx_canceltoken_CancelToken_class). It even theoretically works in place of `AbortSignal` on the web as it repurposes an `AbortSignal` instance with custom `[[Prototype]]`.

[21:22:00.0343] <mgaudet|travelling>
chipmorningstar: https://bugzilla.mozilla.org/show_bug.cgi?id=1914502 shallowEquals in react is one of the hottest functions, and uses this pattern 

[21:22:17.0613] <Jake Archibald>
bakkot: It'd be nice to keep `throwIfAborted()`. I guess JS will need an `AbortError`. As long as it passes `err instanceof Error && err.name === 'AbortError'`, that seems fine

[21:23:45.0218] <Christian Ulbrich>
Yeah chipmorningstar I am totally with you. And giving what nicolo-ribaudo said, I think we have to see real usages in the wild with actual numbers in critical paths.

[21:23:51.0343] <rbuckton>
I'd also considered `source.cancel(reason)` so you could cancel with a specific reason, not just `AbortError`.

[21:24:26.0043] <snek>
it can also be `HostCreateAbortError()`

[21:24:54.0343] <Jake Archibald>
rbuckton: `controller.abort()` has that too

[21:25:31.0947] <Jake Archibald>
snek: yeah that's fine, I'd just like there to be a cross-platform way to tell an 'abort' from other things.

[21:25:39.0759] <nicolo-ribaudo>
Can we just have a cancellation protocol (`obj[Symbol.subscribeForCancellation](cb)`), and have web AbortSignal do that? And the web AbortSignal uses the good algorithm for it

[21:25:45.0451] <nicolo-ribaudo>
And then our APIs can just use that protocol

[21:25:53.0594] <Jake Archibald>
rbuckton: https://dom.spec.whatwg.org/#dom-abortsignal-abort

[21:26:20.0904] <rbuckton>
See https://github.com/tc39/proposal-cancellation/issues/22. Back in 2018 the answer ended up being "No"

[21:26:37.0159] <Jake Archibald>
* rbuckton: https://dom.spec.whatwg.org/#dom-abortcontroller-abort

[21:27:41.0356] <nicolo-ribaudo>
The more time passes without a solution happening, the more people need to relax their constraint (if we gree that want some solution to happen)

[21:27:43.0796] <rbuckton>
Jake Archibald: if you haven't seen it, here is the Stage 0 cancellation proposal from 2017: https://github.com/tc39/proposal-cancellation/tree/master/stage0

[21:28:00.0669] <Michael Ficarra>
I don't think the API name (in this proposal's case) is a Stage 2 concern

[21:28:07.0621] <nicolo-ribaudo>
But I don't see in that issue why the answer ended up being no

[21:29:11.0880] <bakkot>
is there a reason to want this to be a symbol-named protocol instead of a string-named protocol? Because my plan was to add a string-named `whenAborted` or something to AbortSignal, which does the good algorithm, and have consumers like Governor do a call to the user-observable `.whenAborted`, which would make it de-facto a protocol 

[21:29:20.0447] <Michael Ficarra>
also percent of spec text that the name occupies does not make one bit of difference

[21:29:24.0597] <bakkot>
I think symbol-named protocols are good for things where you want the protocol implemented on arbitrary objects

[21:29:28.0044] <bakkot>
like iterator

[21:29:34.0079] <bakkot>
but don't see much reason for symbols for cases like this

[21:29:39.0052] <rbuckton>
I'd been working with Domenic Denicola on a solution and ended up being told later that the protocol idea was not going to be accepted and only thing WHATWG would consider would be a host hook.

[21:29:40.0758] <Jake Archibald>
eemeli: do you know why Map & Set don't use `count`?

[21:29:42.0304] <bakkot>
* but don't see much reason for symbol-named protocols for cases like this

[21:29:54.0397] <nicolo-ribaudo>
That the web API already has one way to register, and it can be confusing to have two

[21:29:56.0776] <ljharb>
you think it needs to happen before stage 2?

[21:30:01.0882] <ljharb>
* you think it needs to be decidd before stage 2?

[21:30:02.0917] <rkirsling>
I don't want to object but this really feels premature

[21:30:03.0680] <ljharb>
* you think it needs to be decided before stage 2?

[21:30:06.0292] <nicolo-ribaudo>
Unless we want every of its users to consider the event-based API to be deprecated

[21:30:12.0950] <nicolo-ribaudo>
* Unless we want every of its users to consider the event-based API to be basically considered to be deprecated

[21:30:16.0550] <Michael Ficarra>
@ljharb:matrix.org no I was objecting to @eemeli:mozilla.org's objection

[21:30:18.0361] <nicolo-ribaudo>
* Unless we want every of its users to consider the event-based API tobe deprecated

[21:30:22.0145] <nicolo-ribaudo>
* Unless we want every of its users to consider the event-based API to be deprecated

[21:30:36.0513] <bakkot>
uhhhh yeah that's pretty much what I'm hoping for

[21:30:51.0085] <nicolo-ribaudo>
Then a string-based protocol is good

[21:30:54.0059] <bakkot>
it's got a bunch of footguns so that's desirable anyway

[21:31:07.0779] <rbuckton>
See https://github.com/tc39/proposal-cancellation/issues/22#issuecomment-916548469

[21:32:13.0644] <nicolo-ribaudo>
It seems like the motivation there is that we have a good API on the web and we shouldn't use a second one. Kevin is now saying that it'd be good to provide a second API on the web (which would be good regardless of the ECMA-262 interop)

[21:32:31.0454] <rkirsling>
oh oops I see, I mistook the conclusion. I'm definitely okay with the conclusion Jordan stated

[21:33:10.0029] <eemeli>
No; I don't find their `size`s awkward though. Is the story relevant here?

[21:33:29.0784] <Mathieu Hofman>
One reason why splitting doesn't really make sense to me

[21:33:57.0463] <Jake Archibald>
eemeli: just that it's another word the platform uses for "number of items"

[21:33:59.0106] <Justin Ridgewell>
@rbuckton:matrix.org What was the proposal that prompted you to create Cancellation?

[21:34:08.0297] <Justin Ridgewell>
I remember there being something that needed the ability to cancel

[21:34:11.0352] <rbuckton>
I've always contended that we have a less than adequate API on the web with numerous footguns. We can possibly address the footguns, but that requires deprecating older parts of the API

[21:34:39.0499] <Jake Archibald>
Justin Ridgewell: on the web side, a lot was driven by cancellable fetch

[21:34:58.0468] <rbuckton>
`Promise` and `async function`. 

[21:35:29.0056] <Justin Ridgewell>
Wasn‚Äôt there something more recent than that?

[21:35:39.0167] <Justin Ridgewell>
Those both predate my joining the committee

[21:35:43.0834] <Justin Ridgewell>
I remember there being something

[21:36:08.0714] <rbuckton>
Not really, I started working on the proposal before `async function` was finalized.

[21:36:15.0794] <Ashley Claymore>
A standard CancellationAsyncContext

[21:36:25.0179] <Ashley Claymore>
also if Observables was done in TC39

[21:36:36.0775] <bakkot>
I think this would still count as the same API, just a different way of using it, and fwiw I think domenic agrees er https://matrixlogs.bakkot.com/WHATWG/2025-09-26#L7

[21:36:44.0067] <bakkot>
* I think this would still count as the same API, just a different way of using it, and fwiw I think domenic agrees per https://matrixlogs.bakkot.com/WHATWG/2025-09-26#L7

[21:37:30.0891] <eemeli>
Tbf my stated preference continues to be for `isEmpty`, but `keysLength` rubs me the wrong way because "keys length" is not grammatically correct English.

[21:38:00.0640] <rbuckton>
I'd already been using cancellation in .NET for years, and had an early implementation of `Promise` for JS back in 2015. When `Promise` was proposed for JS, I wanted cancellation for async programming.

[21:39:47.0472] <rbuckton>
I wanted cancellation for `new Promise(init, token)` and `Promise.prototype.then(onfulfill, onreject, token)` as a way to unregister callbacks as a more memory friendly version of `p.then(() => { token.throwIfCanceled(); ... })`. I also wanted it for dynamic `import()`.

[21:40:58.0549] <rbuckton>
What held up cancellation to the point that WHATWG shipped something before we could standardize, was a number of delegates wanting cancellation to be somehow transparent, which I was strongly opposed to.

[21:41:28.0202] <snek>
i don't love cancellation at the promise layer specifically, I think it leads to a footgun of stopping listening when you meant to stop the actual work that is happening, but cancellation in general seems quite nice.

[21:42:58.0315] <rbuckton>
I based that consideration on my experience with .NET's `new Task()` and `Task.ContinueWith()`, which both accept a cancellation token as a way to cancel work up-front and avoid memory leaks due to holding on to closures longer than necessary.

[21:44:44.0795] <snek>
detaching promise callbacks also seems useful

[21:44:56.0955] <rbuckton>
That's the same reasoning why I think `AbortController`/`CancelSource` needs a `close()`/`[Symbol.dispose]()` that unregisters all callbacks, to avoid memory leaks from entire cancellation graphs that can no longer be canceled.

[21:44:57.0217] <Mathieu Hofman>
* One reason why splitting proposals doesn't really make sense to me

[21:45:08.0101] <Justin Ridgewell>
Isn‚Äôt this effectively what `fetch({ signal })` does?

[21:45:44.0293] <snek>
fetch's signal can actually cancel the native operation 

[21:45:57.0240] <Ashley Claymore>
right. the signal should be given to the producer - not the result

[21:46:06.0405] <Ashley Claymore>
promise != task. promise = result

[21:46:27.0413] <Ashley Claymore>
* promise != task. promise == result

[21:46:32.0097] <bakkot>
a Promise is a producer of calls to its `.then` listeners

[21:47:09.0092] <Ashley Claymore>
program-counter++ is a producer of progress

[21:47:27.0874] <nicolo-ribaudo>
The .then callback can do actual significant work

[21:47:47.0418] <rbuckton>
Ignore the names. A .NET `Task` is virtually the same as a JS `Promise`. The only difference is that a .NET `Task` can delay starting.

[21:48:02.0180] <Ashley Claymore>
that's a big difference

[21:48:06.0001] <rbuckton>
In .NET, a `Task` generally represents an eventual result.

[21:48:41.0996] <rbuckton>
Yes, but in the Venn diagram if Task and Promise, Task covers Promise entirely.

[21:48:51.0003] <Ashley Claymore>
an `async function` that was lazy would have been very different

[21:48:51.0435] <rbuckton>
* Yes, but in the Venn diagram of Task and Promise, Task covers Promise entirely.

[21:49:11.0142] <Justin Ridgewell>
I think you‚Äôre confusing promise `p1` and the callback‚Äôs returned result `p2` in `p2 = p1.then(() => work())`

[21:49:20.0687] <Ashley Claymore>
I agree that tasks have results

[21:49:28.0585] <snek>
my concern is when people write `fetch(url).then(cb, { signal })` instead of `fetch(url, { signal }).then(cb)` these do very different things while being very similar

[21:50:11.0488] <snek>
I also I think both use cases are valid 

[21:50:19.0277] <Ashley Claymore>
I'm saying that even though a task can be a promise, that doesn't mean it's better. Restrictions are powerful

[21:50:26.0282] <keith_miller>
@erights Mark Miller (Agoric) MM: IIRC, you had strong opinions on WeakRef and the [[KeptValues]] list. Do you have thoughts on relaxing the behavior to match JSC in https://bugs.webkit.org/show_bug.cgi?id=301334.

[21:50:57.0068] <Aki>
Perhaps TG1 & WHATWG could take some inspiration from TG2 & W3C I18N: TG2 stage advancement requires _asking_ for a horizontal review from W3C I18NWG, but does not require _receiving_ it

[21:51:18.0552] <keith_miller>
TL;DR JSC only keeps the target alive as long as there exists some WeakRef that has `deref()`ed the target this cycle is still alive

[21:51:18.0843] <nicolo-ribaudo>
How do I add myself to the end of the queue?

[21:51:24.0273] <rbuckton>
Imagine a .NET `Task` being something like:

```js
function Task(init, opts) {
  if (opts?.delay) {
    const { promise, resolve, reject } = Promise.withResolvers();
    promise.start = () => init(resolve, reject);
    return promise;
  }  
  const p = new Promise(init);
  p.start = () => {};
  return p;
}
```

[21:51:32.0638] <nicolo-ribaudo>
It keeps inserting my topic before James's

[21:51:57.0575] <jkup>
It's been doing that all day, that is *not* the normal behavior, right?

[21:52:13.0066] <nicolo-ribaudo>
It's now TCS instead of TCQ

[21:52:34.0926] <jkup>
People who submit New Topic's early during the presentation are kept at the bottom and often don't get to speak

[21:53:00.0147] <ljharb>
splitting them doesn't change that all the names will have to be consistent full stop

[21:54:36.0606] <Mathieu Hofman>
is this an observable difference?

[21:54:46.0930] <Mathieu Hofman>
(didn't read the issue yet)

[21:54:54.0686] <Mathieu Hofman>
let's chat on the break

[21:56:20.0188] <keith_miller>
Only when you have two WeakRefs that point to the same target. My thinking is that's probably impossible to mentally model that two WeakRefs point to the same target correctly anyway.

[21:56:56.0212] <keith_miller>
I also think (once you know the GC of a given engine) that the current behavior is a communications channel

[21:57:30.0248] <Mathieu Hofman>
So we're admitting we want the other methods? The `Count` suffix for the longer Object methods don't read well to me. Advancing keys separately opens the risk it advances with Count

[21:57:51.0646] <Mathieu Hofman>
* So we're admitting we want the other methods? The `Count` suffix for the longer Object methods don't read well to me. Advancing keys separately opens the risk it advances as keyCount

[21:57:54.0818] <ljharb>
it doesn't

[21:58:05.0850] <bakkot>
I am admitting no such thing

[21:58:07.0937] <ljharb>
keysX won't advance with any X that wouldn't also be palatable for all the other methods

[21:58:17.0672] <ljharb>
* keysX won't advance with any X that wouldn't also be palatable for all the other methods, that would violate the "cross-cutting concerns" part of stage 2

[21:58:28.0156] <ljharb>
* keysX won't advance with any X that wouldn't also be palatable for all the other methods, that would violate the "cross-cutting concerns" part of stage 2 (whether we have the other methods eventually or not)

[22:03:11.0482] <sffc>
I wrote out an example of loading JSON with ESM and non-UTF-8 encodings at https://github.com/eemeli/proposal-import-text/issues/6. It has the behavior I described yesterday: early error, triggered by syntax.

I also collected some examples of prior art: https://github.com/eemeli/proposal-import-text/issues/5#issuecomment-3550911025

[22:03:42.0501] <Michael Ficarra>
@sffc:mozilla.org I don't think that makes a difference

[22:04:52.0895] <Michael Ficarra>
there are occasions when you *won't* get an early error, even though you have the wrong encoding, so any warning you want to convey to hosts about mismanaging the encoding for text also applies to JSON because it's the exact same error

[22:05:23.0151] <Michael Ficarra>
and we don't have such a warning about JSON, and I don't think we need it

[22:06:17.0364] <bakkot>
the `encoding` option doesn't make sense here because there is no reason to assume the resource is backed by bytes from the perspective of the importing machiner

[22:06:20.0259] <bakkot>
* the `encoding` option doesn't make sense here because there is no reason to assume the resource is backed by bytes from the perspective of the importing machinery

[22:06:30.0705] <Eli Grey>
MIME types could include a universal `codecs` sub-parameter or similar

[22:06:40.0481] <bakkot>
that assumption is true in e.g. HTML, but whatwg is pretty dogmatic these days about interpreting any text over the wire as UTF-8 in any new APIs, so I don't think they'd be on board with allowing specifying any other encoding anyway

[22:06:48.0305] <nicolo-ribaudo>
Could HTML only support UTF-8, but throw if it detects somehow a non-UTF-8 encoding?

[22:06:58.0098] <Eli Grey>
and we could add a way to include the expect mime type

[22:07:22.0045] <nicolo-ribaudo>
The Content-Type header is already mime type + charset

[22:07:23.0891] <Eli Grey>
* and we could add a way to include the expected mime type

[22:07:46.0580] <Eli Grey>
that's what i meant; re-using that if possible

[22:08:45.0410] <nicolo-ribaudo>
Btw, the scope of the proposal in TC39 is "if an import with type:text succeeds, it must return a string". HTML doesn't actually need our proposal to do type:text, our proposal just prevents returning random stuff there

[22:14:51.0725] <bakkot>
nicolo-ribaudo: are there slides for your "Module-declarations-like proposals in other areas of the web platform" topic? it sounds interesting but I might be asleep

[22:15:17.0326] <nicolo-ribaudo>
I recently added them to the agenda

[22:15:37.0216] <bakkot>
oh nice, just hadn't refreshed

[22:16:05.0125] <nicolo-ribaudo>
It's mostly code snippets though, I was planning to just say the descriptions out lound

[22:21:41.0627] <ljharb>
https://tc39.es/proposal-object-keys-length/, thanks eemeli and james

[22:24:53.0393] <James M Snell>
Spec text lgtm

[22:26:18.0464] <Michael Ficarra>
I'm gonna be real upset if this presentation doesn't mention call stack limit

[22:27:53.0881] <Chris de Almeida>
it does not

[22:28:13.0750] <Ashley Claymore>
or arguments limit

[22:29:06.0579] <Ashley Claymore>
there used to be a limit of unique `Symbol.for` calls in v8 but I think that's fixed now

[22:29:35.0718] <Richard Gibson>
strings have a limit of 2**53 - 1 code units, but what happens when trying to exceed that is not specified: https://github.com/tc39/ecma262/issues/2623

[22:30:13.0060] <Ashley Claymore>
and engines fail before getting to that length too right

[22:30:18.0199] <Ashley Claymore>
* and some engines fail before getting to that length too right

[22:31:54.0852] <Richard Gibson>
all of them; it's a big limit

[22:34:30.0023] <snek>
i don't know how we can discuss any of these questions without a more concrete problem 

[22:34:31.0314] <snek>
like

[22:34:43.0090] <snek>
basically every single expression in js can cause an oom

[22:35:04.0000] <snek>
what is the scope here

[22:35:31.0262] <ljharb>
i think it's less about avoiding OOMs and more about, in the presence of sufficient memory, knowing what ranges are guaranteed vs impossible vs "up to the implementation"

[22:35:52.0453] <snek>
what is sufficient memory 

[22:35:57.0039] <Chris de Almeida>
it's an open-ended discussion

[22:36:45.0693] <Andreu Botella (üïë JST, at TC39)>
assume infinite memory

[22:36:52.0106] <Andreu Botella (üïë JST, at TC39)>
also assume a spherical frictionless cow

[22:36:59.0241] <snek>
well now we don't need any limits

[22:37:25.0199] <Chris de Almeida>
yes, I have proposed exactly that in TDZ

[22:37:34.0045] <Michael Ficarra>
IMO it would be nice to have the spec define minimum upper bounds

[22:37:47.0548] <Michael Ficarra>
otherwise how are you supposed to program this crazy machine?

[22:38:06.0406] <Chris de Almeida>
you will immediately have non-conformant impls, no?

[22:38:26.0965] <Michael Ficarra>
MIMUMUM upper bound

[22:38:33.0319] <Michael Ficarra>
* MINIMUM upper bound

[22:38:34.0995] <snek>
so like if a system doesn't have enough memory for that, and it can't throw a rangeerror up front, it has to just oom?

[22:38:40.0218] <Rob Palmer>
test262 implicitly defines certain minimum limits - maybe those could be turned into spec limits to make them explicit

[22:38:51.0896] <Christian Ulbrich>
having a non-orientable surface, too?

[22:38:57.0846] <Michael Ficarra>
it should never even start if it can't support the minimums

[22:39:13.0966] <bakkot>
test262 has some quite expensive tests which are skipped even on production-grade engines

[22:39:51.0345] <snek>
> Moddable XS has a minimum RAM requirement of approximately 6-7 KB for a basic virtual machine

[22:40:06.0942] <bakkot>
https://github.com/v8/v8/blob/37adb436086fca29284fea8b8440bcda73bbb0fb/test/test262/test262.status#L393

[22:40:34.0454] <keith_miller>
Summary of my chat Mathieu Hofman  was that changing this seems not-insane so maybe we should think deeper thoughts about this

[22:40:59.0531] <Michael Ficarra>
For example, I make function calls with more than 1 argument sometimes. For some number of arguments N (N > 1), it's unsafe to do that because browsers may OOM. As a programmer, I'd like to know that my argument list length is less than N so that won't happen.

[22:41:10.0471] <mgaudet>
@erights Mark Miller (Agoric) MM: I should note that one of my current background tasks is investigating exactly this change 

[22:42:29.0479] <eemeli>
The function body is fine, but the name is not: It needs to unpack into something that's valid English, and "keys length" is not.

[22:42:46.0867] <bakkot>
this number depends on the current size of your stack, so, good luck with that

[22:43:38.0564] <Michael Ficarra>
fair, I guess this is a more difficult limit than some of the others

[22:43:59.0050] <rkirsling>
honestly you could make N=5 there and just encourage people to write nicer code

[22:44:42.0823] <rkirsling>
oh wait I'm thinking of formal params and not concrete args

[22:44:43.0781] <bakkot>
`array.push(...vals)` is nice!

[22:44:52.0225] <rkirsling>
yeah, never mind

[22:45:09.0794] <bakkot>
oh yeah we should limit you to 5 formal parameters, I'm on board with that

[22:45:23.0675] <bakkot>
we have a function in our codebase which takes 13 and I feel bad every time I look at it

[22:47:14.0584] <Michael Ficarra>
I don't feel very bad about functions with excessively long parameter lists, in the same way I don't feel very bad about variables with excessively long names

[22:47:32.0799] <Michael Ficarra>
some things are just complicated and pretending otherwise just makes things worse

[22:48:27.0964] <Christian Ulbrich>
Yeah, but **13** params!

[22:48:44.0353] <Michael Ficarra>
I can count to 13

[22:48:51.0673] <Richard Gibson>
https://en.wikipedia.org/wiki/Sorites_paradox

[22:49:15.0005] <Christian Ulbrich>
How? I only have 10 fingers!

[22:49:35.0664] <bakkot>
your parents didn't teach you to count binary on your fingers?

[22:50:39.0103] <Christian Ulbrich>
My dad showed me how to open a beer bottle with my <dev>eye hole</del> basically anything. We had nothing!

[22:50:55.0834] <ljharb>
10 fingers and 10 toes, that should get you up to base 20

[22:51:00.0047] <Ashley Claymore>
Chrome doesn't seem to kill the whole agent. If I OOM in a web worker in chrome, only the worker crashes

[22:51:11.0896] <Ashley Claymore>
the fail fast proposal was the whole agent cluster right?

[22:51:13.0963] <Christian Ulbrich>
* My dad showed me how to open a beer bottle with my <del>eye hole</del> basically anything. We had nothing!

[22:51:21.0383] <Mathieu Hofman>
yes

[22:51:28.0120] <rbuckton>
count each knuckle too

[22:51:35.0064] <Mathieu Hofman>
* yes, because of SAB

[22:52:22.0796] <Ashley Claymore>
I suspect that's likely the disagreement that @erights Mark Miller (Agoric) MM was remembering

[22:52:29.0124] <Ashley Claymore>
as a guess

[22:53:22.0252] <Mathieu Hofman>
might be able to say only crash the set of agents that have a SAB shared with

[22:53:39.0825] <Ashley Claymore>
crashing the main thread is the bad one

[22:53:50.0800] <Ashley Claymore>
as that's where the website is

[22:53:53.0206] <Mathieu Hofman>
but I also remember something about the OS killing interfering with that

[22:53:53.0800] <Ashley Claymore>
:D

[22:54:56.0693] <Mathieu Hofman>
if the main thread shares a SAB with a worker that failed, it's likely unsafe to let it continue

[22:55:14.0967] <bakkot>
yeah but as a user I prefer that to my whole tab crashing

[22:55:43.0089] <Ashley Claymore>
if the website is a random blog post, I don't want it to crash even if the analytics library has a bug

[22:55:43.0777] <Mathieu Hofman>
as a user you like your applications to misbehave ?

[22:55:47.0048] <James M Snell>
OOM's in V8 can be problematic. They do have a host hook to handle them but new OOM paths that crash instead of using the hook pop up a lot. In workers we have to actively watch out for these since we have thousands of isolates all in the same process... crashing hard is not really an option.

[22:55:56.0987] <Ashley Claymore>
when it's not critical, yes

[22:56:04.0475] <Michael Ficarra>
do you? the alternative might be that the JS can now read uninitialised/reclaimed memory

[22:56:17.0927] <Ashley Claymore>
some bugs in games actually lead to fun qwirks

[22:56:24.0554] <bakkot>
I like my applications to not crash more than I care about them maintaining arbitrary other invariants, yes

[22:57:01.0078] <bakkot>
there are very few webpages that I use where I would prefer a page crash over the sort of bugs likely to arise from a worker crashing, even a worker with access to a SAB

[22:57:10.0868] <Chengzhong Wu>
if the web page is show your wallet balance, and the balance is incorrect rather than crashing due to worker failure, it would cause human panic I think

[22:57:36.0393] <bakkot>
it is true that there are some very few applications where a crash is preferable, but they are _very_ few

[22:58:07.0922] <ljharb>
ooh isn't that how some cultures did base 4 or 8 or something?

[22:58:15.0727] <James M Snell>
server side there are way more cases where crash is absolutely preferable

[22:58:48.0974] <Mathieu Hofman>
we very much advocate for a host hook. I didn't understand yusukesuzuki 's point because I would think host hooks are not affected by JS heap limits (unless they themselves decide to delegate to JS)

[22:58:56.0308] <James M Snell>
often way better to just crash, throw away current state, then start fresh

[22:59:19.0192] <Olivier Fl√ºckiger>
I mean you can always catch RangeError and terminate the process in node when you get it, not?

[22:59:43.0647] <yusukesuzuki>
Ah, sorry for misleading. I was mentioning to delegating to user defined logic after that.

[23:00:14.0271] <Mathieu Hofman>
And those webpage cannot be simply reloaded? I mean what page hold important state that would suffer and yet can sustain corruption ?

[23:00:27.0853] <James M Snell>
yeah, our host hook for OOM definitely does not defer to user code. We actually hard terminate the isolate and force a cold start fresh

[23:00:28.0590] <yusukesuzuki>
But also, if it is coming from system allocator exhausting memory, it is hard to guarantee that the handler can work safely too.

[23:00:38.0120] <Mathieu Hofman>
* And those webpage cannot be simply reloaded? I mean what page hold important state that would suffer from a reload and yet can sustain corruption ?

[23:01:37.0740] <Mathieu Hofman>
no because other code might catch it before it reaches the process handler

[23:01:45.0640] <Mathieu Hofman>
* no because other code might catch it before it reaches the process unhandled handler

[23:02:17.0831] <Olivier Fl√ºckiger>
sure, but if it catches it then it takes responsibility to correctly handle it.

[23:04:05.0023] <James M Snell>
Yes, but there are, of course, cases where we just can't let the user code do that. Lots of cases where "correctly handle it" *is* a hard crash and cold start

[23:04:23.0385] <Mathieu Hofman>
lib A trigger OOM and let it throw, lib B made the call to lib A and handles the thrown error. lib A is now in inconsistent state. App has no clue of what happened

[23:05:54.0282] <Olivier Fl√ºckiger>
B should not have caught it if it can't ensure A stays consistent. How is that different from any other exception that is thrown by A.

[23:06:33.0698] <Mathieu Hofman>
yeah B shouldn't, lots of code out there doing things it shouldn't, and inflicts pain on the rest of the app

[23:06:45.0336] <James M Snell>
Unfortunately not that straightforward. some frameworks unconditionally catch in an attempt to be "helpful"

[23:07:12.0546] <Christian Ulbrich>
Looks like we need uncatchable Errors in JS too.

[23:07:20.0498] <Olivier Fl√ºckiger>
sure, but now you want a crash on all errors proposal?

[23:08:09.0930] <James M Snell>
oh no no ... never that. just don't want an All Failures Are Catchable proposal

[23:08:17.0704] <Mathieu Hofman>
we did advocate for a userland `panic()`. We are concerned about situations where invariants go out the window

[23:09:01.0896] <rkirsling>
ooh interesting, I did not see this on the agenda

[23:11:44.0225] <Olivier Fl√ºckiger>
I see. I still think that websites seem to be doing fine with handling range errors.

[23:12:24.0382] <James M Snell>
Websites yeah, I agree that's different. I'm largely thinking about server-side cases

[23:13:14.0904] <Mathieu Hofman>
web apps "think" they're doing fine, but they really have no clue. web sites could just reload

[23:17:07.0046] <sffc>
Right, I acknowledge this in my post. With non-UTF-8 JSON imports, you get an error _sometimes_: almost always when the source encoding is utf16, and occasionally when the source encoding is latin1. However, with non-UTF-8 Text imports, you get an error _never_. Sometimes is better than never.

[23:19:23.0511] <ljharb>
why would it necessarily be an error case tho

[23:20:32.0896] <sffc>
Sure, but some expressions are much more likely to cause an OOM than others.

[23:21:15.0068] <snek>
right that was my point

[23:21:37.0536] <snek>
that i thought the whole topic is too vague 

[23:22:11.0179] <ljharb>
* shane, why would it necessarily be an error case tho?

[23:23:21.0641] <James M Snell>
definitely needs to be grounded a bit more. there's lots of nuance that gets lost without more detail

[23:26:01.0854] <rkirsling>
wait, we have 50 min of topic left for 35 min of day?

[23:26:14.0582] <rkirsling>
* wait, we have 50 min of topic left for 30 min of day?

[23:27:50.0824] <mgaudet>
Huge props to everyone who does note-taking. The transcription can be _very hard_ to follow sometimes! 

[23:31:28.0444] <sffc>
Right, I agree with this type of sentiment. Ideally, I think the spec authors should use their judgement to decide a minimum for these things (such as length of a bigint/amount). An engine _could_ throw errors for anything that would exceed the minimum and be compliant and also be able to run 99.9% of programs. But, engines are permitted to allow more than that.

[23:32:49.0909] <Chengzhong Wu>
the schedule says we have 15min overflow

[23:34:35.0251] <snek>
i'm still just like... you can make usable bigints in v8 that are larger than the entire minimum heap size for xs. so do we set the minimum really really low? if the minimum is too low it becomes kind of useless

[23:34:57.0426] <snek>
* i'm still just like... you can make usable bigints in v8 that are larger than the entire minimum heap size for xs. so do we set the minimum really really low? if the minimum is too low it loses the point for having it

[23:35:43.0994] <Justin Ridgewell>
Ok `for (const el of divergences) { ‚Ä¶; break; }` would be `first` mode.

[23:35:48.0784] <Justin Ridgewell>
* Or `for (const el of divergences) { ‚Ä¶; break; }` would be `first` mode.

[23:36:53.0204] <sffc>
One of the things I was hoping to get out of the discussion today was just this. My position is that the spec should be more explicit when it comes to acknowledging implementation constraints. But, _where_ or _under what conditions_ should the spec be more explicit? This was question 1: "Under what circumstances should an implementation-defined limit be preferred over a spec-defined limit, and vice versa?"

[23:37:55.0813] <snek>
this is why i mentioned that it would be helpful to have a more concrete problem statement.

[23:38:08.0877] <snek>
like some sort of program you want to write but can't due to platform divergence 

[23:39:08.0911] <James M Snell>
yep, understood. unfortunately I think it's too hard to talk about the general case. I think likely best to focus on a smaller set of specific cases with a definitive problem statement, then try expanding whatever decision we make there out to the other cases

[23:39:29.0766] <snek>
one example given was arr.push(...other)

[23:40:08.0189] <snek>
i would generally not write that code because i would assume it would throw somewhere

[23:40:12.0903] <ljharb>
or to close the iterator (if that matters) `divergences.take(1).next().value`

[23:40:14.0044] <snek>
so that could be something to explore

[23:40:54.0278] <snek>
but a solution to that could be adding array.extend rather than setting a minimum number of arguments

[23:40:58.0994] <snek>
i don

[23:41:14.0408] <snek>
* i'm not pushing for anything in particular here, just pointing this out as an example

[23:42:01.0929] <sffc>
My "problem" is that I am an implementer and I want to write code that can make assumptions about how big a thing can be. I don't want to be forced to write code that is less efficient for the 99.9% case because the spec requires me to keep growing until I panic.

[23:42:36.0977] <snek>
do you have examples of this less efficient code?

[23:42:53.0236] <Justin Ridgewell>
Does `take()` close immediately, or during the next `.next()` (that returns `{ done: true }`)

[23:44:00.0024] <sffc>
Yes, for example, I have the metadata of ICU/ICU4X decimals bitpacked into a u32, because I am able to make assumptions about how big the number can be.

[23:44:36.0602] <ljharb>
i think on the `next()`

[23:44:50.0580] <snek>
you mean to fit safely into the bitwise safe range of js?

[23:44:58.0074] <sffc>
On the GitHub post, I show that importing a UTF-16 JSON file currently triggers a SyntaxError.

[23:45:02.0584] <snek>
* you mean to fit into the bitwise safe range of js?

[23:45:18.0981] <ljharb>
right but i mean, if i'm choosing to import utf-16 text. why would that necessarily be an error

[23:45:29.0144] <snek>
* you mean to fit into the bitwise safe range of js numbers?

[23:47:33.0131] <rkirsling>
I have to agree that this presentation seems very "solution before problem statement"

[23:51:50.0110] <ljharb>
deep-equal has 23m downloads a week and that's just one package this proposal would obsolete. dequal has 28m.

[23:52:06.0076] <Justin Ridgewell>
I think this would actually work if the chars were > 256 code units

[23:52:24.0971] <Rob Palmer>
The repo leads with the problem statement, but this presentation does not.

[23:52:32.0000] <nicolo-ribaudo>
But " and { are not, right?

[23:53:41.0965] <Justin Ridgewell>
Correct, so you can‚Äôt use `‚Äù`. But you could use `0x22 ‚Ä¶`

[23:53:49.0950] <Justin Ridgewell>
The problem is `‚Äù` writes `0x00 0x22`

[23:53:58.0717] <Justin Ridgewell>
* The problem is `‚Äù` writes `0x22 0x00`

[23:54:16.0672] <Justin Ridgewell>
And the JSON parser will error on that unescaped nil char (because it‚Äôs a control char)

[23:54:28.0055] <nicolo-ribaudo>
You need a " at the beginning and one at the end

[23:54:34.0060] <nicolo-ribaudo>
So one of the 0x00 will be out of the quotes

[23:54:37.0818] <Justin Ridgewell>
No, you need `0x22` at the beginning

[23:54:41.0700] <Justin Ridgewell>
That will open the string

[23:54:51.0782] <Justin Ridgewell>
The problem is the `0x00` that immediately follows

[23:54:53.0460] <nicolo-ribaudo>
But then you need to close the string

[23:55:08.0012] <Justin Ridgewell>
That‚Äôs also possible with a high code unit char

[23:55:42.0109] <nicolo-ribaudo>
Oh you are saying if JSON was not ASCII-based for its separators?

[23:55:49.0887] <Justin Ridgewell>
With 100% confidience, I can fool this JSON parser using utf16-le

[23:55:58.0097] <sffc>
My position is that spec authors should decide whether such bigints are _useful_. The minimum shouldn't be "too low". The authors are in a better position to communicate that than implementers who want to make assumptions to improve memory use or performance.

[23:56:15.0397] <Justin Ridgewell>
It will parse, it won‚Äôt result in code points that the input actually feeds it

[23:56:51.0462] <Justin Ridgewell>
I just need to feed it a byte stream that can parse when interpreted as UTF-8.

[23:57:09.0205] <Justin Ridgewell>
That‚Äôs completely possible within utf16-le.

[23:57:18.0525] <Christian Ulbrich>
ljharb: But only if we are to standardize the same equalityAlgorithm as deepEqual. There are several mechanisms for deepEquality, as presented before.

[23:57:30.0180] <nicolo-ribaudo>
What would the bytes be? If you have a string you need to close it. The string `""` encoded as UTF-16 would result as either 0x22-0x00-0x22-0x00 or 0x00-0x22-0x00-0x22, which when decoded as UTF-8 is either `"\0"\0` or `\0"\0"`, both of which have a 0x00 out of the quotes

[23:57:37.0889] <Christian Ulbrich>
* ljharb: But only if we are to standardize the same equalityAlgorithm as deepEqual. There are several algorithms for deepEquality, as presented before.

[23:57:45.0899] <nicolo-ribaudo>
* What would the bytes be? If you have a string you need to close it. The text `""` encoded as UTF-16 would result as either 0x22-0x00-0x22-0x00 or 0x00-0x22-0x00-0x22, which when decoded as UTF-8 is either `"\0"\0` or `\0"\0"`, both of which have a 0x00 out of the quotes

[23:57:51.0638] <sffc>
This might be true and is why I used the language "almost always" instead of "always" for utf16le causing a SyntaxError to be thrown

[23:57:53.0133] <Justin Ridgewell>
You cannot use the literal chars `‚Äù` or `{`/`}`.

[23:57:54.0166] <ljharb>
i maintain at least 2 of them. but it's not actually all that important in practice which one is chosen imo, since they all check similar things

[23:58:24.0193] <nicolo-ribaudo>
Ok, then you can only do either numbers or booleans

[23:58:29.0450] <nicolo-ribaudo>
Both of which use ASCII characters

[23:58:32.0067] <Justin Ridgewell>
But there are other code points that emit the _bytes_ `0x22`, `0x7b`/`0x7d`

[23:58:47.0364] <Justin Ridgewell>
Again, it‚Äôs an arbitrary byte stream being misinterpreted

[23:58:51.0966] <Justin Ridgewell>
I control the byte stream

[23:58:55.0400] <nicolo-ribaudo>
Oh you are not saying something that is both valid JSON when decoded as UTF-8 and UTF-16, just different results?

[23:59:04.0242] <nicolo-ribaudo>
* Oh you are not saying something that is both valid JSON when decoded as UTF-8 and UTF-16?

[23:59:14.0364] <Justin Ridgewell>
It won‚Äôt be valid JSON in UTF-16

[23:59:25.0626] <nicolo-ribaudo>
Ok then I do not disagree

[23:59:48.0880] <nicolo-ribaudo>
But it seems very unlikely that you try to import as JSON that was not meant to be JSON, and it randomly happen to work due to using the wrong encoding

[23:59:49.0393] <sffc>
You mean it won't be valid JSON in UTF-8?

[00:00:00.0206] <nicolo-ribaudo>
* But it seems very unlikely that you try to import as JSON something that was not meant to be JSON, and it randomly happen to work due to using the wrong encoding

[00:00:00.0578] <Justin Ridgewell>
I‚Äôm saying the opposite.

[00:00:25.0457] <Justin Ridgewell>
I can craft a utf16-le byte stream that will be valid JSON when interpreted as UTF-8. It will be invalid when interpreted as UTF-16.

[00:00:54.0647] <Justin Ridgewell>
I‚Äôm saying that the JSON parser is not actually enforcing UTF-8 encoded input, it‚Äôs just a dumb byte parser

[00:01:15.0994] <Justin Ridgewell>
Whether the stream is actually UTF-16 or UTF-8 is up to the implementer to decide

[00:02:06.0674] <sffc>
ok, yeah. You have UTF-16 that, if interpreted as UTF-8, happens to form syntactically valid JSON. But, if you were to convert the UTF-16 to code points and then to UTF-8, you would get something that is not valid JSON. I agree that such cases exist.

[00:02:35.0104] <Justin Ridgewell>
Correct

[00:09:08.0533] <Zb Tenerowicz (ZTZ/naugtur)>
> <@nicolo-ribaudo:matrix.org> But it seems very unlikely that you try to import as JSON something that was not meant to be JSON, and it randomly happen to work due to using the wrong encoding

Unless the author of the file intended for that to happen. But to support your point, there's little to gain with that beyond an error being thrown

[00:13:10.0031] <Richard Gibson>
which JSON parser is just consuming bytes? The ECMA-262 ParseJSON operates on a sequence of code points (which it gets from interpreting an ECMAScript string as UTF-16 per the normal convention). And even a hand-rolled one would implicitly interpret raw octets as something, be that ASCII, a UTF, EBCDIC, etc.

[00:14:24.0293] <Justin Ridgewell>
It‚Äôs not, per Shane‚Äôs comment. It‚Äôs interpreting it as a UTF-8 byte stream

[00:14:49.0054] <Justin Ridgewell>
* It‚Äôs not, per Shane‚Äôs issue. It‚Äôs interpreting it as a UTF-8 byte stream

[00:24:12.0364] <Jacob Smith>
I skipped the problem statements presented last time because they were already agreed last time; the proposal itself was blocked by its dependency on its sibling proposals. That dependency is now removed.

This presented a refinement on a potential solution based on quite a lot of feedback from delegates.

[02:12:54.0215] <sffc>
> <@sffc:mozilla.org> Yes, for example, I have the metadata of ICU/ICU4X decimals bitpacked into a u32, because I am able to make assumptions about how big the number can be.

Also, another key example where a spec limit definitely impacts implementation constraints is the max Temporal date.

