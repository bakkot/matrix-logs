2025-08-01
[11:30:49.0200] <Michael Ficarra>
> <@abotella:igalia.com> it'd be a shame to not have that be captured properly

Isn't that the correct way to capture it in the notes? "This is ZTZ, also know as ZTZ or ZTZ online, but you can call him ZTZ".

[11:42:52.0526] <styfle>
Where can I read the notes?

[11:43:44.0922] <Andreu Botella>
they're linked in the Reflector issue


2025-08-04
[21:23:13.0255] <bakkot>
```
function safePromiseCapability() {
  let { promise, resolve, reject } = Promise.withResolvers();
  function safeResolve(val) {
    Object.defineProperty(val, 'then', { configurable: true, value: void 0 });
    resolve(val);
    delete val.then;
  }
  return { promise, safeResolve, reject };
}

let evilProto = { get then() { throw 'boom'; } };

let { promise, safeResolve } = safePromiseCapability();
safeResolve({ __proto__: evilProto, key: 'value' });
console.log((await promise).key); // no boom
```
turns out we already have the "safe promise resolve" capability with no changes to the language

[21:30:05.0182] <TabAtkins>
I... don't understand how that's safe. Doesn't that override/delete a .then property on the element, potentially wiping out an existing .then property?

[21:32:44.0862] <bakkot>
sorry, yes, the assumption is that you are only using this with an object you've just created yourself

[21:32:55.0296] <bakkot>
and you're trying to avoid the problem where someone might have put a `.then` on Object.prototype

[21:33:25.0614] <bakkot>
* sorry, yes, the assumption is that you are only using this with an object you've just created yourself, which you know not to have such a property

[21:35:00.0663] <bakkot>
* ```
function safePromiseCapability() {
  let { promise, resolve, reject } = Promise.withResolvers();
  function safeResolve(val) {
    if (Object.hasOwn(val, 'then')) throw new TypeError('you are not supposed to use this with thenables');
    Object.defineProperty(val, 'then', { configurable: true, value: void 0 });
    resolve(val);
    delete val.then;
  }
  return { promise, safeResolve, reject };
}

let evilProto = { get then() { throw 'boom'; } };

let { promise, safeResolve } = safePromiseCapability();
safeResolve({ __proto__: evilProto, key: 'value' });
console.log((await promise).key); // no boom
```

turns out we already have the "safe promise resolve" capability with no changes to the language

