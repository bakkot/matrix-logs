2025-08-01
[11:30:49.0200] <Michael Ficarra>
> <@abotella:igalia.com> it'd be a shame to not have that be captured properly

Isn't that the correct way to capture it in the notes? "This is ZTZ, also know as ZTZ or ZTZ online, but you can call him ZTZ".

[11:42:52.0526] <styfle>
Where can I read the notes?

[11:43:44.0922] <Andreu Botella>
they're linked in the Reflector issue


2025-08-04
[21:23:13.0255] <bakkot>
```
function safePromiseCapability() {
  let { promise, resolve, reject } = Promise.withResolvers();
  function safeResolve(val) {
    Object.defineProperty(val, 'then', { configurable: true, value: void 0 });
    resolve(val);
    delete val.then;
  }
  return { promise, safeResolve, reject };
}

let evilProto = { get then() { throw 'boom'; } };

let { promise, safeResolve } = safePromiseCapability();
safeResolve({ __proto__: evilProto, key: 'value' });
console.log((await promise).key); // no boom
```
turns out we already have the "safe promise resolve" capability with no changes to the language

[21:30:05.0182] <TabAtkins>
I... don't understand how that's safe. Doesn't that override/delete a .then property on the element, potentially wiping out an existing .then property?

[21:32:44.0862] <bakkot>
sorry, yes, the assumption is that you are only using this with an object you've just created yourself

[21:32:55.0296] <bakkot>
and you're trying to avoid the problem where someone might have put a `.then` on Object.prototype

[21:33:25.0614] <bakkot>
* sorry, yes, the assumption is that you are only using this with an object you've just created yourself, which you know not to have such a property

[21:35:00.0663] <bakkot>
* ```
function safePromiseCapability() {
  let { promise, resolve, reject } = Promise.withResolvers();
  function safeResolve(val) {
    if (Object.hasOwn(val, 'then')) throw new TypeError('you are not supposed to use this with thenables');
    Object.defineProperty(val, 'then', { configurable: true, value: void 0 });
    resolve(val);
    delete val.then;
  }
  return { promise, safeResolve, reject };
}

let evilProto = { get then() { throw 'boom'; } };

let { promise, safeResolve } = safePromiseCapability();
safeResolve({ __proto__: evilProto, key: 'value' });
console.log((await promise).key); // no boom
```

turns out we already have the "safe promise resolve" capability with no changes to the language

[03:54:46.0926] <nicolo-ribaudo>
This example makes my concern about having `.then` being called with a thenable (and thus `.then(x => x)` not being an identity) moot, since it's already possible

[08:27:51.0901] <Richard Gibson>
"only using this with an [unfrozen] object you've just created yourself" is an **enormous** restriction

[08:32:34.0657] <Richard Gibson>
* "only using this with an \[extensible\] object you've just created yourself" is an **enormous** restriction

[08:39:26.0867] <Aki>
TC39 your individual contributor RFTC license/permission form is so good I'm adapting it for all of Ecma

[08:47:55.0650] <nicolo-ribaudo>
Yes, but it's exactly the case that matters for the security problems in web specs that were presented

[10:04:12.0467] <bakkot>
I should say, basic idea is due to Justin Ridgewell https://github.com/tc39/proposal-thenable-curtailment/issues/5#issuecomment-3145520373

[10:06:03.0028] <bakkot>
"extensible" isn't necessary since you can make it non-extensible after doing this step, but yes, still a pretty significant restriction. but as nicolo says it does cover most of the actual CVEs

[10:06:55.0186] <bakkot>
also the "just" created yourself can be dropped if you're willing to have it throw if the object has a `.then` property that the user put on it, which I think is a perfectly fine restriction; I updated my snippet to do that. as long as you know the object is one you created then you can rely on it not being a proxy and so the hasOwn check not triggering user code

[10:07:30.0814] <bakkot>
* also the "just" part of "just created yourself" can be dropped if you're willing to have it throw if the object has a `.then` property that the user put on it, which I think is a perfectly fine restriction; I updated my snippet to do that. as long as you know the object is one you created, even if you've since handed it out to a user (as in the Animation CVE in the repo) then you can rely on it not being a proxy and so the hasOwn check not triggering user code

[10:12:56.0569] <bakkot>
I wonder if we ought to do this for async iterator result objects https://github.com/tc39/Reflector/issues/535

[10:32:30.0054] <Justin Ridgewell>
Thereâ€™s also the potential to introduce a `Fulfilled` wrapper which could short-circuit the resolution recursion.

[10:34:22.0059] <Justin Ridgewell>
`await Promise.resolve(new Fulfilled(thenable)) === thenable`


2025-08-05
[17:33:54.0873] <TabAtkins>
I mean if we'd just made Promises monadic in the first place, we wouldn't be in this situation.

[17:34:31.0088] <TabAtkins>
* I mean if we'd just made Promises monadic in the first place, we wouldn't be in this situation...

[08:40:44.0499] <mgaudet|back-tuesday>
I do like that there's a proof of concept here about how we can already do this. That's great to hear. I'd actually be OK with this proposal evolving into "NewbornSafeResolve" -- as I said in the proposal  repo, I'm of the opinion we don't need to fix _every_ problem, but if we can at least make progress on improving the state of the world I'd be happy. 


2025-08-06
[22:53:21.0793] <Mathieu Hofman>
> <@bakkot:matrix.org> also the "just" part of "just created yourself" can be dropped if you're willing to have it throw if the object has a `.then` property that the user put on it, which I think is a perfectly fine restriction; I updated my snippet to do that. as long as you know the object is one you created, even if you've since handed it out to a user (as in the Animation CVE in the repo) then you can rely on it not being a proxy and so the hasOwn check not triggering user code

Not true, the user may have set the prototype to a proxy which would trap when not finding and own then

[22:54:46.0133] <Mathieu Hofman>
* Not true, the user may have set the prototype to a proxy which would trap when not finding an own then

[22:55:14.0334] <nicolo-ribaudo>
At which step of that code would it trap?

[22:58:51.0959] <Mathieu Hofman>
In the animation case, the spec does/did `promiseCapability.resolve(this)`, with `this` being the animation instance that had previously been exposed to userland. Resolve does synchronously look up a `then` property, and knowing that the animation object isn't a proxy (having been brand checked) doesn't mean it can't trap a `x.Get('then')`

[22:59:53.0236] <Mathieu Hofman>
I don't see why `hasOwn` is relevant in this case

[23:00:10.0630] <nicolo-ribaudo>
The idea is that instead of .resolve you would use bakkot's implementation above 

[23:00:39.0548] <nicolo-ribaudo>
> <@bakkot:matrix.org> ```
> function safePromiseCapability() {
>   let { promise, resolve, reject } = Promise.withResolvers();
>   function safeResolve(val) {
>     if (Object.hasOwn(val, 'then')) throw new TypeError('you are not supposed to use this with thenables');
>     Object.defineProperty(val, 'then', { configurable: true, value: void 0 });
>     resolve(val);
>     delete val.then;
>   }
>   return { promise, safeResolve, reject };
> }
> 
> let evilProto = { get then() { throw 'boom'; } };
> 
> let { promise, safeResolve } = safePromiseCapability();
> safeResolve({ __proto__: evilProto, key: 'value' });
> console.log((await promise).key); // no boom
> ```
> 
> turns out we already have the "safe promise resolve" capability with no changes to the language

This one

[23:00:49.0560] <Mathieu Hofman>
But you can't rely on that object being extensible anymore

[23:02:00.0955] <nicolo-ribaudo>
Mh ok

[23:03:36.0454] <Mathieu Hofman>
Unless throwing on a frozen animation instance is acceptable ?

[06:00:31.0957] <bakkot>
yeah seems fine

[06:02:39.0428] <bakkot>
options:
- throw on a non-extensible animation instance. this has probably literally never come up so I doubt anyone will even notice
- only use this functionality for newborn objects. doesn't solve the Animation CVE but does still address most of them
- decide that since the above snippet gets us 99% of the way to a "resolveNonThennable", and the "must be extensible" restriction makes no sense from a user's perspective given that the object is not observably-to-them gaining a new property, we might as well just provide an actual "resolveNonThennable" function which works in the non-extensible case as well

[09:05:18.0958] <Mathieu Hofman>
If we're gonna introduce a new resolve function, why can't we simply delay the resolution in those cases by a tick instead of doing things that are weird and / or not 100% compatible.

