2025-08-01
[11:30:49.0200] <Michael Ficarra>
> <@abotella:igalia.com> it'd be a shame to not have that be captured properly

Isn't that the correct way to capture it in the notes? "This is ZTZ, also know as ZTZ or ZTZ online, but you can call him ZTZ".

[11:42:52.0526] <styfle>
Where can I read the notes?

[11:43:44.0922] <Andreu Botella>
they're linked in the Reflector issue


2025-08-04
[21:23:13.0255] <bakkot>
```
function safePromiseCapability() {
  let { promise, resolve, reject } = Promise.withResolvers();
  function safeResolve(val) {
    Object.defineProperty(val, 'then', { configurable: true, value: void 0 });
    resolve(val);
    delete val.then;
  }
  return { promise, safeResolve, reject };
}

let evilProto = { get then() { throw 'boom'; } };

let { promise, safeResolve } = safePromiseCapability();
safeResolve({ __proto__: evilProto, key: 'value' });
console.log((await promise).key); // no boom
```
turns out we already have the "safe promise resolve" capability with no changes to the language

[21:30:05.0182] <TabAtkins>
I... don't understand how that's safe. Doesn't that override/delete a .then property on the element, potentially wiping out an existing .then property?

[21:32:44.0862] <bakkot>
sorry, yes, the assumption is that you are only using this with an object you've just created yourself

[21:32:55.0296] <bakkot>
and you're trying to avoid the problem where someone might have put a `.then` on Object.prototype

[21:33:25.0614] <bakkot>
* sorry, yes, the assumption is that you are only using this with an object you've just created yourself, which you know not to have such a property

[21:35:00.0663] <bakkot>
* ```
function safePromiseCapability() {
  let { promise, resolve, reject } = Promise.withResolvers();
  function safeResolve(val) {
    if (Object.hasOwn(val, 'then')) throw new TypeError('you are not supposed to use this with thenables');
    Object.defineProperty(val, 'then', { configurable: true, value: void 0 });
    resolve(val);
    delete val.then;
  }
  return { promise, safeResolve, reject };
}

let evilProto = { get then() { throw 'boom'; } };

let { promise, safeResolve } = safePromiseCapability();
safeResolve({ __proto__: evilProto, key: 'value' });
console.log((await promise).key); // no boom
```

turns out we already have the "safe promise resolve" capability with no changes to the language

[03:54:46.0926] <nicolo-ribaudo>
This example makes my concern about having `.then` being called with a thenable (and thus `.then(x => x)` not being an identity) moot, since it's already possible

[08:27:51.0901] <Richard Gibson>
"only using this with an [unfrozen] object you've just created yourself" is an **enormous** restriction

[08:32:34.0657] <Richard Gibson>
* "only using this with an \[extensible\] object you've just created yourself" is an **enormous** restriction

[08:39:26.0867] <Aki>
TC39 your individual contributor RFTC license/permission form is so good I'm adapting it for all of Ecma

[08:47:55.0650] <nicolo-ribaudo>
Yes, but it's exactly the case that matters for the security problems in web specs that were presented

[10:04:12.0467] <bakkot>
I should say, basic idea is due to Justin Ridgewell https://github.com/tc39/proposal-thenable-curtailment/issues/5#issuecomment-3145520373

[10:06:03.0028] <bakkot>
"extensible" isn't necessary since you can make it non-extensible after doing this step, but yes, still a pretty significant restriction. but as nicolo says it does cover most of the actual CVEs

[10:06:55.0186] <bakkot>
also the "just" created yourself can be dropped if you're willing to have it throw if the object has a `.then` property that the user put on it, which I think is a perfectly fine restriction; I updated my snippet to do that. as long as you know the object is one you created then you can rely on it not being a proxy and so the hasOwn check not triggering user code

[10:07:30.0814] <bakkot>
* also the "just" part of "just created yourself" can be dropped if you're willing to have it throw if the object has a `.then` property that the user put on it, which I think is a perfectly fine restriction; I updated my snippet to do that. as long as you know the object is one you created, even if you've since handed it out to a user (as in the Animation CVE in the repo) then you can rely on it not being a proxy and so the hasOwn check not triggering user code

[10:12:56.0569] <bakkot>
I wonder if we ought to do this for async iterator result objects https://github.com/tc39/Reflector/issues/535

[10:32:30.0054] <Justin Ridgewell>
Thereâ€™s also the potential to introduce a `Fulfilled` wrapper which could short-circuit the resolution recursion.

[10:34:22.0059] <Justin Ridgewell>
`await Promise.resolve(new Fulfilled(thenable)) === thenable`


2025-08-05
[17:33:54.0873] <TabAtkins>
I mean if we'd just made Promises monadic in the first place, we wouldn't be in this situation.

[17:34:31.0088] <TabAtkins>
* I mean if we'd just made Promises monadic in the first place, we wouldn't be in this situation...

[08:40:44.0499] <mgaudet|back-tuesday>
I do like that there's a proof of concept here about how we can already do this. That's great to hear. I'd actually be OK with this proposal evolving into "NewbornSafeResolve" -- as I said in the proposal  repo, I'm of the opinion we don't need to fix _every_ problem, but if we can at least make progress on improving the state of the world I'd be happy. 


2025-08-06
[22:53:21.0793] <Mathieu Hofman>
> <@bakkot:matrix.org> also the "just" part of "just created yourself" can be dropped if you're willing to have it throw if the object has a `.then` property that the user put on it, which I think is a perfectly fine restriction; I updated my snippet to do that. as long as you know the object is one you created, even if you've since handed it out to a user (as in the Animation CVE in the repo) then you can rely on it not being a proxy and so the hasOwn check not triggering user code

Not true, the user may have set the prototype to a proxy which would trap when not finding and own then

[22:54:46.0133] <Mathieu Hofman>
* Not true, the user may have set the prototype to a proxy which would trap when not finding an own then

[22:55:14.0334] <nicolo-ribaudo>
At which step of that code would it trap?

[22:58:51.0959] <Mathieu Hofman>
In the animation case, the spec does/did `promiseCapability.resolve(this)`, with `this` being the animation instance that had previously been exposed to userland. Resolve does synchronously look up a `then` property, and knowing that the animation object isn't a proxy (having been brand checked) doesn't mean it can't trap a `x.Get('then')`

[22:59:53.0236] <Mathieu Hofman>
I don't see why `hasOwn` is relevant in this case

[23:00:10.0630] <nicolo-ribaudo>
The idea is that instead of .resolve you would use bakkot's implementation above 

[23:00:39.0548] <nicolo-ribaudo>
> <@bakkot:matrix.org> ```
> function safePromiseCapability() {
>   let { promise, resolve, reject } = Promise.withResolvers();
>   function safeResolve(val) {
>     if (Object.hasOwn(val, 'then')) throw new TypeError('you are not supposed to use this with thenables');
>     Object.defineProperty(val, 'then', { configurable: true, value: void 0 });
>     resolve(val);
>     delete val.then;
>   }
>   return { promise, safeResolve, reject };
> }
> 
> let evilProto = { get then() { throw 'boom'; } };
> 
> let { promise, safeResolve } = safePromiseCapability();
> safeResolve({ __proto__: evilProto, key: 'value' });
> console.log((await promise).key); // no boom
> ```
> 
> turns out we already have the "safe promise resolve" capability with no changes to the language

This one

[23:00:49.0560] <Mathieu Hofman>
But you can't rely on that object being extensible anymore

[23:02:00.0955] <nicolo-ribaudo>
Mh ok

[23:03:36.0454] <Mathieu Hofman>
Unless throwing on a frozen animation instance is acceptable ?

[06:00:31.0957] <bakkot>
yeah seems fine

[06:02:39.0428] <bakkot>
options:
- throw on a non-extensible animation instance. this has probably literally never come up so I doubt anyone will even notice
- only use this functionality for newborn objects. doesn't solve the Animation CVE but does still address most of them
- decide that since the above snippet gets us 99% of the way to a "resolveNonThennable", and the "must be extensible" restriction makes no sense from a user's perspective given that the object is not observably-to-them gaining a new property, we might as well just provide an actual "resolveNonThennable" function which works in the non-extensible case as well

[09:05:18.0958] <Mathieu Hofman>
If we're gonna introduce a new resolve function, why can't we simply delay the resolution in those cases by a tick instead of doing things that are weird and / or not 100% compatible.

[09:12:43.0855] <bakkot>
I would prefer not to make users of the web pay a cost, even a small one, just for the sake of avoiding things which are in some sense "weird" but which no developer much less user would ever even notice.

[10:06:27.0203] <Mathieu Hofman>
But unless the developer does something weird there may not be a cost!

[10:07:40.0496] <Mathieu Hofman>
Again my suggestion for a safe resolve spec op is to delay by a tick when it would trigger user code

[10:12:09.0557] <bakkot>
As I understood it, you didn't like that the "would trigger use code" check would let you to build a pretty straightforward gadget to detect proxies, so rather than "would trigger use code" the check would have to be "is an object", which is ~all of the cases in question

[10:12:37.0397] <bakkot>
so the extra tick would be incurred in ~all cases

[10:14:06.0438] <bakkot>
if that understanding is wrong then sure I'm open to going in that direction instead

[10:14:55.0702] <bakkot>
but if our choices are "do something which is theoretically kinda weird but is allowed by the language already, and which no one will ever notice, or make all web specs which resolve a promise with an object slower", I'm going to advocate for the former


2025-08-07
[23:14:26.0989] <Mathieu Hofman>
First I think the main focus here is to build a safe resolve operation for spec and host, and not directly exposed to the programmer.

Second even if that proxy sensitive operation was directly accessible to programs, we may find it preferable to changing the semantics of thenables.

[23:16:46.0532] <bakkot>
Several delegates have expressed the constraint that anything we do here should be implementable in userland; e.g. Node implements a bunch of web APIs in JS

[23:18:51.0639] <bakkot>
and I don't think this is changing the semantics of thenables given that it's doable in userland already, unless we handle the frozen objects case, which is not really part of how anyone thinks of thenables afaik

[13:42:22.0888] <nicolo-ribaudo>
Are AOs first class values? Can I maybe pass an AO name to something that expects an abstract closure?

[13:45:52.0893] <nicolo-ribaudo>
Oh I guess the answer is "yes", like in steps 6-7-8 of https://tc39.es/ecma262/#sec-applystringornumericbinaryoperator. Nice

[14:54:14.0883] <Mathieu Hofman>
I'm not sure I understand what you mean. My concern is that your "userland solution" relies on the resolution value to have a non-frozen `then`. It simply fails with frozen values, which I hope we can agree should be totally valid values to use as a resolution.

[14:55:27.0850] <bakkot>
you cannot specifically pass an AO name to something that expects an abstract closure, those are different operations

[14:55:32.0993] <bakkot>
* you cannot specifically pass an AO name to something that expects an abstract closure, those are different kinds of thing

[14:55:55.0959] <bakkot>
you can do the thing in ApplyStringOrNumericBinaryOperator but it's not a common pattern and I wouldn't recommend it in most cases

[14:56:17.0064] <Mathieu Hofman>
We can definitely consider exposing to userland a safe resolve operation that would let the caller asynchronously discover information about whether the value is a proxy (or has a proxy in its prototype chain).

[14:57:13.0922] <Mathieu Hofman>
I currently find that preferable to other alternatives I've heard so far.

[15:00:38.0287] <Mathieu Hofman>
* We can definitely consider exposing to userland a safe resolve operation, even if that operation would let the caller asynchronously discover information about whether the value is a proxy (or has a proxy in its prototype chain).

[15:02:20.0942] <Mathieu Hofman>
However I haven't heard a request for userland to be able to implement the safe resolve operation itself. Just that whatever hosts can do, that userland can do it just as much (aka a virtualization question)

[15:02:55.0593] <Mathieu Hofman>
* However I haven't heard a request for userland to be able to implement the safe resolve operation itself. Just that whatever hosts can do, that userland can do it just as much (aka a virtualization constraint, which of course I'm 100% behind)

[15:13:20.0571] <Michael Ficarra>
@nicolo-ribaudo:matrix.org according to our editorial conventions, it should be avoided https://github.com/tc39/ecma262/wiki/Editorial-Conventions

[15:14:05.0258] <bakkot>
I am primarily concerned about preventing this class of CVEs in browsers, which are about passing spec-defined objects, none of which expect to have a `then` or to be non-extensible. I think updating web specs to use the solution I suggest there, and throwing in case that a user has given the object a `then` or made it non-extensible in the mean time, is totally fine. Since this is already possible it presumably doesn't change the definition of "thenable".

We could, additionally, provide a version which works even if the object has been modified in one of those two ways. I'm neutral on this; it's pretty much irrelevant to the case of web specs because users are not, in practice, going to do either of those things. However, if we did, I don't think it would meaningfully change the definition of "thenable" given what's already possible.

[15:14:22.0225] <bakkot>
sorry, to be clear, I meant the latter thing yes

[15:17:26.0472] <Michael Ficarra>
there's an easy solution here though, which is to define an AC that just forwards its parameters to an AO

[15:22:35.0648] <bakkot>
I'm fine with that too if everyone else is.


2025-08-08
[18:50:52.0690] <Justin Ridgewell>
> <@mhofman:matrix.org> However I haven't heard a request for userland to be able to implement the safe resolve operation itself. Just that whatever hosts can do, that userland can do it just as much (aka a virtualization constraint, which of course I'm 100% behind)

Unfortunately this approach may not be web compatible, based on Svelte.

[18:51:40.0351] <Justin Ridgewell>
I realize svelte just added it, but the fact that anyoneâ€™s done a get accessor that depends on immediate access makes me wary that others may have done it.

[18:52:30.0057] <bakkot>
The idea would be to only use this in certain places not by default, I think?

[18:52:32.0884] <Justin Ridgewell>
If we limit this to just a safe capability that does the proxy check, thatâ€™s work.

[18:52:42.0701] <Justin Ridgewell>
Yah, thatâ€™d be fine.

[18:54:20.0159] <Justin Ridgewell>
The default promise capability (and then return value, and promise constructor) could use the current immediate then access. The safe capability does a check to immediately resolve a non-thenable, or defers then access if proxy or then accessor is defined.

[18:55:32.0791] <Justin Ridgewell>
Although, `Fulfilled` wrapper could do this without us having to switch everything to a new capability

[18:55:39.0680] <Justin Ridgewell>
* Although, `Fulfilled` wrapper could do this without us having to switch everything to a new capability ðŸ˜‰

[19:27:45.0942] <mgaudet>
Catching up on the discussion right as I head into a late night chat, so can't participate too much at the moment, but, I just want to explicitly say how much I appreciate how much thought and discussion is going into trying to fix this. It really is wonderful to see. Thanks everyone. 

[19:45:26.0432] <Justin Ridgewell>
* If we limit this to just a safe capability that does the proxy check, thatâ€™d work.

