2023-10-01
[17:08:53.0045] <Jack Works>
if a proxy returns configurable: false for property "x", why future calls return true throws an error? (I know it is maintaining invariant) it can also silently change configurable to false IMO

[17:45:12.0405] <Jack Works>
https://github.com/Jack-Works/proposal-module-sync-assert

[21:05:09.0877] <ljharb>
Why would it be better to silently fail to recognize a bug?

[21:05:41.0726] <ljharb>
arguably it could have just not called the trap once the value wouldn’t change, but here we are

[02:58:19.0222] <Ashley Claymore>
My understanding is that Proxies don't have a memory. The invariants that involve time are enforced by comparing the result to the same call made to the target object. So the invariants would be broken if the target object has broken the invariant, but hosts are not supposed to create objects that break the invariants  

[15:35:51.0123] <Mathieu Hofman>
> <@littledan:matrix.org> What if we made a function like Error.raise instead of adding syntax?

rbuckton: I'd like to bring to your attention a TypeScript limitation that seriously impedes the usage of any function call that unconditionally throws like this. I suspect it would also be a problem that needs to be solved for throw expressions in general: https://github.com/microsoft/TypeScript/issues/50739


2023-10-02
[00:55:04.0548] <Ashley Claymore>
> <@mhofman:matrix.org> rbuckton: I'd like to bring to your attention a TypeScript limitation that seriously impedes the usage of any function call that unconditionally throws like this. I suspect it would also be a problem that needs to be solved for throw expressions in general: https://github.com/microsoft/TypeScript/issues/50739

Maybe it might be easier to solve for throw expressions, as the TypeScript AST control-flow-node can be determined without any binding lookup or type-information, the throw is right there in the syntax.  


2023-10-03
[12:21:59.0410] <bakkot>
littledan etc: is there a types-as-comments chat room or call or something I could join? I have a followup thesis from the discussion earlier:

- Making almost all of TS runnable is a bad goal.
  - It's too big to reasonably specify.
  - TS adds new keywords more frequently than our process would allow, and that's good. The constraints on evolving the grammar of TS are genuinely different from the constraints on evolving the grammar of JS.
  - And given the existence of things like Svelte, JSX, `--experimentalDecorators`, etc, you're never going to reach a point where almost all TS projects can stop using transpilers anyway, so there's nothing particularly special about "almost all of TS".
- Making it more practical to use type checkers without transpilation is a good goal. The current jsdoc support in TS is bad enough that people will put up with the cost of transpilation rather than use it except in extreme cases (e.g. Svelte), and that could be improved.
  - But that only helps people in specific circumstances (i.e., those who otherwise would not have a transpilation step).
  - Flow's comment syntax actually gets used, which means that there's room for something between "only jsdoc-style comments" and "all of TS".
  - By far the largest painpoint with Flow's comment syntax is inline type annotations on variables and parameters. Multiline comment syntax is verbose and awkward to type for something used so frequently.
- Therefore, the proposal ought to drop the "un-fork JS" goal and instead set a goal of 80-20'ing the types-without-transpilation experience using a more minimal grammar, omitting (e.g.) any keywords other than maybe `type`. There's a handful of issues on the repo already proposing something like this. Those users who would benefit can opt in without much more pain, and those who would not can continue to benefit from TypeScript's full syntax being able to evolve outside our process.
  - This doesn't need to be a subset of the TS grammar, particularly if automated translation from full-TS to this subset is easy (which it ought to be).
  - This should be general enough to allow ~any type system to opt in to using only this grammar, but shouldn't aim to have parity with the grammar of any existing type systems. It's OK if this grammar is somewhat more awkward than those available when using a transpiler.
  - Concretely, this might look like `:: [nlth] (.? IdentifierName [nlth])* MatchedBraces` being allowed in a few places, and maybe a new top-level `type` declaration form. Possibly with one or two more forms for e.g. imports, but only a couple more at most.
    - This solves some but not all of the ambiguities in the current grammar; the remaining ones (e.g. FunctionBody braces) would need fixing either way.
    - Yes, this means a lot of nontrivial types will need parentheses. That is a significant cost. I think the cost is worth it.

[13:54:44.0496] <littledan>
Yeah, there is a Matrix room, I will try to get it more open to TC39 in general (I don’t have permission to add you). Thanks for the thoughtful comment, interesting stuff to consider. May be good to file an issue for too.

[14:14:47.0865] <TabAtkins>
Strong agree with bakkot's thesis, as someone who has no idea how TS works but is very familiar with Python's types-as-comments.


2023-10-04
[20:08:05.0456] <littledan>
I think we would be better off with O(5) constructs, with the aim of not enabling avoiding all type /* */comment formats, rather than literally just parameters and return values. It sounds like you are open to this possibility, right?

But I am also not yet sure if the whole thing should be reduced as much as bakkot suggests—we should talk more about overall motivation/usage modes in the next presentation.

[20:52:55.0473] <bakkot>
I'm open to that possibility. Also to be clear I didn't mean to suggest this would only cover parameters and return values - for example, `let x = y ::as string;` would be legal under my suggested grammar (assuming the `::` comment form is allowed in the appropriate places). And I think that's better than having a separate `as` production even though that means you can't use TypeScript casts as they're written today.

[21:40:51.0957] <Jack Works>
/// interface X {
///     either(x: this): this
/// }

/// <T extends X>(i: T, j: T): T
function f(i, j) {
    let next = i.either(j) /// T
    return next
}

[23:45:59.0349] <littledan>
One issue with magic comments is that it’s unclear how tools should handle errors—was that comment just a comment?

[23:47:09.0017] <littledan>
I remember having a thought about `::` being problematic grammatically, but I can’t remember what the problem was…

[23:48:14.0781] <littledan>
The main reason I am a little hesitant about that particular grammar is that some things will want to take an argument and some won’t. This is the kind of thing to work out case-by-case when developing encodings of type systems into JS grammar

[00:30:39.0150] <bakkot>
Uhhh yeah I guess it would be something like `:: [nlth] (.? IdentifierName [nlth])+ MatchedBraces?` or `:: MatchedBraces`

[00:30:48.0966] <bakkot>
 * Uhhh yeah I guess it would be something like `:: [nlth] (.? IdentifierName [nlth])+ MatchedBraces?` plus also `:: MatchedBraces`

[00:31:10.0389] <bakkot>
And yes this still has the `FunctionBody` ambiguity

