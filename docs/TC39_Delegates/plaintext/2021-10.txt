2021-10-01

2021-10-02
[16:44:57.0483] <bakkot>
Aki: as long as you are doing matrix-y things, can I petition you to change the logs links to https://matrixlogs.bakkot.com/ ? the current logs are kinda garbage


2021-10-04
[15:29:35.0346] <Michael Ficarra>
bakkot: can we host that somewhere that's controlled by the committee instead?

[15:39:34.0902] <bakkot>
Michael Ficarra: It's on github pages

[15:39:53.0522] <bakkot>
do you want push access to the repo, or?

[15:40:24.0486] <bakkot>
but also we relied on a logbot hosted by a non-committee member for the last several years, which was fine

[15:40:38.0602] <bakkot>
so it does not seem particularly pressing to me

[15:41:06.0221] <Michael Ficarra>
I meant the domain, shouldn't it be easy to be something like `tc39.es/matrixlogs` by transferring to the tc39 org?

[15:44:53.0165] <bakkot>
I don't intend it to be just for tc39; it also hosts logs for whatwg, and I will probably add more if people ask for them. and I don't really want to run multiple instances of it

[15:45:13.0687] <bakkot>
so if you want to do the work of setting up and running a separate instance and hosting it there, go for it

[15:45:18.0650] <bakkot>
otherwise I would prefer not to change mine


2021-10-05
[18:58:41.0939] <ljharb>
it'd probably be good to have tc39's be on their own instance under tc39.es


2021-10-06
[07:32:03.0017] <jschoi>
Several Stage 0 proposals have been transferred to the tc39 GitHub organization. Is there a particular policy about this? https://github.com/tc39/proposals#onboarding-existing-proposals doesn‚Äôt talk about Stage 0.

[07:41:46.0463] <ryzokuken>
are internal slots case sensitive?

[07:46:06.0926] <ryzokuken>
https://tc39.es/ecma262/#sec-object-internal-methods-and-internal-slots doesn't specify that

[07:57:51.0448] <shu>
yeah, treat them as case sensitive

[07:58:01.0159] <shu>
i'd be against every introducing slot names that differ only in casing

[07:58:08.0196] <shu>
but even so just treat them as case sensitive

[08:00:30.0551] <ryzokuken>
I mean more about access. Can I access `[[Foo]]` using `[[foo]]`?

[08:11:24.0610] <Ashley Claymore>
semi-related. is the `[[Description]]` that a Symbol "holds" also an 'internal slot'? The spec seems to say that slots are only on objects, so would it be technically incorrect to say that symbols have an internal slot?

[09:02:16.0519] <shu>
ryzokuken: no, use [[Foo]]

[09:42:19.0358] <shu>
Ashley Claymore: not technically, but conceptually yes

[10:01:31.0475] <Ashley Claymore>
thanks shu  üôÇ

[10:58:30.0344] <shu>
PSA: nobody has signed up for the next incubator call yet. the topic is Proxy performance https://github.com/tc39/Reflector/issues/399

[14:15:52.0018] <ljharb>
> <@jschoi:matrix.org> Several Stage 0 proposals have been transferred to the tc39 GitHub organization. Is there a particular policy about this? https://github.com/tc39/proposals#onboarding-existing-proposals doesn‚Äôt talk about Stage 0.

the policy is that stage 1+ proposals *must* be transferred; stage 0 proposals can be, but for scalability, we should probably only transfer the ones that have been discussed in a plenary

[15:24:30.0814] <rbuckton>
Can the `Contains` spec op be used with a sequence of terminals, or would I need to contain the terminals in a nonterminal to use Contains? For example, would the following be valid spec text?:
```
If _node_ Contains `using const`, ...
```

[15:24:51.0754] <rbuckton>
 * Can the `Contains` spec op be used with a sequence of terminals, or would I need to contain the terminals in a nonterminal to use Contains? For example, would the following be valid spec text?:
```
If _node_ Contains `using const`, ...
```

[15:31:53.0239] <bakkot>
rbuckton: as it is currently written, it cannot. it walks over the children of a parse node one at a time checking if each is an instance of the argument to Contains, which would not work when the thing you are looking for is spread out across multiple children.

[15:32:09.0096] <bakkot>
 * rbuckton: as it is currently written, it cannot. it walks over the children of a parse node one at a time checking if each is an instance of the argument to Contains, which would not work when the thing you are looking for is spread out across multiple children.


2021-10-10
[09:03:57.0802] <TabAtkins>
FYI to CoC people: just sent in a CoC request (in case it gets caught by spam filters like last time)

[10:06:05.0129] <jschoi>
Same: I sent two emails CoC yesterday, in case they‚Äôre caught as spam.


2021-10-11
[08:40:48.0367] <ljharb>
fwiw i got them all.

[09:51:40.0420] <Jory Burson>
Delegates, FYI we have implemented an indefinite block on a "sock-puppet" account. Sock puppet accounts are alternate accounts created by users, typically to get around a block or to create the appearance of more support for a poster's ideas. Creating sock puppet accounts is an example of a negative conflict behaviour that will result in an immediate block. cc TabAtkins ljharb jschoi 

[09:52:40.0323] <Jory Burson>
Thanks for your continued use of the CoC process! Please let me know directly if you have any questions or concerns.


2021-10-13
[10:22:40.0192] <bakkot>
devsnek: for your slides for extending `null`, it would be good to have some some slides with the various edge cases (especially "class which extends a literal `null` and has not had its prototype changed", "class which initially extended some other value but has had its prototype changed to `null`", and "class which initially extended `null` but has had its prototype changed to a non-`null` value")

everyone agrees `extends null` should work, so much of the meat of the discussion is around these edge cases

[10:22:52.0207] <bakkot>
I can write something up if you'd find it helpful

[10:23:40.0460] <bakkot>
also, reminder to the channel that the deadline for advancement eligibility is in two days, and the agenda is currently pretty light

[10:31:27.0966] <jschoi>
If not much else gets added to the agenda, then I will expand my two proposal updates‚Äô timeboxes from ten minutes to thirty minutes each. 

[10:31:49.0409] <jschoi>
* If not much else gets added to the agenda, then I will expand my two proposal updates‚Äô timeboxes from ten minutes to thirty minutes each. 

[11:01:49.0766] <bakkot>
shu: given that the agenda is kind of light, Michael Ficarra and I were thinking it might be a good time for the subclassing discussion

[11:16:40.0444] <bakkot>
jschoi: the spec at https://jschoi.org/21/es-array-async-from/ appears to be ahead of the spec in the proposal

[11:16:46.0921] <bakkot>
I was gonna submit a PR but it's tricky when they're out of sync

[11:36:26.0563] <shu>
bakkot: what's the scope you had in mind?

[11:48:41.0192] <Michael Ficarra>
> <@jschoi:matrix.org> If not much else gets added to the agenda, then I will expand my two proposal updates‚Äô timeboxes from ten minutes to thirty minutes each.

any time box less than 30 minutes is pretty ambitious

[11:50:57.0313] <Michael Ficarra>
> <@shuyuguo:matrix.org> bakkot: what's the scope you had in mind?

tradeoffs of the "minimal core" philosophy where supplementary methods delegate to core methods so that subclasses only need to override the core

[11:51:55.0582] <Michael Ficarra>
recall the question from the Set methods proposal: do helpers like union/intersection/difference touch the set contents themselves or delegate to the add/remove methods

[12:16:12.0156] <jschoi>
> <@bakkot:matrix.org> I was gonna submit a PR but it's tricky when they're out of sync

They should be in sync; I‚Äôm surprised that they were not.
I just updated the spec page to match the repository‚Äôs build. I‚Äôll set up an automatic build on tc39.es sometime.

[12:17:06.0776] <jschoi>
> <@michaelficarra:matrix.org> any time box less than 30 minutes is pretty ambitious

Haha, yeah‚ÄîI was just going to speed through a few update slides then say, ‚ÄúPlease file any questions in a new GitHub issue; thank you!‚Äù

[12:53:28.0965] <bakkot>
> <@jschoi:matrix.org> They should be in sync; I‚Äôm surprised that they were not.
> I just updated the spec page to match the repository‚Äôs build. I‚Äôll set up an automatic build on tc39.es sometime.

unless there's a caching issue or something they appear to still not be in sync - the rendered spec has the TA method, the source in the spec.html file in the repo (which has not been updated in 13 days) does not

[12:55:25.0765] <jschoi>
I‚Äôll look into it, but either way I haven‚Äôt gotten to updating the TypedArray version yet to fulfill #9. 

I‚Äôll work on deploying to GitHub Pages tonight so we can definitely have an up-to-date spec page. 

[12:55:46.0625] <jschoi>
* I‚Äôll look into it, but either way I haven‚Äôt gotten to updating the TypedArray version yet to fulfill #9. 

I‚Äôll work on deploying to GitHub Pages tonight so we can definitely have an up-to-date spec page. 

[13:10:01.0087] <devsnek>
bakkot: updated slides and also rebased the spec text

[13:13:36.0268] <devsnek>
also added a note about how class fields don't currently work

[13:15:01.0268] <devsnek>
 * also added a note about how class fields don't currently work

[16:30:01.0538] <shu>
reminder that nobody has signed up for the next incubator call: https://github.com/tc39/Reflector/issues/399

[16:30:17.0184] <shu>
i will cancel it if nobody else signs up by this friday, Oct 15


2021-10-14
[17:39:46.0654] <jschoi>
> <@jschoi:matrix.org> I‚Äôll look into it, but either way I haven‚Äôt gotten to updating the TypedArray version yet to fulfill #9. 
> 
> I‚Äôll work on deploying to GitHub Pages tonight so we can definitely have an up-to-date spec page.

I added an action to proposal-array-from-async that automatically publishes to its gh-pages branch, but it doesn‚Äôt look like the gh-pages files are showing up at https://tc39.es/proposal-array-from-async/. Is there anything else I need to do?

[17:40:21.0510] <jschoi>
Also, I need access to proposal-bigint-math‚Äôs repository to enable GitHub Actions so that it can also publish to its gh-pages branch.

[23:19:11.0074] <ljharb>
> <@jschoi:matrix.org> I added an action to proposal-array-from-async that automatically publishes to its gh-pages branch, but it doesn‚Äôt look like the gh-pages files are showing up at https://tc39.es/proposal-array-from-async/. Is there anything else I need to do?

you need to make sure github pages is enabled in the repo settings

[06:49:00.0104] <jschoi>
Oh yeah, right. Could I get settings access to proposal-array-from-async and to proposal-bigint-math?

[09:47:39.0319] <ljharb>
the chairs would have to do that

[11:06:50.0538] <rbuckton>
> <@jschoi:matrix.org> I added an action to proposal-array-from-async that automatically publishes to its gh-pages branch, but it doesn‚Äôt look like the gh-pages files are showing up at https://tc39.es/proposal-array-from-async/. Is there anything else I need to do?

I have a similar action set up in a few of my proposal repos. 

[12:26:59.0027] <ljharb>
(note that the template repo does it by auto-building the spec and storing it in the default branch, no gh-pages branch at all - there's a bunch of ways to do it)

[15:21:35.0212] <jschoi>
I do need settings access to those two repositories anyway, to change these repos‚Äô homepage metadata from spec pages on my personal websites to tc39.es pages.

[15:22:17.0359] <jschoi>
Aki, bterlson, yulia: Could any chair give me GitHub admin access to proposal-array-from-async and to proposal-bigint-math?

[15:22:31.0077] <jschoi>
 * Aki, bterlson, yulia: Could any chair give me GitHub admin access to proposal-array-from-async and to proposal-bigint-math?


2021-10-15
[01:57:14.0284] <rbuckton>
Anyone around to merge #1058, #1059, #1060, #1061 in https://github.com/tc39/agendas/pulls?

[01:59:02.0035] <rbuckton>
If not, I think I can merge myself

[02:21:51.0402] <rbuckton>
If we are still light on the agenda, there are a few more proposals I intend to split off from https://github.com/rbuckton/proposal-regexp-features into individual proposals that I can add as well. I intended to propose them for Stage 1, but did not have the time to make individual repos/slide decks for each feature prior to the agenda deadline. I am aware they could be rejected purely on this basis, but if we have the time to spare I can finishing breaking them down tomorrow and add them to the agenda.

[08:43:55.0534] <ljharb>
They don‚Äôt need to be merged before the deadline, for future reference; merely opening the PR is sufficient.

[12:52:47.0437] <rbuckton>
I pointed this out on GH as well, but the Agenda topic rules are actually unclear on that subject:

[12:54:17.0455] <rbuckton>
The term "pull request" is only used in reference to (1). All other points use the term "added" which, given the distinction for PRs in (1), seems to indicate they must be part of the actual agenda by the deadline. If merely having the PR by the deadline is acceptable, I suggest we change the wording in the agenda topic rules.

[12:55:49.0666] <Rob Palmer>
I'd be happy to clarify the rules to say that raising a PR (that includes the links to the materials) is sufficient. Review/merge time should not count against the submitter given that in all normal circumstances it will get merged within a day. 

[12:56:13.0919] <rbuckton>
I was leaning towards the "added" meaning "merged" interpretation because there's no guarantee that a TC39 member looking at the agenda would be expected to also check the open PRs for other not-yet-merged topics and might miss a topic and be unwilling to advance as a result.

[13:00:54.0376] <rbuckton>
As someone who had a proposal blocked because I'd neglected to hit submit on the PR after publishing the branch for the PR (damn two-step process for proposing a change to a MD file on GitHub), I admit to being a bit more cautious in my interpretation. Yes, its not quite the same thing since branches are significantly less visible than PRs, but still its not something I'd like to repeat.

[13:10:08.0218] <ljharb>
since we've considered a PR sufficient in the past, i pushed up a commit clarifying it

[13:10:31.0077] <ljharb>
if anyone objects we can discuss it during plenary

[13:11:16.0185] <Rob Palmer>
Let's remember to explicitly highlight this in the next plenary. 

[13:14:47.0725] <ljharb>
sounds great! i'll be asleep the first half of each day or i'd be happy to volunteer; please do explicitly mention that i've documented past precedent :-)


2021-10-16
[17:23:24.0788] <rbuckton>
I've added a few late additions (#1065 [merged], #1066 [pending], and #1067 [pending]) to the agenda as I've continued to whittle away at the proposal-regexp-features proposal from last meeting. I'm aware they may be blocked due to the agenda topic rules, but from my calculations it looked like we were light on agenda topics for a 4-day plenary. Even if they don't achieve Stage 1 it is at least worth discussing them individually, though I'm *hoping* that the late addition status won't be a primary blocking concern since I discussed all of these in the last meeting.


2021-10-19
[20:14:50.0937] <Ashley Claymore>
TC39 Calendar event reminder: Record&Tuple Monthly call tomorrow (19th). 6pm utc

[20:16:36.0855] <Ashley Claymore>
* TC39 Calendar event reminder: Record&Tuple Monthly call tomorrow (19th). 6pm UTC

[20:31:54.0927] <Ashley Claymore>
* TC39 Calendar event reminder: Record&Tuple Monthly call today/tomorrow (19th). 6pm UTC


2021-10-24
[09:14:03.0588] <ptomato>
justingrant and I have a heads up for delegates about two changes to the Temporal item in the upcoming plenary:

[09:14:53.0345] <ptomato>
Wanted to give a heads-up about two changes we just pushed for Temporal's slides for next week's plenary:

- Added a [new slide](https://ptomato.name/talks/tc39-2021-10/#23) for a fix for a spec bug discovered after the deadline. It will be hard to wait to fix this bug until Dec, so we added it with a "‚åõÔ∏è" mark. if you feel you need more time to review this, don't hesitate to ask for it.

[09:15:21.0716] <ptomato>
- A PR that we thought had everyone's üëçÔ∏è actually needs more feedback. So we moved it from the main slides into a new ["Discussion" section](https://ptomato.name/talks/tc39-2021-10/#25) at the end. We added additional context to frame the discussion, and time permitting we'd appreciate committee input.

[09:15:33.0886] <ptomato>
 * - Added a [new slide](https://ptomato.name/talks/tc39-2021-10/#23) for a fix for a spec bug discovered after the deadline. It will be hard to wait to fix this bug until Dec, so we added it with a "‚åõÔ∏è" mark. if you feel you need more time to review this, don't hesitate to ask for it.

[11:39:08.0830] <shu>
where is the sign-in form? i don't see it in the reflector thread

[11:39:33.0971] <shu>
Rob Palmer: Aki bterlson ^

[12:48:04.0074] <Rob Palmer>
I'll put it up tomorrow two hours before the meeting. Unless you really need it now? 

[14:44:03.0081] <Surma>
I noticed that I‚Äôm not on the TCQ for tomorrow, but I have a constraint that I can really only attend tomorrow although if push comes to shove, I‚Äôm sure I can move some stuff around. Is that an oversight or should I try and dig up a free spot on some other day? 

[14:44:36.0758] <Surma>
nvm me

[14:44:45.0262] <Surma>
 * I noticed that I‚Äôm not on the TCQ for tomorrow, but I have a constraint that I can really only attend tomorrow although if push comes to shove, I‚Äôm sure I can move some stuff around. Is that an oversight or should I try and dig up a free spot on some other day? ~x~

[14:44:50.0820] <Surma>
 * I noticed that I‚Äôm not on the TCQ for tomorrow, but I have a constraint that I can really only attend tomorrow although if push comes to shove, I‚Äôm sure I can move some stuff around. Is that an oversight or should I try and dig up a free spot on some other day? 

[14:44:58.0362] <Surma>
Didn‚Äôt see the draft schedule ü§¶

[15:57:09.0091] <shu>
Rob Palmer: i'd prefer the link and password now so i can wake up at like, 1:45am instead of 1:30am


2021-10-25
[23:46:49.0052] <Rob Palmer>
The sign-in form is now on the Reflector issue.  Please do not post the link here because this is a public channel.

[23:51:36.0157] <Rob Palmer>
Please could someone try the form to check it's working.

[23:55:06.0263] <ryzokuken>
Rob Palmer: just did

[23:55:29.0590] <legendecas>
I filled out the form and it works

[23:55:40.0172] <ryzokuken>
thanks legendecas!

[01:52:23.0044] <Rob Palmer>
There are 5 of us in the Jitsi call.  We'll kick off in 8 mins!

[01:58:20.0922] <Rob Palmer>
13 people are here - two mins to go!

[02:03:46.0088] <Rob Palmer>
26 people now - and we are go

[02:05:27.0224] <Jack Works>
what is the password of the meeting?

[02:05:38.0374] <Rob Palmer>
use the form on the reflector

[02:05:41.0927] <Rob Palmer>
do not post the password here

[02:05:48.0204] <Jack Works>
oh ok thanks

[02:30:25.0443] <Rob Palmer>
40 people are here now - good turnout for 2am Pacific Time

[02:31:31.0909] <shu>
many folks missing affiliations in the names

[02:33:11.0685] <Aki>
anyone who just shows up as an email address probably has an 8x8 meet account

[02:33:19.0078] <Aki>
which doesn't support display names????

[02:33:39.0053] <bakkot>
Several of the people in the 8x8 don't have full names even

[02:34:07.0076] <Aki>
yeah i see that

[02:35:29.0630] <ryzokuken>
there's literally someone with `test123` on here üòÖ

[02:39:02.0826] <yulia>
Aki: should we give an announcement about that? possible tighten the form so that if the name is not on the form they get booted?

[02:39:20.0610] <Aki>
Yup. that's my plan 

[02:40:44.0106] <ryzokuken>
did we have local-only meetings in 2019?

[02:44:34.0142] <Aki>
we haven't had a local-only meeting in‚Ä¶¬†idek 6 years?

[02:45:28.0693] <ryzokuken>
sounds good, I was just confused because they were mentioned in Istvan's report as "no longer on the table" but I thought they had been so for a while

[02:51:20.0893] <waldemar>
SDO = Standards Development Organization ‚ò∫

[02:52:31.0949] <yulia>
who wants to add SDO (syntax directed operation) to terminology? 
https://github.com/tc39/how-we-work/blob/master/terminology.md

[02:52:47.0031] <yulia>
we can add both definitions, i thought "standards development org" at first

[02:54:06.0336] <yulia>
Ashley Claymore volunteered

[03:01:31.0796] <Ashley Claymore>
https://github.com/tc39/how-we-work/pull/102/files

[03:01:53.0881] <Ashley Claymore>
Should I add 'standards development org' too?

[03:01:56.0700] <Ashley Claymore>
To avoid confusion

[03:10:02.0126] <yulia>
yeah, i think we use both in the tc39 context

[03:10:19.0795] <yulia>
for example "ecma is an SDO" for that context

[03:13:47.0273] <Ashley Claymore>
added both :)

[03:14:49.0940] <Rob Palmer>
We have 5 people with non-compliant Jitsi display names.  Please can these people rename to use their full name and (affiliation/company)

Waldemar, 393939, feng, Hongjian Yang, ZY

[03:19:18.0090] <Aki>
waldemar: psst (you're still missing the (Google) part

[03:25:25.0542] <leobalter>
I just catching up (was out of electricity here) but I'm happy to see the nominations for the Ecma award. Thanks yulia for coordinating this!

[03:30:33.0331] <bakkot>
Aki: speaking of scheduling stuff, Michael and I would like to defer the subclassing discussion to a later meeting

[03:30:56.0634] <Michael Ficarra>
we've already removed it from the agenda

[03:31:03.0065] <Aki>
no shit! WELL. that changes things.

[03:31:13.0060] <Michael Ficarra>
sorry, we should've given you a heads up

[03:31:25.0844] <Aki>
all good. i'm sure Ron Buckton will appreciate

[03:31:50.0495] <Michael Ficarra>
turns out subclassing builtins is a very complicated topic

[03:32:04.0634] <Aki>
imagine that

[03:32:06.0684] <Aki>
 * imagine that

[03:37:33.0941] <Michael Ficarra>
can we advance the queue so I can add a reply?

[03:38:10.0896] <Aki>
done

[03:49:51.0102] <Michael Ficarra>
Jack Works: you're only looking to expose the composition of serialise/deserialise, not either individually, right?

[03:53:12.0774] <Jack Works>
> <@michaelficarra:matrix.org> Jack Works: you're only looking to expose the composition of serialise/deserialise, not either individually, right?

I'm looking for a much more powerful serialize/deserialize API in the language that can be integrated with structured clone

[03:53:54.0125] <Jack Works>
but I never presented it to the committe because I didn't make clear about how I should design those APIs

[03:57:14.0530] <Jack Works>
Design goals:
- Format independent (I'm not going to specify a new format to store the serialize result)
- Configurable (e.g.: Devs can define their own structures that can be stored into indexedDB via structured clone algr)
- Async (Some data structures requires async access, including CryptoKey)
- Exportable (a interesting property on CryptoKey)
- Sendable (is it ok to transfer/clone to another Realm)
- Transfer (as structured clone, transfered data cannot be accessed later)

[03:58:31.0764] <Michael Ficarra>
so it's going to be an opaque blob?

[03:58:44.0484] <Rob Palmer>
we are breaking for 62 mins.  returning at 13:00 UK time

[03:58:56.0236] <Jack Works>
> <@michaelficarra:matrix.org> so it's going to be an opaque blob?

Yes, maybe. Host decides how to store them.

[04:00:52.0045] <Jack Works>
My current idea is
- defining a new kind of intermediate data structure (let's call it `InterMap`) which works like a Map
- design a set of API to ser/deser from/to `InterMap`
- let `InterMap` can be structure cloned

[04:02:37.0598] <Michael Ficarra>
k, as long as you can't inspect it and rely on it

[04:03:20.0958] <Michael Ficarra>
though if you plan to have it able to be stored in IndexedDB, I don't see how you're going to do that

[04:03:32.0973] <Michael Ficarra>
will it still be opaque in IndexedDB?

[04:07:23.0435] <Jack Works>
> <@michaelficarra:matrix.org> will it still be opaque in IndexedDB?

yes, if you take it out from the indexedDB, you need to use the deserialize API (with the correct options) to extract data from it.

[04:10:05.0457] <Jack Works>
if `A` and `B` encode and decode the `InterMap` in different way, program will fail

e.g.
- `app that 1 month ago` vs `app today` (via `indexedDB` or other persistent storage)
- `website a` and `website b` (via `postMessage` or other communicating API)) 

[04:58:13.0651] <Rob Palmer>
We will be starting the meeting in 2 mins

[05:09:49.0276] <bakkot>
date.parse is never going to have agreement among engines I think

[05:09:57.0044] <shu>
exactly yes

[05:13:54.0765] <bakkot>
there was that one person (from Mozilla maybe?) a few years ago who was trying to come up with an intersection semantics but then they left and never came back

[05:14:18.0932] <shu>
yeah

[05:14:31.0301] <shu>
that convinced me it was a lost cause

[05:14:38.0158] <shu>
also a spectacular waste of engineer time

[05:14:44.0081] <shu>
 * also a spectacular waste of engineer time

[05:19:12.0056] <Michael Ficarra>
why is this not an arrow?

[05:20:51.0483] <Michael Ficarra>
just so we can do cool point-free stuff?

[05:21:17.0559] <bakkot>
I don't think this counts as point-free, strictly speaking

[05:21:21.0020] <bakkot>
the `?` is a point

[05:21:26.0499] <annevk>
The one thing I'd like to say on waste of time is that the number of engineers downstream from the specification is vastly larger and to some extent they also have to deal with engines disagreeing here. (I'm glad HTML parsing got solved eventually as that had similar sentiments attached to it.)

[05:22:11.0492] <HE Shi-Jun>
is `f~()` (without any `?` or `...`) valid syntax?

[05:23:44.0098] <leobalter>
Surma: Count me in for Stage 3 review of Module Blocks. I have direct interest for this feature and I need to get on the specs to make sure it connects well with ShadowRealms.

[05:25:22.0499] <leobalter>
I just can't guarantee I'm gonna be awake for the time you present it :)

[05:26:11.0299] <Surma>
That‚Äôs okay! I also have Guy Bedford volunteering to be a reviewer, and I don‚Äôt think they‚Äôre awake ;)

[05:26:11.0888] <shu>
annevk: fair, but in this case we have good agreement on the superior solution, Temporal

[05:26:36.0303] <HE Shi-Jun>
two placeholder .... oh 

[05:26:39.0404] <shu>
such that there's no point in salvaging the old thing. i thought people are already shipping usertime libraries today instead of relying on the brokenness of Date.parse

[05:28:16.0918] <annevk>
shu: I'm not sure it needs salvaging; picking an implementation as winner seems preferable to implementation-defined behavior

[05:28:59.0686] <bakkot>
annevk: people switch on which engine they are running on before calling Date.parse sometimes, so I don't think we can even get away with that

[05:29:13.0333] <bakkot>
 * annevk: people switch on which engine they are running on before calling Date.parse sometimes, so I don't think we can even get away with that

[05:31:17.0372] <jschoi>
Sorry, where‚Äôs the queue link posted again?

[05:31:38.0345] <bakkot>
reflector

[05:33:21.0072] <jschoi>
I‚Äôm checking there, but I don‚Äôt see a queue link, sorry. What section is it under?

[05:33:38.0552] <bakkot>
https://github.com/tc39/Reflector/issues/396 under "TCQ"

[05:33:44.0503] <bakkot>
(that link will only work for delegates)

[05:34:00.0995] <jschoi>
Ah, sorry! I had not realized that was the acronym. 

[05:38:14.0557] <Michael Ficarra>
legendecas: the downside of `a.b~()` being the only way to bind is that it only allows binding to an object the function is already installed on, not an arbitrary object

[05:40:38.0304] <leobalter>
I'm glad the to see the TCQ reflecting a lot of my thoughts already. For a big majority, the arrow function seems much easier to read. For constructors it feels lacking motivation and perhaps some weird way to sugar class inheritance.

[05:41:00.0865] <shu>
Michael Ficarra: compose it with comma expressions to first assign `b` to `a`, then delete it

[05:44:22.0947] <Rob Palmer>
shu: to your question on benefit over arrow functions:  Benedict optimized bind to an inch of its life and ultimately made them faster than arrow functions (I believe).    I wonder if this extra ability to bind arbitrary positions could eliminate the need for arrow functions so much, and therefore lead to possible performance wins.

[05:45:30.0973] <Michael Ficarra>
MM is making the exact point I wanted to make: readers are going to have a harder time with this, for basically no benefit

[05:46:35.0600] <shu>
Rob Palmer: i can see it being more optimizable, yes

[05:46:35.0863] <yulia>
I think arrow functions haven't been fully optimized yet if they are still slow. It isn't the syntax that causes this impact here. I wouldn't go with a performance argument for this

[05:46:52.0348] <shu>
but that is far, far below other considerations here

[05:47:05.0367] <yulia>
> <@shuyuguo:matrix.org> Rob Palmer: i can see it being more optimizable, yes

huh interesting

[05:47:14.0554] <shu>
it's easier to analyze, right?

[05:47:31.0386] <yulia>
right, i was thinking about a simpler case

[05:47:34.0262] <shu>
whereas for arrows that do simple forwarding + argument reordering/shuffling, you'd have to pattern match

[05:47:46.0943] <yulia>
yep yep, i didn't read fully -- sorry

[05:47:48.0024] <Rob Palmer>
creating an arrow function captures more scope (the execution context)

[05:48:00.0405] <shu>
it doesn't _have_ to

[05:48:13.0288] <shu>
you could analyze more in the frontend if you really cared, i suppose, to pattern match on forwarding patterns

[05:49:05.0563] <shu>
but speculative optimizability is not compelling enough for this

[05:49:41.0396] <shu>
what are you doing such that you're creating so many forwarding functions?

[05:50:02.0853] <Rob Palmer>
glue. lots of glue.

[05:51:42.0066] <shu>
if the cost of glue is too high

[05:51:58.0546] <shu>
there might be avenues of exploration on a better `bind` here, than syntax

[05:52:17.0614] <ljharb>
+1 to a better bind (but "better" would require syntax imo)

[05:52:54.0329] <Michael Ficarra>
better would probably require syntax, yes

[05:53:15.0268] <shu>
i meant better only in terms of optimizability, i guess

[05:53:50.0883] <shu>
unless glue code writers also really care about how their glue code looks

[05:53:56.0215] <shu>
but i'm less sympathetic to that though

[05:54:02.0742] <shu>
 * but i'm less sympathetic to that though

[05:54:52.0229] <bakkot>
i would be pretty surprised to see a JS codebase in which the difference in optimizability between arrows and `.bind` had a user-visible effect on performance

[05:58:26.0107] <jschoi>
To add onto Ron mentioning bind-this, PFA syntax and bind-this are orthogonal, would synergize, and have very small overlap. Examples in a moment.

[05:59:18.0900] <jschoi>
`obj.method~()` would handle method extraction with implicit binding, which bind-this does not address. I‚Äôm talking about when the receiver of the bound function already contains the function that is being bound. Bind-this would require you to repeat the receiver in this case; it does not address method extraction at all.
```js
n.on("click", v.reset.bind(v))
n.on("click", v::v.reset)
n.on("click", v.reset~())
```

[05:59:24.0657] <jschoi>
 * `obj.method~()` would handle method extraction with implicit binding, which bind-this does not address. I‚Äôm talking about when the receiver of the bound function already contains the function that is being bound. Bind-this would require you to repeat the receiver in this case; it does not address method extraction at all.
```js
n.on("click", v.reset.bind(v))
n.on("click", v::v.reset)
n.on("click", v.reset~())
```

[06:00:01.0320] <jschoi>
Of course, PFA syntax does not address changing the receiver of a function call.
```js
isPending.call(this._target())
this._target()::isPending()
```

[06:00:11.0930] <jschoi>
PFA syntax and bind-this can also work together, when creating bound functions with multiple partially applied arguments, which people sometimes do use `bind` for.
From svgo@1.2.2:
```js
smartRound.bind(this, params.floatPrecision)
x => this::smartRound(params.floatPrecision, x)
this::smartRound~(params.floatPrecision)
```

[06:00:35.0215] <jschoi>
 * PFA syntax and bind-this can also work together, when creating bound functions with multiple partially applied arguments, which people sometimes do use `bind` for.
From svgo@1.2.2:
```js
smartRound.bind(this, params.floatPrecision)
this::smartRound~(params.floatPrecision)
```

[06:01:35.0531] <jschoi>
 * PFA syntax and bind-this can also work together, when creating bound functions with multiple partially applied arguments, which people sometimes do use `bind` for.
From svgo@1.2.2:
```js
smartRound.bind(this, params.floatPrecision)
x => this::smartRound(params.floatPrecision, x)
this::smartRound~(params.floatPrecision)
```

[06:10:09.0147] <shu>
gathering my thoughts some more: i can live with pipeline because, while i disagree with its motivations there as well (e.g. naming intermediates is too onerous), i have a sense that there is in fact a large number of folks clamoring for it and really want to type it. syntax catering to popularism is fine by me, active harm excepted. but here, i haven't gotten the sense there is a large number of folks clamoring for it

[06:11:58.0123] <rbuckton>
```js
class C {}
function g() { return new C(); }
const o2 = g(); // C {}
const o3 = new g(); // C {}
```

[06:12:55.0209] <yulia>
> <@shuyuguo:matrix.org> gathering my thoughts some more: i can live with pipeline because, while i disagree with its motivations there as well (e.g. naming intermediates is too onerous), i have a sense that there is in fact a large number of folks clamoring for it and really want to type it. syntax catering to popularism is fine by me, active harm excepted. but here, i haven't gotten the sense there is a large number of folks clamoring for it

I feel like popular syntax has a life span, and pipeline creates a new way to write pretty much anything. So, i feel like it is much more risky than it appears. I really think we should be careful with pipeline. But there is clearly a broader issue here, which multiple proposals touch on, and it doesn't feel like it has been fully expressed yet. 

[06:15:27.0528] <annevk>
bakkot: that's fair, but that's always a problem; I've seen it happen more than once that such cases end up getting overturned due to newer code (perhaps on other websites) relying on the behavior of a single browser. You cannot win with implementation-defined.

[06:17:44.0553] <sarahghp>
> <@yulia:mozilla.org> I feel like popular syntax has a life span, and pipeline creates a new way to write pretty much anything. So, i feel like it is much more risky than it appears. I really think we should be careful with pipeline. But there is clearly a broader issue here, which multiple proposals touch on, and it doesn't feel like it has been fully expressed yet.

The kind of code to which pipeline applies (temp variables to make a transformation tube) is very common. I don't think I've ever come across cases where partial application of a middle argument is necessary.

[06:17:56.0369] <waldemar>
rbuckton: g is an example of a function on which you get the same thing whether or not you invoke it with new. But most functions aren't like that:
function F() {};
const o2 = F(); // undefined
const o3 = new F(); // object

[06:18:06.0093] <rbuckton>
> <@rbuckton:matrix.org> ```js
> class C {}
> function g() { return new C(); }
> const o2 = g(); // C {}
> const o3 = new g(); // C {}
> ```

This is not the same as `new new Function()`

[06:18:41.0933] <shu>
sarahghp: always good to hear a practitioner's take, thanks

[06:18:46.0088] <waldemar>
I know.

[06:18:46.0709] <jschoi>
* PFA syntax and bind-this can also work together, when creating bound functions with multiple partially applied arguments, which people sometimes do use `bind` for.
From svgo@1.2.2:
```js
smartRound.bind(this, params.floatPrecision)
x => this::smartRound(params.floatPrecision, x)
this::smartRound~(params.floatPrecision, ?)
```

[06:19:32.0303] <rbuckton>
That was the point I was addressing though.

[06:19:53.0697] <waldemar>
We're still talking past each other,.

[06:20:27.0558] <waldemar>
If you wrap new so that it's invoked with a call, it makes no sense to new it again.

[06:20:56.0028] <waldemar>
We have no concept of a double-new.

[06:22:08.0855] <waldemar>
const g from the presentation should be only callable, not constructible.

[06:22:09.0397] <rbuckton>
My point was that the behavior is analogous to the `function g() { return new C(); }` example, above. Banning `new g()` seems strange to me, but I'm not opposed to that.

[06:23:03.0936] <rbuckton>
waldemar: I believe ljharb preferred the opposite, that a `new C~()` would *require* `new` at each call site.

[06:23:14.0651] <waldemar>
No because that function g does the same thing whether you new it or not. Use a function that does something different on new in the example.

[06:23:39.0451] <ljharb>
bound constructors require `new` at the callsite

[06:23:44.0788] <ljharb>
so that's the same thing i'd expect here

[06:23:47.0464] <rbuckton>
The approach I went with was to just do what `function g() { return new C(); }` does, in that calling `new g()` isn't valuable but doesn't break anything.

[06:24:44.0183] <Jack Works>
example code:

[06:25:02.0653] <Jack Works>
```ts
const x = module function f(a = expr()) {
}
```

[06:25:28.0495] <Jack Works>
although we know `expr()` must be evaluated in the new module, it's not clear on the syntax

[06:26:01.0509] <Jack Works>
because it didn't have a good visual separator `{ }`

[06:26:32.0847] <rbuckton>
A partial application of `new C~()` would make the `new` part of the result, regardless as to whether `C` is a class or function:
```js
function C() { }
function g() { return new C(); }
const o1 = g(); // C {}
const o2 = new g(); // C {}
```


[06:27:16.0051] <rbuckton>
> <@waldemarh:matrix.org> No because that function g does the same thing whether you new it or not. Use a function that does something different on new in the example.

 * A partial application of `new C~()` would make the `new` part of the result, regardless as to whether `C` is a class or function:
```js
function C() { }
function g() { return new C(); }
const o1 = g(); // C {}
const o2 = new g(); // C {}
```


[06:27:29.0104] <rbuckton>
The difference is between `C~()` and `new C~()`. 

[06:30:08.0370] <rbuckton>
if we don't have `new` in partial application, the behavior is the same as `.bind`:
```js
function C() {}
const g = C~();
const o1 = g(); // undefined
const o2 = new g(); // C {}
```

However, not having `new` feels strange in this example:
```js
class C {}
const g = C~(); // doesn't throw
const o1 = C(); // does throw, must use `new C()`
```

[06:30:16.0095] <Surma>
Process question: What do I do with reviewers? Do I have to collect/write them down somewhere?

[06:30:25.0257] <rbuckton>
 * if we don't have `new` in partial application, the behavior is the same as `.bind`:
```js
function C() {}
const g = C~();
const o1 = g(); // undefined
const o2 = new g(); // C {}
```

However, not having `new` feels strange in this example:
```js
class C {}
const g = C~(); // doesn't throw
const o1 = C(); // does throw, must use `new C()`
```

[06:30:53.0872] <rbuckton>
They're usually added to the notes.

[06:31:49.0473] <ryzokuken>
Surma: you may include a list of reviewers to the explainer/README, that's something folks do

[06:31:52.0946] <ljharb>
> <@rbuckton:matrix.org> if we don't have `new` in partial application, the behavior is the same as `.bind`:
> ```js
> function C() {}
> const g = C~();
> const o1 = g(); // undefined
> const o2 = new g(); // C {}
> ```
> 
> However, not having `new` feels strange in this example:
> ```js
> class C {}
> const g = C~(); // doesn't throw
> const o1 = C(); // does throw, must use `new C()`
> ```

i don't find that example strange because you're not actually invoking `C` in line 2 (unless you're saying people will be confused by PFA syntax and think it's invoking a function). i think `C()` and `g()` should throw the same, though.

[06:34:55.0027] <Jack Works>
https://github.com/tc39/proposal-js-module-blocks/issues/45

[06:36:33.0709] <rbuckton>
I'm fine with have partial application without `new` (in the partial call), if necessary. I still feel that its unfortunate we don't have a built-in way to allocate a class instance via callback w/o having to defer to arrow functions. If we had `Function.prototype.construct` (to mirror `Function.prototype.call`/`Reflect.construct`) I might be less concerned with supporting `new C~()`.
Something like:
```js
Function.prototype.construct = function (...args) {
  return new this(...args);
};

class C {}
const o1 = C.construct(); // C {}
const g = C.construct~(); 
const o2 = g(); // C {}
```

[06:37:14.0300] <rbuckton>
But that suffers from the same problem as `Function.prototype.bind`: needing to rely on a method that could be patched at runtime.

[06:37:23.0741] <Surma>
Can someone tell me Guy Bedfords association? Or where I can look it up?

[06:38:43.0008] <nicolo-ribaudo>
I think Guy is an Invited Expert

[06:41:06.0188] <Surma>
Stage 3 reviewers PR here! If I missed anyone, please leave a comment :) Thanks to everyone who volunteered!

https://github.com/tc39/proposal-js-module-blocks/pull/56

[06:41:09.0283] <Rob Palmer>
Guy is a delegate of OpenJS Foundation

[06:45:41.0305] <Michael Ficarra>
I have no normative comments for DurationFormat, but it does still need a bit of editorial work, which we can address during stage 3

[06:48:28.0842] <bterlson>
erights: welcome to the matrix

[06:48:29.0075] <erights>
(test please ignore)

[06:48:31.0403] <Jack Works>
> <@surma:matrix.org> Stage 3 reviewers PR here! If I missed anyone, please leave a comment :) Thanks to everyone who volunteered!
> 
> https://github.com/tc39/proposal-js-module-blocks/pull/56

Hi, can you add me too? And I think the sugar and issue 45 are two serious problem, we should not hurry to stage 3

[06:50:58.0404] <Surma>
THanks Jack Works. I‚Äôll add you to the PR 

[06:52:16.0171] <Surma>
Jack Works: Sorry, what‚Äôs your affiliation?

[06:55:18.0182] <Jack Works>
> <@surma:matrix.org> Jack Works: Sorry, what‚Äôs your affiliation?

Jack-Works on github

[06:55:33.0972] <HE Shi-Jun>
> <@michaelficarra:matrix.org> MM is making the exact point I wanted to make: readers are going to have a harder time with this, for basically no benefit

I'm not disagree MM, but IMO, hack style pipe have very similar problems. So...

[06:55:39.0125] <Jack Works>
I'm from Sujitech

[06:57:37.0274] <Michael Ficarra>
> <@haxjs:matrix.org> I'm not disagree MM, but IMO, hack style pipe have very similar problems. So...

Yeah I agree, but the pipe had so much community demand, we had to do *something*

[07:03:07.0293] <HE Shi-Jun>
> <@shuyuguo:matrix.org> gathering my thoughts some more: i can live with pipeline because, while i disagree with its motivations there as well (e.g. naming intermediates is too onerous), i have a sense that there is in fact a large number of folks clamoring for it and really want to type it. syntax catering to popularism is fine by me, active harm excepted. but here, i haven't gotten the sense there is a large number of folks clamoring for it

A very controversial questions: how "large number", and what's they really want? I have said many times, as my personal experience, most people who really like pipeline are come from fp community, and pipeline op in their mind === F# style pipeline, but we now go forward hack style...

[07:05:29.0951] <bakkot>
I just updated the conclusions for the various topics in the notes; presenters, please make sure I captured it accurately

[07:08:07.0459] <HE Shi-Jun>
> <@sarahghp:matrix.org> The kind of code to which pipeline applies (temp variables to make a transformation tube) is very common. I don't think I've ever come across cases where partial application of a middle argument is necessary.

I'd like to say, if u don't need papp, you will very likely also not need hack style pipeline but only f# style pipeline :-)

[07:08:54.0895] <ljharb>
i don't need partial application, but i desperately need hack style pipeline, more than i need F# style

[07:09:18.0001] <ljharb>
(i could use all three for things, but "need" is different than "could use")

[07:12:25.0471] <sarahghp>
Yes, I think I am more in ljharb 's boat there as well.

[07:12:38.0966] <sarahghp>
It's rare I do PFA that bind would not suffice for.

[07:13:35.0812] <HE Shi-Jun>
> <@michaelficarra:matrix.org> Yeah I agree, but the pipe had so much community demand, we had to do *something*

Well I hope that would be "we had to do something which really match people real requirements"

[07:17:00.0765] <HE Shi-Jun>
> <@ljharb:matrix.org> i don't need partial application, but i desperately need hack style pipeline, more than i need F# style

This is quite strange, in 80% cases, hack style pipeline can be replaced by f# style + partial application.

[07:17:08.0228] <ljharb>
can't speak for everyone, but my real requirements are "be able to make nested function calls, some of whose arguments are non-simple expressions, left to right"

[07:17:29.0147] <ljharb>
what i mean is, i don't need what F# or PFA offers, but of course they can be *used* for what i need

[07:17:48.0631] <ljharb>
the smallest thing that does what i need tho is hack, and i don't have a need for PFA outside of that.

[07:17:52.0554] <rbuckton>
JavaScript straddles the fence between an OOP-style language and an FP-style language, without really being stellar at either. The partial application and pipeline proposals (in their various forms) have been trying to chip away at the FP-style side since 2018 to improve the language for those folks, similar to the decorators and public/private field proposals trying to chip away at the OOP-style side.

[07:18:59.0856] <shu>
HE Shi-Jun: polling is a hard problem. we'll never really have the resources to do scientific polling. if your question leads to "we should ignore developer signals because we don't have a good enough polling mechanism", that's not a position that reckons with reality

[07:19:26.0637] <shu>
so we do with the best we have, direct constituents we can poll (e.g. internal partners at our workplaces), anecdotes, compelling arguments from delegates, etc

[07:19:58.0290] <shu>
and the sense from those various sources is that there is enough demand for pipelines for us to do something, despite my personal reservations

[07:20:23.0753] <HE Shi-Jun>
> <@ljharb:matrix.org> the smallest thing that does what i need tho is hack, and i don't have a need for PFA outside of that.

so that's the point, u only want the part which just match your cases, but I don't think it's a good design choice, because separate f# + papp could have better orthogonality and composablity.

[07:20:43.0877] <sarahghp>
I guess ‚Äî and I am being genuine here ‚Äî I don't really see how PFA helps with the FP-"flavored" JS with which I am most familiar. The hard-core FP heads already are living their unary lives if the F# threads are to be believed and otherwise idiomatic JS is written so that arguments apply in order or are argument bags.

[07:20:49.0307] <sarahghp>
> <@rbuckton:matrix.org> JavaScript straddles the fence between an OOP-style language and an FP-style language, without really being stellar at either. The partial application and pipeline proposals (in their various forms) have been trying to chip away at the FP-style side since 2018 to improve the language for those folks, similar to the decorators and public/private field proposals trying to chip away at the OOP-style side.

 * I guess ... and I am being genuine here, I don't really see how PFA helps with the FP-"flavored" JS with which I am most familiar. The hard-core FP heads already are living their unary lives if the F# threads are to be believed and otherwise idiomatic JS is written so that arguments apply in order or are argument bags.

[07:21:05.0094] <sarahghp>
 * I guess ‚Äî and I am being genuine here ‚Äî I don't really see how PFA helps with the FP-"flavored" JS with which I am most familiar. The hard-core FP heads already are living their unary lives if the F# threads are to be believed and otherwise idiomatic JS is written so that arguments apply in order or are argument bags.

[07:21:11.0598] <ljharb>
HE Shi-Jun: to be clear, i'm not opposed to F# or PFA, in general or on the basis of "it's more than i need". i'm just pointing out that your assertion that someone who needs hack will also need PFA or F# is incorrect.

[07:21:41.0947] <ljharb>
 * HE Shi-Jun: to be clear, i'm not opposed to F# or PFA, in general or on the basis of "it's more than i need". i'm just pointing out that your assertion that someone who needs hack will also need PFA is incorrect.

[07:23:38.0388] <ljharb>
 * HE Shi-Jun: to be clear, i'm not opposed to F# or PFA, in general or on the basis of "it's more than i need". i'm just pointing out that your assertion that someone who needs hack will also need PFA or F# is incorrect.

[07:24:35.0867] <shu>
zzz time

[07:27:03.0931] <HE Shi-Jun>
> <@shuyuguo:matrix.org> HE Shi-Jun: polling is a hard problem. we'll never really have the resources to do scientific polling. if your question leads to "we should ignore developer signals because we don't have a good enough polling mechanism", that's not a position that reckons with reality

Obviously I don't say ignore signals. I think everyone who attend the previous meetings should remember I explained many times I think pipeline requirements is very valid.  My point is we should also not ignore the other part, especially pipeline op proposal, there are many conflicts in the repos and some are even locked by the champions.  And I'm very worry about that what we as committee do on pipeline op, doesn't really solve the requirements of the developers.

[07:28:35.0563] <HE Shi-Jun>
But just "give people something".

[09:30:00.0278] <legendecas>
> <@michaelficarra:matrix.org> legendecas: the downside of `a.b~()` being the only way to bind is that it only allows binding to an object the function is already installed on, not an arbitrary object

thanks for the clarification! but doesn't that also indicate that we may have two ways to bind a method to object when bind operators also lands? that can be confusing for developers to choose in between.

[09:33:07.0266] <legendecas>
And they are both sugars for `Function.prototype.bind` with feature augmentations.

[09:41:11.0115] <jschoi>
> <@legendecas:matrix.org> And they are both sugars for `Function.prototype.bind` with feature augmentations.

I wouldn‚Äôt say that bind-this and PFA syntax overlap that much.
I wrote about this in https://github.com/js-choi/proposal-bind-this/blob/main/README.md#pfa-syntax. I also have a slide devoted to this in my upcoming presentation about bind-this.

[09:42:04.0801] <jschoi>
PFA syntax does not address the clunkiness of this:
```js
// bluebird@3.5.5/js/release/synchronous_inspection.js
isPending.call(this._target())
this._target()::isPending()
```
‚Ä¶or this:
```js
// ajv@6.10.0/lib/ajv.js
validate = macro.call(self, schema, parentSchema, it);
validate = self::macro(schema, parentSchema, it);
```

[09:42:25.0197] <jschoi>
Bind-this does not address `fn.bind(null, ...args)`.

[09:43:06.0057] <jschoi>
At most they overlap somewhat when the receiver object itself contains the function to which we wish to bind. In that case, PFA syntax would be terser than bind-this, because bind-this would require repeating the receiver.
```js
n.on("click", v.reset.bind(v)) // Note how v both contains v.reset and is the receiver of the function.
n.on("click", v::v.reset) // bind-this
n.on("click", v.reset~()) // PFA syntax
```

[09:43:30.0802] <jschoi>
 * At most they overlap somewhat when the receiver object itself contains the function to which we wish to bind. In that case, PFA syntax would be terser than bind-this, because bind-this would require repeating the receiver.
```js
n.on("click", v.reset.bind(v)) // Note how v both contains v.reset and is the receiver of the function.
n.on("click", v::v.reset) // bind-this
n.on("click", v.reset~()) // PFA syntax
```

[09:44:20.0881] <jschoi>
But there are many cases in which it is not the case that you want to bind/call a function on an object that does not already contain that function. In fact, that may be the majority of uses of `.call`. And there are a *lot* of uses of `.call`: it‚Äôs one of the most frequently used JavaScript methods.

[09:50:12.0040] <legendecas>
This is a very detailed explanation, thanks! I'm very eager to see the progress of bind operator. However, I'm a bit concerned that several proposals are trying to do it in different directions and they all overlaps in one use case or another.

[09:53:09.0824] <jschoi>
That is understandable. 
Do note that bind-this and PFA syntax could also work synergistically. 
```js
// svgo@1.2.2/plugins/convertTransform.js
smartRound.bind(this, params.floatPrecision) // Original
x => this::smartRound(params.floatPrecision, x) // bind-this
this::smartRound~(this, params.floatPrecision) // bind-this + PFA syntax
```


[10:00:11.0373] <jschoi>
 * That is understandable.
Do note that bind-this and PFA syntax could also work synergistically.
```js
// svgo@1.2.2/plugins/convertTransform.js
smartRound.bind(this, params.floatPrecision) // Original
x => this::smartRound(params.floatPrecision, x) // bind-this only
this::smartRound~(this, params.floatPrecision, ?) // bind-this + PFA syntax
```
Anyways, I view them as pretty orthogonal. I understand Yulia‚Äôs desire to see if there‚Äôs a grand unifying syntax that could address all of the use cases, but I think the old bind operator kind of tried to do that and got stuck in the muck. bind-this, at least, tries to solve only one problem: .call/.bind are very common but are very clunky. Because of that, it can combine with PFA syntax or the pipe operator or whatever well.

[10:00:27.0951] <jschoi>
 * That is understandable.
Do note that bind-this and PFA syntax could also work synergistically.
```js
// svgo@1.2.2/plugins/convertTransform.js
smartRound.bind(this, params.floatPrecision) // Original
x => this::smartRound(params.floatPrecision, x) // bind-this only
this::smartRound~(this, params.floatPrecision, ?) // bind-this + PFA syntax
```

Anyways, I view PFA syntax and bind-this (and pipe operator) as pretty orthogonal. I understand Yulia‚Äôs desire to see if there‚Äôs a grand unifying syntax that could address all of the use cases, but I think the old bind operator kind of tried to do that and got stuck in the muck. bind-this, at least, tries to solve only one problem: .call/.bind are very common but are very clunky. Because of that, it can combine with PFA syntax or the pipe operator or whatever well.

[10:05:23.0541] <legendecas>
`this::smartRound~(this, params.floatPrecision, ?)` Sorry but I'm confused by this example. Why the first argument of `~()` is been treated as this binding?

[10:51:11.0673] <shu>
HE Shi-Jun: i hear you, but we've been debating "which pipeline" on more principled grounds for _years_ with no real progress

[11:14:10.0094] <Ashley Claymore>
IMO one nice little detail of hack pipes is that they can be slotted into the middle of a method call chain without changing any of the surrounding code

```
arr
  .map(f)
  .filter(g)
  |> customMethod(%)   // added in later
  .reduce(j, unit)
```


[11:17:02.0358] <Ashley Claymore>
* IMO one nice little detail of hack pipes is that they can be slotted into the middle of a method call chain without changing any of the surrounding code

```
arr
  .map(f)
  .filter(g)
  |> customMethod(%) // added later
  .reduce(j, unit)
```


[11:17:21.0965] <Ashley Claymore>
* IMO one nice little detail of hack pipes is that they can be slotted into the middle of a method call chain without changing any of the surrounding code

```
arr
  .map(f)
  .filter(g)
  |> customMethod(%) // added later
  .reduce(h, unit)
```


[11:25:14.0566] <jschoi>
Apologies; I made an error. It should indeed be `this::smartRound~(params.floatPrecision, ?)` to be equivalent to `x => this::smartRound(params.floatPrecision, x)`. I have corrected my previous message.

[11:25:20.0507] <jschoi>
 * That is understandable.
Do note that bind-this and PFA syntax could also work synergistically.
```js
// svgo@1.2.2/plugins/convertTransform.js
smartRound.bind(this, params.floatPrecision) // Original
x => this::smartRound(params.floatPrecision, x) // bind-this only
this::smartRound~(params.floatPrecision, ?) // bind-this + PFA syntax
```

Anyways, I view PFA syntax and bind-this (and pipe operator) as pretty orthogonal. I understand Yulia‚Äôs desire to see if there‚Äôs a grand unifying syntax that could address all of the use cases, but I think the old bind operator kind of tried to do that and got stuck in the muck. bind-this, at least, tries to solve only one problem: .call/.bind are very common but are very clunky. Because of that, it can combine with PFA syntax or the pipe operator or whatever well.

[11:25:28.0049] <jschoi>
> <@legendecas:matrix.org> `this::smartRound~(this, params.floatPrecision, ?)` Sorry but I'm confused by this example. Why the first argument of `~()` is been treated as this binding?

 * Apologies; I made an error. It should indeed be `this::smartRound~(params.floatPrecision, ?)` to be equivalent to `x => this::smartRound(params.floatPrecision, x)`. I edited my message.

[11:26:27.0965] <jschoi>
 * Apologies; I made an error. It should indeed be `this::smartRound~(params.floatPrecision, ?)` to be equivalent to `x => this::smartRound(params.floatPrecision, x)`. I have corrected my previous message.

[12:42:32.0488] <devsnek>
> <@aclaymore:matrix.org> IMO one nice little detail of hack pipes is that they can be slotted into the middle of a method call chain without changing any of the surrounding code
> 
> ```
> arr
>   .map(f)
>   .filter(g)
>   |> customMethod(%) // added later
>   .reduce(h, unit)
> ```

the ambiguity on that method access is very scary

[12:53:47.0921] <ljharb>
how is it ambiguous?


2021-10-26
[18:01:45.0760] <ptomato>
another heads up for delegates, about Temporal. we got another spec bug report from two implementors today, and while investigating that one, Justin found another spec bug. I've added the fixes to the slides that I will present on Wednesday, but again since they are late additions, we understand if delegates will need more time to consider them.

[20:05:46.0358] <jschoi>
Was there no CoC Committee update in the first session? It was on the agenda, but I didn‚Äôt hear any update and it‚Äôs not in the notes.

[01:43:49.0592] <sarahghp>
No, I think the plan was to have it later. 

[01:57:38.0797] <Rob Palmer>
The Halloween edition of TC39 plenary will begin in 3 mins.

[01:59:38.0301] <Surma>
üëª

[02:03:29.0357] <nicolo-ribaudo>
I forget it every time: I don't have to fill the form every day, right?

[02:03:35.0229] <nicolo-ribaudo>
 * I forget it every time: I don't have to fill the form every day, right?

[02:04:46.0934] <Rob Palmer>
correct, nicolo - we keep the same password

[02:04:57.0777] <Rob Palmer>
we just need each attendee to fill it in once

[02:05:04.0355] <nicolo-ribaudo>
Ok thanks!

[02:10:19.0199] <sarahghp>
(I had to do it twice because if you don't open matrix in a new window or save the info, you can't get back to it üôà)

[02:16:31.0928] <Tierney Cyren>
oh hi Surma 

[02:16:56.0696] <Surma>
üëã Tierney Cyren 

[02:17:11.0246] <Tierney Cyren>
glad to see you here :)

[02:18:57.0194] <devsnek>
üëãhello

[02:20:28.0557] <bakkot>
for the notes: frank said 3 PRs, but I can't figure out what the third one was

[02:20:30.0481] <bakkot>
anyone know?

[02:20:32.0697] <rbuckton>
That looked like it worked.

[02:20:41.0480] <bakkot>
there was the non-continuous weekend one and the annex A one and then a third one

[02:21:19.0898] <ryzokuken>
"canonical"?

[02:21:26.0687] <bakkot>
ah yes thanks

[02:23:22.0818] <devsnek>
queue may be confused https://gc.gy/285b32a5-6cd1-4c10-9e9a-8a300f754897.png

[02:26:57.0041] <devsnek>
an engine could probably do nice stack traces like that itself, no need to include pos in the error

[02:30:32.0232] <devsnek>
shu: raw returns some magic object that tells json.stringify to use the string as source instead of a string

[02:30:59.0641] <rbuckton>
In the cases where I have needed position information in JSON, I've generally had to rely on something like the TypeScript parser and AST, even in a purely JS project. My use cases so far have been fairly niche, such as doing minor updates to an existing JSON file while preserving the source formatting (usually for JSON files intended to be both human and machine readable such as package.json).

[02:39:42.0422] <bakkot>
syg: right now, JSON.stringify of an object without a `toString` is guaranteed to do the thing you expect absent a reviver, but if the symbol is shared that's no longer true

[02:46:15.0404] <bakkot>
Michael Ficarra: I am strongly opposed to having the marker be an object with a symbol here because it implies that the engine will need to do a lookup on every object

[02:46:23.0948] <bakkot>
which is observable

[02:46:53.0114] <bakkot>
it's simpler in the sense of "fewer kinds of object in the language", true, but not in terms of "how much observable behavior there is", and the second thing seems like the thing we should be minimizing most of the time

[02:48:17.0197] <Michael Ficarra>
bakkot: fair point

[02:49:04.0438] <shu>
that's a good point

[02:49:16.0282] <shu>
though i don't think a particular problem for performance in the common case

[02:49:18.0605] <Michael Ficarra>
bakkot: how do we ensure these exotic marked objects don't usefully escape the callback?

[02:49:31.0682] <devsnek>
you don't

[02:49:39.0045] <Michael Ficarra>
is the value of the slot fresh?

[02:50:08.0564] <devsnek>
oh you mean per-invocation

[02:50:28.0599] <devsnek>
in terms of spec language you could say its `{[[Index]]: n, [[String]]: s}`

[02:50:48.0056] <devsnek>
and expect that index back

[02:50:55.0002] <devsnek>
or you could expect the whole object i guess

[02:50:57.0873] <devsnek>
cuz it has identity

[02:52:14.0216] <bakkot>
Michael Ficarra: you can't ensure they don't escape, but like devsnek says you have a field which indicates which invocation it is

[02:52:25.0301] <bakkot>
s/field/internal slot/

[02:52:28.0336] <shu>
> <@bakkot:matrix.org> syg: right now, JSON.stringify of an object without a `toString` is guaranteed to do the thing you expect absent a reviver, but if the symbol is shared that's no longer true

is that something that's generally depended upon?

[02:52:41.0243] <devsnek>
```js
let thing;
let raw = (v) => {
  thing = { v };
  return thing;
};
const result = callback(key, value, { raw });
if (thing && result === thing) {
```

[02:52:48.0816] <Michael Ficarra>
okay I mean a counter is just a fresh value, so I'm fine with that

[02:52:55.0095] <shu>
like, wouldn't the new guidance be "here's another hook we need, if you hook into it, well, you get hook behavior"

[02:52:55.0098] <bakkot>
and stringify encounters an object with this slot holding a different value than for the current invocation it can throw

[02:53:03.0030] <devsnek>
what happens if you call raw multiple times in one callback

[02:53:05.0811] <bakkot>
 * and stringify encounters an object with this slot holding a different value than for the current invocation it can throw

[02:53:14.0277] <Michael Ficarra>
devsnek: same index

[02:53:15.0893] <devsnek>
i feel like that should work, you could compose a sub-object

[02:53:45.0596] <nicolo-ribaudo>
Tbh I would expect the argument to `raw` to always be a string

[02:53:48.0879] <nicolo-ribaudo>
Otherwise it's not raw

[02:53:54.0446] <devsnek>
no i mean like

[02:54:16.0910] <devsnek>
`(key, value, { raw }) => ({ a: raw(foo), b: raw(bar) })`

[02:54:32.0225] <nicolo-ribaudo>
uh ok, that makes sense

[02:55:10.0571] <nicolo-ribaudo>
For example to represent a `class Fraction { #numerator: bigint; #denominator: bigint }`

[02:55:29.0742] <nicolo-ribaudo>
 * For example to represent a `class Fraction { #numerator: bigint; #denominator: bigint }`

[02:55:30.0803] <devsnek>
ye you could put a tojson on that

[02:55:36.0078] <devsnek>
which uses raw

[02:56:24.0632] <bakkot>
toJson wouldn't get passed `raw`

[02:56:25.0492] <bakkot>
I think

[02:56:41.0445] <bakkot>
unless we do the global well-known symbol approach

[02:56:55.0938] <devsnek>
why does it matter which approach

[02:57:00.0399] <nicolo-ribaudo>
Can't toJSON receive a parameter even if it's not global?

[02:57:04.0150] <devsnek>
i think tojson should get to participate 

[02:57:23.0202] <nicolo-ribaudo>
> <@nicolo-ribaudo:matrix.org> Can't toJSON receive a parameter even if it's not global?

(it _could_ break something?)

[02:57:30.0158] <bakkot>
I mean it could but it doesn't in the current proposal

[02:57:37.0694] <bakkot>
> <@nicolo-ribaudo:matrix.org> Can't toJSON receive a parameter even if it's not global?

 * I mean it could but it doesn't in the current proposal

[02:57:59.0430] <bakkot>
also if we're going to let toJson participate I think a well-known symbol would make more sense anyway

[02:58:22.0581] <bakkot>
since the point of having the per-invocation value is to ensure the stringifier callback has control

[02:58:37.0829] <bakkot>
and toJson is for giving the objects being serialized control

[02:59:24.0444] <bakkot>
though, I guess a global well-known symbol means we'd be imposing a cost on all _existing_ serialization calls, which seems bad

[03:01:38.0248] <shu>
extra get per object in the graph to be stringified does seem bad

[03:01:47.0170] <shu>
though isn't that an issue even with a per-stringify symbol

[03:02:46.0597] <bakkot>
yeah

[03:02:54.0437] <bakkot>
not with an opaque object though!

[03:03:29.0873] <shu>
well, not an extra get but an extra slot check, which ought to be much cheaper, yes

[03:03:37.0761] <bakkot>
so, ok, here is an alternate possible design which I don't hate:

add a new `JSON.rawString` which returns an opaque, frozen, null-prototype object with a new internal slot holding a string (which has been checked to be valid JSON - maybe even a valid JSON primitive?). this can be called by any code. if JSON.stringify encounters such an object, it serializes it to its internal slot

[03:03:59.0955] <bakkot>
then toJson can use this function, and revivers can as well

[03:04:41.0174] <bakkot>
basically just the "allow it to be not per-invocation" approach, but with internal slots instead of symbols

[03:04:58.0652] <shu>
+1 from me. if the opaque object has gensym behavior it also complicates the performance of the slot check

[03:05:13.0984] <bakkot>
"has gensym behavior"?

[03:05:38.0860] <devsnek>
https://gc.gy/d9ff7617-8eb7-4039-81bf-ac0201805137.png

[03:05:42.0647] <shu>
the fresh minting behavior where each invocation of stringify has a new kind of opaque object only valid for that invocation

[03:06:03.0056] <devsnek>
gensym = generate symbol?

[03:06:12.0792] <shu>
yeah

[03:06:31.0032] <shu>
it's the scheme thing that returns fresh symbols

[03:09:52.0872] <bakkot>
I know what gensym is but am confused about how it affects GC here

[03:10:24.0663] <bakkot>
oh, unless you're thinking about the GC of the underlying string?

[03:10:45.0637] <bakkot>
I would just not worry about the fact that holding the opaque object holds the string, I guess

[03:10:55.0827] <shu>
no not gc

[03:11:25.0989] <shu>
i meant the "is this one of them opaque objects" checks

[03:11:32.0837] <bakkot>
oh

[03:11:58.0170] <bakkot>
I mean, you check if it has the slot, and then if it does you check if the value for the slot matches the value for the current invocation

[03:12:01.0337] <bakkot>
seems not so bad

[03:12:13.0277] <bakkot>
and it's just the presence-of-slot check which gets paid by code not using this capability

[03:14:35.0097] <shu>
agree, seems not so bad

[03:15:45.0763] <Michael Ficarra>
yeah I favour this raw function that returns an object with an internal slot with index (or two such slots) option now

[03:15:53.0600] <bakkot>
github issue: https://github.com/tc39/proposal-json-parse-with-source/issues/19

[03:16:33.0094] <bakkot>
Michael Ficarra: https://github.com/tc39/proposal-json-parse-with-source/issues/18#issuecomment-951789801

[03:16:36.0117] <shu>
Michael Ficarra: what index? the per-invocation counter?

[03:16:50.0725] <shu>
ehh, i'd still rather we just have global

[03:17:20.0845] <rbuckton>
The only issue I see with an exotic object is if you write any custom JSON serialization logic today in a replacer/reviver, you would need to be able to test whether the object is one of these exotic objects so you can pass it through rather than trying to convert it yourself.

[03:17:35.0260] <Michael Ficarra>
yes, per-Json-stringify counter and possibly a per-callback counter

[03:17:45.0458] <shu>
i am against a per-callback counter

[03:17:58.0783] <Michael Ficarra>
that's probably fine shu 

[03:18:15.0671] <shu>
i am also against a per-invocation counter and favor bakkot's concrete alternative, to be clear

[03:18:21.0848] <shu>
but i am more against per-callback counter

[03:18:29.0263] <rbuckton>
So you need both a `JSON.rawSting` and a `JSON.isRawString`, otherwise it comes *harder* to write serializers/deserializers.

[03:18:53.0953] <devsnek>
what do you do with isRawString

[03:19:58.0906] <rbuckton>
If you do custom serialization of any kind you need to know if the object you get in your custom serializer/replacer is this special exotic object or some other object.

[03:20:35.0846] <nicolo-ribaudo>
fwiw, in the R&T repository there has been a bunch of discussion about tagged strings (https://github.com/tc39/proposal-record-tuple/issues/258#issuecomment-947115796). This feels similar, since it's a string tagged with `JSON.rawString`.

(we are not looking to include tagged strings in the R&T proposal)

[03:20:49.0528] <devsnek>
why do you need to know

[03:20:53.0010] <nicolo-ribaudo>
 * fwiw, in the R&T repository there has been a bunch of discussion about tagged strings (https://github.com/tc39/proposal-record-tuple/issues/258#issuecomment-947115796). This feels similar, since it's a string tagged with `JSON.rawString`.

(we are not looking to include tagged strings in the R&T proposal)

[03:21:55.0777] <devsnek>
> <@nicolo-ribaudo:matrix.org> fwiw, in the R&T repository there has been a bunch of discussion about tagged strings (https://github.com/tc39/proposal-record-tuple/issues/258#issuecomment-947115796). This feels similar, since it's a string tagged with `JSON.rawString`.
> 
> (we are not looking to include tagged strings in the R&T proposal)

this issue makes me very sad, previously we said that Box(v) should always work without you having to care what v is

[03:22:25.0904] <rbuckton>
A naive replacer might do:
```js
function serializer(value) {
  if (typeof value === "object") {
    if (Array.isArray) { ... }
    const result = {};
    for (const key in value) { ... } 
    return result; // uh oh, we've replaced the exotic object with an empty normal object.
  }
  ...
}
```

[03:22:51.0618] <rbuckton>
If there's no way to test, you have to expect to pass through objects with no keys, which adds complexity.

[03:23:08.0765] <bakkot>
rbuckton: `JSON.isRawString = o => o && typeof o === 'object' && !(toJSON in o) && !['{', '['].includes(JSON.stringify(o))`

[03:23:13.0692] <Michael Ficarra>
> <@nicolo-ribaudo:matrix.org> fwiw, in the R&T repository there has been a bunch of discussion about tagged strings (https://github.com/tc39/proposal-record-tuple/issues/258#issuecomment-947115796). This feels similar, since it's a string tagged with `JSON.rawString`.
> 
> (we are not looking to include tagged strings in the R&T proposal)

I really don't like attaching state to strings or any object in a way that is not only immediately consumed

[03:23:36.0064] <Michael Ficarra>
if we do that, we'd have to at least have a testing function like what Ron's talking about

[03:23:57.0006] <Michael Ficarra>
but then you force anyone using this feature to test anything that goes into their returned object

[03:23:59.0872] <bakkot>
> <@bakkot:matrix.org> rbuckton: `JSON.isRawString = o => o && typeof o === 'object' && !(toJSON in o) && !['{', '['].includes(JSON.stringify(o))`

(assuming that `isRawString` enforces that its argument is a primitive JSON string or digit sequence)

[03:24:05.0902] <rbuckton>
The upside of a symbol is its something you can check for.

[03:24:09.0259] <bakkot>
(to be clear, not saying this is great, just saying that it's possible-ish without a new function)

[03:24:25.0076] <nicolo-ribaudo>
> <@bakkot:matrix.org> rbuckton: `JSON.isRawString = o => o && typeof o === 'object' && !(toJSON in o) && !['{', '['].includes(JSON.stringify(o))`

A `JSON.rawString("{}")` would be observabily the same as `Object.freeze({ __proto__: null })`

[03:24:47.0271] <rbuckton>
bakkot: So, your suggestion is to JSON.stringify an arbitrarily complex/large object that may have its own nested toJSON just to check for an exotic raw string object?

[03:24:56.0523] <bakkot>
nicolo-ribaudo: "assuming that isRawString enforces that its argument is a primitive JSON string or digit sequence"

[03:25:19.0393] <nicolo-ribaudo>
> <@bakkot:matrix.org> nicolo-ribaudo: "assuming that isRawString enforces that its argument is a primitive JSON string or digit sequence"

Whops, I didn't read it

[03:25:26.0049] <bakkot>
rbuckton: you can add `Object.keys(o).length === 0` if you're worried about that

[03:25:27.0524] <rbuckton>
It would have to be much more robust, checking for null prototype, no properties, etc.

[03:26:57.0391] <rbuckton>
bakkot: More like `Object.getPrototypeOf(o) === null && Object.getOwnPropertyNames(o).length === 0 && Object.getOwnPropertySymbols(o).length === 0` etc.

[03:27:13.0332] <bakkot>
unless you're concerned about proxies, I don't think you need those additional checks

[03:27:58.0078] <bakkot>
no non-exotic object can have the behavior that `toJSON` is absent and also `!['{', '['].includes(JSON.stringify(o)[0])`

[03:27:59.0560] <rbuckton>
In which case I point you at `Array.isArray`, which is better (and more reliable) than `o => typeof o === "object" && o !== null && Object.prototype.toString.call(o) === "[object Array]"`

[03:28:19.0009] <bakkot>
 * no non-exotic object can have the behavior that `toJSON` is absent and also `!['{', '['].includes(JSON.stringify(o)[0])`

[03:28:49.0505] <rbuckton>
I thought rawString could return a string that contains any valid JSON. Couldn't you do `JSON.rawString("{}")`, and wouldn't that fail the check?

[03:29:01.0104] <bakkot>
rbuckton: "assuming that isRawString enforces that its argument is a primitive JSON string or digit sequence"

[03:29:19.0915] <bakkot>
which I think it should, separately from this concern

[03:29:32.0823] <bakkot>
(otherwise you can abuse it to add whitespace, which seems bad)

[03:29:34.0876] <rbuckton>
That's fair, but you're still requiring a fairly complex check that could be more easily exposed by the language. 

[03:29:45.0512] <bakkot>
yeah

[03:30:02.0503] <bakkot>
like I said, not saying my proposal is great, just that it's possible-ish

[03:30:12.0142] <bakkot>
though I guess you _do_ also need to check for boxed numbers / strings, which is also annoying

[03:30:30.0178] <bakkot>
so yeah it seems reasonable to add `isRawString`

[03:31:08.0249] <rbuckton>
An `isRawString` shim is much more complex than an `isArray` shim, which means its much easier to get wrong if you're rolling your own serializer (which, I would argue, is the exact situation you're in if you're using this functionality).

[03:32:11.0985] <Tierney Cyren>
is there a good way for me to get involved in the LF discussion meetings?

[03:32:32.0203] <ryzokuken>
Tierney Cyren: you may join this ad-hoc group

[03:32:40.0784] <Tierney Cyren>
I've wanted to participate but how is unclear and I've not gotten around to asking

[03:32:50.0087] <ryzokuken>
write an email to Patrick and he'll add you to the mailing list/event

[03:32:53.0565] <ryzokuken>
 * write an email to Patrick and he'll add you to the mailing list/event

[03:33:29.0870] <ryzokuken>
talk to Isabelle, I think she's responsible for getting everyone interested from MS involved

[03:46:23.0686] <Tierney Cyren>
$4m seems like a lot but what's the actual runway that provides? 

[03:46:57.0054] <Tierney Cyren>
that number does not feel helpful in a vacuum

[04:59:38.0630] <Rob Palmer>
we are starting up plenary in 1 minute!

[05:06:00.0779] <devsnek>
it also happened with NativeError.prototype.toString lol

[05:06:53.0237] <devsnek>
chrome had that from 2016 to 2019 until i removed it

[05:09:53.0861] <Michael Ficarra>
instead of tightening host restrictions, can't we just make a section of test262 which is like "okay to fail, but should probably be looked at because it's more likely a bug"?

[05:10:13.0843] <devsnek>
i was just thinking that

[05:10:19.0127] <devsnek>
like a common-sense directory lol

[05:10:27.0077] <shu>
Michael Ficarra: yes, i plan to bring that up

[05:10:37.0479] <shu>
i object to this proposal

[05:10:38.0155] <Michael Ficarra>
thanks shu 

[05:10:43.0678] <devsnek>
what is this proposal

[05:10:48.0243] <shu>
but i'll wait for jordan to actually say the proposal first

[05:10:48.0516] <ljharb>
i haven't made it yet.

[05:10:51.0026] <shu>
before i add myself to the queue

[05:11:00.0642] <devsnek>
i assume its restricting names on prototypes or smth

[05:11:59.0335] <Michael Ficarra>
test262-parser-tests has a "fail" directory which is spiritually the same: https://github.com/tc39/test262-parser-tests/tree/master/fail

[05:12:29.0059] <ljharb>
"Any property on a given object mentioned in the specification, must ONLY appear in the locations specified on that object or its prototype chain"

[05:12:37.0684] <devsnek>
> <@michaelficarra:matrix.org> test262-parser-tests has a "fail" directory which is spiritually the same: https://github.com/tc39/test262-parser-tests/tree/master/fail

good filenames

[05:13:17.0122] <Michael Ficarra>
hey you try naming files with random non-programs

[05:13:29.0615] <Michael Ficarra>
pull requests welcome

[05:14:17.0867] <ryzokuken>
are the names just a hash of the source code or sth?

[05:14:22.0438] <ryzokuken>
 * are the names just a hash of the source code or sth?

[05:14:24.0800] <Michael Ficarra>
yep ryzokuken 

[05:14:43.0750] <devsnek>
i like test262 names

[05:17:07.0705] <bakkot>
man I gotta update that project

[05:17:10.0984] <ryzokuken>
`test-assignment-really-terribly-bad.js`

[05:19:26.0096] <bterlson>
would we need work in e.g. test262.report if we add a new test category?

[05:21:04.0517] <devsnek>
test262.report is bocoup right

[05:21:38.0729] <bterlson>
Yeah

[05:23:17.0920] <bterlson>
I wonder if there are test cases we would like to add to 262 aside from things we feel bold enough to tighten that would nonetheless be useful for impls? I seem to recall tests in this category back in the day but have forgotten

[05:23:48.0223] <devsnek>
gc tests :P

[05:26:36.0265] <bterlson>
devsnek: you ready to present extending null next?

[05:26:42.0857] <devsnek>
yep

[05:26:54.0805] <devsnek>
assuming i haven't fallen asleep by then

[05:27:03.0867] <bterlson>
do not fall asleep üòÅ

[05:27:43.0043] <Mathieu Hofman>
> <@devsnek:matrix.org> gc tests :P

Well for what it's worth, all those are busted right now (relies on removed `cleanupSome`). I have on my todo list of fixing all these

[05:28:04.0356] <devsnek>
i'm still sad about cleanupsome being separated

[05:28:24.0140] <bterlson>
Justin Ridgewell: if we need to pull in items today, are you available to present destructure private fields?

[05:38:33.0059] <erights>
NativeError.prototype.toString on v8 only shadows Error.prototype.toString uselessly 


[05:51:29.0767] <yulia>
hm i didn't really have a position

[06:02:12.0569] <yulia>
lol ok i am going to be the only one maybe

[06:05:18.0276] <rbuckton>
Could `super()` just be a no-op in `class extends null`?

[06:05:51.0421] <bakkot>
yulia: someone brought up the possibility of `class extends void {}` for a statically-analyzable version of `null`

[06:06:02.0219] <shu>
she brought that up, yeah

[06:06:08.0462] <bakkot>
oh yeah

[06:06:09.0129] <shu>
i guess some SM engineers thought it odd because (void 0) is undefined?

[06:06:12.0381] <bakkot>
sorry I'm tired

[06:06:14.0960] <yulia>
yeah

[06:06:17.0908] <shu>
that doesn't seem like a very big objection, though

[06:06:22.0449] <shu>
the void 0 thing

[06:06:35.0608] <yulia>
yeah i think it works kind off well personally

[06:06:46.0338] <ljharb>
it's super weird to not allow `extends X` for any valid X, and to force `null` to have a special syntactic form

[06:06:51.0743] <ljharb>
 * it's super weird to not allow `extends X` for any valid X, and to force `null` to have a special syntactic form

[06:07:12.0302] <ljharb>
null objects aren't supposed to be special, from a conceptual standpoint

[06:07:16.0424] <ljharb>
 * null objects aren't supposed to be special, from a conceptual standpoint

[06:07:21.0759] <bakkot>
`null` was already special

[06:07:27.0342] <bakkot>
you have to extend a _constructor_

[06:07:31.0571] <bakkot>
there is nothing weird about `null` not working

[06:07:34.0732] <yulia>
i would consider null special

[06:07:40.0595] <bakkot>
it was always going to be special-cased

[06:07:47.0892] <rbuckton>
Besides, you can't write `class extends void 0` since a `void` expression isn't a LHS expression

[06:07:54.0373] <devsnek>
the weird thing is that we special cased it to not throw on definition

[06:08:21.0550] <yulia>
if we can do this from a syntax perspective, i don't mind if super == this

[06:08:23.0106] <yulia>
thats fine

[06:08:56.0812] <rbuckton>
We could always have a shared %NullConstructor% that you assign as the base for `class extends null` so that `super()` could work.

[06:11:45.0179] <rbuckton>
i.e., change 8.f.ii. of ClassDefinitionEvaluation to be `Let constructorParent be %NullConstructor%.`, where %NullConstructor% is a built-in function purely for the purpose of supporting `super()`.

[06:11:57.0013] <rbuckton>
 * i.e., change 8.f.ii. of ClassDefinitionEvaluation to be `Let constructorParent be %NullConstructor%.`, where %NullConstructor% is a built-in function purely for the purpose of supporting `super()`.

[06:11:57.0940] <shu>
yulia: could you expand a bit on the runtime problem in SM?

[06:12:20.0568] <yulia>
basically, we won't be able to determine which bytecode we need to use until we execute it

[06:12:33.0454] <shu>
bytecode for what operation?

[06:12:56.0362] <yulia>
for the look up of the prototype iirc

[06:13:08.0887] <yulia>
im trying to find the notes just a sec

[06:13:14.0532] <shu>
thank you

[06:13:38.0932] <yulia>
"In this proposal if the base is null, the spec is asking for the constructor to still extend Function.prototype (which is reasonable enough). Normally we pull the super target function off the constructors own prototype while running, but in this case we also need to check elsewhere to find the original heritage to know if it was null vs explicitly Function.prototype.
This can be fixed for us by adding the original heritage (or at least a flag) to the JSFunction of the constructor. Problem is we don't really have a lot of spare slots or flags on functions themselves"

[06:14:08.0469] <ljharb>
Mathieu Hofman: it's not a base class _unless_ it inherits from Object.

[06:14:33.0585] <ljharb>
perhaps base classes should all have extended null, and `extends Object` should have been required to make something inherit from Object.prototype, but that ship's long gone

[06:14:42.0458] <shu>
ooh, i see

[06:14:58.0650] <shu>
that makes sense, yes, that's a bigger problem, in its requiring two bits of info

[06:17:10.0037] <ljharb>
(totally fine with me if the constructor itself also inherits from null)

[06:17:13.0060] <ljharb>
 * (totally fine with me if the constructor itself also inherits from null)

[06:17:30.0666] <bakkot>
the custructor should not inherit from null

[06:17:37.0807] <rbuckton>
> <@ljharb:matrix.org> (totally fine with me if the constructor itself also inherits from null)

This is problematic if you want to use `.bind`

[06:17:38.0370] <bakkot>
that makes the function prototype methods not available

[06:18:01.0909] <shu>
yes gut reaction for not having F.p methods on the constructor is "oof" from me

[06:18:25.0227] <ljharb>
Function.prototype.bind.call etc, which is already what robust code does

[06:18:32.0122] <devsnek>
do people use function prototype methods on constructors?

[06:18:34.0024] <bakkot>
ljharb: no code does that

[06:18:39.0324] <ljharb>
lol most doesn't, sure

[06:18:45.0731] <bakkot>
your code, my code, a couple of polyfills, and no one else in the entire world

[06:18:48.0016] <ljharb>
but how often are you binding constructors either

[06:18:52.0731] <bakkot>
not never!

[06:19:18.0070] <shu>
`‚ä§ class`

[06:19:39.0622] <bakkot>
that's `Object`

[06:19:51.0783] <bakkot>
or, well

[06:19:54.0837] <shu>
a _second_ top class

[06:19:56.0206] <bakkot>
i guess we don't really have a lattice

[06:20:03.0242] <devsnek>
TIL bound functions proxy [[Construct]]

[06:20:04.0898] <shu>
create your own!

[06:21:47.0743] <ljharb>
yulia: if the word `extends` appears then it's not a base class

[06:22:14.0520] <devsnek>
haha shu i was just thinking about structs

[06:22:16.0721] <ljharb>
a base class is `class {}` which includes inheriting from Object

[06:22:34.0158] <shu>
that is not the usual OO understanding of "base class"

[06:22:35.0156] <devsnek>
> <@ljharb:matrix.org> yulia: if the word `extends` appears then it's not a base class

with this pr that's not true

[06:22:56.0750] <ljharb>
i don't care what the spec says about what's base/derived, i'm concerned with what users think

[06:23:03.0126] <yulia>
i feel like this isn't a useful direction for the discussion? there are many ways to read it and virtual classes are really useful

[06:23:09.0624] <ljharb>
and the syntax determines that imo, not theoretical inheritance models

[06:23:21.0660] <yulia>
so, i am happy to consider other syntax

[06:23:32.0942] <yulia>
like, very much -- we don't have to have extends at all

[06:23:40.0335] <shu>
> <@ljharb:matrix.org> and the syntax determines that imo, not theoretical inheritance models

fairly strong disagree, actually, class hiearchies are very conceptual

[06:24:31.0407] <ljharb>
if that were broadly true then there would have been outcry that default class inheritance wasn't null

[06:24:48.0776] <ljharb>
Object.prototype isn't a "top class" because you can have things that don't inherit from it

[06:24:55.0424] <rbuckton>
a base class is defined in relation to a class definition. In `class B extends A {}`, `A` is a base class in that `B` derives from `A`. `B` could always be the base class for another definition (i.e., `class C extends B {}`).

[06:25:19.0226] <shu>
i meant more like "top of a lattice"

[06:25:33.0691] <rbuckton>
You can say that `B` is a subclass, and that `class A {}` is not a subclass

[06:25:34.0043] <shu>
ron's right on general use of "base class", ime

[06:25:40.0505] <ljharb>
i suspect i'm not familiar with that term in the way you're using it (lattice)

[06:25:57.0285] <bakkot>
strong agree with shu here

[06:26:00.0718] <Mathieu Hofman>
> <@rbuckton:matrix.org> a base class is defined in relation to a class definition. In `class B extends A {}`, `A` is a base class in that `B` derives from `A`. `B` could always be the base class for another definition (i.e., `class C extends B {}`).

I probably should have said "root class"

[06:26:42.0253] <jschoi>
`üå± class {}`

[06:26:59.0201] <jschoi>
[joke]

[06:27:32.0401] <yulia>
I am going to drop in 3 min, and caroline will take over for mozilla

[06:27:51.0111] <yulia>
so, any further questions on the null stuff, just dm me and ill get to it when im back

[06:30:53.0343] <shu>
ljharb: "root class" is just as cromulent for what i mean, the thing hierarchies top out at

[06:31:11.0923] <shu>
like, surely it's not just syntax, because we set up class hierarchies before `class` syntax was added

[06:31:16.0703] <shu>
and people understood them just fine

[06:33:06.0342] <ljharb>
sure but in those cases null and a constructor were 100% interchangeable

[06:33:33.0178] <ljharb>
you did have to either omit or conditionally call a superclass constructor, to be fair, but there wasn't a syntactic requirement around `super` there

[06:38:55.0393] <bterlson>
rbuckton: if we need will you be able to bring forward a regexp item to today?

[06:39:35.0833] <devsnek>
`Uint8Array.fromAsync(reader)` üëÄ

[06:39:53.0068] <Mathieu Hofman>
I personally do not think it's weird to have 2 ways to express syntactically a root class: `class {}` or `class extends void {}`. In both cases no `super()` would be allowed

[06:40:13.0299] <ljharb>
a root class doesn't extend anything.

[06:40:25.0633] <ljharb>
`root class {}` or something would at least not have that confusion

[06:40:31.0898] <rbuckton>
bterlson: That would be fine

[06:40:47.0377] <Mathieu Hofman>
My understanding is that in english `void` is nothing ;)

[06:41:02.0678] <ljharb>
`void` produces `undefined` which is a reified thing, not the absence of a thing

[06:41:12.0038] <ljharb>
 * `void` produces `undefined` which is a reified thing, not the absence of a thing

[06:41:13.0253] <devsnek>
technically in english void and null are synonyms

[06:41:27.0031] <Mathieu Hofman>
no, `void expr` produces `undefined`

[06:41:37.0650] <bakkot>
`class {}` does not literally "not extend anything" either - it extends `Object.prototype`

[06:41:41.0180] <ljharb>
right, currently that's the only way JS supports using `void`

[06:41:52.0191] <bakkot>
but, the way you think about it is that it does not extend anything

[06:41:57.0101] <ljharb>
bakkot: yes, that's true as well. but it's not explicitly claiming to not extend

[06:44:07.0850] <bakkot>
my point is that "`void` produces `undefined` which is a reified thing, not the absence of a thing" is true in a technical sense but it is also true in a technical sense that `class {}` is a base class but also extends `Object.prototype`, if you are being that kind of precise.

on the other hand, _colloquially_ it is understood that `class {}` is a base class, and I argue that _colloquially_ it would be easily understood that `extends void` means "does not extend anything"

[06:44:48.0340] <devsnek>
i would do `null class Foo {}`

[06:45:37.0917] <ljharb>
`const o = null { a: b }` when

[06:45:49.0978] <shu>
there's already __proto__ syntax tho

[06:45:56.0206] <devsnek>
wait hold on

[06:46:02.0339] <devsnek>
`class Foo { __proto__: null }`

[06:46:11.0155] <devsnek>
what does that do

[06:46:29.0963] <ljharb>
with the colon, it's a syntax error, in TS i'm not sure

[06:46:32.0171] <devsnek>
oh wait it uses DefineOwnProperty

[06:46:34.0853] <rbuckton>
Its a SyntaxError :)

[06:46:48.0654] <ljharb>
`__proto__ = null` would probably create a public class field, or throw, not sure

[06:46:50.0895] <bakkot>
can someone put in a conclusion for the previous agenda item in the notes

[06:46:51.0749] <devsnek>
man i really wish class fields used Set

[06:46:54.0757] <rbuckton>
In TS its says you have a field named `__proto__` whose type is `null`.

[06:47:03.0073] <bakkot>
I am so glad class fields do not use Set

[06:47:11.0311] <ljharb>
(re conclusion) there really isn't one i think, it's an update

[06:47:16.0219] <ljharb>
 * (re conclusion) there really isn't one i think, it's an update

[06:47:21.0307] <shu>
galaxy brain is: what if object literals used set

[06:47:25.0667] <bakkot>
they used to

[06:47:30.0514] <devsnek>
lol

[06:47:45.0038] <devsnek>
ok so we just need to special case

[06:47:49.0233] <devsnek>
`__proto__ = null` in classes

[06:48:11.0416] <bakkot>
```
The production
PropertyNameAndValueList : PropertyName : AssignmentExpression is evaluated as follows:
1. Create a new object as if by the expression new Object().
2. Evaluate PropertyName.
3. Evaluate AssignmentExpression.
4. Call GetValue(Result(3)).
5. Call the [[Put]] method of Result(1) with arguments Result(2) and Result(4).
6. Return Result(1).
```
~ ES3

[06:48:21.0994] <bakkot>
 * ```
The production
PropertyNameAndValueList : PropertyName : AssignmentExpression is evaluated as follows:
1. Create a new object as if by the expression new Object().
2. Evaluate PropertyName.
3. Evaluate AssignmentExpression.
4. Call GetValue(Result(3)).
5. Call the [[Put]] method of Result(1) with arguments Result(2) and Result(4).
6. Return Result(1).
```
~ ES3

[06:48:32.0071] <devsnek>
is that SSA

[06:49:31.0362] <rbuckton>
> <@devsnek:matrix.org> `__proto__ = null` in classes

Except that already has a well-defined behavior: 
```
> class C { __proto__ = null; }
undefined
> var o = new C();
undefined
> o
C { ['__proto__']: null }
```

[06:49:42.0800] <shu>
bakkot: wtf

[06:49:43.0167] <devsnek>
ya ik :(

[06:50:03.0520] <rbuckton>
Just need decorators:
```js
@extendsNull
class C {}
```

[06:50:28.0467] <bakkot>
shu: yeah it was a wild time

[06:50:30.0046] <Michael Ficarra>
rbuckton: doesn't matter if nobody relies on it

[06:50:33.0887] <devsnek>
i need to convert more people to my function decorator cult

[06:50:50.0865] <Michael Ficarra>
devsnek: I'm always willing to try a new cult

[06:51:19.0046] <rbuckton>
> <@devsnek:matrix.org> i need to convert more people to my function decorator cult

But the hoisting problem though

[06:51:43.0155] <devsnek>
that kind of hoisting is almost never used in practice

[06:51:53.0542] <devsnek>
i don't know a case where its *needed*

[06:52:03.0123] <rbuckton>
Function expression decorators: ‚úîÔ∏è
Function declaration decorators: ‚ò†Ô∏è

[06:52:32.0194] <devsnek>
i seriously believe we can do decorators on function declarations by just not hoisting the function value

[06:52:35.0393] <rbuckton>
> <@devsnek:matrix.org> that kind of hoisting is almost never used in practice

That kind of hoisting is about 80% of the TypeScript compiler 

[06:52:38.0027] <devsnek>
no one will notice

[06:52:41.0101] <bakkot>
i definitely hoist a lot of functions

[06:52:52.0267] <bakkot>
on the other hand, decorators are bad, so I'm ok with them being harder to use :P

[06:52:52.0383] <devsnek>
but do you call them before their declaration 

[06:52:54.0432] <devsnek>
or just refer to them

[06:52:57.0299] <bakkot>
devsnek: yes

[06:53:00.0976] <bakkot>
call them

[06:53:06.0164] <devsnek>
ok but

[06:53:07.0652] <devsnek>
you can just

[06:53:10.0739] <devsnek>
not put decorators on that code

[06:53:11.0385] <bakkot>
functions go at the bottom, logic goes at the top

[06:53:15.0922] <bakkot>
(for scripts)

[06:53:29.0103] <devsnek>
its a simple choice

[06:53:49.0992] <rbuckton>
At one point I was thinking about this:
```js
// not hoisted
// not reassignable
const function f() {} 

// ok
@dec
const function f() {}

// syntax error
@dec
function f() {}
```

[06:54:10.0778] <rbuckton>
as a shorthand for `const f = function () {}`

[06:54:14.0622] <devsnek>
ron i won't accept stylistic practice from the typescript compiler source

[06:54:18.0586] <bakkot>
`const function` means a different thing

[06:54:19.0331] <devsnek>
until you get rid of the 40k line file

[06:54:45.0814] <rbuckton>
> <@bakkot:matrix.org> `const function` means a different thing

in some languages, yes.

[06:55:06.0543] <rbuckton>
Either way, I'm all for function expression decorators.

[06:55:20.0020] <devsnek>
anyway i think this would work in practice and i encourage some company that has resources to do research to research it

[06:55:25.0621] <rbuckton>
Just not a fan of adding a decorator breaking hoisting on a function declaration.

[06:56:20.0864] <devsnek>
i don't think it counts as "breaking" as much as a tradeoff, it certainly doesn't have any impact on existing code

[06:56:22.0803] <rbuckton>
since it also can break circular imports

[06:56:25.0685] <devsnek>
 * i don't think it counts as "breaking" as much as a tradeoff, it certainly doesn't have any impact on existing code

[06:56:31.0782] <devsnek>
it can't break circular imports

[06:56:42.0301] <bakkot>
re: the actual presentation, I strongly agree with WH

[06:56:50.0500] <bakkot>
sqrt is good, we should have it

[06:56:54.0464] <devsnek>
i mean it can break stuff but that's unrelated to the circular importing

[06:57:05.0628] <rbuckton>
Its the same hoisting problem. Hoisted functions are reachable in a circular import.

[06:58:19.0238] <devsnek>
right i'm just saying the base case is unchanged and the worst case is the same case as an undecorated class or a variable decoaration

[06:58:25.0129] <rbuckton>
> <@devsnek:matrix.org> i don't think it counts as "breaking" as much as a tradeoff, it certainly doesn't have any impact on existing code

The problem with existing code is that existing code is some the code I want to decorate, and adding a decorator would change the semantics in a non-obvious way.

[06:58:57.0675] <devsnek>
its the same hazard as migrating function to class

[06:59:56.0584] <rbuckton>
There's a hidden hazard with decorators that doesn't exist when you're changing `function` -> `class`, in that its still `function`.

[07:00:11.0122] <ljharb>
adding a decorator to something definitely risks all sorts of breakage; it's not something you can expect to do transparently

[07:00:41.0841] <rbuckton>
If someone is using TypeScript (or JS with the TS language service), we could give you errors on decorated function decls. 

[07:00:53.0798] <ljharb>
you could do that when it breaks hoisting too

[07:01:12.0420] <ljharb>
(not arguing for breaking hoisting, necessarily, but none of those are compelling arguments against doing so to me)

[07:01:19.0146] <devsnek>
p sure the two most popular eslint configs yell at you about hoisting and circulars, separately

[07:01:27.0805] <devsnek>
 * p sure the two most popular eslint configs yell at you about hoisting and circulars, separately

[07:02:35.0068] <devsnek>
anyway that's my hill

[07:03:05.0385] <devsnek>
honestly i don't even know what i would use decorators on classes for lol

[07:03:35.0133] <devsnek>
and yes i know there are use cases, that's just where i'm at personally

[07:03:52.0407] <ljharb>
i very much want
```
@bound
method () {}
```
to be a thing

[07:03:55.0511] <rbuckton>
> <@devsnek:matrix.org> honestly i don't even know what i would use decorators on classes for lol

I use them in TS for so many things.

[07:04:12.0063] <rbuckton>
I want function decorators, but I also want parameter decorators.

[07:04:17.0423] <devsnek>
i just want `@router.get('/foo') function getFoo() {}`

[07:04:54.0491] <ljharb>
why that over `router.get('/foo')(function getFoo() {})`?

[07:05:09.0969] <devsnek>
because that's ugly and weird

[07:05:33.0521] <devsnek>
and it doesn't compose well

[07:06:03.0223] <devsnek>
`@get('/foo') @loginRequired({ admin: true }) @ratelimit(4, 1) function getFoo() {}`

[07:06:25.0007] <ljharb>
`|>`?

[07:06:26.0299] <rbuckton>
One reason:
```js
const getFoo = router.get('/foo')(() => {});
getFoo.name; // ""

// vs
const getFoo = @router.get('/foo') () => {}
getFoo.name; // "getFoo"
```

[07:06:35.0219] <devsnek>
lol

[07:06:47.0583] <ljharb>
lol fair, but that's not compelling to me; if you want a name don't use arrows

[07:06:55.0959] <devsnek>
i do not like expression position decorators lol

[07:06:56.0082] <ljharb>
i will always believe FNI was a mistake

[07:07:36.0203] <rbuckton>
ljharb: You want `@bound`, let the snek have `@dec function f() {}`.

[07:07:41.0941] <Michael Ficarra>
FNI was a mistake only if you think name is anything other than a debugging facility

[07:07:45.0279] <ljharb>
lol

[07:08:05.0244] <ljharb>
> <@michaelficarra:matrix.org> FNI was a mistake only if you think name is anything other than a debugging facility

i think it's a mistake BECAUSE it's a debugging facility. inferred names are harder to grep for.

[07:08:23.0580] <bakkot>
> i just want `@router.get('/foo') function getFoo() {}`

oh god, this is the strongest argument against function decorators I've yet seen

[07:08:29.0928] <devsnek>
just have a code server that supports fni

[07:08:39.0390] <bakkot>
if people are going to write code like that we should not have function decorators

[07:09:21.0767] <devsnek>
like what

[07:09:23.0106] <rbuckton>
The VS Code codebase uses so many parameter decorators for DI, we really need parameter decorators shortly after class/member decorators.

[07:09:25.0647] <devsnek>
oh

[07:09:35.0044] <devsnek>
bakkot: have you never used flask in python

[07:09:43.0452] <bakkot>
devsnek: yeah, it's _awful_

[07:09:43.0847] <devsnek>
its incredible 

[07:09:48.0036] <devsnek>
lol

[07:09:50.0095] <rbuckton>
Parameter decorators are so much higher on my list of priorities than function decorators, tbh.

[07:09:52.0032] <bakkot>
especially debugging other people's flask apps

[07:09:58.0096] <bakkot>
just instantly unmaintaintable nightmares

[07:10:11.0771] <devsnek>
idk i love it

[07:10:20.0312] <devsnek>
aside from the globals

[07:10:21.0770] <rbuckton>
Worst case, you can do:
```js
const { getFoo, ... } = class {
  @router.get("/foo")
  static getFoo() {}
};
```

[07:10:22.0704] <devsnek>
should've been function parameters

[07:15:30.0244] <shu>
at a deep level i really do not get dependency injection

[07:17:19.0635] <devsnek>
i do not like DI

[07:29:39.0906] <shu>
but what is it?

[07:29:54.0987] <shu>
is it just passing parameters or is there some gestalten design thing i'm not getting

[07:30:35.0208] <jschoi>
Yeah. It‚Äôs just passing parameters.

[07:32:53.0552] <devsnek>
but then you need parameter decorators for some reason

[07:34:35.0287] <jschoi>
It‚Äôs kind of like the opposite of `import` in that‚Ä¶if A needs B and B needs C‚Äîinstead of B pulling in specifically C for itself‚ÄîB defines a parameter, A pulls in B and C, and A plugs C into B‚Äôs parameter.

[07:35:14.0141] <jschoi>
So A can switch C with something else compatible with B‚Äôs parameter before plugging it into it.

[07:35:42.0463] <jschoi>
 * So A can switch C with something else compatible with B‚Äôs parameter before plugging it into it.

[07:35:58.0668] <rbuckton>
most DI is something like taking parameters for your dependencies, but the actual construction of your object graph is handled by a composer.

[07:36:17.0072] <rbuckton>
It allows you to substitute dependencies for testing or even at runtime based on circumstance.

[07:38:38.0172] <jschoi>
Whenever we need to refer to another variable elsewhere, we always face the choice of (1) defining it as a function parameter to be plugged in later or (2) importing it and hardcoding the dependency. There‚Äôs nothing special about that choice; it‚Äôs just an everyday thing.

[07:40:08.0940] <jschoi>
Although like Ron said, some people use elaborate composer systems that try to abstract away this plugging in for you.

[07:40:33.0061] <rbuckton>
DI using parameter decorators is something like:

```js
// service-c.js
class ServiceC {
  constructor(
    @inject("service-a") serviceA,
    @inject("service-b") serviceB
  ) { ... }
}

// main.js
import { ServiceA } from "./service-a.js";
import { ServiceB } from "./service-b.js";
import { ServiceC } from "./service-c.js";

const container = new ServiceContainer();
container.addClass("service-a", ServiceA);
container.addClass("service-b", ServiceB);
container.addClass("service-c", ServiceC);

const instance = container.getService("service-c"); // gets or creates a ServiceC from the container
```

[07:41:48.0181] <rbuckton>
And in test code, you can do:
```js
import { ServiceC } from "./service-c.js";
it("test the service", () => {
  const mockServiceA = { ... };
  const mockServiceB = { ... };
  const serviceC = new ServiceC(mockServiceA, mockServiceB);
  // test serviceC using mock behavior from dependencies
});
```

[07:43:27.0872] <rbuckton>
Of course, `main.js` is a contrived example. Many DI containers are fairly flexible, allowing you to specify optional dependencies, aggregate dependencies, nested containers, disposable containers (to manage component lifetime), etc.

[07:43:56.0046] <rbuckton>
As well as lazily-injected circular dependencies using field decorators.

[07:54:27.0926] <shu>
and why would i want to do this?

[07:56:59.0879] <rbuckton>
You would want to do this if you're a very large application that wants to break itself into smaller components for ease of maintenance, or support pluggability/extensions.

[07:58:04.0993] <rbuckton>
Its a fairly common idiom across any number of programming languages. Its primarily used server-side or in desktop applications, though not so much in the browser.

[07:58:29.0964] <shu>
the easiest to maintain thing is the thing i can read

[08:00:47.0248] <rbuckton>
Like anything, once you understand the system its fairly easy to read.

[08:08:05.0784] <rbuckton>
The VS Code system has a decorator factory that is used to create the actual decorators used for injection, and names the decorators to coincide with the interface name of the expected input. As a result, your code looks something like (in TS):

```ts
// themeService.ts

// describe the service interface
export interface IThemeService {
  getColorTheme(): IColorTheme;
  readonly onDidColorThemeChange: Event<IColorTheme>;
  getFileIconTheme(): IFileIconTheme;
  readonly onDidFileIconThemeChange: Event<IFileIconTheme>;
}

// create a decorator for the service
export const IThemeService = createDecorator<IThemeService>();

// editor.ts
import { IThemeService } from "./themeService";

export class EditorService {
  themeService: IThemeService;

  constructor(
    @IThemeService themeService: IThemeService
  ) {
    this.themeService = themeService;
  }

  // code that uses themService
}
```

[08:10:50.0567] <rbuckton>
All the decorator does is provide the glue that the composition plumbing uses. The idea is fairly similar to context providers in React. I don't have to dig around in the plumbing of my application to find and use a dependency, I merely need to declare that I require the dependency and the composition runtime will either provide it, or fail to compose early because of an unsatisfied dependency.

[08:11:23.0471] <rbuckton>
Its also much like a module import graph, except that you have more control over lifetime of the entire dependency graph.

[08:12:58.0855] <rbuckton>
The Managed Extensibility Framework (MEF) API in .NET is another example of a DI system, and it actually uses `Import` and `Export` attributes to define dependency relationships within a DI container.

[08:17:37.0072] <sarahghp>
this seems like an invitation to write unnecessarily complex code ... the virtue of low-magic is links are really clear (I also don't really like `context` in React tho)

[08:18:01.0982] <sarahghp>
to be verbosely clever instead of code-golf-style tersely clever

[09:01:50.0635] <rickbutton>
does anyone have a good resource for descriptions of non-standard JS extensions over the years? as-in, pre-harmony stuff that got removed like conditional catch / let blocks / etc

[09:03:41.0244] <rickbutton>
rubber duck method, i guess this is a good resource: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Deprecated_and_obsolete_features

[09:07:09.0149] <annevk>
Doesn't list E4X!

[09:07:40.0370] <jschoi>
Microsoft JScript had a special `::` syntax for events, I believe. (CC: rbuckton)

[09:07:43.0593] <jschoi>
 * Microsoft JScript had a special `::` syntax for events, I believe. (CC: rbuckton)

[09:08:56.0369] <Jack Works>
And JScript supports `expr() = expr2`?

[09:10:44.0679] <rickbutton>
what does that do?

[09:11:11.0372] <jschoi>
Golly, I do not remember. I wish there were still resources about this. üòî

[09:12:45.0156] <Jack Works>
> <@rick.button:matrix.org> what does that do?

IDK, just heard of that

[09:13:52.0212] <nicolo-ribaudo>
> <@rick.button:matrix.org> what does that do?

I think it was to allow things like `eval("x") = 2`, but I might be wrong

[09:15:36.0008] <rickbutton>
wild

[09:16:20.0368] <rickbutton>
`eval("x") = 2` is what engine developers fear

[09:16:30.0209] <rickbutton>
 * `eval("x") = 2` is what engine developers fear

[09:23:47.0870] <nicolo-ribaudo>
Ok, maybe it wasn't for eval: the ES 1 specification, at paragraph 11.2.3, says that any host function can return a reference, but `eval` doesn't

[09:24:41.0484] <nicolo-ribaudo>
* Ok, maybe it wasn't for eval: the ES 1 specification, at paragraph 11.2.3, says that any host function can return a reference, but `eval` doesn't

[09:26:41.0523] <rbuckton>
You can do `(x) = 2` today, but you can't do `({ x }) = { x: 2 }`.

[09:28:33.0359] <rbuckton>
not a non-standard extension, just an idiosyncrasy of the language

[09:29:07.0098] <nicolo-ribaudo>
We are taking about `fn(x)=2`, not `(x)=2`!

[09:48:06.0586] <ljharb>
can anyone read through https://tc39.es/ecma262/#sec-number.prototype.toexponential and confirm whether `0.0.toExponential(2)` should be `'0.00e+0'` vs `'0e+0'`?

[10:05:47.0965] <shu>
uh, looks like 0.00e+0

[10:06:16.0464] <shu>
`f` is 2, so step 9.a says `m` is `"000"`

[10:06:27.0487] <shu>
then step 11 puts a `.` after the first digit

[10:14:34.0842] <ljharb>
ok cool, thanks - that seemed right to me but i wanted another check

[10:51:06.0855] <bakkot>
re: `f() = x`, see discussion in https://github.com/tc39/ecma262/issues/257

[11:01:46.0233] <bakkot>
on some previous occasion this came up, bterlson said it was vbarrays specifically that used this

[11:02:04.0182] <bterlson>
yessir, vbarrays

[11:02:05.0840] <bakkot>
and someone in the meeting chat said:

```
[2:21 PM] Paul Leathers
Yes, VB arrays are the case I remember.

[2:23 PM] Paul Leathers
The call didn‚Äôt really return an lvalue. If the engine saw a(i) = x, it would perform a call to IDispatch::Invoke with the PROPERTY_PUT attribute set and the value to write as an extra argument.
```

[11:02:34.0647] <bakkot>
though I never did manage to find an example of this I could actually get to work in IE6

[11:02:37.0619] <bakkot>
maybe that was too new though

[11:03:12.0998] <bterlson>
I think because of the COM magic, it's possible vbs wouldn't work right on newer systems even if IE6 and JScript+JS did

[11:03:33.0760] <bakkot>
oh, fun

[11:03:53.0783] <bterlson>
I recall there being some particular system setup when I was testing VB/JS interop

[16:57:07.0266] <ptomato>
hi chairs, re. https://github.com/tc39/Reflector/issues/396#issuecomment-952406138, chipmorningstar needs a power-up üòÑ

