2023-08-01
[20:48:08.0108] <ljharb>
bakkot: bad news for your coercion proposal, some people like it https://twitter.com/wesbos/status/1686014875040956416

[00:10:50.0710] <bakkot>
ljharb: some people are incorrect

[07:26:28.0110] <shu>
this is someone who teaches beginner javascript, according to the twitter profile

[07:59:09.0760] <Anthony Bullard>
> <@shuyuguo:matrix.org> this is someone who teaches beginner javascript, according to the twitter profile

He's one of the most popular and influential people in JS dev content targeted at beginners to early intermediate 

[07:59:30.0359] <shu>
alas

[07:59:43.0955] <shu>
teaching `at(0.1)` as a benefit seems not good to me

[08:01:01.0336] <Anthony Bullard>
Not going to argue that.  And does somewhat surprise me

[08:01:28.0522] <Anthony Bullard>
I haven't been in discussions on .at() so I was unaware of the coercion

[08:02:18.0307] <shu>
there were no discussions around coercion specifically at the time, the method follows the coercion precedence of other methods

[08:02:31.0771] <Anthony Bullard>
I wasn't aware it worked with other array methods either, hadn't tried in that in my 24 years of JavaScripting

[08:02:46.0986] <shu>
which is the point of bakkot's proposal. we've been operating on precedence grounds for decades, it's time to rethink that

[08:02:48.0945] <Anthony Bullard>
Never even occurred to me to try

[08:02:53.0235] <shu>
yeah

[08:04:16.0715] <rkirsling>
huh

[08:04:41.0503] <rkirsling>
yeah I can't say I've ever attempted to pass a non-integral number to `slice`, say

[08:11:06.0271] <Anthony Bullard>
Strangely enough it works. Had to open a terminal to prove it to myself

[08:12:22.0999] <rkirsling>
yeah.

[08:13:58.0025] <rkirsling>
the thing is that if `array[1.2]` were already valid, then you could argue that `array.at(1.2)` is a non-regression, or something

[08:14:57.0605] <rkirsling>
but given that `array[1.2]` is not in fact equivalent to `array[1]`, it definitely seems hard to consider the equivalence of `.at(1.2)` and `.at(1)` a good thing

[08:15:03.0076] <rkirsling>
I don't necessarily mean that we screwed up

[08:15:11.0947] <rkirsling>
but for educational materials...

[08:15:18.0762] <rkirsling>
ðŸ˜“

[08:16:02.0335] <rkirsling>
 * the thing is that if `array[1.2]` already worked like that, then you could argue that `array.at(1.2)` is a non-regression, or something

[08:25:17.0180] <Anthony Bullard>
`array[1.2]` won't error though, so it's a question of what the behavior should be for `.at()` if we don't want coercion.  There is a sort of coercion happening with `arr[1.2]` as well, and I don't think we would want to extend that to `.at(1.2)`

[08:27:37.0770] <rkirsling>
certainly, `at` isn't meant to string coerece

[08:27:39.0499] <rkirsling>
 * certainly, `at` isn't meant to string coerce

[08:27:59.0816] <rkirsling>
in that regard I guess an error could've been argued for

[08:30:28.0385] <Anthony Bullard>
My argument is that either way there is either a loss of backwards compat (nope) or a lack of symmetry between accessing an integer index or a decimal extension of said integer.

[08:31:26.0345] <Anthony Bullard>
I think the best case for sanity going forward would be a TypeError, but it would create more errata for devs leveraging previous knowledge 

