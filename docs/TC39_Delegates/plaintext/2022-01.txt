2022-01-05
[07:36:20.0739] <jschoi>
https://github.com/tc39/proposal-class-fields is still getting new comments despite it being Stage 4. It should get archived, right?

[07:43:41.0033] <Rob Palmer>
maybe ljharb (our Administrator-to-be) would like to handle that

[07:53:49.0672] <ljharb>
Yup, that is the first thing on my list


2022-01-06
[10:55:24.0433] <jschoi>
FYI, the State of JS people have reached out to TC39 at https://es.discourse.group/t/help-shape-the-contents-of-the-next-state-of-js-survey/1148 asking what sort of questions they should be asking for the upcoming community survey. This might be really useful.

[10:57:36.0268] <jschoi>
* FYI, the State of JS people have reached out to TC39 at https://es.discourse.group/t/help-shape-the-contents-of-the-next-state-of-js-survey/1148 asking what sort of questions they should be asking for the upcoming survey. This might be really useful.

[10:57:42.0056] <jschoi>
* FYI, the State of JS people have reached out to TC39 at https://es.discourse.group/t/help-shape-the-contents-of-the-next-state-of-js-survey/1148 asking what sort of questions they should be asking for the upcoming community survey. This might be really useful.

[10:58:18.0850] <jschoi>
Oh wait, I missed this already in the General chat, whoops.


2022-01-10
[22:54:10.0326] <ljharb>
i'd love a review here: https://github.com/tc39/notes/pull/176 if someone has a sec

[14:44:45.0192] <Michael Ficarra>
Aki bterlson Rob Palmer can one of you take a look at this invited expert issue? https://github.com/tc39/Admin-and-Business/issues/190

[14:45:29.0956] <Rob Palmer>
yep - I will get to it Michael - thank you for the reminder

[14:45:38.0394] <Michael Ficarra>
thanks so much Rob!


2022-01-15
[17:42:13.0315] <waldemar>
Only three proposals made today's deadline for possible advancement at this month's TC39 meeting. Looks like it's going to be a short meeting‚Ä¶

[09:17:48.0808] <ljharb>
i count 4 for advancement, but indeed there'll be a lot of time that could be filled with updates and discussions

[12:00:22.0129] <jschoi>
It might be worth offloading some of the chartered incubator topics into plenary, if there‚Äôs lots of room. https://github.com/tc39/incubator-agendas/issues/22


[12:00:22.0989] <jschoi>

https://github.com/tc39/process-document/pull/33 might also be worth discussing.


2022-01-18
[10:22:10.0438] <shu>
jschoi: agreed, i haven't had time to run any calls at all between last meeting and this one

[10:57:00.0403] <waldemar>
> <@ljharb:matrix.org> i count 4 for advancement, but indeed there'll be a lot of time that could be filled with updates and discussions

Ah, enum for stage 1 was in the "open-ended discussion category" instead of in the proposals.

[11:03:15.0680] <Justin Ridgewell>
I thought TC39 was this week‚Ä¶

[11:03:26.0610] <Justin Ridgewell>
Anyways, TCQ's SSL cert is expired.

[11:03:34.0367] <Justin Ridgewell>
We should fix that before plenary.

[11:03:41.0578] <Justin Ridgewell>
bterlson: ^

[12:52:00.0986] <Rob Palmer>
Bterlson is on it. 

[14:31:39.0444] <waldemar>
What is the "presentation from KAIST research group"? I'd like an idea of what we're planning on discussing for this item. It's hard to prepare or look at background materials without any idea what the topic is.

[14:45:22.0946] <Mathieu Hofman>
Here is a link to their publications: https://plrg.kaist.ac.kr/research/publications

Michael Ficarra might want to ask them if there is anything that might be relevant to look at before their presentation.

Also I believe they have an "as late as possible in the day" scheduling constraint. The 2-3 PM slot probably makes sense for them?

[15:01:18.0938] <bakkot>
waldemar: the most relevant papers are https://dl.acm.org/doi/10.1145/3324884.3416632 and https://ieeexplore.ieee.org/document/9402086


2022-01-19
[17:09:03.0610] <Michael Ficarra>
I've also asked them to post links to resources next to their agenda item once they are prepared

[17:14:25.0572] <Michael Ficarra>
from my invited expert proposal (https://github.com/tc39/Admin-and-Business/issues/187):

[17:14:34.0669] <Michael Ficarra>
> Reason for invitation: These researchers from KAIST presented their recently published works to the TC39 editor group. This work includes automatic generation of a reference implementation, automatic generation of a step-through debugger, and tools for helping editors to catch spec errors. We think this work would be useful to share more broadly with the rest of the committee in a plenary.

[14:07:28.0922] <bakkot>
jschoi: your agenda item for Array.fromAsync does not say it's going for stage 3

[14:07:45.0612] <bakkot>
so people might not be reviewing it in enough detail

[14:10:44.0277] <bakkot>
(the rules for advancement eligibility "Proposals looking to advance to stages 2, 3, or 4 must be added (**and noted as such**)" [emphasis added], so in principle someone can object to advancement on those grounds)

[14:15:27.0997] <bakkot>
also it's currently stage 2; the "stage" column is the stage it _is_, not going for

[14:34:47.0336] <ljharb>
oops

[14:36:16.0859] <ljharb>
i pushed up a change to that, under the assumption it's meant to be for stage 3. if that's not the intention, we can remove it; if someone missed it between the deadline and now due to the mislabeling, we can deal with that as part of the normal process in plenary

[14:36:59.0334] <Luca Casonato>
> <@bakkot:matrix.org> also it's currently stage 2; the "stage" column is the stage it _is_, not going for

Oh darn - I think enum and string split might be wrong too. Should both be 0 in that column then, right?

[14:37:22.0795] <ljharb>
yes, i'll fix those too

[14:37:36.0801] <Luca Casonato>
> <@ljharb:matrix.org> yes, i'll fix those too

thx :-)

[15:48:29.0268] <jschoi>
Yeah, my intent was to go for Stage¬†3. I marked it as such in the pull request but I forgot to add it to the table entry itself. My apologies. üôá


2022-01-24
[01:18:01.0927] <Jack Works>
üëÄ is there drafted agenda for this meeting so I can schedule my sleeping time? thanks!

[03:14:34.0838] <yulia>
jschoi: i have a dumb question, what if promise.all accepted async iterators and returned an array of values, instead of doing that in a separate API? re: https://github.com/tc39/proposal-array-from-async

[03:17:01.0295] <yulia>
 * jschoi: i have a dumb question, what if promise.all accepted async iterators (it already takes iterables), instead of doing that in a separate API? re: https://github.com/tc39/proposal-array-from-async

[05:28:57.0100] <Rob Palmer>
The draft schedule for today's meeting is now posted:  https://hackmd.io/s3ovtgLsTa-QAhFqYTl_YA

[05:29:06.0829] <Rob Palmer>
 * The draft schedule for today's meeting is now posted

[05:29:26.0725] <Rob Palmer>
 * The draft schedule for today's meeting is now posted: https://github.com/tc39/Reflector/issues/411

[05:31:48.0122] <Luca Casonato>
> <@robpalme:matrix.org> The draft schedule for today's meeting is now posted: https://github.com/tc39/Reflector/issues/411

Thanks! üôè

[07:59:53.0759] <jschoi>
> <@yulia:mozilla.org> jschoi: i have a dumb question, what if promise.all accepted async iterators (it already takes iterables), instead of doing that in a separate API? re: https://github.com/tc39/proposal-array-from-async

`Promise.all`‚Äôs current semantics involve parallel awaiting of input values. If some `input` yields `a, b, c`, then `Promise.all(input)` would first drain `input` into its three items `a, b, c`, and then it would simultaneously await `a, b, c`.

Parallel awaiting is impossible when getting values from async iterators; we must sequentially await the values. 

I think it would be quite confusing if `Promise.all` did parallel awaiting on sync inputs and sequential awaiting on async inputs. This is the similar to how it would be confusing if `for await` did parallel awaiting on sync inputs but sequential sequential awaiting on async inputs. Hopefully that makes sense.

[08:00:30.0717] <yulia>
I see, thanks!

[08:17:33.0102] <jschoi>
* > <@yulia:mozilla.org> jschoi: i have a dumb question, what if promise.all accepted async iterators (it already takes iterables), instead of doing that in a separate API? re: https://github.com/tc39/proposal-array-from-async

`Promise.all`‚Äôs current semantics involve parallel awaiting of input values. If some `input` yields `a, b, c`, then `Promise.all(input)` would first drain `input` into its three items `a, b, c`, and then it would simultaneously await `a, b, c`.

Parallel awaiting is impossible when getting values from async iterators; we must sequentially await for the values. 

I think it would be quite confusing if `Promise.all` did parallel awaiting on sync inputs and sequential awaiting on async inputs. This is the similar to how it would be confusing if `for await` did parallel awaiting on sync inputs but sequential sequential awaiting on async inputs. Hopefully that makes sense.

[09:48:09.0063] <Rob Palmer>
We will start the meeting in 12 minutes!

[10:24:27.0713] <leobalter>
I like the formal votes, but fine with it going without it.

I also have no opposition to ryzokuken being on both roles (402 Editor + TC39 Co-Chair).

[10:50:29.0004] <bakkot>
we could in theory make a bot to download issues but I don't wanna do it

[10:55:19.0300] <bterlson>
bakkot: is the ecmarkup change an API change or breaking in the sense that new things in the biblio will change where links go/what links/etc.?

[10:55:22.0470] <bterlson>
just curious

[10:56:29.0306] <ljharb>
Rick Waldron: can you confirm that https://github.com/tc39/proposal-modules-pragma should become an inactive proposal?

[10:57:41.0978] <Rick Waldron>
ljharb: That was true in 2017. I have no further information that changes that status 

[10:58:00.0772] <ljharb>
ok thanks, i'll update the repo and the proposals list to mark it as such. would you call it "rejected' or "withdrawn"?

[10:58:24.0198] <Rick Waldron>
ljharb: lemme check the notes, one sec. 

[10:59:57.0044] <rbuckton>
possible bot autocorrect needed: "x markup" -> "ecmarkup"

[10:59:58.0341] <bakkot>
bterlson: main change is that the biblio will not be built in, and you'll have to specify `--load-biblio=file/package` to get the biblio

[11:00:08.0548] <bakkot>
so it can be updated independently of ecmarkup

[11:00:28.0513] <bakkot>
(in particular the plan is to release a new biblio with every commit to the spec, or at least every one which affects the biblio)

[11:00:37.0210] <bakkot>
 * (in particularly the plan is to release a new biblio with every commit to the spec, or at least every one which affects the biblio)

[11:01:14.0011] <bakkot>
 * (in particular the plan is to release a new biblio with every commit to the spec, or at least every one which affects the biblio)

[11:01:35.0707] <Rick Waldron>
ljharb: I cannot find discussion of record, but I would not pursue it myself in 2022, or any year... I can't even remember why I thought it was an idea to explore at the time. 

[11:01:49.0425] <Michael Ficarra>
 thank you for the feedback on this topic, sffc :-)

[11:02:05.0559] <Rick Waldron>
> <@rwaldron:matrix.org> ljharb: I cannot find discussion of record, but I would not pursue it myself in 2022, or any year... I can't even remember why I thought it was an idea to explore at the time.

I may have been doing a favor for a community member 

[11:02:16.0837] <ljharb>
> <@rwaldron:matrix.org> ljharb: I cannot find discussion of record, but I would not pursue it myself in 2022, or any year... I can't even remember why I thought it was an idea to explore at the time.

as i recall, it was around the time of the fauxtrage about `.js` and ESM in node

[11:02:27.0483] <ljharb>
i'll mark it as just being "inactive"

[11:02:50.0867] <bterlson>
@bakkot sounds great, it's super annoying for non-262 uses to have the biblio there at all :-P

[11:03:05.0610] <Rick Waldron>
> <@ljharb:matrix.org> as i recall, it was around the time of the fauxtrage about `.js` and ESM in node

Which would TOTALLY support my suspicion that I was "proxy-championing" this

[11:03:14.0968] <yulia>
This is so amazing shu 

[11:03:23.0760] <sffc>
yulia Michael Ficarra Here is a discussion from October (https://github.com/tc39/ecma402/blob/master/meetings/notes-2021-10-07.md#normative-add-new-numbering-system-tnsa) and another from January (https://github.com/tc39/ecma402/blob/master/meetings/notes-2022-01-13.md#normative-add-new-numbering-system-tnsa)

[11:03:32.0345] <Rick Waldron>
That is something I would've done: tell a community member to write a solution and that I would present it in good faith. 

[11:03:36.0564] <shu>
thanks! kevin helped a lot too with the ecmarkup stuff needed

[11:04:14.0248] <Rick Waldron>
But it looks like they never really pushed forward on it, and since I was acting in a proxy role, I wouldn't have done any extra work beyond reporting to committee. 

[11:09:43.0381] <bakkot>
> <@bterlson:matrix.org> @bakkot sounds great, it's super annoying for non-262 uses to have the biblio there at all :-P

there's actually already a `--no-ecma-262-biblio` which tells it not to load it

[11:10:00.0862] <bakkot>
> <@bterlson:matrix.org> @bakkot sounds great, it's super annoying for non-262 uses to have the biblio there at all :-P

 * there's actually already a `--no-ecma-262-biblio` which tells it not to load the built-in one

[11:10:36.0748] <yulia>
sffc: per anba's comment here (https://github.com/tc39/ecma402/pull/614#issuecomment-938638422) i don't think we have any comments but i will clear it with our intl team

[11:13:29.0358] <waldemar>
How do you annotate that something doesn't call user code?

[11:15:11.0540] <bakkot>
waldemar: https://github.com/tc39/ecma262/pull/2548 describes guidance for spec authors, relevant part of which is

> False positives can be manually suppressed with `<emu-meta suppress-effects="user-code">suppressed</emu-meta>`.


[11:15:13.0208] <Michael Ficarra>
waldemar: if you need to do it manually, like this: https://github.com/tc39/ecma262/pull/2548/files#diff-181371b08d71216599b0acccbaabd03c306da6de142ea6275c2135810999805aR18446

[11:15:31.0905] <Michael Ficarra>
but mostly it's implied by `!`

[11:16:22.0246] <shu>
@waldemar: you can wrap the abstract operation / SDO call in `<emu-meta suppress-effects="user-code">AbstractOp()</emu-meta>`, but yeah as Michael Ficarra says `!` implies the suppression

[11:24:28.0695] <shu>
for spec authors, the tests in this file also serve as a good tutorial for how to annotate, but hopefully most spec authors require no additional work: https://github.com/tc39/ecmarkup/blob/main/test/baselines/sources/effect-user-code.html

[11:25:51.0989] <shu>
 * for spec authors, the tests in this file also serve as a good tutorial for how to annotate, but hopefully most spec drafts require no additional work: https://github.com/tc39/ecmarkup/blob/main/test/baselines/sources/effect-user-code.html

[11:39:53.0469] <yulia>
whatwg on polyfils: https://w3ctag.github.io/polyfills/

[11:41:28.0505] <Michael Ficarra>
> <@yulia:mozilla.org> whatwg on polyfils: https://w3ctag.github.io/polyfills/

that document is broken for me

[11:41:29.0544] <shu>
did my queue item get deleted?

[11:42:49.0510] <shu>
Rob Palmer: ^

[11:43:48.0653] <ryzokuken>
> <@michaelficarra:matrix.org> that document is broken for me

took a second for me

[11:44:09.0071] <ryzokuken>
perhaps the CSS load is non-blocking

[11:44:48.0894] <Rob Palmer>
sorry shu I did not see you on the queu

[11:45:10.0266] <Rob Palmer>
put yourself back on and i shall re-order - just tell me where it should go

[11:45:11.0512] <shu>
hm, pretty sure i added myself, guess i'll re-add myself to the end

[11:45:27.0001] <Rob Palmer>
i can move you up

[11:45:38.0124] <yulia>
in that doc they have 
```
* **polyfill**: Emulates a well established feature of the web platform
* **speculative polyfill** (aka 'ponyfill', 'prollyfill', 'nottifill'): Emulates a proposed feature of the web platform
* **library** (aka 'module'): Provides features or functionality not anticipated to be a web platform feature
```

[11:45:39.0977] <shu>
Rob Palmer: after J. S. Choi is done is good

[11:46:34.0026] <Rob Palmer>
actually you're already there!

[11:46:42.0628] <Rob Palmer>
just refresh - tcq bug :-(

[11:47:02.0162] <shu>
oh weird :(

[11:48:10.0060] <yulia>
jschoi:  i didn't have time to respond, but yes feature detection is a problem

[11:49:38.0506] <yulia>
though i wonder if it makes sense to include this in the document. Experiment should be treated as not in production code

[11:50:53.0645] <TabAtkins>
Here's the published version of the TAG finding, which is *not* broken: https://www.w3.org/2001/tag/doc/polyfills/

[11:51:19.0911] <TabAtkins>
Also note that this is *not* WHATWG, it's the W3C TAG.

[11:51:27.0885] <yulia>
I feel like this could be cited?

[11:51:31.0816] <yulia>
 * I feel like this could be cited?

[11:51:34.0838] <ptomato>
> <@tabatkins:matrix.org> Also note that this is *not* WHATWG, it's the W3C TAG.

oh, my bad

[11:51:35.0792] <Michael Ficarra>
I just don't think anything will tangibly change, whatever recommendation we make

[11:51:48.0350] <yulia>
clarity is helpful though

[11:53:39.0092] <Michael Ficarra>
I haven't had time to review the document we're being asked to voice our support for

[11:53:53.0307] <Michael Ficarra>
maybe we come back with a modified proposal that references the document next time?

[11:54:47.0322] <yulia>
Yeah, that makes sense

[11:55:24.0794] <ljharb>
for the specific wording, that's fine, but i still wanted to get consensus on the conceptual change, to avoid distractions in the PR.

[11:57:54.0007] <yulia>
we may need to change 3.5 of that document...

[11:58:46.0322] <ljharb>
3.5?

[11:59:02.0788] <yulia>
https://www.w3.org/2001/tag/doc/polyfills/#detect-and-defer-to-native-implementations

[11:59:35.0811] <Michael Ficarra>
yeah, that sounds like the opposite of what we would advise

[12:00:30.0963] <TabAtkins>
Note that that's explicitly guarded by "past the tipping point", aka things that are already well-decided and implemented in some browsers, and thus very unlikely to change.

[12:01:03.0705] <TabAtkins>
It explicitly warns against doing this before that point, and has examples of the "grab the native if it exists, otherwise use the polyfill" pattern as explicitly discouraged.

[12:02:33.0458] <yulia>
hmmm, maybe we can define tipping point clearly

[12:02:51.0674] <yulia>
but even then , it seems liable to being misinterpretted..

[12:03:27.0080] <Michael Ficarra>
ah, thanks TabAtkins I misread it

[12:24:23.0083] <yulia>
if we need clarifications we can post on the TAGs design issue tracker

[12:25:28.0640] <yulia>
 * I think tab is right, this aligns with our goals it looks like. if we need clarifications we can post on the TAGs design issue tracker

[12:55:04.0167] <yulia>
is ptomato ready to go?

[12:59:04.0913] <ptomato>
I am

[12:59:45.0510] <yulia>
great

[13:18:38.0480] <bakkot>
motion to close this discussion and move on, no one disagrees with the proposal afaict

[13:19:25.0573] <leobalter>
well, I appreciate everyone having clarity on the topics we discuss

[14:15:48.0577] <ljharb>
would this document basically be like a new TG?

[14:16:03.0461] <ljharb>
i can ask that on the queue if it wouldn't derail the ending of the item

[14:17:35.0055] <yulia>
is 404 a tg?

[14:17:38.0938] <yulia>
 * is 404 a tg?

[14:17:40.0456] <ljharb>
i think so

[14:17:48.0169] <ljharb>
actually i dunno, maybe not

[14:17:50.0269] <yulia>
we also have the spec suite as a document

[14:17:54.0864] <yulia>
i see this as closer to one of those

[14:18:01.0730] <ljharb>
since there's just tc39, 402, and security

[14:18:03.0194] <ljharb>
k

[14:18:17.0316] <yulia>
i still want it to be 405

[14:19:22.0568] <shu>
ljharb: i don't see it as a TG, no

[14:19:32.0345] <shu>
the IP-making body is still TG1

[14:19:39.0726] <shu>
it just goes into a separate document than ecma262

[14:20:09.0969] <ljharb>
cool

[14:20:27.0828] <shu>
i don't know how to legally set that up but i'm not too worried about it?

[14:21:21.0151] <ljharb>
can prolly just make a repo for it when we're at that stage, which i'm now empowered to do

[14:54:01.0905] <Bradford Smith>
When did the "structured clone" discussion start? I really thought it started before 2pm. Isn't the time box spent?

[14:55:53.0569] <bakkot>
Bradford Smith: meeting's over

[14:55:59.0121] <bakkot>
this is post-plenary me picking mark's brain

[14:56:29.0831] <Bradford Smith>
oh, thx

[15:49:06.0611] <bakkot>
ljharb: can you use your admin powers to drop a link to https://github.com/bakkot/proposal-duplicate-named-capturing-groups on https://github.com/tc39/proposal-regexp-named-groups/issues/44 ?

[15:50:41.0567] <bakkot>
also, new (small) regex proposal I intend to put together for next meeting: allow capture group names to be re-used (when in different `|` alternatives) rather than enforcing uniqueness in the full regex

https://github.com/bakkot/proposal-duplicate-named-capturing-groups


2022-01-25
[16:46:48.0084] <ljharb>
sure, i can unarchive it if you want to comment it yourself? just lmk

[16:47:25.0974] <ljharb>
> <@bakkot:matrix.org> ljharb: can you use your admin powers to drop a link to https://github.com/bakkot/proposal-duplicate-named-capturing-groups on https://github.com/tc39/proposal-regexp-named-groups/issues/44 ?

 * sure, i can unarchive it if you want to comment it yourself? just lmk

[16:47:50.0717] <ljharb>
also, what happened with the "set method argument internal slot" discussion? i had to drop off

[16:58:10.0293] <ljharb>
 * sure, i can unarchive it if you want to comment it yourself? just lmk, or if we can't coordinate, i can

[19:32:46.0276] <bakkot>
ljharb: if you want to unarchive tonight and ping me I'll link it, or you should feel free to do so on my behalf

[19:33:11.0253] <bakkot>
> <@ljharb:matrix.org> also, what happened with the "set method argument internal slot" discussion? i had to drop off

tl;dr was, for the argument to `Set.prototype.union`, MM does not like the idea of _only_ reaching in to the [[SetData]] internal slot, but would potentially be OK with reaching in to that slot if present and otherwise falling back to the publicly exposed methods (`has`, etc), even though this would technically be a violation of proxy transparency (because for most cases it would still Just Work)

[19:33:12.0903] <ljharb>
bakkot: done now, go nuts

[19:34:24.0206] <ljharb>
bakkot: but the receiver would still have slot access only, yes?

[19:34:32.0427] <bakkot>
yeah, receiver is fine

[19:34:37.0817] <bakkot>
that's already how it works

[19:34:46.0767] <ljharb>
awesome

[19:34:49.0100] <bakkot>
that is, it is already common to access the internal slot of the receiver

[19:34:55.0507] <ljharb>
(re-archived the repo, after your comment; lmk if you need anything else)

[19:35:03.0674] <bakkot>
nope, that was all, thanks

[19:35:17.0532] <bakkot>
though in both the argument case and the receiver case we need to figure out what affordances, if any, we're going to make for subclasses

[08:38:53.0172] <Jack Works>
hi I've read the meeting logs yesterday. I'm interested in reviewing structured clone algr. (cc syg )

[08:40:54.0146] <shu>
Jack Works: sure, will request your review when the draft is ready

[08:49:20.0372] <Jack Works>
üëÄ I set an alarm on 14:00 PST and not be able to present enum before 14:00 cause I'm sleeping.

[08:52:50.0339] <Rob Palmer>
Jack Works: we'll schedule you as late as possible today to help you sleep - so in between 14:00-15:00 PST

[09:57:01.0660] <Rob Palmer>
This is your 4 minute warning: Plenary starts soon

[10:02:18.0016] <ptomato>
I can't do notes right away, but I can in a bit

[10:03:15.0269] <Rob Palmer>
thanks ptomato 

[10:27:03.0089] <bakkot>
Mathieu Hofman: can you confirm the conclusion we have captured in the notes is correct

[10:27:10.0574] <bakkot>
I think so but best to confirm

[10:44:57.0848] <bakkot>
never GCing is always legal, so XS's implementation would still be conformant

[11:00:25.0095] <ljharb>
+1, that was a mistake

[11:00:47.0907] <ljharb>
(but i also think registered symbols themselves are a mistake)

[11:04:46.0899] <shu>
what was the original use case for them anyway

[11:05:01.0486] <bakkot>
for registered symbols?

[11:05:07.0532] <bakkot>
it lets you do the same thing as well-known symbols for libraries

[11:05:12.0515] <bakkot>
so a library can interop with itself across realms

[11:05:22.0245] <shu>
but... what realms

[11:05:24.0963] <shu>
we didn't have sync realms

[11:05:40.0866] <bakkot>
iframes

[11:05:48.0655] <bakkot>
we have always had iframes

[11:05:48.0791] <shu>
oh, i guess sync iframes

[11:05:54.0917] <bakkot>
but also, not necessarily across realms

[11:05:59.0345] <shu>
i have a hard time believing that was a use case tc39 cared about back then?

[11:05:59.0886] <bakkot>
just multiple version of the library within the same realm

[11:06:06.0082] <bakkot>
 * but also, not necessarily across realms

[11:06:09.0908] <yulia>
Ashley Claymore: can you share with me the test case you used to identify SM gc behavior?

[11:06:23.0620] <shu>
yes, right, coordination without having the library do the heavy lifting

[11:07:10.0666] <Ashley Claymore>
> <@yulia:mozilla.org> Ashley Claymore: can you share with me the test case you used to identify SM gc behavior?

will do :)

[11:07:26.0284] <bakkot>
well, also lets consumers of a library coordinate with it without having a direct reference to it

[11:07:46.0826] <bakkot>
like you can have a library which defines a protocol, and have someone else implement that protocol without reference to the library

[11:09:02.0097] <ljharb>
shu: as much as i claim that the existence of iframes means browsers can't pretend realms don't exist, i completely agree with you that it's unlikely that was the motivation

[11:09:23.0522] <ljharb>
making the symbol registry realm-specific would have supported the library use case just fine, i think

[11:09:33.0217] <bakkot>
forget I said realms; "multiple versions of a library" is the right thing to think about, whether that's cross-realm or not

[11:09:43.0714] <bakkot>
and consumers of a library which aren't including it directly

[11:10:58.0030] <ljharb>
erights: what if i had a WeakMap of a symbol to an object, and then a WeakRef of the same object, and no other refs to the object. couldn't i observe the collection of the symbol via the collection of the object?

[11:19:52.0376] <Richard Gibson>
subclassing doesn't work anyway, because of e.g. `BaseClass[method].call(subclassInstance, ‚Ä¶)` directly interacting with internal slots

[11:20:06.0385] <bakkot>
ljharb: fwiw I don't think "registered symbols" and "unique symbols" are actually the same kind of thing for users

[11:20:15.0533] <bakkot>
they have the same type but they really do not come up in the same cases

[11:21:12.0896] <Ben Newman (Apollo, @benjamn on GH)>
Aren't registered Symbols often used for safely branding objects, in case you have more the one copy of a library (so instanceof is risky)?

[11:21:44.0065] <bakkot>
Ben Newman (Apollo, @benjamn on GH): yes, but that's not like a regular symbol

[11:22:05.0123] <Ben Newman (Apollo, @benjamn on GH)>
I was responding to the question about whether anyone actually uses registered Symbols

[11:22:17.0572] <bakkot>
ah, sure

[11:22:33.0692] <ljharb>
that's the common _appropriate_ use case, yeah

[11:24:31.0958] <Ben Newman (Apollo, @benjamn on GH)>
"eternal" seems to mean/imply "recoverable after all references are lost" (fair?)

[11:24:32.0226] <bakkot>
Ben Newman (Apollo, @benjamn on GH): my claim is that there is no good reason to want to put such a brand in a WeakMap

[11:24:46.0148] <bakkot>
at least not that i can think of offhand

[11:25:51.0419] <Ben Newman (Apollo, @benjamn on GH)>
I'm uncomfortable with throwing "good" around like that

[11:25:53.0436] <ljharb>
hm, i just got kicked off the call

[11:25:57.0150] <nicolo-ribaudo>
Me too

[11:25:59.0313] <ljharb>
what did i miss?

[11:26:05.0067] <ljharb>
ah k

[11:26:19.0827] <rickbutton>
did the call just die?

[11:26:47.0133] <ptomato>
same

[11:26:48.0892] <Ben Newman (Apollo, @benjamn on GH)>
(it's back if you reconnect)

[11:27:17.0386] <nicolo-ribaudo>
 * Oh again

[11:30:03.0364] <bakkot>
let me put it a different way: the reason to want a registered symbol is that you want something which lives forever, for e.g. coordination across instances/consumers of a library. the reason you want to put symbols in a weakmap is that you want to hold something weakly - you have a symbol which is ephemeral, and you want to hold something else ephemerally. (Otherwise you could just use a Map.) these uses are directly opposed.

[11:31:16.0912] <Ben Newman (Apollo, @benjamn on GH)>
I'm fine with never collecting registered symbols, as are V8 and Mozilla's engine, it sounds like

[11:31:32.0290] <Ben Newman (Apollo, @benjamn on GH)>
they are, quite literally, always reachable once registered, even if you've lost all references

[11:32:44.0274] <rbuckton>
bakkot: But you can also intentionally craft an object that should live forever and also place it in a weakmap. If you *want* to track a symbol in a way that is "preferrably" weak, you would have to write a lot of defensive code and have both a WeakMap and a Map.

[11:33:03.0821] <Ben Newman (Apollo, @benjamn on GH)>
the "optimization" of collecting registered symbols anyway and then later returning a new reference if someone asks for them again with Symbol.for is simply unsound, IMO

[11:33:15.0209] <Ben Newman (Apollo, @benjamn on GH)>
it would be nice to hear about a JS engine that actually does that

[11:34:31.0126] <Ben Newman (Apollo, @benjamn on GH)>
is someone from Apple on the call? msaboff ? does Safari actually collect registered symbols?

[11:34:34.0296] <bakkot>
rbuckton: my position is that the desire to weakly hold symbols which may or may not be registered is niche enough that it's sufficient for the language to _support_ it without needing to make it trivial

[11:34:39.0087] <bakkot>
 * rbuckton: my position is that the desire to weakly hold symbols which may or may not be registered is niche enough that it's sufficient for the language to _support_ it without needing to make it trivial

[11:34:53.0878] <yulia>
Robin Ricard: can you add "no preference, general support"?

[11:35:16.0120] <Ben Newman (Apollo, @benjamn on GH)>
XS does not collect any symbols (just stated by Peter H on the call)

[11:35:19.0642] <yulia>
i mean, i care, i like it

[11:35:28.0731] <rickbutton>
yulia: "indifferent"

[11:35:31.0423] <shu>
Ben Newman (Apollo, @benjamn on GH): why is that unsound?

[11:35:35.0620] <Robin Ricard>
changed wording

[11:35:42.0844] <shu>
it happens with strings all the time

[11:35:56.0475] <shu>
and doubles, actually, in V8

[11:36:12.0511] <Ben Newman (Apollo, @benjamn on GH)>
@shu because the reference shouldn't change in any semantically observable way, and the WeakMap question provides observability

[11:36:27.0384] <Ben Newman (Apollo, @benjamn on GH)>
strings aren't stored in [weak]maps/sets by reference though

[11:36:31.0822] <Ben Newman (Apollo, @benjamn on GH)>
they're stored by value

[11:36:41.0236] <bakkot>
it's only unsound if WeakMaps can hold registered symbols

[11:36:42.0724] <shu>
strings can't be put into weak collections at all

[11:36:52.0344] <shu>
 * strings can't be put into weak collections at all

[11:36:53.0453] <bakkot>
(and doing so does not prevent GC of the symbol)

[11:36:59.0344] <shu>
correct

[11:37:06.0287] <Ben Newman (Apollo, @benjamn on GH)>
I'm saying it's unsound anyway, and this is just the first gotcha we've encountered

[11:37:13.0496] <shu>
it's... not unsound anyway

[11:37:21.0418] <Ben Newman (Apollo, @benjamn on GH)>
it's sound by accident, currently

[11:37:34.0454] <bakkot>
wasn't an accident

[11:37:50.0982] <bakkot>
that was definitely an intentional part of the design of the symbol registry

[11:38:12.0146] <shu>
yes, they *were* accidentally eternal before, when it was keyed by something else, like parse nodes or something?

[11:38:34.0137] <yulia>
i have the screenshots if anyone needs them

[11:38:43.0211] <bakkot>
you're thinking of template tags

[11:38:43.0548] <yulia>
cc Robin Ricard 

[11:38:53.0369] <shu>
oh, i am, bakkot correct

[11:41:55.0776] <Robin Ricard>
thanks yulia, nicolo took them as well so we are good

[11:43:30.0902] <Ben Newman (Apollo, @benjamn on GH)>
catch the positive names?

[11:43:36.0243] <Ben Newman (Apollo, @benjamn on GH)>
 * catch the positive names?

[11:50:54.0430] <TabAtkins>
shu: "We should do the same as others" isn't quite the point, "everyone else is doing something useful that we aren't" is.

[11:52:36.0161] <shu>
TabAtkins: can i cast your own spell on you? isn't that a fully general argument for stdlib differences?

[11:53:12.0783] <TabAtkins>
No, it's just pointing out that the argument wasn't just "we should be following the bandwagon".

[11:53:21.0438] <shu>
ah

[11:53:34.0342] <shu>
i was responding to the narrower motivating story of "even surma got tripped up"

[11:54:02.0314] <TabAtkins>
The other lang's version of split() is just genuinely better, which is definitely part of why JS's version is so confusing. ^_^

[11:54:07.0150] <shu>
which isn't the same as "i wish we had this other behavior but we don't", it's "i thought our behavior was X but it wasn't"

[11:54:54.0605] <bakkot>
I will try to remember to ask my dad about the history of this next time I talk to him

[11:55:16.0455] <TabAtkins>
Insofar as Surma would have been confused by Python (off-by-one versus the other langs), sure. But it's not clear from his particular complaint whether it was *just* familiarity or "i'm confused this works differently entirely"

[11:55:46.0341] <leobalter>
I'd like if we rename this splitn to `String.prototype.part` (or parts)

[11:55:54.0537] <leobalter>
 * I'd like if we rename this splitn to `String.prototype.part` (or parts)

[12:00:41.0913] <TabAtkins>
Going for the `{remainder: true}` part and taking on Python's numbering semantics would defuse these complains, I think.

[12:00:59.0717] <Michael Ficarra>
I have an open issue about the possible confusion that Chip is talking about: https://github.com/lucacasonato/proposal-reversible-string-split/issues/6

[12:01:24.0638] <TabAtkins>
So `.split(..., 2, ...)` always returns 2 bits between separators, you just get a *third* item with the remainder if you pass the flag. 

[12:02:10.0052] <bakkot>
> taking on Python's numbering semantics would defuse these complains, I think

[12:02:17.0143] <bakkot>
say more about what that means?

[12:05:22.0203] <ljharb>
Luca Casonato: i invited you to tc39-transfer on github, so you can bounce your proposal repo there

[12:06:14.0846] <TabAtkins>
bakkot: Well there was an "and" there that was pretty important.

[12:06:33.0611] <TabAtkins>
The part after the "and" that you quoted was more of an "(and, in effect, ...)"

[12:07:39.0703] <Luca Casonato>
> <@leobalter:matrix.org> I'd like if we rename this splitn to `String.prototype.part` (or parts)

Could you add that to this issue? https://github.com/lucacasonato/proposal-reversible-string-split/issues/6

[12:08:32.0194] <TabAtkins>
But basically, if we use a flag argument in .split(), I don't think we should significantly change the existing semantics/behavior of the proposal. `.split(..., 2)` should still always trigger (up to) 2 splits, with the option just controlling whether we get the remainder or not included in the array.

[12:08:58.0745] <TabAtkins>
That also avoids all the regex questions, since the answer remains "act exactly as normal, just include the remainder as a final item"

[12:11:03.0745] <Surma>
(sounds like Luca Casonato got stage 1? :D)

[12:11:17.0136] <TabAtkins>
yes

[12:12:23.0540] <Luca Casonato>
> <@surma:matrix.org> (sounds like Luca Casonato got stage 1? :D)

indeed! :D

[12:12:36.0668] <leobalter>
> <@lucacasonato:matrix.org> Could you add that to this issue? https://github.com/lucacasonato/proposal-reversible-string-split/issues/6

Done

[12:13:16.0435] <Luca Casonato>
> <@tabatkins:matrix.org> But basically, if we use a flag argument in .split(), I don't think we should significantly change the existing semantics/behavior of the proposal. `.split(..., 2)` should still always trigger (up to) 2 splits, with the option just controlling whether we get the remainder or not included in the array.

Don't generally disagree with this, I just worry about discoverability here. If people already don't know about the second argument, how will they find a third argument?

[12:13:40.0604] <TabAtkins>
If people already don't know about the second argument, how will they find a completely separate method?

[12:13:54.0099] <Luca Casonato>
> <@tabatkins:matrix.org> If people already don't know about the second argument, how will they find a completely separate method?

Editor autocompletions :-)

[12:14:13.0618] <TabAtkins>
Editors often offer signature suggestions too ^_^

[12:16:21.0181] <Luca Casonato>
> <@tabatkins:matrix.org> That also avoids all the regex questions, since the answer remains "act exactly as normal, just include the remainder as a final item"

This brings up the question of what our actual definition of N is - is it number of splits, or number of return values? If we continue expanding regexps capturing groups into the return values array when "remainder" is included, then we must use number of return values (non python behaviour). I'd argue that if we overload, then the overload should not support regexp separators.

[12:16:55.0023] <Ben Newman (Apollo, @benjamn on GH)>
 * "eternal" seems to mean/imply "recoverable after all references are lost"

[12:17:49.0289] <Luca Casonato>
Really, I dislike this capturing group expansion into the return value array behaviour. It significantly increases complexity

[12:19:01.0675] <TabAtkins>
Ugggggh I didn't realize the N is *literally* "length of the returned array" even when regex capture groups are used, that's *worthless*.

[12:19:27.0735] <ljharb>
does anyone know who https://github.com/phohensee is, in relation to tc39?

[12:22:49.0095] <Luca Casonato>
> <@tabatkins:matrix.org> Ugggggh I didn't realize the N is *literally* "length of the returned array" even when regex capture groups are used, that's *worthless*.

You understand my frustration now? xD

[12:23:32.0844] <HE Shi-Jun>
Yeah the currrent split behavior is just useless 

[12:23:39.0601] <Luca Casonato>
`"".split(sep, n)` === `"".split(sep).slice(0, n)` 

[12:24:30.0793] <ljharb>
for n >= 0, i presume

[12:24:33.0986] <ljharb>
 * for n >= 0, i presume

[12:25:12.0135] <HE Shi-Jun>
I think we'd better follow rust, splitN(n, s) seems very clear and won't confused with the old one.

[12:25:21.0293] <Luca Casonato>
> <@ljharb:matrix.org> for n >= 0, i presume

```
> "a|b|c|d|e".split("|", -1)
[ "a", "b", "c", "d", "e" ]
```

[12:30:20.0807] <Michael Ficarra>
üéâ we just got consensus at the UTC meeting for my proposal to stabilise the spelling of property names/values/aliases! https://www.unicode.org/L2/L2022/22029-canonical-prop-spelling.pdf

[12:31:50.0083] <Michael Ficarra>
we'll be able to delete tables 67 and 68 now

[12:41:17.0502] <Ben Newman (Apollo, @benjamn on GH)>
 * table 69 is breathing a sigh of relief right now

[12:59:00.0237] <Rob Palmer>
the meeting resumes in 60 seconds

[13:03:12.0813] <bakkot>
Michael Ficarra: did you ask them why they recommended loose matching in the first place?

[13:03:39.0384] <Michael Ficarra>
no, though it sounded like it's just kind of their default position

[13:03:50.0575] <bakkot>
weird

[13:04:52.0957] <Michael Ficarra>
someone was like "can't we just make it stable but not add it to our stability policy?" and I was like "uuuhhhh that's not gonna work" lol

[13:05:27.0486] <Michael Ficarra>
imo the only reason they would want that is if they planned to break it

[13:07:54.0926] <Michael Ficarra>
why do we allow this form in any position other than the target of a call? do we really want it being passed around?

[13:08:13.0957] <ljharb>
which form?

[13:08:24.0188] <Michael Ficarra>
class.hasInstance

[13:08:39.0587] <ljharb>
i assume `class.hasInstance()` would work just like `super()` and `import()`, in that it's not a real function and can't be passed around

[13:08:54.0245] <Michael Ficarra>
exactly, that's what I'm suggesting

[13:09:06.0277] <ljharb>
oh, is this proposal currently suggesting something different?

[13:09:31.0859] <Michael Ficarra>
that's how I understood the presenter, maybe not?

[13:09:54.0365] <Michael Ficarra>
I didn't look at spec text for this proposal

[13:10:04.0086] <ljharb>
for stage 2 i'd definitely insist alongside you that that's how it work ¬Ø\\\_(„ÉÑ)\_/¬Ø

[13:10:20.0146] <Michael Ficarra>
oh no your arm

[13:10:33.0194] <ljharb>
 * for stage 2 i'd definitely insist alongside you that that's how it work ¬Ø\\_(„ÉÑ)_/¬Ø

[13:10:36.0757] <ljharb>
 * for stage 2 i'd definitely insist alongside you that that's how it work ¬Ø\\\_(„ÉÑ)\_/¬Ø

[13:10:48.0948] <ljharb>
lol matrix is even worse than github with the markdown escaping (Ôºç‚Ä∏·Éö) 

[13:12:46.0645] <shu>
i thought it was a meta property call syntax, yeah

[13:12:50.0199] <shu>
how do you even pass it around

[13:13:27.0371] <ljharb>
if it were a real function you could `foo(class.hasInstance)` but obv that'd be subpar

[13:13:52.0087] <shu>
well right, but i didn't think it was a real function

[13:15:34.0638] <Michael Ficarra>
someone want to ask the clarifying question? I'm kinda in the middle of my lunch

[13:15:44.0121] <bakkot>
i am not so convinced by the "you might end up with a partially constructed instance" problem. you have to work pretty hard to still end up with a reference to the instance when a field initializer throws; it's not something you're going to end up passing around natuarlly

[13:16:10.0826] <shu>
i am not understanding what is being proposed for the synthetic brand he wants `class.hasInstance` to make

[13:16:13.0422] <shu>
at the start or at the end?

[13:16:27.0153] <shu>
oh here's the slide

[13:17:20.0367] <bakkot>
"after the constructor returns" does seem like the right answer to this question to me yeah

[13:18:14.0238] <Michael Ficarra>
oh THAT'S what he meant by function-like

[13:19:09.0108] <bakkot>
does `import()` work inside eval?

[13:19:17.0202] <bakkot>
i am guessing yes, so I would say this should also work

[13:19:36.0044] <bakkot>
"if there is a direct eval you have to do a lot more work" is not a new thing

[13:20:28.0553] <shu>
super does

[13:20:39.0543] <shu>
and super already causes extra allocation for home objects

[13:20:44.0773] <shu>
so eval also causes that

[13:20:53.0370] <shu>
it's no worse than the status quo, which remains "don't use eval"

[13:21:08.0312] <ljharb>
private fields don't tho, i think

[13:21:19.0199] <shu>
really?

[13:21:25.0016] <ljharb>
~hm, let me confirm~ no nvm, they do work

[13:21:42.0909] <rbuckton>
I need to draft an update on class access expressions. Assuming it will ever move forward, I think I need to move it to a meta property like `class.static` or something.

[13:22:02.0474] <rbuckton>
or `class.constructor` maybe.

[13:22:07.0501] <ljharb>
 * ~hm, let me confirm~ no nvm, they do work

[13:22:11.0488] <ljharb>
 * ~~hm, let me confirm~~ no nvm, they do work

[13:22:17.0473] <ljharb>
 * ~hm, let me confirm~ no nvm, they do work

[13:22:33.0094] <ptomato>
I think we're managing just adequately with the notes, so no need to interrupt the presentation to ask for more, but if someone wants to help out I'd nonetheless appreciate it

[13:23:47.0392] <Michael Ficarra>
rbuckton: for anonymous classes or something?

[13:25:17.0679] <rbuckton>
Its original intent was to handle multiple things: anonymous classes and giving a consistent name to access statics to avoid the `this.#foo` footgun in static methods

[13:26:52.0314] <ljharb>
it's also nice to avoid repeating the class name - gives you only one thing to change if you want to rename a class declaration

[13:26:54.0588] <Rob Palmer>
so `hasInstance()` true implies the object was fully constructed without throwing

[13:26:58.0722] <ljharb>
 * it's also nice to avoid repeating the class name - gives you only one thing to change if you want to rename a class declaration

[13:27:39.0742] <shu>
all non-throwing cases can be, yes

[13:27:42.0785] <Michael Ficarra>
then why did we even expose an immutable binding inside the class? I'm unconvinced

[13:27:53.0517] <shu>
~~~recursion~~~~~~

[13:28:00.0139] <shu>
what the hell

[13:28:13.0654] <shu>
i typed `~~~~recursion~~~~~~`

[13:28:15.0158] <ljharb>
yulia: i do agree that `class.hasInstance` is always equivalent to a private field at the end of the class body, that's assigned to `sentinel` at the end of the constructor, and doing `#field in o && o.#field === sentinel`

[13:28:28.0925] <shu>
it's not equivalent to private field at the end, is it?

[13:28:29.0024] <Rob Palmer>
to replicate this feature with ergonomic brand checks, i think the user would have to assign to the brand field at each return point in the constructor

[13:28:49.0415] <shu>
yeah, it's like that, but that's also why i'm kinda not super convinced

[13:28:51.0891] <ljharb>
Michael Ficarra good question. i don't find that binding immutability particularly useful, and would have preferred a class access expression

[13:28:56.0804] <shu>
but i'll ask during my queue item

[13:29:28.0737] <rbuckton>
> <@michaelficarra:matrix.org> then why did we even expose an immutable binding inside the class? I'm unconvinced

The immutable binding in the class has been a problem for decorators and is constantly surprising to some

[13:29:37.0688] <Michael Ficarra>
ljharb: I think it speaks to the intentions of the delegates who designed the class proposal

[13:29:58.0317] <bakkot>
> <@robpalme:matrix.org> to replicate this feature with ergonomic brand checks, i think the user would have to assign to the brand field at each return point in the constructor

only because someone might get a hold of `this` during the constructor even if the constructor throws, right? if you assume the ctor/initializers don't throw it's equivalent?

[13:29:58.0777] <Ashley Claymore>
https://github.com/tc39/proposal-class-brand-check/issues/6#issuecomment-1015303592

[13:30:03.0891] <shu>
Michael Ficarra: it might be just copying the function scope

[13:30:13.0828] <shu>
named function expressions also have that constant lambda scope

[13:30:14.0866] <ljharb>
Michael Ficarra: since some of them are here, it'd be nice to hear their intentions spoken instead of inferring them

[13:30:19.0350] <ljharb>
but yes, it's the same way functions work

[13:30:20.0639] <bakkot>
if so, as I said above, i am not so convinced by the "you might end up with a partially constructed instance" problem

[13:30:29.0374] <Michael Ficarra>
shu: they have their own name scope, but it's mutable

[13:30:35.0417] <ljharb>
which fwiw is also subpar, it's just that self-recursion is much rarer than accessing the constructor's statics

[13:30:37.0663] <shu>
what

[13:30:41.0681] <shu>
the lambda scope is not mutable

[13:30:52.0566] <Michael Ficarra>
uhh I thought it was, let me check

[13:31:00.0304] <bakkot>
nope

[13:31:04.0085] <bakkot>
you can assign to it but it's immutable

[13:31:08.0563] <shu>
yeah

[13:31:11.0058] <bakkot>
it's a unique kind of const among bindings in JS

[13:31:14.0522] <shu>
it's not the same semantics as const but it's immutable

[13:31:15.0318] <shu>
so good

[13:31:22.0668] <Michael Ficarra>
ugh weird

[13:31:31.0266] <bakkot>
 * it's a unique kind of const among bindings in JS

[13:31:53.0416] <bakkot>
> <@ljharb:matrix.org> which fwiw is also subpar, it's just that self-recursion is much rarer than accessing the constructor's statics

doubt

[13:32:03.0568] <ljharb>
doubt which, the rarity?

[13:32:06.0782] <Rob Palmer>
> <@bakkot:matrix.org> only because someone might get a hold of `this` during the constructor even if the constructor throws, right? if you assume the ctor/initializers don't throw it's equivalent?

yes.  maybe the constructor passes `this` to a static function that contains `hasInstance` from the same class

[13:32:11.0314] <shu>
> <@michaelficarra:matrix.org> ugh weird

sickos.jpg

[13:32:12.0435] <bakkot>
yes

[13:32:21.0904] <ljharb>
bakkot: recursion at all is rare in JS due to a lack of PTC

[13:32:29.0836] <ljharb>
it's certainly all over the place, but way rarer than it would be otherwise

[13:32:30.0757] <shu>
...false?

[13:32:32.0765] <bakkot>
this has not been my experience

[13:32:44.0007] <ljharb>
perhaps we look at very different kinds of codebases

[13:32:50.0188] <shu>
most useful recursion i argue is in fact not tail recursion

[13:33:12.0647] <Michael Ficarra>
everything is tail recursion

[13:33:15.0883] <waldemar>
How does Contains work with respect to a class? If you're evaluating Contains on Expr which contains a class expression C, does Contains peek into C's computed property names?

[13:33:37.0606] <Justin Ridgewell>
I do recursion all the time.

[13:33:47.0884] <bakkot>
waldemar: there is a special ComputedPropertyContains which, yes, descends into the computed property names, but not into method bodies or initializers

[13:33:53.0465] <waldemar>
And if you're doing Contains on C itself, does it peek into its own property names?

[13:34:13.0414] <bakkot>
That one I'm not sure of offhand

[13:34:46.0227] <bakkot>
looks like, yes, it peeks into its names but not into method bodies, same as if you called Contains on a parent of C

[13:34:49.0948] <waldemar>
It seems that both do, which is weird. Things in computed property names are both in the class and not in the class?

[13:35:13.0360] <waldemar>
This is a problem for things which are class-scoped like the proposal just presented.

[13:35:36.0804] <bakkot>
We'd need to use a different operation than Contains, yes

[13:36:54.0212] <bakkot>
Contains normally stops at function boundaries - which you can read to mean "places where `yield` might start meaning a different thing", to be precise - which is why it looks into computed property names but not method bodies

[13:37:20.0583] <waldemar>
Hax's proposal makes it pierce function boundaries

[13:37:40.0626] <waldemar>
Methinks Contains is getting too overloaded and confusing

[13:37:56.0891] <bakkot>
I would suggest introducing a different operation, yes

[13:38:28.0286] <bakkot>
we've done that before - e.g. we have ContainsArguments for looking for `arguments` in field initializers, which is like Contains but with some details different (it descends into arrows, in particular)

[13:38:46.0104] <bakkot>
adding a similar new ContainsClassHasInstance is probably the way to go

[13:48:34.0883] <HE Shi-Jun>
Currently we use ContainsClassHasInstance to check whether a class scope include any class.hasInstance. Maybe we don't need modify Contains... Speccing such things is too hard for me or TianYang üòÇ

[13:49:20.0158] <HE Shi-Jun>
Actually we already rewrite the spec text at least three times.

[13:52:28.0837] <HE Shi-Jun>
> <@waldemarh:matrix.org> It seems that both do, which is weird. Things in computed property names are both in the class and not in the class?

We (three champion) haven't has meeting for that, but we chatted about it  yesterday and we tend to make `class.hasInstance` in computed property syntax error. Though as current spec text, (if I really figure out all things) i believe it's allowed but always give u false, because at that time, no one have the class so no instance of it.

[13:53:37.0035] <HE Shi-Jun>
> <@waldemarh:matrix.org> Hax's proposal makes it pierce function boundaries

Yeah, this part make me headache...

[13:54:00.0617] <bakkot>
If you figure out exactly what the semantics you want I'm happy to help with writing the spec text before stage 3

[13:54:27.0128] <bakkot>
at least in terms of telling what is probably the simplest way to write the thing you want

[13:54:54.0565] <bakkot>
important part is figuring out the semantics you want

[13:59:47.0660] <Rick Waldron>
rbuckton: I just realized that I'm going to miss the Enum proposal because I have to go get my kid from school.

[14:00:34.0682] <bakkot>
waldemar: if it's a syntax error [in computed names] then it doesn't refer to either the inner or outer class, because it's unutterable

[14:00:39.0167] <bakkot>
which seems like a good approach to me

[14:00:46.0081] <rbuckton>
> <@rwaldron:matrix.org> rbuckton: I just realized that I'm going to miss the Enum proposal because I have to go get my kid from school.

Is there anything you need me to cover?

[14:00:50.0566] <bakkot>
 * waldemar: if it's a syntax error [in computed names] then it doesn't refer to either the inner or outer class, because it's unutterable

[14:01:44.0663] <HE Shi-Jun>
sorry i lose the connection

[14:05:13.0261] <Justin Ridgewell>
~Do we have a link to the slides?~ nevermind, the agenda was updated

[14:05:30.0809] <Justin Ridgewell>
 * ~Do we have a link to the slides?~ nevermind, the agenda was updated

[14:10:56.0694] <Mathieu Hofman>
> <@bakkot:matrix.org> Mathieu Hofman: can you confirm the conclusion we have captured in the notes is correct

Looks right to me. And PR has been updated.

[14:11:14.0759] <Ashley Claymore>
I wonder if we could have a more general construct for 'run this on successful return' . `catch` for errors, `finally` for all exits and something else for `completed without error`

[14:11:31.0708] <Ashley Claymore>
`</half-baked-idea>`

[14:11:50.0196] <bakkot>
> <@mhofman:matrix.org> Looks right to me. And PR has been updated.

(pr will need another update; see comment)

[14:12:28.0246] <bakkot>
Ashley Claymore: there's been proposals for like a `catch.error` meta-property you could use in `finally` which would tell you what the error is in that case

[14:12:36.0454] <ljharb>
Ashley Claymore: isn't that just "add a statement at the end of the `try`" tho

[14:12:41.0590] <bakkot>
which lets you just check in your `finally` if you are in the `completed without error` case

[14:12:55.0018] <bakkot>
ljharb: end of the `try` isn't necessarily reached if there's a `return`

[14:13:01.0411] <ljharb>
(to add that now we'd have to solve it both for syntactic and Promise `finally`)

[14:13:03.0480] <ljharb>
oh true

[14:13:28.0709] <bakkot>
strong disagree with the claim that any functionality available in syntactic finally must also be available in `Promise.finally`

[14:13:33.0108] <bakkot>
if that was the claim

[14:13:41.0273] <Ashley Claymore>
> <@ljharb:matrix.org> Ashley Claymore: isn't that just "add a statement at the end of the `try`" tho

I set a flag in a catch

[14:13:44.0003] <ljharb>
it was, because in the past that was one of the stated blockers for three-state promises - iow, that claim has precedent.

[14:13:55.0920] <ljharb>
 * it was, because in the past that was the stated blocker for three-state promises - iow, that claim has precedent.

[14:14:02.0195] <ljharb>
 * it was, because in the past that was one of the stated blockers for three-state promises - iow, that claim has precedent.

[14:14:17.0753] <ljharb>
eg the whole `catchCancel` thing

[14:14:26.0292] <bakkot>
ehhhhhhhhhhhhhhhhhhhhh

[14:14:40.0884] <bakkot>
don't really agree with that on multiple levels

[14:14:57.0725] <ljharb>
none the less, that parity was a huge part of the design of Promise, and it constrained me on Promise `finally` as well

[14:15:36.0543] <ljharb>
any motivating use case for `catch.error` would exist in promise finally, so i'm not sure i understand why it'd be ok to do just one

[14:15:48.0571] <bakkot>
you can achieve the same thing with `.then` and `.catch` if you really want to

[14:16:17.0859] <ljharb>
you can achieve it with a boolean flag in .catch too.

[14:16:25.0446] <bakkot>
yeah but it's gross

[14:16:34.0954] <bakkot>
> so i'm not sure i understand why it'd be ok to do just one

you can add a meta-property to solve it in syntax, and you cannot do that to add it in `Promise.finally`

[14:16:46.0591] <ljharb>
right, it'd have to be an argument to the finally callback somehow

[14:16:50.0661] <bakkot>
"there is a good way to do this in one case, and not in this other" is a fine reason to provide an affordance in one case and not the other

[14:16:59.0566] <Mathieu Hofman>
> <@bakkot:matrix.org> Ashley Claymore: there's been proposals for like a `catch.error` meta-property you could use in `finally` which would tell you what the error is in that case

I have on my list of wishes to add an optional error argument to the `finally` block:
```
try {
 // something that throws
} finally (err) {
  if (err) {
    // something
  } else {
    //something else
  }
}
```

[14:17:23.0642] <Ashley Claymore>
what if someone throws falsey

[14:17:26.0101] <ljharb>
Mathieu Hofman: you can throw and reject with `undefined`, so it'd have to be a container

[14:17:30.0057] <yulia>
you can implement this with private fields though, so it is a usecase that is possible with it -- is it being used for that?

[14:17:32.0074] <waldemar>
> We (three champion) haven't has meeting for that, but we chatted about it  yesterday and we tend to make `class.hasInstance` in computed property syntax error. Though as current spec text, (if I really figure out all things) i believe it's allowed but always give u false, because at that time, no one have the class so no instance of it.

It's not always false. You can define a function inside a computed property name expression, squirrel it away somewhere, and call it later.

[14:17:52.0047] <waldemar>
 * > We (three champion) haven't has meeting for that, but we chatted about it  yesterday and we tend to make `class.hasInstance` in computed property syntax error. Though as current spec text, (if I really figure out all things) i believe it's allowed but always give u false, because at that time, no one have the class so no instance of it.
It's not always false. You can define a function inside a computed property name expression, squirrel it away somewhere, and call it later.

[14:17:53.0628] <Mathieu Hofman>
and allow spread so you can do `finally (...errs) { if (errs.length); }` to handle the `err === undefined` case

[14:18:02.0331] <waldemar>
 * > We (three champion) haven't has meeting for that, but we chatted about it  yesterday and we tend to make `class.hasInstance` in computed property syntax error. Though as current spec text, (if I really figure out all things) i believe it's allowed but always give u false, because at that time, no one have the class so no instance of it.
> It's not always false. You can define a function inside a computed property name expression, squirrel it away somewhere, and call it later.

[14:18:13.0166] <waldemar>
 * > We (three champion) haven't has meeting for that, but we chatted about it  yesterday and we tend to make `class.hasInstance` in computed property syntax error. Though as current spec text, (if I really figure out all things) i believe it's allowed but always give u false, because at that time, no one have the class so no instance of it.

It's not always false. You can define a function inside a computed property name expression, squirrel it away somewhere, and call it later.

[14:18:20.0964] <ljharb>
i suppose that'd work in `.finally` with `arguments.length`

[14:18:30.0380] <Mathieu Hofman>
And similar for `Promise.p.finally`

[14:18:43.0299] <Ashley Claymore>
Also there's not a way to only freeze prototype right, though I think there is a proposal for that right?

[14:18:44.0533] <Mathieu Hofman>
 * And similar for `Promise.p.finally`

[14:18:47.0101] <bakkot>
anyway maybe it would prove possible to add an argument to the `Promise.finally` callback, which would be fine; but if not I don't think that needs to block the syntax

[14:19:10.0887] <bakkot>
> <@aclaymore:matrix.org> Also there's not a way to only freeze prototype right, though I think there is a proposal for that right?

yeah, though I haven't been working on that one lately

[14:19:38.0291] <bakkot>
need to revisit and figure out how to work with the rest of the traps, like [[IsExtensible]]

[14:20:04.0545] <ljharb>
i'd love to see that freeze proto one advance

[14:20:28.0646] <shu>
override mistake be damned?

[14:20:56.0805] <ljharb>
? how does it conflict with that?

[14:21:32.0619] <shu>
oh, maybe i misunderstood what the freeze proto proposal does

[14:21:47.0452] <ljharb>
iiuc it'd make Object.prototype not be exotic, because it'd make "a fully mutable object with a frozen [[Prototype]]" a normally achievable thing

[14:21:52.0531] <ljharb>
 * iiuc it'd make Object.prototype not be exotic

[14:22:05.0394] <ljharb>
 * iiuc it'd make Object.prototype not be exotic, because it'd make "a fully mutable object with a frozen prototype" a normally achievable thing

[14:22:08.0608] <shu>
yeah i completely misunderstood, please ignore

[14:22:10.0310] <bakkot>
yeah, just freezes the prototype slot itself, not the prototype object

[14:22:14.0548] <ljharb>
 * iiuc it'd make Object.prototype not be exotic, because it'd make "a fully mutable object with a frozen [[Prototype]]" a normally achievable thing

[14:22:24.0349] <bakkot>
> <@shuyuguo:matrix.org> override mistake be damned?

still on board with this though :P

[14:22:36.0352] <ljharb>
lol

[14:22:51.0748] <shu>
if you can get someone else to own the breakage fallout bugs on v8, sure

[14:23:44.0970] <bakkot>
really it's more "be damned" in the sense of "damn it"

[14:26:15.0159] <yulia>
HE Shi-Jun: posted https://github.com/tc39/proposal-class-brand-check/issues/15

[14:27:08.0277] <bakkot>
ljharb: ok, so, syntactic `finally` is already unlike `Promise.prototype.finally`, in that syntactic `finally` can _override_ the return value, and `Promise.prototype.finally` cannot

[14:27:13.0839] <bakkot>
so how does that not already break the equivalence?

[14:28:22.0040] <HE Shi-Jun>
> <@waldemarh:matrix.org> > We (three champion) haven't has meeting for that, but we chatted about it  yesterday and we tend to make `class.hasInstance` in computed property syntax error. Though as current spec text, (if I really figure out all things) i believe it's allowed but always give u false, because at that time, no one have the class so no instance of it.
> 
> It's not always false. You can define a function inside a computed property name expression, squirrel it away somewhere, and call it later.

You are correct! so maybe we could keep current behavior üòÖ 

[14:30:55.0424] <bakkot>
I like syntax error, syntax error is good - there is no reason to want to write this code

[14:31:42.0728] <ljharb>
bakkot: you're right, that is the one way it's unlike; and given that it's impossible via the callback, we all decided to accept that difference. but that doesn't mean further avoidable deviation is a good idea

[14:32:08.0987] <bakkot>
sure. depends on how avoidable it is.

[14:32:10.0675] <Michael Ficarra>
I am so incredibly opposed to auto-increment, I cannot find the words to describe it

[14:34:09.0082] <ljharb>
so for the enum proposal - this is a ton of discussion about semantics, which are more of a stage 1+ concern. is it worth a üí© to talk about problem space/motivation?

[14:34:18.0173] <ljharb>
sorry that's a "point of order" initialism; my autocorrect took over

[14:34:24.0477] <ljharb>
 * sorry that's a "point of order" initialism; my autocorrect took over

[14:34:29.0074] <Michael Ficarra>
ljharb: agreed, was thinking the same thing

[14:34:46.0724] <Michael Ficarra>
this is cool and all, but the more important bit is to convince us that there's a problem worth solving here

[14:34:52.0091] <Justin Ridgewell>
Lessons from protobuf are that anything other than explicitly id'd values are a big footgun for cross-module apps

[14:34:55.0386] <rbuckton>
auto-increment gives a meaningful value for enums whose base primitive is `number`.

[14:35:12.0999] <Mathieu Hofman>
> <@aclaymore:matrix.org> Also there's not a way to only freeze prototype right, though I think there is a proposal for that right?

Yeah unfortunately setImmutablePrototype is tied to preventExtensions right now. I wish it was available

[14:35:44.0027] <bakkot>
https://github.com/tc39/proposal-freeze-prototype

[14:36:35.0567] <bakkot>
(very stale, as mentioned, just the place to follow along or pick up if you want to make it happen)

[14:37:02.0745] <rbuckton>
If you have `enum Color of String { Red, Green, Blue }`, it can be clear that `Color.Red === "Red"`.
If you have `enum Color of Symbol { Red, Green, Blue }`, it can be clear that `typeof Color.Red === "symbol"` and `Color.Red.description === "Color.Red"`.
If you have `enum Color of Number { Red, Green, Blue }`, what would you expect `Color.Red` to be?

[14:37:12.0052] <rbuckton>
 * If you have `enum Color of String { Red, Green, Blue }`, it can be clear that `Color.Red === "Red"`.
If you have `enum Color of Symbol { Red, Green, Blue }`, it can be clear that `typeof Color.Red === "symbol" and `Color.Red.description === "Color.Red"`.
If you have`enum Color of Number { Red, Green, Blue }`, what would you expect `Color.Red` to be?

[14:37:12.0309] <Mathieu Hofman>
> <@shuyuguo:matrix.org> if you can get someone else to own the breakage fallout bugs on v8, sure

I have ideas to tame the override mistake beast, but I need to familiarize myself with previous attempts first

[14:37:23.0321] <rbuckton>
 * If you have `enum Color of String { Red, Green, Blue }`, it can be clear that `Color.Red === "Red"`.
If you have `enum Color of Symbol { Red, Green, Blue }`, it can be clear that `typeof Color.Red === "symbol" and `Color.Red.description === "Color.Red"`.  
If you have`enum Color of Number { Red, Green, Blue }`, what would you expect `Color.Red` to be?

[14:37:28.0780] <shu>
good luck

[14:37:34.0899] <rbuckton>
 * If you have `enum Color of String { Red, Green, Blue }`, it can be clear that `Color.Red === "Red"`.
If you have `enum Color of Symbol { Red, Green, Blue }`, it can be clear that `typeof Color.Red === "symbol"` and `Color.Red.description === "Color.Red"`.
If you have`enum Color of Number { Red, Green, Blue }`, what would you expect `Color.Red` to be?

[14:38:05.0244] <rbuckton>
 * If you have `enum Color of String { Red, Green, Blue }`, it can be clear that `Color.Red === "Red"`.
If you have `enum Color of Symbol { Red, Green, Blue }`, it can be clear that `typeof Color.Red === "symbol"` and `Color.Red.description === "Color.Red"`.
If you have `enum Color of Number { Red, Green, Blue }`, what would you expect `Color.Red` to be?

[14:39:37.0768] <yulia>
note takers?

[14:40:30.0647] <Michael Ficarra>
it's unfortunate, I think there actually is a pattern in use in the wild that we could improve by providing language support with something like this, but this proposal hasn't been motivated in that way

[14:41:02.0199] <Michael Ficarra>
> <@mhofman:matrix.org> I have ideas to tame the override mistake beast, but I need to familiarize myself with previous attempts first

many have come before you; none have succeeded

[14:41:17.0419] <shu>
i am most interested in danielrosenwasser's agenda item

[14:41:35.0714] <shu>
the thing that would convince me is to get rid of a TS wart if TS is willing to do some kind of breaking change, or maybe there's a way to thread the needle, idk

[14:42:04.0631] <Mathieu Hofman>
> <@ljharb:matrix.org> bakkot: you're right, that is the one way it's unlike; and given that it's impossible via the callback, we all decided to accept that difference. but that doesn't mean further avoidable deviation is a good idea

At least errors thrown or a rejected promise returned in a finally is taken into consideration. I think `return` or `break` being control flow justify the difference

[14:42:36.0361] <Rob Palmer>
do we accept that creating a set of unique values for a given type is a frequent use-case?   I hope the answer is yes - it feels self-evident based on other languages and my personal usage.

[14:42:51.0878] <shu>
sure, but it's not an expressivity gap

[14:43:26.0804] <Michael Ficarra>
shu: but I bet there's some value in normalising how that's done

[14:43:43.0793] <Rob Palmer>
it's not succinct enough with the current constructs imo - it becomes imperative rather than declarative

[14:43:50.0380] <Michael Ficarra>
right now people just do one of a dozen different approaches, and it makes code more accessible if everyone is using built-in support

[14:43:59.0235] <ljharb>
i agree on the "coordination" angle for what is currently "a set of strings/symbols/numbers"

[14:44:12.0585] <shu>
that feels very hopeful

[14:44:15.0898] <shu>
i am not that full of hope

[14:44:24.0935] <ljharb>
but i hope we're all on the same page about that motivation before we debate syntax, is all :-)

[14:44:29.0641] <Michael Ficarra>
Rob Palmer: not just succinct, but it would be nice if, for example, all of the value-back-to-enum-name functions had the same name

[14:44:32.0000] <shu>
but i'm not against it! i just want TS to convince me

[14:44:39.0865] <shu>
TS has the biggest lever here in pushing folks to one way

[14:44:55.0917] <rbuckton>
I'm interested in formalizing a syntax for a common pattern, just as `class` formalized syntax for class behaviors previously built using `function`. This also affords a number of opportunities:
- declaration on which to hang decorators for metadata/serialization/etc.
- possibility of leveraging constant inlining vs a regular object.
- possibility of extending to ADT enums with support for pattern matching/destructuring.
- improved API for working with `enum`-like types, such as reverse mapping (value -> key) without the conflicts TS string enums currently have.

[14:45:02.0265] <Justin Ridgewell>
Can we just fix TS's utterly-terrible-no-good-very-bad output for enums?

[14:45:04.0611] <Michael Ficarra>
yeah we're going to have to get past that unfortunate typescript cowpath

[14:46:18.0148] <Rob Palmer>
Mark is now talking about string unions

`type foo = "this" | "that"`

[14:46:32.0586] <shu>
people use string literals as enums, don't they

[14:47:01.0118] <ljharb>
sure but it's nice if they have identity, so Foo.A and Bar.A aren't accidentally interchangeable

[14:47:28.0369] <rbuckton>
You won't necessarily get that for string based enums, but you would for symbol-based ones.

[14:47:28.0863] <shu>
i definitely do not want to solve the ADT use case in the same proposal

[14:47:33.0433] <shu>
that seems like a very very different problem space to me

[14:47:33.0837] <TabAtkins>
Yeah, identity (aka enum members are primitives or similar) is pretty important

[14:47:38.0267] <ljharb>
(i'm still bitter from realizing that scala inherits java's silly confusion of chars and ints)

[14:47:42.0199] <TabAtkins>
and agree that ADT should be put to the side

[14:47:42.0764] <Michael Ficarra>
shu: yes exactly, people use literally dozens of different approaches, and it would be nice if there was more consistency there

[14:47:45.0271] <ljharb>
 * (i'm still bitter from realizing that scala inherits java's silly confusion of chars and ints)

[14:48:11.0690] <Michael Ficarra>
ljharb: Scala inherits *so much* of Java's crap, it really kills the language for me

[14:48:19.0462] <shu>
Michael Ficarra: i dislike TC39 being looked to as a lever to move the ecosystem one way

[14:48:31.0709] <ljharb>
shu: re your queue item, `class` DID actually kill off almost all of the other ways of doing inheritance (including `Object.create`, not that it was very popular before that)

[14:48:37.0471] <Michael Ficarra>
shu: how is it a lever? people are already doing this all over the place

[14:48:41.0260] <ljharb>
so i think an `enum` syntax would actually achieve that goal.

[14:48:43.0354] <shu>
i should qualify, where there is no expressivity gap

[14:49:02.0177] <ljharb>
 * shu: re your queue item, `class` DID actually kill off almost all of the other ways of doing inheritance (including `Object.create`, not that it was very popular before that)

[14:49:40.0120] <shu>
ljharb: `class` is good historical evidence, yes

[14:49:42.0178] <shu>
thanks

[14:50:20.0282] <bakkot>
can't typescript just introduce like a `// ts-enum` annotation which means "this is an enum"

[14:50:24.0586] <bakkot>
without needing new syntax in the language

[14:50:32.0507] <bakkot>
I am confused by this whole "it helps static analysis" claim

[14:50:50.0057] <ljharb>
"eslint, for normal JS" is still a pretty important use case

[14:51:02.0371] <bakkot>
not clear how much this would help eslint?

[14:51:28.0706] <ljharb>
targeting parseable grammar (that comes with semantics) is far easier than trying to target a nonstandard commenting convention?

[14:51:36.0581] <ljharb>
 * targeting parseable grammar (that comes with semantics) is far easier than trying to target a nonstandard commenting convention

[14:51:47.0685] <rbuckton>
There's already a `/** @enum {T} */` in JSDoc, but it does not mean what most people want it to mean, unfortunately.

[14:51:48.0454] <ljharb>
 * targeting parseable grammar (that comes with semantics) is far easier than trying to target a nonstandard commenting convention?

[14:52:15.0750] <shu>
> <@michaelficarra:matrix.org> shu: how is it a lever? people are already doing this all over the place

people aren't doing the same thing all over the place, they're doing the same kind of thing all over the place

[14:52:21.0643] <bakkot>
ljharb: if TS wrote down a specific syntax for the comment then it would not be any harder to target

[14:52:35.0767] <ljharb>
sure but then it'd still be TS-specific, and that's not relevant to non-TS users.

[14:52:40.0254] <Jack Works>
oh sorry I got offlined

[14:52:45.0535] <Jack Works>
let me rejoin

[14:53:35.0577] <bakkot>
ljharb: I was responding specifically to the "it helps TS analysis" motivation

[14:53:41.0153] <bakkot>
if there is some other motivation, sure

[14:53:43.0955] <ljharb>
ah ok, gotcha

[14:53:54.0240] <rbuckton>
I'm interested in whether ADT enums could help avoid megamorphic ICs in V8, where the "kind" of enum value could be inlined into the IC, so that switching/matching on the enum kind wouldn't be polymorphic. 

[14:54:53.0489] <Jack Works>
hmm can anyone hear me? 

[14:55:02.0952] <Jack Works>
looks like still not got online ü§î

[14:55:17.0094] <rbuckton>
The TS compiler has a lot of `switch (node.kind) { ... }` cases that are megamorphic. Being able to do something like `match (node) { when (Node.Identifier) -> ... }` and avoid megamorphism would (hopefully) be a perf win.

[14:55:58.0226] <Michael Ficarra>
exhaustiveness checks will be a godsend, too

[14:56:05.0796] <rbuckton>
Jack Works: Are you able to hear and just can't speak?

[14:57:08.0488] <shu>
rbuckton: not sure why a tagged disjoint union "kind", even if built-in, would make a callsite any less megamorphic

[14:57:46.0125] <shu>
presumably each disjunct of the sum type still has a different layout

[14:57:55.0436] <shu>
if the callsite deals with those different layouts, it's as polymorphic as before

[14:59:26.0679] <Justin Ridgewell>
Can anyone give a demonstration of ADT without using pattern matching?

[14:59:38.0870] <bakkot>
Justin Ridgewell: every AST

[15:00:06.0932] <bakkot>
the usefulness for ASTs means people who work with programming languages tend to think about them a lot

[15:00:10.0321] <TabAtkins>
what's the point of adt without pattern matching

[15:00:11.0905] <bakkot>
 * the usefulness for ASTs means people who work with programming languages tend to think about them a lot

[15:00:30.0697] <TabAtkins>
(i say, as one of the pattern-matching champions)

[15:00:53.0792] <shu>
my hot take is i think PL and compiler people definitely overindex on pattern matching and ADTs

[15:01:03.0217] <shu>
like ML is a great language for writing ML compilers

[15:01:17.0610] <Justin Ridgewell>
A code example. I don't understand how I get fields out of a `Square(int int)`

[15:01:22.0446] <rbuckton>
Yes, but I'm curious if it would be possible to inline a consistent shared field such as a "kind" that *all* ADT enum values would be expected to have, so that the `switch` isn't megamorphic when branching on that "kind". Each branch could then be monomorphic.

[15:01:34.0507] <Justin Ridgewell>
The only thing that demonstrates is pattern matching, and I hate pattern matching.

[15:02:10.0663] <Ben Newman (Apollo, @benjamn on GH)>
hate? wow

[15:02:13.0827] <bakkot>
Justin Ridgewell: normally you name the fields I think

[15:02:21.0264] <rbuckton>
Justin Ridgewell: You mean like, `square[0]`?

[15:02:31.0696] <Justin Ridgewell>
Is it an object?

[15:02:59.0755] <rbuckton>
An ADT enum would likely be a record or tuple value, if not a regular object. That's still TBD.

[15:03:05.0904] <gkz>
Flow Enums: https://flow.org/en/docs/enums/
Comparison with TS and Flow Enums: https://medium.com/flow-type/typescript-enums-vs-flow-enums-83da2ca4a9b4

[15:03:19.0624] <bakkot>
gkz: your mic is still hot I think

[15:03:24.0324] <bakkot>
oh fixed nvm

[15:03:32.0471] <Michael Ficarra>
there's a common pattern in Haskell libraries, considered a good practice, to actually not expose your ADT constructors so that consumers *can't* pattern match on them

[15:03:56.0736] <Michael Ficarra>
the idea is you're supposed to do every kind of pattern matching that makes sense as functions and expose those

[15:04:01.0501] <Michael Ficarra>
also allows for "smart constructors"

[15:04:39.0709] <bakkot>
lol I just did exactly the same thing as PH: https://github.com/Z3Prover/z3/blob/c6539deb6169afde2b569fba89a828f2f726691f/src/api/js/scripts/parse-api.js#L141-L204

[15:04:42.0403] <bakkot>
converts C enums to TS

[15:06:50.0445] <shu>
Justin Ridgewell: i don't think you can get fields out of an ADT without pattern matching. the point of ADTs is that you have N type constructors to create the data, and on the other side you have "eliminators" to unwrap the type constructors and get the field out. usually, the eliminator is pattern matching

[15:07:20.0630] <shu>
on the flipside, you have classes, which sometimes get described as co-data, where eliminators (methods) are how you define the class to begin with

[15:07:51.0557] <shu>
 * Justin Ridgewell: i don't think you can get fields out of an ADT without pattern matching. the point of ADTs is that you have N type constructors to create the data, and on the other side you have "eliminators" to unwrap the type constructors and get the field out. usually, the eliminator is pattern matching

[15:09:40.0460] <shu>
but that part of my life is behind me now, never to be thought of again

[15:09:56.0790] <bakkot>
have a hard time imagining going from that to C++

[15:10:04.0943] <Michael Ficarra>
waldemar: I would describe the problem as "there is a common need today to create related but distinguishable values, and there's many different ways to do it. language support would unify these strategies, make code more approachable, provide useful info to tooling to do things like exhaustiveness checks, etc"

[15:10:43.0774] <Michael Ficarra>
Justin Ridgewell: you should check out recursion schemes

[15:10:44.0279] <bakkot>
that doesn't cover sum types, though

[15:11:06.0720] <ptomato>
but the intention was not to cover sum types in this proposal, right?

[15:11:08.0609] <ptomato>
 * but the intention was not to cover sum types in this proposal, right?

[15:11:14.0733] <bakkot>
ptomato: not clear to me

[15:11:24.0261] <bakkot>
definitely sounded like sum types were in scope?

[15:11:42.0883] <waldemar>
sum types are the interesting part of this proposal, that we can't currently do in the language

[15:11:44.0750] <Michael Ficarra>
the last slide said "simple enums", with other stuff being later

[15:12:06.0539] <waldemar>
but they do have a fairly large impedance mismatch given how dynamically typed ecmascript is

[15:12:28.0906] <rbuckton>
Michael Ficarra: As well as additional affordances that novel syntax would present, such as the possibilities for constant inlining, decorators, serialization, and consistent patterns for construction (and deconstruction) of these values.

[15:13:05.0932] <Michael Ficarra>
I'm frustrated that this couldn't reach stage 1. I think it met the criteria, but just wasn't presented in a way that made that clear, no offense to the champion group.

[15:13:30.0445] <Michael Ficarra>
rbuckton: true

[15:14:04.0641] <Bradford Smith>
I think what's missing here is some clear examples of the current way of doing what enums do are problematic.

[15:14:23.0363] <waldemar>
I'd view the problem more as providing a lightweight statically analyzable way of defining constants in general. But all of the options are biased to do other things by using the `enum` keyword.

[15:14:25.0003] <Bradford Smith>
s/examples of/examples of how/

[15:15:00.0618] <rbuckton>
For example:
```
const Color = { Red: 0, Green: 1, Blue: 2 };
const data = { color: Color.Red };
fs.writeFileSync("foo.json", JSON.stringify(data));
```
Writes `{color:0}`, which isn't helpful when maintaining config files, while:
```
const Color = { Red: Symbol(), Green: Symbol(), Blue: Symbol() };
...
```
Would be safer at runtime, but would fail to stringify. 

[15:15:09.0455] <Bradford Smith>
"JavaScript doesn't have enums" isn't a problem all on its own.

[15:16:34.0766] <Bradford Smith>
rbuckton: that's a start. I'd love to see a presentation with at least a half dozen such examples and explanation of what the desired behavior is.

[15:17:18.0359] <Bradford Smith>
and why it's hard with current language constructs to get that behavior

[15:17:58.0383] <sarahghp>
> <@rbuckton:matrix.org> For example:
> ```
> const Color = { Red: 0, Green: 1, Blue: 2 };
> const data = { color: Color.Red };
> fs.writeFileSync("foo.json", JSON.stringify(data));
> ```
> Writes `{color:0}`, which isn't helpful when maintaining config files, while:
> ```
> const Color = { Red: Symbol(), Green: Symbol(), Blue: Symbol() };
> ...
> ```
> Would be safer at runtime, but would fail to stringify.

How is this not solved by `const Color = { Red: 'red' , ..}`

[15:23:21.0972] <Jack Works>
üòÇ I didn't do a good preparation cause I didn't figured out how to express those ideas in my brain. with suggestions and feedbacks from the chat I think it can be better next time.

and as I said in the presentation, I'm not push the proposal forward until it has a complete design and proven to has benefit to add it.

I agree that frozen object (or TypeScript/flow.js enum) is enough today (mostly?) so my main focus point is on the ADT enum.

[15:31:24.0042] <Rob Palmer>
Jack Works: I'm really pleased you gave this presentation.  It seems like there were plenty of people interested in this space.  So hopefully they can help you to work more on the use-cases and problem definition.  (And I am biased because I love enums)

[15:33:15.0407] <Jack Works>
Thanks üôè

[15:35:49.0303] <gkz>
Jack Works: I would happy to be involved with this proposal if it's something that's going to be moving forward. We had a lot of discussion with both library authors and end users, and examined many use-cases, in preparation for the design of Flow Enums, and then listened and iterated based off of feedback. But again for us a large amount of the value derived is from when enums are used with the type system. 
We have also begun research on an ADT extension to Flow Enums, and have analyzed use-cases and so on. 

[15:39:19.0889] <rbuckton>
> <@sarahghp:matrix.org> How is this not solved by `const Color = { Red: 'red' , ..}`

When I initially started talking about an enum proposal several years ago, a number of current committee members were strongly in favor of symbol-valued enum members for better runtime safety. Yes, you could do `{ Red: 'red', ... }`, but you lose out on that safety.

[15:43:01.0555] <Rob Palmer>
Authenticity of enum values (provided by Symbols) is something folk won't reach for unless it has sweet syntax.  And I'd argue it's what you normally want for robustness reasons - no typos.

[15:44:23.0040] <shu>
enums-as-constants is a different problem than ADT enums

[15:44:42.0182] <shu>
until they're separated or more clearly articulated to need to be solved together i'm uncomfortable with the proposal

[15:44:42.0983] <bakkot>
symbols also can't be serialized, so I don't think that helps the "would fail to stringify" case?

[15:45:09.0147] <shu>
even thuogh Jack Works says ADTs are deferred as a follow on it keeps coming up in the discussion so i'm not sure who's interested in solving what

[15:48:09.0067] <Jack Works>
I know rbuckton is interested

[15:50:16.0229] <Jack Works>
Ah I should go sleep first, I'm not clear headed now

[15:59:45.0087] <rbuckton>
shu: Every time I've brought up enums in discussion with other members of plenary or folks in the TS/JS community, ADTs are invariably mentioned as a feature someone would like to see adopted. The use cases frequently overlap, and a number of languages support enums that can be used both for ADT and non-ADT scenarios.


2022-01-26
[16:00:54.0073] <rbuckton>
enums-as-constants isn't orthogonal to ADT enums.

[16:02:19.0976] <Jack Works>
https://matrix.to/#/!vofPwuBJgbSdyEilYo:matrix.org?via=matrix.org
Welcome to join the chat if you have interest in working on this together. ‚≠ê

This is NOT a tc39 group cause it didn't reach stage 1, it's a public group but not following the ECMA policy (logged and published). I'll create an official group like pattern matching and pipeline after it reaches stage 1.

[16:04:41.0893] <yulia>
we can probably make it an official group if the chairs choose so

[16:05:07.0117] <yulia>
 * we can probably make it an official group if the chairs decide that

[16:07:51.0168] <Michael Ficarra>
rbuckton: I agree, but I also think it wouldn't do any harm to pursue it in two phases

[16:08:36.0367] <rbuckton>
> <@michaelficarra:matrix.org> rbuckton: I agree, but I also think it wouldn't do any harm to pursue it in two phases

Even if we pursue it in two phases, we need to consider how ADT enums need to function to ensure we don't paint ourselves into a corner with non-ADT enums.

[16:08:58.0605] <Michael Ficarra>
I think we have the ability to do that though

[16:09:04.0781] <leobalter>
Rob Palmer, yulia my coworker Jenna couldn't access the Reflector today to get the meeting info. Can you confirm her github user is ok? https://github.com/tc39/Admin-and-Business/issues/174

[16:10:08.0157] <ljharb>
leobalter: i just invited them; invites expire in 7 days so perhaps they didn't accept in time the first go

[16:10:16.0383] <rbuckton>
Which means we need to do most, if not all, of the work we would need to do for ADT enums to ensure we have consistency across multiple other language features such as pattern matching.

[16:10:41.0192] <leobalter>
Thanks, ljharb! 

[16:14:59.0610] <shu>
rbuckton: i'd like a tighter story than that, because the implementation complexity and the design space of the primitive enums vs ADTs are miles apart

[16:29:24.0062] <jschoi>
> <@jridgewell:matrix.org> I do recursion all the time.

To give a concrete example of this for Jordan, I invariably use recursion when I write parsers. Recursive descent parsers are my favorite type.

[16:29:41.0483] <jschoi>
With or without PTC‚Ä¶

[16:36:29.0949] <rbuckton>
I'm primarily interested in ADT enums for how they could possibly be optimized by engines in ways that regular objects can't (hence my comments about megamorphism earlier). Switching on `node.kind` in the TS compiler is often a performance cliff due to megamorphism, even if every object/shape seen by a function has a `.kind`. If V8 were able to optimize this case for regular objects, I'd be ecstatic. If not, and V8 instead was able to optimize for ADT enums in a similar fashion, I would happily rewrite the entire TypeScript compiler to use an ADT for `Node` instead of regular objects/constructors even if that meant a complete breaking API change for consumers. If there are no performance optimizations that V8 could offer for either case, then ADT enums are at least interesting to me as a data structure but not a necessity.

[16:39:07.0313] <rbuckton>
There's a convenience factor for ADT enums coupled with something like Scala's "Extractor Objects" and pattern matching that is extremely interesting to me, but that's nowhere near as compelling to me as possible performance benefits.

[16:40:45.0527] <Rob Palmer>
rbuckton: a dirty hack proposal... if the `.kind` property is special and you want to avoid the megamorphic de-opt, couldn't you rename it to be index zero?  `node[0]`

[16:43:25.0040] <rbuckton>
Does that work? I'd happily turn `kind` into a getter that just reads `this[0]` (for API compatibility) and replace all `node.kind` references in the compiler if that would actually improve performance.

[16:44:55.0120] <Rob Palmer>
I'm not 100% sure but seem to recall the V8 object layout for elements permits direct lookups not based on the map type.  If only we had someone who knew V8 here...

[16:48:54.0546] <shu>
by my reading keyed loads like [0] also checks receiver maps

[16:51:03.0717] <rickbutton>
I wonder how off the ‚Äú# of kinds of nodes in ts‚Äù is from the upper limit in v8 for optimization 

[16:51:33.0466] <bakkot>
alternatively just rewrite it in go

[16:51:58.0416] <bakkot>
(this is a reference to https://kdy1.dev/posts/2022/1/tsc-go, not a serious proposal)

[16:52:28.0116] <shu>
i think if you want speed what you want is C

[16:52:44.0714] <bakkot>
you never want c under any circumstances whatsoever

[16:53:03.0340] <bakkot>
except writing aviation code with the very constrained dialect they use plus all of their static analysis tools I suppose

[16:53:18.0644] <bakkot>
and even then it's less "want" than "have no legal alternative"

[16:54:18.0600] <shu>
it is when we are constrained by the law that we are at our most creative

[16:54:35.0032] <bakkot>
doubt

[17:23:25.0342] <Rob Palmer>
rbuckton: shu this microbenchmark suggests megamorphic access to index properties is 3x faster than the same for string properties https://esbench.com/bench/61f099d96c89f600a570158a

[17:28:15.0875] <Rob Palmer>
oh wow - Axel Rauschmeyer has taken Dean Tribble's Proxy trick and blogged about it within 90mins of learning it...  https://2ality.com/2022/01/symbol-factory.html

[17:28:20.0947] <rbuckton>
We tried to improve perf by ensuring that frequently-used fields like `kind`, `pos`, `end`, and `flags` are all stored in-object:
```
000003E4E0E47A91: [Map]
 - type: JS_OBJECT_TYPE
 - instance size: 160
 - inobject properties: 17
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 7
 - enum length: invalid
 - stable_map
 - back pointer: 0x03e4e0e47a49 <Map(HOLEY_ELEMENTS)>
 - prototype_validity cell: 0x034eb1241659 <Cell value= 1>
 - instance descriptors (own) #11: 0x012f0b6cfb21 <DescriptorArray[11]>
 - prototype: 0x012f0b6cf441 <Object map = 000003E4E0E47779>
 - constructor: 0x013a75523b41 <JSFunction Node (sfi = 00000353F65D5C41)>
 - dependent code: 0x020140ac1281 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
 - construction counter: 6

  [0]: 00000378FA033E49: [String] in OldSpace: #pos (const data field 0:s, p: 7, attrs: [WEC]) @ Any
  [1]: 0000009B539BD2B9: [String] in OldSpace: #end (const data field 1:s, p: 1, attrs: [WEC]) @ Any
  [2]: 0000028DD0EF42B9: [String] in OldSpace: #kind (const data field 2:s, p: 3, attrs: [WEC]) @ Any
  [3]: 0000007EABDD4071: [String] in OldSpace: #id (const data field 3:s, p: 9, attrs: [WEC]) @ Any
  [4]: 0000020140AC45D1: [String] in ReadOnlySpace: #flags (const data field 4:s, p: 8, attrs: [WEC]) @ Any
  [5]: 0000036E885DE309: [String] in OldSpace: #modifierFlagsCache (const data field 5:s, p: 10, attrs: [WEC]) @ Any
  [6]: 000001B37FD2DA09: [String] in OldSpace: #transformFlags (const data field 6:s, p: 0, attrs: [WEC]) @ Any
  [7]: 0000007EABDC4B09: [String] in OldSpace: #parent (const data field 7:h, p: 6, attrs: [WEC]) @ Any
  [8]: 00000378FA0349F1: [String] in OldSpace: #original (const data field 8:h, p: 5, attrs: [WEC]) @ Any
  [9]: 000001B37FD2D511: [String] in OldSpace: #decorators (const data field 9:h, p: 4, attrs: [WEC]) @ Any
  [10]: 000001B37FD24099: [String] in OldSpace: #modifiers (const data field 10:h, p: 2, attrs: [WEC]) @ Any
```

[17:36:01.0747] <shu>
that should save you a load, yeah

[17:58:38.0099] <Michael Ficarra>
there's a spam comment on an ecma262 PR, what should I do?

[17:58:49.0574] <Justin Ridgewell>
You should take a look at closure compilers AST layout

[17:59:18.0172] <Justin Ridgewell>
Everything is firstchild lastchild nextchild

[17:59:41.0215] <Justin Ridgewell>
Can‚Äôt have megamorphic access if everything has the exact same properties

[18:18:48.0899] <Mathieu Hofman>
jschoi: I double checked `Array.fromAsync`, and since the content of the `[[Iterator]]` slot is never revealed to user code, the async iterator wrapper prototype is still spec internal only. It sure would be nice to have a way to explicitly note this, so that these internal only things don't get surprisingly exposed without anyone noticing in the future!

[18:46:42.0441] <Richard Gibson>
Mathieu Hofman: do you mean like the note at https://tc39.es/ecma262/#sec-createlistiteratorRecord ?

[19:08:28.0895] <Mathieu Hofman>
I suppose, but these things can be lost transitively. First, the `CreateAsyncFromSyncIterator` doesn't have this annotation. Second, really it seems that `GetIterator` creates a record for an iterator (possibly coming from user code, possibly internally built through `CreateAsyncFromSyncIterator`), but while that record transits through a lot of place, the iterator it contains is seemingly never exposed to user code. It's a weird invariant that is not well understood

[19:08:42.0191] <Mathieu Hofman>
 * I suppose, but these things can be lost transitively. First, the `CreateAsyncFromSyncIterator` doesn't have this annotation. Second, really it seems that `GetIterator` creates a record for an iterator (possibly coming from user code, possibly internally built through `CreateAsyncFromSyncIterator`), but while that record transits through a lot of place, the iterator it contains is seemingly never exposed to user code. It's a weird invariant that is not well understood

[22:06:48.0377] <Ashley Claymore>
> <@jridgewell:matrix.org> Can‚Äôt have megamorphic access if everything has the exact same properties

I though location of the initial object creation matters too; for some engines where the hidden-class graph is a forest and not a tree

[06:18:11.0121] <Jack Works>
> <@jridgewell:matrix.org> Can anyone give a demonstration of ADT without using pattern matching?

that's depends on the semantics of ADT enum but it doesn't have a runtime semantics specified yet so I cannot give an example sorry

[08:57:49.0129] <ljharb>
jschoi: fair, but i hope you're not suggesting that writing a parser is anywhere remotely near a common use case

[09:02:27.0098] <Michael Ficarra>
ljharb: parsers are everywhere

[09:02:49.0643] <Michael Ficarra>
people are writing parsers all the time, whether they know it or not

[09:03:04.0535] <Michael Ficarra>
most are simple and can be expressed as a regexp or a series of regexps

[09:03:12.0136] <ljharb>
that sounds like either a really bold claim, or one so broad as to dissolve the context

[09:03:30.0772] <ljharb>
"writing a parser where recursion makes sense" is not a common use case.

[09:03:36.0144] <Michael Ficarra>
parsing is turning something less-structured into something more-structured

[09:03:46.0898] <ljharb>
 * "writing a parser where recursion makes sense" is not a common use case.

[09:04:17.0599] <jschoi>
Yeah. It doesn‚Äôt even have to be on text input but any sequence of values. 

[09:04:17.0740] <ljharb>
so parsing is anything that fights the entropy of the universe, gotcha

[09:04:32.0665] <jschoi>
* Yeah. It doesn‚Äôt even have to be on text input but any sequence of values. 

[09:04:38.0679] <ljharb>
when i grow hair, i'm parsing?

[09:05:06.0376] <ljharb>
in the context we're discussing things, "writing a parser" such that you'd reach for recursion is simply not a common use case

[09:05:18.0299] <jschoi>
JSON validation is parsing, for example.

[09:05:28.0503] <ljharb>
i don't need recursion for that tho.

[09:06:10.0449] <jschoi>
Hm, is recursion not required to validate many JSON structures? After all, many JSON schemata are recursive.

[09:06:42.0961] <ljharb>
i'm sure a JSONSchema validator may be recursive, sure. but most people don't write those, they just consume them

[09:07:13.0604] <ljharb>
i'm not trying to claim that parsers don't affect a lot of devs. i'm saying that most devs don't author them.

[09:07:52.0057] <ljharb>
in the same way as "get intrinsics" affects a lot of devs, but most devs don't need to do that directly. and both are relevant when weighing the importance of including syntactic affordances in the language (which is why i'm not trying to pursue syntax for getting intrinsics - because it's *not common*)

[09:08:08.0686] <ljharb>
 * in the same way as "get intrinsics" affects a lot of devs, but most devs don't need to do that directly. and both are relevant when weighing the importance of including syntactic affordances in the language (which is why i'm not trying to pursue syntax for getting intrinsics - because it's *not common*)

[09:08:30.0273] <jschoi>
Yeah, it may be that because I‚Äôm familiar with them, I reach for them more readily than most developers.

[09:08:39.0839] <jschoi>
But I do know I write a lot of ad-hoc parsers to validate stuff.

[09:08:53.0822] <jschoi>
Just the other day, I had to write an ad-hoc parser for some custom-formatted text file‚Äôs lines‚Ä¶and, before that, the Unicode Character Database‚Äôs source text files (though recursion wasn‚Äôt necessary for the latter).

[09:08:59.0370] <Jack Works>
As I can recall from some of my friends, "it's very hard to find some candidates that understand what is recursion" 

[09:09:15.0032] <jschoi>
* Just the other day, I had to write an ad-hoc parser for some custom-formatted text file‚Äôs lines‚Ä¶and, before that, the Unicode Character Database‚Äôs source text files.

[09:09:39.0137] <jschoi>
* Just the other day, I had to write an ad-hoc parser for some custom-formatted text file‚Äôs lines‚Ä¶and, before that, the Unicode Character Database‚Äôs source text files (though recursion wasn‚Äôt necessary for the latter).

[09:10:25.0511] <jschoi>
* But I do know I write a lot of ad-hoc parsers to validate stuff‚Äîboth textual and non-textual.

[09:10:47.0343] <jschoi>
* Just the other day, I had to write an ad-hoc parser for some custom-formatted text file‚Äôs lines, as well as some JSON input from a hospital‚Äôs record system‚Ä¶and, before that, the Unicode Character Database‚Äôs source text files (though recursion wasn‚Äôt necessary for the latter).

[09:10:57.0524] <jschoi>
* Just the other day, I had to write an ad-hoc parser for some custom-formatted text file‚Äôs lines, as well as some JSON input from a hospital‚Äôs record system‚Ä¶and, before that, the Unicode Character Database‚Äôs source text files (though recursion wasn‚Äôt necessary for the last one).

[09:12:02.0879] <jschoi>
* Just the other day, I had to write an ad-hoc parser for some custom-formatted text file‚Äôs lines, as well as some JSON input from a hospital‚Äôs record system‚Ä¶and, before that, the Unicode Character Database‚Äôs source text files (though recursion wasn‚Äôt necessary for the last one).

Regexes are super common, but I often need more power than regular expressions‚Ä¶and I often need to apply them to non-textual input.

[09:12:21.0722] <jschoi>
* Just the other day, I had to write an ad-hoc parser for some custom-formatted text file‚Äôs lines, as well as some JSON data from a hospital‚Äôs record system containing entities within entities‚Ä¶and, before that, the Unicode Character Database‚Äôs source text files (though recursion wasn‚Äôt necessary for the last one).

Regexes are super common, but I often need more power than regular expressions‚Ä¶and I often need to apply them to non-textual input.

[09:12:41.0006] <ljharb>
i have the opposite experience - i have interviewed _thousands_ of candidates over the years who are incapable of NOT using recursion, since they were indoctrinated with it in university. our hiring panels always reject those, because recursion is often the wrong tool for the job, at least in frontend.

[09:13:21.0295] <ljharb>
at any rate, i'm not trying to debate the value of use cases/parsers or techniques/recursion, just that i strongly believe it's an uncommon combination.

[09:15:42.0099] <Jack Works>
Yeah. I agree (I think get intrinsics are useful for a very limited set of people including me, but doubt if it worth an API)

[09:16:29.0429] <ljharb>
to be clear, i think getting intrinsics is worth an API (hence the proposal), but decidedly not worth syntax.

[09:16:37.0380] <ljharb>
 * to be clear, i think getting intrinsics is worth an API (hence the proposal), but decidedly not worth syntax.

[09:17:24.0010] <ljharb>
the context from before was about functions having an immutable binding for their own name but lacking a `function.self` metakeyword, or similar - as compared to `class.self` or similar, where i think the use case is much more common.

[09:17:51.0917] <ljharb>
(i'd be _fine_ with `function.self` and `class.self` both, ofc, but i think the former would be much more rarely used)

[09:19:29.0913] <Jack Works>
Hmm. Inside a named function, is the name mutable? 

[09:30:18.0950] <Michael Ficarra>
Jack Works: If you scroll up, we discussed that. Apparently it is immutable but does not error if you try to assign to it. The assignment just does nothing.

[09:31:09.0835] <ljharb>
even in strict mode? (edit: checked, and yes, even in strict mode; that is super weird)

[09:33:31.0457] <ljharb>
 * even in strict mode? (edit: checked, and yes, even in strict mode; that is super weird)

[09:34:24.0581] <shu>
it is an ur-const

[09:36:05.0730] <Michael Ficarra>
all these years, I just thought it was mutable

[09:43:19.0520] <Rob Palmer>
"ur-const"?

[09:43:33.0212] <bakkot>
this behavior predates `const`

[09:43:49.0810] <bakkot>
it used to be the only immutable binding, so it wasn't inconsistent that it didn't throw

[09:44:00.0142] <Michael Ficarra>
Rob Palmer: https://www.oxfordlearnersdictionaries.com/us/definition/english/ur

[09:44:14.0176] <Rob Palmer>
i would have named it "pre-const"

[09:45:04.0786] <ryzokuken>
pre-const somehow sounds like something which _isn't_ const but predates const for some reason

[09:54:55.0061] <ljharb>
i'm surprised that when adding strict mode, it was missed

[09:57:45.0232] <ljharb>
erights: was that omission intentional?

[09:59:02.0939] <Rob Palmer>
We start plenary in 1 minute!

[10:09:08.0395] <shu>
jitsi always messes with my audio for some reason

[10:09:26.0574] <shu>
yesterday it wouldn't detect my headphones until i open preferences, but it goes away after i close preferences

[10:09:35.0282] <shu>
today, everytime i join, it moves the balance all the way to the left

[10:09:35.0807] <shu>
wtf

[10:12:03.0871] <bakkot>
if it's the system audio balance, that's a Mac OS bug that triggers when the CPU is pegged sometimes

[10:12:15.0475] <bakkot>
it's crazy and it has been known about for like a year now

[10:12:25.0225] <shu>
that is wild, how does that bug arise

[10:14:37.0074] <Mathieu Hofman>
mac os audio subsystem is extremely buggy. Afaik, chrome had to move to a restart-able audio process to deal with macos issues. Zoom used to just ask for admin rights to be able to kill the system audio when issues were detected.

[10:16:48.0679] <yulia>
this is very cool

[10:16:56.0467] <Ben Newman (Apollo, @benjamn on GH)>
no kidding

[10:20:05.0056] <leobalter>
the idea one can generate test for test262 (ish) but also customize outputs

[10:22:54.0664] <yulia>
ok, stuff like this would be _amazing_ to record

[10:23:55.0432] <yulia>
 * ok, stuff like this would be _amazing_ to record

[10:25:15.0757] <bakkot>
i am reminded of Futamura projections

[10:25:31.0410] <yulia>
wow

[10:25:33.0799] <shu>
which_one_meme.jpg

[10:28:52.0303] <rickbutton>
wut

[10:31:20.0832] <rickbutton>
WHAT

[10:31:23.0445] <rickbutton>
this is dope

[10:32:18.0250] <rkirsling>
very

[10:32:40.0994] <Michael Ficarra>
this is why I wanted them to share it with committee üôÇ

[10:32:48.0712] <Michael Ficarra>
I think a lot of you will find this useful

[10:32:53.0087] <ryzokuken>
is the ECMA-402 spec too loose to try this? Let's get this working on 402 too!

[10:33:28.0683] <Michael Ficarra>
they will probably have to do a decent amount more work to make it work with ECMA-402

[10:33:42.0890] <ryzokuken>
understandable ‚òπÔ∏è

[10:33:49.0812] <ryzokuken>
but we could help!

[10:33:58.0447] <Michael Ficarra>
remember, their contribution involved encoding the semantics of the phrasing we use in 262

[10:34:08.0348] <Michael Ficarra>
reducing the variety of that phrasing will simplify things

[10:34:18.0194] <Michael Ficarra>
ecma-402 unfortunately has a greater variety

[10:34:20.0623] <ryzokuken>
yeah, that's what I was afraid of

[10:34:39.0322] <ryzokuken>
absolutely. That plus the fact that large parts of it are impl-defined (relatively anyway) I suppose...

[10:34:50.0438] <Michael Ficarra>
ryzokuken: it's all open source, so you actually can make it work

[10:34:52.0044] <ryzokuken>
 * absolutely. That plus the fact that large parts of it are impl-defined (relatively anyway) I suppose...

[10:35:02.0399] <Michael Ficarra>
seems simple enough to add support for new phrases

[10:35:25.0339] <ryzokuken>
cool, I'll try to get it to work üòÄ 

[10:35:26.0486] <Michael Ficarra>
but I'd prefer just reducing the variety of your phrasing in 402 anyway

[10:35:50.0388] <ryzokuken>
that's not a bad idea either, did you have an issue or sth to track this in 262?

[10:36:28.0653] <Michael Ficarra>
nah, we've just been doing them one by one as we notice them

[10:37:51.0550] <ryzokuken>
fair, I'll kickstart something on #tc39-ecma402:matrix.org 

[10:39:22.0995] <bakkot>
shared array buffers are going to be hard to formalize by anything similar to the way the rest of the language is formalized

[10:39:33.0335] <yulia>
omgm

[10:39:35.0405] <bakkot>
though conrad watt has a formalization somewhere I think

[10:39:50.0086] <shu>
depends on what the goal of mechanizing the memory model would be

[10:39:52.0546] <yulia>
loving this

[10:40:02.0228] <shu>
it's possible to "support" the memory model by just treating them as non-shared

[10:40:12.0732] <shu>
like, an SC execution is never wrong

[10:40:14.0650] <bakkot>
shu: i mean mostly that the memory model is not written in the same kind of way as the rest of the spec

[10:40:31.0855] <shu>
right, mechanizing that into something operational is original research

[10:40:34.0904] <shu>
and is unsolved last i checked

[10:40:54.0072] <shu>
but i'm saying they could just ignore it

[10:41:28.0503] <Michael Ficarra>
PEGs use ordered choice

[10:41:40.0336] <Michael Ficarra>
so it probably just adopts the order we wrote it in

[10:43:41.0328] <Rick Waldron>
shu: I'm about to enter a 3 hour block of meetings, which ends with me leaving to pick up my daughter at school (I'm EST). Since there are no slides, or other information attached to "Let's talk about test262 maintenance and contribution", I'm not sure what else you want to discuss beyond the creation of the maintainers group. I'm concerned that I'm now going to miss this topic due to obligations on my end. What can we do about that? Can we defer it to tomorrow?

[10:44:23.0690] <shu>
i would prefer no deferral if there are no other agenda items for Thursday

[10:45:02.0407] <Michael Ficarra>
ptomato: if you integrated your proposal, as you would in a PR, I don't see why it wouldn't work

[10:45:03.0068] <shu>
i want to discuss the role of the maintainer group, the workflow, expectations from proposal authors, and stage requirements

[10:46:11.0486] <shu>
Rick Waldron: is there someone else you trust to present your viewpoint? are there also specific topics you want to raise?

[10:46:29.0599] <Rob Palmer>
we could bring forward JS Choi's item next, and then do test262 last today - does that help Rick? 

[10:47:02.0645] <shu>
yeah, a schedule reshuffle if possible would be ideal, i guess

[10:47:26.0747] <Rick Waldron>
Rob Palmer: I think the end of the day for the meeting is when I'm feeding my daughter dinner

[10:48:07.0364] <Rob Palmer>
end of the meeting is 14:00-15:00 PST after your 3 hours of meetings

[10:48:38.0048] <Rick Waldron>
My meetings end at 5, and then I have to leave to pick my child up from school. 

[10:50:14.0020] <Rob Palmer>
ok so that won't work then

[10:51:47.0633] <Rick Waldron>
I'm trying to figure out how long the 4pm thing will be

[10:57:03.0170] <Michael Ficarra>
Ben Newman (Apollo, @benjamn on GH): that was one of the questions the editors asked in our first call with them

[10:57:20.0284] <Ben Newman (Apollo, @benjamn on GH)>
cool, I guess it's a natural one!

[10:57:32.0505] <bakkot>
editors are planning on fixing up regex chapter at some point

[10:57:34.0921] <Michael Ficarra>
we'll try to make more progress on it following initial integration after we finish up this completion record reform work

[10:57:38.0483] <bakkot>
it's already gotten a lot better thanks to jmdyck 

[10:59:45.0669] <bakkot>
learning that the regex chapter used to be lisp definitely explains some things

[11:00:55.0163] <Michael Ficarra>
yep, the "ordered pairs" probably came from there

[11:01:09.0764] <Michael Ficarra>
why port it so literally? lol

[11:01:38.0788] <Michael Ficarra>
I guess we didn't have the same ambitions of running analysers on the spec back then

[11:03:00.0624] <Rick Waldron>
Rob Palmer: shu My 4pm meeting was canceled. So 1pm PST?

[11:03:13.0441] <shu>
sure, i'm flexible for whatever time that works for rick

[11:03:19.0191] <shu>
(though still prefer today, not tomorrow)

[11:03:30.0348] <Rob Palmer>
ok

[11:03:41.0039] <Rob Palmer>
let's see if JS Choi can go next

[11:04:26.0660] <Rob Palmer>
jschoi: can you go next after this?

[11:06:27.0118] <Michael Ficarra>
WH is right, the papers are actually pretty easy to follow

[11:06:43.0411] <Michael Ficarra>
and they're very nicely split up

[11:07:00.0056] <bakkot>
I do think we should have a central place for this though

[11:07:13.0938] <bakkot>
there's a lot of research, not all of it in academia, and it would be good to have it more discoverable

[11:07:44.0835] <bakkot>
e.g. jmdyck's ecmaspeak and WH's link from earlier are both relevant and do not have papers

[11:11:37.0604] <Michael Ficarra>
I support saving the final 10 minutes for after lunch

[11:12:25.0147] <shu>
there's some kind of sync issue

[11:12:54.0938] <ljharb>
https://jschoi.org/21/es-dataflow/

[11:13:05.0707] <rkirsling>
dang this page is pretty

[11:13:32.0068] <ljharb>
https://jschoi.org/21/es-dataflow/map/

[11:14:35.0968] <Michael Ficarra>
is there like an extreme audio delay or something?

[11:15:00.0578] <ljharb>
there seems to be, yes

[11:15:28.0080] <rkirsling>
it's certainly robot-ing here and there

[11:15:34.0138] <leobalter>
Now I can hear JS-Choi better

[11:15:55.0513] <Rob Palmer>
i think js choi's connection is having issues.

[11:16:10.0552] <leobalter>
yes

[11:16:58.0778] <waldemar>
It would be great if we could read the presentations ahead of the meeting. I'd have appreciated some time to study the map of ES dataflow proposals ahead of time instead of in real-time at the meeting.

[11:16:58.0866] <Rob Palmer>
but it seems to be workable now - i suspect it is js choi's upload quality/bandwith

[11:17:58.0732] <Rob Palmer>
waldemar: the material was published ahead of time https://github.com/tc39/agendas/pull/1106

[11:18:01.0192] <Justin Ridgewell>
They stopped presenting, so the audio got better.

[11:18:48.0424] <TabAtkins>
Yeah, the whole point of assembling the agendas is precisely to allow you to review things ahead of time if you wish, and this in particular was put on the agenda about two weeks ago.

[11:22:02.0236] <waldemar>
The title was on the agenda, but there were no links to anything on the agenda.

[11:22:35.0385] <ljharb>
waldemar: that PR contains three links

[11:22:39.0554] <TabAtkins>
Yes there was - the PR shows that all the linkes were there.

[11:23:34.0555] <waldemar>
Sorry; my bad.

[11:23:49.0937] <waldemar>
I was looking at the wrong item.

[11:26:54.0321] <Mathieu Hofman>
> <@bakkot:matrix.org> you can assign to it but it's immutable

> the lambda scope is not mutable

I'm not following, do you have an example?

[11:27:22.0221] <Mathieu Hofman>
(sorry catching up on some previous discussions)

[11:32:45.0410] <bakkot>
Mathieu Hofman: `(function f(){ f = 0; console.log(f); })();`

[11:33:01.0146] <bakkot>
the assignment doesn't throw, but also doesn't change `f`

[11:33:20.0954] <bakkot>
 * the assignment doesn't throw, but also doesn't change `f`

[11:36:04.0161] <Mathieu Hofman>
It does in strict mode, doesn't it?
`(function(){"use strict"; let foo = (function f() { f = 'foo'; }); foo(); return foo;})()`
`Uncaught TypeError: Assignment to constant variable.`

[11:36:24.0955] <bakkot>
yeah

[11:37:28.0703] <Mathieu Hofman>
it's like assignment to a readonly property in sloppy, it silently ignore it. But strict mode fixes it.

[11:37:46.0185] <ljharb>
oh hmm. i'm not sure why my earlier strict mode tests didn't throw then

[11:38:32.0311] <Mathieu Hofman>
> <@ljharb:matrix.org> even in strict mode? (edit: checked, and yes, even in strict mode; that is super weird)

I was confused by ^

[11:38:46.0153] <ljharb>
my mistake then, sorry about that

[11:39:13.0413] <Mathieu Hofman>
Was trying to double check things before raising this with MM ;)

[11:42:17.0779] <shu>
i thought it also didn't throw in strict mode

[11:42:24.0392] <shu>
because it's always created with _S_ = false

[11:43:33.0593] <shu>
been a while though

[11:45:34.0716] <bakkot>
`S = true` means that assignments to it will throw even in sloppy mode

[11:45:55.0816] <shu>
ah ha, got it backwards

[11:48:43.0537] <shu>
let's get to the queue imo

[11:51:25.0743] <Justin Ridgewell>
Do we not have free overflow time later today?

[11:52:06.0604] <ljharb>
the hackmd says 15 minutes

[11:52:23.0644] <shu>
is 10 of that already filled up by this?

[11:52:28.0963] <Rob Palmer>
yes

[11:57:24.0253] <shu>
did i hear voting

[11:57:57.0206] <bakkot>
can we have the "what voting system" fight again

[11:58:09.0818] <bakkot>
my position is, we should list every subset of these proposals and then do approval voting for the subsets

[12:00:52.0480] <yulia>
damn it, i was getting so pumped for this

[12:01:13.0373] <sarahghp>
gotta stay pumped for 1h

[12:01:17.0976] <sarahghp>
come in kicking

[12:01:46.0939] <Justin Ridgewell>
Thank you for splitting the topic (if needed, please continue without me)

[12:01:57.0666] <Justin Ridgewell>
Have to give an interview...

[12:03:02.0283] <Rob Palmer>
We shall return at 13:00 PST for a 10 minute continuation of the current topic on JS Choi's dataflow discussion.  Please do not be late!

[13:01:52.0015] <ljharb>
it occurs to me throughout this agenda item, that it might be helpful to avoid using the word "this" to describe something that's not `this` :-)

[13:01:54.0626] <ljharb>
 * it might be helpful to avoid using the word "this" to describe something that's not `this` :-)

[13:02:09.0167] <ljharb>
 * it occurs to me throughout this agenda item, that it might be helpful to avoid using the word "this" to describe something that's not `this` :-)

[13:13:00.0343] <SoftwareChris>
> <@ljharb:matrix.org> it occurs to me throughout this agenda item, that it might be helpful to avoid using the word "this" to describe something that's not `this` :-)

_Non-Lexical use of `this` considered harmful_

[13:18:08.0718] <rkirsling>
yeah, I'm interested in this, but it's a bit hard to follow with nothing to look at

[13:18:22.0852] <ptomato>
shu: maybe it'd be good to structure the discussion by naming a topic that you'd like to start with?

[13:18:34.0567] <ptomato>
there are many topics that you touched on in your initial speech

[13:19:02.0716] <jschoi>
sarahghp: By the way, take a look at https://github.com/tabatkins/proposal-call-this-operator and let us know in the pipe room what you think. It‚Äôs another version of bind-this but which doesn‚Äôt overlap with the pipe operator.

[13:22:45.0488] <rkirsling>
anba is indeed the GOAT when it comes to really weird edge cases

[13:23:09.0276] <rkirsling>
 * anba is indeed the GOAT when it comes to really weird edge cases

