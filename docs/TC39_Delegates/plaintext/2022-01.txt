2022-01-05
[07:36:20.0739] <jschoi>
https://github.com/tc39/proposal-class-fields is still getting new comments despite it being Stage 4. It should get archived, right?

[07:43:41.0033] <Rob Palmer>
maybe ljharb (our Administrator-to-be) would like to handle that

[07:53:49.0672] <ljharb>
Yup, that is the first thing on my list


2022-01-06
[10:55:24.0433] <jschoi>
FYI, the State of JS people have reached out to TC39 at https://es.discourse.group/t/help-shape-the-contents-of-the-next-state-of-js-survey/1148 asking what sort of questions they should be asking for the upcoming community survey. This might be really useful.

[10:57:36.0268] <jschoi>
* FYI, the State of JS people have reached out to TC39 at https://es.discourse.group/t/help-shape-the-contents-of-the-next-state-of-js-survey/1148 asking what sort of questions they should be asking for the upcoming survey. This might be really useful.

[10:57:42.0056] <jschoi>
* FYI, the State of JS people have reached out to TC39 at https://es.discourse.group/t/help-shape-the-contents-of-the-next-state-of-js-survey/1148 asking what sort of questions they should be asking for the upcoming community survey. This might be really useful.

[10:58:18.0850] <jschoi>
Oh wait, I missed this already in the General chat, whoops.


2022-01-10
[22:54:10.0326] <ljharb>
i'd love a review here: https://github.com/tc39/notes/pull/176 if someone has a sec

[14:44:45.0192] <Michael Ficarra>
Aki bterlson Rob Palmer can one of you take a look at this invited expert issue? https://github.com/tc39/Admin-and-Business/issues/190

[14:45:29.0956] <Rob Palmer>
yep - I will get to it Michael - thank you for the reminder

[14:45:38.0394] <Michael Ficarra>
thanks so much Rob!


2022-01-15
[17:42:13.0315] <waldemar>
Only three proposals made today's deadline for possible advancement at this month's TC39 meeting. Looks like it's going to be a short meeting‚Ä¶

[09:17:48.0808] <ljharb>
i count 4 for advancement, but indeed there'll be a lot of time that could be filled with updates and discussions

[12:00:22.0129] <jschoi>
It might be worth offloading some of the chartered incubator topics into plenary, if there‚Äôs lots of room. https://github.com/tc39/incubator-agendas/issues/22


[12:00:22.0989] <jschoi>

https://github.com/tc39/process-document/pull/33 might also be worth discussing.


2022-01-18
[10:22:10.0438] <shu>
jschoi: agreed, i haven't had time to run any calls at all between last meeting and this one

[10:57:00.0403] <waldemar>
> <@ljharb:matrix.org> i count 4 for advancement, but indeed there'll be a lot of time that could be filled with updates and discussions

Ah, enum for stage 1 was in the "open-ended discussion category" instead of in the proposals.

[11:03:15.0680] <Justin Ridgewell>
I thought TC39 was this week‚Ä¶

[11:03:26.0610] <Justin Ridgewell>
Anyways, TCQ's SSL cert is expired.

[11:03:34.0367] <Justin Ridgewell>
We should fix that before plenary.

[11:03:41.0578] <Justin Ridgewell>
bterlson: ^

[12:52:00.0986] <Rob Palmer>
Bterlson is on it. 

[14:31:39.0444] <waldemar>
What is the "presentation from KAIST research group"? I'd like an idea of what we're planning on discussing for this item. It's hard to prepare or look at background materials without any idea what the topic is.

[14:45:22.0946] <Mathieu Hofman>
Here is a link to their publications: https://plrg.kaist.ac.kr/research/publications

Michael Ficarra might want to ask them if there is anything that might be relevant to look at before their presentation.

Also I believe they have an "as late as possible in the day" scheduling constraint. The 2-3 PM slot probably makes sense for them?

[15:01:18.0938] <bakkot>
waldemar: the most relevant papers are https://dl.acm.org/doi/10.1145/3324884.3416632 and https://ieeexplore.ieee.org/document/9402086


2022-01-19
[17:09:03.0610] <Michael Ficarra>
I've also asked them to post links to resources next to their agenda item once they are prepared

[17:14:25.0572] <Michael Ficarra>
from my invited expert proposal (https://github.com/tc39/Admin-and-Business/issues/187):

[17:14:34.0669] <Michael Ficarra>
> Reason for invitation: These researchers from KAIST presented their recently published works to the TC39 editor group. This work includes automatic generation of a reference implementation, automatic generation of a step-through debugger, and tools for helping editors to catch spec errors. We think this work would be useful to share more broadly with the rest of the committee in a plenary.

[14:07:28.0922] <bakkot>
jschoi: your agenda item for Array.fromAsync does not say it's going for stage 3

[14:07:45.0612] <bakkot>
so people might not be reviewing it in enough detail

[14:10:44.0277] <bakkot>
(the rules for advancement eligibility "Proposals looking to advance to stages 2, 3, or 4 must be added (**and noted as such**)" [emphasis added], so in principle someone can object to advancement on those grounds)

[14:15:27.0997] <bakkot>
also it's currently stage 2; the "stage" column is the stage it _is_, not going for

[14:34:47.0336] <ljharb>
oops

[14:36:16.0859] <ljharb>
i pushed up a change to that, under the assumption it's meant to be for stage 3. if that's not the intention, we can remove it; if someone missed it between the deadline and now due to the mislabeling, we can deal with that as part of the normal process in plenary

[14:36:59.0334] <Luca Casonato>
> <@bakkot:matrix.org> also it's currently stage 2; the "stage" column is the stage it _is_, not going for

Oh darn - I think enum and string split might be wrong too. Should both be 0 in that column then, right?

[14:37:22.0795] <ljharb>
yes, i'll fix those too

[14:37:36.0801] <Luca Casonato>
> <@ljharb:matrix.org> yes, i'll fix those too

thx :-)

[15:48:29.0268] <jschoi>
Yeah, my intent was to go for Stage¬†3. I marked it as such in the pull request but I forgot to add it to the table entry itself. My apologies. üôá


2022-01-24
[01:18:01.0927] <Jack Works>
üëÄ is there drafted agenda for this meeting so I can schedule my sleeping time? thanks!

[03:14:34.0838] <yulia>
jschoi: i have a dumb question, what if promise.all accepted async iterators and returned an array of values, instead of doing that in a separate API? re: https://github.com/tc39/proposal-array-from-async

[03:17:01.0295] <yulia>
 * jschoi: i have a dumb question, what if promise.all accepted async iterators (it already takes iterables), instead of doing that in a separate API? re: https://github.com/tc39/proposal-array-from-async

[05:28:57.0100] <Rob Palmer>
The draft schedule for today's meeting is now posted:  https://hackmd.io/s3ovtgLsTa-QAhFqYTl_YA

[05:29:06.0829] <Rob Palmer>
 * The draft schedule for today's meeting is now posted

[05:29:26.0725] <Rob Palmer>
 * The draft schedule for today's meeting is now posted: https://github.com/tc39/Reflector/issues/411

[05:31:48.0122] <Luca Casonato>
> <@robpalme:matrix.org> The draft schedule for today's meeting is now posted: https://github.com/tc39/Reflector/issues/411

Thanks! üôè

[07:59:53.0759] <jschoi>
> <@yulia:mozilla.org> jschoi: i have a dumb question, what if promise.all accepted async iterators (it already takes iterables), instead of doing that in a separate API? re: https://github.com/tc39/proposal-array-from-async

`Promise.all`‚Äôs current semantics involve parallel awaiting of input values. If some `input` yields `a, b, c`, then `Promise.all(input)` would first drain `input` into its three items `a, b, c`, and then it would simultaneously await `a, b, c`.

Parallel awaiting is impossible when getting values from async iterators; we must sequentially await the values. 

I think it would be quite confusing if `Promise.all` did parallel awaiting on sync inputs and sequential awaiting on async inputs. This is the similar to how it would be confusing if `for await` did parallel awaiting on sync inputs but sequential sequential awaiting on async inputs. Hopefully that makes sense.

[08:00:30.0717] <yulia>
I see, thanks!

[08:17:33.0102] <jschoi>
* > <@yulia:mozilla.org> jschoi: i have a dumb question, what if promise.all accepted async iterators (it already takes iterables), instead of doing that in a separate API? re: https://github.com/tc39/proposal-array-from-async

`Promise.all`‚Äôs current semantics involve parallel awaiting of input values. If some `input` yields `a, b, c`, then `Promise.all(input)` would first drain `input` into its three items `a, b, c`, and then it would simultaneously await `a, b, c`.

Parallel awaiting is impossible when getting values from async iterators; we must sequentially await for the values. 

I think it would be quite confusing if `Promise.all` did parallel awaiting on sync inputs and sequential awaiting on async inputs. This is the similar to how it would be confusing if `for await` did parallel awaiting on sync inputs but sequential sequential awaiting on async inputs. Hopefully that makes sense.

[09:48:09.0063] <Rob Palmer>
We will start the meeting in 12 minutes!

[10:24:27.0713] <leobalter>
I like the formal votes, but fine with it going without it.

I also have no opposition to ryzokuken being on both roles (402 Editor + TC39 Co-Chair).

[10:50:29.0004] <bakkot>
we could in theory make a bot to download issues but I don't wanna do it

[10:55:19.0300] <bterlson>
bakkot: is the ecmarkup change an API change or breaking in the sense that new things in the biblio will change where links go/what links/etc.?

[10:55:22.0470] <bterlson>
just curious

[10:56:29.0306] <ljharb>
Rick Waldron: can you confirm that https://github.com/tc39/proposal-modules-pragma should become an inactive proposal?

[10:57:41.0978] <Rick Waldron>
ljharb: That was true in 2017. I have no further information that changes that status 

[10:58:00.0772] <ljharb>
ok thanks, i'll update the repo and the proposals list to mark it as such. would you call it "rejected' or "withdrawn"?

[10:58:24.0198] <Rick Waldron>
ljharb: lemme check the notes, one sec. 

[10:59:57.0044] <rbuckton>
possible bot autocorrect needed: "x markup" -> "ecmarkup"

[10:59:58.0341] <bakkot>
bterlson: main change is that the biblio will not be built in, and you'll have to specify `--load-biblio=file/package` to get the biblio

[11:00:08.0548] <bakkot>
so it can be updated independently of ecmarkup

[11:00:28.0513] <bakkot>
(in particular the plan is to release a new biblio with every commit to the spec, or at least every one which affects the biblio)

[11:00:37.0210] <bakkot>
 * (in particularly the plan is to release a new biblio with every commit to the spec, or at least every one which affects the biblio)

[11:01:14.0011] <bakkot>
 * (in particular the plan is to release a new biblio with every commit to the spec, or at least every one which affects the biblio)

[11:01:35.0707] <Rick Waldron>
ljharb: I cannot find discussion of record, but I would not pursue it myself in 2022, or any year... I can't even remember why I thought it was an idea to explore at the time. 

[11:01:49.0425] <Michael Ficarra>
 thank you for the feedback on this topic, sffc :-)

[11:02:05.0559] <Rick Waldron>
> <@rwaldron:matrix.org> ljharb: I cannot find discussion of record, but I would not pursue it myself in 2022, or any year... I can't even remember why I thought it was an idea to explore at the time.

I may have been doing a favor for a community member 

[11:02:16.0837] <ljharb>
> <@rwaldron:matrix.org> ljharb: I cannot find discussion of record, but I would not pursue it myself in 2022, or any year... I can't even remember why I thought it was an idea to explore at the time.

as i recall, it was around the time of the fauxtrage about `.js` and ESM in node

[11:02:27.0483] <ljharb>
i'll mark it as just being "inactive"

[11:02:50.0867] <bterlson>
@bakkot sounds great, it's super annoying for non-262 uses to have the biblio there at all :-P

[11:03:05.0610] <Rick Waldron>
> <@ljharb:matrix.org> as i recall, it was around the time of the fauxtrage about `.js` and ESM in node

Which would TOTALLY support my suspicion that I was "proxy-championing" this

[11:03:14.0968] <yulia>
This is so amazing shu 

[11:03:23.0760] <sffc>
yulia Michael Ficarra Here is a discussion from October (https://github.com/tc39/ecma402/blob/master/meetings/notes-2021-10-07.md#normative-add-new-numbering-system-tnsa) and another from January (https://github.com/tc39/ecma402/blob/master/meetings/notes-2022-01-13.md#normative-add-new-numbering-system-tnsa)

[11:03:32.0345] <Rick Waldron>
That is something I would've done: tell a community member to write a solution and that I would present it in good faith. 

[11:03:36.0564] <shu>
thanks! kevin helped a lot too with the ecmarkup stuff needed

[11:04:14.0248] <Rick Waldron>
But it looks like they never really pushed forward on it, and since I was acting in a proxy role, I wouldn't have done any extra work beyond reporting to committee. 

[11:09:43.0381] <bakkot>
> <@bterlson:matrix.org> @bakkot sounds great, it's super annoying for non-262 uses to have the biblio there at all :-P

there's actually already a `--no-ecma-262-biblio` which tells it not to load it

[11:10:00.0862] <bakkot>
> <@bterlson:matrix.org> @bakkot sounds great, it's super annoying for non-262 uses to have the biblio there at all :-P

 * there's actually already a `--no-ecma-262-biblio` which tells it not to load the built-in one

[11:10:36.0748] <yulia>
sffc: per anba's comment here (https://github.com/tc39/ecma402/pull/614#issuecomment-938638422) i don't think we have any comments but i will clear it with our intl team

[11:13:29.0358] <waldemar>
How do you annotate that something doesn't call user code?

[11:15:11.0540] <bakkot>
waldemar: https://github.com/tc39/ecma262/pull/2548 describes guidance for spec authors, relevant part of which is

> False positives can be manually suppressed with `<emu-meta suppress-effects="user-code">suppressed</emu-meta>`.


[11:15:13.0208] <Michael Ficarra>
waldemar: if you need to do it manually, like this: https://github.com/tc39/ecma262/pull/2548/files#diff-181371b08d71216599b0acccbaabd03c306da6de142ea6275c2135810999805aR18446

[11:15:31.0905] <Michael Ficarra>
but mostly it's implied by `!`

[11:16:22.0246] <shu>
@waldemar: you can wrap the abstract operation / SDO call in `<emu-meta suppress-effects="user-code">AbstractOp()</emu-meta>`, but yeah as Michael Ficarra says `!` implies the suppression

[11:24:28.0695] <shu>
for spec authors, the tests in this file also serve as a good tutorial for how to annotate, but hopefully most spec authors require no additional work: https://github.com/tc39/ecmarkup/blob/main/test/baselines/sources/effect-user-code.html

[11:25:51.0989] <shu>
 * for spec authors, the tests in this file also serve as a good tutorial for how to annotate, but hopefully most spec drafts require no additional work: https://github.com/tc39/ecmarkup/blob/main/test/baselines/sources/effect-user-code.html

[11:39:53.0469] <yulia>
whatwg on polyfils: https://w3ctag.github.io/polyfills/

[11:41:28.0505] <Michael Ficarra>
> <@yulia:mozilla.org> whatwg on polyfils: https://w3ctag.github.io/polyfills/

that document is broken for me

[11:41:29.0544] <shu>
did my queue item get deleted?

[11:42:49.0510] <shu>
Rob Palmer: ^

[11:43:48.0653] <ryzokuken>
> <@michaelficarra:matrix.org> that document is broken for me

took a second for me

[11:44:09.0071] <ryzokuken>
perhaps the CSS load is non-blocking

[11:44:48.0894] <Rob Palmer>
sorry shu I did not see you on the queu

[11:45:10.0266] <Rob Palmer>
put yourself back on and i shall re-order - just tell me where it should go

[11:45:11.0512] <shu>
hm, pretty sure i added myself, guess i'll re-add myself to the end

[11:45:27.0001] <Rob Palmer>
i can move you up

[11:45:38.0124] <yulia>
in that doc they have 
```
* **polyfill**: Emulates a well established feature of the web platform
* **speculative polyfill** (aka 'ponyfill', 'prollyfill', 'nottifill'): Emulates a proposed feature of the web platform
* **library** (aka 'module'): Provides features or functionality not anticipated to be a web platform feature
```

[11:45:39.0977] <shu>
Rob Palmer: after J. S. Choi is done is good

[11:46:34.0026] <Rob Palmer>
actually you're already there!

[11:46:42.0628] <Rob Palmer>
just refresh - tcq bug :-(

[11:47:02.0162] <shu>
oh weird :(

[11:48:10.0060] <yulia>
jschoi:  i didn't have time to respond, but yes feature detection is a problem

[11:49:38.0506] <yulia>
though i wonder if it makes sense to include this in the document. Experiment should be treated as not in production code

[11:50:53.0645] <TabAtkins>
Here's the published version of the TAG finding, which is *not* broken: https://www.w3.org/2001/tag/doc/polyfills/

[11:51:19.0911] <TabAtkins>
Also note that this is *not* WHATWG, it's the W3C TAG.

[11:51:27.0885] <yulia>
I feel like this could be cited?

[11:51:31.0816] <yulia>
 * I feel like this could be cited?

[11:51:34.0838] <ptomato>
> <@tabatkins:matrix.org> Also note that this is *not* WHATWG, it's the W3C TAG.

oh, my bad

[11:51:35.0792] <Michael Ficarra>
I just don't think anything will tangibly change, whatever recommendation we make

[11:51:48.0350] <yulia>
clarity is helpful though

[11:53:39.0092] <Michael Ficarra>
I haven't had time to review the document we're being asked to voice our support for

[11:53:53.0307] <Michael Ficarra>
maybe we come back with a modified proposal that references the document next time?

[11:54:47.0322] <yulia>
Yeah, that makes sense

[11:55:24.0794] <ljharb>
for the specific wording, that's fine, but i still wanted to get consensus on the conceptual change, to avoid distractions in the PR.

[11:57:54.0007] <yulia>
we may need to change 3.5 of that document...

[11:58:46.0322] <ljharb>
3.5?

[11:59:02.0788] <yulia>
https://www.w3.org/2001/tag/doc/polyfills/#detect-and-defer-to-native-implementations

[11:59:35.0811] <Michael Ficarra>
yeah, that sounds like the opposite of what we would advise

[12:00:30.0963] <TabAtkins>
Note that that's explicitly guarded by "past the tipping point", aka things that are already well-decided and implemented in some browsers, and thus very unlikely to change.

[12:01:03.0705] <TabAtkins>
It explicitly warns against doing this before that point, and has examples of the "grab the native if it exists, otherwise use the polyfill" pattern as explicitly discouraged.

[12:02:33.0458] <yulia>
hmmm, maybe we can define tipping point clearly

[12:02:51.0674] <yulia>
but even then , it seems liable to being misinterpretted..

[12:03:27.0080] <Michael Ficarra>
ah, thanks TabAtkins I misread it

[12:24:23.0083] <yulia>
if we need clarifications we can post on the TAGs design issue tracker

[12:25:28.0640] <yulia>
 * I think tab is right, this aligns with our goals it looks like. if we need clarifications we can post on the TAGs design issue tracker

[12:55:04.0167] <yulia>
is ptomato ready to go?

[12:59:04.0913] <ptomato>
I am

[12:59:45.0510] <yulia>
great

[13:18:38.0480] <bakkot>
motion to close this discussion and move on, no one disagrees with the proposal afaict

[13:19:25.0573] <leobalter>
well, I appreciate everyone having clarity on the topics we discuss

[14:15:48.0577] <ljharb>
would this document basically be like a new TG?

[14:16:03.0461] <ljharb>
i can ask that on the queue if it wouldn't derail the ending of the item

[14:17:35.0055] <yulia>
is 404 a tg?

[14:17:38.0938] <yulia>
 * is 404 a tg?

[14:17:40.0456] <ljharb>
i think so

[14:17:48.0169] <ljharb>
actually i dunno, maybe not

[14:17:50.0269] <yulia>
we also have the spec suite as a document

[14:17:54.0864] <yulia>
i see this as closer to one of those

[14:18:01.0730] <ljharb>
since there's just tc39, 402, and security

[14:18:03.0194] <ljharb>
k

[14:18:17.0316] <yulia>
i still want it to be 405

[14:19:22.0568] <shu>
ljharb: i don't see it as a TG, no

[14:19:32.0345] <shu>
the IP-making body is still TG1

[14:19:39.0726] <shu>
it just goes into a separate document than ecma262

[14:20:09.0969] <ljharb>
cool

[14:20:27.0828] <shu>
i don't know how to legally set that up but i'm not too worried about it?

[14:21:21.0151] <ljharb>
can prolly just make a repo for it when we're at that stage, which i'm now empowered to do

[14:54:01.0905] <Bradford Smith>
When did the "structured clone" discussion start? I really thought it started before 2pm. Isn't the time box spent?

[14:55:53.0569] <bakkot>
Bradford Smith: meeting's over

[14:55:59.0121] <bakkot>
this is post-plenary me picking mark's brain

[14:56:29.0831] <Bradford Smith>
oh, thx

[15:49:06.0611] <bakkot>
ljharb: can you use your admin powers to drop a link to https://github.com/bakkot/proposal-duplicate-named-capturing-groups on https://github.com/tc39/proposal-regexp-named-groups/issues/44 ?

[15:50:41.0567] <bakkot>
also, new (small) regex proposal I intend to put together for next meeting: allow capture group names to be re-used (when in different `|` alternatives) rather than enforcing uniqueness in the full regex

https://github.com/bakkot/proposal-duplicate-named-capturing-groups


2022-01-25
[16:46:48.0084] <ljharb>
sure, i can unarchive it if you want to comment it yourself? just lmk

[16:47:25.0974] <ljharb>
> <@bakkot:matrix.org> ljharb: can you use your admin powers to drop a link to https://github.com/bakkot/proposal-duplicate-named-capturing-groups on https://github.com/tc39/proposal-regexp-named-groups/issues/44 ?

 * sure, i can unarchive it if you want to comment it yourself? just lmk

[16:47:50.0717] <ljharb>
also, what happened with the "set method argument internal slot" discussion? i had to drop off

[16:58:10.0293] <ljharb>
 * sure, i can unarchive it if you want to comment it yourself? just lmk, or if we can't coordinate, i can

[19:32:46.0276] <bakkot>
ljharb: if you want to unarchive tonight and ping me I'll link it, or you should feel free to do so on my behalf

[19:33:11.0253] <bakkot>
> <@ljharb:matrix.org> also, what happened with the "set method argument internal slot" discussion? i had to drop off

tl;dr was, for the argument to `Set.prototype.union`, MM does not like the idea of _only_ reaching in to the [[SetData]] internal slot, but would potentially be OK with reaching in to that slot if present and otherwise falling back to the publicly exposed methods (`has`, etc), even though this would technically be a violation of proxy transparency (because for most cases it would still Just Work)

[19:33:12.0903] <ljharb>
bakkot: done now, go nuts

[19:34:24.0206] <ljharb>
bakkot: but the receiver would still have slot access only, yes?

[19:34:32.0427] <bakkot>
yeah, receiver is fine

[19:34:37.0817] <bakkot>
that's already how it works

[19:34:46.0767] <ljharb>
awesome

[19:34:49.0100] <bakkot>
that is, it is already common to access the internal slot of the receiver

[19:34:55.0507] <ljharb>
(re-archived the repo, after your comment; lmk if you need anything else)

[19:35:03.0674] <bakkot>
nope, that was all, thanks

[19:35:17.0532] <bakkot>
though in both the argument case and the receiver case we need to figure out what affordances, if any, we're going to make for subclasses

[08:38:53.0172] <Jack Works>
hi I've read the meeting logs yesterday. I'm interested in reviewing structured clone algr. (cc syg )

[08:40:54.0146] <shu>
Jack Works: sure, will request your review when the draft is ready

[08:49:20.0372] <Jack Works>
üëÄ I set an alarm on 14:00 PST and not be able to present enum before 14:00 cause I'm sleeping.

[08:52:50.0339] <Rob Palmer>
Jack Works: we'll schedule you as late as possible today to help you sleep - so in between 14:00-15:00 PST

[09:57:01.0660] <Rob Palmer>
This is your 4 minute warning: Plenary starts soon

[10:02:18.0016] <ptomato>
I can't do notes right away, but I can in a bit

[10:03:15.0269] <Rob Palmer>
thanks ptomato 

[10:27:03.0089] <bakkot>
Mathieu Hofman: can you confirm the conclusion we have captured in the notes is correct

[10:27:10.0574] <bakkot>
I think so but best to confirm

[10:44:57.0848] <bakkot>
never GCing is always legal, so XS's implementation would still be conformant

[11:00:25.0095] <ljharb>
+1, that was a mistake

[11:00:47.0907] <ljharb>
(but i also think registered symbols themselves are a mistake)

[11:04:46.0899] <shu>
what was the original use case for them anyway

[11:05:01.0486] <bakkot>
for registered symbols?

[11:05:07.0532] <bakkot>
it lets you do the same thing as well-known symbols for libraries

[11:05:12.0515] <bakkot>
so a library can interop with itself across realms

[11:05:22.0245] <shu>
but... what realms

[11:05:24.0963] <shu>
we didn't have sync realms

[11:05:40.0866] <bakkot>
iframes

[11:05:48.0655] <bakkot>
we have always had iframes

[11:05:48.0791] <shu>
oh, i guess sync iframes

[11:05:54.0917] <bakkot>
but also, not necessarily across realms

[11:05:59.0345] <shu>
i have a hard time believing that was a use case tc39 cared about back then?

[11:05:59.0886] <bakkot>
just multiple version of the library within the same realm

[11:06:06.0082] <bakkot>
 * but also, not necessarily across realms

[11:06:09.0908] <yulia>
Ashley Claymore: can you share with me the test case you used to identify SM gc behavior?

[11:06:23.0620] <shu>
yes, right, coordination without having the library do the heavy lifting

[11:07:10.0666] <Ashley Claymore>
> <@yulia:mozilla.org> Ashley Claymore: can you share with me the test case you used to identify SM gc behavior?

will do :)

[11:07:26.0284] <bakkot>
well, also lets consumers of a library coordinate with it without having a direct reference to it

[11:07:46.0826] <bakkot>
like you can have a library which defines a protocol, and have someone else implement that protocol without reference to the library

[11:09:02.0097] <ljharb>
shu: as much as i claim that the existence of iframes means browsers can't pretend realms don't exist, i completely agree with you that it's unlikely that was the motivation

[11:09:23.0522] <ljharb>
making the symbol registry realm-specific would have supported the library use case just fine, i think

[11:09:33.0217] <bakkot>
forget I said realms; "multiple versions of a library" is the right thing to think about, whether that's cross-realm or not

[11:09:43.0714] <bakkot>
and consumers of a library which aren't including it directly

[11:10:58.0030] <ljharb>
erights: what if i had a WeakMap of a symbol to an object, and then a WeakRef of the same object, and no other refs to the object. couldn't i observe the collection of the symbol via the collection of the object?

[11:19:52.0376] <Richard Gibson>
subclassing doesn't work anyway, because of e.g. `BaseClass[method].call(subclassInstance, ‚Ä¶)` directly interacting with internal slots

[11:20:06.0385] <bakkot>
ljharb: fwiw I don't think "registered symbols" and "unique symbols" are actually the same kind of thing for users

[11:20:15.0533] <bakkot>
they have the same type but they really do not come up in the same cases

[11:21:12.0896] <Ben Newman (Apollo, @benjamn on GH)>
Aren't registered Symbols often used for safely branding objects, in case you have more the one copy of a library (so instanceof is risky)?

[11:21:44.0065] <bakkot>
Ben Newman (Apollo, @benjamn on GH): yes, but that's not like a regular symbol

[11:22:05.0123] <Ben Newman (Apollo, @benjamn on GH)>
I was responding to the question about whether anyone actually uses registered Symbols

[11:22:17.0572] <bakkot>
ah, sure

[11:22:33.0692] <ljharb>
that's the common _appropriate_ use case, yeah

[11:24:31.0958] <Ben Newman (Apollo, @benjamn on GH)>
"eternal" seems to mean/imply "recoverable after all references are lost" (fair?)

[11:24:32.0226] <bakkot>
Ben Newman (Apollo, @benjamn on GH): my claim is that there is no good reason to want to put such a brand in a WeakMap

[11:24:46.0148] <bakkot>
at least not that i can think of offhand

[11:25:51.0419] <Ben Newman (Apollo, @benjamn on GH)>
I'm uncomfortable with throwing "good" around like that

[11:25:53.0436] <ljharb>
hm, i just got kicked off the call

[11:25:57.0150] <nicolo-ribaudo>
Me too

[11:25:59.0313] <ljharb>
what did i miss?

[11:26:05.0067] <ljharb>
ah k

[11:26:19.0827] <rickbutton>
did the call just die?

[11:26:47.0133] <ptomato>
same

[11:26:48.0892] <Ben Newman (Apollo, @benjamn on GH)>
(it's back if you reconnect)

[11:27:17.0386] <nicolo-ribaudo>
 * Oh again

[11:30:03.0364] <bakkot>
let me put it a different way: the reason to want a registered symbol is that you want something which lives forever, for e.g. coordination across instances/consumers of a library. the reason you want to put symbols in a weakmap is that you want to hold something weakly - you have a symbol which is ephemeral, and you want to hold something else ephemerally. (Otherwise you could just use a Map.) these uses are directly opposed.

[11:31:16.0912] <Ben Newman (Apollo, @benjamn on GH)>
I'm fine with never collecting registered symbols, as are V8 and Mozilla's engine, it sounds like

[11:31:32.0290] <Ben Newman (Apollo, @benjamn on GH)>
they are, quite literally, always reachable once registered, even if you've lost all references

[11:32:44.0274] <rbuckton>
bakkot: But you can also intentionally craft an object that should live forever and also place it in a weakmap. If you *want* to track a symbol in a way that is "preferrably" weak, you would have to write a lot of defensive code and have both a WeakMap and a Map.

[11:33:03.0821] <Ben Newman (Apollo, @benjamn on GH)>
the "optimization" of collecting registered symbols anyway and then later returning a new reference if someone asks for them again with Symbol.for is simply unsound, IMO

[11:33:15.0209] <Ben Newman (Apollo, @benjamn on GH)>
it would be nice to hear about a JS engine that actually does that

[11:34:31.0126] <Ben Newman (Apollo, @benjamn on GH)>
is someone from Apple on the call? msaboff ? does Safari actually collect registered symbols?

[11:34:34.0296] <bakkot>
rbuckton: my position is that the desire to weakly hold symbols which may or may not be registered is niche enough that it's sufficient for the language to _support_ it without needing to make it trivial

[11:34:39.0087] <bakkot>
 * rbuckton: my position is that the desire to weakly hold symbols which may or may not be registered is niche enough that it's sufficient for the language to _support_ it without needing to make it trivial

[11:34:53.0878] <yulia>
Robin Ricard: can you add "no preference, general support"?

[11:35:16.0120] <Ben Newman (Apollo, @benjamn on GH)>
XS does not collect any symbols (just stated by Peter H on the call)

[11:35:19.0642] <yulia>
i mean, i care, i like it

[11:35:28.0731] <rickbutton>
yulia: "indifferent"

[11:35:31.0423] <shu>
Ben Newman (Apollo, @benjamn on GH): why is that unsound?

[11:35:35.0620] <Robin Ricard>
changed wording

[11:35:42.0844] <shu>
it happens with strings all the time

[11:35:56.0475] <shu>
and doubles, actually, in V8

[11:36:12.0511] <Ben Newman (Apollo, @benjamn on GH)>
@shu because the reference shouldn't change in any semantically observable way, and the WeakMap question provides observability

[11:36:27.0384] <Ben Newman (Apollo, @benjamn on GH)>
strings aren't stored in [weak]maps/sets by reference though

[11:36:31.0822] <Ben Newman (Apollo, @benjamn on GH)>
they're stored by value

[11:36:41.0236] <bakkot>
it's only unsound if WeakMaps can hold registered symbols

[11:36:42.0724] <shu>
strings can't be put into weak collections at all

[11:36:52.0344] <shu>
 * strings can't be put into weak collections at all

[11:36:53.0453] <bakkot>
(and doing so does not prevent GC of the symbol)

[11:36:59.0344] <shu>
correct

[11:37:06.0287] <Ben Newman (Apollo, @benjamn on GH)>
I'm saying it's unsound anyway, and this is just the first gotcha we've encountered

[11:37:13.0496] <shu>
it's... not unsound anyway

[11:37:21.0418] <Ben Newman (Apollo, @benjamn on GH)>
it's sound by accident, currently

[11:37:34.0454] <bakkot>
wasn't an accident

[11:37:50.0982] <bakkot>
that was definitely an intentional part of the design of the symbol registry

[11:38:12.0146] <shu>
yes, they *were* accidentally eternal before, when it was keyed by something else, like parse nodes or something?

[11:38:34.0137] <yulia>
i have the screenshots if anyone needs them

[11:38:43.0211] <bakkot>
you're thinking of template tags

[11:38:43.0548] <yulia>
cc Robin Ricard 

[11:38:53.0369] <shu>
oh, i am, bakkot correct

[11:41:55.0776] <Robin Ricard>
thanks yulia, nicolo took them as well so we are good

[11:43:30.0902] <Ben Newman (Apollo, @benjamn on GH)>
catch the positive names?

[11:43:36.0243] <Ben Newman (Apollo, @benjamn on GH)>
 * catch the positive names?

[11:50:54.0430] <TabAtkins>
shu: "We should do the same as others" isn't quite the point, "everyone else is doing something useful that we aren't" is.

[11:52:36.0161] <shu>
TabAtkins: can i cast your own spell on you? isn't that a fully general argument for stdlib differences?

[11:53:12.0783] <TabAtkins>
No, it's just pointing out that the argument wasn't just "we should be following the bandwagon".

[11:53:21.0438] <shu>
ah

[11:53:34.0342] <shu>
i was responding to the narrower motivating story of "even surma got tripped up"

[11:54:02.0314] <TabAtkins>
The other lang's version of split() is just genuinely better, which is definitely part of why JS's version is so confusing. ^_^

[11:54:07.0150] <shu>
which isn't the same as "i wish we had this other behavior but we don't", it's "i thought our behavior was X but it wasn't"

[11:54:54.0605] <bakkot>
I will try to remember to ask my dad about the history of this next time I talk to him

[11:55:16.0455] <TabAtkins>
Insofar as Surma would have been confused by Python (off-by-one versus the other langs), sure. But it's not clear from his particular complaint whether it was *just* familiarity or "i'm confused this works differently entirely"

[11:55:46.0341] <leobalter>
I'd like if we rename this splitn to `String.prototype.part` (or parts)

[11:55:54.0537] <leobalter>
 * I'd like if we rename this splitn to `String.prototype.part` (or parts)

[12:00:41.0913] <TabAtkins>
Going for the `{remainder: true}` part and taking on Python's numbering semantics would defuse these complains, I think.

[12:00:59.0717] <Michael Ficarra>
I have an open issue about the possible confusion that Chip is talking about: https://github.com/lucacasonato/proposal-reversible-string-split/issues/6

[12:01:24.0638] <TabAtkins>
So `.split(..., 2, ...)` always returns 2 bits between separators, you just get a *third* item with the remainder if you pass the flag. 

[12:02:10.0052] <bakkot>
> taking on Python's numbering semantics would defuse these complains, I think

[12:02:17.0143] <bakkot>
say more about what that means?

[12:05:22.0203] <ljharb>
Luca Casonato: i invited you to tc39-transfer on github, so you can bounce your proposal repo there

[12:06:14.0846] <TabAtkins>
bakkot: Well there was an "and" there that was pretty important.

[12:06:33.0611] <TabAtkins>
The part after the "and" that you quoted was more of an "(and, in effect, ...)"

[12:07:39.0703] <Luca Casonato>
> <@leobalter:matrix.org> I'd like if we rename this splitn to `String.prototype.part` (or parts)

Could you add that to this issue? https://github.com/lucacasonato/proposal-reversible-string-split/issues/6

[12:08:32.0194] <TabAtkins>
But basically, if we use a flag argument in .split(), I don't think we should significantly change the existing semantics/behavior of the proposal. `.split(..., 2)` should still always trigger (up to) 2 splits, with the option just controlling whether we get the remainder or not included in the array.

[12:08:58.0745] <TabAtkins>
That also avoids all the regex questions, since the answer remains "act exactly as normal, just include the remainder as a final item"

[12:11:03.0745] <Surma>
(sounds like Luca Casonato got stage 1? :D)

[12:11:17.0136] <TabAtkins>
yes

[12:12:23.0540] <Luca Casonato>
> <@surma:matrix.org> (sounds like Luca Casonato got stage 1? :D)

indeed! :D

[12:12:36.0668] <leobalter>
> <@lucacasonato:matrix.org> Could you add that to this issue? https://github.com/lucacasonato/proposal-reversible-string-split/issues/6

Done

[12:13:16.0435] <Luca Casonato>
> <@tabatkins:matrix.org> But basically, if we use a flag argument in .split(), I don't think we should significantly change the existing semantics/behavior of the proposal. `.split(..., 2)` should still always trigger (up to) 2 splits, with the option just controlling whether we get the remainder or not included in the array.

Don't generally disagree with this, I just worry about discoverability here. If people already don't know about the second argument, how will they find a third argument?

[12:13:40.0604] <TabAtkins>
If people already don't know about the second argument, how will they find a completely separate method?

[12:13:54.0099] <Luca Casonato>
> <@tabatkins:matrix.org> If people already don't know about the second argument, how will they find a completely separate method?

Editor autocompletions :-)

[12:14:13.0618] <TabAtkins>
Editors often offer signature suggestions too ^_^

[12:16:21.0181] <Luca Casonato>
> <@tabatkins:matrix.org> That also avoids all the regex questions, since the answer remains "act exactly as normal, just include the remainder as a final item"

This brings up the question of what our actual definition of N is - is it number of splits, or number of return values? If we continue expanding regexps capturing groups into the return values array when "remainder" is included, then we must use number of return values (non python behaviour). I'd argue that if we overload, then the overload should not support regexp separators.

[12:16:55.0023] <Ben Newman (Apollo, @benjamn on GH)>
 * "eternal" seems to mean/imply "recoverable after all references are lost"

[12:17:49.0289] <Luca Casonato>
Really, I dislike this capturing group expansion into the return value array behaviour. It significantly increases complexity

[12:19:01.0675] <TabAtkins>
Ugggggh I didn't realize the N is *literally* "length of the returned array" even when regex capture groups are used, that's *worthless*.

[12:19:27.0735] <ljharb>
does anyone know who https://github.com/phohensee is, in relation to tc39?

[12:22:49.0095] <Luca Casonato>
> <@tabatkins:matrix.org> Ugggggh I didn't realize the N is *literally* "length of the returned array" even when regex capture groups are used, that's *worthless*.

You understand my frustration now? xD

[12:23:32.0844] <HE Shi-Jun>
Yeah the currrent split behavior is just useless 

[12:23:39.0601] <Luca Casonato>
`"".split(sep, n)` === `"".split(sep).slice(0, n)` 

[12:24:30.0793] <ljharb>
for n >= 0, i presume

[12:24:33.0986] <ljharb>
 * for n >= 0, i presume

[12:25:12.0135] <HE Shi-Jun>
I think we'd better follow rust, splitN(n, s) seems very clear and won't confused with the old one.

[12:25:21.0293] <Luca Casonato>
> <@ljharb:matrix.org> for n >= 0, i presume

```
> "a|b|c|d|e".split("|", -1)
[ "a", "b", "c", "d", "e" ]
```

[12:30:20.0807] <Michael Ficarra>
üéâ we just got consensus at the UTC meeting for my proposal to stabilise the spelling of property names/values/aliases! https://www.unicode.org/L2/L2022/22029-canonical-prop-spelling.pdf

[12:31:50.0083] <Michael Ficarra>
we'll be able to delete tables 67 and 68 now

[12:41:17.0502] <Ben Newman (Apollo, @benjamn on GH)>
 * table 69 is breathing a sigh of relief right now

[12:59:00.0237] <Rob Palmer>
the meeting resumes in 60 seconds

[13:03:12.0813] <bakkot>
Michael Ficarra: did you ask them why they recommended loose matching in the first place?

[13:03:39.0384] <Michael Ficarra>
no, though it sounded like it's just kind of their default position

[13:03:50.0575] <bakkot>
weird

[13:04:52.0957] <Michael Ficarra>
someone was like "can't we just make it stable but not add it to our stability policy?" and I was like "uuuhhhh that's not gonna work" lol

[13:05:27.0486] <Michael Ficarra>
imo the only reason they would want that is if they planned to break it

[13:07:54.0926] <Michael Ficarra>
why do we allow this form in any position other than the target of a call? do we really want it being passed around?

[13:08:13.0957] <ljharb>
which form?

[13:08:24.0188] <Michael Ficarra>
class.hasInstance

[13:08:39.0587] <ljharb>
i assume `class.hasInstance()` would work just like `super()` and `import()`, in that it's not a real function and can't be passed around

[13:08:54.0245] <Michael Ficarra>
exactly, that's what I'm suggesting

[13:09:06.0277] <ljharb>
oh, is this proposal currently suggesting something different?

[13:09:31.0859] <Michael Ficarra>
that's how I understood the presenter, maybe not?

[13:09:54.0365] <Michael Ficarra>
I didn't look at spec text for this proposal

[13:10:04.0086] <ljharb>
for stage 2 i'd definitely insist alongside you that that's how it work ¬Ø\\\_(„ÉÑ)\_/¬Ø

[13:10:20.0146] <Michael Ficarra>
oh no your arm

[13:10:33.0194] <ljharb>
 * for stage 2 i'd definitely insist alongside you that that's how it work ¬Ø\\_(„ÉÑ)_/¬Ø

[13:10:36.0757] <ljharb>
 * for stage 2 i'd definitely insist alongside you that that's how it work ¬Ø\\\_(„ÉÑ)\_/¬Ø

[13:10:48.0948] <ljharb>
lol matrix is even worse than github with the markdown escaping (Ôºç‚Ä∏·Éö) 

[13:12:46.0645] <shu>
i thought it was a meta property call syntax, yeah

[13:12:50.0199] <shu>
how do you even pass it around

[13:13:27.0371] <ljharb>
if it were a real function you could `foo(class.hasInstance)` but obv that'd be subpar

[13:13:52.0087] <shu>
well right, but i didn't think it was a real function

[13:15:34.0638] <Michael Ficarra>
someone want to ask the clarifying question? I'm kinda in the middle of my lunch

[13:15:44.0121] <bakkot>
i am not so convinced by the "you might end up with a partially constructed instance" problem. you have to work pretty hard to still end up with a reference to the instance when a field initializer throws; it's not something you're going to end up passing around natuarlly

[13:16:10.0826] <shu>
i am not understanding what is being proposed for the synthetic brand he wants `class.hasInstance` to make

[13:16:13.0422] <shu>
at the start or at the end?

[13:16:27.0153] <shu>
oh here's the slide

[13:17:20.0367] <bakkot>
"after the constructor returns" does seem like the right answer to this question to me yeah

[13:18:14.0238] <Michael Ficarra>
oh THAT'S what he meant by function-like

[13:19:09.0108] <bakkot>
does `import()` work inside eval?

[13:19:17.0202] <bakkot>
i am guessing yes, so I would say this should also work

[13:19:36.0044] <bakkot>
"if there is a direct eval you have to do a lot more work" is not a new thing

[13:20:28.0553] <shu>
super does

[13:20:39.0543] <shu>
and super already causes extra allocation for home objects

[13:20:44.0773] <shu>
so eval also causes that

[13:20:53.0370] <shu>
it's no worse than the status quo, which remains "don't use eval"

[13:21:08.0312] <ljharb>
private fields don't tho, i think

[13:21:19.0199] <shu>
really?

[13:21:25.0016] <ljharb>
~hm, let me confirm~ no nvm, they do work

[13:21:42.0909] <rbuckton>
I need to draft an update on class access expressions. Assuming it will ever move forward, I think I need to move it to a meta property like `class.static` or something.

[13:22:02.0474] <rbuckton>
or `class.constructor` maybe.

[13:22:07.0501] <ljharb>
 * ~hm, let me confirm~ no nvm, they do work

[13:22:11.0488] <ljharb>
 * ~~hm, let me confirm~~ no nvm, they do work

[13:22:17.0473] <ljharb>
 * ~hm, let me confirm~ no nvm, they do work

[13:22:33.0094] <ptomato>
I think we're managing just adequately with the notes, so no need to interrupt the presentation to ask for more, but if someone wants to help out I'd nonetheless appreciate it

[13:23:47.0392] <Michael Ficarra>
rbuckton: for anonymous classes or something?

[13:25:17.0679] <rbuckton>
Its original intent was to handle multiple things: anonymous classes and giving a consistent name to access statics to avoid the `this.#foo` footgun in static methods

[13:26:52.0314] <ljharb>
it's also nice to avoid repeating the class name - gives you only one thing to change if you want to rename a class declaration

[13:26:54.0588] <Rob Palmer>
so `hasInstance()` true implies the object was fully constructed without throwing

[13:26:58.0722] <ljharb>
 * it's also nice to avoid repeating the class name - gives you only one thing to change if you want to rename a class declaration

[13:27:39.0742] <shu>
all non-throwing cases can be, yes

[13:27:42.0785] <Michael Ficarra>
then why did we even expose an immutable binding inside the class? I'm unconvinced

[13:27:53.0517] <shu>
~~~recursion~~~~~~

[13:28:00.0139] <shu>
what the hell

[13:28:13.0654] <shu>
i typed `~~~~recursion~~~~~~`

[13:28:15.0158] <ljharb>
yulia: i do agree that `class.hasInstance` is always equivalent to a private field at the end of the class body, that's assigned to `sentinel` at the end of the constructor, and doing `#field in o && o.#field === sentinel`

[13:28:28.0925] <shu>
it's not equivalent to private field at the end, is it?

[13:28:29.0024] <Rob Palmer>
to replicate this feature with ergonomic brand checks, i think the user would have to assign to the brand field at each return point in the constructor

[13:28:49.0415] <shu>
yeah, it's like that, but that's also why i'm kinda not super convinced

[13:28:51.0891] <ljharb>
Michael Ficarra good question. i don't find that binding immutability particularly useful, and would have preferred a class access expression

[13:28:56.0804] <shu>
but i'll ask during my queue item

[13:29:28.0737] <rbuckton>
> <@michaelficarra:matrix.org> then why did we even expose an immutable binding inside the class? I'm unconvinced

The immutable binding in the class has been a problem for decorators and is constantly surprising to some

[13:29:37.0688] <Michael Ficarra>
ljharb: I think it speaks to the intentions of the delegates who designed the class proposal

[13:29:58.0317] <bakkot>
> <@robpalme:matrix.org> to replicate this feature with ergonomic brand checks, i think the user would have to assign to the brand field at each return point in the constructor

only because someone might get a hold of `this` during the constructor even if the constructor throws, right? if you assume the ctor/initializers don't throw it's equivalent?

[13:29:58.0777] <Ashley Claymore>
https://github.com/tc39/proposal-class-brand-check/issues/6#issuecomment-1015303592

[13:30:03.0891] <shu>
Michael Ficarra: it might be just copying the function scope

[13:30:13.0828] <shu>
named function expressions also have that constant lambda scope

[13:30:14.0866] <ljharb>
Michael Ficarra: since some of them are here, it'd be nice to hear their intentions spoken instead of inferring them

[13:30:19.0350] <ljharb>
but yes, it's the same way functions work

[13:30:20.0639] <bakkot>
if so, as I said above, i am not so convinced by the "you might end up with a partially constructed instance" problem

[13:30:29.0374] <Michael Ficarra>
shu: they have their own name scope, but it's mutable

[13:30:35.0417] <ljharb>
which fwiw is also subpar, it's just that self-recursion is much rarer than accessing the constructor's statics

[13:30:37.0663] <shu>
what

[13:30:41.0681] <shu>
the lambda scope is not mutable

[13:30:52.0566] <Michael Ficarra>
uhh I thought it was, let me check

[13:31:00.0304] <bakkot>
nope

[13:31:04.0085] <bakkot>
you can assign to it but it's immutable

[13:31:08.0563] <shu>
yeah

[13:31:11.0058] <bakkot>
it's a unique kind of const among bindings in JS

[13:31:14.0522] <shu>
it's not the same semantics as const but it's immutable

[13:31:15.0318] <shu>
so good

[13:31:22.0668] <Michael Ficarra>
ugh weird

[13:31:31.0266] <bakkot>
 * it's a unique kind of const among bindings in JS

[13:31:53.0416] <bakkot>
> <@ljharb:matrix.org> which fwiw is also subpar, it's just that self-recursion is much rarer than accessing the constructor's statics

doubt

[13:32:03.0568] <ljharb>
doubt which, the rarity?

[13:32:06.0782] <Rob Palmer>
> <@bakkot:matrix.org> only because someone might get a hold of `this` during the constructor even if the constructor throws, right? if you assume the ctor/initializers don't throw it's equivalent?

yes.  maybe the constructor passes `this` to a static function that contains `hasInstance` from the same class

[13:32:11.0314] <shu>
> <@michaelficarra:matrix.org> ugh weird

sickos.jpg

[13:32:12.0435] <bakkot>
yes

[13:32:21.0904] <ljharb>
bakkot: recursion at all is rare in JS due to a lack of PTC

[13:32:29.0836] <ljharb>
it's certainly all over the place, but way rarer than it would be otherwise

[13:32:30.0757] <shu>
...false?

[13:32:32.0765] <bakkot>
this has not been my experience

[13:32:44.0007] <ljharb>
perhaps we look at very different kinds of codebases

[13:32:50.0188] <shu>
most useful recursion i argue is in fact not tail recursion

[13:33:12.0647] <Michael Ficarra>
everything is tail recursion

[13:33:15.0883] <waldemar>
How does Contains work with respect to a class? If you're evaluating Contains on Expr which contains a class expression C, does Contains peek into C's computed property names?

[13:33:37.0606] <Justin Ridgewell>
I do recursion all the time.

[13:33:47.0884] <bakkot>
waldemar: there is a special ComputedPropertyContains which, yes, descends into the computed property names, but not into method bodies or initializers

[13:33:53.0465] <waldemar>
And if you're doing Contains on C itself, does it peek into its own property names?

[13:34:13.0414] <bakkot>
That one I'm not sure of offhand

[13:34:46.0227] <bakkot>
looks like, yes, it peeks into its names but not into method bodies, same as if you called Contains on a parent of C

[13:34:49.0948] <waldemar>
It seems that both do, which is weird. Things in computed property names are both in the class and not in the class?

[13:35:13.0360] <waldemar>
This is a problem for things which are class-scoped like the proposal just presented.

[13:35:36.0804] <bakkot>
We'd need to use a different operation than Contains, yes

[13:36:54.0212] <bakkot>
Contains normally stops at function boundaries - which you can read to mean "places where `yield` might start meaning a different thing", to be precise - which is why it looks into computed property names but not method bodies

[13:37:20.0583] <waldemar>
Hax's proposal makes it pierce function boundaries

[13:37:40.0626] <waldemar>
Methinks Contains is getting too overloaded and confusing

[13:37:56.0891] <bakkot>
I would suggest introducing a different operation, yes

[13:38:28.0286] <bakkot>
we've done that before - e.g. we have ContainsArguments for looking for `arguments` in field initializers, which is like Contains but with some details different (it descends into arrows, in particular)

[13:38:46.0104] <bakkot>
adding a similar new ContainsClassHasInstance is probably the way to go

[13:48:34.0883] <HE Shi-Jun>
Currently we use ContainsClassHasInstance to check whether a class scope include any class.hasInstance. Maybe we don't need modify Contains... Speccing such things is too hard for me or TianYang üòÇ

[13:49:20.0158] <HE Shi-Jun>
Actually we already rewrite the spec text at least three times.

[13:52:28.0837] <HE Shi-Jun>
> <@waldemarh:matrix.org> It seems that both do, which is weird. Things in computed property names are both in the class and not in the class?

We (three champion) haven't has meeting for that, but we chatted about it  yesterday and we tend to make `class.hasInstance` in computed property syntax error. Though as current spec text, (if I really figure out all things) i believe it's allowed but always give u false, because at that time, no one have the class so no instance of it.

[13:53:37.0035] <HE Shi-Jun>
> <@waldemarh:matrix.org> Hax's proposal makes it pierce function boundaries

Yeah, this part make me headache...

[13:54:00.0617] <bakkot>
If you figure out exactly what the semantics you want I'm happy to help with writing the spec text before stage 3

[13:54:27.0128] <bakkot>
at least in terms of telling what is probably the simplest way to write the thing you want

[13:54:54.0565] <bakkot>
important part is figuring out the semantics you want

