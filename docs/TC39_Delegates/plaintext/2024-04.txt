2024-04-04
[07:14:40.0599] <ljharb>
i hope Temporal will be able to support the moon https://www.reuters.com/science/white-house-directs-nasa-create-time-standard-moon-2024-04-02/

[07:17:02.0068] <nicolo-ribaudo>
That is a clear use case for sub-microsecond precision

[07:21:24.0968] <Jesse>
we'll need a v2 of Temporal where we specify the astronomical "home base" object. CLDR will need to be extended with a new catalog of astronomical objects and new lunar time zones. Should be doable!

[07:22:01.0255] <Andreu Botella>
make sure you never end up with a home base inside a black hole

[07:25:47.0132] <Jesse>
maybe this time we can get it right and agree to use timex time (100 second minutes, 100 minute hours) on the moon

[07:30:17.0337] <Jesse>
 * we'll need a v2 of Temporal where we specify the astronomical "home base" object for all operations. CLDR will need to be extended with a new catalog of astronomical objects and new lunar time zones. Should be doable!

[12:23:57.0519] <ptomato>
what I learned from researching the moon standard time in the past couple of days, is that local gravity affects the rate at which atomic clocks tick. Earth's atomic time is the average of several dozen atomic clocks, all with gravitational corrections applied so that they are effectively ticking at mean sea level (even if the clock itself is physically far above sea level)

[12:34:03.0904] <TabAtkins>
Yup, that's relativity for you. Gravity affects the rate time passes.

[12:34:36.0407] <bakkot>
yeah it's not just that it affects the rate at which the clocks tick, it's that it affects the rate at which _everything_ ticks https://en.wikipedia.org/wiki/Gravitational_time_dilation

[12:35:20.0711] <bakkot>
looking forward to Temporal being updated to include a "strength of local gravity" parameter :D

[12:38:07.0627] <ptomato>
right, so I'm a bit skeptical about whether it makes any sense to stretch the definition of POSIX time to incorporate other astronomical bodies

[13:56:02.0800] <Chris de Almeida>
gentle reminder to please add any and all plenary schedule constraints as soon as possible

[14:45:50.0407] <TabAtkins>
> <@bakkot:matrix.org> looking forward to Temporal being updated to include a "strength of local gravity" parameter :D

"velocity relative to timebase station", too

[14:46:24.0570] <bakkot>
if we're doing velocity we need acceleration and jerk and so on as well, so we can properly represent dates in the future

[14:46:37.0262] <bakkot>
really just a full PDE I figure

[14:52:33.0535] <Andreu Botella>
the curvature of the entire universe too

[14:57:37.0525] <shu>
what the fuck


2024-04-05
[17:19:11.0869] <waldemar>
The current time systems in common use are only really designed to work on the surface of the Earth. Astronomers and other space scientists use different time systems which account for relativistic effects such as https://en.wikipedia.org/wiki/Barycentric_Dynamical_Time

[17:21:00.0409] <waldemar>
One of my favorite papers is measuring the masses of various solar system bodies such as Saturn using nothing more than clocks, comparing earthbound clocks to clocks outside the solar system (in the form of distant pulsars): https://arxiv.org/abs/1008.3607

[17:24:04.0707] <waldemar>
The approach of counting seconds won't work well after we expand into space because clocks tick at different rates in different places in the solar system. If you want everyone to stay synced to Earth time, you'll need to adjust the duration of the second depending on where you are. If you want to keep the SI definition of a second, clocks in various places will diverge over time.

[17:25:16.0778] <waldemar>
We already have that issue with spacecraft, but the scientists and engineers working them account for the differences.

[15:18:54.0730] <Aki>
if you'll all allow a brief single off-topic post: i'm baaaaaack. üòò

[15:37:44.0040] <Chris de Almeida>
requesting consensus for an eclipse break on Monday

[15:39:42.0077] <Chris de Almeida>
well. I guess that doesn't make much sense unless the break is like.. 2 hours long

[15:39:44.0800] <Aki>
i wonder if people will be too distributed

[15:39:46.0787] <Aki>
lol

[15:39:50.0436] <Aki>
also that

[15:40:40.0576] <Chris de Almeida>
ah, actually for me the meeting will be over already

[15:41:04.0653] <Aki>
yeah the farther east you are, i think


2024-04-06
[17:35:11.0123] <rbuckton>
I will be missing Monday for the eclipse, though I might try to dial in to observe the plenary for part of the day. 

[23:36:03.0603] <Chris de Almeida>
https://github.com/tc39/Reflector/issues/522#issuecomment-2040991367

[23:38:46.0738] <Chris de Almeida>
‚òùÔ∏è draft schedule is available. all constraints have been accommodated


2024-04-08
[07:02:26.0932] <shu>
is there a way to join the meeting without logging in

[07:02:59.0511] <Jesse>
I joined the call anonymously (no prior log in)

[07:03:46.0202] <bakkot>
you do not have to use the client

[07:04:12.0479] <shu>
oh i see, i can just enter any name/email, thanks

[07:04:12.0879] <bakkot>
if you click the "use on the web" it kind of implies you're signing in, but you just put your name and email and then join regardless of what you put in those boxes

[07:04:22.0400] <Chris de Almeida>
> <@shuyuguo:matrix.org> is there a way to join the meeting without logging in

yes

[07:04:37.0660] <littledan>
I just gave my name and email address, and then the "join as guest" button un-grayed

[07:04:52.0415] <littledan>
(done on the native client)

[07:07:19.0489] <shu>
> <@bakkot:matrix.org> if you click the "use on the web" it kind of implies you're signing in, but you just put your name and email and then join regardless of what you put in those boxes

thanks, that's what confused me

[07:20:48.0227] <littledan>
Slides for this presentation at https://github.com/tc39/agendas/blob/littledan-patch-2/2024/tc39-2024-016.pdf (PR'd to the agenda also)

[07:21:29.0352] <Michael Ficarra>
ooohh we're bringing WinterCG into Ecma?

[07:21:35.0040] <littledan>
yep!

[07:21:40.0316] <ryzokuken>
WinterTC

[07:21:42.0628] <Michael Ficarra>
I imagine it won't continue to be called WinterCG?

[07:22:02.0902] <littledan>
More context: https://github.com/wintercg/admin/issues/58

[07:22:28.0541] <littledan>
The W3C CG will be the main place for technical development; WinterTC will be more for validation and formal standardization (this mirrors CycloneDX)

[07:25:15.0098] <nicolo-ribaudo>
Are temp checks an official vote?

[07:25:21.0423] <littledan>
no

[07:25:26.0632] <nicolo-ribaudo>
It's weird that voting rules apply to temp checks 

[07:26:05.0675] <littledan>
yes, I agree. I think these Ecma rules only apply directly to official votes, which we do not have. That said, I'm not sure if IEs should be able to block.

[07:26:09.0848] <ljharb>
they're def not votes

[07:26:35.0227] <littledan>
calling for consensus on advancement might be thought of as an implicit vote

[07:26:39.0873] <littledan>
but temperature checks certainly aren't fotes

[07:26:43.0137] <littledan>
 * but temperature checks certainly aren't votes

[07:26:44.0160] <Michael Ficarra>
IEs definitely should not be voting/blocking

[07:26:48.0579] <ljharb>
IEs not being able to participate in consensus would be a radical change from the way tc39 has always operated, so that'd be something that needs discussion

[07:27:02.0636] <shu>
IEs should not be able to veto

[07:27:08.0299] <littledan>
> <@ljharb:matrix.org> IEs not being able to participate in consensus would be a radical change from the way tc39 has always operated, so that'd be something that needs discussion

OK, let's have this discussion now with Samina

[07:27:13.0942] <littledan>
in the queue

[07:27:55.0522] <ljharb>
about temp checks sure. but ecma rules aren't really relevant; IEs participate in consensus here, and we'd need an agenda item to get consensus on changing that.

[07:31:40.0124] <ljharb>
shu: "being an IE" is at the discretion of chairs and ecma, so if that were ever abused it would be pretty easy to shut it down

[07:32:48.0877] <eemeli>
Does consensus for stage advancement count as a "vote" in ECMA terms?

[07:33:08.0900] <shu>
imo yes?

[07:33:25.0901] <nicolo-ribaudo>
I think so

[07:33:26.0192] <ljharb>
no

[07:33:27.0989] <shu>
like i don't see why there would be any bylaws if any TC can also just say "actually we don't do that"?

[07:33:33.0498] <ljharb>
it's consensus. not a ote.

[07:33:34.0769] <ljharb>
 * it's consensus. not a vote.

[07:33:43.0685] <ljharb>
if it was a vote than we wouldn't ask individuals, we'd ask members.

[07:33:50.0747] <nicolo-ribaudo>
And we informally agree that the chairs only ask for the vote if there is would be full consensus

[07:34:00.0218] <shu>
i strongly disagree

[07:34:04.0350] <ljharb>
for example, google having 30 delegates would still only get 1 response to a call for consensus. that's not how we operate.

[07:34:19.0368] <littledan>
there has long been disagreement within the committee about what the policy is. It's good for this to be on the table for discussion.

[07:35:06.0618] <ljharb>
 * for example, google having 30 delegates would still only get 1 response to a call for consensus. that's not how we operate, or have literally ever operated.

[07:35:28.0730] <nicolo-ribaudo>
 * And we informally agree that the champions only ask for the vote if there is would be full consensus

[07:35:39.0534] <nicolo-ribaudo>
 * And we informally agree that the champions only "ask for the vote" if there is would be full consensus anyway, so no vote needed

[07:35:45.0497] <ljharb>
it's fine to discuss it, and if someone would like to, it'd be great to add an agenda item for it. but making a change here would be dramatic and unprecedented for tc39, and isn't a matter of simply "interpreting bylaws".

[07:35:47.0564] <eemeli>
It would be Really Good for execom to explicitly comment on our consensus practices.

[07:36:13.0061] <littledan>
good reminder from @ljharb on GitHub teams, and thank you for your good work on setting up the GitHub teams. I do want to note that we have some inconsistencies between the GitHub and Ecma data (which member organizations have provided to Ecma and are published in the Ecma memento) and we will need to work through these. I believe neither one of these is perfectly up to date, and we will make a lot of progress by reconciling them.

[07:36:30.0673] <ljharb>
in general, laws serve the people, so if the bylaws conflict with what we actually do, the bylaws, not us, should change.

[07:37:22.0954] <littledan>
> <@eemeli:mozilla.org> It would be Really Good for execom to explicitly comment on our consensus practices.

In general, the ExeCom and Ecma management are very happy with TC39's "self-governance" and don't want to intervene too much. Ecma folks have previously said that they are happy with consensus-based processes like ours, but have found our way of dealing with vetos as absolute to be a bit much.

[07:37:29.0948] <ljharb>
 * in general, laws serve the people, so if the bylaws conflict with what committees actually do, the bylaws, not us, should change.

[07:39:42.0536] <littledan>
> <@ljharb:matrix.org> in general, laws serve the people, so if the bylaws conflict with what committees actually do, the bylaws, not us, should change.

Yes, I very strongly agree with you that we should be thoughtful about any change to TC39's practices and not just blindly apply rules/bylaws, but consider whether they need to be changed if they don't fit, and submit such changes to the Ecma GA for a vote [in practice, consensus there too]. That said, the committee has long contained multiple opinions about whether IEs can block, so it's not clear what the change would/should be. Ecma rules are still set by the GA and not by TC39 precedent.

[07:40:06.0634] <littledan>
I mean, this is why I got involved in Ecma stuff in the first place, to ensure that we had an IE policy in the first place and that we didn't accidentally kick Babel etc out

[07:42:21.0294] <eemeli>
littledan: Does "a bit much" mean that there's an expectation for us to change something at some point, or that the divergence from expectations is small enough to ignore?

[07:43:36.0431] <ljharb>
i mean sure, but opinions that differ from 100% of past history don't change what's actually happened

[07:44:02.0808] <ljharb>
it's fine to believe IEs shouldn't participate in consensus, for example, but that's only relevant in a discussion about whether to change the fact that they do :-)

[07:45:10.0345] <ljharb>
 * it's fine to believe IEs shouldn't participate in consensus, for example, but that's only relevant in a discussion about whether to change the fact that they do :-) (which is also fine to have, ofc)

[07:50:01.0990] <littledan>
> <@eemeli:mozilla.org> littledan: Does "a bit much" mean that there's an expectation for us to change something at some point, or that the divergence from expectations is small enough to ignore?

No, there is no expectation that we change anything; they respect our self-management here and don't want to excessively intervene.

[07:50:38.0182] <littledan>
> <@ljharb:matrix.org> i mean sure, but opinions that differ from 100% of past history don't change what's actually happened

in past incidents of IEs blocking, IMO there is ambiguity as to whether the IE actually executed a block, or whether the IE expressed a strong negative opinion and the champion withdrew the request for advancement.

[07:51:18.0335] <ljharb>
there's no such thing as "block". there's either consensus for something, or not

[07:51:19.0727] <littledan>
IEs are definitely here to participate actively in all technical discussions, and express strong negative opinions when there's a request for consensus, no doubt about that. If they make a good argument, they won't be the only blocker, so this is probably not a very impactful decision.

[08:10:06.0150] <Ben>
402 update slides: https://notes.igalia.com/p/fxx00_k5K#/

[08:14:39.0447] <nicolo-ribaudo>
This transcriber wrote "camel cased" as CamelCased

[08:14:47.0790] <nicolo-ribaudo>
üíØ

[08:19:43.0281] <ljharb>
oh no, that's PascalCased tho

[08:21:34.0343] <dminor>
ptomato: Could you please provide a link to the sovereign tech fund that is funding the test262 work? Or to your slides?

[08:22:08.0509] <ljharb>
it's Germany

[08:22:14.0492] <ljharb>
https://www.sovereigntechfund.de

[08:22:27.0910] <ptomato>
I was about to paste the content of the slide into the notes, will that work?

[08:22:30.0491] <ljharb>
they also gave nearly a million to the OpenJS Foundation last year

[08:22:33.0853] <ptomato>
otherwise yes what Jordan said

[08:22:38.0930] <ljharb>
they're doing what all governments should be doing :-) it's great

[08:22:50.0560] <dminor>
Great, thank you :)

[08:29:53.0178] <dminor>
Hypothetical question, would we take money from any sovereign tech fund, or would we consider things like human rights records, etc. before accepting funding?

[08:29:55.0536] <littledan>
apparently there's also https://nlnet.nl/bluehatsprize/2024 currently seeking nominations

[08:31:06.0719] <shu>
> <@dminor:mozilla.org> Hypothetical question, would we take money from any sovereign tech fund, or would we consider things like human rights records, etc. before accepting funding?

we = TC39?

[08:33:33.0268] <dminor>
Well, in that case I guess it's Igalia's decision, but yes, I'm kind of wondering how we as a group would feel about this.

[08:33:46.0813] <littledan>
There's also https://www.opentech.fund (from the US govt)

[08:34:09.0282] <littledan>
> <@dminor:mozilla.org> Well, in that case I guess it's Igalia's decision, but yes, I'm kind of wondering how we as a group would feel about this.

I guess this would be something at the Ecma level? In which case it'd definitely be a matter up for GA discussion

[08:34:18.0521] <shu>
i feel like TC39 itself isn't a legal entity to receive funds, so i imagine it's just up to Ecma

[08:35:14.0197] <littledan>
 * There's also https://www.opentech.fund (from the US govt) , specifically https://apply.opentech.fund/foss-sustainability-fund/

[08:35:30.0172] <Michael Ficarra>
it'd be nice if the CoC update included what actions were taken (if any) instead of just saying "it's been resolved"

[08:36:04.0448] <shu>
the usual non-profit donation tricks abound, i imagine, with whether you can or cannot earmark donations for specific activities, especially if it's from a government

[08:42:48.0319] <littledan>
> <@shuyuguo:matrix.org> the usual non-profit donation tricks abound, i imagine, with whether you can or cannot earmark donations for specific activities, especially if it's from a government

FWIW Ecma is a Swiss "association", not a US 501(c)(3). I think this makes certain things more flexible.

[08:42:49.0122] <Michael Ficarra>
serious question: is there anyone who goes to the Firefox download page, says "300MB?! No thanks.", and leaves?

[08:43:01.0054] <Michael Ficarra>
I think by the time you're there, you're downloading Firefox, right?

[08:43:11.0121] <littledan>
it's sort of a cumulative thing though, right?

[08:43:19.0205] <littledan>
especially for mobile

[08:43:21.0208] <shu>
my intuition on almost all size concerns are about mobile, not desktop

[08:43:25.0833] <Michael Ficarra>
you mean Mozilla wants to save upload bandwidth?

[08:43:33.0612] <shu>
indeed i don't think people say that to the desktop downloader

[08:43:37.0711] <nicolo-ribaudo>
> <@michaelficarra:matrix.org> serious question: is there anyone who goes to the Firefox download page, says "300MB?! No thanks.", and leaves?

When your phone is out of storage you have to start going through the list of big apps ü§∑

[08:43:52.0500] <nicolo-ribaudo>
And all phones already have a built-in browser

[08:44:03.0169] <littledan>
> <@shuyuguo:matrix.org> the usual non-profit donation tricks abound, i imagine, with whether you can or cannot earmark donations for specific activities, especially if it's from a government

 * FWIW Ecma is a Swiss "association", not a US 501(c)(3). I think this makes certain things more flexible (IANAL!)

[08:44:24.0422] <shu>
also, markets with significantly cheaper hardware

[08:44:35.0991] <ljharb>
how small is the average phone in those markets these days?

[08:44:52.0859] <littledan>
I think it's more about bandwidth

[08:45:08.0499] <nicolo-ribaudo>
> <@ljharb:matrix.org> how small is the average phone in those markets these days?

Idk but my dad is always uninstalling apps to free up space because his phone is full

[08:45:18.0199] <littledan>
 * I think it's more about download bandwidth

[08:48:05.0841] <bakkot>
> <@ljharb:matrix.org> how small is the average phone in those markets these days?

(nominally 64GB-128GB, usually)

[08:48:18.0998] <ljharb>
that's what i'd expect

[08:48:47.0927] <Jesse>
for me it's images/movies, not apps, that take up space

[08:49:31.0939] <eemeli>
> <@michaelficarra:matrix.org> serious question: is there anyone who goes to the Firefox download page, says "300MB?! No thanks.", and leaves?

To be picky, Firefox desktop on MacOS is currently 134Mb, and on Android it's 88Mb.

[08:49:44.0151] <eemeli>
> <@michaelficarra:matrix.org> serious question: is there anyone who goes to the Firefox download page, says "300MB?! No thanks.", and leaves?

 * To be picky, Firefox desktop on MacOS is currently 134MB, and on Android it's 88MB.

[08:49:57.0772] <Michael Ficarra>
yeah I was too lazy to look up the actual number

[08:50:25.0530] <Michael Ficarra>
here, let me fix it for you: "134MB?! No thanks."

[08:51:12.0437] <ryzokuken>
> <@jesse:igalia.com> for me it's images/movies, not apps, that take up space

spotify's cache grows nearly exponentially 

[08:53:42.0877] <Chris de Almeida>
> <@michaelficarra:matrix.org> it'd be nice if the CoC update included what actions were taken (if any) instead of just saying "it's been resolved"

per the Code of Conduct:  

> The Committee will never publicly discuss the issueÕæ all public statements, if needed, will be made by the TC39 Chair and/or the Ecma Secretariat.

[08:55:37.0682] <Michael Ficarra>
telling us what actions were taken (like somebody being banned from a particular forum) is not discussing the issue IMO

[08:58:53.0469] <littledan>
The CoC committee could refer more public statements to the chair or secretariat for disclosure. Overall I think we have enough experience that statements like, "there was a report, it was handled" don't really make all of TC39 feel more secure about the process. But maybe we should just trust the CoC committee, and even these notifications are unnecessary--confidentiality is really important to preserve.

[08:59:21.0144] <shu>
yeah i think if you want to be confidential just don't update

[08:59:31.0979] <shu>
100% confidential, that is

[09:00:38.0215] <Chris de Almeida>
depending on the action taken, saying what that action was may have privacy risk

[09:00:45.0184] <ryzokuken>
there's no harm in evolving our CoC processes in order to better serve delegates and make everyone feel more secure about our working environment here

[09:10:07.0761] <Chris de Almeida>
it's up to TC39 what the CoC is and how the CoC committee reports back to TC39 and the ExeCom/GA. if folks want to change the CoC, that's fine. it needs to be raised and get consensus at plenary, and I think Ecma ExeCom also would need to support if I'm not mistaken

[09:11:13.0487] <Chris de Almeida>
 * it's up to TC39 what the CoC is and how the CoC committee reports back to TC39 and the ExeCom/GA. if folks want to change the CoC, that's fine. it needs to be raised and get consensus at plenary

[09:22:37.0997] <littledan>
Definitely needs an agenda item to draw a conclusion; this is just some earlier discussion/feedback, which is also valid (like our above discussion about Ecma rules despite this not being a GA meeting). The CoC committee could also be the ones to propose something to plenary, based on this kind of feedback.

[09:33:14.0276] <Chris de Almeida>
you're absolutely right. I want to be clear it's not a matter the CoC committee can unilaterally decide

[09:40:03.0157] <littledan>
About blocks: IMO IEs should generally be able to operate equally to all other committee delegates, and the process focus should probably be more on, what can we do in response to someone (anyone) blocking, and whether the committee may still have general consensus (e.g., by establishing that general consensus at a follow-on meeting once we all have more time to consider things).

[10:06:38.0293] <bakkot>
I don't know that "I would prefer to work with arrays" is... really an answer to "what is the benefit"?

[10:13:14.0896] <littledan>
yeah I think we kinda settled this with iterator helpers a while ago... I did try to give more space to the iterables vs iterators discussion with inviting Axel in, etc.

[10:14:40.0695] <shu>
i mean i also to prefer to work with arrays when cache locality matters

[10:14:53.0769] <shu>
but i don't know if i care about it for joint iteration in particular

[10:15:14.0243] <shu>
and "caring about cache locality" certainly argues for case-by-case for the operation, not a catch-all

[10:15:26.0619] <ljharb>
to be clear i'm not arguing for 100% symmetry

[10:16:32.0099] <Michael Ficarra>
FYI I consider take/drop to be the analogue to slice @nicolo-ribaudo:matrix.org @bakkot:matrix.org

[10:16:45.0068] <bakkot>
they're certainly similar, just not identical

[10:20:36.0850] <bakkot>
I would like us to explicitly have a policy that we don't use "this package has many downloads" as a reason to add a feature

[10:20:59.0442] <bakkot>
"this package has many dependents from different authors", sure

[10:21:41.0686] <nicolo-ribaudo>
(in this case, the package has a dependency of Jest)

[10:21:45.0127] <ljharb>
yeah i was more saying, this is empirical evidence that the original belief is false

[10:21:54.0495] <ljharb>
(that everybody would prefer an aiife)

[10:22:13.0426] <nicolo-ribaudo>
 * (in this case, the package is a transitive dependency of Jest)

[10:22:30.0550] <Michael Ficarra>
> <@shuyuguo:matrix.org> but i don't know if i care about it for joint iteration in particular

please add these comments to https://github.com/tc39/proposal-joint-iteration/issues/1

[10:23:32.0294] <nicolo-ribaudo>
 * (in this case, the package is a transitive dependency of Jest and yargs)

[10:26:24.0038] <shu>
ok

[10:26:28.0184] <bakkot>
tbc, the closest analogy is `new Promise(r => r(foo, ...args))`, not a try-catch

[10:26:41.0794] <bakkot>
 * tbc, the closest analogy is `new Promise(r => r(foo(args)))`, not a try-catch

[10:26:48.0086] <littledan>
We've heard a lot of skepticism on motivation. Maybe we should do a temperature check/

[10:26:52.0606] <littledan>
 * We've heard a lot of skepticism on motivation. Maybe we should do a temperature check?

[10:27:56.0365] <nicolo-ribaudo>
My position is exactly the same

[10:28:03.0225] <nicolo-ribaudo>
"Not bad, but not convinced that it's useful"

[10:29:54.0512] <littledan>
Promise.prototype.catch/finally are really different from Promise.try...

[10:30:26.0888] <shu>
we have spent more time talking about the check than just doing the check

[10:31:17.0288] <tkopp>
I like the hoisting of a sometimes promised function into a definite promise.
It helps decluttering functional chaining.

[10:31:59.0561] <ptomato>
> <@shuyuguo:matrix.org> we have spent more time talking about the check than just doing the check

we do that every time. but temperature checks are rare. if they were more common, I think we wouldn't have to talk about them so much

[10:34:06.0303] <danielrosenwasser>
> <@littledan:matrix.org> Promise.prototype.catch/finally are really different from Promise.try...

could you say more about what the big differences are?

[10:34:52.0945] <nicolo-ribaudo>
Temp polls should have a symmetrical state, going from Strong Positive to Strong Negative

[10:36:06.0616] <littledan>
I voted "indifferent" based on agreeing with what Nicolo said. The intended meaning is not "abstain"

[10:37:12.0071] <bakkot>
"very weak negative" is how I intended my "indifferent"

[10:37:23.0817] <danielrosenwasser>
I assumed "üëÄ" was abstain

[10:37:39.0733] <waldemar>
Indifferent indicates that you had time to consider the issue and vote. 

[10:38:03.0075] <waldemar>
Indifferent has no negative connotations to me.

[10:38:28.0604] <waldemar>
Without "indifferent" it would be hard to tell if people had a chance to vote.

[10:38:33.0136] <littledan>
communication is all about relationships and context, and not only absolute meanings of words

[10:39:14.0024] <littledan>
here, several people explicitly clarified that they specifically meant "very weak negative", so it doesn't really matter if "indifferent" generally has no negative connotations

[10:39:22.0218] <littledan>
anyway it has Stage 2.7 so this is closed, I think

[10:39:31.0287] <bakkot>
I guess given that we would not advance a proposal unless at least some people were strongly positive, and that "very weak negative" is "I don't object to advancement", there's not much practical difference between the two

[10:40:09.0667] <littledan>
in this case, yes

[10:40:23.0112] <Chris de Almeida>
more of an aside, but we regularly change the semantics of what the temp check options are because they don't always align well with the question

[10:40:25.0642] <littledan>
I did want to elicit some more positive/strongly positive feedback, which we did get

[10:42:13.0844] <Michael Ficarra>
just a backslash wouldn't work anyway since we got rid of identity escapes

[10:42:30.0766] <Michael Ficarra>
so it'd be replacing the first character with an escape sequence for that character, like a hex escape

[10:42:39.0129] <Michael Ficarra>
if this is even needed, which I don't believe it is

[10:44:33.0107] <littledan>
> <@nicolo-ribaudo:matrix.org> Temp polls should have a symmetrical state, going from Strong Positive to Strong Negative

I think this choice was deliberate because it was trying to avoid negativity, but after a couple years of experience, it doesn't seem like that design worked. I like the idea of a basically 1-5 symmetrical scale; the other options don't seem to be very easy to interpret.

[10:44:58.0284] <littledan>
and in particular, temperature checks were designed to avoid, well, this kind of vote as a use case, to be honest

[10:44:58.0494] <nicolo-ribaudo>
I opened https://github.com/bterlson/tcq/pull/67for now

[10:45:12.0241] <nicolo-ribaudo>
 * I opened https://github.com/bterlson/tcq/pull/67 for now

[10:46:35.0698] <Michael Ficarra>
strictly more options?!

[10:46:42.0933] <Michael Ficarra>
please no, please get rid of some options at the same time

[10:47:37.0849] <nicolo-ribaudo>
Who should take the fall, "Strongly positive" or "Following"

[10:47:59.0219] <ljharb>
following

[10:48:03.0667] <ptomato>
following. has anyone ever voted following

[10:48:31.0037] <Michael Ficarra>
following for sure

[10:49:18.0624] <littledan>
So "unconvinced" is weakly negative, and "negative" is strongly negative? Should we rename the options to be symmetrical?

[10:49:24.0508] <Michael Ficarra>
also confused because if you're confused, you should be asking for clarification, not voting!

[10:49:44.0896] <littledan>
I guess in this case, "unconvinced" being the strongest negative option makes it scary to vote for

[10:50:03.0976] <littledan>
no, confused is good, we should keep it--it's a big problem if people are confused and afraid to ask!

[10:50:43.0771] <nicolo-ribaudo>
I think calling it unconvinced is more expressive than "weakly negative"

[10:51:04.0400] <nicolo-ribaudo>
Or "This temperature check has been worded terribly I don't know what I'm voting" üòõ

[10:51:07.0151] <littledan>
OK, I'm convinced :)

[10:51:15.0439] <nicolo-ribaudo>
 * Or "This temperature check has been worded terribly I don't understand what the options mean in this case" üòõ

[10:51:25.0428] <littledan>
the most important thing is to have something stronger than unconvinced, so that unconvinced becomes less harsh, I think

[10:57:14.0993] <nicolo-ribaudo>
Ughh I just noticed that I forgot to add slides to one of my topics on the agenda (a status update)

[10:57:26.0116] <Michael Ficarra>
this is enough change in the proposal that, even Wednesday, I don't think I'd be prepared to advance to 2.7

[10:57:26.0547] <nicolo-ribaudo>
 * Ughh I just noticed that I forgot to add slides to one of my topics on the agenda (a status update) -- I'm sorry

[10:57:41.0666] <ljharb>
100% agreed

[10:58:06.0556] <ljharb>
maybe with just one of these changes, but with 2 or 3 i'd rather wait

[10:58:50.0013] <Michael Ficarra>
to be clear, I think they're all good improvements, but I'd want to review it as a whole again

[11:00:31.0247] <ljharb>
yep, i've unchecked all the signoffs so i know to re-ask

[11:00:42.0656] <ljharb>
btw for the steno, can we get them to stop double spacing after periods?

[11:01:18.0285] <Michael Ficarra>
they're also inserting newlines at the page width instead of letting it wrap üò≠

[11:02:17.0713] <nicolo-ribaudo>
"Can you please set your line width to 100_000_000?"

[11:02:43.0350] <ljharb>
both of those, yes please

[11:03:15.0141] <littledan>
we've asked the stenographers to do this before. They should be doing it. I'll call them today.

[11:03:27.0536] <littledan>
They've fixed this in the past, it's just that not all of them do it

[11:25:27.0279] <bakkot>
waldemar: On the topic of RegExp escapes, what escaping do you think we ought to use for null bytes? We have `\0`, but `\x00` is plenty readable, and `\0` has the complication that you can't use it if the next character is an ASCII digit. My inclination is to use `\x00`.

[11:56:29.0626] <Michael Ficarra>
should `microwait` be called `microWait`?

[11:58:54.0669] <bakkot>
should "kilogram" be spelled "kiloGram"?

[12:00:52.0828] <Michael Ficarra>
if it was a JS API? probably

[12:01:03.0838] <bakkot>
nooooo

[12:01:14.0277] <bakkot>
we use camel case when it's two words

[12:01:21.0453] <bakkot>
but "micro" is a prefix, not a new word

[12:01:47.0696] <nicolo-ribaudo>
`setTimeOut`

[12:03:47.0535] <nicolo-ribaudo>
Feedback about WebEx: much better than zoom

[12:04:04.0285] <shu>
i liked how it had a light mode

[12:04:07.0488] <shu>
down with dark mode!!

[12:04:11.0315] <Michael Ficarra>
much better than I expected, about the same as zoom

[12:04:11.0484] <ryzokuken>
please qualify better better.

[12:04:11.0796] <bakkot>
it is literally indistinguishable afacit

[12:04:24.0283] <nicolo-ribaudo>
In Zoom I always have audio issues

[12:04:30.0244] <nicolo-ribaudo>
It never works the first time

[12:04:41.0866] <shu>
is this a zoom problem or is this "year of linux on the desktop" problem

[12:04:52.0340] <ptomato>
video/screenshare entirely didn't work on firefox for me, so webex is a üëéÔ∏è from me

[12:05:03.0336] <nicolo-ribaudo>
> <@shuyuguo:matrix.org> is this a zoom problem or is this "year of linux on the desktop" problem

A year of firefox problem üòõ

[12:05:07.0476] <Michael Ficarra>
it only allowed you to share "apps", not windows, so if I changed which Chrome window was focused, it would share that one instead

[12:05:11.0874] <ryzokuken>
IMO the web version was nicer than zoom and thus I had no reason to even attempt to use the native (apropos the parens thingie that was weird) and zoom's native version just takes years off my life

[12:05:13.0098] <nicolo-ribaudo>
> <@pchimento:igalia.com> video/screenshare entirely didn't work on firefox for me, so webex is a üëéÔ∏è from me

Oh weird, I had zero problems with it

[12:05:25.0322] <nicolo-ribaudo>
> <@usharma:igalia.com> IMO the web version was nicer than zoom and thus I had no reason to even attempt to use the native (apropos the parens thingie that was weird) and zoom's native version just takes years off my life

Oh yes, I use the web version for both

[12:05:31.0690] <nicolo-ribaudo>
Long live the web

[12:06:16.0136] <ryzokuken>
> <@usharma:igalia.com> IMO the web version was nicer than zoom and thus I had no reason to even attempt to use the native (apropos the parens thingie that was weird) and zoom's native version just takes years off my life

but I'd clarify that calling zoom not working hard enough on their linux app a linux problem is unfair

[12:06:35.0866] <ryzokuken>
like other native video conferencing apps exist, many of them are electron based and still do a vastly better job

[13:17:37.0105] <ljharb>
> <@michaelficarra:matrix.org> it only allowed you to share "apps", not windows, so if I changed which Chrome window was focused, it would share that one instead

mine, from chrome, let me choose which specific chrome tab i wanted to share

[13:17:41.0839] <ljharb>
> <@michaelficarra:matrix.org> it only allowed you to share "apps", not windows, so if I changed which Chrome window was focused, it would share that one instead

 * mine, from chrome, let me choose which specific chrome tab i wanted to share (zoom does also)

[13:30:12.0215] <ptomato>
I think that's a chrome/chromium-specific feature

[16:10:10.0622] <waldemar>
> <@bakkot:matrix.org> waldemar: On the topic of RegExp escapes, what escaping do you think we ought to use for null bytes? We have `\0`, but `\x00` is plenty readable, and `\0` has the complication that you can't use it if the next character is an ASCII digit. My inclination is to use `\x00`.

I didn't ask that question, but I did notice that non-whitespace control characters weren't escaped. I thought that was deliberate, but escaping them would be a worthwhile change for readability. I agree with `\x00` for the reasons you state.


2024-04-09
[06:52:32.0959] <ryzokuken>
good morning/evening/night everyone!

[06:52:36.0888] <ryzokuken>
meeting starts in ~7

[07:29:19.0744] <littledan>
I have trouble understanding the motivation for this null change, but also it doesn't seem harmful

[07:29:55.0863] <littledan>
(or rather, I have trouble understanding the motivation for the null skipping in the first place)

[07:30:39.0976] <nicolo-ribaudo>
Random fact: Babel accidentally ignores `null`s while guaranteeing at least one `await` -- we have a PR open to match the behavior of the current (pre-this-change) proposal

[07:35:07.0570] <hax (HE Shi-Jun)>
It seems this PR try to avoid nulls introducing extra awaits, am I understanding this correctly?

[07:35:17.0535] <nicolo-ribaudo>
Yes

[07:37:51.0235] <shu>
this is a small thing, but i'd be interested in people's thoughts on banning `using` inside base switch cases: https://github.com/tc39/proposal-explicit-resource-management/issues/215#issuecomment-2040486653

[07:39:23.0609] <nicolo-ribaudo>
Babel's `using` support in `switch` is currently completely broken

[07:39:42.0017] <nicolo-ribaudo>
Because everything in `switch` is incredibly annoying to compile

[07:39:57.0272] <shu>
i wanna ban it but recognize that'll break symmetry with let/const

[07:40:52.0756] <nicolo-ribaudo>
Is it for implementation reasons?

[07:41:54.0326] <shu>
it's laid out in the comment -- saves some codegen complexity

[07:42:36.0729] <shu>
we can unroll the dispose loop in all cases except switch cases

[07:44:25.0497] <nicolo-ribaudo>
I'm trying to think of any usecase for `using` in switch, but I cannot think of any where I would want `using`'s scope to fall through multiple cases

[07:46:00.0809] <nicolo-ribaudo>
(Babel doesn't unroll the loop anymore, so for us it wouldn't actually be difficult to fix `using` in `switch`)

[07:46:39.0248] <shu>
we don't unroll currently, but would like to

[07:50:26.0532] <rbuckton>
> <@nicolo-ribaudo:matrix.org> I'm trying to think of any usecase for `using` in switch, but I cannot think of any where I would want `using`'s scope to fall through multiple cases

The most relevant case I can see would be something like manual loop unrolling, where you skip over the `using` for a chunk of operations when it isn't needed, such as if a lock was needed for a 16k chunk of data that isn't needed for a smaller chunk of data. The point of manual loop unrolling is to avoid a bunch of comparisons and branches based on a single condition such as input size, so a smaller chunk of data skips over the `using` (and avoids the extraneous `null`/`undefined` check), while a larger chunk of data enforces the `using` and holds the lock until the current iteration of the loop ends.

[07:52:52.0530] <nicolo-ribaudo>
Oh I see, like for transpiling generators

[07:53:13.0016] <nicolo-ribaudo>
(in a world where generators are transpiled and `using` is not I guess)

[07:53:51.0282] <rbuckton>
```js
for (let start = 0; start < len; start += 8) {
    switch (start % 8) {
        case 0:
          // full chunk, perform lock
          using lck = new UniqueLock(mut);
          readByte();
        case 1: readByte();
        case 2: readByte();
        case 3: readByte();
        case 4: readByte();
        case 5: readByte();
        case 6: readByte();
        case 7: readByte();
    } // lock released if taken
}
```

[07:56:40.0590] <rbuckton>
not for transpiling generators, no. that would be using a `switch` as a finite state machine, but an FSM would result in the `using` terminating early. Loop unrolling in this case is to handle chunks of data without continuously spinning and checking in the `for` to process one element at a time and cutting down the number of comparisons/branching from n to 1/n for a given chunk size of n.

[07:58:31.0396] <rbuckton>
 * not for transpiling generators, no. that would be using a `switch` as a finite state machine, but an FSM would result in the `using` terminating early. Loop unrolling in this case is to handle chunks of data without continuously spinning and checking in the `for` to process one element at a time and cut down the number of comparisons/branching from n to 1/n for a given chunk size of n.

[08:25:18.0882] <littledan>
If we could get to Ashley's point, he can explain why TLA running eagerly is useful within Bloomberg

[08:26:40.0529] <hax (HE Shi-Jun)>
tla already can break expectations...

[08:29:10.0363] <ljharb>
certainly a TLA being added anywhere in your graph is a breaking change

[08:29:20.0562] <littledan>
The thing is: in practice, you really shouldn't use JSON or CSS modules either, due to the lack of built-in bundling. The limited utility of built-in modules is not at all limited to this feature

[08:29:46.0958] <bakkot>
this strongly suggests to me that we need a path to standardize bundler-only syntax

[08:29:48.0867] <littledan>
until then, we'll be talking about features that are mostly useful for bundlers and non-web environments

[08:29:55.0338] <ljharb>
 * certainly a TLA being added anywhere in your graph (that's not an entrpoint) is a breaking change

[08:30:13.0856] <littledan>
> <@bakkot:matrix.org> this strongly suggests to me that we need a path to standardize bundler-only syntax

I disagree; I think we should fix the issues to allow native modules to be usable in browsers

[08:30:27.0596] <shu>
i disagree with that disagree

[08:30:32.0747] <shu>
doesn't seem a good use of resources tbh

[08:31:06.0008] <bakkot>
> <@littledan:matrix.org> I disagree; I think we should fix the issues to allow native modules to be usable in browsers

That is also good! And then, after that, standardizing things like this everywhere instead of bundler-only. But not before that.

[08:31:13.0688] <littledan>
these are all arguments against ES6 modules in the first place

[08:31:22.0335] <bakkot>
*cough*

[08:31:31.0248] <bakkot>
I mean, yes.

[08:31:36.0224] <bakkot>
But that ship has sailed.

[08:31:45.0035] <ljharb>
you're soooo close

[08:31:53.0368] <rbuckton>
bundler-related, but could `import defer` potentially avoid fetch and parse as well if we could serialize the import graph on the server side ahead of time?

[08:32:03.0172] <hax (HE Shi-Jun)>
In Jack's "assert sync" proposal I suggest we can also add "use async" directive which might help to make TLA explicit. Maybe it also help this issue.

[08:32:16.0253] <littledan>
well, yeah, so this would be good input to the module harmony group, if we don't like modules features anymore...

[08:32:19.0410] <bakkot>
I think standardizing ES6 modules as bundler-only syntax would have been better than the current world

[08:32:33.0030] <rbuckton>
or is that not an option because fetch is async

[08:33:28.0283] <bakkot>
> <@littledan:matrix.org> well, yeah, so this would be good input to the module harmony group, if we don't like modules features anymore...

`import source` is useful on the web!

[08:33:45.0613] <bakkot>
so it's not "module features" in general, just those specific ones which aren't useful on the web

[08:34:11.0898] <Justin Ridgewell>
/me Taking over Chair responsibilities for a bit

[08:34:12.0251] <bakkot>
(possibly "[...] aren't useful on the web _yet_")

[08:34:29.0614] <littledan>
I think the Matrix results show that it's useful on the web *in practice*

[08:34:53.0125] <littledan>
It's a good thing that bundlers are aligned to TC39 and browsers in their syntax and semantics. It will be good for us to preserve that.

[08:35:07.0286] <Ashley Claymore>
> <@rbuckton:matrix.org> bundler-related, but could `import defer` potentially avoid fetch and parse as well if we could serialize the import graph on the server side ahead of time?

yep. That's what we do at Bloomberg. We find the TLA at build time. And add a simplified module graph of which imports have TLA deps to our equivalent of 'package.json'

[08:35:09.0814] <bakkot>
IIUC the Matrix results show that it's useful on the web to have bundler-level syntax for this, but not that it's useful to have in browsers, right?

[08:35:22.0291] <littledan>
we've made tons of progress by actually building things into JS; the code splitting situation was a mess before import(), and it resulted in code splitting not occurring.

[08:35:30.0794] <bakkot>
I am not proposing "give up on this"; I am proposing "have a path to standardize bundler-level syntax that isn't actually in browsers"

[08:35:40.0746] <littledan>
TC39 is the JavaScript standards committee--our role is to find this common syntax

[08:36:27.0193] <littledan>
once we find common syntax, it's OK if some implementations fall behind and don't implement everything, but it'd be a big cost to split the language in two

[08:36:33.0100] <bakkot>
my response is the thing Shu is saying out loud right now

[08:36:54.0555] <littledan>
we should have this as an actual agenda item; that'd make it easier to discuss

[08:39:05.0549] <littledan>
IMO Stage 3 serves this purpose of "it's in tools and not necessarily in browsers". Maybe we just want to leave things in Stage 3 for longer.

[08:39:36.0712] <bakkot>
fwiw eslint refuses to implement features prior to stage 4, though that's maybe a them problem

[08:41:07.0294] <ljharb>
stage 3 is when it gets shipped in browsers tho

[08:41:10.0342] <ljharb>
 * stage 3 is when it gets shipped in (most) browsers tho

[08:42:48.0786] <shu>
John-David Dalton: why is it disingenuous? this is arguably _better_ handled by tools. tools have a different view (they can see the whole app) and optimization opportunities than a VM

[08:43:14.0638] <shu>
we designed a super static module system. it is not surprising to me that it has been leveraged to success with ahead-of-time tooling

[08:44:10.0049] <littledan>
> <@bakkot:matrix.org> fwiw eslint refuses to implement features prior to stage 4, though that's maybe a them problem

well, there's babel-eslint

[08:46:23.0828] <ljharb>
(`@babel/eslint-parser` as of babel 7)

[08:47:03.0198] <littledan>
> <@ljharb:matrix.org> stage 3 is when it gets shipped in (most) browsers tho

IMO browsers *should* ship features like this at that point, but if they want to leave some features out of browsers for now (but we still assess that the feature is solid enough for Stage 3), maybe they can just let them sit in that bucket. Doesn't require holding back 2.7 or 3.

[08:47:22.0696] <littledan>
> <@ljharb:matrix.org> stage 3 is when it gets shipped in (most) browsers tho

 * I'd be happiest if browsers ship features like this at that point, but if they want to leave some features out of browsers for now (but we still assess that the feature is solid enough for Stage 3), maybe they can just let them sit in that bucket. Doesn't require holding back 2.7 or 3.

[08:47:33.0695] <ljharb>
3 is a pretty clear signal, that's the big purpose of 2.7. i agree it wouldn't require holding back 2.7

[08:48:23.0429] <Michael Ficarra>
so is this feature going to encourage the dreaded "barrel" module pattern?

[08:48:36.0398] <littledan>
> <@michaelficarra:matrix.org> so is this feature going to encourage the dreaded "barrel" module pattern?

it's about optimizing the feature--no encouragement is needed

[08:48:44.0114] <bakkot>
While that's technically true, I would be happier revising our process if we want to do that - I would prefer that stage 2.7/3 be taken as a commitment from browsers to implement a feature at some point. I don't want to get to a point where browsers allow features to reach 2.7 that they intend to never implement.

[08:49:04.0020] <shu>
agree

[08:49:09.0469] <shu>
the two design spaces are honestly different

[08:49:14.0285] <shu>
the constraints are different

[08:49:17.0420] <ljharb>
> <@michaelficarra:matrix.org> so is this feature going to encourage the dreaded "barrel" module pattern?

oof, i hadn't thought about that.

[08:49:29.0454] <littledan>
> <@bakkot:matrix.org> While that's technically true, I would be happier revising our process if we want to do that - I would prefer that stage 2.7/3 be taken as a commitment from browsers to implement a feature at some point. I don't want to get to a point where browsers allow features to reach 2.7 that they intend to never implement.

ah OK well I'm happy to get browser commitments like that; I don't want to discourage that. I haven't thought this through enough.

[08:49:54.0372] <Michael Ficarra>
> <@littledan:matrix.org> it's about optimizing the feature--no encouragement is needed

well it doesn't provide any benefit to those not using the pattern, so it seems like encouragement to use it

[08:50:06.0567] <shu>
littledan: i have been thinking about for most of this year, i'll give you something more thought out soon

[08:51:05.0282] <littledan>
> <@michaelficarra:matrix.org> well it doesn't provide any benefit to those not using the pattern, so it seems like encouragement to use it

I think you're overthinking it... there's a lot of existing usages of this pattern, and it's slow, and it is hard to migrate away from (a lot of effort has gone into this migration)

[08:51:20.0789] <littledan>
it's not about newly incentivizing usage

[08:51:54.0139] <Michael Ficarra>
so someone who wants to get similar tree-shakeability can just dump this pattern?

[08:52:24.0635] <littledan>
> <@michaelficarra:matrix.org> so someone who wants to get similar tree-shakeability can just dump this pattern?

sure, if you can get all your dependencies to dump this pattern, then you'll have no reason to use this pattern in your dependency tree

[08:52:44.0025] <littledan>
> <@michaelficarra:matrix.org> so someone who wants to get similar tree-shakeability can just dump this pattern?

 * sure, if you can get all your dependencies to dump this pattern, then you'll have no reason to use this feature in your dependency tree

[08:52:59.0639] <ljharb>
there's a growing group of vocal folks in the ecosystem telling people to get rid of barrel modules, fwiw

[08:53:18.0876] <ljharb>
(coinbase's RN app's binary size dropped 71% when we banned barrel exports)

[08:53:40.0499] <ljharb>
 * (coinbase's RN app's binary size dropped 71% when we/they banned barrel exports back in 2021)

[08:53:52.0538] <littledan>
> <@ljharb:matrix.org> there's a growing group of vocal folks in the ecosystem telling people to get rid of barrel modules, fwiw

yes, they're doing good work; I think those two groups (the ecosystem effort and this proposal) should be understood to be supporting each other

[08:54:42.0621] <ljharb>
even with import defer, barrel exports will still result in a larger app than "just import what you need directly", no?

[08:54:53.0357] <bakkot>
I don't think "this feature is not useful in browsers" is a new category of objection?

[08:54:57.0161] <bakkot>
that's like... the main objection

[08:55:03.0284] <Michael Ficarra>
can someone remind me why people ever did that in the first place?

[08:55:23.0889] <ljharb>
i don't know why people tend to like "god objects"

[08:55:44.0526] <ljharb>
 * i don't know why people tend to like "god objects", deep imports is The Way

[08:55:53.0557] <ljharb>
 * i don't know why people tend to like "god objects", deep imports is The Way. but they do tend to like them.

[08:56:02.0865] <ptomato>
maybe the pattern was copied from python modules and `__init__.py`?

[08:56:08.0294] <littledan>
> <@michaelficarra:matrix.org> can someone remind me why people ever did that in the first place?

I always understood it to be a response to named exports being a thing, making use of that syntactic space, whereas require returning a single function was more natural

[08:56:16.0208] <ljharb>
i've seen people have a visceral preference for one `import` keyword that has N identifiers, instead of N `import` keywords

[08:56:44.0865] <shu>
> <@bakkot:matrix.org> that's like... the main objection

yeah i feel like most of our concerns that have caused feature compromises and redesigns boil down to this. sometimes it's couched in more specific terms, like "performance footgun" etc

[08:56:59.0201] <Michael Ficarra>
I'm finding it very hard to find sympathy for these people...

[08:57:00.0961] <ljharb>
also i think that a number of major IDEs implemented auto-refactoring features for named exports but ignored default exports

[08:57:06.0477] <ljharb>
 * also i think that a number of major IDEs implemented auto-refactoring features for named exports but ignored default exports (for no technical reason)

[08:57:15.0173] <ljharb>
 * also i think that a number of major IDEs implemented auto-refactoring features for named exports but ignored default exports (for no technical reason) which drove increased usage of named exports

[08:57:26.0804] <littledan>
> <@michaelficarra:matrix.org> I'm finding it very hard to find sympathy for these people...

why does it matter whose fault this is? it's currently a performance issue, and this is a solution.

[08:58:01.0118] <ljharb>
but is "don't use barrel files" perhaps a better solution?

[08:58:08.0095] <ljharb>
 * but is "don't use barrel files" perhaps a better solution? (genuine question)

[08:58:53.0606] <Justin Ridgewell>
Barrels are so convenient, and so awful for performance (both browsers and bundlers)

[08:58:56.0043] <littledan>
I dunno, there's a lot of recommendations about performance that people aren't taking up...

[08:59:24.0498] <Justin Ridgewell>
@guybedford:matrix.org Your mic is echoing

[08:59:47.0003] <bakkot>
but wouldn't this be a recommendation for performance in exactly the same way? it requires work to adopt; it doesn't just give you performance for free

[08:59:59.0606] <ryzokuken>
sorry guybedford bad timing

[09:00:06.0237] <Justin Ridgewell>
Timebox!

[09:00:09.0827] <bakkot>
and if the people in question were willing to do work to get performance they already can already do so, right?

[09:01:13.0988] <Michael Ficarra>
@nicolo-ribaudo:matrix.org your async feedback from me is that, for now, I'm unconvinced by the motivation

[09:01:30.0332] <ljharb>
> <@jridgewell:matrix.org> Barrels are so convenient, and so awful for performance (both browsers and bundlers)

convenience often makes for better paving than good intentions

[09:01:48.0748] <littledan>
> <@bakkot:matrix.org> but wouldn't this be a recommendation for performance in exactly the same way? it requires work to adopt; it doesn't just give you performance for free

The uptake is a "semver-minor" change--it doesn't require that importers update

[09:02:09.0563] <ljharb>
> <@jridgewell:matrix.org> Barrels are so convenient, and so awful for performance (both browsers and bundlers)

 * convenience often makes for better road-paving than good intentions

[09:03:04.0365] <ljharb>
so importers keep thinking they're doing a fine thing, when they're doing a horrible thing, and the entire ecosystem has to move to `import defer` to avoid the education problem?

[09:03:41.0791] <ljharb>
education's super hard so maybe that's the right tradeoff to make, tbf

[09:10:02.0762] <nicolo-ribaudo>
> <@bakkot:matrix.org> but wouldn't this be a recommendation for performance in exactly the same way? it requires work to adopt; it doesn't just give you performance for free

It moves the changes from the consumers to the library itself

[09:10:08.0224] <nicolo-ribaudo>
So 1 instead of N

[09:10:47.0173] <nicolo-ribaudo>
> <@ljharb:matrix.org> so importers keep thinking they're doing a fine thing, when they're doing a horrible thing, and the entire ecosystem has to move to `import defer` to avoid the education problem?

There is currently a choice to make between convenience and performance, and the goal here is to not make them exclusive

[09:43:07.0539] <ljharb>
does using `import defer` on a barrel file with a bundler that supports it give the ~same results as using deep imports in the first place?

[09:43:31.0739] <ljharb>
 * does using `import defer` on a barrel file with a bundler that supports it give the ~same results as using deep imports in the first place? because treeshaking so far still doesn't fully achieve "only importing what you need in the first place" afaik.

[09:46:05.0602] <Michael Ficarra>
in a language without so many hidden effects all over the place, it would be

[09:49:25.0896] <nicolo-ribaudo>
> <@ljharb:matrix.org> does using `import defer` on a barrel file with a bundler that supports it give the ~same results as using deep imports in the first place? because treeshaking so far still doesn't fully achieve "only importing what you need in the first place" afaik.

Sorry no, it's `export defer`/`export optional` that helps with barrel files

[09:49:50.0264] <nicolo-ribaudo>
And `export defer` would have the same result as using deep imports

[09:50:02.0350] <ljharb>
ok, so that's a compelling argument in favor of that one

[09:51:34.0893] <ljharb>
so `import defer` would be to lessen the downside of importing a barrel file that did not use `export defer`?

[09:52:04.0637] <nicolo-ribaudo>
And the boundary is still at the `export defer` level, so if you do
```js
// main.js
import { x } from "library;

// library
export defer { x, y } from "./x-and-y";
export defer { z } from "./z";

// library/x-and-y
export const x = 1;
export const y = 2;
```

it will also load `y` (so it's not complete dead code elimination), but gives the building block to remove code if you put unrelated code in separate modules

[09:52:09.0264] <nicolo-ribaudo>
 * And the boundary is still at the `export defer` level, so if you do

```js
// main.js
import { x } from "library";

// library
export defer { x, y } from "./x-and-y";
export defer { z } from "./z";

// library/x-and-y
export const x = 1;
export const y = 2;
```

it will also load `y` (so it's not complete dead code elimination), but gives the building block to remove code if you put unrelated code in separate modules

[09:52:39.0112] <nicolo-ribaudo>
 * And the boundary is still at the `export defer` level, so if you do

```js
// main.js
import { x } from "library";

// library
export defer { x, y } from "./x-and-y";
export defer { z } from "./z";

// library/x-and-y
export const x = 1;
export const y = 2;
```

it will also load/run the code for `const y = 2` (so it's not complete dead code elimination), but gives the building block to remove code if you put unrelated code in separate modules

[09:52:55.0016] <nicolo-ribaudo>
Exactly like deep imports

[09:53:14.0206] <nicolo-ribaudo>
> <@ljharb:matrix.org> so `import defer` would be to lessen the downside of importing a barrel file that did not use `export defer`?

`import defer` is not really related to barrel file

[09:53:28.0915] <nicolo-ribaudo>
It's in general for "big modules subgraphs"

[09:53:40.0275] <nicolo-ribaudo>
Even if you have a file with a single export but many dependencies, `import defer` is useful there

[09:54:00.0084] <littledan>
One thing that's important to understand is, the barrel file stuff doesn't relate to the motivation for `import defer`--they solve for totally unrelated issues, just both about loading less code

[10:14:46.0864] <littledan>
Agree with the various arguments for minimalism here, we just don't have any reason to go into this fractional stuff or BigInts, and IsSafeInteger is a good test.

[10:16:38.0985] <Michael Ficarra>
I agree with Kevin that this isn't especially confusing

[10:17:57.0970] <littledan>
 * <del>Agree with the various arguments for minimalism here, we just don't have any reason to go into this fractional stuff or BigInts, and IsSafeInteger is a good test.</del> I don't have a strong opinion about any of this and am just happy for range to happen

[10:18:06.0226] <Michael Ficarra>
is there maybe justification to have this produce its own iterator subclass that can have optimised helpers implemented on it?

[10:18:33.0888] <Michael Ficarra>
like `.drop(1e300)` could be implemented very efficiently for this special iterator

[10:19:07.0346] <bakkot>
I think `drop` and `take` are the only things which could have better implementations and I don't think it's worth doing just for those

[10:19:38.0502] <bakkot>
and engines could do this optimization anyway

[10:20:16.0703] <hax (HE Shi-Jun)>
The original proposal includes `BigInt.range()`, don't remember why it is added in first place

[10:20:25.0275] <Bradford Smith>
I might expect to be able to use `Iterator.range()` to generate unique identifiers, in which case possibly a BigInt type is desirable.

[10:21:10.0762] <hax (HE Shi-Jun)>
> <@bradfordcsmith:matrix.org> I might expect to be able to use `Iterator.range()` to generate unique identifiers, in which case possibly a BigInt type is desirable.

seems a valid use case :P

[10:21:11.0214] <Michael Ficarra>
to waldemar's point, yes, there are some editorial bugs, but nothing that's not fixable

[10:21:21.0391] <Michael Ficarra>
it hasn't passed editorial review yet

[10:21:35.0623] <shu>
> <@bradfordcsmith:matrix.org> I might expect to be able to use `Iterator.range()` to generate unique identifiers, in which case possibly a BigInt type is desirable.

oh yeah?

[10:21:56.0277] <shu>
like, give me monotonic ids starting with <large number> or something?

[10:22:19.0093] <ljharb>
i have no bigint range use cases, but "works for one kind of numeric primitive and not the others" seems like a big problem

[10:22:55.0359] <Bradford Smith>
> <@shuyuguo:matrix.org> like, give me monotonic ids starting with <large number> or something?

yes, something like that

[10:23:28.0592] <Justin Ridgewell>
Are bigints still massively slower than numbers?

[10:23:31.0141] <rbuckton>
I'd prefer it work for bigint just so I'm not having to coerce using `BigInt()` when I need to do math with other bigints.

[10:23:31.0609] <shu>
> <@ljharb:matrix.org> i have no bigint range use cases, but "works for one kind of numeric primitive and not the others" seems like a big problem

why is that a big problem?

[10:23:36.0139] <shu>
> <@jridgewell:matrix.org> Are bigints still massively slower than numbers?

haha yes

[10:23:51.0728] <danielrosenwasser>
Mathieu Hofman: can you add yourself to the notes?

[10:23:57.0368] <ljharb>
it's an inconsistency. one of those warts we'd inevitably have to make a "fill in the table" proposal for in a few years.

[10:23:59.0128] <eemeli>
Timestamps in microseconds as a use case?

[10:24:26.0548] <ljharb>
it's fine if we want to wait for that, but is there a reason why it's beneficial to defer it?

[10:24:28.0683] <shu>
> <@ljharb:matrix.org> it's an inconsistency. one of those warts we'd inevitably have to make a "fill in the table" proposal for in a few years.

not everyone shares that goal though

[10:24:53.0581] <ljharb>
that is true of most of the goals we all have :-)

[10:25:09.0283] <shu>
right, which is why i pushed back on "seems like a big problem"

[10:25:19.0072] <bakkot>
it's not that inconsistent - the Math methods do not and never will take Numbers

[10:25:23.0971] <bakkot>
 * it's not that inconsistent - the Math methods do not and never will take BigInts

[10:25:35.0052] <shu>
in any case i was given a concrete use case i found plausible

[10:25:38.0744] <bakkot>
in fact I don't think we have _anything_ that takes only Number of BigInt?

[10:25:39.0682] <shu>
so i'm happy with bigints being accepted here

[10:25:53.0572] <bakkot>
but yeah I also prefer accepting BigInt here

[10:26:13.0522] <ptomato>
> <@eemeli:mozilla.org> Timestamps in microseconds as a use case?

I think the idea was to introduce Temporal.Instant ranges for this use case in the future

[10:28:10.0892] <nicolo-ribaudo>
> <@pchimento:igalia.com> I think the idea was to introduce Temporal.Instant ranges for this use case in the future

Maybe `Iterator.range(instant1, instant2, duration)` if `range` is overloaded anyway

[10:28:15.0922] <nicolo-ribaudo>
> <@pchimento:igalia.com> I think the idea was to introduce Temporal.Instant ranges for this use case in the future

 * Maybe `Iterator.range(instant1, instant2, duration)` if `range` is overloaded anyway?

[10:28:41.0761] <Jack Works>
> <@bradfordcsmith:matrix.org> I might expect to be able to use `Iterator.range()` to generate unique identifiers, in which case possibly a BigInt type is desirable.

can you explain this use case more? I think unique id should be something like crypto.getRandomUUID()

[10:29:17.0689] <shu>
might not need to be unique

[10:29:36.0590] <ljharb>
also autoincrementing is fine sometimes, not everything has the german tank problem

[10:30:00.0346] <nicolo-ribaudo>
Python bans floats in range() right?

[10:30:46.0389] <ptomato>
right

[10:32:40.0106] <ptomato>
python's popular computing library has `numpy.arange()` which does suffer from unexpected iterations due to floating point errors, and `numpy.linspace()` which does not

[10:33:08.0960] <Jesse>
...decimal.

[10:33:58.0185] <bakkot>
I do like linspace 

[10:34:13.0086] <bakkot>
the options object does leave room for it

[10:34:57.0125] <nicolo-ribaudo>
You can just use a range of integers and .map for what Matthew is proposing, right?

[10:35:02.0238] <Michael Ficarra>
FWIW it would be nice to have extra time to iron out all the editorial issues as well

[10:35:09.0610] <Michael Ficarra>
then we can have a really solid 2.7 advancement

[10:36:23.0494] <Bradford Smith>
I'll definitely +1 this feature either with or without fractional values.

[10:36:39.0158] <bakkot>
same though I do prefer accepting fractional values

[10:36:52.0090] <bakkot>
but if left out it's not the end of the world

[10:41:01.0148] <hax (HE Shi-Jun)>
> <@bakkot:matrix.org> the options object does leave room for it

I think linspace should be a separate method?

[10:41:30.0943] <Michael Ficarra>
even 2-4x slower must still be faster than `.reduce((a, b) => a + b, -0)`

[10:43:58.0486] <hax (HE Shi-Jun)>
As the original author of range floating issue, I prefer not accepting franctional values , and change the name from`Iterator.range` to `Iterator.integers` which make it even more clear to developers üòâ 

[10:44:38.0306] <Michael Ficarra>
`intRange`

[10:46:34.0236] <hax (HE Shi-Jun)>
Do people also need `ProductExact()` ?

[10:46:51.0683] <littledan>
I can't understand the difference in precision/exactitude between precise and exact in this case... can anyone else?

[10:47:42.0675] <eemeli>
I think "precise" applies to all numbers. So `0.1 + 0.2` has a precise value, it's just not exactly `0.3`.

[10:47:45.0962] <shu>
kinda, i guess there is a notion of "low precision" vs "high precision" that's more commonly used than "low exactitude" vs "high exactitude"

[10:47:56.0832] <shu>
but in this particular case i don't really understand

[10:47:59.0640] <eemeli>
"Accurate" would be more... accurate.

[10:48:21.0363] <hax (HE Shi-Jun)>
> <@littledan:matrix.org> I can't understand the difference in precision/exactitude between precise and exact in this case... can anyone else?

It just avoid some loss and more close to exact number?

[10:48:23.0882] <littledan>
> <@eemeli:mozilla.org> I think "precise" applies to all numbers. So `0.1 + 0.2` has a precise value, it's just not exactly `0.3`.

huh? but we're starting with Numbers, not those funny things that we don't have a representation of in JS

[10:49:04.0788] <littledan>
> <@shuyuguo:matrix.org> kinda, i guess there is a notion of "low precision" vs "high precision" that's more commonly used than "low exactitude" vs "high exactitude"

OK but it's not like we have a precision arg here... it's just supposed to get the right answer

[10:49:12.0294] <littledan>
right?

[10:49:22.0826] <shu>
right, in this particular case i don't understand the difference

[10:49:41.0299] <shu>
if it were up to me i'd name it sumSlow

[10:50:13.0140] <shu>
like i would totally believe that if kevin's slides said "this is named sumPrecise, but it may give the wrong impression", someone will then say "sumExact is better"

[10:50:15.0934] <eemeli>
To be clear, I'm fine with sumExact as a least worst option.

[10:50:53.0161] <Jack Works>
> <@nicolo-ribaudo:matrix.org> Maybe `Iterator.range(instant1, instant2, duration)` if `range` is overloaded anyway?

Yes, next follow on might be adding a new Symbol.rangeTo, and then range(a, b, options) where a is an object will do the following: `yield* a[Symbol.rangeTo](b, options)`, then you can add it on Temporal, Decimal (they're not primitive now) and your own class.

[10:51:01.0101] <Jack Works>
> <@nicolo-ribaudo:matrix.org> Maybe `Iterator.range(instant1, instant2, duration)` if `range` is overloaded anyway?

 * Yes, next follow on proposal might be adding a new Symbol.rangeTo, and then range(a, b, options) where a is an object will do the following: `yield* a[Symbol.rangeTo](b, options)`, then you can add it on Temporal, Decimal (they're not primitive now) and your own class.

[10:51:01.0197] <rbuckton>
Doesn't temporal use `from` ?

[10:51:12.0861] <littledan>
what name are we considering?

[10:52:16.0817] <Bradford Smith>
So, I guess we should go with `Math.sumPreciseFrom()`?

[10:52:33.0603] <Bradford Smith>
or not...

[10:52:37.0067] <bakkot>
it sounds like we are not doing `From` based on everyone else doesn't like it

[10:52:41.0303] <bakkot>
so `sumExact` or `sumPrecise`

[10:54:29.0625] <hax (HE Shi-Jun)>
> <@shuyuguo:matrix.org> if it were up to me i'd name it sumSlow

As I understand, it is not necessarily slow.

[10:54:42.0708] <danielrosenwasser>
dminor: can you clarify your last point in the notes?

[10:54:43.0245] <shu>
yeah it is?

[10:54:48.0756] <shu>
it's necessarily slow_er_

[10:54:50.0160] <nicolo-ribaudo>
I was going to say that I dislike `From` because it currently means "I'm creating something of this type from these other values". `Iterator.from` creates an iterator, `Array.from` an array, `Object.fromEntries` an object. If we wanted this to contain from it should be on number (`Number.fromSum`), but also Number is not a collection

[10:55:23.0762] <rbuckton>
Temporal uses `from` in many places and those functions do not take iterables, so I disagree with the Michael Ficarra 's statement that "everything named from takes an iterable"

[10:56:03.0724] <Mathieu Hofman>
> <@nicolo-ribaudo:matrix.org> You can just use a range of integers and .map for what Matthew is proposing, right?

It's not ergonomic at all: `range(start * stepDivider, end * stepDivider, stepMultipler) | map(x => x / stepDivider)`

[10:56:20.0889] <rbuckton>
> <@nicolo-ribaudo:matrix.org> I was going to say that I dislike `From` because it currently means "I'm creating something of this type from these other values". `Iterator.from` creates an iterator, `Array.from` an array, `Object.fromEntries` an object. If we wanted this to contain from it should be on number (`Number.fromSum`), but also Number is not a collection

Agreed. "Foo.from" does imply "takes an iterable", it imples "make a `Foo` from these inputs"

[10:56:28.0104] <rbuckton>
> <@nicolo-ribaudo:matrix.org> I was going to say that I dislike `From` because it currently means "I'm creating something of this type from these other values". `Iterator.from` creates an iterator, `Array.from` an array, `Object.fromEntries` an object. If we wanted this to contain from it should be on number (`Number.fromSum`), but also Number is not a collection

 * Agreed. "Foo.from" does not imply "takes an iterable", it imples "make a `Foo` from these inputs"

[10:57:42.0897] <littledan>
I'm having trouble understanding why we're bothering with an optimization for an error case

[10:57:46.0107] <Michael Ficarra>
I don't think arithmetic commutativity comes into play when we're talking about throwing, which is inherently not arithmetic

[10:58:10.0356] <Michael Ficarra>
@littledan:matrix.org an iterable of Number producing a NaN is not an error case?

[10:58:45.0358] <littledan>
I think NaN is kinda usually for error cases?

[10:59:05.0953] <littledan>
I get that it's within the domain of Numbers but.... when was the last time you wanted NaN to come up for you?

[10:59:08.0733] <Michael Ficarra>
at the business logic layer, maybe, but at this data processing layer, no

[10:59:38.0109] <dminor>
I have to drop, Eemeli and Matthew Gaudet will represent SpiderMonkey for the rest of the day.

[11:00:18.0622] <littledan>
> <@michaelficarra:matrix.org> at the business logic layer, maybe, but at this data processing layer, no

obviously we need a well-defined answer, but is this going to provide a meaningful speedup meaningfully often?

[11:00:38.0045] <Michael Ficarra>
yes, iterators can yield very many values

[11:01:04.0621] <Michael Ficarra>
a multi-hours' batch could be short-circuited immediately after starting instead of waiting until the end

[11:03:16.0007] <hax (HE Shi-Jun)>
> <@shuyuguo:matrix.org> it's necessarily slow_er_

As https://en.wikipedia.org/wiki/Pairwise_summation "Pairwise summation is the default summation algorithm in NumPy[8] and the Julia technical-computing language,[9] where in both cases it was found to have comparable speed to naive summation"

[11:04:22.0688] <danielrosenwasser>
eemeli: can you add yourself to the notes doc?

[11:09:51.0346] <Justin Ridgewell>
I had to miss the presentation, but why is empty list `-0`? (no opinion, just curious)

[11:10:11.0098] <shu>
it is the identity of floating point addition

[11:10:36.0658] <Michael Ficarra>
@jridgewell:matrix.org `Object.is(-0 + -0, -0)`

[11:10:58.0835] <shu>
(while +0 + -0 = +0)

[11:11:20.0612] <Justin Ridgewell>
Why is `-0` the starting point?

[11:11:32.0340] <Justin Ridgewell>
If I‚Äôm interpreting those correctly....

[11:11:32.0664] <shu>
what does starting point mean?

[11:11:57.0197] <Justin Ridgewell>
`let sum = -0; for (const i of array) sum += i`

[11:12:22.0686] <Michael Ficarra>
so that when `array` is `[-0]` you get the correct answer

[11:17:46.0171] <Duncan MacGregor>
The equality question feels very like the question of `==` on value types in Java.

[11:19:32.0485] <bakkot>
the slides will reference project Valhalla IIRC

[11:19:38.0459] <Michael Ficarra>
value types being the ones with lowercase names?

[11:19:43.0209] <bakkot>
(i.e. value objects for java)

[11:19:59.0459] <bakkot>
https://openjdk.org/projects/valhalla/

[11:24:22.0706] <Michael Ficarra>
this presentation is so well structured üòç

[11:25:58.0649] <bakkot>
I really like the composite object approach though I would not call them "CompositeKey"

[11:27:42.0113] <bakkot>
I linked a few userland implementations here: https://github.com/tc39/proposal-record-tuple/issues/387#issuecomment-2033531920 though I am sure there are others

[11:29:02.0219] <rbuckton>
Composite keys don't seem like a solution to case-insensitive Maps. I still strongly favor equals/hash.

[11:29:56.0465] <bakkot>
I think they solve a different problem - equals/hash doesn't let me write `groupBy` with the result of my comparator being a composite key (without doing a bunch of work)

[11:29:57.0684] <ptomato>
but uniqBy without CompositeKey would cover that use case, no?

[11:30:11.0763] <rbuckton>
i.e., `new Map([], { comparer: caseInsensitiveStringComparer }`

[11:30:28.0924] <Michael Ficarra>
@rbuckton:matrix.org it works fine, Unicode has case folding for tht

[11:30:51.0739] <rbuckton>
> <@bakkot:matrix.org> I think they solve a different problem - equals/hash doesn't let me write `groupBy` with the result of my comparator being a composite key (without doing a bunch of work)

Wouldn't you just do groupBy over anything you want?

[11:31:46.0331] <rbuckton>
> <@michaelficarra:matrix.org> @rbuckton:matrix.org it works fine, Unicode has case folding for tht

It's an extra allocation, likely thrown away, for any given key comparison. equals/hash is defined once and reused

[11:32:30.0079] <bakkot>
I don't know what that means? I am asking about, for example, I have a list of { name, employer, city } objects, and I want to collect them by `{ employer, city }`. with composite key that's just `Map.groupBy(vals, x => Tuple(x.employer, x.city))`. with equals/hash there's a bunch more ceremony 

[11:33:48.0586] <rbuckton>
I have already written a `groupBy` that uses `equals`/hash`, and an equaler that already does tuple structural equality. 

[11:34:57.0949] <rbuckton>
That library also supports `[Equatable.equals](obj)` and `[Equatable.hash]()` that can be used if an equaler is not provided, so a given composite key just builds on top of that.

[11:35:54.0406] <bakkot>
sure, it can certainly be done, there's just a bunch more ceremony

[11:36:11.0494] <rbuckton>
It is far more flexible, IMO. 

[11:36:35.0816] <bakkot>
it's just different

[11:36:39.0911] <bakkot>
it solves different problems

[11:36:50.0888] <rbuckton>
Having to turn everything into a `CompositeKey` seems like a lot more ceremony to me.

[11:37:01.0391] <eemeli>
Map.p.getImprecise, anyone?

[11:37:06.0158] <rbuckton>
`CompositeKey` can be built on equals/hash, the other is not true.

[11:37:43.0443] <bakkot>
`Map.groupBy(vals, x => Tuple(x.employer, x.city))` is very close to zero ceremony

[11:37:47.0700] <bakkot>
that's exactly how I think about the problem

[11:38:02.0084] <rbuckton>
Plus, AFAIK equals/hash is how every implementation implements maps natively, it's just not exposed to user code.

[11:40:25.0551] <rbuckton>
For that case, maybe. What about `map.set(key, value)` though? You have to write `map.set(new CompositeKey(foo.a, foo.b), value)` or `map.get(new CompositeKey(foo.a, foo.b))`. With equals/hash, you can set it up once and just do `map.set(foo, value)` or `map.get(foo)`.

[11:40:54.0638] <bakkot>
but if my map is not keyed by `foo`, I don't want it to behave that way?

[11:41:01.0683] <bakkot>
I want to use a composite key for that case

[11:41:02.0171] <ljharb>
with a Map constructor hook, you could set it up once too

[11:41:16.0022] <ljharb>
 * with a Map constructor hook, you could set it up once too with composite keys

[11:41:19.0943] <rbuckton>
You can use a composite key for that case, I'd like to *not* have to use composite key for all of the other cases.

[11:41:31.0916] <Mathieu Hofman>
> <@rbuckton:matrix.org> It is far more flexible, IMO.

it's a lot more risk prone

[11:41:35.0103] <rbuckton>
> <@ljharb:matrix.org> with a Map constructor hook, you could set it up once too with composite keys

The same is true for equals/hash.

[11:41:58.0424] <ljharb>
right. which is why it's not an argument in favor of either one.

[11:42:12.0066] <rbuckton>
> <@mhofman:matrix.org> it's a lot more risk prone

It's far more efficient. If I want to write a custom collection that employs a hashtable, I'd rather have it easier to compute a hash.

[11:43:02.0144] <sffc>
For the set comparator, it seems like a prototype method `[Symbol.setCompare]` would work, and if Record/Tuple implement that function, then R&T Set/Map semantics should just work

[11:43:09.0175] <bakkot>
> <@rbuckton:matrix.org> You can use a composite key for that case, I'd like to *not* have to use composite key for all of the other cases.

right that's what I mean by "they are different"

[11:43:14.0994] <Mathieu Hofman>
JS is a high level language, I don't want low level concept like computing hashes exposed to programmer, especially if they can cause erroneous executions if mishandled

[11:43:25.0984] <bakkot>
I'm not saying that we should have composite keys _instead of_ hash/equals, just that they solve different problems

[11:45:30.0646] <bakkot>
(I am _separately_ somewhat skeptical of hash/equals because of the concerns about inconsistency, especially since that seems like it might be a bug farm in engines themselves and not just programs. but that concern is unrelated to this.)

[11:50:02.0058] <Mathieu Hofman>
> <@sffc:mozilla.org> For the set comparator, it seems like a prototype method `[Symbol.setCompare]` would work, and if Record/Tuple implement that function, then R&T Set/Map semantics should just work

That means the collection correctness is dependent on the stable behavior of its values. I want to use a collection that is resilient against misbehaving values

[11:50:28.0218] <Mathieu Hofman>
> <@sffc:mozilla.org> For the set comparator, it seems like a prototype method `[Symbol.setCompare]` would work, and if Record/Tuple implement that function, then R&T Set/Map semantics should just work

 * That means the collection correctness is dependent on the stable behavior of its values. I want the ability to create a collection that is resilient against misbehaving values

[11:55:03.0753] <Duncan MacGregor>
+1 on pretty much everything rbuckton said.

[11:58:16.0417] <rbuckton>
> <@mhofman:matrix.org> That means the collection correctness is dependent on the stable behavior of its values. I want the ability to create a collection that is resilient against misbehaving values

If you do not trust the stability of your keys, then you could use a `CompositeKey` and pay the overhead for every get/set. If you do trust the stability of your keys, equals/hash lets you avoid that overhead.

[12:00:45.0527] <rbuckton>
I have a strong preference for fast, efficient JS. `CompositeKey` overhead does not seem fast/efficient.

[12:01:19.0339] <Mathieu Hofman>
> <@rbuckton:matrix.org> If you do not trust the stability of your keys, then you could use a `CompositeKey` and pay the overhead for every get/set. If you do trust the stability of your keys, equals/hash lets you avoid that overhead.

Not if the only way is for the collection to ask the value. My answer was to sffc who was proposing that

[12:01:51.0193] <rbuckton>
equals/hash does not preclude `CompositeKey`, but rather is the building block a `CompositeKey` could be built on. It's also the building block using a `Uri` as a key could be built on too.

[12:02:37.0781] <bakkot>
It's not something you could build `CompositeKey` on because `CompositeKey` has `===` equality

[12:02:46.0586] <bakkot>
and `===` will never invoke a userland `equals`

[12:03:22.0843] <shu>
i missed that there was a configuration of the new direction that has new objects that have special ===?

[12:03:28.0265] <rbuckton>
If we could have `CompositeKey` have `===` equality, why would we not have R&T have `===` equality?

[12:03:31.0558] <shu>
that isn't any more acceptable than the R&T's overloading of ===

[12:03:51.0610] <bakkot>
> <@shuyuguo:matrix.org> i missed that there was a configuration of the new direction that has new objects that have special ===?

the CompositeKey thing he presented, with interning, which is already being done in userland

[12:03:53.0983] <littledan>
can we change indexOf just for these new objects?

[12:04:00.0738] <bakkot>
it was not one ACE advocated for

[12:04:20.0417] <shu>
> <@bakkot:matrix.org> the CompositeKey thing he presented, with interning, which is already being done in userland

tools compile away === or something?

[12:04:34.0001] <bakkot>
no I mean they do interning

[12:05:03.0311] <Ashley Claymore>
> <@littledan:matrix.org> can we change indexOf just for these new objects?

I assumed 'no', but never asked

[12:05:16.0687] <shu>
> <@bakkot:matrix.org> no I mean they do interning

oh by "===" you mean they do interning?

[12:05:40.0285] <shu>
i see, ok

[12:05:43.0547] <bakkot>
https://github.com/benjamn/immutable-tuple/blob/485b32326349cb0329c749090cebf43f8359fa12/src/tuple.js#L12-L19

[12:06:01.0997] <rbuckton>
Isn't the discussion around `CompositeKey` predicated on R&T *not* having `===` equality? I have concerns about the GC overhead associated with `CompositeKey` using something like weakmaps/maps as either `CompositeKey("a")` leaks forever, or it requires a FinalizationRegistry and the GC overhead for tracking/collection the object.

[12:06:22.0422] <littledan>
> <@rbuckton:matrix.org> Isn't the discussion around `CompositeKey` predicated on R&T *not* having `===` equality? I have concerns about the GC overhead associated with `CompositeKey` using something like weakmaps/maps as either `CompositeKey("a")` leaks forever, or it requires a FinalizationRegistry and the GC overhead for tracking/collection the object.

yes, it's all predicated on === not being supported for R&T

[12:06:31.0243] <shu>
rbuckton: that was also my confusion. the resolution is that CompositeKeys have interning semantics built in, they return deduplicated objects such that === just works like object ===, because it's literally deduplicated

[12:06:39.0950] <bakkot>
or you forbid having a `CompositeKey` that doesn't contain an object, which is what userland does

[12:06:50.0347] <rbuckton>
Interning semantics will have GC overhead

[12:06:55.0760] <shu>
yes indeedy

[12:07:35.0555] <shu>
but it's like, deterministic overhead that's always there, instead of non-deterministic overhead that engines have to tune for and hope they get it right for the largest swath of the code that runs

[12:07:35.0943] <rbuckton>
> <@bakkot:matrix.org> or you forbid having a `CompositeKey` that doesn't contain an object, which is what userland does

`CompsiteKey(obj, "a")` works, but `CompositeKey("a", "b")` does not? That seems like a very unstable design. 

[12:07:45.0699] <shu>
which is a better place to be in, but... definitely still overhead, yes

[12:07:54.0973] <Ashley Claymore>
I dropped it after presenting the slides to some other people, they felt it complicated the question I was asking

[12:08:04.0220] <Mathieu Hofman>
I believe that is NOT was was presented. `#[1] !== #[1] `

[12:08:22.0786] <rbuckton>
I'm concerned about the overhead of 1000s of `map.get(CompositeKey(a, b))` in a loop.

[12:08:34.0530] <eemeli>
I kinda like the idea of being able to do something like 
```
new Map([], { compare: 'duck' })
```
and have that "just work".

[12:08:34.0675] <Mathieu Hofman>
but when used in collections, the equality used is the one supporting R&T equality

[12:08:34.0758] <bakkot>
> <@mhofman:matrix.org> I believe that is NOT was was presented. `#[1] !== #[1] `

CompositeKey was presented, it's just not what was proposed

[12:10:49.0833] <rbuckton>
> <@eemeli:mozilla.org> I kinda like the idea of being able to do something like 
> ```
> new Map([], { compare: 'duck' })
> ```
> and have that "just work".

`@esfx/collections-hashmap` and `@esfx/equatable` does this. You can do, say:

```js
import { HashMap } from "@esfx/collections-hashmap";
import { Uri } from "./uri.js";

const map = new HashMap(undefined, { equaler: Uri.equaler });
```

where `Uri.equaler` is just an object with `{ equals(a, b), hash(obj) }`.

[12:11:35.0237] <Mathieu Hofman>
I'm confused about the discussion about `CompositeKey` here as it's not what was proposed, but presented as background / historical context. A R/T would, unlike CompositeKey, not have `===` equality.

[12:13:14.0203] <rbuckton>
I was under the impression these were discussed as possible directions to consider, with historical context as to prior discussions within TC39.

[12:14:38.0912] <Mathieu Hofman>
rbuckton: I don't want to build R&T on top of a equals / hash mechanism IF there is any way that values can influence the hashing mechanism when added to a collection I created. I am fine if the collection defers to a construction time provided config.

[12:14:45.0185] <Ashley Claymore>
I should have been more clear. I was trying to say `Key(v1, v2) === Key(v1, v2)` is good in that it doesn't introduce a new form of equality. But from what I have heard from engines re R&T and from my own research it seems difficult to make them perform well at scale, the whole app has contention on one global interning table that requires GC hooks to clean up the unused keys.


[12:15:01.0056] <Mathieu Hofman>
 * rbuckton: I don't want to build R&T on top of a equals / hash mechanism IF there is any way that values can influence the hashing mechanism at the time they're added to a collection I created. I am fine if the collection defers to a construction time provided config.

[12:15:16.0519] <Mathieu Hofman>
 * rbuckton: I don't want to build R&T on top of a equals / hash mechanism IF there is any way that values can influence the hashing mechanism or any part of the prohgram at the time they're added to a collection I created. I am fine if the collection defers to a construction time provided config.

[12:16:08.0346] <Mathieu Hofman>
 * rbuckton: I don't want to build R&T on top of a equals / hash mechanism IF there is any way that values can influence the hashing mechanism or any part of the program at the time they're added to a collection I created. I am fine if the collection defers to a construction time provided config.

[12:16:23.0327] <rbuckton>
The upside of equals/hash is that it is a known quantity. Numerous languages and runtimes use this, thus the caveats are known. 

[12:16:41.0141] <rbuckton>
A `CompositeKey` based on equals/hash doesn't require complex GC semantics.

[12:19:01.0375] <rbuckton>
If you have a native `CompositeKey` with equals/hash, you just make the "default equaler" behavior used by a `Map` have a specific case for `CompositeKey` vs `===`. But then you can make that "default equaler" an actual object from which to build other equalers from.

[12:19:04.0017] <Mathieu Hofman>
To be more clear:
`new Map([], {compare: Record.equals})` is fine, and so is `new Map([], {compare: customHashCodeThing}`, but not `new Map([], compareWithHashCode: true)` which would be assuming Records.prototype[Symbol.hashCode]`

[12:20:06.0801] <Mathieu Hofman>
 * To be more clear:
`new Map([], {compare: Record.equals})` is fine, and so is `new Map([], {compare: customHashCodeThing}`, but not `new Map([], compareWithHashCode: true)` which would be assuming looking up a `Records.prototype\[Symbol.hashCode\]\`

[12:20:15.0587] <Mathieu Hofman>
 * To be more clear:
`new Map([], {compare: Record.equals})` is fine, and so is `new Map([], {compare: customHashCodeThing}`, but not `new Map([], compareWithHashCode: true)` which would be assuming looking up a `Records.prototype[Symbol.hashCode]`

[12:21:46.0991] <Ashley Claymore>
In other plenary sessions it has come up that the language should be as close to fully deterministic as we can. e.g. not exposing a browser-sniffing API. `Object.hash` feels like it would need to be fully deterministic across engines to meet these goals.
Perhaps I have mis-read committee comments with this goal.

[12:22:56.0661] <rbuckton>
> <@mhofman:matrix.org> To be more clear:
> `new Map([], {compare: Record.equals})` is fine, and so is `new Map([], {compare: customHashCodeThing}`, but not `new Map([], compareWithHashCode: true)` which would be assuming looking up a `Records.prototype[Symbol.hashCode]`

I've experimented with something like `[Symbol.hashCode]`. In well written applications its perfectly fine and would serve most users well. If you don't trust your inputs, you could opt-out with a custom equaler that doesn't call an `@@hashCode`. That said, I'm more interested in a general purpose `{ equals, hash }` mechanism for `Map`/`Set` and various other methods that do equality checks, than i am with instance-overrideable hash codes.

[12:23:12.0520] <Ashley Claymore>
I also wonder if even string hashing is not as easy to standardize in 262 due to the spec being in wtf-16 and runtimes potentially using different encodings?

[12:32:50.0075] <Mathieu Hofman>
We don't automatically need to expose the result of the internal hashing. We could have special values for `compare`

[12:33:50.0673] <rbuckton>
> <@aclaymore:matrix.org> In other plenary sessions it has come up that the language should be as close to fully deterministic as we can. e.g. not exposing a browser-sniffing API. `Object.hash` feels like it would need to be fully deterministic across engines to meet these goals.
> Perhaps I have mis-read committee comments with this goal.

`Object.hash()` *shouldn't* be fully deterministic, at least not for strings. String hash code generators benefit from randomness as it evens out clumping due to collisions over the course of various app restarts. An implementation would also want to be able to swap from one hash algorithm to another from version to version as hash algorithms improve.

In .NET, you can control whether to use a randomized string hashing algorithm via configuration: https://learn.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.

[12:34:20.0207] <rbuckton>
> <@mhofman:matrix.org> We don't automatically need to expose the result of the internal hashing. We could have special values for `compare`

I considered describing it as an opaque value, but you need to be able to do math on it.

[12:35:16.0223] <Mathieu Hofman>
To follow up on Ashley Claymore 's comment, I would be opposed to any new APIs to expose non determinism to the program. It's fine for these things to remain internal to the engine, but I don't want them to be observable

[12:37:46.0581] <Mathieu Hofman>
Or should I say, the new API would have to be extremely well motivated, like FR/WeakRef, but I don't think hashcode would clear that line

[12:38:12.0317] <rbuckton>
For example
```js
class Point {
  #x;
  #y;
  constructor(x, y) {
    this.#x = x;
    this.#y = y;
  }
  get x() { return this.#x; }
  get y() { return this.#y; }
  static equaler = {
    equals(a, b) {
      return #x in a && #x in b && a.#x == b.#x && a.#y == b.#y;
    },
    hash(obj) {
      let hc = Object.hash(obj.#x);
      hc = ((hc << 7) | (hc >>> 25)) ^ Object.hash(obj.#y);
      return hc;
    }
  }
}
```

[12:38:16.0030] <Mathieu Hofman>
 * Or should I say, the new API would have to be extremely well motivated and fairly self contained, like FR/WeakRef, but I don't think hashcode would clear that line

[12:38:31.0572] <rbuckton>
 * For example

```js
class Point {
  #x;
  #y;
  constructor(x, y) {
    this.#x = x;
    this.#y = y;
  }
  get x() { return this.#x; }
  get y() { return this.#y; }
  static equaler = {
    equals(a, b) {
      return #x in a && #x in b && a.#x === b.#x && a.#y === b.#y;
    },
    hash(obj) {
      let hc = Object.hash(obj.#x);
      hc = ((hc << 7) | (hc >>> 25)) ^ Object.hash(obj.#y);
      return hc;
    }
  }
}
```

[12:40:02.0241] <Mathieu Hofman>
I honestly don't understand why `hashLike(obj) { return #[obj.#x, obj.#y] }` is not an acceptable approach`. Engines are definitely capable of optimizing this

[12:40:24.0427] <Mathieu Hofman>
 * I honestly don't understand why `hashLike(obj) { return #[obj.#x, obj.#y]; }` is not an acceptable approach. Engines are definitely capable of optimizing this

[12:40:55.0573] <Mathieu Hofman>
 * I honestly don't understand why `hashLike(obj) { return #[Point, obj.#x, obj.#y]; }` is not an acceptable approach. Engines are definitely capable of optimizing this

[12:41:52.0424] <rbuckton>
Capable does not mean willing or likely to do so.

[12:43:20.0808] <rbuckton>
And that still doesn't let me write a hashtable. I need something I can use as a numeric index with good avalanche properties. Maybe 95% of users don't need this, but its a headache for the small percent that do for good reason.

[12:43:33.0007] <rbuckton>
 * And that still doesn't let me write a hashtable. I need something I can use as a numeric index with good avalanche properties. Maybe 95% of users don't need this, but its a headache for the small percent that do need it for a good reason.

[12:48:02.0971] <rbuckton>
For example, I had to do quite a bit to workaround this limitation when experimenting with the shared structs dev trial. I had a very strong need for a concurrent Map, which required implementing a hash table. It would have been far easier if I could actually generate a hash for a string or an object: https://github.com/microsoft/TypeScript/blob/shared-struct-test/src/compiler/sharing/collections/concurrentMap.ts

Yes, maybe we would want to add a `ConcurrentMap` after we add shared structs, but that's certainly not going to be in the MVP. 

[12:55:51.0531] <Mathieu Hofman>
generating a non-deterministic value from a basic value like and object or a string feels like a non starter for me. I'd claim it's not needed by 99.9999% of JS authors

[12:56:24.0171] <rbuckton>
Hash bucket lookup is approximately O(1), while a user-built collection relying on manually comparing tuples is O(n), and if you can't compare tuples using `===`, it's O(n*m) where `m` is the number of keys in the tuple. 

[13:01:49.0975] <rbuckton>
> <@mhofman:matrix.org> generating a non-deterministic value from a basic value like and object or a string feels like a non starter for me. I'd claim it's not needed by 99.9999% of JS authors

Then call the method `Object.nondeterministicHash(obj)` or `Object.randomHash(obj)` or document the non-deterministic nature on MDN. If you were an implementer that built internally used murmur3 for string hashing and found you could speed up all applications by a significant percentage by switching to xxhash64, wouldn't you do so? `Object.hash()` must be explicitly "non-deterministic" from the get-go just so anyone consuming it could reap the same benefits if a better hash algorithm comes along.

[13:02:05.0810] <rbuckton>
> <@mhofman:matrix.org> generating a non-deterministic value from a basic value like and object or a string feels like a non starter for me. I'd claim it's not needed by 99.9999% of JS authors

 * Then call the method `Object.nondeterministicHash(obj)` or `Object.randomHash(obj)` or document the non-deterministic nature on MDN. If you were an implementer that internally used murmur3 for string hashing and found you could speed up all applications by a significant percentage by switching to xxhash64, wouldn't you do so? `Object.hash()` must be explicitly "non-deterministic" from the get-go just so anyone consuming it could reap the same benefits if a better hash algorithm comes along.

[13:03:20.0984] <rbuckton>
Case in point, even if you're using the non-random string hash algorithm in .NET, `Object.GetHashCode()` is still considered to be non-deterministic as upgrading the version can change the hash algorithm to one that is more efficient.

[13:03:27.0652] <Mathieu Hofman>
I just don't think there is sufficient motivation to expose this in the language

[13:09:22.0821] <rbuckton>
I'd argue that the number of times we've discussed mechanisms for customizing equality indicates it *is* sufficient motivation. The main reason I want custom equality for Map/Set at all is related to performance. You can use them as-is as long as you're willing to sacrifice performance and memory at the cost of the overhead introduced by alternatives. I want custom `Map` equality so that I *don't* have to `.toString()` every Uri I use as a key in a `map.get()`. Forcing custom collections to operate at O(n) while native collections can have O(1) because they can cheat and do the hashtable lookup is not the answer when your algorithms are performance-critical.

[13:18:40.0627] <rbuckton>
I'm not saying that `Object.hash()` must return a number, but that you could conceivably do all the things you would need to do to implement a hash table for an alternative to be a reasonable compromise. For example, let's say we had an API like this:

```ts
interface Equaler<T> {
  equals(a: T, b: T): boolean;
  hash(a: T): opaque;
}
```
where `hash` returns an opaque value. I'd need, at a minimum, something like this as well:
```ts
declare const defaultEqualer: Equaler<unknown>;
declare function combineHash(a: opaque, b: opaque): opaque;
interface HashArray<T> {
  length: number;
  [hash: opaque]: T;
  ...
}
interface SharedHashArray<T> {
  length: number;
  [hash: opaque]: T;
  ...
}
```

to have any possibility of achieving similar perf to it being a number.

[13:18:47.0429] <Mathieu Hofman>
You can customize equality using the `hashLike` approach I suggested above. It is also optimizable by engines.

[13:19:46.0383] <Mathieu Hofman>
The combine hash is exactly what creating a R/T with your components does

[13:20:13.0774] <rbuckton>
But not for a custom collection. As I said, native `Map`/`Set` could cheat and unwrap a composite key to do a hashtable lookup for O(1), but a custom collection would be O(n) at best.

[13:21:27.0155] <rbuckton>
I think a design that ignores custom collections is too short sighted. 

[13:22:09.0308] <Mathieu Hofman>
Sorry I don't understand how your opaque hash is any different than a R/T

[13:22:39.0343] <rbuckton>
The opaque hash is just a number you can't actually see in to.

[13:22:55.0324] <rbuckton>
 * The opaque hash is just a number you can't actually see into.

[13:23:21.0962] <rbuckton>
The only reason it would be opaque is so that users can't depend on the actual value.

[13:23:40.0428] <rbuckton>
If it were a tuple, you couldn't use it as an index into an array of hash buckets.

[13:24:03.0324] <rbuckton>
If it were a number, or an opaque value that's actually just a number, then you conceivably could.

[13:24:33.0110] <rbuckton>
Numbers are just far easier to reason over since we already have `Array` and shared structs would have `SharedArray`.

[13:25:42.0475] <rbuckton>
To use a hash code efficiently, I need to be able to compare it using `===`, shift it using `<<` and `>>>`, and combine it using `^`. All of these operations are extremely fast using 32-bit integers.

[13:25:59.0563] <rbuckton>
 * To use a hash code efficiently, I need to be able to compare it using `===`, shift it using `<<` and `>>>`, combine it using `^`, and use it as the index into an array. All of these operations are extremely fast using 32-bit integers.

[13:28:16.0323] <rbuckton>
`#[a, b, c]` has no avalanche properties I can use to ensure proper distribution in a hashtable, and cannot be used as an index, so comparing keys using `#[a, b, c]` in a custom collection is at least O(n*3), since I must compare the elements of every key in the map to the elements in the provided key. It's terribly inefficient.

[13:32:43.0378] <Mathieu Hofman>
> <@rbuckton:matrix.org> If it were a tuple, you couldn't use it as an index into an array of hash buckets.

You could use it as a key in a Map, how is it different?

[13:33:00.0991] <rbuckton>
not across threads

[13:33:29.0336] <Mathieu Hofman>
if the "opaque" number value is actually observable by the program, even indirectly, it defeats the purpose of being opaque

[13:34:29.0428] <rbuckton>
And that assumes that all JS devs will only ever need `Map` and `Set`, and that there are no other collection classes JS does not implement that will ever be needed.

[13:34:47.0291] <Mathieu Hofman>
when you said opaque, I had assumed actually opaque, like a unique symbol

[13:35:05.0532] <Mathieu Hofman>
anything else is not opaque by my definition

[13:35:39.0396] <rbuckton>
I don't need it to be opaque. I'm saying the only way an opaque value would work for me is if it could have the same properties I would need from an integer hash code.

[13:35:41.0782] <Mathieu Hofman>
 * when you said opaque, I had assumed actually opaque, like a unique symbol, or empty object

[13:36:38.0780] <rbuckton>
The problem is that if it's not a 32-bit integer, it becomes a boxed value in most implementations, and those are going to be slower.

[13:49:09.0555] <rbuckton>
Let me summarize my thoughts:
- Any mechanism to customize equality for `Map` and `Set` should be done in a way that could be leveraged by a custom collection. Anything less is too short sighted.
- Using a composite key/tuple will not give me the performance characteristics I would need in a custom collection, as it would result in O(n*m) lookup time.
- Equals/hash can be employed by a hashtable in a custom collection for O(1) lookup time.
- Using a composite key/tuple would not be compatible with custom collections under shared memory multithreading, which are likely to be necessary since concurrent/synchronized collections are not part of the shared structs MVP.
- Composite keys require an allocation that is likely to be repeated for every call to `map.get`. Engines *could* optimize, but likely won't do so immediately, if ever.
- A composite key mechanism can be implemented on top of equals/hash such that a WeakMap/Map-based registry is unnecessary. equals/hash cannot be implemented on top of a composite key.


[13:51:11.0114] <rbuckton>
 * Let me summarize my thoughts:

- Any mechanism to customize equality for `Map` and `Set` should be done in a way that could be leveraged by a custom collection. Anything less is too short sighted.
- Using a composite key/tuple will not give me the performance characteristics I would need in a custom collection, as it would result in O(n\*m) lookup time.
- Equals/hash can be employed by a hashtable in a custom collection for O(1) lookup time.
- Using a composite key/tuple would not be compatible with custom collections under shared memory multithreading, which are likely to be necessary since concurrent/synchronized collections are not part of the shared structs MVP.
- Composite keys require an allocation that is likely to be repeated for every call to `map.get`. Engines _could_ optimize, but likely won't do so immediately, if ever.
- A composite key mechanism can be implemented on top of equals/hash such that a WeakMap/Map-based registry is unnecessary. equals/hash cannot be implemented on top of a composite key.
- Equals/hash can use 32-bit integers, `<<`, `>>>` and `^`, which are all already fast and optimized. Opaque values require boxing, making them slow (see bigint performance as an example)

[13:52:37.0428] <Mathieu Hofman>
I'm saying that any value that is a source of observable non determinism does not seem sufficiently motivated for a "keying" mechanism when there are alternatives that cover most of the use cases except performance, which can be optimized, or shared memory, which is a hypothetical future, and could have its own collections API. JS is a high level language that does not expose low level / internal details of its objects or memory layout. exposing hash code would change that

[13:54:48.0532] <Ashley Claymore>
> Composite keys require an allocation that is likely to be repeated for every call to map.get. Engines could optimize, but likely won't do so immediately, if ever.
The idea with R&T is that, being objects and arrays. In many cases they are the data structure, so there is no extra allocation for these cases

[13:54:57.0037] <Ashley Claymore>
 * > Composite keys require an allocation that is likely to be repeated for every call to map.get. Engines could optimize, but likely won't do so immediately, if ever.

The idea with R&T is that, being objects and arrays. In many cases they are the data structure, so there is no extra allocation for these cases

[13:56:17.0493] <rbuckton>
As I've discovered while discussing array iterator performance, "can be optimized" isn't a useful metric. Implementations won't optimize unless they have very good reason to. Array destructuring has been around for ~9 years and still isn't optimized.

[13:59:13.0053] <rbuckton>
> <@aclaymore:matrix.org> > Composite keys require an allocation that is likely to be repeated for every call to map.get. Engines could optimize, but likely won't do so immediately, if ever.
> 
> The idea with R&T is that, being objects and arrays. In many cases they are the data structure, so there is no extra allocation for these cases

@bakkot's example in matrix earlier shows this to not be true. The keys are often a subset of the data structure, and will very likely be generated on the fly.

[13:59:17.0855] <Ashley Claymore>
If the data model of the application is already using R&T. Inserting these into a map could be the fastest case. Because all the hashing and equality operations are entirely native, with zero entry into userland minimizing guards and allowing JIT.

[13:59:52.0082] <Ashley Claymore>
>  The keys are often a subset of the data structure
If this really is common, then apps could keep those parts of the data structure seperate

[13:59:56.0813] <Ashley Claymore>
 * > The keys are often a subset of the data structure

If this really is common, then apps could keep those parts of the data structure seperatee

[14:00:01.0528] <Ashley Claymore>
 * > The keys are often a subset of the data structure

If this really is common, then apps could keep those parts of the data structure seperate

[14:00:10.0433] <rbuckton>
> <@aclaymore:matrix.org> If the data model of the application is already using R&T. Inserting these into a map could be the fastest case. Because all the hashing and equality operations are entirely native, with zero entry into userland minimizing guards and allowing JIT.

You're only proving my point. `Map` and `Set` can only have O(1) performance for a tuple as a composite key if they use equals/hash internally. Custom collections cannot do the same.

[14:00:36.0340] <Mathieu Hofman>
Custom collections can use Map/Set internally

[14:00:57.0804] <Mathieu Hofman>
 * Custom collections can use Map/Set internally for the vast majority of custom use cases

[14:00:58.0993] <Ashley Claymore>
Yes. I said earlier. The implementations must use hash + equals at some layer. I 100% agree that the pattern is efficent

[14:01:01.0993] <rbuckton>
custom collections aren't an ephemeral thing, there is production code that uses them. The perf hit is likely the only reason they aren't used more.

[14:01:38.0881] <Ashley Claymore>
The custom collections I've needed were wrappers around Maps

[14:01:56.0511] <Ashley Claymore>
I'd be interested in hearing about other cases. I'm familiar with the ConcurrentMap one.

[14:07:58.0577] <rbuckton>
> <@aclaymore:matrix.org> The custom collections I've needed were wrappers around Maps

This is often the case, but these are often still inefficient. You often have to do some type of conversion for every `get`/`set`, which can result in unnecessary allocations. You could build a custom map that does case insensitive string comparisons on keys by passing them through a case folding algorithm, but that's terribly inefficient. For a case insensitive comparison, you might use case folding on the string to compare, but then you're also producing another string in memory. If you want to preserve the input key as written, you have to store both the original key and value as the map entry, resulting in another allocation and duplication, plus the need to wrap `keys()`, `values()`, etc. This is all unnecessary overhead.

[14:09:47.0851] <Ashley Claymore>
Gotcha. That matches my understanding. It's not that lots of custom collections can't be built, but they will need to do more allocations.

[14:11:48.0467] <rbuckton>
> <@aclaymore:matrix.org> Gotcha. That matches my understanding. It's not that lots of custom collections can't be built, but they will need to do more allocations.

Map/Set wrappers can be built with allocation overhead, but only if their keys are easily translated to something that works as an existing key. Complex objects and up requiring O(n)

[14:12:51.0128] <rbuckton>
Even if you are using weakmap/map registries to ensure a composite key has the same identity, that's *still* O(n) if you're writing `map.get(CompositeKey(a, b))`. You're just paying the O(n) cost walking the registry.

[14:13:34.0450] <rbuckton>
i.e., for n steps, you're doing an O(1) operation for each step.

[14:13:44.0773] <Ashley Claymore>
what is n here?

[14:13:52.0855] <rbuckton>
n is the number of elements in the composite key.

[14:14:12.0420] <Ashley Claymore>
ok. I thought you were referring to collection size and got confused

[14:14:17.0041] <rbuckton>
https://docs.google.com/presentation/d/1JfChmW8tQ2_mrFDynosNqa1tjJ2j-qX6WoKm8vc_tkY/edit#slide=id.g2c6eebea946_0_40

[14:14:38.0673] <rbuckton>
Sorry, I should have said m instead of n for that case.

[14:15:56.0824] <rbuckton>
> <@aclaymore:matrix.org> Gotcha. That matches my understanding. It's not that lots of custom collections can't be built, but they will need to do more allocations.

 * Map/Set wrappers can be built with allocation overhead, but only if their keys are easily translated to something that works as an existing key. Complex objects end up requiring O(n)

[14:17:37.0348] <littledan>
> <@rbuckton:matrix.org> Let me summarize my thoughts:
> 
> - Any mechanism to customize equality for `Map` and `Set` should be done in a way that could be leveraged by a custom collection. Anything less is too short sighted.
> - Using a composite key/tuple will not give me the performance characteristics I would need in a custom collection, as it would result in O(n\*m) lookup time.
> - Equals/hash can be employed by a hashtable in a custom collection for O(1) lookup time.
> - Using a composite key/tuple would not be compatible with custom collections under shared memory multithreading, which are likely to be necessary since concurrent/synchronized collections are not part of the shared structs MVP.
> - Composite keys require an allocation that is likely to be repeated for every call to `map.get`. Engines _could_ optimize, but likely won't do so immediately, if ever.
> - A composite key mechanism can be implemented on top of equals/hash such that a WeakMap/Map-based registry is unnecessary. equals/hash cannot be implemented on top of a composite key.
> - Equals/hash can use 32-bit integers, `<<`, `>>>` and `^`, which are all already fast and optimized. Opaque values require boxing, making them slow (see bigint performance as an example)

we actually added Map and Set as built-ins without having a way that what they do could be done in a custom collection. Of course it would be nice to support efficient maps defined in JS if possible given all of the other goals and constraints, but I don't see why it makes sense to say that no advances should be made for Map and Set without managing to support this other goal.

[14:18:40.0207] <littledan>
the composite-ness of composite keys or R&T doesn't actually depend on any new built-in thing, but identity hashcodes continue to not be exposed

[14:20:59.0554] <rbuckton>
> <@littledan:matrix.org> we actually added Map and Set as built-ins without having a way that what they do could be done in a custom collection. Of course it would be nice to support efficient maps defined in JS if possible given all of the other goals and constraints, but I don't see why it makes sense to say that no advances should be made for Map and Set without managing to support this other goal.

We did, and this has continued to come up regularly since. I'm not opposed to things that make `Map` and `Set` more efficient. I'm concerned with choosing an API design that caters to native maps and sets that could never be efficiently implemented in a custom collection. We either end up never improving the story for custom collections, or end up with two independent mechanisms for customizing equality.

[14:22:49.0391] <rbuckton>
A composite key that uses a weakmap registry just to ensure reference identity for equivalent keys is entirely unnecessary with hash/equals. If we were to then implement hash/equals to improve the custom collection story, then composite keys become an evolutionary dead end for the language.

[14:23:40.0314] <littledan>
Is anyone defending CompositeKey?

[14:24:00.0251] <littledan>
Object-based R&T seems like a cleaner mechanism and doesn't do anything which should make things harder for custom collections, I think

[14:24:25.0664] <bakkot>
I'm not sure what distinction between CompositeKey and object-based R&T you're drawing

[14:24:29.0103] <rbuckton>
How is object-based R&T not a composite key?

[14:25:05.0210] <rbuckton>
The distinction I would make would be between a WeakMap-registry based composite key, or a Map/Set privileged CompositeKey.

[14:27:55.0096] <rbuckton>
A Map/Set-privileged CompositeKey has a way forward to equals/hash, but then why not have equals/hash instead (or at the same time).

[14:29:48.0437] <littledan>
> <@bakkot:matrix.org> I'm not sure what distinction between CompositeKey and object-based R&T you're drawing

well, the basic version of R&T that we were discussing is, there isn't support for being keys in WeakMap, so the whole registry thing just goes away

[14:30:01.0835] <littledan>
and there's no support for ===

[14:30:18.0493] <littledan>
I guess the registry was more for ===; WeakMap doesn't actually need it

[14:31:09.0816] <littledan>
so I guess you're calling this Map/Set privileged? But I don't see what Map/Set are doing that other collections couldn't also do

[14:32:18.0237] <littledan>
> <@rbuckton:matrix.org> A Map/Set-privileged CompositeKey has a way forward to equals/hash, but then why not have equals/hash instead (or at the same time).

This is something I have trouble understanding. Even if we do want to generalize to hash, the question of "why not instead" was answered--you want a nice default mechanism for the normal case, as other languages tend to have

[14:32:18.0888] <rbuckton>
I'd also like more details from the folks that are concerned about non-determinism as to why that should matter. It would be guaranteed to be deterministic so long as the app/browser is executing. Assuming no string-random-hash algorithm at the outset, the only thing that would change the hash result would probably be upgrading the browser as a newer runtime could choose a more efficient algorithm.

[14:32:46.0987] <bakkot>
my preferred approach is to allow composite objects (i.e. interned objects, that give you `===`) as keys in WeakMaps iff they contain at least one thing which could itself be in a WeakMap, and to introduce a `canBeWeaklyHeld` predicate so that's easier to determine.

[14:32:54.0591] <littledan>
why not at the same time was also answered: because there is not consensus to expose hashcodes, due to interop risk

[14:33:32.0907] <littledan>
so I guess you want more details... what do you mean by details?

[14:33:49.0191] <rbuckton>
> <@littledan:matrix.org> so I guess you're calling this Map/Set privileged? But I don't see what Map/Set are doing that other collections couldn't also do

No, Map/Set privileged would mean a Map would treat a CompositeKey as a special value and essentially do equals/hash natively. Without runtime support for equals/hash, a custom collection cannot do the same.

[14:34:01.0340] <Mathieu Hofman>
> if you're writing `map.get(CompositeKey(a, b))`. You're just paying the O(n) cost walking the registry.

I do not understand. How is it `O(n)` if there is a Map that supports a native composite keying ?

[14:34:36.0176] <rbuckton>
> <@littledan:matrix.org> This is something I have trouble understanding. Even if we do want to generalize to hash, the question of "why not instead" was answered--you want a nice default mechanism for the normal case, as other languages tend to have

Other languages tend to have equal/hash, with a few built-in equalers you can readily reference. I would certainly want those as well.

[14:34:41.0505] <littledan>
> <@rbuckton:matrix.org> No, Map/Set privileged would mean a Map would treat a CompositeKey as a special value and essentially do equals/hash natively. Without runtime support for equals/hash, a custom collection cannot do the same.

hmm, what kind of custom collection are you imagining? I guess I'm not picturing it properly

[14:35:12.0407] <rbuckton>
> <@mhofman:matrix.org> > if you're writing `map.get(CompositeKey(a, b))`. You're just paying the O(n) cost walking the registry.
> 
> I do not understand. How is it `O(n)` if there is a Map that supports a native composite keying ?

That was in reference to the WeakMap registry mechanism on https://docs.google.com/presentation/d/1JfChmW8tQ2_mrFDynosNqa1tjJ2j-qX6WoKm8vc_tkY/edit#slide=id.g2c6eebea946_0_40

[14:40:28.0160] <Mathieu Hofman>
> <@rbuckton:matrix.org> I'd also like more details from the folks that are concerned about non-determinism as to why that should matter. It would be guaranteed to be deterministic so long as the app/browser is executing. Assuming no string-random-hash algorithm at the outset, the only thing that would change the hash result would probably be upgrading the browser as a newer runtime could choose a more efficient algorithm.

I want a language where I can deterministically reproduce execution. If you exclude I/O (which encompasses Date.now and Math.random), we currently have that language

[14:41:29.0085] <rbuckton>
> <@littledan:matrix.org> hmm, what kind of custom collection are you imagining? I guess I'm not picturing it properly

https://github.com/esfx/esfx/blob/main/packages/collections-hashmap/src/index.ts, though its essentially just a `Map` that takes an `{ equaler }` option, as I'm suggesting.
https://github.com/microsoft/TypeScript/blob/shared-struct-test/src/compiler/sharing/collections/concurrentMap.ts, which is a lock-free concurrent map that cannot use `Map` as a backing store.
https://github.com/microsoft/TypeScript/blob/shared-struct-test/src/compiler/sharing/collections/sharedMap.ts, which is a coarse-grained synchronized map.
to name a few. In other languages you're likely to see custom collections where specific semantics for get/set are necessary, such as with observable collections in .NET.

[14:44:23.0678] <rbuckton>
> <@mhofman:matrix.org> I want a language where I can deterministically reproduce execution. If you exclude I/O (which encompasses Date.now and Math.random), we currently have that language

But for what purpose is this important? Is it for testing? If you're going to exclude `Date.now` and `Math.random`, why would you not exclude `Object.hash`? Could an implementation not have a `--hash-algorithm=...` flag to ensure a stable hash algorithm for tests?

[14:45:25.0011] <rbuckton>
If it's for security, wouldn't a randomized Object.hash be preferred over a deterministic one?

[14:46:22.0153] <rbuckton>
Are there any "implementation defined" behaviors you also have to discount? `Object.hash` would essentially be implementation defined.

[14:48:16.0078] <Mathieu Hofman>
> <@rbuckton:matrix.org> But for what purpose is this important? Is it for testing? If you're going to exclude `Date.now` and `Math.random`, why would you not exclude `Object.hash`? Could an implementation not have a `--hash-algorithm=...` flag to ensure a stable hash algorithm for tests?

We actually use this determinism for replay of program execution, sometimes across engines. Yes we could remove, but then it increases the difference with what programs may expect being in the language.

[14:48:37.0197] <rbuckton>
There's also the possibility we could define hashing as `Object.hash(obj, algorithm?)` where you can optionally specify `"stable"` or `"fast"`.

[14:49:15.0376] <rbuckton>
 * There's also the possibility we could define hashing as `Object.hash(obj, algorithm?)` where you can optionally specify `"stable"` or `"fast"` (or similar).

[14:50:10.0893] <rbuckton>
> <@mhofman:matrix.org> We actually use this determinism for replay of program execution, sometimes across engines. Yes we could remove, but then it increases the difference with what programs may expect being in the language.

And how does this differ from the unique reference identity that a CompositeKey might have at runtime?

[14:52:04.0943] <Mathieu Hofman>
> <@rbuckton:matrix.org> And how does this differ from the unique reference identity that a CompositeKey might have at runtime?

all usages of such unique identity would be deterministic.

[14:52:06.0796] <rbuckton>
It should be clearly called out in documentation that `Object.hash()` is not stable across application restarts and shouldn't be serialized. I would expect that code that respects that would work just fine when replaying execution.

[14:52:19.0197] <rbuckton>
It isn't deterministic.

[14:52:28.0293] <Mathieu Hofman>
how isn't it?

[14:52:47.0712] <Mathieu Hofman>
 * how isn't it? observably ?

[14:52:53.0638] <rbuckton>
It's unobservably non-deterministic. An object reference at runtime can exist in a different memory address each time you execute.

[14:53:23.0911] <Mathieu Hofman>
sure but I don't care about internals of the engine that are not observable

[14:53:33.0517] <rbuckton>
If your code treats a hash as unobservably non-deterministic, there is no difference.

[14:53:54.0575] <Mathieu Hofman>
it's like saying a JS object representation may live at a different pointer, that is just not relevant

[14:53:57.0959] <rbuckton>
The problem is that you can't make a hash code opaque without severely impacting the performance.

[14:54:27.0287] <rbuckton>
And the whole point is the performance.

[14:54:53.0789] <Mathieu Hofman>
I care about what the language exposes, that it not allow JS program to have non deterministic behaviors. I do not control the programs that run in my environment

[14:55:46.0870] <rbuckton>
JS allows programs to have non-deterministic behaviors, hence Date.now(), Math.random(). You can only make that assertion about a subset of the language.

[14:57:20.0452] <rbuckton>
Would control over the algorithm assuage that concern? Be it that from a CLI option or an option to a ShadowRealm, or an optional argument to `Object.hash()`?

[14:57:38.0121] <Mathieu Hofman>
right, and any further non-deterministic behaviors would IMO have to be extremely well motivated, and I am not seeing that from hashCode

[15:13:34.0522] <rbuckton>
I would find a custom equality solution that cannot be implemented efficiently in a pure-JS collection to be a serious design flaw in the language. If Map/Set have privileged support for a composite key, that will end up poisoning other APIs over time. It will inevitably be reused by `groupBy` and `distinct`, or possibly a future `join`/`crossJoin`/`leftJoin` for iterators. We will move further and further away from the ability for the runtime to evolve in userland as no userland implementation could have the same performance characteristics. And we _regularly_ suggest that some proposals instead evolve in userland.

[15:14:55.0068] <rbuckton>
I'd like to point out one specific bit. `Object.hash()` is essentially deterministic for everything *except* strings. The only non-determinism in strings would be if a more efficient hashing algorithm were to come along.

[15:18:16.0247] <rbuckton>
It's possible that we could handle that case with a `subtle`-like  API. Get consensus on a base algorithm for string hashing, and allow users to use a faster algorithm as it comes along. For example, were `Object.hash` to use `mumur3` by default, we could later support xxhash via `Object.hash.xxhash32` or `Object.hash(v, "xxhash32")`.

[15:18:24.0671] <rbuckton>
 * It's possible that we could handle that case with a `subtle`-like  API. Get consensus on a base algorithm for string hashing, and allow users to use a faster algorithm as it comes along. For example, were `Object.hash` to use `mumur3` by default, we could later support xxhash via `Object.hash.xxhash32()` or `Object.hash(v, "xxhash32")`.

[15:20:43.0522] <rbuckton>
Then the program remains deterministic. If randomized string hashing becomes important, make that an option but add that narrow bit to the set of things you don't support if you want determinism instead of throwing out the whole feature.

[15:27:45.0576] <rbuckton>
Correction, strings are not the only case. `Object.hash({})` might also need to be non-deterministic to avoid introducing a side-channel. I have to think on that a bit more.

[15:28:50.0891] <rbuckton>
It could just be that `Object.hash({})` always returns zero or throws, and you have to work around that yourself, but that would be unfortunate.

[15:40:06.0913] <rbuckton>
IMO, I'd rather have a non-deterministic `Object.hash()` and better support for time-travel debugging across engines to handle the "replayable program execution" case. 

[16:12:08.0740] <Bradford Smith>
Mathieu Hofman: It's my understanding that iteration over Map() and Set() is always in the order in which items were added. This wouldn't be affected by allowing a userland-provided hashCode form of equals, would it? Are you thinking of some other way in which non-determinism would creep in? Are you concerned userland bugs causing the hashCode for a mutable object to change when the object is mutated?

[16:16:54.0172] <Mathieu Hofman>
> <@bradfordcsmith:matrix.org> Mathieu Hofman: It's my understanding that iteration over Map() and Set() is always in the order in which items were added. This wouldn't be affected by allowing a userland-provided hashCode form of equals, would it? Are you thinking of some other way in which non-determinism would creep in? Are you concerned userland bugs causing the hashCode for a mutable object to change when the object is mutated?

I'm not saying that the builtin collections would use hashCode for order. I'm saying exposing more non-determinism would intrinsically risk causing more non-deterministic execution of JS programs.

[16:28:48.0280] <Bradford Smith>
Ok, so the issue isn't that the proposed use of `Symbol.hashCode` and `Symbol.equals` properties (or something like that) for Map/Set equality is itself a cause of non-determinism. It is rather that any userland implementation of `Symbol.hashCode` is likely to be non-deterministic in order to be functional.  And, other uses of `Symbol.hashCode` that may crop-up in user-land could then lead to non-deterministic behavior. The existence of this API practically requires that userland code produce non-deterministic values in order to use it.

Is that right?

[16:50:02.0493] <Mathieu Hofman>
My understanding is that for hashCode to be effective, some non-determinism will become observable. That non-determinism comes from APIs that would need to be introduced to hash "root" values, like strings or the identity of some values (e.g. unique symbols)


2024-04-10
[17:01:03.0754] <waldemar>
If you care about performance, it's a bad idea to feed external input into a deterministic hash function. That invites attacks such as Hash Flooding: https://en.wikipedia.org/wiki/Collision_attack#Hash_flooding

[17:40:26.0514] <littledan>
> <@waldemarh:matrix.org> If you care about performance, it's a bad idea to feed external input into a deterministic hash function. That invites attacks such as Hash Flooding: https://en.wikipedia.org/wiki/Collision_attack#Hash_flooding

V8 rotates its hash function on boot, but at some point there was a security issue where, if you put some Maps in the startup snapshot (which Chrome doesn't do, but Node.js started doing at some point), it forgot to re-rotate them, causing a DOS risk of this form! Fixed by joyee :)

[18:49:54.0096] <littledan>
I am not sure what we're supposed to get from Project Valhalla when primitives/value semantics has already been deemed not an option due to implementability issues

[18:51:07.0105] <littledan>
if the question is class-based vs object-based immutable things, I think there's a lot of interest among JS developers in having easy-to-use mechanisms that aren't based on classes.

[18:51:21.0072] <littledan>
 * if the question is class-based vs object-based immutable things, I think there's a lot of interest among JS developers in having easy-to-use mechanisms for immutable data structures that don't force them to write classes

[18:54:02.0864] <rbuckton>
> <@waldemarh:matrix.org> If you care about performance, it's a bad idea to feed external input into a deterministic hash function. That invites attacks such as Hash Flooding: https://en.wikipedia.org/wiki/Collision_attack#Hash_flooding

Performance and/or security. This is one of the reasons why I indicated non-determinism for string hashing between application restarts is a good thing, actually. 

[18:54:30.0944] <littledan>
There's a lot of complexity with class-based immutable things, e.g., we'd need to use initializer list-based constructors, so if there's subclassing it's a totally different instantiation protocol. And if they're value types, it's even more complicated if we want to avoid any kind of global registries like we discussed with shared structs.

[18:55:48.0841] <littledan>
> <@rbuckton:matrix.org> Performance and/or security. This is one of the reasons why I indicated non-determinism for string hashing between application restarts is a good thing, actually.

Right so given that it's simultaneously a good thing and a bad thing, we've so far opted to hide the hashcodes

[19:00:51.0335] <rbuckton>
The "bad thing" case (non-determinism being bad) seems so narrowly focused that I have a hard time believing it should apply broadly across the language.

[19:04:06.0637] <bakkot>
I don't know that class-based vs object-based is a meaningful distinction in JS, but in any case, the main things I want to take away are

- even in a language with a well-established idiom for .equals/.hash, having the ability to conveniently create objects which are `==` each other is useful
- they've explored some of the relevant space already, such as having WeakMaps which reject these values (though, this being Java, that behavior is customizable)

[19:16:51.0726] <rbuckton>
The overhead incurred by a `CompositeKey` just seems like a non-starter to me. Maybe we could find another approach that can overcome these caveats. For example, a `Hasher` class instead of a global `Object.hash()`. A given `Hasher` could just use a monotonically increasing number for each unique object instance it comes across, and maybe is configurable as to how it handles string hashing (e.g., algorithm, randomness, seed values, etc.). Then your equaler looks like `{ equals(a, b), hash(obj, hasher) }` and you then can write `new Map([], { equaler, hasher })`. Object hashes could be deterministic without being a global communications channel. String hashing can be deterministic if you want it to be, or not, as best fits your scenario.

[19:33:30.0028] <littledan>
yes, I agree that having objects which === each other is useful; it's unfortunate that we can't go in that direction per implementer feedback, but I think we can still find many related but different improvements to JavaScript.

[19:34:53.0019] <littledan>
 * yes, I agree that having values which === each other based on their contents is useful; it's unfortunate that we can't go in that direction per implementer feedback, but I think we can still find many related but different improvements to JavaScript.

[19:35:20.0038] <littledan>
Class-based vs object-based is more about syntax and conventions. I think these sorts of features are more likely to have broad adoption with convenient syntax, especially with something related to object/array syntax. If we had classes, we'd have to think through the instantiation protocol. But it's also useful to look at other issues in this area which don't relate to those.

[19:35:37.0526] <littledan>
 * Class-based vs object-based is more about syntax and conventions. I think these sorts of features are more likely to have broad adoption with convenient syntax, especially with something related to object/array syntax. If we had class syntax, we'd have to think through the instantiation protocol. But it's also useful to look at other issues in this area which don't relate to those.

[19:35:50.0373] <littledan>
 * Class-based vs object-based is more about syntax and conventions. I think these sorts of features are more likely to have broad adoption with convenient syntax, especially with something related to object/array syntax. If we had class syntax, we'd have to think through how `new` works. But it's also useful to look at other issues in this area which don't relate to those.

[19:36:46.0538] <littledan>
> The overhead incurred by a CompositeKey just seems like a non-starter to me.

If this means one which is interned so that === works, I agree

[19:37:21.0938] <littledan>
> <@rbuckton:matrix.org> The "bad thing" case (non-determinism being bad) seems so narrowly focused that I have a hard time believing it should apply broadly across the language.

How do you think we should work through the situation where a bunch of people directly disagree with this judgement?

[19:49:13.0090] <rbuckton>
That's why I mentioned alternatives in the preceding message. I'm willing to consider alternatives that support the scenarios I've discussed. I'd entertain an opaque hash if it were feasible to actually support those scenarios in a performant way. A Composite key cannot satisfy those scenarios as it can never be fast in a custom collection, only in native Map/Set. Maybe I'd be less concerned if a `ConcurrentMap` were in the MVP for shared structs, but I know that shared structs *without* concurrent collections is already a hard sell. The problem is that shared structs *without* concurrent collections is nearly unusable for my use cases without the ability to implement a fast efficient custom collection. To support it in the dev trial I essentially had to tag every shared struct with a monotonically increasing identity to use as the hash, and implement a string hashing algorithm just so I could roll my own `ConcurrentMap`. That approach has a lot of overhead I'd rather avoid.

[19:53:42.0680] <rbuckton>
tl;dr, I don't need hash/equals if I know I'll get `ConcurrentMap`, but I know that's a long shot at this point. I'd still lament the overhead of a `CompositeKey`, but my primary use cases would be covered. On the other hand, hash/equals means I'm less concerned about when, if ever, I get `ConcurrentMap` since I could readily implement it in userland.

[20:04:00.0639] <bakkot>
it was not clear to me that this feedback applied to interning at construction time, with a constructor function rather than syntax

[20:05:05.0279] <bakkot>
and being actual `typeof "object"` objects rather than a new kind of primitive, and so on

[20:05:15.0176] <bakkot>
https://matrixlogs.bakkot.com/TC39_Delegates/2024-04-09#L294-L290

[23:06:40.0145] <eemeli>
Could a hashcode be a global symbol for which `Symbol.keyFor()` returned `undefined`? Wouldn't that avoid the concerns about non-determinism?

[01:43:01.0918] <Ashley Claymore>
Symbols don't help non-determinism.

```
typeof hash("a"); // "symbol"

if (hash("a") === hash("b")) {
  print("foo");
}
```


[01:43:02.0462] <Ashley Claymore>
Does the program print foo?

[01:47:59.0303] <Ashley Claymore>
If the spec says that the symbol hash of every value is different and never equal, then we haven't hashed into a smaller space.
If the spec says which values have the same hash then this opens up code to collisions attacks.
If the spec says it's random which values have the same hash then it's non-deterministic if the program prints foo.

is my understanding of the problem statement with the  various design constraints put forward from committee.

[02:14:42.0430] <eemeli>
> <@rbuckton:matrix.org> Plus, AFAIK equals/hash is how every implementation implements maps natively, it's just not exposed to user code.

Ashley Claymore: I understood from this earlier assertion by Ron that implementations have already found ways to square the circle with respect to "different and never equal", but maybe I misunderstood?

[02:18:32.0400] <nicolo-ribaudo>
Hashes can have conflicts ‚Äî in a Map you store a list of entries per each hash. When looking up values in the map, you:
1. Compute the has of the key
2. Get the list corresponding to that hash
3. Iterate through the list to check if the key is indeed there

[02:26:45.0807] <Ashley Claymore>
> <@eemeli:mozilla.org> Ashley Claymore: I understood from this earlier assertion by Ron that implementations have already found ways to square the circle with respect to "different and never equal", but maybe I misunderstood?

Yep. The important part is that this isn't exposed. Apart from trying to measure the execution time. Doing `map.set("a", 1)` I can't tell if there was a hash collision and it had to probe, or the buckets needed to be-resized 

[02:53:08.0319] <eemeli>
Ah, got it. So for a "different and never equal" sort of hash, `hash()` would need to remember all the values that have passed through it.

A related thought I had that could limit the impact of that would be making the hash (or composite key, not really sure how they'd be very different) linked to the lifetime of an object. Then `hash(foo, "a")` and `hash(bar, "a")` would never equal if `foo !== bar`, but `hash(obj, { a: 1, b: 2}) === hash(obj, { b: 2, a: 1 })` could work.

[05:05:43.0408] <Ashley Claymore>
That is essentially the CompositeKey / R&T design. That doesn't help Ron's use case of building high performance custom hash maps. To implement custom hash maps the only truely useful hashing function is one where it is possible for values to collide, otherwise the space hasn't been reduced to something that can fit into a small number of indexable buckets

[05:07:00.0418] <Ashley Claymore>
this is why Ron desires a hashing function that returns integers

[05:16:11.0364] <Ashley Claymore>
I would like to think that the object based R&T provide lots of value without needing to expose hashing.
While also not precluding another proposal for exposing hashing function for the use cases when full control and minimal object allocations are desirable.
For use cases when R&T can be adopted as the data model of the application, this would be efficient. Using these values as Map/Set keys would require not extra allocation (outside of the map/set's own storage naturally), and the hashing and equality functions would be 100% native with zero need for userland re-entrancy guards.
However Ron is correct that when R&T need to be created as keys because the data model and the keys are not directly compatible then those application will need to allocate more objects to create the keys. This should be more memory efficient than the current solution of flattening values into one long string, but is still an extra allocation that a purely manual hashing+equality interface would avoid.

[05:26:00.0271] <littledan>
> <@rbuckton:matrix.org> The overhead incurred by a `CompositeKey` just seems like a non-starter to me. Maybe we could find another approach that can overcome these caveats. For example, a `Hasher` class instead of a global `Object.hash()`. A given `Hasher` could just use a monotonically increasing number for each unique object instance it comes across, and maybe is configurable as to how it handles string hashing (e.g., algorithm, randomness, seed values, etc.). Then your equaler looks like `{ equals(a, b), hash(obj, hasher) }` and you then can write `new Map([], { equaler, hasher })`. Object hashes could be deterministic without being a global communications channel. String hashing can be deterministic if you want it to be, or not, as best fits your scenario.

In this hasher scenario, I don't really understand why not just use the object as a representative of its own binary hash, and I don't understand what you're proposing for compound values

[05:28:05.0258] <littledan>
> <@bakkot:matrix.org> it was not clear to me that this feedback applied to interning at construction time, with a constructor function rather than syntax

We didn't present the interning idea at that pivotal TC39 meeting because it had already been ruled out for the reasons Ashley presented about the cost of interning, based on previous conversations with implementers (which we maybe should've repeated in committee)

[05:29:07.0569] <littledan>
shu: Could you clarify whether "better" is good enough, when it comes to interning overhead?

[05:30:50.0686] <rbuckton>
I want to compare object equality structurally, not by reference. The most efficient way to do so for custom equality in a hash table is to calculate a hashcode for bucketing, and use an equals method against each element in the bucket. A user-defined hash table cannot use object reference identity as it is not a numeric value, instead it needs an identity hash. 

[05:32:34.0045] <nicolo-ribaudo>
Can you convert an object identity into a number by having a `WeakMap<object, number>`, and assigning a number to each object?

[05:36:29.0865] <littledan>
let's see if we can avoid these weak things where possible... it has a real GC perf cost

[05:37:20.0790] <littledan>
rbuckton: If your goal is to have a concurrent map, maybe we should focus on that. That could work both by identity (by default) and converting to a R&T for structural comparison (opt in with a keyBy function). Would that implement what you need?

[05:37:57.0079] <rbuckton>
That is what is generally done to work around this currently, but it has drawbacks:
- It's not resilient to version conflicts when multiple versions of the same package are installed.
- If globally accessible, it must be randomized to avoid becoming a communications channel.
- It doesn't work across threads for something like shared structs.

It's also only part of the problem with hashing, the other problem is strings.

[05:47:18.0707] <littledan>
a concurrent map would hash strings well, right?

[05:47:34.0390] <littledan>
> <@rbuckton:matrix.org> That is what is generally done to work around this currently, but it has drawbacks:
> - It's not resilient to version conflicts when multiple versions of the same package are installed.
> - If globally accessible, it must be randomized to avoid becoming a communications channel.
> - It doesn't work across threads for something like shared structs.
> 
> It's also only part of the problem with hashing, the other problem is strings.

How can you solve these problems with a custom data structure?

[05:48:00.0664] <littledan>
I'm not sure what you mean by "this is what is done" -- the concurrent map construct doesn't exist yet

[05:49:52.0354] <rbuckton>
> <@littledan:matrix.org> rbuckton: If your goal is to have a concurrent map, maybe we should focus on that. That could work both by identity (by default) and converting to a R&T for structural comparison (opt in with a keyBy function). Would that implement what you need?

One of my goals is performance. Composite keys, or using R&T as keys, is going to have overhead. If I want to use a `Uri` or a `Point` or a `Location` as a key, I would have to convert it to a R&T type or composite key first, which is an allocation for *every* call to `get`/`set`/`has`. This can be 1000s of allocations in a tight loop, and if I don't own `Uri` or `Point` or `Location` I can't just convert those to be R&T types. An `{ equals, hash }` object is a single allocation that is reused for every key.
Another of my goals is maturing the language. Custom collection classes can't perform as well as native `Map`/`Set` because developers don't have access to the requisite core capabilities necessary to make that happen. I'm concerned that composite keys either become evolutionary dead end for the language if these building blocks become available, or they become a rationale to never make these building blocks available and thus we never have the flexibility to write efficient custom collections.

[05:51:50.0436] <rbuckton>
> <@littledan:matrix.org> I'm not sure what you mean by "this is what is done" -- the concurrent map construct doesn't exist yet

I was responding to nicolo. Also, a concurrent map *does* exist. I had to build one for TypeScript as part of experimenting with shared structs. The lack of an `Object.hash()` required a significant number of workarounds that I wouldn't want to rely on in a released product.

[05:54:07.0166] <littledan>
Yes, I can see how composite keys or R&T has more runtime cost than a hashcode. That is sometimes the compromise that we make in high-level languages. I guess when domain-specific hacks are possible, they can be included as the keyBy.

[05:54:15.0547] <littledan>
> <@rbuckton:matrix.org> I was responding to nicolo. Also, a concurrent map *does* exist. I had to build one for TypeScript as part of experimenting with shared structs. The lack of an `Object.hash()` required a significant number of workarounds that I wouldn't want to rely on in a released product.

ah, now I understand why you identify strings as an issue

[05:54:17.0014] <rbuckton>
And yes, if concurrent collections were part of the MVP for shared structs then I might be less concerned, but I don't see that being likely.

[05:54:30.0178] <rbuckton>
Strings are an issue for multiple reasons.

[05:55:37.0206] <littledan>
> <@rbuckton:matrix.org> And yes, if concurrent collections were part of the MVP for shared structs then I might be less concerned, but I don't see that being likely.

I can understand your concern there but in this chat we've identified some serious concerns with exposing identity hashcodes... maybe it would work better to push on ConcurrentMap as a follow-on for shared structs, rather than these lower-level utilities in other parts of the language.

[05:55:59.0859] <rbuckton>
- Implementations need to be able to choose more efficient string hashing algorithms as they become available, and thus requires non-determinism between upgrades.
- Strings are a notorious source for hash collisions, and thus requires non-determinism between app restarts.

[05:56:49.0047] <littledan>
> <@rbuckton:matrix.org> - Implementations need to be able to choose more efficient string hashing algorithms as they become available, and thus requires non-determinism between upgrades.
> - Strings are a notorious source for hash collisions, and thus requires non-determinism between app restarts.

these sound like issues if you're going to implement your own string hashtable; if this task is offloaded to the VM, it might be easier

[06:01:02.0347] <rbuckton>
> <@littledan:matrix.org> I can understand your concern there but in this chat we've identified some serious concerns with exposing identity hashcodes... maybe it would work better to push on ConcurrentMap as a follow-on for shared structs, rather than these lower-level utilities in other parts of the language.

I need more context as to why this is a serious concern. The argument's I've heard for only advancing deterministic APIs do not seem convincing to me. Non-determinism is good for security. Non-determinism is good for performance. Non-determinism is necessary for a large percentage of existing applications. The only rationale I've heard is replay of execution, but there are other technologies for that and it depends on denial of `Math.random()` and `Date.now()` (and `Temporal.Now`, and numerous other sources of randomness). `Object.hash()` could just as easily be denied or made deterministic to serve that case. Determinism for the sake of Determinism does not serve the web platform.

[06:02:27.0279] <littledan>
We already know that we must not expose a deterministic identity hashcode operation. But we also have serious issues around nondeterminism. I'm especially concerned with the interop risks over time. This all is why we're currently taking the middle path of hiding the identity hashcode.

[06:04:10.0611] <Ashley Claymore>
userland re-entracy is also a common concern for proposals. If the equals function is written in userland, this puts userland re-entracy right at the heart of the map internal bucket probing loop. I'll leave it to engine implementations to state how much of a concern that is to them.

[06:04:35.0056] <littledan>
what do you mean by reentrancy here?

[06:04:43.0421] <Ashley Claymore>
leaving C++

[06:04:51.0244] <Ashley Claymore>
back to the application's logic

[06:05:00.0328] <Ashley Claymore>
which could re-enter the currently executing function

[06:05:09.0408] <rbuckton>
> <@littledan:matrix.org> We already know that we must not expose a deterministic identity hashcode operation. But we also have serious issues around nondeterminism. I'm especially concerned with the interop risks over time. This all is why we're currently taking the middle path of hiding the identity hashcode.

Can you expand on your concerns about interop risks? A hashcode is not a portable value. It is only relevant during the life of the application. That is the case in every language as far as I know.

[06:06:01.0585] <Ashley Claymore>
 * which could re-enter the currently executing function. Invalidating pointers, if this re-entrancy was not taken into account.
e.g. the buckets being re-sized while walked

[06:06:42.0416] <littledan>
It's easy to imagine someone depending on string hashcodes having certain properties

[06:07:21.0077] <littledan>
for example you could check whether the hashcode has changed as an indicator of whether your JS program has restarted, which feels off

[06:09:35.0562] <rbuckton>
> <@littledan:matrix.org> I can understand your concern there but in this chat we've identified some serious concerns with exposing identity hashcodes... maybe it would work better to push on ConcurrentMap as a follow-on for shared structs, rather than these lower-level utilities in other parts of the language.

Getting shared structs through committee is going to be an uphill battle. Concurrent collections are a necessity to make them practically useful in large-scale applications. If the MVP for shared structs suddenly became stage 4 today I still wouldn't be able to use them for TypeScript without having to build my own concurrent `Deque`, Work stealing queue, `ConcurrentMap`, and `ConcurrentBag`/`ConcurrentSet`.

[06:10:22.0241] <littledan>
> <@rbuckton:matrix.org> Getting shared structs through committee is going to be an uphill battle. Concurrent collections are a necessity to make them practically useful in large-scale applications. If the MVP for shared structs suddenly became stage 4 today I still wouldn't be able to use them for TypeScript without having to build my own concurrent `Deque`, Work stealing queue, `ConcurrentMap`, and `ConcurrentBag`/`ConcurrentSet`.

sounds like a good argument that we should have a built-in ConcurrentMap, whether as part of shared structs or a follow-on proposal

[06:10:40.0117] <rbuckton>
> <@littledan:matrix.org> for example you could check whether the hashcode has changed as an indicator of whether your JS program has restarted, which feels off

There are easier ways to do this that don't depend on `Object.hash()`

[06:10:51.0733] <yulia>
shu: I hear you have concerns re: import defer and it's usability for the web. happy to talk about it

[06:11:09.0970] <littledan>
"this is an uphill battle" doesn't *necessarily* imply that taking the battle somewhere else will make it easier

[06:11:42.0664] <rbuckton>
> <@littledan:matrix.org> "this is an uphill battle" doesn't *necessarily* imply that taking the battle somewhere else will make it easier

There's nowhere else to take it, IMO. 

[06:12:32.0535] <rbuckton>
> <@littledan:matrix.org> It's easy to imagine someone depending on string hashcodes having certain properties

Pretty much every hash generation API in every language include documentation that hash codes are not stable across application restarts.

[06:23:28.0899] <rbuckton>
> <@littledan:matrix.org> Yes, I can see how composite keys or R&T has more runtime cost than a hashcode. That is sometimes the compromise that we make in high-level languages. I guess when domain-specific hacks are possible, they can be included as the keyBy.

JS performance is a hot button issue in the ecosystem. The "why not rewrite in Rust" crowd is growing louder and louder, especially now that WASM-GC is available, and the easier it becomes for people to move off of JS. I want the JS language to evolve and mature, to continue to be relevant. I don't want to end up with JS just being for hobbyists because the rest of the world has moved on. We mature by adding flexibility, smoothing rough edges, improving performance, improving ergonomics, simplifying common tasks, and adding new capabilities that open the doors for new classes of applications. JS is not a specialized language, it is a general purpose language, and that's its strength.

[06:23:54.0785] <rbuckton>
> <@littledan:matrix.org> Yes, I can see how composite keys or R&T has more runtime cost than a hashcode. That is sometimes the compromise that we make in high-level languages. I guess when domain-specific hacks are possible, they can be included as the keyBy.

 * JS performance is a hot button issue in the ecosystem. The "why not rewrite in Rust" crowd is growing louder and louder, especially now that WASM-GC is available, and its becoming easier and easier for people to move off of JS. I want the JS language to evolve and mature, to continue to be relevant. I don't want to end up with JS just being for hobbyists because the rest of the world has moved on. We mature by adding flexibility, smoothing rough edges, improving performance, improving ergonomics, simplifying common tasks, and adding new capabilities that open the doors for new classes of applications. JS is not a specialized language, it is a general purpose language, and that's its strength.

[06:24:04.0744] <rbuckton>
 * JS performance is a hot button issue in the ecosystem. The "why not rewrite in Rust" crowd is growing louder and louder, especially now that WASM-GC is available, and it's becoming easier and easier for people to move off of JS. I want the JS language to evolve and mature, to continue to be relevant. I don't want to end up with JS just being for hobbyists because the rest of the world has moved on. We mature by adding flexibility, smoothing rough edges, improving performance, improving ergonomics, simplifying common tasks, and adding new capabilities that open the doors for new classes of applications. JS is not a specialized language, it is a general purpose language, and that's its strength.

[06:39:56.0817] <rbuckton>
* Pretty much every hash generation API in every language includes documentation that hash codes are not stable across application restarts.

[06:50:44.0512] <ryzokuken>
good morning/evening/night delegates! meeting starting in ~10m.

[06:58:29.0228] <shu>
> <@yulia:mozilla.org> shu: I hear you have concerns re: import defer and it's usability for the web. happy to talk about it

will take you up on that

[07:03:56.0101] <shu>
> <@littledan:matrix.org> shu: Could you clarify whether "better" is good enough, when it comes to interning overhead?

not at this time

[07:04:22.0971] <Duncan MacGregor>
I would volunteer for note taking, but I'm getting pinged on non-TC39 things a lot right now.

[07:05:42.0480] <ryzokuken>
> <@aardvark179:matrix.org> I would volunteer for note taking, but I'm getting pinged on non-TC39 things a lot right now.

understandable, thanks anyway!

[07:23:46.0164] <Michael Ficarra>
hard agree with USA here

[07:24:18.0690] <littledan>
> <@michaelficarra:matrix.org> hard agree with USA here

could you elaborate?

[07:26:57.0813] <Michael Ficarra>
stage 1 acknowledges that localisation is important for the web and something we should try to address within TC39; that remains the case, regardless of how long it will take or how hard it might be to provide a solution

[07:30:09.0310] <littledan>
> <@michaelficarra:matrix.org> stage 1 acknowledges that localisation is important for the web and something we should try to address within TC39; that remains the case, regardless of how long it will take or how hard it might be to provide a solution

Where is the point where you're disagreeing with USA?

[07:30:27.0427] <Michael Ficarra>
... nowhere?

[07:30:43.0151] <littledan>
oh oops I misread sorry

[07:31:02.0423] <littledan>
somehow turned into hard disagree

[07:39:24.0546] <Mathieu Hofman>
> <@rbuckton:matrix.org> JS performance is a hot button issue in the ecosystem. The "why not rewrite in Rust" crowd is growing louder and louder, especially now that WASM-GC is available, and it's becoming easier and easier for people to move off of JS. I want the JS language to evolve and mature, to continue to be relevant. I don't want to end up with JS just being for hobbyists because the rest of the world has moved on. We mature by adding flexibility, smoothing rough edges, improving performance, improving ergonomics, simplifying common tasks, and adding new capabilities that open the doors for new classes of applications. JS is not a specialized language, it is a general purpose language, and that's its strength.

How would a concurrent map actually be implemented in the context of wasm-gc? Isn't there the same kind of problems that you have an opaque identity for your objects like in JS?

I actually still fail to understand what the data model is for your use case, and as such what the solution space might look like. You want structural comparisons for your collection entries, but these values are shared? How can a structural comparison be stable if the data itself can change from under you? Could part of the "solution" be to make R/T sharable and valid values inside shared structs?

IMO, the ability to shim new features is highly preferable, but it rarely needs to be efficient / performant, nor does it need to be ergonomic for the shim implementer. I'd rather have a cohesive language that doesn't expose sharp edges.

[07:40:01.0774] <Mathieu Hofman>
> <@rbuckton:matrix.org> JS performance is a hot button issue in the ecosystem. The "why not rewrite in Rust" crowd is growing louder and louder, especially now that WASM-GC is available, and it's becoming easier and easier for people to move off of JS. I want the JS language to evolve and mature, to continue to be relevant. I don't want to end up with JS just being for hobbyists because the rest of the world has moved on. We mature by adding flexibility, smoothing rough edges, improving performance, improving ergonomics, simplifying common tasks, and adding new capabilities that open the doors for new classes of applications. JS is not a specialized language, it is a general purpose language, and that's its strength.

 * How would a concurrent map actually be implemented in the context of wasm-gc? Isn't there the same kind of problems that you have an opaque identity for your objects (and possibly strings) like in JS?

I actually still fail to understand what the data model is for your use case, and as such what the solution space might look like. You want structural comparisons for your collection entries, but these values are shared? How can a structural comparison be stable if the data itself can change from under you? Could part of the "solution" be to make R/T sharable and valid values inside shared structs?

IMO, the ability to shim new features is highly preferable, but it rarely needs to be efficient / performant, nor does it need to be ergonomic for the shim implementer. I'd rather have a cohesive language that doesn't expose sharp edges.

[07:40:51.0753] <Ashley Claymore>
+1 to finding ways to reduce champion burnout. There's a reason why it was 2022 when I was presented R&T :)

[07:41:31.0887] <littledan>
it has not reached an impasse

[07:44:39.0128] <Ashley Claymore>
 * +1 to finding ways to reduce champion burnout. There's a reason why it was 2022 when I last presented R&T :)

[07:50:33.0472] <nicolo-ribaudo>
I was scrolling through Twitter and found another case of somebody not realizing that `using` requires a binding even if it's not actually needed: https://twitter.com/nullvoxpopuli/status/1777364717805142411

[07:51:19.0038] <nicolo-ribaudo>
Maybe we could allow `using LeftHandSideExpression`

[07:51:22.0947] <nicolo-ribaudo>
 * Maybe we could allow `using LeftHandSideExpression ;`

[07:51:48.0623] <nicolo-ribaudo>
It would beed a cover grammar, but `using fn()` is much better than `using void = fn()`

[07:52:22.0545] <eemeli>
I used "impasse", or "stuck" in the issue, to indicate that no actions only within TC39 are sufficient for further progress. The impasse may be resolved by actions outside the committee, i.e. industry feedback and/or adoption. But didn't want to get into an argument about semantics.

[07:52:42.0873] <nicolo-ribaudo>
> <@nicolo-ribaudo:matrix.org> It would beed a cover grammar, but `using fn()` is much better than `using void = fn()`

And then `using void =` would be a syntax error like `let void =` and `const void =`

[07:53:31.0683] <Michael Ficarra>
@nicolo-ribaudo:matrix.org https://github.com/tc39/proposal-discard-binding/issues/1#issuecomment-2030365690

[07:55:12.0177] <nicolo-ribaudo>
Thank you

[07:59:11.0671] <hax (HE Shi-Jun)>
I really like allow redeclare `_` ...

[08:05:45.0046] <Ashley Claymore>
https://johnnyreilly.com/typescript-eslint-no-unused-vars

[08:06:07.0877] <Ashley Claymore>
^^ for reference to what RBN said about eslint config

[08:07:08.0825] <Duncan MacGregor>
I think the Risks and Assumptions section in the Java JEP for unnamed variables is interesting:
> We assume that little if any actively-maintained code uses underscore as a variable name. Developers migrating from Java 7 to Java 22 without having seen the warnings issued in Java 8 or the errors issued since Java 9 could be surprised. They face the risk of dealing with compile-time errors when reading or writing variables named _ and when declaring any other kind of element (class, field, etc.) with the name _.



[08:07:25.0551] <dminor>
This just feels risky to me, maybe it's better to keep this in extractors and pattern matching and explicit resource management, even if it would be nice to have it elsewhere.

[08:07:48.0608] <ljharb>
fwiw eslint supports an ignore prefix _pattern_ for the reason ron just mentioned

[08:08:46.0837] <littledan>
> <@dminor:mozilla.org> This just feels risky to me, maybe it's better to keep this in extractors and pattern matching and explicit resource management, even if it would be nice to have it elsewhere.

it seems kinda weird to me to restrict this construct to just pattern matching and explicit resource management, but if we can't have it elsewhere, that's maybe OK

[08:09:31.0970] <dminor>
I agree it would be weird

[08:09:57.0043] <dminor>
But there's no risk of breaking existing code, and we can have `_` there, right?

[08:10:56.0584] <shu>
i don't understand how any existing variable name can be web compat

[08:11:09.0332] <dminor>
It would be nice to use `_` in pattern matching, given precedent in other languages with pattern matching

[08:11:33.0333] <rbuckton>
`const _ = a, _ -= b` is illegal everywhere

[08:11:39.0956] <littledan>
> <@shuyuguo:matrix.org> i don't understand how any existing variable name can be web compat

this is if it's restricted to the new constructs

[08:11:40.0009] <nicolo-ribaudo>
> <@shuyuguo:matrix.org> i don't understand how any existing variable name can be web compat

Instead of "redeclaring a variable is an error in strict mode" it becomes "reading a variable that has been redeclared in strict mode is an error"

[08:11:42.0633] <rbuckton>
 * `const _ = a, _ = b` is illegal everywhere

[08:12:09.0540] <nicolo-ribaudo>
> <@nicolo-ribaudo:matrix.org> Instead of "redeclaring a variable is an error in strict mode" it becomes "reading a variable that has been redeclared in strict mode is an error"

"strict mode" -> I mean let, const, and strict params

[08:12:10.0613] <ljharb>
but `var _ = 1, _ = 2;` is not

[08:12:15.0471] <ljharb>
 * but `var _ = 1, _ = 2;` is not illegal anywhere

[08:12:29.0884] <nicolo-ribaudo>
> <@ljharb:matrix.org> but `var _ = 1, _ = 2;` is not illegal anywhere

And nobody is proposing changing how it works

[08:12:53.0212] <Jack Works>
I don't like `_` as discard. What's wrong with `void`? Is there any pushback on `void`?

[08:13:01.0002] <ljharb>
what about `function f(_, _) {}`, which is legal in sloppy mode?

[08:13:06.0430] <shu>
> <@nicolo-ribaudo:matrix.org> Instead of "redeclaring a variable is an error in strict mode" it becomes "reading a variable that has been redeclared in strict mode is an error"

sloppy mode so popular though?

[08:13:13.0598] <eemeli>
To me "void" sounds an awful lot like "undefined".

[08:13:45.0745] <ryzokuken>
for C/C++ developers it could be a source of confusion, yes

[08:13:47.0296] <ljharb>
and indeed the binding is not defined :-p

[08:14:30.0672] <nicolo-ribaudo>
> <@shuyuguo:matrix.org> sloppy mode so popular though?

The error cases remain the same, with the difference that the error is moved from declaration position to reference position

[08:14:45.0685] <nicolo-ribaudo>
So what works in strict mode would keep working the same

[08:14:49.0267] <Ashley Claymore>
I assume other languages could cope with `_` easier because they didn't have a popular library that was commonly imported as `_`

[08:14:56.0025] <nicolo-ribaudo>
 * So what works in any mode would keep working the same

[08:15:16.0881] <shu>
> <@nicolo-ribaudo:matrix.org> The error cases remain the same, with the difference that the error is moved from declaration position to reference position

i am still confused what the proposed semantics is for sloppy mode

[08:15:38.0075] <Justin Ridgewell>
@rbuckton:matrix.org Why do we lose assignment patterns with `_`?

[08:15:39.0408] <ryzokuken>
> <@aclaymore:matrix.org> I assume other languages could cope with `_` easier because they didn't have a popular library that was commonly imported as `_`

it's on us for not doing modules/namespaces well I guess

[08:15:43.0798] <ryzokuken>
> <@aclaymore:matrix.org> I assume other languages could cope with `_` easier because they didn't have a popular library that was commonly imported as `_`

 * it's on us for not doing modules/namespaces well at start I guess

[08:15:52.0525] <Justin Ridgewell>
The simple case is just to allow redeclaring `_`, no other restrictions.

[08:15:52.0603] <nicolo-ribaudo>
> <@shuyuguo:matrix.org> i am still confused what the proposed semantics is for sloppy mode

vars and function params can be redeclared, but if you redeclare a let/const then it throws when you reference the binding

[08:16:02.0946] <Ashley Claymore>
> <@usharma:igalia.com> it's on us for not doing modules/namespaces well at start I guess

How would that change things?
People do `import _ from "lodash"`

[08:16:10.0366] <bakkot>
I am totally fine restricting this feature to strict mode

[08:16:33.0391] <Justin Ridgewell>
> <@aclaymore:matrix.org> How would that change things?
> People do `import _ from "lodash"`

Renaming a static import is trivial.

[08:16:46.0538] <Ashley Claymore>
Sure, but popular?

[08:17:01.0235] <ryzokuken>
plus the `_` name is less necessary with imports

[08:17:20.0959] <ryzokuken>
but if all you can do is pollute the global namespace, `$` and `_` abound.

[08:17:22.0122] <Justin Ridgewell>
They should be using `import { foo, bar } from ‚Äòlodash‚Äô` anyways‚Ä¶

[08:17:49.0377] <ljharb>
they should be using `import foo from 'lodash.foo'` anyways, to avoid the CVE noise :-p

[08:18:00.0080] <bakkot>
nothing wrong with namespace imports

[08:18:03.0865] <shu>
> <@nicolo-ribaudo:matrix.org> vars and function params can be redeclared, but if you redeclare a let/const then it throws when you reference the binding

okay well, i don't think this proposal meets the bar thus far for complicated binding handling

[08:18:45.0160] <ljharb>
> <@bakkot:matrix.org> nothing wrong with namespace imports

in this case i'm complaining about big-bag-o-things packages, not namespace imports

[08:18:54.0548] <Justin Ridgewell>
> <@bakkot:matrix.org> nothing wrong with namespace imports

Too many people mistake it for a mutable object, or use it dynamically in a way the minifier can‚Äôt eliminate _everything_ else.

[08:19:28.0214] <bakkot>
well don't do that

[08:19:30.0797] <ljharb>
^ the latter is also a problem with barrel files

[08:19:41.0744] <bakkot>
but put the blame where the problem is, not on something else

[08:20:03.0985] <ljharb>
the-world-if-people-didnt-do-things-they-shouldnt-do.jpg

[08:21:38.0595] <danielrosenwasser>
> <@aclaymore:matrix.org> I assume other languages could cope with `_` easier because they didn't have a popular library that was commonly imported as `_`

you should see the bananas stuff I've heard about in Python

[08:22:11.0737] <Ashley Claymore>
yes please! I have done very little Python and am all ears!

[08:22:32.0803] <danielrosenwasser>
https://docs.djangoproject.com/en/5.0/topics/i18n/translation/

[08:23:09.0061] <danielrosenwasser>
Okay, it's not really bananas - but they're doing the same thing

[08:23:15.0924] <Justin Ridgewell>
> <@shuyuguo:matrix.org> okay well, i don't think this proposal meets the bar thus far for complicated binding handling

We don‚Äôt need the ‚Äúreference the binding‚Äù restriction.

[08:23:39.0483] <shu>
that would be more palatable

[08:23:49.0545] <danielrosenwasser>
> <@aclaymore:matrix.org> I assume other languages could cope with `_` easier because they didn't have a popular library that was commonly imported as `_`

 * you should see the ~bananas stuff~ similar stuff I've seen in Python

[08:24:45.0983] <ptomato>
aliasing `gettext()` to `_()` is a fairly common pattern for programming languages that have an implementation of gettext

[08:25:00.0895] <eemeli>
I'm really interested in extractors effectively providing runtime types: https://github.com/tc39/proposal-extractors/issues/20

[08:25:08.0060] <ptomato>
because the `xgettext` tool extracts strings inside `_()` out of source files into message files

[08:25:18.0203] <danielrosenwasser>
Justin Ridgewell: you mean bindings to `_` work in a last-write-wins manner and so there's no ambiguity?

[08:25:32.0136] <Justin Ridgewell>
Yes

[08:25:32.0198] <danielrosenwasser>
 * Justin Ridgewell: you mean bindings to `_` work in a last-write-wins manner and so there's no ambiguity error?

[08:25:55.0540] <Justin Ridgewell>
It‚Äôs just a regular binding, but it can be redeclared.

[08:26:23.0883] <bakkot>
I like rust's thing where a redeclaration introduces a new scope which shadows the previous one

[08:26:33.0004] <bakkot>
so closures which capture the old one still work

[08:26:39.0962] <bakkot>
at least I assume that's how it works, I haven't actually checked

[08:26:47.0673] <bakkot>
now that I'm saying this I have no idea why I believe it

[08:26:58.0989] <eemeli>
With extractors, you can have
```
function foo(String(s), Number(n)) { ... }
```
and be sure of `s` being a string and `n` being a number.

[08:27:14.0323] <Ashley Claymore>
I think that's right

[08:27:49.0124] <ljharb>
i think you'd need `String(const s)` etc to make the binding tho?

[08:27:54.0776] <eemeli>
Nope.

[08:27:58.0864] <Justin Ridgewell>
> <@bakkot:matrix.org> so closures which capture the old one still work

The closure would have to move the value in. I‚Äôm not sure it works the way you think.

[08:29:03.0501] <Michael Ficarra>
@eemeli:mozilla.org what `Symbol.customMatcher` implementation are you thinking of for the built-in constructors?

[08:30:06.0606] <ljharb>
those are in the pattern matching proposal, fwiw

[08:30:12.0143] <ljharb>
 * those are already in the pattern matching proposal, fwiw

[08:30:28.0214] <ljharb>
 * those are already in the pattern matching proposal, fwiw, with brand checking semantics

[08:30:51.0041] <bakkot>
... brand checking or typeof?

[08:30:56.0316] <eemeli>
Something like
```
class Number {
  ...
  [Symbo.customMatcher](subject) {
    if (typeof subject === 'number') return [subject];
    if (subject instanceof Number) return [Number(subject)];
    return false;
  }
}
```

[08:31:21.0465] <eemeli>
 * Something like

```
class Number {
  ...
  [Symbol.customMatcher](subject) {
    if (typeof subject === 'number') return [subject];
    if (subject instanceof Number) return [Number(subject)];
    return false;
  }
}
```

[08:31:33.0154] <bakkot>
I am categorically opposed to accepting boxed primitives here or anywhere

[08:31:38.0386] <ljharb>
it'd check for the internal slot of a Number instead of instanceof, but otherwise yes

[08:31:52.0609] <Justin Ridgewell>
> <@jridgewell:matrix.org> The closure would have to move the value in. I‚Äôm not sure it works the way you think.

Actually you can‚Äôt reference `_` in a closure (I‚Äôve never tried before): https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=ab28412522dba608f6964c9a11ce600f

[08:32:18.0124] <ljharb>
> <@bakkot:matrix.org> I am categorically opposed to accepting boxed primitives here or anywhere

it doesn't make any sense to reject boxed primitives if people are going to be referencing the constructor

[08:32:27.0053] <ljharb>
i don't expect it to come up in practice either way tho, tbf

[08:32:38.0354] <ljharb>
> <@bakkot:matrix.org> I am categorically opposed to accepting boxed primitives here or anywhere

 * it doesn't make any sense to reject boxed primitives if people are going to be referencing the _constructor_

[08:32:41.0875] <bakkot>
sure it does, `Number(foo)` doesn't produce a boxed primitive

[08:32:44.0217] <eemeli>
I don't care about boxed primitives tbh.

[08:32:55.0952] <ljharb>
it's a constructor. `new Number(foo)` does

[08:33:05.0594] <bakkot>
if the extractor used `new` I would agree with you

[08:33:08.0081] <bakkot>
but it doesn't

[08:33:15.0844] <Michael Ficarra>
`const new Number(n) = 5`

[08:33:23.0096] <ljharb>
so you want the requirement to be `new UserClass()` to match a user class?

[08:33:35.0333] <ljharb>
 * so you want the requirement to be `new UserClass` as a pattern to match a user class?

[08:33:42.0655] <eemeli>
`new Number` is not a valid ExtractorMemberExpression.

[08:34:10.0610] <Michael Ficarra>
@eemeli:mozilla.org sorry I forgot the Kappa

[08:34:13.0495] <ljharb>
iow, a pattern of `Number` and a pattern of `UserClass` should work the same - either both require new or neither does

[08:34:16.0329] <Michael Ficarra>
I'll go back to TDZ

[08:34:25.0593] <ljharb>
and i don't see any argument for requiring `new` on non-primitive constructors

[08:34:50.0469] <bakkot>
`UserClass(foo)` should throw or either behave the same as `new UserClass(foo)`, so it's fine for `let UserClass(foo) = bar` to be the extractor pattern

[08:35:03.0442] <bakkot>
but `Number` doesn't work like that, so we can't use that as precedent for how `Number` should work

[08:35:21.0689] <ljharb>
not if it's an ES5 class

[08:35:40.0625] <ljharb>
and many predicates are constructible (because they're not written as arrows or concise methods)

[08:35:54.0916] <ljharb>
 * and many predicates are technically constructible (because they're not written as arrows or concise methods)

[08:36:01.0426] <ljharb>
 * and many predicates are technically constructible (because they're not written as arrows or concise methods etc)

[08:36:11.0827] <bakkot>
I don't think "this is technically constructible" ought to guide our design of these features

[08:36:25.0786] <bakkot>
this applies to user-defined predicates and also to `Number`

[08:36:29.0518] <ljharb>
ok. but we don't actually have a clear thing in JS that divides constructors and functions, so PascalCase is the universal convention that JS devs use for that

[08:37:14.0488] <ljharb>
so, designing for that universal expectation, Number would (and does) look like a constructor just like UserClass or Set

[08:37:16.0747] <bakkot>
users should not regard Number as being constructible and we should not design the feature to suggest that it is

[08:37:40.0205] <bakkot>
it is true that `Number` is technically constructible but I don't care about this fact, and we should not promote it to people's attention, nor make features which support it

[08:38:32.0848] <ljharb>
i do not believe that it accepting boxed primitives - and unboxing them, ftr - is going to encourage usage of it. i strongly believe the opposite

[08:38:36.0177] <Justin Ridgewell>
> <@jridgewell:matrix.org> Actually you can‚Äôt reference `_` in a closure (I‚Äôve never tried before): https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=ab28412522dba608f6964c9a11ce600f

Anyways, the value is _moved_ into the closure when you create it, so it‚Äôs not redeclaring a scope: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=0be61d281692f23d745632011a77a86b

[08:38:45.0662] <bakkot>
> <@ljharb:matrix.org> i do not believe that it accepting boxed primitives - and unboxing them, ftr - is going to encourage usage of it. i strongly believe the opposite

... say more?

[08:38:59.0429] <ljharb>
certainly no new sites of *producing* a boxed primitive should ever be added

[08:39:47.0956] <ljharb>
if you want to use pattern matching, with the current semantics, even if you do the very unlikely thing of making a boxed primitive, you will as rapidly as possible unbox it.

just like how sparse arrays are terribad, and all new stuff just papers over that by making them dense, and we do NOT throw when you have a sparse array

[08:39:52.0031] <littledan>
I thought V8 optimized array destructuring

[08:39:58.0027] <ljharb>
 * if you want to use pattern matching, with the current semantics, even if you do the very unlikely thing of making a boxed primitive, you will as rapidly as possible unbox it.

just like how sparse arrays are terribad, and all new stuff just papers over that by making them dense, and we do NOT throw when you have a sparse array, we shouldn't throw or fail when you have a boxed primitive. we should just paper over it.

[08:40:16.0406] <ljharb>
 * if you want to use pattern matching, with the current semantics, even if you do the very unlikely thing of making a boxed primitive, you will as rapidly as possible unbox it.

just like how sparse arrays are terribad, and all new stuff just papers over that by making them dense, and we do NOT throw when you have a sparse array, we shouldn't throw or fail when you have a boxed primitive. we should just paper over it and get you into "normal primitives" as fast as possible.

[08:40:20.0394] <bakkot>
> <@ljharb:matrix.org> if you want to use pattern matching, with the current semantics, even if you do the very unlikely thing of making a boxed primitive, you will as rapidly as possible unbox it.
> 
> just like how sparse arrays are terribad, and all new stuff just papers over that by making them dense, and we do NOT throw when you have a sparse array, we shouldn't throw or fail when you have a boxed primitive. we should just paper over it and get you into "normal primitives" as fast as possible.

we don't throw when we have a sparse array because it would require a special case to do so

[08:40:23.0293] <hax (HE Shi-Jun)>
> <@littledan:matrix.org> I thought V8 optimized array destructuring

I remember they published an article about it several years ago

[08:40:39.0111] <bakkot>
but here you're suggesting we add a special case to _support_ the thing that people should not encounter

[08:40:43.0197] <bakkot>
I want to not do that

[08:40:45.0728] <littledan>
we have to avoid saying "stage n concern" because of the ambiguity between this being a thing to resolve before reaching stage n, or only once stage n is reached

[08:41:09.0302] <bakkot>
if user is passing around a boxed primitive, they should expect to get an error, not for the language to accomadate them

[08:41:17.0549] <ljharb>
p sure the motivation was more "because that hurts people to no benefit" as opposed to "we don't want a special case in the spec/impl"

[08:41:17.0555] <bakkot>
 * if user is passing around a boxed primitive, they should expect to get an error, not for the language to accommodate them

[08:43:21.0590] <bakkot>
I do not think that's right, but in any case, boxed primitives are more different from primitives than holey arrays are from dense arrays

[08:45:06.0871] <Justin Ridgewell>
> <@littledan:matrix.org> I thought V8 optimized array destructuring

It‚Äôs still not nearly as fast as regular property destrutcuring

[08:45:07.0739] <ljharb>
boxed primitives exist. if they are used, then providing encouragement and ergonomics for quickly getting them unboxed is good. if they are not used, then accepting them provides no such encouragement.

[08:45:38.0603] <Ashley Claymore>
> <@haxjs:matrix.org> I remember they published an article about it several years ago

https://docs.google.com/document/d/1hWb-lQW4NSG9yRpyyiAA_9Ktytd5lypLnVLhPX9vamE/edit#heading=h.9ss45aibqpw2

[08:46:03.0143] <bakkot>
counterpoint: if they are used, _discouraging their use_ is good

[08:46:10.0245] <bakkot>
no code should accept them

[08:46:20.0449] <bakkot>
(unless it accepts other bjects, of course)

[08:46:22.0764] <bakkot>
 * (unless it accepts other objects, of course)

[08:50:01.0268] <bakkot>
I am not looking forward to parsing `foo(bar(baz)) => 0`

[08:50:26.0393] <littledan>
extractors do a good job addressing one of the points that Yulia raised a while ago, about the availability of parallel constructs inside and outside of pattern matching.

[08:50:35.0142] <bakkot>
 * I am not looking forward to parsing `(bar(baz)) => 0`

[08:50:41.0583] <bakkot>
but I guess it's not that much worse than `({ bar }) => 0`

[08:51:07.0274] <bakkot>
and `async(bar(baz)) => 0` of course

[08:52:06.0915] <littledan>
yeah by 2017 we already got up to a certain bar of annoying-to-parse, and my feeling was that extractors didn't really add anything that was so bad... but non-backtracking parsers will have some more complexity in their error tracking with this

[08:52:17.0478] <littledan>
 * yeah by 2017 we already got up to a certain bar of annoying-to-parse, and my feeling was that extractors didn't really add anything that was so much more bad... but non-backtracking parsers will have some more complexity in their error tracking with this

[08:53:34.0181] <bakkot>
it is not that much worse, it's just adding more complexity to what is already the single most complex-to-parse construct in the language

[08:54:40.0825] <Michael Ficarra>
the extractor has to be an identifier or a member access on an extractor, right?

[08:55:20.0970] <bakkot>
yeah

[08:55:22.0498] <eemeli>
It can also be e.g. `super`.

[08:55:24.0763] <bakkot>
https://tc39.es/proposal-extractors/#prod-ExtractorMemberExpression

[08:55:51.0140] <eemeli>
Ah, not `super`, just `super.foo` or `this`.

[08:58:06.0590] <shu>
i mean in general i agree with george but i got bad news for him on the understandability of JS wrt user code today

[09:01:56.0854] <Ashley Claymore>
That's because it's all minified on the web

[09:04:06.0300] <rbuckton>
> <@jridgewell:matrix.org> @rbuckton:matrix.org Why do we lose assignment patterns with `_`?

Because you can already write `[_, _] = ar` today and it has a meaning.

[09:04:23.0087] <keith_miller>
Do other engines think that throwing for each failed match seems like it would be way too slow?

[09:04:34.0231] <littledan>
> <@keith_miller:matrix.org> Do other engines think that throwing for each failed match seems like it would be way too slow?

I think the concern was more around the iteration protocol

[09:04:36.0727] <keith_miller>
Or did I just misunderstand the proposal?

[09:04:53.0643] <littledan>
also engines don't have to actually do the throw

[09:05:49.0137] <Justin Ridgewell>
> <@rbuckton:matrix.org> Because you can already write `[_, _] = ar` today and it has a meaning.

But that‚Äôs behaving exactly the way discard bindings should.

[09:05:56.0870] <keith_miller>
You'd need to inline every pattern, IIUC, which doesn't seem plausible in all places (it could be virtual, it could be huge, etc)

[09:05:58.0063] <rbuckton>
> <@keith_miller:matrix.org> Do other engines think that throwing for each failed match seems like it would be way too slow?

While that's more of a discussion for pattern matching, Refutability is a very important mechanic for pattern matching. If you want irrefutability, you use a `default:` clause.

[09:06:02.0746] <Justin Ridgewell>
We just need the ability to redeclare.

[09:07:10.0884] <keith_miller>
I agree it's more of a discussion for pattern matching I don't want to get to a place where we have throwing here and have to have a totally different mechanism for pattern matching

[09:07:31.0568] <ljharb>
> <@keith_miller:matrix.org> Do other engines think that throwing for each failed match seems like it would be way too slow?

it would be for a failed `match` not for a failed _clause_, to be clear - the intention for a match construct is that it always matches something

[09:07:38.0449] <Ashley Claymore>
> <@jridgewell:matrix.org> We just need the ability to redeclare.

which definition would closures capture?

[09:07:43.0546] <rbuckton>
> <@jridgewell:matrix.org> But that‚Äôs behaving exactly the way discard bindings should.

Redeclare what? if `_` isn't already declared, `[_, _] = ar` will either throw in strict mode, or introduce a global in non-strict mode. I don't think we can change that. If you want to use `_` as a discard in assignments, you do that by declaring a `var _` somewhere in the same scope.

[09:08:15.0481] <rbuckton>
Or are you talking about binding patterns?

[09:08:30.0368] <gkz>
> <@shuyuguo:matrix.org> i mean in general i agree with george but i got bad news for him on the understandability of JS wrt user code today

If we're creating a brand new feature, why not aim higher? Especially if the increased power/flexibility is not required for the majority of use-cases 

[09:09:03.0804] <rbuckton>
> <@keith_miller:matrix.org> I agree it's more of a discussion for pattern matching I don't want to get to a place where we have throwing here and have to have a totally different mechanism for pattern matching

This must throw. If `const {} = null` throws or `const [] = 1` throws, so must this.

[09:09:49.0327] <rbuckton>
`match` must throw if it has no default. Since `match` is syntactic, if a `default:` clause doesn't exist you just synthetically introduce one that throws.

[09:10:20.0977] <shu>
> <@gkz:matrix.org> If we're creating a brand new feature, why not aim higher? Especially if the increased power/flexibility is not required for the majority of use-cases

you're reading the wrong conclusion. i, as an engine person, would be very happy with no custom matchers

[09:10:35.0854] <shu>
i'm saying that doesn't meaningfully move the needle for the general problem of understanding user code in JS

[09:11:42.0568] <littledan>
shu: dminor : What was the performance concern?

[09:11:49.0596] <shu>
the new one?

[09:12:01.0551] <shu>
my new one is cover grammars incur cost, as you well know

[09:12:03.0289] <shu>
and we don't like it

[09:12:05.0423] <shu>
nothing deeper than that

[09:13:25.0822] <Justin Ridgewell>
> <@rbuckton:matrix.org> Redeclare what? if `_` isn't already declared, `[_, _] = ar` will either throw in strict mode, or introduce a global in non-strict mode. I don't think we can change that. If you want to use `_` as a discard in assignments, you do that by declaring a `var _` somewhere in the same scope.

Oh, I was assuming `_` was already a binding in scope. Why can‚Äôt we make sloppy mode continue to function as is, and just not create the binding in strict?

[09:13:44.0556] <rbuckton>
Regarding the `const InventoryID(customerId) = "Contoso-12345"` example, I've regularly described extractors as _unapplication_ (the Scala method is literally called `unapply()`). This dualilty is important for both data types and primitive types:

```js
const InventoryID(customerID, Name) = InventoryID("12345", "Contoso");
```


[09:15:14.0172] <rbuckton>
> <@jridgewell:matrix.org> Oh, I was assuming `_` was already a binding in scope. Why can‚Äôt we make sloppy mode continue to function as is, and just not create the binding in strict?

That would definitely be a violation of ljharb 's concerns. I think we can only use `_` if it would otherwise be syntactically illegal. If you have 

```js
var _ = require("lodash");
function f() {
  [_, _] = [1, 2, 3];
}
```

Then you're breaking code non-locally.

[09:16:18.0073] <Justin Ridgewell>
> <@rbuckton:matrix.org> That would definitely be a violation of ljharb 's concerns. I think we can only use `_` if it would otherwise be syntactically illegal. If you have 
> 
> ```js
> var _ = require("lodash");
> function f() {
>   [_, _] = [1, 2, 3];
> }
> ```
> 
> Then you're breaking code non-locally.

We had that discussion above. Renaming the lodash import is trivial.

[09:17:15.0167] <rbuckton>
In a 10,000 line file, it's easy to lose sight of the imports at the top of the file.

[09:18:43.0197] <ljharb>
oof, if you have a 10k line file you have bigger problems than a binding no longer working

[09:19:22.0609] <gkz>
> <@rbuckton:matrix.org> Regarding the `const InventoryID(customerId) = "Contoso-12345"` example, I've regularly described extractors as _unapplication_ (the Scala method is literally called `unapply()`). This dualilty is important for both data types and primitive types:
> 
> ```js
> const InventoryID(customerID, Name) = InventoryID("12345", "Contoso");
> ```

I don't disagree that there are use-cases that would be addressed with this, just that the power required to support them (when these are the minority of use-cases, and other languages e.g. OCaml do fine without supporting this), allows completely arbitrary behavior which means that it will be more difficult to understand and analyze the main use-case, which is matching against some datatype and extracting values from it. 

[09:19:31.0843] <rbuckton>
Yeah, yeah. I'd love to refactor checker.ts to something more manageable, but that's still a ways out.

[09:20:41.0304] <rbuckton>
> <@gkz:matrix.org> I don't disagree that there are use-cases that would be addressed with this, just that the power required to support them (when these are the minority of use-cases, and other languages e.g. OCaml do fine without supporting this), allows completely arbitrary behavior which means that it will be more difficult to understand and analyze the main use-case, which is matching against some datatype and extracting values from it.

Do you mean something more like Python's `__match_args__` approach? I've discussed that with the pattern matching champions and there was fairly strong opposition.

[09:21:35.0512] <eemeli>
rbuckton: Are there any dynamically typed languages that support extractors?

[09:23:06.0066] <rbuckton>
OCaml is a statically typed language, as is Rust. They have type systems to do the work for them. JS does not. It often depends on runtime evaluation of code to do similar things. Extractors is the way it is because it isn't statically typed.

[09:23:41.0836] <eemeli>
Racket, apparently?

[09:24:00.0307] <gkz>
> <@rbuckton:matrix.org> Do you mean something more like Python's `__match_args__` approach? I've discussed that with the pattern matching champions and there was fairly strong opposition.

I'm not familiar with that feature, but to explain what I mean in loose terms, you could still have a `customMatcher`-like function which can decide which values to return for extraction, but the check of "is this of this datatype" (be it instanceof or whatever) would always be run, separating these two concerns

[09:24:15.0960] <rbuckton>
> <@eemeli:mozilla.org> rbuckton: Are there any dynamically typed languages that support extractors?

Python has `__match_args__`, not full extractors. They'd considered them but determined they didn't have use cases. JS has private state, which Python does not, so a `__match_args__` approach is not sufficient. Other Pattern Matching champions have opinions on this as well.

[09:24:49.0358] <gkz>
Dart recently added a pattern matching feature, and seems to work in this way: https://dart.dev/language/pattern-types#object

[09:27:15.0515] <rbuckton>
> <@gkz:matrix.org> I'm not familiar with that feature, but to explain what I mean in loose terms, you could still have a `customMatcher`-like function which can decide which values to return for extraction, but the check of "is this of this datatype" (be it instanceof or whatever) would always be run, separating these two concerns

In Python, you can do
```py
match p:
  case Point(x=0, y=0): ...
```
where `Point.__match_args__` is `["x", "y"]`.

It checks if `p` is a `Point`, then basically checks if `p[Point.__match_args__[0]] == 0 and p[Point.__match_args__[1]] == 0`

[09:29:03.0019] <rbuckton>
There is no opportunity to run user-defined code as part of that validation. It can also only read public properties, but that's fine for Python since it does not have privacy. A `Point[Symbol.matchArgs] = ["#x", "#y"]` in JS wouldn't be able to read a private `#x` in JS.

[09:32:00.0259] <littledan>
Is Mark Miller here this afternoon?

[09:32:19.0117] <littledan>
my presentation is largely about refuting a past argument that he made

[09:32:35.0551] <eemeli>
Random thought: Would `@@customMatcher` as a generator be potentially more performant than returning an array or iterator?

[09:35:53.0169] <littledan>
> <@littledan:matrix.org> my presentation is largely about refuting a past argument that he made

he seems to be in the call, so I'll go ahead

[09:36:13.0750] <littledan>
> <@eemeli:mozilla.org> Random thought: Would `@@customMatcher` as a generator be potentially more performant than returning an array or iterator?

what does this question mean? a generator returns an iterator.

[09:36:52.0454] <littledan>
> <@rbuckton:matrix.org> There is no opportunity to run user-defined code as part of that validation. It can also only read public properties, but that's fine for Python since it does not have privacy. A `Point[Symbol.matchArgs] = ["#x", "#y"]` in JS wouldn't be able to read a private `#x` in JS.

you can intercept __getattr__ though!

[09:37:01.0212] <littledan>
> <@rbuckton:matrix.org> There is no opportunity to run user-defined code as part of that validation. It can also only read public properties, but that's fine for Python since it does not have privacy. A `Point[Symbol.matchArgs] = ["#x", "#y"]` in JS wouldn't be able to read a private `#x` in JS.

 * you can intercept `__getattr__` though!

[09:39:20.0204] <eemeli>
littledan: I mean having
```
class Number {
  ...
  *[Symbol.customMatcher](subject) {
    if (typeof subject === 'number') yield subject;
    else if (subject instanceof Number) yield Number(subject);
    else return false;
    return true;
  }
}
```
instead of
```
class Number {
  ...
  [Symbol.customMatcher](subject) {
    if (typeof subject === 'number') return [subject];
    if (subject instanceof Number) return [Number(subject)];
    return false;
  }
}
```

[09:39:33.0723] <mgaudet>
(side note: Can someone update the topic to point to this meeting rather than feb) 

[09:41:48.0502] <gkz>
> <@rbuckton:matrix.org> There is no opportunity to run user-defined code as part of that validation. It can also only read public properties, but that's fine for Python since it does not have privacy. A `Point[Symbol.matchArgs] = ["#x", "#y"]` in JS wouldn't be able to read a private `#x` in JS.

I like this aspect of the feature:
"Whether a match succeeds or not is determined by the equivalent of an isinstance call. If the subject (shape, in the example) is not an instance of the named class (Point or Rectangle), the match fails."

But my focus is on that, if you wanted to still have a `Symbol.matchArgs` function to determine the values being extracted, which can access private properties, that could be fine.
This simply separates the concerns of "is this a value of this datatype" and "what values should be extracted" rather than combining them into one function and allowing both to be user-defined.

[09:43:59.0496] <rbuckton>
That does not satisfy my goals and motivations. Pattern matching could do that with `x is Point and { let x, let y }`. Executing user-defined code is the whole point of the feature.

[09:45:01.0819] <Mathieu Hofman>
> <@littledan:matrix.org> Is Mark Miller here this afternoon?

he should be, I'll make sure he is

[09:45:26.0306] <gkz>
To clarify, with that example it would be `x is Point(let x, let y)` - we check if `x instanceof Point`, and then get the arguments you want extracted

[09:45:51.0317] <gkz>
If would just not allow things like using extractors on strings to extract parts of those strings

[09:46:21.0729] <gkz>
I guess this would be similar to how both Python and Dart use these features

[09:47:23.0852] <rbuckton>
I want to be able to do that with this feature. Restricting it to data types is a manufactured limitation, not a natural limitation of the syntax.

[09:47:29.0999] <Anthony Bullard>
> <@gkz:matrix.org> I guess this would be similar to how both Python and Dart use these features

It is very similar to Dart. Which has been well received

[09:47:46.0148] <rbuckton>
Also, `instanceof` is broken. Pattern matching is not using it.

[09:48:40.0252] <gkz>
Sure, whatever actual check is more appropriate to use, I think the general idea I'm talking about is clear though

[09:49:31.0069] <iain>
> <@eemeli:mozilla.org> Random thought: Would `@@customMatcher` as a generator be potentially more performant than returning an array or iterator?

No. Returning an array is the least-bad case for the iterator protocol. 

[09:49:41.0645] <rbuckton>
I understand the semantics you are describing. I just see no reason to introduce an artificial limitation. 

[09:50:05.0905] <rbuckton>
If a custom matcher is an iterator, then it is irrefutable. It always matches.

[09:51:31.0611] <eemeli>
iain: Presumably with the exception of only returning one value, and handling its destruction as a separate concern.

[09:51:56.0064] <rbuckton>
The reason I pursued this feature in the first place was to support user-defined validation and transformation. That it works for datatypes is a happy benefit.

[09:53:07.0709] <iain>
eemeli: Yes, returning a single value would be significantly more performant

[09:53:40.0749] <rbuckton>
Also, you can destructure a string, so restricting extractors to datatypes breaks that. `const { length } = "abc"` and `const [a, b, c]="abc"` are perfectly legal. I don't want extractors to be _less_ capable than `{}` and `[]`.

[09:54:23.0066] <nicolo-ribaudo>
Webex is again refusing to pick up my audio, hopefully I can fix it on time

[09:54:48.0449] <eemeli>
> <@iain:mozilla.org> eemeli: Yes, returning a single value would be significantly more performant

And then you'd need to write e.g. `let Point([x, y]) = ...` to get the same effect, if you need more than one value out of the extractor.

[09:55:35.0773] <gkz>
> <@rbuckton:matrix.org> I understand the semantics you are describing. I just see no reason to introduce an artificial limitation.

It seems like languages like Dart, Python, OCaml, Rust all have this limitation. And the reason is what I described before, there is a trade-off between the flexibility this feature provides, and making code easy to understand (for both humans and tooling)

[09:55:43.0411] <rbuckton>
Besides, writing an extractor to handle a non-datatype input is more complex than the default implementation for a data type. In the pattern matching proposal, `class C {}` will have a default `[Symbol.customMatcher]` that performs a brand check and returns the subject. You get it for free unless you want to do the more complex things.

[09:57:25.0552] <rbuckton>
And ideally, ADT enums would have a default implementation that matched their definition, i.e.:

```js
enum Message {
  Write(text),
  Move({ x, y })
}

const Message.Write(text) = msg1;
const Message.Move({ x, y }) = msg2;
```
You would have to manually write a `[Symbol.customMatcher]` method to override this behavior, so it is an opt-in mechanism.

[09:58:04.0574] <rbuckton>
> <@gkz:matrix.org> It seems like languages like Dart, Python, OCaml, Rust all have this limitation. And the reason is what I described before, there is a trade-off between the flexibility this feature provides, and making code easy to understand (for both humans and tooling)

C# and Scala do not have this limitation. Scala has `unapply`, C# has `Deconstruct`.

[09:59:27.0340] <gkz>
Yeah, given that there are trade-offs and different languages have made different design choices regarding this trade-off, it seems worth discussing at least!

[10:00:04.0886] <littledan>
Slides for my Array.isTemplateObject presentation: https://docs.google.com/presentation/d/1LTlzpboYwKxRwigATcFYEh06CIbZvOvmFdPzkNn7vJI/edit#slide=id.g2cae2397581_0_66

[10:01:49.0230] <rbuckton>
> <@gkz:matrix.org> Yeah, given that there are trade-offs and different languages have made different design choices regarding this trade-off, it seems worth discussing at least!

A good place to continue this discussion would be in the the #tc39-pattern-matching:matrix.org room

[10:02:07.0820] <gkz>
Thanks, will join now!

[10:08:49.0839] <eemeli>
> <@rbuckton:matrix.org> Besides, writing an extractor to handle a non-datatype input is more complex than the default implementation for a data type. In the pattern matching proposal, `class C {}` will have a default `[Symbol.customMatcher]` that performs a brand check and returns the subject. You get it for free unless you want to do the more complex things.

Is there any plan to move/add those default matchers to extractors?

[10:11:32.0925] <rbuckton>
The exact semantics need to match between destructuring and pattern matching, so yes, most likely. Currently it's being managed as a cross-cutting concern between the two proposals. If extractors in destructuring gets Stage 2, but pattern matching is held back, then we would likely need to move over the default semantics.

[10:18:08.0592] <ljharb>
i don't think stage 2 is the time to separate them, it'd be if extractors is ready for 2.7, and pattern matching isn't stage 2 and also is content with the design constraints that advancing extractors would cause

[10:30:59.0581] <ljharb>
ok so why is this stage 3 instead of a normative PR? the discussion was hard to follow

[10:31:12.0175] <Michael Ficarra>
it should return a spec enum or a string

[10:31:36.0350] <ljharb>
 * i don't think stage 2 is the time to separate them, it'd be if extractors is ready for 2.7, and if pattern matching isn't stage 2 and also is content with the design constraints that advancing extractors would cause

[10:31:37.0039] <littledan>
> <@ljharb:matrix.org> ok so why is this stage 3 instead of a normative PR? the discussion was hard to follow

I don't think we really discussed that, but is there a problem with considering it Stage 3?

[10:31:44.0110] <littledan>
we can still reconsider

[10:31:54.0761] <ljharb>
just more ceremony than we probably need

[10:31:59.0474] <littledan>
IMO it'd be valid either way

[10:33:24.0511] <ptomato>
+1 would be good to document where the dividing line is. I agree with Jordan in that I would've preferred this to be a needs-consensus PR

[10:33:37.0830] <littledan>
Nicolo's answer seemed good: the stage process let us develop this proposal and build consensus incrementally

[10:34:19.0883] <ljharb>
was this one even a proposal before today?

[10:34:35.0596] <nicolo-ribaudo>
> <@ljharb:matrix.org> was this one even a proposal before today?

Yes, "dynamic code brand checks", stage 1

[10:34:44.0319] <ljharb>
aha, thanks

[10:35:17.0039] <ljharb>
i'm not sure being stage 1 for many years, and suddenly getting revived and jumping straight to stage 3, justifies it being a proposal vs a PR, but it really doesn't matter much :-)

[10:36:03.0082] <nicolo-ribaudo>
To be honest I spent the last two weeks swinging between "stage 3" and "normative PR", but given that we are changing behavior of `eval()` (and dropping the guarantee that all objects are returned as-is), I preferred being more conservative

[10:36:14.0350] <nicolo-ribaudo>
Implementations are in progress, so this will be ready for stage 4 soon

[10:47:41.0255] <Michael Ficarra>
ü§î could you data URI an iframe and then pull the "literal" template out of it?

[10:48:23.0148] <Michael Ficarra>
@bakkot:matrix.org ^

[10:48:33.0297] <bakkot>
no, those are cross-origin

[10:48:50.0809] <Michael Ficarra>
okay good

[10:49:22.0134] <Michael Ficarra>
I can never remember how data URIs and file/loopback URIs can interact with web pages

[10:49:41.0846] <bakkot>
data URIs are opaque (=unique) origins in all contexts I am pretty sure

[10:50:28.0970] <Michael Ficarra>
that's good, and I'm sure I will forget before the next time I need that piece of information

[11:00:18.0692] <bakkot>
I have to drop for a bit but I'm happy with this proposal with either cross-realm or same-realm semantics

[11:09:21.0737] <Michael Ficarra>
is this only useful for bundlers? if so, can't they start using a non-standard directive?

[11:13:08.0262] <littledan>
I kinda share danielrosenwasser 's composability concern

[11:13:29.0518] <hax (HE Shi-Jun)>
nicolo-ribaudo: I believe "adding TLA currently considered to be a semver-major change" should be true...

[11:14:37.0136] <shu>
> <@michaelficarra:matrix.org> is this only useful for bundlers? if so, can't they start using a non-standard directive?

i'd appreciate your putting this on queue

[11:14:58.0354] <ljharb>
adding TLA is always a breaking change.

[11:15:00.0648] <shu>
if other people share daniel r's view that this is a dev-time thing, that seems to segue naturally into tools doing better here

[11:15:04.0043] <ljharb>
 * adding TLA is always a breaking change, with or without this proposal

[11:15:06.0292] <hax (HE Shi-Jun)>
> <@michaelficarra:matrix.org> is this only useful for bundlers? if so, can't they start using a non-standard directive?

It's also useful if someone want to make it clear some code is rely on sync semantic.

[11:15:08.0285] <Michael Ficarra>
feel free to take it from me @shuyuguo:matrix.org

[11:15:30.0193] <Michael Ficarra>
I do feel like it's a dev time thing though

[11:16:34.0467] <keith_miller>
Yeah feels like a dev time issue

[11:16:46.0934] <ljharb>
imo we shouldn't have allowed TLA to be used in a statically imported module in the first place

[11:17:21.0447] <littledan>
Does this proposal have a spec?

[11:17:25.0230] <ljharb>
 * imo we shouldn't have allowed static import of a module using TLA in the first place

[11:17:36.0900] <Michael Ficarra>
I find the "you'll get an error anyway" argument compelling

[11:17:38.0165] <hax (HE Shi-Jun)>
> <@littledan:matrix.org> I kinda share danielrosenwasser 's composability concern

The root cause is TLA is already lose composability ...

[11:19:00.0379] <hax (HE Shi-Jun)>
To be honest, I really feel this proposal is just a patch for TLA footguns...

[11:19:38.0198] <littledan>
re semver: What if we standardized semver in Ecma? Darcy Clarke is interested in this, with a better specification than exists currently (including Node semver ecosystem reality). We could do it in a new TC in TC39, or maybe a TC39 TG. Who's in? Eventually maybe it'd make sense for JavaScript to have a small built-in library for working with semver values, once we have the core defined (this is an extremely popular npm package).

[11:19:46.0914] <littledan>
 * re semver: What if we standardized semver in Ecma? Darcy Clarke is interested in this, with a better specification than exists currently (including Node semver ecosystem reality). We could do it in a new TC in Ecma, or maybe a TC39 TG. Who's in? Eventually maybe it'd make sense for JavaScript to have a small built-in library for working with semver values, once we have the core defined (this is an extremely popular npm package).

[11:20:29.0432] <Ashley Claymore>
I wonder if the service worker API could be updated to not have the late-listener issue

[11:20:49.0568] <nicolo-ribaudo>
> <@littledan:matrix.org> re semver: What if we standardized semver in Ecma? Darcy Clarke is interested in this, with a better specification than exists currently (including Node semver ecosystem reality). We could do it in a new TC in Ecma, or maybe a TC39 TG. Who's in? Eventually maybe it'd make sense for JavaScript to have a small built-in library for working with semver values, once we have the core defined (this is an extremely popular npm package).

I spent enough time in the past month fighting with semver implementations that don't follow the community spec that I'd love to do it

[11:22:28.0855] <hax (HE Shi-Jun)>
> <@ljharb:matrix.org> imo we shouldn't have allowed static import of a module using TLA in the first place

At least not by default (it should only be allowed with <script async type=module> )

[11:25:38.0012] <ryzokuken>
> <@littledan:matrix.org> re semver: What if we standardized semver in Ecma? Darcy Clarke is interested in this, with a better specification than exists currently (including Node semver ecosystem reality). We could do it in a new TC in Ecma, or maybe a TC39 TG. Who's in? Eventually maybe it'd make sense for JavaScript to have a small built-in library for working with semver values, once we have the core defined (this is an extremely popular npm package).

more standardization opportunities are never bad! it'll help ECMA diversify/gain more popularity and it'll allow us to be more involved in semver... win-win!

[11:26:34.0337] <dminor>
Would this be useful in conjunction with deferred imports to catch the switch to eager loading?

[11:26:49.0562] <ljharb>
there's two open PRs on the semver spec that, once landed, would make semver v3 actually match npm - and that's what i'd hope lands in the language

[11:27:07.0187] <ljharb>
(i'm already working with semver folks to try to get one of those landed)

[11:27:34.0822] <ljharb>
 * there's two open PRs on the semver spec that, once landed, would make semver v3 actually match npm (neither v1 nor v2 is what npm does, and what npm does is what matters) - and that's what i'd hope lands in the language

[11:27:42.0158] <nicolo-ribaudo>
> <@dminor:mozilla.org> Would this be useful in conjunction with deferred imports to catch the switch to eager loading?

Maybe we could have it only for deferred imports
```js
import defer * as ns from "x" with { async: "error" }
import defer * as ns from "x" with { async: "eager" }
```

[11:28:52.0084] <nicolo-ribaudo>
> <@dminor:mozilla.org> Would this be useful in conjunction with deferred imports to catch the switch to eager loading?

 * Maybe we could have it only for deferred imports rather than as a general language feature

```js
import defer * as ns from "x" with { async: "error" }
import defer * as ns from "x" with { async: "eager" }
```

[11:29:24.0465] <Ashley Claymore>
Can this be tested like:

```
import "./start-test.js";
import "./app.js";
import { wasThereATick } from "./end-test.js"; // shares state with start-test
assert(!wasThereATick);
```

[11:29:45.0602] <nicolo-ribaudo>
> <@aclaymore:matrix.org> Can this be tested like:
> 
> ```
> import "./start-test.js";
> import "./app.js";
> import { wasThereATick } from "./end-test.js"; // shares state with start-test
> assert(!wasThereATick);
> ```

./end-test.js doesn't wait for ./app.js to be done

[11:29:55.0556] <nicolo-ribaudo>
You would need to inline ./end-test in your module

[11:30:00.0189] <Ashley Claymore>
ah right

[11:30:02.0513] <Ashley Claymore>
wrap them up

[11:30:27.0094] <Ashley Claymore>
so like:

```
// end-test-wrapper.js
import "./app.js";
import { wasThereATick } from "./end-test.js"; // shares state with start-test
```

[11:30:57.0200] <nicolo-ribaudo>
well, again ./end-test.js doesn't wait for ./app.js üòõ

[11:31:50.0813] <littledan>
+100 to Jordan, [Symbol.toStringTag] was just a mistake

[11:31:57.0549] <Ashley Claymore>
how about

```
import { ticked } "./start-test.js";
import "./app.js";
assert(!ticked); // ticked live binding
```

[11:32:05.0220] <Michael Ficarra>
tbf brand checking is icky and I don't like it

[11:32:08.0216] <nicolo-ribaudo>
```js
import { ticksCount } from "./dynamic-ticks-counter";
import "./app.js";
assert(ticksCount === 0)
```

[11:35:03.0199] <Ashley Claymore>
Yeah this seems to work in Node

```
// start-test.js
export let ticked = false;
Promise.resolve().then(() => {
    ticked = true;
});
```

[11:35:35.0446] <Ashley Claymore>
If I add a TLA to "app.js" the assert fails

[11:37:22.0726] <Jack Works>
> <@aclaymore:matrix.org> how about
> 
> ```
> import { ticked } "./start-test.js";
> import "./app.js";
> assert(!ticked); // ticked live binding
> ```

this is like implementing lodash.throttle but you also need to be a ES module specialist 

[11:38:31.0094] <hax (HE Shi-Jun)>
Is `Error.isError(new Proxy(new Error, {}))` returns true?

[11:39:39.0276] <ljharb>
in the 9 year old spec, yes. it's fine if it returns false tho

[11:39:52.0867] <Ashley Claymore>
> <@jackworks:matrix.org> this is like implementing lodash.throttle but you also need to be a ES module specialist

Maybe this could be an npm library?

[11:41:58.0621] <ljharb>
eemeli: yes, and we would regardless of this proposal

[11:44:45.0243] <ljharb>
shu: i checked and the HTML spec already requires doing that, i think?

[11:44:54.0481] <shu>
no it doesn't?

[11:45:03.0430] <ljharb>
https://html.spec.whatwg.org/#structureddeserialize

[11:45:03.0836] <shu>
where do you read that it does

[11:45:17.0838] <ljharb>
 * https://html.spec.whatwg.org/#structureddeserialize, step 21

[11:45:20.0443] <shu>
wait what are you responding to?

[11:45:23.0030] <eemeli>
So if extractors or pattern matching would provide for an `Error[Symbol.customMatcher]` "regardless", does it make sense to advance a separate proposal on this?

[11:45:40.0232] <ljharb>
"be a real subclass" is the same as "has the expected slots and [[Prototype]]"

[11:45:49.0951] <ptomato>
`{ isError() { return true; } }` yup that's a native Error

[11:46:04.0858] <shu>
> <@ljharb:matrix.org> "be a real subclass" is the same as "has the expected slots and [[Prototype]]"

those are not deserializing DOMExceptions

[11:46:09.0118] <ljharb>
> <@eemeli:mozilla.org> So if extractors or pattern matching would provide for an `Error[Symbol.customMatcher]` "regardless", does it make sense to advance a separate proposal on this?

yes, because having a predicate is the more basic component

[11:46:10.0673] <shu>
those are deserializing actual JS errors, not subclassed

[11:46:17.0553] <ljharb>
oh i don't care about domexceptions

[11:46:18.0509] <shu>
 * those steps are deserializing actual JS errors, not subclassed

[11:46:22.0031] <shu>
*i* do

[11:46:40.0808] <Jack Works>
> <@aclaymore:matrix.org> Maybe this could be an npm library?

might be better to PR webpack and rollup

[11:46:44.0338] <littledan>
> <@eemeli:mozilla.org> So if extractors or pattern matching would provide for an `Error[Symbol.customMatcher]` "regardless", does it make sense to advance a separate proposal on this?

yes, that's an excuse we can use to stash the check there -- Jordan has generally been requesting that proposal authors find a way to make such an API (though it has to serve some sort of dual use case today, due to this set of arguments we're having)

[11:46:49.0120] <ljharb>
i mean that i'm 100% fine with domexceptions passing this predicate, or not. what would you prefer?

[11:47:05.0088] <littledan>
> <@littledan:matrix.org> yes, that's an excuse we can use to stash the check there -- Jordan has generally been requesting that proposal authors find a way to make such an API (though it has to serve some sort of dual use case today, due to this set of arguments we're having)

I agree that `[Symbol.customMatcher]` should make this easier

[11:47:27.0290] <shu>
> <@ljharb:matrix.org> i mean that i'm 100% fine with domexceptions passing this predicate, or not. what would you prefer?

those are my topics, i'll discuss it then

[11:47:41.0106] <Jack Works>
> <@shuyuguo:matrix.org> *i* do

_HostIsErrorLike_

[11:48:46.0972] <eemeli>
> <@littledan:matrix.org> yes, that's an excuse we can use to stash the check there -- Jordan has generally been requesting that proposal authors find a way to make such an API (though it has to serve some sort of dual use case today, due to this set of arguments we're having)

Fair point; makes this sound appropriate for Stage 1.

[11:48:56.0823] <shu>
yes, we can do HostIsErrorLike. but look, like, 90% of the time, when i ask a question, i'm not also implicitly asking "how do we do this mechanically". most things are possible to do! i'm asking if it's a good idea

[11:49:50.0278] <Jack Works>
then no, DOMException does not inherit Error and missing some property Error have

[11:50:03.0030] <Michael Ficarra>
@littledan:matrix.org regarding "What policies has TC39 adopted?" do you think we need to cover this during Jordan's limited time?

[11:50:05.0713] <bakkot>
if no code can distinguish between "a real error" and "not a real error", why would you ever need to know the answer to that question when debugging?

[11:50:16.0289] <bakkot>
"I need this for debugging" is confusing to me

[11:50:17.0999] <shu>
i am also confused by this point

[11:50:56.0131] <Jack Works>
> <@jackworks:matrix.org> then no, DOMException does not inherit Error and missing some property Error have

Oh no longer the case. In my memory, in the past, a DOMException has no "stack" (although stack is not standarized) property

[11:52:56.0891] <Jack Works>
then yes, DOMException is a normal sense of "Error". but by that mean, if I made my own Exception, is it a "Error"

[11:54:26.0319] <Jack Works>
but why we should care this... I'll just log/report anything thrown to me, without categorize them

[11:57:18.0622] <littledan>
> <@michaelficarra:matrix.org> @littledan:matrix.org regarding "What policies has TC39 adopted?" do you think we need to cover this during Jordan's limited time?

No, I'm fine to skip it

[11:57:57.0110] <littledan>
but it's kinda funny that we have these dualing policies asserted by Jordan and Mark, and these are not written down and just enforced personally by them... we have to get out of this situation

[11:58:26.0818] <littledan>
 * but it's kinda funny that we have these dualing policies asserted by Jordan and Mark, and these are not written down and just enforced personally by them... we have to get out of this situation by documenting shared policies that we agree on

[11:58:42.0810] <Michael Ficarra>
hopefully after this meeting we will have a place to put them: https://github.com/tc39/how-we-work/pull/136

[11:59:07.0543] <Michael Ficarra>
everybody just say yes to everything Kevin suggests and then we will have a `normative-conventions.md` on Friday

[11:59:09.0807] <hax (HE Shi-Jun)>
yeah, DOMException is strange, domException instanceof Error is true, but they do not have all properties of Error (eg. no stack?)

[11:59:47.0223] <Jack Works>
> <@haxjs:matrix.org> yeah, DOMException is strange, domException instanceof Error is true, but they do not have all properties of Error (eg. no stack?)

it has stack now

[12:00:35.0911] <bakkot>
`(new DOMException).stack // undefined`

[12:02:29.0239] <littledan>
IIRC it differs between browsers whether you get the stack when allocating the exception or when it's thrown

[12:05:05.0634] <eemeli>
I'm getting a stack from that in Firefox and Node.js.

[12:06:28.0690] <rbuckton>
Chakra did not set `.stack` during construction, but during `throw`. Setting `.stack` during construction was a V8 contrivance, I think, that was later adopted by some other implementations.

[12:07:15.0461] <rbuckton>
So `try { throw new DOMException(); } catch (e) { e.stack; }` would still show a stack in Chakra

[12:08:34.0656] <Jack Works>
on firefox

[12:17:34.0615] <bakkot>
yeah looks like this is browser-specific

[12:17:35.0468] <bakkot>
fun!


2024-04-11
[18:04:33.0408] <rkirsling>
woo-ow

[18:04:44.0073] <rkirsling>
that example Waldemar found is pretty epic

[18:04:56.0958] <littledan>
what example?

[18:05:34.0532] <rkirsling>
https://github.com/tc39/proposal-pattern-matching/issues/323, at the end of the link

[18:06:23.0815] <rkirsling>
keywords are terrifying

[18:07:04.0687] <rkirsling>
 * contextual keywords are terrifying

[19:04:49.0901] <Justin Ridgewell>
@rbuckton:matrix.org Have you considered `.` for discard bindings before? It‚Äôs visually insigificant, isn‚Äôt an identifier, and can‚Äôt be used in any place that makes discard bindings useful.

[19:05:17.0723] <Justin Ridgewell>
It might be _too_ visually small.

[19:06:20.0138] <rbuckton>
That, and too easy to confuse for a property access.

[19:19:37.0017] <Justin Ridgewell>
How would you confuse it for propery access?

[19:19:49.0685] <Justin Ridgewell>
There‚Äôs no preceding object

[20:02:24.0783] <rbuckton>
it could theoretically be mixed with `and`, `or`, or `not` in pattern matching, though that's not exactly practical.

[03:24:40.0737] <Jack Works>
for (using is of and [not/a+"/g]; b++; [/"/g, 5])

[03:25:07.0175] <Jack Works>
how Waldemar find this

[03:26:18.0638] <Jack Works>
üò® real insight 

[03:50:12.0222] <Jack Works>
```
for (using is of and [not/a+"/g]; b++; [/"/g, 5])

First parse
for (using x of ...) {}
    keyword using
    Identifier is
    keyword of
    Expression [not/a+"/g]; b++; [/"/g, 5]
        ArrayExpression [
            Element not/a+"/g]; b++; [/"/g
                Division not/a
                Plus +
                Division "/g]; b++; [/"/g
                    Left "/g]; b++; [/"
                    Right g
            Element 5
        ]

Second parse
for (a; b; c)
FirstPart
    PatternMatching
        Identifier using
        Keyword is
        Pattern
            IdentifierPattern of
            Keyword and
            ArrayPatter []
                Keyword not
                RegExpPattern /a+"/g
SecondPart b++
ThirdPart [/"/g, 5]
```

[03:53:03.0875] <rbuckton>
Anything involving regexp literals is suspect

[04:03:18.0119] <Jack Works>
but it's a real ambiguous example 

[04:03:29.0793] <Jack Works>
both interpretations are legal 

[06:09:45.0480] <ryzokuken>
the authors' copy of the soon-to-be RFC 9557 üéâ

https://www.rfc-editor.org/authors/rfc9557.html

[06:29:18.0857] <littledan>
> <@usharma:igalia.com> the authors' copy of the soon-to-be RFC 9557 üéâ
> 
> https://www.rfc-editor.org/authors/rfc9557.html

Wow! The extension if ISO 8601 with custom timezone and calendar syntax has an RFC number!

[06:54:38.0304] <keith_miller>
Does anyone else fill out the sign-in form every day because they didn't save the Webex link?

[06:54:48.0099] <keith_miller>
 * Does anyone else fill out the sign-in form every day because they didn't save the Webex link? lol

[06:58:40.0761] <ryzokuken>
starting real soon folks!

[07:37:31.0612] <Chris de Almeida>
we lost Nicolo as a notes helper.  if someone else here could volunteer to help, even just for this topic, that would really help us out.  chair group is trying to help w/ notes (as we often do), but also have to juggle other things.  thank you üôè

[07:38:07.0926] <Chris de Almeida>
it's easier during the presentation, and a little more work during discussion

[07:46:03.0925] <hax (HE Shi-Jun)>
> <@jackworks:matrix.org> for (using is of and [not/a+"/g]; b++; [/"/g, 5])

It's just like old `for (async of () => {}` issue, maybe worse?

[07:49:30.0439] <littledan>
saminahusain: It'd be great if Ecma could facilitate getting TC39 the relevant ISO/IEEE specs. This is a technical barrier for us in this proposal, as it was in the development of Temporal (with the relationship with ISO 8601)

[07:54:33.0291] <Chris de Almeida>
> <@softwarechris:matrix.org> sent a file.

‚òùÔ∏è

[08:29:10.0719] <waldemar>
What's TLS?

[08:29:26.0626] <rbuckton>
ljharb: no `class extends sharedStruct {}` won't work, for the reasons shu is discussing now, as well as that it has too many rough edges. You can't add new public or private fields in a subclass of a shared struct as it would violate the fixed layout. Plus we can't correlate a class prototype across realms.

[08:29:29.0233] <rbuckton>
thread-local storage

[08:29:37.0348] <rbuckton>
 * TLS: thread-local storage

[08:29:54.0384] <rbuckton>
Though he really means "Realm-local storage"

[08:29:56.0506] <ljharb>
the instance would still be sealed ofc

[08:30:25.0084] <ljharb>
and it has the same problem of correlation, but it seems a better way to correlate to me than a "boxed primitive"-like hand wavy mechanism

[08:30:50.0732] <rbuckton>
> <@ljharb:matrix.org> the instance would still be sealed ofc

The prototype would not be correlated.

[08:31:04.0080] <ljharb>
this also reminds me of yaml class marshalling attack vectors in ruby, for some reason

[08:31:43.0902] <rbuckton>
You are misunderstanding correlation, I think. We're talking about ensuring the same struct type defined in the same file and loaded into two different realms/threads/agents will have same methods.

[08:31:53.0794] <ljharb>
right

[08:32:15.0604] <ljharb>
i'm suggesting that you make a class with methods, and extend the struct, and then the "automatic" part would be reloading that same class code in each place

[08:32:20.0801] <rbuckton>
We can't correlate a class prototype, because classes and class prototypes aren't correlated across threads. We can correlate a struct definition and prototype.

[08:32:37.0185] <ljharb>
the prototype is a mutable object tho

[08:32:48.0795] <ljharb>
if that can be correlated, why can't anything be?

[08:33:11.0304] <rbuckton>
No, correlation is based on syntax and source location. 

[08:33:41.0666] <ljharb>
right but i mean, you have to re-evaluate code in each place in order to get the prototype, right?

[08:33:47.0102] <ljharb>
 * right but i mean, you have to re-evaluate code in each context in order to get the prototype, right?

[08:33:50.0286] <rbuckton>
correlating every `class` is way too much overhead.

[08:33:51.0088] <ljharb>
 * right but i mean, you have to re-evaluate code in each context in order to get the prototype object, right?

[08:34:22.0035] <littledan>
> <@rbuckton:matrix.org> correlating every `class` is way too much overhead.

this is just the shared ones, right?

[08:34:37.0406] <ljharb>
well sure, not every class. only one canonical one that the shared struct creator indicates

[08:34:52.0464] <ljharb>
 * well sure, not every class. only one canonical one that the shared struct creator indicates. that seems like it'd be precisely the same amount of overhead as the prototype object correlation

[08:34:54.0992] <rbuckton>
We would only correlate `shared struct` types between realms

[08:35:07.0839] <ljharb>
the prototype object isn't a shared struct

[08:35:37.0654] <rbuckton>
> <@ljharb:matrix.org> well sure, not every class. only one canonical one that the shared struct creator indicates. that seems like it'd be precisely the same amount of overhead as the prototype object correlation

`class extends sharedStruct` cannot be cannonical and cannot be determined syntactically.

[08:35:42.0940] <rbuckton>
> <@ljharb:matrix.org> well sure, not every class. only one canonical one that the shared struct creator indicates. that seems like it'd be precisely the same amount of overhead as the prototype object correlation

 * `class extends sharedStruct` cannot be canonical and cannot be determined syntactically.

[08:35:43.0889] <ljharb>
if a function is re-eval'd in multiple contexts to achieve the goal of "having the same methods", then surely any code could be

[08:36:02.0100] <rbuckton>
That isn't the problem.

[08:36:03.0915] <ljharb>
there's all sorts of ways that can be covered

[08:36:29.0052] <ljharb>
the wrapper class could be defined inside the shared struct, or you could just define method syntax inside the struct definition and the semantics would be that methods are copied

[08:36:50.0923] <ljharb>
 * the wrapper class could be defined lexically inside the shared struct, or you could just define method syntax inside the struct definition and the semantics would be that methods are copied

[08:36:59.0691] <ljharb>
 * the wrapper class could be defined lexically inside the shared struct, or you could just define method syntax directly inside the struct definition and the semantics would be that methods are copied

[08:37:05.0363] <ljharb>
 * the wrapper class could be defined lexically inside the shared struct, or you could just define method syntax directly inside the shared struct definition and the semantics would be that shared struct methods are copied

[08:37:45.0866] <rbuckton>
Those sound categorically worse than what we are proposing. Class construction has the wrong semantics for shared structs.

[08:38:03.0148] <ljharb>
```

[08:38:26.0829] <rbuckton>
> <@ljharb:matrix.org> the wrapper class could be defined lexically inside the shared struct, or you could just define method syntax directly inside the shared struct definition and the semantics would be that shared struct methods are copied

we are proposing methods defined in the struct.

[08:38:32.0121] <ljharb>
 * why would something like
```
shared struct {
  // existing stuff
  foo() {}
}
```
where the methods are auto-re-eval'd be worse?

[08:38:50.0370] <ljharb>
hm, maybe i misunderstood shu's slides, it looked like he was mutating `.prototype`

[08:39:10.0387] <rbuckton>
He was showing a build up to what we actually want.

[08:46:07.0441] <littledan>
We already reference source location in TemplateMap. This isn't a new solution

[08:46:13.0378] <littledan>
 * We already reference source location in TemplateMap. This isn't a new concept

[08:51:18.0808] <Ashley Claymore>
Maybe tooling could extract out the minimal part of the struct declarations so they can have a more concrete source text location. And then re-write the code so it can reference that.

[08:51:34.0093] <Ashley Claymore>
(for the virtulization case)

[08:52:18.0372] <bakkot>
this is a sidebar but it would be nice if we could structuredClone symbols in a coherent way (i.e., such that if you send the same one over twice, you get the same value)

[08:52:44.0606] <rbuckton>
That's what bundlers would need to do if they have different entrypoints. IIRC, many bundlers can already do source splitting for those cases.

[08:52:54.0666] <littledan>
> <@bakkot:matrix.org> this is a sidebar but it would be nice if we could structuredClone symbols in a coherent way (i.e., such that if you send the same one over twice, you get the same value)

I've been told that this would be too troublesome to implement

[08:53:43.0062] <Ashley Claymore>
> <@bakkot:matrix.org> this is a sidebar but it would be nice if we could structuredClone symbols in a coherent way (i.e., such that if you send the same one over twice, you get the same value)

only RegisteredSymbols would be the easier form of this

[08:53:56.0579] <bakkot>
> <@littledan:matrix.org> I've been told that this would be too troublesome to implement

huh. doesn't seem like it would be that hard.

[08:54:07.0527] <ljharb>
the usefulness for me would be unforgeable transferable symbols

[08:54:12.0280] <ljharb>
 * the usefulness for me would be unforgeable transferable symbols, ie, not registered ones

[08:54:43.0440] <bakkot>
you can do it in userland if you patch postMessage / the message event / structuredClone and stash symbols in a weakmap

[08:56:36.0329] <rbuckton>
littledan: Maybe doesn't matter, but I prefer the term `ConcurrentMap` to `SharedMap`. Just because a map is shareable does not mean it can be used concurrently by multiple threads. A true concurrent map uses lock-free CAS mechanisms to allow for concurrent reads and writes. 

[08:57:24.0290] <Mathieu Hofman>
keith_miller: I have previously advocated for a manual correlation over postMessage, but apparently the DX of that is not acceptable, and prevents some use cases that I don't fully understand

[08:58:06.0274] <Ashley Claymore>
> <@bakkot:matrix.org> you can do it in userland if you patch postMessage / the message event / structuredClone and stash symbols in a weakmap

Like CK, if the sending realm is also trying to put these symbols in a weak{Map/set/ref}, now the local GC only holds them weakly. They might be GC'ed before the round trip comes back

[08:58:39.0269] <bakkot>
CK?

[08:58:46.0427] <ljharb>
put them in a weakref that's strongly held by a Map, and if the weakref is collected, you can just make a new symbol?

[08:58:55.0283] <Ashley Claymore>
CompositeKeys

[08:59:12.0368] <Ashley Claymore>
But then that's not round tripping

[08:59:23.0132] <bakkot>
ah, sure, ok

[08:59:44.0346] <ljharb>
ah true, hm

[09:00:28.0206] <Ashley Claymore>
In Java Valhala, they 'fix' that by letting WeakMaps have a 'soft' policy. Where there is no guarantee that the value will remain in the map, even if it's reachable

[09:00:50.0543] <littledan>
> <@rbuckton:matrix.org> littledan: Maybe doesn't matter, but I prefer the term `ConcurrentMap` to `SharedMap`. Just because a map is shareable does not mean it can be used concurrently by multiple threads. A true concurrent map uses lock-free CAS mechanisms to allow for concurrent reads and writes.

I don't get it; shouldn't we use ConcurrentArray then?

[09:01:39.0422] <rbuckton>
Arrays only usually require a single operation to update. Maps require many more operations that are not thread safe.

[09:02:49.0785] <Mathieu Hofman>
> <@littledan:matrix.org> I've been told that this would be too troublesome to implement

How is it so much more troublesome that sharing an instance of `shared struct SharedSymbol {}` ?

[09:03:31.0796] <Ashley Claymore>
> <@mhofman:matrix.org> How is it so much more troublesome that sharing an instance of `shared struct SharedSymbol {}` ?

SharedStructs are in someways Finite, due to source text location ?

[09:03:36.0053] <Ashley Claymore>
> <@mhofman:matrix.org> How is it so much more troublesome that sharing an instance of `shared struct SharedSymbol {}` ?

 * SharedStructs are in someways finite, due to source text location ?

[09:03:42.0811] <Mathieu Hofman>
> <@bakkot:matrix.org> you can do it in userland if you patch postMessage / the message event / structuredClone and stash symbols in a weakmap

You cannot if you want to make sure you don't leak memory. You need distributed GC for this to work

[09:04:12.0788] <bakkot>
presumably shared structs will in fact be more work than structuredCloning symbols would be, and engines just think it's worth it because it is plainly much more valuable

[09:04:14.0344] <Ashley Claymore>
 * SharedStructs are in someways finite (and eternal), due to source text location ?

[09:05:39.0582] <Mathieu Hofman>
Right, if you do the work for shared structs you basically could share unique symbols almost for free

[09:06:21.0548] <Mathieu Hofman>
> <@aclaymore:matrix.org> SharedStructs are in someways finite (and eternal), due to source text location ?

instances of shared structs are definitely not eternal. they require distributed gc. and fun part, they can be used as WeakMap keys

[09:07:20.0217] <bakkot>
it would certainly be a nice bonus if this feature gave us clonable symbols!

[09:10:22.0124] <hax (HE Shi-Jun)>
Will `import {SharedStruct} from "shared.js" with { foo: "bar" }` have same source location? I guess not?

[09:12:41.0175] <littledan>
> <@mhofman:matrix.org> How is it so much more troublesome that sharing an instance of `shared struct SharedSymbol {}` ?

I guess this was from back when we didn't have a shared heap, and it would've been about correlating signals in different agents (and then the question is, how do you GC them)

[09:32:53.0173] <Richard Gibson>
> <@mhofman:matrix.org> keith_miller: I have previously advocated for a manual correlation over postMessage, but apparently the DX of that is not acceptable, and prevents some use cases that I don't fully understand

I'd _really_ like to see these use cases enumerated, because it seems to me like explicit handshaking in which e.g. a reference to the shared struct is exchanged constitutes a more comprehensible and robust pattern
```
let ready = false;
onmessage = evt => {
  if (!ready) {
    ready = true;
    correlate(localStructDef, evt.data);
    return;
  }

  assert(Object.getPrototypeOf(evt.data) === localStructDef.prototype);
  ‚Ä¶use evt.data as an instance of the shared struct‚Ä¶
}
```

[09:35:12.0094] <keith_miller>
Yeah, I guess I still don't fully understand. It seems like the spawner of a worker could just forward their shared types to that worker. Or alternatively the spawned worker could fetch it lazily, if desired.

[09:35:35.0088] <keith_miller>
 * Yeah, I guess I still don't fully understand. It seems like the spawner of a worker could just forward their shared types to that worker before revealing the existence of that worker to the world. Or alternatively the spawned worker could fetch it lazily, if desired.

[09:35:49.0340] <keith_miller>
 * Yeah, I guess I still don't fully understand. It seems like the spawner of a worker could just forward their shared types to that worker before revealing the existence of that worker to the world. Or alternatively the spawned worker could fetch the shared structs lazily, if desired.

[09:37:21.0762] <littledan>
maybe the answer to this question would be in the V8 CL history, if Shu has already implemented it and found it to be not good enough?

[09:39:22.0488] <keith_miller>
I guess it could be hard to do it lazily because there's no sync postMessage for workers

[09:41:43.0738] <shu>
> <@gibson042:matrix.org> I'd _really_ like to see these use cases enumerated, because it seems to me like explicit handshaking in which e.g. a reference to the shared struct is exchanged constitutes a more comprehensible and robust pattern
> ```
> let ready = false;
> onmessage = evt => {
>   if (!ready) {
>     ready = true;
>     correlate(localStructDef, evt.data);
>     return;
>   }
> 
>   assert(Object.getPrototypeOf(evt.data) === localStructDef.prototype);
>   ‚Ä¶use evt.data as an instance of the shared struct‚Ä¶
> }
> ```

that constitutes a barrier though, right?

[09:42:22.0945] <shu>
like, your workers can't just import and start doing stuff. it has to import, wait till some barrier is reached, then continue doing stuff. it's worse for loading performance

[09:42:35.0972] <shu>
it's definitely _possible_, rbuckton has built such a thing

[09:43:14.0428] <shu>
the "more robust" argument is interesting, i buy the explicitness of it for sure

[09:43:41.0444] <Richard Gibson>
an example of "more robust" is the fact that it isn't broken by na√Øve bundlers

[09:44:00.0284] <shu>
ah okay

[09:44:15.0943] <shu>
that depends on whether that's a goal worth optimizing for

[09:44:50.0191] <bakkot>
There's only a small handful of bundlers in common use, and they're all maintained by specific individuals who you can talk to, so I don't wan to design a feature on the assumption that bundlers will not be writing careful handling

[09:44:56.0460] <bakkot>
 * There's only a small handful of bundlers in common use, and they're all maintained by specific individuals who you can talk to, so I don't want to design a feature on the assumption that bundlers will not be writing careful handling

[09:45:01.0339] <shu>
i was also initially on the other side of comprehendability argument, but flipped after realizing that the "JS classes are distinct per evaluation" thing is pretty JS-specific and folks generally don't have that mental model

[09:45:04.0545] <rbuckton>
> <@shuyuguo:matrix.org> it's definitely _possible_, rbuckton has built such a thing

I did not build such a thing, but I do have a document describing that kind of interaction. There is a lot more user error involved though. I also have hopes to eventually support `#name` private state, but that isn't safe to do so unless I can be certain the struct declarations on both sides are identical. A handshaking mechanism makes that impossible.

[09:45:19.0600] <shu>
i see, i misremembered

[09:45:21.0529] <rbuckton>
> <@shuyuguo:matrix.org> it's definitely _possible_, rbuckton has built such a thing

 * I did not build such a thing, but I do have a document describing that kind of interaction. There is a lot more user error involved though. I also have hopes to eventually support `#name` private state, but it isn't safe to do so unless I can be certain the struct declarations on both sides are identical. A handshaking mechanism makes that impossible.

[09:45:56.0165] <rbuckton>
Private state can only maintain its privacy if you can ensure the same encapsulation exists in both realms.

[09:46:30.0703] <Richard Gibson>
> <@bakkot:matrix.org> There's only a small handful of bundlers in common use, and they're all maintained by specific individuals who you can talk to, so I don't want to design a feature on the assumption that bundlers will not be writing careful handling

I'm not limiting "more robust" to bundlers, just using that as an easily understood example. The same applies to e.g. dynamic code evaluation/version skew/etc.

[09:47:16.0012] <keith_miller>
Do shared structs allow for private state in the current proposal?

[09:47:39.0019] <rbuckton>
No, it is not part of the MVP. They do allow fields, methods, getters, and setters though. 

[09:47:44.0277] <keith_miller>
Is that strictly needed? Or just ergonomic?

[09:47:57.0456] <rbuckton>
I believe it is needed.

[09:48:32.0493] <rbuckton>
You cannot use a `WeakMap` as pseudo-privacy like you might have done for a `class` because a `WeakMap` is local to a specific thread/agent/realm.

[09:48:34.0823] <keith_miller>
Because it seems like you could wrap the private bits in a per-worker wrapper?

[09:48:59.0170] <rbuckton>
How, without exposing the private state as public state?

[09:49:22.0560] <rbuckton>
You have to share something between threads to communicate private state, and if it is not itself private then there is no private state.

[09:49:22.0946] <keith_miller>
I guess you can't have that in transitive members though?

[09:50:49.0044] <keith_miller>
I also don't fully understand how private state interacts with wasm GC

[09:52:10.0401] <rbuckton>
If private state was important for `class`, despite `WeakMap` as a possible solution, then it is _more_ important for `struct` as `WeakMap` is not a possible solution. There are a lot of open questions on private state, which is why it's not part of the MVP, but I don't want to chose a direction that completely rules it out as a possibility.

[09:52:46.0225] <rbuckton>
Are we resuming at 1:00pm or 1:10pm?

[09:53:43.0970] <shu>
i heard 1

[09:54:23.0965] <rbuckton>
Ah, trying to finish eating and wrangling my dogs before we start back up. Thanks

[09:54:37.0998] <ljharb>
you're eating your dogs?

[09:54:44.0747] <rbuckton>
lol.

[09:54:47.0961] <ljharb>
 * you're eating your dogs? (lol sorry, will take it to tdz)

[09:55:33.0597] <Richard Gibson>
> <@rbuckton:matrix.org> I did not build such a thing, but I do have a document describing that kind of interaction. There is a lot more user error involved though. I also have hopes to eventually support `#name` private state, but it isn't safe to do so unless I can be certain the struct declarations on both sides are identical. A handshaking mechanism makes that impossible.

I dispute the "makes that impossible" claim. As a strawperson, consider
```
shared struct SharedPoint {
  ‚Ä¶
  #id
  x;
  y;
}
```
describing a struct with three fields in which instance properties `x` and `y` can be accessed from anywhere but `#id` can be accessed only from functions within the definition (i.e., just like `class`)

[09:55:53.0151] <Richard Gibson>
> <@rbuckton:matrix.org> I did not build such a thing, but I do have a document describing that kind of interaction. There is a lot more user error involved though. I also have hopes to eventually support `#name` private state, but it isn't safe to do so unless I can be certain the struct declarations on both sides are identical. A handshaking mechanism makes that impossible.

 * I dispute the "makes that impossible" claim. As a strawperson, consider

```
shared struct SharedPoint {
  ‚Ä¶
  #id;
  x;
  y;
}
```

describing a struct with three fields in which instance properties `x` and `y` can be accessed from anywhere but `#id` can be accessed only from functions within the definition (i.e., just like `class`)

[09:55:59.0151] <Richard Gibson>
 * I dispute the "makes that impossible" claim. As a strawperson, consider

```
shared struct SharedPoint {
  #id;
  x;
  y;
  ‚Ä¶
}
```

describing a struct with three fields in which instance properties `x` and `y` can be accessed from anywhere but `#id` can be accessed only from functions within the definition (i.e., just like `class`)

[09:56:38.0732] <rbuckton>
Sure. And via handshaking I can replace what with my own `SharedPoint` that has a getter that exposes `#id`.

[09:56:55.0348] <rbuckton>
The correlation must be unforgeable.

[09:56:55.0593] <Richard Gibson>
correct

[09:57:12.0351] <Richard Gibson>
because...?

[09:57:37.0634] <rbuckton>
Otherwise a bad actor could spin up a worker with code that does this, pass it a shared struct instance, and extract the private state.

[09:58:04.0584] <ljharb>
or even observe that it exists.

[09:58:28.0022] <keith_miller>
How are they doing this?

[09:58:49.0090] <Richard Gibson>
it seems like you and I have wildly different threat models and conceptions of the purpose of private fields

[09:58:52.0747] <keith_miller>
Wouldn't they be different types? With different private names?

[09:58:52.0952] <rbuckton>
Sorry, must finish eating and prep for my presentation.

[10:00:28.0710] <Mathieu Hofman>
> <@rbuckton:matrix.org> Private state can only maintain its privacy if you can ensure the same encapsulation exists in both realms.

Not entirely true. If the capability is derived from the shared struct declaration, it is likely fine for that capability to allow wiring private state access. The same way you can declare static methods on a class that can be plucked to give friends the ability to access class privates. 

[10:01:55.0941] <Richard Gibson>
exactly. Access to private fields in the above example would require a reference to the struct _definition_; a mere instance would not suffice

[10:02:45.0670] <littledan>
> <@keith_miller:matrix.org> Wouldn't they be different types? With different private names?

it'd be like, you'd have a different private name in each agent, but they would both be associated to the same underlying field in memory

[10:02:57.0022] <eemeli>
ryzokuken / Chris de Almeida : Will we have time for the extractor continuation?

[10:02:58.0689] <Chris de Almeida>
for anyone who is disappointed that they missed their opportunity to help with the notes during this plenary meeting, there is an opportunity opening up in about 30 minutes after this topic.  please register your interest by contacting the chair group. first come, first served.  thank you üôè

[10:03:35.0962] <Chris de Almeida>
> <@eemeli:mozilla.org> ryzokuken / Chris de Almeida : Will we have time for the extractor continuation?

virtually no chance, unfortunately üòû

[10:03:46.0629] <eemeli>
Alas.

[10:04:42.0126] <Aki>
yikes i'm having a really hard time cognitively keeping up, this is the first time i've tried doing notes since i went on leave for a head injury and maybe it was a touch overambitious of me

[10:05:49.0743] <Chris de Almeida>
> <@akirose:matrix.org> yikes i'm having a really hard time cognitively keeping up, this is the first time i've tried doing notes since i went on leave for a head injury and maybe it was a touch overambitious of me

oh.  hopefully Daniel is able to keep up. chais also help but aren't always able to. if you need to bow out, no worries, don't feel obliged if the vibes are off

[10:06:02.0091] <Chris de Almeida>
> <@akirose:matrix.org> yikes i'm having a really hard time cognitively keeping up, this is the first time i've tried doing notes since i went on leave for a head injury and maybe it was a touch overambitious of me

 * oh.  hopefully Daniel is able to keep up. chairs also help but aren't always able to. if you need to bow out, no worries, don't feel obliged if the vibes are off

[10:10:49.0699] <Michael Ficarra>
the getter and the FinalizationRegistry solutions don't seem so bad...

[10:13:19.0126] <ptomato>
particularly FinalizationRegistry seems pretty suboptimal compared to strict enforcement where you can just throw one exception saying "you forgot `using`" _from the source code location where you forgot it_

[10:13:38.0842] <bakkot>
FinalizationRegistry is very bad

[10:13:43.0369] <bakkot>
it is not a guarantee at all

[10:13:49.0081] <bakkot>
and it is at some point in the future

[10:13:59.0798] <bakkot>
it's really, really not a solution for anything except releasing memory

[10:14:04.0481] <bakkot>
which is the only thing it was ever for

[10:15:29.0114] <Mathieu Hofman>
FR is only ok here as a diagnostic mechanism 

[10:24:46.0452] <Justin Ridgewell>
Is @shuyuguo:matrix.org's concern that you can just manually call `foo[Symbol.enter]()` and so there‚Äôs no real enforcement?

[10:25:00.0282] <shu>
+ it's still not local warning to the user doing something wrong

[10:25:13.0062] <bakkot>
yeah but you don't have the resource if you don't call Symbol.enter, so there's no leak

[10:25:19.0415] <shu>
right okay

[10:25:29.0911] <shu>
i think i understand it now, it's just not [[nodiscard]]

[10:25:32.0402] <shu>
it's something pretty different

[10:25:35.0433] <bakkot>
yeah

[10:26:15.0847] <ljharb>
it really does seem like you have to gate every public operation on "the dispose getter has been called, and the resource is not yet disposed"

[10:26:43.0395] <ljharb>
iow, the entire thing is invalid before being `using`d - queued for disposal - and again invalid after disposal

[10:26:51.0238] <bakkot>
"resource is not yet disposed" is not quite as important; that can be invalid but is not a leak

[10:27:34.0389] <bakkot>
it's still probably good practice but the hit to performance for public fields is not necessarily worth it

[10:27:34.0972] <ljharb>
 * it really does seem like you have to gate every public operation on "the dispose getter has been called, and the resource is not yet disposed" (in order to get the enforcement that motivates this proposal)

[10:27:53.0116] <shu>
can... TS add [[nodiscard]]?

[10:28:06.0638] <ljharb>
not yet disposed? or not yet queued for disposal? because the former is the only time you want people to interact with the resource

[10:28:12.0564] <bakkot>
https://github.com/microsoft/TypeScript/issues/8240

[10:28:16.0246] <ljharb>
 * not yet disposed? or not yet queued for disposal? because the former true, and the latter false, is the only time you want people to interact with the resource, i'd think

[10:28:30.0647] <Ashley Claymore>
The userland solution might be a naming convention

[10:28:40.0258] <Ashley Claymore>
like how in react all hooks are `use[A-Z...`

[10:28:54.0498] <Ashley Claymore>
and linters enforce where they are allowed to be called from

[10:28:56.0622] <ljharb>
oof, that was such a poor choice by react tho

[10:29:05.0458] <bakkot>
unfortunately Ron wants to add it to existing things, which do not follow any naming convention

[10:29:21.0018] <ljharb>
i think they're still planning to name their new mega-hook "use", so RIP googling for things

[10:29:21.0808] <bakkot>
 * unfortunately Ron wants to add Symbol.dispose to existing things, which do not follow any naming convention

[10:29:26.0930] <Ashley Claymore>
> <@bakkot:matrix.org> unfortunately Ron wants to add Symbol.dispose to existing things, which do not follow any naming convention

they'll have to be grandparented in to the set of names ;)

[10:29:52.0272] <bakkot>
inconsistent naming I think makes that naming not viable as a solution for saving people from errors here

[10:30:16.0192] <littledan>
It'd be nice if we can really nail down the full scope of these protocols before Stage 3. It'll make rollout of this solution slower to have this diversity of interpretations for using.

[10:31:39.0409] <littledan>
It's too bad that this proposal doesn't give strong enough guarantees to let us use it for AsyncContext

[10:32:15.0074] <ptomato>
I'm not sure I understand why adding strict enforcement will bifurcate the ecosystem. resource management doesn't exist currently; code wanting to use resource management needs to port, so why would strict enforcement be a burden that hinders adoption?

[10:33:01.0130] <bakkot>
rbuckton: to be clear I am not going to block further advancement of `using` on this feature existing: it is too late in the process

[10:33:13.0120] <rbuckton>
_Mandatory_ strict enforcement could cause bifurcation. That's why this is an opt-in mechanism.

[10:33:20.0643] <Andreu Botella>
> <@littledan:matrix.org> It's too bad that this proposal doesn't give strong enough guarantees to let us use it for AsyncContext

I opened an issue to discuss this: https://github.com/rbuckton/proposal-using-enforcement/issues/1

[10:33:32.0159] <Andreu Botella>
> <@littledan:matrix.org> It's too bad that this proposal doesn't give strong enough guarantees to let us use it for AsyncContext

 * I opened an issue yesterday to discuss this: https://github.com/rbuckton/proposal-using-enforcement/issues/1

[10:33:38.0191] <Mathieu Hofman>
> <@littledan:matrix.org> It's too bad that this proposal doesn't give strong enough guarantees to let us use it for AsyncContext

why is it not sufficient?

[10:33:42.0496] <littledan>
> <@pchimento:igalia.com> I'm not sure I understand why adding strict enforcement will bifurcate the ecosystem. resource management doesn't exist currently; code wanting to use resource management needs to port, so why would strict enforcement be a burden that hinders adoption?

I think it means, if some transpilers/browsers ship the initial `using` semantics, and others ship the later semantics, then it's harder to start shipping APIs using strict enforcement (since it's not enough to check whether the syntax exists, you also have to check that users are updated)

[10:34:06.0421] <littledan>
> <@mhofman:matrix.org> why is it not sufficient?

you can just call enter and not call dispose, so you'd have unbalanced use of the stack

[10:34:11.0484] <ptomato>
> <@littledan:matrix.org> I think it means, if some transpilers/browsers ship the initial `using` semantics, and others ship the later semantics, then it's harder to start shipping APIs using strict enforcement (since it's not enough to check whether the syntax exists, you also have to check that users are updated)

that's the breaks of stage 3 though?

[10:34:34.0497] <littledan>
> <@pchimento:igalia.com> that's the breaks of stage 3 though?

right, the part that makes this painful is that we knew about this part of the design space through the whole life of the `using` proposal.

[10:34:43.0293] <Michael Ficarra>
it is within our power to demote a proposal from stage 3 to 2

[10:35:03.0357] <rbuckton>
> <@littledan:matrix.org> you can just call enter and not call dispose, so you'd have unbalanced use of the stack

Calling enter is an explicit action the user takes. They are opting out of strict enforcement, and thus must ensure they do the work themselves.

[10:35:42.0603] <rbuckton>
I've said elsewhere, I'd be fine with a `Symbol.enter_DO_NOT_USE_OR_YOU_WILL_BE_FIRED`, or something less meme-y, to illustrate the unsafe nature of the operation.

[10:35:57.0368] <Andreu Botella>
> <@rbuckton:matrix.org> Calling enter is an explicit action the user takes. They are opting out of strict enforcement, and thus must ensure they do the work themselves.

We agree that if a user does this, their code is buggy. That's not in discussion. But some use cases need something stricter

[10:36:08.0894] <Andreu Botella>
> <@rbuckton:matrix.org> Calling enter is an explicit action the user takes. They are opting out of strict enforcement, and thus must ensure they do the work themselves.

 * We agree that if a user does this, their code is buggy. I don't think that's in discussion. But some use cases need something stricter

[10:36:10.0350] <keith_miller>
I'm going to guess that implementors are going to reject production work for the equivelent of a [[nodiscard]] attribute. I know I currently would.

[10:36:20.0275] <littledan>
> <@rbuckton:matrix.org> Calling enter is an explicit action the user takes. They are opting out of strict enforcement, and thus must ensure they do the work themselves.

right, so in the rollout, people may find themselves wanting to do that more than would be optimal, to deal with the risk that their code will be transpired with an older version of `using`.

[10:36:20.0968] <keith_miller>
 * I'm going to guess that implementors are going to reject production time work for the equivelent of a \[\[nodiscard\]\] attribute. I know I currently would.

[10:36:39.0525] <rbuckton>
> <@abotella:igalia.com> We agree that if a user does this, their code is buggy. I don't think that's in discussion. But some use cases need something stricter

Without a compiler or type system, I'm not sure something stricter is entirely feasible in JS. 

[10:37:00.0935] <littledan>
> <@rbuckton:matrix.org> Without a compiler or type system, I'm not sure something stricter is entirely feasible in JS.

AsyncContext currently enforces stack discipline strictly by having a callback-based API.

[10:37:11.0512] <littledan>
but there's real demand for having something "flatter"

[10:37:11.0907] <ljharb>
you'd do it with a type-aware linter, like typescript-eslint

[10:37:31.0115] <Michael Ficarra>
unary plus is such a weird thing to have

[10:37:31.0225] <ljharb>
 * you'd do it with a type-aware linter, like typescript-eslint. that's already how people catch unawaited promises with the `no-floating-promises` rule.

[10:37:38.0922] <Michael Ficarra>
what was the intention behind its inclusion?

[10:37:46.0591] <Mathieu Hofman>
> <@littledan:matrix.org> you can just call enter and not call dispose, so you'd have unbalanced use of the stack

sure, but just don't do that? disposables are not only used syntactically. If you call enter, you accept responsibility to call dispose

[10:37:48.0833] <ptomato>
I mean, I'm trying to understand how bad the burden of mandatory enforcement would be? I expect the vast majority of the potential future users of this feature have not ported their code yet (or written it, for that matter)

[10:38:40.0564] <Andreu Botella>
> <@mhofman:matrix.org> sure, but just don't do that? disposables are not only used syntactically. If you call enter, you accept responsibility to call dispose

Do we want to allow that to effectively pollute the caller's scope, switching the current context at their function from under their feet? That's not something I'm confortable with

[10:38:43.0155] <Mathieu Hofman>
> <@abotella:igalia.com> We agree that if a user does this, their code is buggy. I don't think that's in discussion. But some use cases need something stricter

I still do not understand the use case

[10:38:56.0926] <ptomato>
anyway is there a github issue where I can follow this? I'm splitting my attention between this discussion and Kevin's presentation and it's not working very well üòÑ

[10:39:25.0665] <littledan>
Yes, we can follow up in https://github.com/rbuckton/proposal-using-enforcement/issues/1

[10:39:57.0156] <rbuckton>
> <@pchimento:igalia.com> I mean, I'm trying to understand how bad the burden of mandatory enforcement would be? I expect the vast majority of the potential future users of this feature have not ported their code yet (or written it, for that matter)

It depends on the definition of mandatory enforcement. There are two approaches: some magic mechanism that indicates to the resource producer the user is initializing to a `using`, or that `using` and `DisposableStack` explicitly call `[Symbol.enter]` and throw if it doesn't exist.

[10:40:11.0194] <Andreu Botella>
> <@mhofman:matrix.org> sure, but just don't do that? disposables are not only used syntactically. If you call enter, you accept responsibility to call dispose

 * Do we want to allow that to effectively pollute the caller's scope, switching the current context at their function from under their feet? That's something the current AsyncContext proposal explicitly avoids doing

[10:40:53.0834] <Michael Ficarra>
RequireObjectCoercible -> is an Object

[10:41:09.0590] <Mathieu Hofman>
> <@abotella:igalia.com> Do we want to allow that to effectively pollute the caller's scope, switching the current context at their function from under their feet? That's something the current AsyncContext proposal explicitly avoids doing

Ok I think I now understand, and I have ideas on how to do this at the AsyncContext API layer

[10:41:31.0129] <rbuckton>
A magical mechanism doesn't work with `DisposableStack` and wouldn't allow user-defined resource management building blocks.

[10:42:16.0645] <ljharb>
lol, core-js used to make Number.prototype iterable

[10:44:43.0234] <rbuckton>
If `[Symbol.enter]` is mandatory, existing APIs would have to write `[Symbol.enter]() { return this; }`, or would need to duplicate the API to one that produces an object with a `[Symbol.enter]()`. API Bifurcation is a documentation and maintenance headache and would break the ability for tools to introduce simple refactors from `const res = ...; try { ... } finally { res.close(); }` to `using res = ...`

[10:45:52.0718] <Andreu Botella>
are we conflating two separate things? I don't think "true strict enforcement" necessarily means a mandatory `[Symbol.enter]`

[10:46:37.0450] <rbuckton>
For examples of existing APIs that could be adapted to support `[Symbol.dispose]`, see https://github.com/tc39/proposal-explicit-resource-management#relation-to-dom-apis and https://github.com/tc39/proposal-explicit-resource-management?tab=readme-ov-file#relation-to-nodejs-apis

[10:46:50.0262] <rbuckton>
> <@abotella:igalia.com> are we conflating two separate things? I don't think "true strict enforcement" necessarily means a mandatory `[Symbol.enter]`

What would you consider to be "true strict enforcement"?

[10:47:14.0866] <Andreu Botella>
> <@rbuckton:matrix.org> A magical mechanism doesn't work with `DisposableStack` and wouldn't allow user-defined resource management building blocks.

^ this "magical mechanism"

[10:48:04.0742] <rbuckton>
Can you conceive of a magical mechanism that works with both `using` and `DisposableStack` and user-defined resource management wrapper classes?

[10:48:58.0458] <Andreu Botella>
I don't have an alternative, but I think that issue has been conflated with the mandatoryness of `[Symbol.enter]`

[10:49:22.0179] <rbuckton>
for example, if there were a `function.using` meta-property accessible within a function that is only `true` when being initialized to a `using`, how would that work with `DisposableStack.prototype.use`?

[10:50:18.0926] <rbuckton>
I wasn't trying to conflate strict enforcement with mandatory enforcement. They are mostly separate concerns.

[10:50:56.0894] <rbuckton>
I'm bouncing between two different discussions

[10:51:38.0093] <bakkot>
that was much faster than I was expecting!

[10:52:50.0329] <rbuckton>
Mandatory enforcement is a concern for API bifurcation. In general I don't believe mandatory enforcement is necessary, API producers should be able to opt-in or opt-out of enforcement, as should API consumers. 

[10:54:46.0119] <rbuckton>
API producers need an opt-out mechanism for existing APIs or for APIs that don't require such a guarantee. API consumers need an opt-out mechanism so they can compose disposables in their own classes and extend resource management capabilities in userland.

[10:55:00.0130] <Justin Ridgewell>
Agree, mandatory use of `enter` is necessary.

[10:55:16.0404] <Justin Ridgewell>
But for APIs that choose to have an `enter`, some require much stricter requirements.

[10:55:23.0956] <Justin Ridgewell>
(I still need to read https://github.com/rbuckton/proposal-using-enforcement/issues/1)

[10:55:27.0853] <rbuckton>
> <@jridgewell:matrix.org> Agree, mandatory use of `enter` is necessary.

What are you agreeing with?

[10:55:34.0756] <Justin Ridgewell>
But ideally we‚Äôd only allow syntatic `using`.

[10:55:49.0940] <Justin Ridgewell>
> <@rbuckton:matrix.org> Mandatory enforcement is a concern for API bifurcation. In general I don't believe mandatory enforcement is necessary, API producers should be able to opt-in or opt-out of enforcement, as should API consumers. 

I was agreeing with this.

[10:55:56.0411] <rbuckton>
I believe `Symbol.enter` is optional, for those APIs that need it.

[10:56:06.0915] <Mathieu Hofman>
Syntactic super powers make me feel suspicious

[10:56:12.0180] <rbuckton>
We can't only have syntactic using.

[10:56:30.0206] <rbuckton>
You absolutely need composition.

[10:56:57.0169] <Justin Ridgewell>
`AsyncContext` demands knowing whether you‚Äôre using `using` syntatically, using `DisposableStack` (bad), or manually calling (even worse).

[10:57:21.0719] <Mathieu Hofman>
I don't think this use case requires such a capability. I'll write down my idea after plenary

[10:57:51.0147] <rbuckton>
why is `DisposableStack` bad?

[10:58:01.0682] <Justin Ridgewell>
Only syntatic `using` guarantees returning the context stack to the appropriate state.

[10:58:16.0796] <Mathieu Hofman>
Nope there are alternatives

[10:58:19.0486] <Justin Ridgewell>
`DisposableStack` may not be disposed.

[10:58:31.0003] <Justin Ridgewell>
Or it‚Äôs disposed later.

[10:58:38.0183] <Justin Ridgewell>
In which case the caller has been polluted.

[10:58:44.0443] <Mathieu Hofman>
you can do a hybrid by introducing a single new stack entry

[10:58:45.0539] <Justin Ridgewell>
Either way, it doesn‚Äôt work.

[10:59:33.0080] <Andreu Botella>
My point with opening that issue is to point out that there are use cases that need something stricter. I would be fine with the proposal simply not supporting that, and using callbacks.

[10:59:36.0656] <rbuckton>
`DisposableStack`, or any other composition mechanism, is a necessity for building applications that work with resources.

[10:59:54.0050] <Justin Ridgewell>
I‚Äôm not arguing against `DisposableStack` in general.

[11:00:08.0286] <Justin Ridgewell>
But it‚Äôs not acceptable for `AsyncContext`.

[11:01:02.0614] <rbuckton>
I only have a very rough idea of the use case for `AsyncContext` you're concerned about.

[11:01:07.0828] <bakkot>
ljharb: should `Array.zip` zip iterables or arrays or array-likes?

[11:01:12.0649] <rbuckton>
I think I need more context.

[11:01:23.0036] <bakkot>
presumably array-likes?

[11:01:38.0158] <ljharb>
iirc all the array things, except Array.from/fromAsync, take "arraylikes" only (which includes arrays)

[11:01:44.0449] <bakkot>
and of course it will produce an array rather than an iterator

[11:01:54.0699] <ljharb>
right

[11:02:04.0540] <Mathieu Hofman>
The stack frame requirement comes from the use case (AsyncContext). It happens that `using` is a close concept: scope. I will provide an example of API that satisfies the use case without making `using` required

[11:02:14.0366] <ljharb>
i don't *mind* if it takes iteratables, but at that point `Array.zip(iterable)` is just sugar for `Iterator.zip(iterable).toArray()` which isn't that valuable

[11:02:18.0703] <ljharb>
 * i don't _mind_ if it takes iterables, but at that point `Array.zip(iterable)` is just sugar for `Iterator.zip(iterable).toArray()` which isn't that valuable

[11:02:34.0638] <ljharb>
 * i don't _mind_ if it takes iterables, but at that point `Array.zip(...iterables)` is just sugar for `Iterator.zip(...iterables).toArray()` which isn't that valuable

[11:03:00.0142] <Justin Ridgewell>
> <@rbuckton:matrix.org> I think I need more context.

I‚Äôll provide details in the #1 issue later today

[11:03:42.0972] <bakkot>
(it's `.zip(iterables)` not a var-args, to be clear)

[11:04:12.0045] <ljharb>
 * i don't _mind_ if it takes iterables, but at that point `Array.zip(iterables)` is just sugar for `Iterator.zip(iterables).toArray()` which isn't that valuable

[11:05:11.0712] <bakkot>
this seems like it will be a useful place to Stop Coercing Things, so that `{ optionsbag }` isn't treated as an array-like of length 0

[11:09:29.0662] <ljharb>
```
let x
(a) = b;
```

[11:09:52.0672] <ljharb>
 * WH's example:
```
let x
(a) = b;
```

[11:10:13.0660] <bakkot>
`let` strikes again, I hate it

[11:10:20.0753] <ljharb>
an NLTH between the identifier and the `(` seems fine to me

[11:10:28.0518] <ljharb>
 * an NLTH between the identifier and the `(` seems fine to me, just for extractors

[11:10:43.0818] <bakkot>
the line break restriction is also bad, I want to write

```
let Foo
  (long extractor pattern) = RHS
```

[11:10:46.0630] <ljharb>
i don't have empathy for folks who want to write calls like
```
fn
(a, b)
```

[11:10:50.0246] <ljharb>
lol

[11:11:06.0953] <ljharb>
i'd expect there to see
```
let Foo(
  long extractor pattern
) = RHS
```

[11:11:07.0812] <littledan>
extractors are extremely limited in their syntax; this seems way more minor than the other parts

[11:11:19.0281] <littledan>
> <@ljharb:matrix.org> i'd expect there to see
> ```
> let Foo(
>   long extractor pattern
> ) = RHS
> ```

I don't think Waldemar's case runs into that

[11:11:46.0593] <littledan>
I think we're just talking about between `Foo` and `)`

[11:11:50.0926] <ljharb>
true, it's only if the extractor pattern looks like a valid parenthesized LHS?

[11:12:19.0015] <littledan>
(I don't understand the question)

[11:12:58.0527] <bakkot>
man ASI is just the worst

[11:12:59.0447] <ljharb>
like i think waldemar's ambiguity pops up only when the extractor pattern is a valid thing to be in a `(reference) =` usage

[11:13:12.0059] <ljharb>
eg, `(x) = 3` is currently valid, `(x, y) = 3` is not

[11:13:19.0741] <ljharb>
 * eg, `(x) = 3` is currently valid, `(x, y) = 3` is not, so only the former has the conflict

[11:13:34.0078] <ljharb>
and we couldn't even agree to *suggest people avoid it*

[11:13:52.0813] <ljharb>
 * eg, `(x) = 3` is currently valid, `(x, y) = 3` is not, so only the former has the conflict, afaict

[11:14:01.0728] <littledan>
we actually *did* agree to suggest people avoid it! and then took it back

[11:14:26.0202] <ljharb>
fax

[11:14:39.0826] <ljharb>
i guess our decision got a second-pass

[11:14:41.0201] <littledan>
I wish we required you to start your arrow functions with a `^` or something

[11:14:52.0544] <ljharb>
 * eg, `(x) = 3` and `(x.y) = 3` are currently valid, `(x, y) = 3` is not, so only the former have the conflict, afaict

[11:15:00.0392] <littledan>
but now I'm dreaming of other possible uses for prefix ^

[11:15:12.0886] <ljharb>
(parenthesized assignment LHS's are gross also)

[11:16:03.0866] <bakkot>
`(x, y) = 3 technically doesn't but introducing a cover grammar which could distinguish those would be a nightmare

[11:16:07.0868] <bakkot>
 * `(x, y) = 3` technically doesn't but introducing a cover grammar which could distinguish those would be a nightmare

[11:17:31.0667] <ljharb>
but as long as we say that extractors are only an identifier followed by a no-newline `(`, then i think the problem's solved?

[11:17:53.0658] <rbuckton>
As I understand it, Waldemar's concern is this:

```
let a
(b) = {};
```

[11:18:03.0202] <dminor>
Did Extractors advance to Stage 2? I wasn't clear if all blocking concerns were withdrawn.

[11:18:21.0395] <rbuckton>
I don't believe it did, no.

[11:18:25.0798] <littledan>
> <@dminor:mozilla.org> Did Extractors advance to Stage 2? I wasn't clear if all blocking concerns were withdrawn.

Extractors did not advance to Stage 2. The sole blocking concern was the NLT issue.

[11:18:28.0400] <Michael Ficarra>
> <@littledan:matrix.org> I wish we required you to start your arrow functions with a `^` or something

backslash surely

[11:18:33.0052] <dminor>
Ok, thank you.

[11:18:46.0533] <littledan>
> <@michaelficarra:matrix.org> backslash surely

,\

[11:18:47.0236] <rbuckton>
It sounded like the cover grammar complexity might not be blocking, but the NLT issue is still a concern.

[11:19:08.0928] <littledan>
> <@rbuckton:matrix.org> It sounded like the cover grammar complexity might not be blocking, but the NLT issue is still a concern.

the cover grammar complexity will be investigated during stage 2, to resolve before stage 2.7

[11:19:10.0207] <bakkot>
> <@ljharb:matrix.org> but as long as we say that extractors are only an identifier followed by a no-newline `(`, then i think the problem's solved?

yeah, but waldemar didn't like that solution either

[11:19:12.0299] <shu>
> <@rbuckton:matrix.org> It sounded like the cover grammar complexity might not be blocking, but the NLT issue is still a concern.

not blocking for stage 2. i need to do more work to figure out how blocking we consider it for 3

[11:19:13.0250] <bakkot>
(I would be fine with it)

[11:21:52.0310] <Richard Gibson>
> <@ljharb:matrix.org> (parenthesized assignment LHS's are gross also)

`++((‚Ö†))`

[11:22:03.0478] <rbuckton>
We would need an NLT in binding patterns, which seems fine to me. The question is how easy is it to make the NLT conditional on whether we're parsing a `let`/`const`/`var` or not.

[11:26:15.0706] <Michael Ficarra>
the first speaker (currently being referred to as JRA in the notes) is not assigned this abbreviation in https://github.com/tc39/notes/blob/main/delegates.txt

[11:26:29.0901] <Michael Ficarra>
could someone reach out to them to create a PR?

[11:28:09.0534] <shu>
i did already https://github.com/tc39/notes/pull/318

[11:28:11.0816] <waldemar>
I'm having trouble understanding the syntax of the slides

[11:28:44.0487] <Michael Ficarra>
oh okay thanks @shuyuguo:matrix.org

[11:29:01.0832] <waldemar>
What's ({{counter.parity}})?

[11:29:47.0339] <ljharb>
literal parens, with a rendered JS value inside them

[11:29:49.0749] <Michael Ficarra>
@shuyuguo:matrix.org oh, it hasn't been merged because CI is failing due to you not adding them in the correct order

[11:29:50.0521] <rbuckton>
It's vue's templating mechanism.

[11:30:01.0051] <shu>
> <@michaelficarra:matrix.org> @shuyuguo:matrix.org oh, it hasn't been merged because CI is failing due to you not adding them in the correct order

oh

[11:31:09.0045] <shu>
someone more inclined can fix

[11:34:09.0576] <ljharb>
i'm confused, isn't the parity supposed to autoupdate with the counter?

[11:34:14.0834] <littledan>
Preact does recreate the vdom, but at least we didn't bother recalculating parity 

[11:34:29.0409] <ljharb>
but 2 isn't odd

[11:34:32.0522] <littledan>
and Preact may be able to save more work when you have nested components--Preact only has to re-render at the component level

[11:35:10.0690] <littledan>
> <@ljharb:matrix.org> i'm confused, isn't the parity supposed to autoupdate with the counter?

in this case, because it incremented by 2, the parity bit stayed the same, so we didn't have to redo the expensive calculation to change 1/0 into odd/even

[11:35:13.0963] <ljharb>
 * but 2 isn't odd. the parity depends on the counter.

[11:35:17.0589] <rbuckton>
> <@ljharb:matrix.org> but 2 isn't odd

1 + 2 is

[11:35:23.0366] <keith_miller>
ljharb: It's was X+2 so parity shouldn't change

[11:35:25.0697] <ljharb>
ahhh gotcha

[11:35:42.0053] <ljharb>
thanks

[11:35:58.0013] <littledan>
so we memoize things in the data dependency graph so that we have to do minimal work to recompute based on changes

[11:36:12.0766] <keith_miller>
I'm confused is this some mechanism where at closure time we detect the captured variable is a Signal?

[11:36:59.0343] <littledan>
> <@keith_miller:matrix.org> I'm confused is this some mechanism where at closure time we detect the captured variable is a Signal?

there's a hidden global variable that tracks all the signals read within the execution of the computed

[11:37:10.0540] <keith_miller>
I don't understand how we would know that `parity` doesn't need to be updated in general

[11:37:34.0366] <ljharb>
what about signals that aren't unconditionally read?

[11:37:37.0211] <ljharb>
 * what about signals that aren't unconditionally read in the computation?

[11:38:05.0106] <rbuckton>
I expect the execution of `Computed`'s callback could record any `get` for a nested signal

[11:38:33.0600] <rbuckton>
> <@ljharb:matrix.org> what about signals that aren't unconditionally read in the computation?

Their changes don't matter until the condition that made them unread changes?

[11:38:46.0103] <ljharb>
this sounds like why react hooks force you via linter to always unconditionally run all hooks, which is super annoying and unergonomic

[11:38:59.0086] <ljharb>
> <@rbuckton:matrix.org> Their changes don't matter until the condition that made them unread changes?

right but you have to rerun the computation, then, to know if it's updated

[11:39:07.0296] <ljharb>
which means doing the expensive thing

[11:39:33.0670] <keith_miller>
What if the condition isn't tracked by a Signal?

[11:39:43.0175] <keith_miller>
Is that a bug?

[11:39:43.0226] <shu>
> <@keith_miller:matrix.org> I don't understand how we would know that `parity` doesn't need to be updated in general

my understanding from reading the readme was that the dependencies are dynamically re-computed per computation (per "pull")

[11:39:43.0868] <rbuckton>
No, you either record what signals were used and query whether they've changed, or when they change they notify any computations that depend on them.

[11:39:55.0903] <shu>
oh dan is saying that right now

[11:40:14.0146] <bakkot>
if your signal depends on values which can change which are not themselves signals, it's not going to be able to correctly track updates

[11:40:23.0618] <bakkot>
but i mean... don't do that

[11:40:23.0635] <ljharb>
ok so it doesn't prevent an expensive computation, it prevents *dependent* ones?

[11:40:41.0165] <ljharb>
 * ok so it doesn't prevent an expensive computation, it prevents _dependent_ expensive ones?

[11:41:19.0916] <Duncan MacGregor>
I'm trying to think how this would work if multiple realms are involved‚Ä¶ Do they all need to share the hidden global?

[11:42:12.0521] <ljharb>
i'd assume it's realm-specific, since we probably wouldn't want another cross-realm registry

[11:44:01.0558] <Ashley Claymore>
I thought we didn't want per-realm state :D

[11:44:40.0393] <Mathieu Hofman>
Observable global mutable state is definitely a concern we want to discuss with the champions.

[11:45:48.0080] <Mathieu Hofman>
it's fine to have internal global state, but it's not to make it observable to user code. It's a fine line that AsyncContext took a lot of pain to prove and satisfy

[11:46:28.0989] <ljharb>
i mean, this would effectively just be closed-over variables

[11:46:36.0009] <ljharb>
it's not an object you can mutate

[11:46:58.0651] <Mathieu Hofman>
I'm not sufficiently familiar with signals usages, but I'm wondering if there would be ways to implement this auto tracking without making this internal contextual state observable

[11:50:08.0368] <Duncan MacGregor>
> <@mhofman:matrix.org> I'm not sufficiently familiar with signals usages, but I'm wondering if there would be ways to implement this auto tracking without making this internal contextual state observable

Yeah. It feels like the graph should have GC roots somewhere and shouldn't really need a separate global variable‚Ä¶ but I think I'd need some time and paper to work that out.

[11:50:18.0326] <rbuckton>
Seems like this could be done with weakly held pub/sub events rather than a global variable.

[11:51:06.0748] <Anthony Bullard>
> <@rbuckton:matrix.org> Seems like this could be done with weakly held pub/sub events rather than a global variable.

This is, if memory serves, closer to userland implementations I‚Äôve seen

[11:51:07.0638] <Ashley Claymore>
the benefit is that the code doesn't need to know that it's being tracked

[11:51:22.0902] <Ashley Claymore>
everything adding event observers manually is a lot of work

[11:51:46.0646] <Ashley Claymore>
with signals, I can call functions and they don't need to know that the things they call to get data are getters that add to the tracking

[11:52:31.0849] <bakkot>
like `Promise`s

[11:52:32.0906] <Ashley Claymore>
In FunctionalReactiveProgramming their are events and cells.
Signals are much more like cells, than events

[11:52:36.0722] <bakkot>
the data does not need to know you're looking at it

[11:52:41.0945] <Mathieu Hofman>
I understand the motivation, but this is effectively dynamic scoping, and I'm trying to understand if we can put it back within the limits of fluid scoping that AsyncContext offers

[11:54:00.0748] <Ashley Claymore>
 * In FunctionalReactiveProgramming there are events and cells.
Signals are much more like cells, than events

[11:56:46.0738] <Anthony Bullard>
There needs to be a tracking context/scope, and a way to access the underlying value without tracking.

[11:56:49.0389] <Michael Ficarra>
this sounds like perfect incubation call material

[11:57:14.0268] <keith_miller>
Could there be a registry for each signal that's not an hidden global value? Not sure if that would be possible or cause other problems?

[11:57:36.0475] <bakkot>
> <@michaelficarra:matrix.org> this sounds like perfect incubation call material

they already have other discussions going

[11:57:41.0968] <bakkot>
I don't think an incubation call would help

[11:57:46.0261] <shu>
signals sounds like it has _way_ bigger scope than incubation calls

[11:57:46.0530] <keith_miller>
 * Could there be a registry for each batch of signals that's not an hidden global value? Not sure if that would be possible or cause other problems?

[11:57:54.0937] <ljharb>
if you create the computed by providing all the signals it cares about explicitly, then you wouldn't need any global state, i think?

[11:57:55.0833] <shu>
incubation calls are time set-aside for one-off smaller things that don't have regular side discussions

[11:57:57.0404] <Justin Ridgewell>
This is large enough they need a dedicated group call

[11:58:02.0271] <Duncan MacGregor>
> <@keith_miller:matrix.org> Could there be a registry for each batch of signals that's not an hidden global value? Not sure if that would be possible or cause other problems?

Couldn't that be on the signal itself?

[11:58:06.0646] <ljharb>
like `Signal.Computed(fn, signals)`

[11:58:18.0966] <Michael Ficarra>
> <@jridgewell:matrix.org> This is large enough they need a dedicated group call

sure, even better!

[11:58:22.0179] <shu>
that would be static dependencies, not dynamic

[11:58:28.0602] <shu>
that's a pretty big reduction in expressivity

[11:58:36.0320] <shu>
(not arguing for one way or another, but it's pretty different)

[11:58:38.0556] <bakkot>
yeah that API would not be worth having

[11:58:39.0352] <Michael Ficarra>
then I think we should just go for stage 1 and provide all of this feedback in such a call

[11:59:09.0132] <ljharb>
right, i agree

[11:59:19.0837] <ljharb>
 * right, i agree with that too

[11:59:20.0391] <danielrosenwasser>
Yes, these topics seem fair to discuss after stage 1.

[11:59:38.0408] <Anthony Bullard>
> <@ljharb:matrix.org> if you create the computed by providing all the signals it cares about explicitly, then you wouldn't need any global state, i think?

This ruins a good amount of the ergonomics of this feature

[11:59:39.0413] <Duncan MacGregor>
Where did the term `Signal` itself come from? It feels like these are Signallers rather than Signals.

[11:59:49.0659] <ljharb>
> <@anthonybullard:matrix.org> This ruins a good amount of the ergonomics of this feature

it certainly does

[11:59:55.0526] <Justin Ridgewell>
I‚Äôm confused by the global state discussion, there shouldn‚Äôt be any.

[12:00:10.0694] <Justin Ridgewell>
It‚Äôs all on the Signal

[12:00:19.0309] <rbuckton>
While I don't consider it a blocking concern, my concern seemed wide reaching enough that it might be a concern for others who had not previously considered the implications.

[12:00:25.0186] <rbuckton>
 * While I don't consider it a Stage 1 blocking concern, my concern seemed wide reaching enough that it might be a concern for others who had not previously considered the implications.

[12:00:26.0841] <ljharb>
but if the ergonomics are only achievable with weird unenforceable caveats like "you must evaluate all signals unconditionally, in the callback", i'm not sure it's worth striving for them (i dont think that's the case, to be clear)

[12:00:36.0326] <ljharb>
 * but if the ergonomics are only achievable with weird unenforceable caveats like "you must evaluate all signals unconditionally, in the callback" - like react has for hooks, i'm not sure it's worth striving for them (i dont think that's the case, to be clear)

[12:00:55.0555] <Mathieu Hofman>
> <@jridgewell:matrix.org> It‚Äôs all on the Signal

From what I understand it's used for auto-tracking and preventing notify footguns

[12:01:00.0841] <Justin Ridgewell>
> <@ljharb:matrix.org> but if the ergonomics are only achievable with weird unenforceable caveats like "you must evaluate all signals unconditionally, in the callback" - like react has for hooks, i'm not sure it's worth striving for them (i dont think that's the case, to be clear)

You don‚Äôt need to

[12:01:12.0619] <Anthony Bullard>
> <@jridgewell:matrix.org> I‚Äôm confused by the global state discussion, there shouldn‚Äôt be any.

Usually there is a tracking context that coordinates updates of a set of signals

[12:01:20.0880] <bakkot>
> <@ljharb:matrix.org> but if the ergonomics are only achievable with weird unenforceable caveats like "you must evaluate all signals unconditionally, in the callback" - like react has for hooks, i'm not sure it's worth striving for them (i dont think that's the case, to be clear)

you don't have to evaluate all signals unconditionally

[12:01:23.0784] <Justin Ridgewell>
> <@mhofman:matrix.org> From what I understand it's used for auto-tracking and preventing notify footguns

But the state is stored on the Signal itself

[12:01:37.0727] <ljharb>
i'd love to hear how a computed callback of `one.get() ? two.get() : three.get()` can deterministically track all three signals

[12:01:51.0083] <Ashley Claymore>
As Dan said, it's the last read that is tracked

[12:01:56.0527] <rbuckton>
> <@ljharb:matrix.org> i'd love to hear how a computed callback of `one.get() ? two.get() : three.get()` can deterministically track all three signals

Why would it need to?

[12:01:58.0895] <Ashley Claymore>
the last set of reads

[12:02:02.0921] <Anthony Bullard>
> <@ljharb:matrix.org> i'd love to hear how a computed callback of `one.get() ? two.get() : three.get()` can deterministically track all three signals

One of those would not be tracked until called

[12:02:05.0287] <Justin Ridgewell>
> <@ljharb:matrix.org> i'd love to hear how a computed callback of `one.get() ? two.get() : three.get()` can deterministically track all three signals

You only need to track 2 of the 3, the third is irrelevant.

[12:02:11.0097] <rbuckton>
It only needs to track `one.get()` and whichever branch was evaluated.

[12:02:19.0835] <ljharb>
hm

[12:02:21.0933] <rbuckton>
if `three.get()` changes it doesn't affect the computation.

[12:02:34.0599] <rbuckton>
If `one.get()` changes, it evaluates the other branch.

[12:02:49.0023] <Mathieu Hofman>
> <@jridgewell:matrix.org> But the state is stored on the Signal itself

but it's ambient during signal computation, which is currently exposed to any user code running during that time

[12:02:50.0382] <ljharb>
ok, so the list of tracked signals potentially shifts over time?

[12:02:56.0452] <bakkot>
correct

[12:03:02.0066] <bakkot>
each time it's re-evaluated

[12:03:02.0351] <Anthony Bullard>
ljharb: yes

[12:03:02.0644] <rbuckton>
> <@ljharb:matrix.org> ok, so the list of tracked signals potentially shifts over time?

It would have to

[12:03:21.0558] <Anthony Bullard>
Which is why there is usually a hierarchy of tracking contexts

[12:03:43.0971] <Anthony Bullard>
That do the actually coordination and scheduling

[12:03:47.0735] <Ashley Claymore>
> <@ljharb:matrix.org> ok, so the list of tracked signals potentially shifts over time?

exactly

```
if (false) {
  readSignal();
}
```

tracks nothing

[12:03:49.0555] <Justin Ridgewell>
> <@mhofman:matrix.org> but it's ambient during signal computation, which is currently exposed to any user code running during that time

It‚Äôs the same as an `AsyncContxt.Variable.run()` internally in a `computed()` call

[12:03:54.0695] <Chris de Almeida>
it appears we lost the transcriptionist

[12:04:00.0406] <rbuckton>
My concern is how a `Computed` interacts with a weakly held `Signal`. Does it then strongly hold the `Signal`? that seems leaky.

[12:04:20.0115] <Mathieu Hofman>
> <@jridgewell:matrix.org> It‚Äôs the same as an `AsyncContxt.Variable.run()` internally in a `computed()` call

Not quite, there are APIs that effectively expose the `acVar.get()` value

[12:04:29.0102] <bakkot>
wouldn't the `Computed` strongly hold the signal in its closure?

[12:04:46.0515] <rbuckton>
> <@bakkot:matrix.org> wouldn't the `Computed` strongly hold the signal in its closure?

Not if it's closure is `() => weakRef.get()?.get()`

[12:04:52.0874] <Anthony Bullard>
> <@rbuckton:matrix.org> My concern is how a `Computed` interacts with a weakly held `Signal`. Does it then strongly hold the `Signal`? that seems leaky.

Isn‚Äôt putting a weakly held anything in a closure potentially leaky?

[12:05:05.0231] <bakkot>
oh, yeah, I would hope that this case wouldn't leak

[12:05:13.0595] <rbuckton>
Not if you're holding the weakRef.

[12:05:31.0660] <Justin Ridgewell>
> <@mhofman:matrix.org> Not quite, there are APIs that effectively expose the `acVar.get()` value

Internally the `Signal` can access the ambient Computed context‚Äôs var, but that‚Äôs not exposed?

[12:05:48.0090] <bakkot>
though, a `weakRef` is kind of a scary thing to use in a signal - it's a thing whose state can change which is not being read by a Signal

[12:05:50.0477] <Justin Ridgewell>
That‚Äôs still not global state any more than `AsyncContext` is.

[12:06:05.0265] <bakkot>
 * though, a `weakRef` is kind of a scary thing to use in a signal - it's a thing whose state can change which is not being read via a Signal

[12:06:15.0203] <Xuan Huang (ÈªÑÁéÑ)>
> <@ljharb:matrix.org> ok, so the list of tracked signals potentially shifts over time?

Yes, the dependency graph collected and re-formed by Signals is dynamic, as opposed to the number and indexes of Hooks, which are fixed in React. Therefore you don't need it to be unconditional and don't need a lint rule

[12:06:40.0352] <rbuckton>
> <@bakkot:matrix.org> though, a `weakRef` is kind of a scary thing to use in a signal - it's a thing whose state can change which is not being read via a Signal

Sure, but its code someone could conceivably write. I'd just like to know what the behavior is. 

[12:06:42.0632] <Mathieu Hofman>
> <@jridgewell:matrix.org> Internally the `Signal` can access the ambient Computed context‚Äôs var, but that‚Äôs not exposed?

See things like `currentComputed()` and notify guards

[12:07:25.0119] <trueadm>
In various signal implementations, there's the notion of a computed signal being "connected" to the graph. In other words, they are actively being watched by a an effect (via a Watcher) when you `get()` the comptued. If a signal reads a state signal, the state signal strongly holds a relationship with the computed signal. However, if the comptued is read outside an effect, then no strong connection is made, and instead we use a form of counter/version instead.

[12:07:27.0605] <Ashley Claymore>
> <@softwarechris:matrix.org> it appears we lost the transcriptionist

I'm guessing we only paid for up to the hour :)

[12:07:51.0412] <Chris de Almeida>
üôÇ  they bill us after the fact

[12:07:55.0608] <Duncan MacGregor>
So what can a Signal hold? How do we stop people putting something whose values can change unexpectedly?

[12:07:56.0936] <Justin Ridgewell>
> <@mhofman:matrix.org> See things like `currentComputed()` and notify guards

Oh, `subtle` exposes it.

[12:08:12.0364] <Ashley Claymore>
There is `Signal.subtle.currentComputed`

[12:08:16.0585] <trueadm>
The computed will always have a strong connection to the state signals and other comptueds it depends on, but they might not have a relationship back to it.

[12:08:28.0006] <Ashley Claymore>
It's like an async context that everyone has a reference to

[12:08:33.0446] <shu>
> <@aardvark179:matrix.org> So what can a Signal hold? How do we stop people putting something whose values can change unexpectedly?

what does that mean? the developer has to update a Signal.State afaict

[12:08:41.0497] <trueadm>
> <@aardvark179:matrix.org> So what can a Signal hold? How do we stop people putting something whose values can change unexpectedly?

I state signal holds a value. a computed also holds a value and is memoized.

[12:08:51.0583] <rbuckton>
I have a very mild concern over the name `Signal`. It could be conflated with `AbortSignal`. Many years ago it was indicated that WHATWG planned to eventually make more things called `Signal` that likely weren't this.

[12:10:37.0740] <Duncan MacGregor>
> <@rbuckton:matrix.org> I have a very mild concern over the name `Signal`. It could be conflated with `AbortSignal`. Many years ago it was indicated that WHATWG planned to eventually make more things called `Signal` that likely weren't this.

I have many concerns with the name Signal, all of them mild but I think it overlaps existing terms that mean different things and doesn't quite express the concept they seem to be aiming for.

[12:10:41.0857] <Anthony Bullard>
> <@rbuckton:matrix.org> I have a very mild concern over the name `Signal`. It could be conflated with `AbortSignal`. Many years ago it was indicated that WHATWG planned to eventually make more things called `Signal` that likely weren't this.

Yeah, but it is an omnipresent term in userland today, and always meaning something similar to this. A different term would be more confusing I think

[12:10:47.0090] <Yehuda Katz>
HI!

[12:11:15.0254] <Anthony Bullard>
Though this usage is only within the past few years

[12:12:24.0042] <Yehuda Katz>
This is valid. That said, `Signal` has a ton of momentum in the ecosystem right now to describe this effort, in part because the standardization effort was spurred by multiple shipped features called "Signal." I have been happy to go with the name :)

[12:12:30.0575] <bakkot>
> <@softwarechris:matrix.org> it appears we lost the transcriptionist

whisper transcript (linked on reflector) is still going

[12:12:37.0852] <rbuckton>
I find it interesting that signals are gaining so much popularity right now, given that knockout existed 

[12:12:50.0809] <trueadm>
Arguably, signals existed all the way back from Knockout.js and various other libraries, but the popularity of of the name "signal" has been in the last few years.

[12:12:51.0128] <Chris de Almeida>
> <@bakkot:matrix.org> whisper transcript (linked on reflector) is still going

saved again by the kevbot!

[12:12:59.0963] <ryzokuken>
bakkotbot*

[12:13:01.0211] <Yehuda Katz>
Starbeam calls the primitives `Cell` and `Formula` as an Excel pun, which I like but I'm not that attached to these details :)

[12:13:03.0138] <Anthony Bullard>
> <@rbuckton:matrix.org> I find it interesting that signals are gaining so much popularity right now, given that knockout existed 

Ryan Carniato was a knockout dev. Sometimes things come back around

[12:13:39.0435] <Yehuda Katz>
Convergence around pull-based signals is a pretty important detail imo.

[12:13:42.0084] <rbuckton>
In .NET there is a somewhat similar mechanism called dependency properties.

[12:13:59.0320] <rbuckton>
Though its tied to a property declaration, not an independent value.

[12:14:01.0760] <Yehuda Katz>
It's what makes them so abstractable and allows for the separation we were talking about. 

[12:14:47.0004] <rbuckton>
(not suggesting that as a name, "dependency" has an overloaded meaning in JS already)

[12:15:15.0394] <danielrosenwasser>
> <@bakkot:matrix.org> whisper transcript (linked on reflector) is still going

let me know next time!

[12:15:21.0348] <Yehuda Katz>
Ultimately, for convergence/interop, it's pretty important that the shared primitive can support both arbitrarily interesting reactive objects built on the primitives *and* integrate deeply with the framework. 

[12:15:40.0248] <danielrosenwasser>
:D

[12:16:04.0962] <Yehuda Katz>
If either of those are missing, there's no real motivation to collaborate on a standard rather than build something well tuned for your framework's rendering needs

[12:16:28.0030] <ljharb>
also "abortsignal" isn't a great name anyways. the DOM _shouldn't_ build more "signal" things like it

[12:17:24.0001] <Yehuda Katz>
I am willing to go with this narrative, but I personally don't believe in the strong version that implies a lost decade simply because people couldn't see what was in front of their faces ;)

[12:17:50.0122] <Yehuda Katz>
üëçÔ∏è

[12:18:25.0206] <Duncan MacGregor>
> <@rbuckton:matrix.org> (not suggesting that as a name, "dependency" has an overloaded meaning in JS already)

PropagatedValue and PropagatingCalculation?

[12:18:37.0884] <littledan>
Yeah we've definitely been making incremental progress the whole time

[12:18:59.0054] <ljharb>
"propagate" is too easy to misspell

[12:20:11.0461] <Yehuda Katz>
The signals proposal does something in between. There's always a counter that can be used for invalidation, and you can form a strong connection from state->effect (via a watcher). The invalidation itself works the same in both cases though (e.g. the cache is invalidated not via a watcher but via the counter)

[12:21:44.0068] <Yehuda Katz>
I think I had this in my slides: the watcher is narrowly focused on notifying something that is going to flush the signal out into the real world. But then the actual flushing is a regular pull that works in the the way you described the "no strong connection" scenario.

[12:23:38.0116] <rbuckton>
> <@aardvark179:matrix.org> PropagatedValue and PropagatingCalculation?

That's decidedly worse.

[12:24:16.0036] <ptomato>
> <@anthonybullard:matrix.org> Yeah, but it is an omnipresent term in userland today, and always meaning something similar to this. A different term would be more confusing I think

a counterexample is the GNOME platform, where "Signal" means pub-sub, and "property notify" is used for this

[12:24:24.0710] <rbuckton>
Maybe something using `Cell`? i.e., `ValueCell`, `DataCell`, etc.

[12:25:17.0141] <Yehuda Katz>
I have a weak aesthetic dislike for Signal for a similar reason as these rub me the wrong way: the mental model (and design) is really focused on pull-based patterns (i.e. normal JS access patterns). Propagating implies that there's a strong, semantically meaningful arrow from the state through intermediate computeds that lands on effects, and that that's how you think about invalidation.

[12:25:19.0139] <shu>
`CellLikeTheOneInExcel`

[12:26:57.0644] <Yehuda Katz>
What systems that use signals are aiming for is to make the whole end-to-end feel like a one-shot function that somehow is up to date, and one reason signals end up working so well across many different paradigms (and evolved independently) is that the pull-based model facilitates that design. 

[12:27:12.0731] <rbuckton>
If we had a native event mechanism, would we need `Watcher`?

[12:27:17.0427] <Yehuda Katz>
Starbeam is `Cell` and `Formula` for this reason ü§∑

[12:28:01.0214] <Yehuda Katz>
I just want to respect the ecosystem and my fellow framework collaborators and not turn the conversation into a rathole on this. And frankly I would be ecstatic to get framework interop with a name I don't love.

[12:30:33.0653] <Yehuda Katz>
`Watcher` is very careful to facilitate lossy consumption patterns (i.e. the notification itself is fairly simple, you're not allowed to read from the reactive value inside of it, and you can trivially and efficiently coalesce notifications into a consumer-specified scheduling mechanism)

[12:30:44.0094] <littledan>
> <@rbuckton:matrix.org> If we had a native event mechanism, would we need `Watcher`?

I don't understand the question; what would a native event mechanism solve to simplify Watcher?

[12:30:53.0070] <Yehuda Katz>
The scheduling mechanism can include things like "validation happens from the top-down in tree order"

[12:31:38.0984] <Yehuda Katz>
rbuckton: events and observables are really awesome for lossless streams of data, and have affordances and efficiency tradeoffs that are tuned for that.

[12:31:40.0405] <rbuckton>
For example, I'd sketched out an idea awhile back about using a symbol-protocol for pub/sub events that could sit on top of `EventTarget`/`EventEmitter`/etc., and just add a very lightweight event primitive to JS. 

then you do something like `cell::onchanged += () => {}` to watch for changes on a single cell.

[12:31:59.0604] <Yehuda Katz>
`stopImmediatePropagation` ü§¶

[12:32:02.0659] <Yehuda Katz>
Did I get it right?

[12:33:34.0831] <Yehuda Katz>
I feel like I'm brushing you off a little too much here. I'd love to sync up and give enough time to hear you out. You've thought about this a lot and I would love to mind-meld :)

[12:33:41.0352] <rbuckton>
If the event mechanism is hookable (which it would have to be to work with `EventTarget`/`EventEmitter`), then you can be flexible in the underlying event notifaction mechanism.

[12:33:52.0877] <trueadm>
I think the important part of Watcher, vs events, is that is that signals are designed to be lossy. If you were to write to a signal multiple times, we'd only really care that the signal is dirty and when we get around to scheduling an update from the watcher we get the latest value. The intermediate signal state values wouldn't be important as we only "pull" the latest value when we're interested in it, vs being notified everytime a signal changes.

[12:34:59.0669] <rbuckton>
> <@trueadm:matrix.org> I think the important part of Watcher, vs events, is that is that signals are designed to be lossy. If you were to write to a signal multiple times, we'd only really care that the signal is dirty and when we get around to scheduling an update from the watcher we get the latest value. The intermediate signal state values wouldn't be important as we only "pull" the latest value when we're interested in it, vs being notified everytime a signal changes.

That's perfectly fine. Events don't have to be lossless.

[12:35:39.0445] <Yehuda Katz>
I can definitely imagine a foundation for events that allows things like the watcher API to fit neatly into it.

[12:36:31.0814] <Yehuda Katz>
This use-case a good thing to keep in mind if people are going to try to nail down an events foundation

[12:38:19.0721] <rbuckton>
My main concern is adding Yet Another Subscription Mechanism to JS. I'll admit, I've done my fair share. `DisposableStack` can take callbacks and notify them, but that capability is a one shot notification and is primarily designed as an adapter for legacy code. 

[12:38:22.0986] <Mathieu Hofman>
(I really wish Matrix had better threading support)28375256508519

[12:38:30.0567] <Mathieu Hofman>
 * (I really wish Matrix had better threading support)

[12:38:42.0638] <rbuckton>
Same...

[12:39:13.0149] <Yehuda Katz>
rbuckton: that's a good framing for your feelings. It will help me remember your concern as we iterate the design :)

[12:40:11.0109] <Mathieu Hofman>
bakkot: is the log bot down?

[12:40:46.0894] <littledan>
But why can‚Äôt the unifying mechanism be ‚Äúcallbacks‚Äù?

[12:41:27.0118] <rbuckton>
Regardless as to its internal implementation, `Watcher` is yet another in a long line of pub/sub mechanisms. One would be enough, two is pushing it, but we already have 5+ and some are for *very* niche events. I'd like us to stop that trend if possible.

[12:42:36.0754] <littledan>
I mean, that underlies all these other ones

[12:42:47.0486] <rbuckton>
That's not a unified mechanism. If you ask any JS developer if JS has events, I expect they'd say yes. Except, it doesn't. DOM has events, NodeJS has events, JS itself does not.

[12:43:29.0306] <littledan>
One thing to understand about the watcher mechanism is that it‚Äôs use should really be buried within the implementation of effects or rendering

[12:43:59.0742] <trueadm>
In an earlier design, we had the notion that you could pass a computed a callback function that would trigger when it was made dirty. The downside was that you had to pass this upon construction of the computed, which meant interoperability was impaired. However, it could be modelled differently. Is that better than having a watcher?

[12:45:31.0445] <littledan>
* One thing to understand about the watcher mechanism is that its use should really be buried within the implementation of effects or rendering, not for direct use by JS devs

[12:46:05.0759] <rbuckton>
Maybe I didn't represent my position correctly when I asked if `Watcher` is needed. I agree it is needed, even with a native event mechanism, even if only as the event coordinator. I'm trying to ascertain which parts of `Watcher` are unique to `Watcher` as opposed to a generalized pub/sub mechanism.

[12:46:33.0661] <Yehuda Katz>
rbuckton: I mostly defer to Dan and other deep in the implementation constraint space on the fine details. What I primarily care about is not turning it into yet another pipe for data to flow through

[12:46:49.0938] <Yehuda Katz>
so I guess we're both worried about the same thing, it turns out? :)

[12:47:19.0751] <Yehuda Katz>
trueadm: doesn't that fly in the face of decoupling and abstraction goals?

[12:47:39.0504] <Yehuda Katz>
I guess not, since you're always making a computed at the edge

[12:47:46.0638] <rbuckton>
Using .NET as an example (as I am oft to do), events aren't only defined using `Delegate` or `MulticastDelegate`, they are hookable. WPF has RoutedEvents which act similar to DOM events and are primarily used to work with dependency properties.

[12:47:53.0162] <Yehuda Katz>
however... it implies that the watcher is forever, no?

[12:49:32.0345] <trueadm>
> <@wycats:matrix.org> however... it implies that the watcher is forever, no?

Well back then the design allowed for effects to be detached from the graph. I was just seeing what the appetite was for an alternative approach.

[12:50:48.0759] <trueadm>
I think events might be fine. However, I do worry about the overhead in allocations from events and EventTarget. The signal graph is essential for performance so it needs to be as lean and optimal as possible to ensure it can scale well for complex UI cases.

[12:51:08.0978] <Yehuda Katz>
trueadm: I'm both pretty free-and-easy on the exact details of what's going on at the flushing edges *and* very committed to designing a feature that facilitates and supports "it looks like one-shot but is magically up to date" patterns.

[12:51:25.0693] <Yehuda Katz>
Preact and React get a lot of that "for free" (with some cost) from the JSX model.

[12:51:51.0981] <Yehuda Katz>
But the Watcher API should facilitate a way of thinking about Vue/Svelte/Ember/etc templates that are, more-or-less, like JSX.

[12:51:55.0813] <rbuckton>
It could be that `Watcher` ends up being a poor use case for events. I'm still concerned that we don't have events. Signals and events both belong to a similar class of observer-related mechanisms, and that we're catering to a niche use case without considering wider issues.

[12:53:29.0025] <Yehuda Katz>
I think I see where you're coming from. I'm especially interested in the possibility of stripping away the affordances that have accreted onto the high-level EventEmitter and get down to the fundamentals

[12:54:15.0491] <Yehuda Katz>
What bothers me about "why not use an event" is that it implies a bunch of noise around the usage pattern when a much tinier pattern actually works. This is probably also why we keep getting more of these things.

[12:54:44.0329] <rbuckton>
FYI, I think the general consensus is that Matrix threads are a terrible UI. Replies are easier to follow when there aren't 5 conversations going on at once.

[12:56:11.0100] <Yehuda Katz>
I guess I'm just used to it via work Slack. I have been keeping the threads pane open, but I'm probably swallowing a lot of cognitive overhead because I'm used to it.

[12:56:17.0866] <rbuckton>
> <@wycats:matrix.org> What bothers me about "why not use an event" is that it implies a bunch of noise around the usage pattern when a much tinier pattern actually works. This is probably also why we keep getting more of these things.

Yes, but this becomes a death by a thousand papercuts. At some point we have to stop tacking on one-off "similar but not the same" mechanisms.

[12:57:03.0637] <Yehuda Katz>
I'm super into the design space of "what's the minimal EventEmitter that would be ergonomic enough so people would use it instead of ad-hoc callbacks, and also serve as a foundation for the ones that exist"

[12:57:10.0722] <Yehuda Katz>
Does that characterize your position correctly?

[12:57:11.0915] <rbuckton>
If `Watcher` is dissimilar enough, maybe I drop the concern, It just doesn't *feel* so dissimilar.

[12:58:14.0584] <Yehuda Katz>
> <@littledan:matrix.org> One thing to understand about the watcher mechanism is that its use should really be buried within the implementation of effects or rendering, not for direct use by JS devs

ljharb was quibbling with this point, but I really liked your point that the "simple effects" people intuit they want are a DOM feature, which keeps this point true.

[12:59:07.0732] <rbuckton>
> <@wycats:matrix.org> Does that characterize your position correctly?

That and "how do we make it compatible with the DOM and NodeJS". I'm pretty sure there would be opposition to a wholly new event mechanism.

[12:59:30.0846] <Yehuda Katz>
> <@littledan:matrix.org> One thing to understand about the watcher mechanism is that its use should really be buried within the implementation of effects or rendering, not for direct use by JS devs

 * ljharb was quibbling with this point, and he's not wrong about the  `fetch` precedent. That said, I really liked what your point (the "simple effects" people intuit they want are a DOM feature). 

[12:59:41.0535] <Yehuda Katz>
 * ljharb was quibbling with this point, and he's not wrong about the  `fetch` precedent. That said, I really liked your point (the "simple effects" people intuit they want are a DOM feature).

[13:01:29.0691] <Ashley Claymore>
`Watcher` is in someways like `FinalizationRegistry`, where its core purpose is to be notified. So taking a single callback as a constructor argument maybe does fit this pattern well. As opposed to EventEmitters which are fan out to a changing N

[13:01:52.0178] <Ashley Claymore>
* `Watcher` is in someways like `FinalizationRegistry`, where its core purpose is to be notified. So taking a single callback as a constructor argument maybe does fit this pattern well. As opposed to EventEmitters which are fan out to a changing N observers 

[13:01:53.0365] <Yehuda Katz>
> <@aclaymore:matrix.org> `Watcher` is in someways like `FinalizationRegistry`, where its core purpose is to be notified. So taking a single callback as a constructor argument maybe does fit this pattern well. As opposed to EventEmitters which are fan out to a changing N

Great observation!

[13:02:09.0355] <rbuckton>
I would like to have proposed an events mechanism before, and have wanted one for years, but I'm already overcommitted to other work and I hadn't yet reached the proverbial "last straw".

[13:04:05.0624] <rbuckton>
> <@aclaymore:matrix.org> `Watcher` is in someways like `FinalizationRegistry`, where its core purpose is to be notified. So taking a single callback as a constructor argument maybe does fit this pattern well. As opposed to EventEmitters which are fan out to a changing N observers

Maybe it is, but Signals, Observables, Promises, and Events all belong to a similar category of observation mechanisms, even if they fill out different quadrants.

[13:05:09.0152] <Ashley Claymore>
True, but something grouping things hides how they should be approached differently 

[13:07:04.0899] <Ashley Claymore>
Observables can model Promises and also synchronous return values. But when I worked on projects that used Observables in perhaps too many places it was hard to reason about them. "Is this an observable of many values, or one. Is it async or sync"  

[13:07:41.0284] <Ashley Claymore>
The Watcher is more like a Sink than an Emitter. And has a different set of responsibilities 

[13:07:58.0532] <Ashley Claymore>
but I do see your point

[13:08:09.0915] <rbuckton>
Side question: How much of the Signals proposal is actually `Signal`/`Computed` vs `Watcher`? In other words, is `Watcher` the building block that both `Signal` and `Computed` are built on?

[13:10:05.0553] <Ashley Claymore>
Signals and computed on their own work, but to be reactive without watcher that would be a polling system. Like how some hardware works where the main loop just keeps checking what is dirty 

[13:10:23.0569] <Ashley Claymore>
on their own the caching still works 

[13:10:33.0731] <Yehuda Katz>
> <@rbuckton:matrix.org> Side question: How much of the Signals proposal is actually `Signal`/`Computed` vs `Watcher`? In other words, is `Watcher` the building block that both `Signal` and `Computed` are built on?

No, it's not

[13:10:36.0047] <Ashley Claymore>
Reading a computed twice in a row is cached 

[13:12:13.0377] <Yehuda Katz>
> <@wycats:matrix.org> No, it's not

Everything about reading computeds, having them cache, invalidation, etc can be described without reference to the `Watcher`

[13:13:08.0132] <Yehuda Katz>
a `Watcher` allows you to say "I am using this computed to populate a sink of some sort (usually a DOM node), and I need to know when any of its dependencies change so I can properly schedule it to update and read its value when I do that"

[13:13:26.0551] <rbuckton>
> <@aclaymore:matrix.org> The Watcher is more like a Sink than an Emitter. And has a different set of responsibilities

This is a fair point. I have to think more about my concerns and whether I might still consider them blocking for stage 2. Either way, I still think it is unfortunate that we might have this and yet still be missing events.

[13:17:39.0173] <Yehuda Katz>
> <@rbuckton:matrix.org> This is a fair point. I have to think more about my concerns and whether I might still consider them blocking for stage 2. Either way, I still think it is unfortunate that we might have this and yet still be missing events.

I keep trying to nudge the term `Sink` into the explanations we give

[13:17:42.0109] <Yehuda Katz>
I think it's really good

[13:17:55.0019] <rbuckton>
Signals feels like we're giving everyone a chainsaw when they need a flathead screwdriver. Sure, that's great for the woodcutters, but that means the rest of us have to get by with a butter knife. Normally, I wouldn't conflate two proposals in this way were it not for the close similarities.

[13:19:16.0317] <Yehuda Katz>
> <@rbuckton:matrix.org> Maybe it is, but Signals, Observables, Promises, and Events all belong to a similar category of observation mechanisms, even if they fill out different quadrants.

I'm pretty open to filling out the table. Some formal-ish observations: Signals facilitate discrete updates, are pull-based, and have a lot in common with the incremental computation academic space

[13:19:39.0471] <rbuckton>
And don't get me wrong, I like the idea of signals. I've used knockout and React and so many other systems with a similar concept, and I can see its utility in other places as well.

[13:20:12.0617] <Yehuda Katz>
> <@wycats:matrix.org> I'm pretty open to filling out the table. Some formal-ish observations: Signals facilitate discrete updates, are pull-based, and have a lot in common with the incremental computation academic space

People want to tell me that they're push-pull, but signals do a pretty different thing than what people usually mean by push-pull, producing pretty different abstractability and interface outcomes

[13:20:28.0306] <Yehuda Katz>
I could believe you want to make "push-pull" more subtle

[13:21:20.0565] <rbuckton>
"Filling out the table" was supposed to include Observable as well. I'm not certain why the proposal switched venues.

[13:21:45.0146] <rbuckton>
Can setting a signal trigger a UI update? If so, it's push based.

[13:21:47.0484] <Yehuda Katz>
rbuckton: What, imo, is new from the FRP wikipedia page (or even the various attempts to nail this down in terms of promises and observables) is that we have a lot of existence proofs now that the theoretical issues people have with those choices are managable and efficient at scale in the context of web UIs.

[13:21:55.0172] <rbuckton>
 * Can setting a signal trigger a UI update? If so, it's _also_ push based.

[13:22:47.0958] <Yehuda Katz>
> <@rbuckton:matrix.org> Can setting a signal trigger a UI update? If so, it's _also_ push based.

Setting a signal sends a notification, but there's an all-signals read-write barrier in the notification, which prevents you from simply updating the UI right there

[13:22:57.0435] <Yehuda Katz>
it also doesn't need to propagate through computeds

[13:22:57.0790] <rbuckton>
`Computed` is definitely pull only.

[13:24:02.0522] <Yehuda Katz>
At the extreme end, the original Ember model (which is spiritually equivalent) has a single microtask notification that coalesces any amount of signal updates

[13:25:37.0746] <Yehuda Katz>
and that causes a top-down revalidation uses pull-based revalidation to cut off subtrees, and which manages to be relatively efficient because of the natural logarithmic(ish) properties of output DOM trees

[13:26:06.0256] <Yehuda Katz>
You can call this a "push" but it's not really what people mean when they talk about "push-pull" models

[13:29:04.0199] <rbuckton>
I will withdraw my Stage 2 blocking concern. While I'd like to have a native event mechanism, `Watcher` does not seem like a fit for it and I don't think it's fair to block a proposal on the basis of the existence or non-existence of a separate proposal I do not have the capacity to champion myself. I am still concerned about the lack of events, but I'm willing to wait until the next push trigger to raise the concern, or for when I have less on my plate.

[13:31:37.0080] <rbuckton>
> <@wycats:matrix.org> You can call this a "push" but it's not really what people mean when they talk about "push-pull" models

I suppose that's true in the broader sense

[13:50:39.0539] <rbuckton>
I have an interesting observation, though in the end it is perhaps not relevant to signals. For a number of years I have also been considering a proposal to add `ref` (though potentially spelled `&`) for both reference passing and reified references, i.e.:

```js
function f(&x) { x = 1; } // reference passing
function g(xref) { xref.value = 2; } // reified reference

let y = 0;

f(&y); // pass reference to mutable binding
y; // 1

const yref = &y; 
g(yref); // pass reified reference to mutable binding

y; // 2

let &ym = yref; // dereference to mutable binding
ym = 3;

y; // 3

const &yc = yref; // dereference to immutable (but live) binding
y++;
yc; // 4
```

I wonder how interesting it would be if you could treat state/computed as refs:

```js
let &counter = new Signal.State(0);
counter; // 0
counter++;
counter; // 1

const &parity = new Signal.Computed(() => counter % 2 ? "odd" : "even");
```

[13:51:28.0206] <rbuckton>
I've been collecting use cases and this seems like an interesting one.

[13:57:01.0400] <rbuckton>
Some of the other use cases include decorators (to handle circularity/TDZ)

```js
@Entity
class Parent {
  @OneToMany(&Child) children;
}

@Entity
class Child {
  @ManyToOne(&Parent) parent;
}
```

and private state in shared structs

```js
shared struct AtomicValue {
  #value; // do not allow unordered access to private field

  load() { return Atomics.load(&this.#value); }
  compareExchange(expected, replacement) { return Atomics.compareExchange(&this.#value, expected, replacement); }
  ...
}
```

Plus a few others.

[14:02:04.0812] <rbuckton>
To the runtime, `&` is more like a syntactic transformation, so the signals example ends up treated as something roughly like this:

```js
const ref_mut_counter = new Signal.State(0);
ref_mut_counter.value; // 0
ref_mut_counter.value++;
ref_mut_counter.value; // 1

const ref_cnst_parity = new Signal.Computed(() => ref_mut_counter.value % 2 ? "odd" : "even");
```



[14:03:44.0763] <rbuckton>
One benefit to having Signals as a built-in mechanism in ECMA-262 is that we could get away with specifying it as a reified reference.

[14:04:09.0775] <rbuckton>
or rather, a kind of reified reference.

[14:19:23.0671] <Yehuda Katz>
I had to suddenly switch back to work-work -- sorry for disappearing mid-convo :)

[14:21:32.0477] <Yehuda Katz>
> <@rbuckton:matrix.org> To the runtime, `&` is more like a syntactic transformation, so the signals example ends up treated as something roughly like this:
> 
> ```js
> const ref_mut_counter = new Signal.State(0);
> ref_mut_counter.value; // 0
> ref_mut_counter.value++;
> ref_mut_counter.value; // 1
> 
> const ref_cnst_parity = new Signal.Computed(() => ref_mut_counter.value % 2 ? "odd" : "even");
> ```

fwiw, I am personally interested in exploring trimming down the portion of the API that really has to be a reference, ideally separating it from the value portion. This is roughly the Starbeam API, but I would need to float it by other framework authors to see whether there are incidental simplifying assumptions in Ember that let us get away with that design, but which prevent it from being fully general

[14:30:31.0967] <Yehuda Katz>
> <@wycats:matrix.org> I had to suddenly switch back to work-work -- sorry for disappearing mid-convo :)

And now I really do have to go! Please DM me with any follow-ups. The thoughtful feedback and questions were really invigorating :)

[14:43:18.0761] <trueadm>
> <@rbuckton:matrix.org> I have an interesting observation, though in the end it is perhaps not relevant to signals. For a number of years I have also been considering a proposal to add `ref` (though potentially spelled `&`) for both reference passing and reified references, i.e.:
> 
> ```js
> function f(&x) { x = 1; } // reference passing
> function g(xref) { xref.value = 2; } // reified reference
> 
> let y = 0;
> 
> f(&y); // pass reference to mutable binding
> y; // 1
> 
> const yref = &y; 
> g(yref); // pass reified reference to mutable binding
> 
> y; // 2
> 
> let &ym = yref; // dereference to mutable binding
> ym = 3;
> 
> y; // 3
> 
> const &yc = yref; // dereference to immutable (but live) binding
> y++;
> yc; // 4
> ```
> 
> I wonder how interesting it would be if you could treat state/computed as refs:
> 
> ```js
> let &counter = new Signal.State(0);
> counter; // 0
> counter++;
> counter; // 1
> 
> const &parity = new Signal.Computed(() => counter % 2 ? "odd" : "even");
> ```

That's pretty much how Svelte 5 works with signals. We don't actually expose Signal objects, instead they're hidden away by the compiler.

```js
let counter = $state(0):

counter++;
console.log(counter); // 2
```

[14:45:04.0339] <Yehuda Katz>
> <@trueadm:matrix.org> That's pretty much how Svelte 5 works with signals. We don't actually expose Signal objects, instead they're hidden away by the compiler.
> 
> ```js
> let counter = $state(0):
> 
> counter++;
> console.log(counter); // 2
> ```

it's also how Ember works with our precursor to signals and how Starbeam (our next generation reactivity system, which is my primary technical project on Ember these days) interacts with them.

[14:45:05.0492] <trueadm>
 * That's pretty much how Svelte 5 works with signals. We don't actually expose Signal objects, instead they're hidden away by the compiler.

```js
let counter = $state(0):

counter++;
console.log(counter); // 1
```

[14:45:20.0872] <Yehuda Katz>
There's mostly a pretty close mapping between the concepts we use and signals.

[14:45:39.0175] <Yehuda Katz>
Also, turns out if I want to avoid nerd-sniping myself, I need to turn off notifications :P


2024-04-12
[17:17:44.0426] <littledan>
Watcher is about notifying "something may be going on with something in this set of things that I care about", and then letting you (later) access that going-on subset. I haven't heard of a pub-sub thing with a requirement like that. Using the signals directly to represent themselves, as opposed to a subscription object, saves lots of allocations in a hot path. And there's no payload--also unusual for pub/sub systems (since you get the payload by reading the computed, and computeds are not pub/sub)

[17:22:15.0039] <littledan>
> <@wycats:matrix.org> ljharb was quibbling with this point, and he's not wrong about the  `fetch` precedent. That said, I really liked your point (the "simple effects" people intuit they want are a DOM feature).

Yes, I am sympathetic with this inevitability of direct use... I would like to improve the ergonomics as much as possible, as long as the proposal still works (e.g., not introducing too much runtime overhead).

The main thing that's relevant here is, you shouldn't use Watcher objects as if they represent a subscription to a Computed. You *can* sort of do this, but we  want to discourage that usage style--Computeds are supposed to exist within a lazily evaluated dependency graph.

Overusing Watchers moves you back towards push-based reactivity. It causes more "loops" until all the values "settle". It's like overusing `useEffect` in React.

[03:06:53.0712] <Duncan MacGregor>
I would strongly support rbuckton's suggestion of adding a better idea of references, and then building signals on top of that as a type of reference. References feel like they carry their own weight as a feature much better than Signals do on their own.

[05:58:03.0504] <littledan>
> <@aardvark179:matrix.org> I would strongly support rbuckton's suggestion of adding a better idea of references, and then building signals on top of that as a type of reference. References feel like they carry their own weight as a feature much better than Signals do on their own.

There was a lot of skepticism to the idea of references when they were introduced to committee previously. What should be the next steps there?

[05:58:26.0759] <littledan>
(I think they'd be cool, personally)

[05:59:19.0040] <rbuckton>
Was something similar ever presented? I haven't proposed it yet

[05:59:58.0447] <rbuckton>
I've briefly mentioned them on occasion, but nothing formal as of yet

[06:04:05.0119] <littledan>
oh sorry I got confused... probably I'm thinking of when I floated the idea of variable decorators... sorry for the confusion on my part!

[06:04:28.0480] <littledan>
> <@aardvark179:matrix.org> I would strongly support rbuckton's suggestion of adding a better idea of references, and then building signals on top of that as a type of reference. References feel like they carry their own weight as a feature much better than Signals do on their own.

 * <del>There was a lot of skepticism to the idea of references when they were introduced to committee previously. What should be the next steps there?</del> (I was hallucinating) I'm pretty worried that the committee would be really negative about that idea.

[06:04:42.0632] <littledan>
actually I'm not sure if I actually brought that to committee either

[06:05:40.0245] <littledan>
but, I really don't want to block signals (which are perfectly expressible within JS as it is today) on something fundamental about how variables work (which might be nice but also IMO would compose well "on top")

[06:07:02.0396] <littledan>
> <@trueadm:matrix.org> In an earlier design, we had the notion that you could pass a computed a callback function that would trigger when it was made dirty. The downside was that you had to pass this upon construction of the computed, which meant interoperability was impaired. However, it could be modelled differently. Is that better than having a watcher?

and this was a special computed which we called an "effect" -- normal computeds would definitely not work this way; it's just not the programming model for computeds.

[06:08:57.0036] <littledan>
I don't think there's anything in signals which is pub/sub.

[06:20:44.0566] <littledan>
At least I think of "sub" as subscribing to the data which is published--signals, even the watcher, doesn't have an API like this.

[06:22:31.0951] <littledan>
I wanted to go with Signal/State/Computed because they approximated ecosystem consensus for terms, so I though they'd be the most straightforward reference point

[06:23:13.0001] <littledan>
> <@wycats:matrix.org> The signals proposal does something in between. There's always a counter that can be used for invalidation, and you can form a strong connection from state->effect (via a watcher). The invalidation itself works the same in both cases though (e.g. the cache is invalidated not via a watcher but via the counter)

the counter is kinda an implementation detail, and implementations can drop it while a signal is connected, if they want to

[06:23:37.0714] <littledan>
my mental model matches trueadm's

[06:26:26.0014] <littledan>
definitely not more things with Abort in them, at least

[06:27:19.0548] <littledan>
somehow the terrible naming there (plus the high level of difficulty of using AbortSignal/AbortController correctly without leaks) makes me feel like, uniquely, we actually *could* make another cancellation API

[06:27:46.0092] <littledan>
Yeah the question is whether the state is "well-behaved"

[07:41:29.0797] <ljharb>
fwiw i think references would be a very dangerous concept to add to the language

[08:10:13.0130] <rbuckton>
> <@ljharb:matrix.org> fwiw i think references would be a very dangerous concept to add to the language

Why?

[08:11:00.0353] <ljharb>
they‚Äôre hard to understand and can be an easy footgun. people already misunderstand object mutation behavior in terms of references.

[08:11:46.0699] <ljharb>
if you want a live version of a value, we already have functions and getters (and I‚Äôve often heard live export bindings described as a mistake)

[08:19:45.0175] <rbuckton>
Specifying arrows to handle both read and write, or an object with getters and setters, is a lot of boilerplate that could be reduced down to a single character. Decorators could sorely use them and are the reason I drafted a proposal for refs ages ago. The repetition of `() =>` for every relationship in an ORM and for DI binding gets quite exhausting after awhile.

[08:24:09.0857] <rbuckton>
And long term I think there will be sufficient motivation for private fields in shared structs, such as to ensure you use methods on the struct to ensure reads and writes to the field are atomic. To support that scenario, though, you need to be able to pass some kind of reference to `Atomics.load`/`Atomics.store`/`Atomics.compareExchange`/etc., and there's no other way to do that presently.

[08:29:25.0073] <rbuckton>
They would be a powerful feature, but I do believe they need a large number of motivating use cases before they should be considered. That's why I haven't brought the proposal to plenary yet. Decorators alone weren't sufficient motivation, IMO, and even then it took a long time for Decorators to reach Stage 3. Decorators + Private Names in Shared Structs + Signals + multiple return value efficiencies over array destructuring might be close enough, but there's still a ways to go for some of those.

[09:06:54.0701] <littledan>
my other idea to avoid `() =>` was to make prefix `^` before an expression to be our "lightweight arrow function" syntax

[09:07:31.0834] <littledan>
(doesn't address atomics references, or references to a map entry, etc)

[09:07:35.0157] <rbuckton>
That doesn't help with setters though.

[09:07:41.0118] <littledan>
nope

[09:08:01.0335] <littledan>
 * nope it doesn't

[09:08:36.0177] <rbuckton>
Its also still a function with call overhead. With `&`, an implementation could theoretically inline the reference if both the argument and the parameter are refs.

[09:10:39.0647] <Yehuda Katz>
littledan: And I think ecosystem consensus matters more than my aesthetics, which is why I didn't even advocate for a change once, even privately :)

[09:12:41.0224] <rbuckton>
 * Its also still a function with call overhead. With `&` an implementation could theoretically inline the reference if both the argument and the parameter are refs.

[09:12:56.0717] <littledan>
do you think this would be realistic to do in a baseline bytecode interpreter? function calls are already inlined during higher JIT modes

[09:13:52.0166] <littledan>
in some sense, a traffic signal is just there, and you look at it when it's relevant to you :)

[09:14:10.0915] <Yehuda Katz>
I will inform my driving instructor üòÜ

[09:14:32.0087] <littledan>
oh yeah I don't drive...

[09:14:37.0069] <Yehuda Katz>
me neither

[09:14:44.0537] <Yehuda Katz>
that's why I'm 41 and have a driving instructor

[09:15:08.0157] <rbuckton>
Sorry, inlining is the wrong term here. I described `&` as being a syntactic transform. What I'm saying is that if you use `&` for both the argument and the parameter no such transform needs to occur and the `Reference`, not the value, is passed as the argument. 

[09:17:25.0699] <rbuckton>
By passing the reference, reads and writes would just occur against the referenced binding without any function call overhead or additional stack space.

[09:18:29.0074] <rbuckton>
Since this could be analyzed statically, its possible this could be handled at any layer.

[09:21:18.0085] <rbuckton>
You might not be able to optimize away a reified ref, but then you're still no slower than a function call might be.

[12:09:56.0110] <trueadm>
I'm really interested in the Reference proposal idea. If you have any draft notes somewhere, I'd love to read them. I think they'd really help solve a big problem with Svelte 5's new reactivity model in how we can "pass" reactivity around boundaries such as functions and modules. We've been pushing the community towards using closures and getters/setters, but there's been a lot of resistance as they just find it cumbersome. We've been holding off adding more Svelte compiler magic because it skews the lines of what's really happening.

[12:19:14.0234] <littledan>
> <@rbuckton:matrix.org> Since this could be analyzed statically, its possible this could be handled at any layer.

yeah this kind of thing sounds like a bytecode interpreter might be able to handle it...


2024-04-14
[10:55:30.0312] <bakkot>
I've written up all the "stop coercing things" rules; would appreciate review https://github.com/tc39/how-we-work/blob/e7d60e88d5ae2b5b5ae133ce94d6654cceba2c1f/normative-conventions.md

[10:55:43.0100] <bakkot>
PR is https://github.com/tc39/how-we-work/pull/136


2024-04-15
[18:20:39.0027] <rkirsling>
ah, year is updated to 2024 because there was never a PR merged in the mean time?

[18:37:33.0897] <bakkot>
indeed

[19:49:53.0482] <rkirsling>
funny transcription error in notes:
> first of all, I support this at Stage 1 because Stage 1 is sufficiently asmr

[16:00:03.0101] <shu>
how does the assert in step 2 here work: https://tc39.es/ecma262/#sec-%asyncfromsynciteratorprototype%.next

[16:00:16.0388] <shu>
am i missing something? can't you call it with an arbitrary receiver?

[16:02:31.0531] <bakkot>
asyncfromsynciterator is fictional right now 

[16:02:55.0779] <bakkot>
it's only used in `for await (let item of sync)`, or `yield* sync` in an async iterator

[16:03:01.0837] <bakkot>
neither of which expose the actual wrapping iterator

[16:06:14.0895] <shu>
ah okay

[16:06:32.0101] <bakkot>
 * it's only used in `for await (let item of sync)`, or `yield* sync` in an async generator


2024-04-16
[00:05:01.0597] <nicolo-ribaudo>
We should probably convert the "Async-from-Sync Iterator instances are not directly observable from ECMAScript code" fact from https://tc39.es/ecma262/#sec-properties-of-async-from-sync-iterator-instances into some normative requirement on calls to `GetIterator(..., ASYNC)`, since it can return an Async-from-sync Iterator and it's called by hosts

[00:05:46.0771] <nicolo-ribaudo>
The web streams spec uses it, for example (and they correctly do not expose Async-from-sync iterators to user code)

[07:56:07.0909] <Michael Ficarra>
please open an issue on ecma262


2024-04-17
[09:49:42.0711] <bakkot>
hey nice, SRI support for ES modules finally https://github.com/whatwg/html/pull/10269

[12:00:10.0268] <bakkot>
ljharb: I just realized that I had previously suggested a `Function.prototype.try`, and that kind of conflicts with `Promise.try` in that `Promise` inherits from `Function` but `Promise.try` is a different thing than `Function.prototype.try` would be

[12:00:32.0653] <bakkot>
I feel like if we are going to use that name for something it would be better used on `Function.prototype.try`

[12:01:18.0593] <bakkot>
`Function.prototype.try` being https://matrixlogs.bakkot.com/TC39_Delegates/2023-11-29#L10

[12:01:28.0505] <bakkot>
maybe we can just live with the conflict? but it's a bit awkward

[12:02:25.0335] <bakkot>
I guess because `Promise` can't be called without `new` it is unlikely to be an issue in practice, but still

[12:19:43.0238] <Justin Ridgewell>
I don't think that'd be a conflict

[12:20:02.0788] <Justin Ridgewell>
One returns a sync monad (can we get a `Result` type?), the other returns an async monad

[12:20:25.0678] <Justin Ridgewell>
Someone actually just asked for `Result` in the internal Google chat yesterday

[12:23:24.0661] <nicolo-ribaudo>
> <@jridgewell:matrix.org> I don't think that'd be a conflict

Promise is an instance if function, so it would shadow .try with an incompatible implementation 

[12:23:54.0789] <Justin Ridgewell>
I understand, but disagree that it‚Äôs incompatible

[12:24:20.0967] <Justin Ridgewell>
It‚Äôs returning the type appropriate for the constructor

[12:26:46.0036] <Justin Ridgewell>
And I'm now remembering that `Promise.try` receive the fn to call as its first argument, and `Function.try` would not.

[12:26:53.0168] <Justin Ridgewell>
 * And I'm now realizing that `Promise.try` receive the fn to call as its first argument, and `Function.try` would not.

[12:26:59.0956] <Justin Ridgewell>
Never mind, ignore my comments.

[16:07:31.0965] <Michael Ficarra>
https://github.com/tc39/ecma262/pull/3313

[16:26:27.0057] <rbuckton>
> <@jridgewell:matrix.org> Someone actually just asked for `Result` in the internal Google chat yesterday

Something along the lines of `Option` that I've been talking about in relation to extractors and pattern matching and ADT enums? 

[16:28:00.0447] <Justin Ridgewell>
 Similar but not quite, since `None` can‚Äôt carry data that `Err` can

[16:29:16.0388] <rbuckton>
Fair, though `Result` still seems like something in the same ballpark 


2024-04-18
[20:53:19.0757] <rkirsling>
I feel dumb but can somebody tell me what test262 directory a test for `null[{ toString: () => { ... } }]` belongs in?

[20:53:37.0707] <rkirsling>
 * I feel dumb but can somebody tell me what test262 directory a test for `null[{ toString() { ... } }]` belongs in?

[21:02:12.0893] <rkirsling>
e.g. `language/expressions/property-accessors` seems like it's about _specific_ properties to access and not about the general concept of how "bracket access" should operate

[21:36:10.0285] <bakkot>
rkirsling: I don't see an obvious place for it

[21:36:29.0041] <bakkot>
so... make `language/expressions/member-expression`?

[21:39:44.0531] <rkirsling>
can do 

[05:08:50.0935] <Jack Works>
> <@bakkot:matrix.org> ljharb: I just realized that I had previously suggested a `Function.prototype.try`, and that kind of conflicts with `Promise.try` in that `Promise` inherits from `Function` but `Promise.try` is a different thing than `Function.prototype.try` would be

does it have a receiver parameter?

[06:10:45.0155] <ljharb>
a receiver param for function try is awkward imo

[06:29:31.0942] <nicolo-ribaudo>
`fn(...args)!?` and `obj.method(...args)!?` syntax instead of `.try`, so that there is no question problem with the receiver?

[06:31:27.0680] <Anthony Bullard>
Are we talking about Rust? üòâ

[07:28:17.0325] <Ashley Claymore>
Part of me feels like it should be a static helper. As this is the year of `Object.groupBy` and `Promise.try` but we don't have a class for what this returns. Or maybe we wait until we do and then it's `Result.try(fn)`

[11:14:09.0072] <bakkot>
It is not worth having syntax for this

[11:14:43.0568] <bakkot>
For the specifying the receiver, `Function.prototype.tryCall`

[11:15:36.0471] <bakkot>
 * For the specifying the receiver, `Function.prototype.tryCall(obj.method, obj, ...args)`

[11:37:54.0277] <ljharb>
i don't think it makes sense to have a receiver argument at all. you can do that yourself with `.bind`. `Function.try` or `Result.try` makes much more sense to me.

[11:54:39.0406] <Michael Ficarra>
there's no need for a receiver parameter, you can just do `Function.prototype.call.bind(Function.prototype.call).try(fn, thisValue, ...args)`

[11:55:11.0643] <bakkot>
uhhhh I would much prefer to write `obj.meth.tryCall(obj, ...args)` instead of that

[11:55:16.0362] <Michael Ficarra>
I often save this "call-bound call" (`Function.prototype.call.bind(Function.prototype.call`) and use it throughout my programs

[11:55:31.0605] <Michael Ficarra>
maybe instead we need to introduce a `Reflect.call` or something that has it pre-defined

[11:55:57.0907] <bakkot>
https://github.com/js-choi/proposal-function-demethodize

[11:56:46.0674] <Michael Ficarra>
lol nice: https://www.npmjs.com/package/call-bind

[11:56:52.0219] <bakkot>
https://github.com/tc39/proposal-call-this

[11:57:22.0770] <bakkot>
I am not in favor of new syntax but yes a new method would be good

[11:58:07.0972] <Michael Ficarra>
I think some people may be opposed to it being on `Reflect`, but it seems so nice to have `call` sitting next to `apply` there

[11:58:09.0145] <Richard Gibson>
I don't know why the current dislike of receiver is so prevalent (cf. [proposal-async-context#80](https://github.com/tc39/proposal-async-context/issues/80) and the aforementioned [proposal-promise-try#15](https://github.com/tc39/proposal-promise-try/issues/15#issuecomment-2045965423)) and assumed to be permanent, but I very much dislike the corresponding fracturing of the language in which new proposals gratuitously diverge from Function.prototype.{apply,call} and Reflect.apply‚Äî_especially_ when discussion in plenary has raised opposition to anything that encourages more use of things like `.bind` and arrow wrappers.

[11:59:21.0644] <Michael Ficarra>
Richard Gibson: maybe because most of the time you don't need to specify receiver, and when you do, you have call-bound call to bail you out?

[11:59:22.0300] <bakkot>
`Function.prototype.apply/call` and `Reflect.apply` are special helpers, which are very rarely sensible precedent to use for other methods

[12:00:33.0345] <bakkot>
I am happy to have a `Function.prototype.tryCall` sitting next to `Function.prototype.try` for that use case, but I don't want to make the signature of methods like that worse for the common case of no receiver just for parity with `Function.prototype.call` 

[12:00:51.0804] <ljharb>
the receiver argument in array methods is terrible and if not for precedent, i'd hope none of the new methods would have had it. bind, or an arrow, is The Way

[12:01:17.0290] <ljharb>
> <@bakkot:matrix.org> I am happy to have a `Function.prototype.tryCall` sitting next to `Function.prototype.try` for that use case, but I don't want to make the signature of methods like that worse for the common case of no receiver just for parity with `Function.prototype.call`

which is also why "receiver" and "varargs" is a problem, because having to put `null` when you don't care about the receiver sucks

[12:01:22.0681] <ljharb>
so, we should just omit the receiver

[12:01:38.0899] <ljharb>
 * so, we should just omit the receiver. the language has lots of tools to handle that, and there's proposals for the ones it doesn't.

[12:08:58.0378] <Richard Gibson>
> bind, or an arrow, is The Way

have you forgotten that implementers specifically objected to proposals that would encourage their use?

> **most of the time** you don't need to specify receiver
> worse for the **common case** of no receiver

Emphasis mine. This is presumptive about future language use, but even so I would agree if not for precedent in the existing ways to call functions with arbitrary arguments. To have new signatures leave no room for an argument that is present in all old ones seems like unnecessary complexity. If you want to break with the past and foster arrow functions, then make that be necessary for arguments as well (e.g., `try(() => fn(‚Ä¶))`).

[12:09:43.0544] <bakkot>
To have new signatures specifically require the user to think about receivers is unnecessary complexity

[12:12:48.0385] <ljharb>
> <@gibson042:matrix.org> > bind, or an arrow, is The Way
> 
> have you forgotten that implementers specifically objected to proposals that would encourage their use?
> 
> > **most of the time** you don't need to specify receiver
> > worse for the **common case** of no receiver
> 
> Emphasis mine. This is presumptive about future language use, but even so I would agree if not for precedent in the existing ways to call functions with arbitrary arguments. To have new signatures leave no room for an argument that is present in all old ones seems like unnecessary complexity. If you want to break with the past and foster arrow functions, then make that be necessary for arguments as well (e.g., `try(() => fn(‚Ä¶))`).

that wasn't about encouraging their _use_, but their _overuse_

[12:13:28.0491] <ljharb>
as for "make it necessary for arguments as well", i agree with that, which is why Promise.try didn't initially have that capacity, but folks wanted it so i added it

[12:13:35.0463] <bakkot>
I am happy to have _additional_ methods which allow specifying the receiver, but now that we have spread args there's no reason to use `Function.prototype.call/apply` except when specifying the receiver - specifying the receiver is what they're for. It really, really does not make sense to consider them precedent for other functions

[12:13:44.0051] <ljharb>
either way, "no recevier, with arguments" is way way more common than "with a receiver"

[12:13:58.0796] <ljharb>
 * either way, "no receiver, with arguments" is way way more common than "with a receiver"

[12:14:16.0016] <ljharb>
 * either way, "no receiver, with arguments" is way way more common than "with a receiver", at least for any usage that isn't literally `obj.method(...args)`

[12:14:28.0055] <Richard Gibson>
> <@ljharb:matrix.org> either way, "no receiver, with arguments" is way way more common than "with a receiver", at least for any usage that isn't literally `obj.method(...args)`

by "more common" you're referring to authored code, right?

[12:14:55.0476] <ljharb>
yes? if the alternative is "generated code", we should not care about what generated code does

[12:15:03.0509] <ljharb>
 * yes? if the alternative is "generated code", we should not care about what generated code does (wrt API design, only wrt breakage)

[12:15:09.0550] <ljharb>
 * yes? if the alternative is "generated code", we should not care about what generated code does (not wrt API design, only wrt breakage)

[12:15:41.0064] <ljharb>
 * yes? if the alternative is "generated code", we should not care about what generated code does (not wrt API design, i mean, only wrt breakage)

[12:18:26.0868] <bakkot>
It is worth caring about generated code, but that should take the form of supplying APIs suitable for generated code, not changing the APIs for human-authored code

[12:18:31.0428] <bakkot>
... human or llm I guess

[12:18:47.0648] <Andreu Botella>
> <@bakkot:matrix.org> To have new signatures specifically require the user to think about receivers is unnecessary complexity

+1 to this, especially because of language learnability. `this`/receivers aren't things that come early when learning JS, especially because of how they differ from the equivalents in other languages. Even if `Promise.try` and `AsyncContext` are advanced use cases, language learning is non-linear.

[12:20:14.0990] <Richard Gibson>
fine, I yield

[12:31:35.0697] <Justin Ridgewell>
I also think an inline syntactic arrow fn doesn‚Äôt have the same performance penalties that dynamic closure-returning helpers and `fn.bind()` would have.

[12:40:47.0552] <littledan>
Richard Gibson: 
> have you forgotten that implementers specifically objected to proposals that would encourage their use?

Thinking about "how many closures is this going to imply are allocated in real use cases" is different from "thisArg should be a thing". Signals try to pass the right `this` value to achieve a similar goal.

[14:28:25.0364] <Michael Ficarra>
 * I often save this "call-bound call" (`Function.prototype.call.bind(Function.prototype.call)`) and use it throughout my programs


2024-04-19
[09:55:35.0352] <Chris de Almeida>
https://github.com/tc39/Reflector/issues/529

[09:55:46.0743] <Chris de Almeida>
‚òùÔ∏è gentle reminder to review/update notes from plenary before the 25th

[14:47:23.0155] <Justin Ridgewell>
@bakkot:matrix.org Can you kick the matrix log bot?

[14:47:51.0073] <Justin Ridgewell>
Oh, never mind

[14:48:17.0863] <Justin Ridgewell>
I forgot I have to click to go to the previous day üò¨

[14:48:33.0139] <Justin Ridgewell>
* ~~@bakkot:matrix.org Can you kick the matrix log bot?~~


2024-04-22
[15:05:38.0632] <TabAtkins>
Can I get https://github.com/tc39-transfer/proposal-random-functions adopted into the tc39 repo?

[15:14:20.0826] <Chris de Almeida>
> <@tabatkins:matrix.org> Can I get https://github.com/tc39-transfer/proposal-random-functions adopted into the tc39 repo?

proposals don't transfer to tc39 until stage 1

[15:29:31.0538] <ljharb>
i'll surely bounce it in as soon as it gets stage 1 tho

[15:29:38.0182] <ljharb>
lmk if you need any permissions fixed or anything

[15:34:18.0123] <TabAtkins>
Ah, k, np then. So far it looks like we're good.

[15:34:58.0704] <TabAtkins>
(Someone pinged me with some good ideas for a parallel project alongside my seeded random, and it would benefit to have them consistent, so I'm running it as well.)

[16:11:18.0822] <Michael Ficarra>
ah, this person I assume? https://github.com/tc39/proposal-seeded-random/issues/21

[16:12:57.0723] <Michael Ficarra>
TabAtkins: here's some more prior art for you: https://www.npmjs.com/package/gentest

[16:13:08.0461] <kriskowal>
> <@michaelficarra:matrix.org> ah, this person I assume? https://github.com/tc39/proposal-seeded-random/issues/21

This reminds me that I should get in touch with TabAtkins and poison his mind with my ‚Äúnew math‚Äù idea. (`new Math({ seed })`)

[16:13:29.0995] <TabAtkins>
> <@michaelficarra:matrix.org> ah, this person I assume? https://github.com/tc39/proposal-seeded-random/issues/21

yes

[16:13:38.0288] <TabAtkins>
> <@kriskowal:aelf.land> This reminds me that I should get in touch with TabAtkins and poison his mind with my ‚Äúnew math‚Äù idea. (`new Math({ seed })`)

lol what

[16:13:48.0056] <Michael Ficarra>
generative testing / directed fuzzing is just applying structure to a stream of randomness, so there's plenty of prior art to explore there

[16:14:24.0224] <kriskowal>
> <@tabatkins:matrix.org> lol what

got it in one

[16:15:30.0706] <kriskowal>
> <@michaelficarra:matrix.org> generative testing / directed fuzzing is just applying structure to a stream of randomness, so there's plenty of prior art to explore there

I have done this by hand at least twice.

[16:16:00.0865] <Michael Ficarra>
> <@kriskowal:aelf.land> I have done this by hand at least twice.

same

[16:16:35.0845] <kriskowal>
e.g., https://github.com/kriskowal/collections/blob/master/packages/specs/set-fuzz.js

[16:17:58.0117] <Michael Ficarra>
honestly, anyone who has ever made a data structure or pure data transformation as a library should have done this

[16:19:16.0011] <TabAtkins>
Thanks, I filed gentest under prior art

[16:21:01.0983] <bakkot>
I would start with just sampling an integer in a range and shuffling an array I think

[16:21:41.0725] <Michael Ficarra>
yeah it's gonna be hard to draw a line between obvious MVP inclusions and later additions

[16:21:47.0395] <Michael Ficarra>
like with iterator helpers

[16:28:29.0329] <TabAtkins>
Yup, that's why we're looking at a lot of prior art, to see what has a good argument for initial inclusion. Like, probably not all the distribution sampling from Python (tho *maybe* normal)

[16:28:48.0588] <TabAtkins>
But ints, floats, and shuffle I think are shoe-ins.

[16:31:26.0985] <bakkot>
I can't think of a time I've ever wanted a uniformly random float in some range other that [0, 1), but I guess I'm not opposed to having it

[16:32:28.0019] <TabAtkins>
I mean at least for floats it's not too bad to just implement it as `.random()*(max-min) + min`, tho perhaps there are more intelligent ways to make that slightly more uniform. 

[16:55:47.0159] <Michael Ficarra>
TabAtkins: I think you'd get a slightly unbalanced distribution for some very specific min/max choices (close together on either side of an ulp boundary) using that strategy


2024-04-23
[17:34:29.0754] <TabAtkins>
Right, exactly why I said you could do it more uniformly if you're smart (and why we should thus include it in the proposal, tho without requiring any guarantees stronger than what we already require for `Math.random()`)

[17:54:26.0944] <Michael Ficarra>
ü§î I don't know how to describe the distribution constraint on a function like `randomFiniteNumber(min, max)`

[17:54:31.0265] <Michael Ficarra>
I think this is going to be pretty hard

[17:57:12.0528] <kriskowal>
Might be fun. Might involve Bayes.

[17:57:38.0149] <kriskowal>
Or the old trick about removing bias from a biased coin flip.

[18:29:29.0821] <bakkot>
"distribution of numbers should be indistinguishable from the distribution you'd get by picking a real number uniformly at random from `[min, max)` and then converting to double, re-sampling the result is `max`" works but I don't know how practical that is to implement

[18:30:13.0881] <bakkot>
in practice most RNGs have some doubles they simply won't output

[18:30:21.0146] <bakkot>
further reading at https://github.com/tc39/proposal-seeded-random/issues/20

[18:30:54.0568] <bakkot>
frankly I don't think it's worth asking engines to try to de-bias for case Michael Ficarra mentions

[18:40:08.0893] <TabAtkins>
Agreed, personally. If committee thinks differently I'm fine with whatever, but the crypto random exists for high quality randomness purposes. We can live with "sufficiently good" randomness elsewhere.

[18:44:14.0363] <Michael Ficarra>
to be clear, this isn't about randomness generation, this is about a transform applied to a random, pseudorandom, or even non-random source

[18:44:54.0023] <Michael Ficarra>
crypto random is a high quality random, yes, but if you apply a biased transform to it, you're still going to get a biased result

[07:24:16.0717] <littledan>
> <@softwarechris:matrix.org> proposals don't transfer to tc39 until stage 1

This matches my understanding of the process, though ljharb has said something else in #tc39-beginners:matrix.org . Let's figure out what we want the process (I'm fine either way) to be and document the result somewhere.

[08:13:38.0887] <Chris de Almeida>
> <@littledan:matrix.org> This matches my understanding of the process, though ljharb has said something else in #tc39-beginners:matrix.org . Let's figure out what we want the process (I'm fine either way) to be and document the result somewhere.

it's documented, although could be clearer.  I'll follow up in the other channel

[08:21:09.0952] <Chris de Almeida>
on second thought, this is the better room to discuss

[08:42:24.0918] <Chris de Almeida>
there is documentation in the presenting.md and champion.md that make it clear that proposals move to the tc39 org once they reach stage 1

[08:42:43.0309] <Chris de Almeida>
> it's not that a proposal repo is disallowed in the org pre-stage-1, just that it's not a requirement until then, and if the proposal isn't going to go anywhere, it may not want to live there

this appears to technically be true. I suggest that we explicitly disallow this in the future. repos within the org give the impression that the committee has agreed to work on the proposal, or is at least interested in the problem it addresses. proposals that have not been presented/discussed in committee (and reached stage 1) cannot attest to that.

also, it would be a distraction and unnecessary burden (and for whom?) to have to decide what stage 0 proposals are or are not allowed in the TC39 org. requiring stage 1 inherently resolves this problem and responsibility is clear.

answering DE's question from the other channel: there is at least one stage 0 proposal in the TC39 org, from about 10 years ago:  https://github.com/tc39/proposal-bind-operator . it was presented to committee at least, but champions did not seek stage 1 at the time.

[09:55:07.0642] <littledan>
That proposed policy SGTM. I'm fine with bind operator being grandfathered in as an exception.

[10:31:44.0154] <TabAtkins>
> <@softwarechris:matrix.org> there is documentation in the presenting.md and champion.md that make it clear that proposals move to the tc39 org once they reach stage 1

What repo are those files in? I'd checked in tc39/proposals and didn't see any information.

[10:32:10.0644] <Chris de Almeida>
> <@tabatkins:matrix.org> What repo are those files in? I'd checked in tc39/proposals and didn't see any information.

https://github.com/tc39/how-we-work

[10:32:46.0146] <Chris de Almeida>
> <@softwarechris:matrix.org> https://github.com/tc39/how-we-work

and in the proposals repo, it's at the bottom of the readme:  https://github.com/tc39/proposals#onboarding-existing-proposals

[10:36:42.0695] <TabAtkins>
All right, dropped a few PRs in the proposals repo to fix the usability of the README

[10:48:35.0871] <ljharb>
> <@softwarechris:matrix.org> > it's not that a proposal repo is disallowed in the org pre-stage-1, just that it's not a requirement until then, and if the proposal isn't going to go anywhere, it may not want to live there
> 
> this appears to technically be true. I suggest that we explicitly disallow this in the future. repos within the org give the impression that the committee has agreed to work on the proposal, or is at least interested in the problem it addresses. proposals that have not been presented/discussed in committee (and reached stage 1) cannot attest to that.
> 
> also, it would be a distraction and unnecessary burden (and for whom?) to have to decide what stage 0 proposals are or are not allowed in the TC39 org. requiring stage 1 inherently resolves this problem and responsibility is clear.
> 
> answering DE's question from the other channel: there is at least one stage 0 proposal in the TC39 org, from about 10 years ago:  https://github.com/tc39/proposal-bind-operator . it was presented to committee at least, but champions did not seek stage 1 at the time.

i don't agree; the archival needs of ecma suggest that we should want rejected proposals in the org also

[10:49:45.0860] <ljharb>
we also have https://github.com/tc39/proposal-symbol-thenable and there's probably a few others

[10:50:01.0628] <ljharb>
iow the current process is just a requirement, not a prohibition, and that was quite intentional

[11:07:29.0157] <littledan>
When different people believe that there are different policies in currently place, let's focus on what the policy *should* be. We might not find the "real" answer for some of these cases, and it's not the most relevant thing.

[11:08:04.0145] <littledan>
 * When different people believe that there are different policies in currently place (for confusing unwritten things which are presumably guided by precedent), let's focus on what the policy _should_ be. We might not find the "real" answer for some of these cases, and it's not the most relevant thing.

[11:44:45.0579] <Chris de Almeida>
> <@ljharb:matrix.org> i don't agree; the archival needs of ecma suggest that we should want rejected proposals in the org also

this is a good point.  maybe the requirement should be only that the proposal was at least presented to committee.  (thenable was presented as well as bind operator, FWIW)

[11:54:57.0059] <ljharb>
requiring any proposal presented to the committee be in the org seems good

[11:55:06.0805] <ljharb>
but i don't see any value from prohibiting any proposal from being in the org, ever

[11:55:44.0140] <ljharb>
if it's not in the stage process then it can be archived, and/or a note added to the readme, if "confusion" is a concern (but i've not heard concrete examples of people being confused)

[11:56:28.0010] <Chris de Almeida>
oh, I don't really view it in terms a prohibition..  I am mostly interested in disambiguating when a proposal repo should be in the org.  I just don't want us to be wasting any time humming and hawing about it.  so something easy like 'has it been presented' or even 'does it have a champion and at least an explainer' would probably be fine too

[11:56:32.0019] <ljharb>
> <@littledan:matrix.org> When different people believe that there are different policies in currently place (for confusing unwritten things which are presumably guided by precedent), let's focus on what the policy _should_ be. We might not find the "real" answer for some of these cases, and it's not the most relevant thing.

i generally agree with this, but people happening to believe incorrect things shouldn't cause anything to be relitigatable, either

[11:57:44.0606] <ljharb>
> <@littledan:matrix.org> When different people believe that there are different policies in currently place (for confusing unwritten things which are presumably guided by precedent), let's focus on what the policy _should_ be. We might not find the "real" answer for some of these cases, and it's not the most relevant thing.

 * i generally agree with this, but people happening to believe incorrect things shouldn't automatically cause anything to be necessarily relitigatable, either

[11:58:02.0483] <ljharb>
> <@softwarechris:matrix.org> oh, I don't really view it in terms a prohibition..  I am mostly interested in disambiguating when a proposal repo should be in the org.  I just don't want us to be wasting any time humming and hawing about it.  so something easy like 'has it been presented' or even 'does it have a champion and at least an explainer' would probably be fine too

"when a champion wants it in the org" seems like it's worked fine so far

[11:58:28.0121] <ljharb>
we don't need explicit rules and regs for every little thing :-) sometimes "ad hoc" makes the most sense

[12:04:37.0857] <Chris de Almeida>
I don't disagree with that sentiment. it's good to have clarity on process and procedures, especially for newcomers that don't have prior knowledge -- and this is something I think we need to do better about across the board.  there is a lot of esoteric wisdom that is not as accessible as it probably should be

[12:12:59.0241] <Chris de Almeida>
> <@ljharb:matrix.org> i generally agree with this, but people happening to believe incorrect things shouldn't automatically cause anything to be necessarily relitigatable, either

documenting things also helps to avoid this

[12:14:19.0110] <Michael Ficarra>
I would prefer we have *some* tangible bar, and having been presented to committee seems acceptable to me

[13:19:44.0143] <TabAtkins>
Yeah, it would have helped me, a few days ago, to have some explicit guidance, regardless of what it actually was. I was happy to either make my own repo or put it directly into tc39, I just didn't know which was appropriate.

[13:46:39.0138] <littledan>
> <@michaelficarra:matrix.org> I would prefer we have *some* tangible bar, and having been presented to committee seems acceptable to me

We could define "Stage 0" as "has been presented at committee" and say that Stage 0 proposals can be in the TC39 org

[13:46:46.0948] <littledan>
maybe that's too complicated...

[13:47:06.0821] <littledan>
(it's confusing to me when something is considered Stage 0 or not)

[13:59:54.0594] <Chris de Almeida>
> <@littledan:matrix.org> (it's confusing to me when something is considered Stage 0 or not)

indeed.  stage 0 is not really a stage (?) and means stageless or no-stage.  docs refer to a proposal being "staged" as meaning it's at stage >= 1

[14:00:35.0005] <Chris de Almeida>
new stage: `-0`

[14:00:39.0898] <littledan>
but then sometimes I hear assertions that it's not Stage 0 until there's a TC39 champion

[14:01:34.0395] <littledan>
whether such assertions are backed by precedent is slightly beside the point; the current state is that the definitions are unwritten and different people have different ideas about what the reality is.

[14:06:59.0899] <littledan>
(if the precedent were strong then maybe it wouldn't be beside the point, but I expect that in several of these cases, people can make precedent-based arguments on both sides.)

[14:10:17.0742] <bakkot>
my understanding has always been

- stage 0 is any proposal any tc39 delegate has declared to be stage 0
- stage 1 is presented to the committee and not rejected (and can now go in the tc39 org)

I don't recall seeing any historical cases where this was not true?

"it's not Stage 0 until there's a TC39 champion" is consistent with "no entrance criteria" if you add the additional fact that only TC39 delegates can make proposals; "no entrance criteria" doesn't imply "anyone can make a proposal"

[14:24:04.0460] <littledan>
yep, this is a consistent story, and it's one that I've heard, alongside the "stage 0 is not really a thing" story (with the latter implying that it doesn't really require a TC39 champion given that it's not a thing in the first place)

[14:24:19.0188] <littledan>
either one is OK; let's choose one of the two and make it clear in writing

[14:25:31.0586] <littledan>
my strategy has been to sort of avoid mentioning Stage 0 given this ambiguity

[15:22:40.0468] <TabAtkins>
I'm fine with Stage 0 being "not really a stage" and something anyone can claim, akin to a UD in the W3C. It doesn't actually *matter* until it's presented to committee, which needs a champion, and I'm happy with the idea that "has been, or is about to be, presented to committee" is a sufficient condition for the proposal to be put into the tc39 org (and it seems reasonable to me to *require* that).

[15:24:11.0491] <kriskowal>
Saw a stage -1 the other day https://github.com/nzakas/proposal-write-once-const

[15:24:21.0614] <kriskowal>
 * Saw a Stage -1 the other day https://github.com/nzakas/proposal-write-once-const

[15:30:01.0198] <ljharb>
stage 0 is indeed almost everything, but by convention, only proposals that are on an agenda or presented to committee are considered stage 0

[15:30:18.0167] <ljharb>
it's become common to call things stage -1 prior to that point


2024-04-24
[23:24:56.0087] <Jesse>
> <@ljharb:matrix.org> it's become common to call things stage -1 prior to that point

proposal to use -0 for that purpose

[00:31:59.0316] <rkirsling>
-0 is kinda perfect, actually

[00:32:09.0390] <rkirsling>
still 0, but in a less positive way

[02:48:29.0630] <Rob Palmer>
If we're going to start differentiating between pre-stage 1 proposals I think it would be worth us documenting this somewhere, e.g. on how-we-work even if it's not part of the formal process. Until now I assumed Stage <1 were all in the same bucket.

[03:00:18.0344] <littledan>
> <@robpalme:matrix.org> If we're going to start differentiating between pre-stage 1 proposals I think it would be worth us documenting this somewhere, e.g. on how-we-work even if it's not part of the formal process. Until now I assumed Stage <1 were all in the same bucket.

By this do you mean, it is in the same bucket regardless of whether a delegate is involved?

[06:30:36.0207] <Rob Palmer>
Whatever meaning or difference we assign to the pre-stage 1 proposals (delegate involvement, agenda referenced, presented-but-not-advanced) to determine "you can call it stage 0 vs -1" should be documented - even if it's just a community convention.  Or we just say "they are all the same and outside our scope".

[06:38:17.0210] <rkirsling>
I've described Stage 0 in presentations before as "an idea you had in the shower and wrote up in Markdown", i.e. "an idea which is present-_able_", wherein the thing keeping it from Stage 1 could very well be finding a champion

[06:39:08.0710] <rkirsling>
would be unfortunate to have that not be valid

[06:41:27.0069] <rkirsling>
 * I've described Stage 0 in presentations before as "an idea you had in the shower and wrote up in Markdown", i.e. "any idea which could hypothetically be presented", wherein the thing keeping it from Stage 1 could very well be finding a champion

[06:42:22.0269] <rkirsling>
(I think `-0` is a very fun non-serious turn of phrase but `-1` is just enraging)

[06:42:37.0841] <rkirsling>
 * (I think `-0` is a fun non-serious turn of phrase but `-1` is just enraging)

[06:48:26.0182] <rkirsling>
 * I've described Stage 0 in presentations before as "an idea you had in the shower and wrote up in Markdown", i.e. "any idea which someone has put into a presentable state", wherein the thing keeping it from Stage 1 could very well be finding a champion

[07:23:43.0640] <ljharb>
> <@rkirsling:matrix.org> I've described Stage 0 in presentations before as "an idea you had in the shower and wrote up in Markdown", i.e. "any idea which someone has put into a presentable state", wherein the thing keeping it from Stage 1 could very well be finding a champion

stage 1 includes consensus the committee wants to explore the problem.

[07:27:44.0087] <rkirsling>
definition of Stage 1 goes without saying 

[09:31:48.0188] <ljharb>
oh right, i misread your coment

[09:31:50.0167] <ljharb>
 * oh right, i misread your comment

[09:32:21.0757] <ljharb>
so yeah, technically your stage 0 description is right, but the thing that would let it be in the proposals table is having a champion and being on an agenda, past or future


2024-04-25
[17:50:19.0963] <rkirsling>
right

[17:50:44.0301] <rkirsling>
I feel like that status doesn't really warrant a separate term but yeah

[20:03:00.0068] <littledan>
I am seeing both stories represented in this chat (‚Äústage 0 is not an actual thing that makes sense to think about criteria for‚Äù vs ‚Äústage 0 is when we have a real potential proposal, eg with a champion lined up‚Äù). There isn‚Äôt an agreed-on answer, even if your own interpretation seems obviously correct to you. I think we should make a shared decision on which interpretation we all take. A third option is to discourage the use of the term.

[20:06:09.0649] <littledan>
This is just a random one of several process points we have where there are multiple interpretations going around among long-time delegates. ‚ÄúCan IEs block‚Äù has long been another. I mean this in a neutral way: different understandings simply do exist; I am not advocating for one or the other position.

[20:11:58.0285] <ljharb>
that's true about "ship at stage 3", too. but the way things have mostly always been done in practice is usually the thing we should clear up misunderstandings about.

[20:17:01.0583] <littledan>
Right it was complicated and slow to build consensus around that, and the result is not 100% unambiguous even now. I think the currently reality is slightly more like, Stage 3 plus some intangible confidence is when things ship; I hope we can move more towards building up that confidence so it‚Äôs there right when something becomes Stage 3, and the recent 2.7 addition helps towards that goal.

[20:21:31.0759] <littledan>
* Right it was complicated and slow to build consensus around that, and the result is not 100% unambiguous even now. I think the currently reality is slightly more like, Stage 3 plus (in certain complicated cases) some intangible confidence is when things ship; I hope we can move more towards more consistently having that confidence when something becomes Stage 3, and the recent 2.7 addition helps towards that goal.

[20:22:31.0731] <ljharb>
indeed, "what thing actually mean" is often more complex than can be easily explained, or than is documented. but it's empirically deriveable, for all the things you've mentioned - there's only one current correct understanding. we can and should improve documentation when there's confusion, and we always can discuss changing what things mean if we think there's a better way.

[20:23:16.0603] <littledan>
I think these are exercises in consensus-building, not uncovering and documenting the real truth.

[20:23:24.0896] <ljharb>
both are part of it

[20:23:50.0631] <ljharb>
the meaning of a thing doesn't change just because someone comes up with a different understanding of it, unless that different understanding becomes what the committee empirically follows.

[20:26:35.0769] <littledan>
Often both precedent and historically intended meanings are ambiguous. We can work through this by gradually building consensus on what *should* be our way of working.

[20:27:12.0378] <ljharb>
i agree. but imo we can't build that consensus unless misunderstandings about how we *have* been working get cleared up.

[20:27:53.0167] <littledan>
Sure but making strong assertions on one side or the other doesn‚Äôt necessarily clarify things

[20:27:56.0528] <ljharb>
for example, IEs empirically have blocked, ‚à¥ they can block. if someone thinks they shouldn't be able to block, let's build consensus around that

[20:28:45.0880] <ljharb>
 * for example, IEs empirically have blocked, ‚à¥ they can block. if someone thinks they shouldn't be able to block, let's build consensus around changing that

[20:29:23.0678] <littledan>
When blocks occur, it can sometimes be ambiguous what is going on, eg what the rationale is, who did the block, or whether the champion just voluntarily decided to withdraw the proposal from consideration for advancement. I am glad we are working more on clarifying note-taking in this area.

[20:30:21.0900] <littledan>
A lot of times the committee carefully works at the intersection of many people‚Äòs interpretations of process

[20:30:50.0146] <ljharb>
indeed. and that becomes much more complex when new and different understandings materialize, which is why correcting those is beneficial.

[08:26:59.0785] <Chris de Almeida>
epistemology is hard

[08:33:13.0381] <Chris de Almeida>
a lot of good points have been made. I think it's important to proceed a bit cautiously, at the risk of overcorrecting with solutions to non-problems.  in other words, I am a lot more interested in solving for things like "what should delegates/IEs do when creating a proposal repo" and not as much in more abstract things like "what is the meaning of stage 0"

[08:39:01.0645] <Chris de Almeida>
I should have worded the last bit better.  it's important to have a shared understanding of what stage 0 means. further qualifying what is or is not stage 0 based on some criteria is only useful as far as it is practically relevant

[08:53:27.0035] <Chris de Almeida>
for example, if we added entrance criteria for stage 0, such as "there must be a champion", how is this valuable or materially different than the status quo?  a champion is needed for the proposal to progress to stage 1 (and beyond) anyway. so adding this (or probably _any_ entrance criteria) to stage 0 doesn't help anything, and it introduces a new problem: what to call non-stage 0 proposals. you effectively introduce a new stage, and to what end?

[10:52:38.0436] <keith_miller>
What do folks think about recommending web authors put the `value`/`done` properties on the iterator object directly and return that rather than return a fresh object each iteration loop? This, I think, should improve the performance of their iterators as they're not allocating fresh objects all the time. Is this a compatibility breaking change we should look into for built-in iterators too?

[10:54:03.0413] <keith_miller>
Given there's been a lot of debate about the performance of the iterator protocol on a bunch of recent proposals I'm trying to brainstorm solutions.

[10:55:21.0570] <keith_miller>
 * What do folks think about recommending web authors put the `value`/`done` properties on the iterator object directly and return `this` (aka the iterator itself) rather than return a fresh object each iteration loop? This, I think, should improve the performance of their iterators as they're not allocating fresh objects all the time. Is this a compatibility breaking change we should look into for built-in iterators too?

[10:56:21.0643] <keith_miller>
 * What do folks think about recommending web authors put the `value`/`done` properties on the iterator object directly and return `this` (aka the iterator itself) from `next` rather than return a fresh object each iteration loop? This, I think, should improve the performance of their iterators as they're not allocating fresh objects all the time. Is this a compatibility breaking change we should look into for built-in iterators too?

[10:57:37.0973] <shu>
are you saying as a new protocol?

[10:58:46.0654] <keith_miller>
No, as in you'd do ```function makeRangeIterator(start = 0, end = Infinity, step = 1) {
 let iterationCount = 0;

 const rangeIterator = {
   // It's recommended that iterators attach their value and done properties to the
   // iterator itself rather than return a new object every time (e.g. via `return { value: ..., done: ... }`)
   // as a performance optimization.
   value: start,
   done: false,
   next() {
     if (nextIndex < end) {
       this.value += step;
       iterationCount++;
       return this;
     }

     this.value = iterationCount; // Nit: This isn‚Äôt read so I don‚Äôt know why it‚Äôs here
     this.done = true;
     return this;
   },
 };
 return rangeIterator;
}``` Stolen from MDN's example and refactored

[10:59:04.0067] <shu>
ooh

[10:59:21.0782] <keith_miller>
 * No, as in you'd do ```function makeRangeIterator(start = 0, end = Infinity, step = 1) {
let iterationCount = 0;

const rangeIterator = {
// It's recommended that iterators attach their value and done properties to the
// iterator itself rather than return a new object every time (e.g. via `return { value: ..., done: ... }`)
// as a performance optimization.
value: start,
done: false,
next() {
if (nextIndex \< end) {
this.value += step;
iterationCount++;
return this;
}

 this.value = iterationCount; // Nit: This isn‚Äôt read so I don‚Äôt know why it‚Äôs here
 this.done = true;
 return this;
```

},
};
return rangeIterator;
}\`\`\` Stolen from MDN's example and refactored

[10:59:31.0018] <keith_miller>
 * No, as in you'd do function makeRangeIterator(start = 0, end = Infinity, step = 1) {
let iterationCount = 0;

const rangeIterator = {
// It's recommended that iterators attach their value and done properties to the
// iterator itself rather than return a new object every time (e.g. via `return { value: ..., done: ... }`)
// as a performance optimization.
value: start,
done: false,
next() {
if (nextIndex \< end) {
this.value += step;
iterationCount++;
return this;
}

this.value = iterationCount; // Nit: This isn‚Äôt read so I don‚Äôt know why it‚Äôs here
this.done = true;
return this;

```

},
};
return rangeIterator;
}\`\`\` Stolen from MDN's example and refactored
```

[10:59:34.0794] <shu>
that certainly has a _higher_ chance of being compatible but i still don't know how we find out other than "ship and see"

[10:59:49.0997] <keith_miller>
 * No, as in you'd do 
```
function makeRangeIterator(start = 0, end = Infinity, step = 1) {
let iterationCount = 0;

const rangeIterator = {
// It's recommended that iterators attach their value and done properties to the
// iterator itself rather than return a new object every time (e.g. via `return { value: ..., done: ... }`)
// as a performance optimization.
value: start,
done: false,
next() {
if (nextIndex \< end) {
this.value += step;
iterationCount++;
return this;
}

this.value = iterationCount; // Nit: This isn‚Äôt read so I don‚Äôt know why it‚Äôs here
this.done = true;
return this;

},
};
return rangeIterator;
}
```

[11:00:13.0973] <keith_miller>
Yeah, fair enough

[11:00:17.0253] <shu>
otherwise i mean, yeah, i like it for the obvious reasons

[11:01:22.0863] <keith_miller>
It also seems like we should recommend having `done`/`value` as the first two properties on your iterator so they don't blow out your ICs. But I don't know if engines all have the same behavior there so that's a bit more controversial

[11:02:05.0390] <bakkot>
I would make it a seperate object and re-use it

[11:03:17.0411] <keith_miller>
That's fine too although I guess slightly less efficient. But might be more likely compatible.

[11:03:52.0485] <keith_miller>
I suppose it also better avoids the `done`/`value` blowout problem

[11:04:29.0612] <bakkot>
In practice I don't think people are implementing iterators themselves much, rather than using generators

[11:05:27.0269] <keith_miller>
Yeah, probably. I suppose this same concept could be applied to generators. I have less of an idea on whether we can change that behavior...

[11:05:30.0679] <shu>
> <@keith_miller:matrix.org> It also seems like we should recommend having `done`/`value` as the first two properties on your iterator so they don't blow out your ICs. But I don't know if engines all have the same behavior there so that's a bit more controversial

V8 has a lot of complexity for fast-path checks for the shape of the iterator result object

[11:06:12.0967] <shu>
(we have a canonical map that's the same as if you wrote an object literal `{value, done}` and check against that)

[11:06:47.0682] <keith_miller>
Gotcha, I think we treat them the same as any other IC

[11:07:24.0772] <shu>
oh in user code we treat them the same as any other IC

[11:07:31.0452] <shu>
but in our built-ins we have all these checks

[11:07:46.0303] <keith_miller>
Ah ok

[11:18:35.0936] <bakkot>
It would be pretty weird, conceptually, for generators and built-in iterators to re-use their result object for each yielded value.... but I would be kind of surprised if it actually breaks anything? Holding onto the `{ done, value }` pair is a very strange thing to do

[11:28:29.0619] <keith_miller>
That's kinda why I was thinking that the iterator would return itself and have own `done`/`value` because it feels conceptually less weird but I'll take either solution.

[11:40:12.0891] <littledan>
> <@softwarechris:matrix.org> a lot of good points have been made. I think it's important to proceed a bit cautiously, at the risk of overcorrecting with solutions to non-problems.  in other words, I am a lot more interested in solving for things like "what should delegates/IEs do when creating a proposal repo" and not as much in more abstract things like "what is the meaning of stage 0"

I agree completely; that's the question from Tab that started all of this! I think I focused on less important things above, got off on a tangent.

[11:41:25.0717] <littledan>
> <@softwarechris:matrix.org> for example, if we added entrance criteria for stage 0, such as "there must be a champion", how is this valuable or materially different than the status quo?  a champion is needed for the proposal to progress to stage 1 (and beyond) anyway. so adding this (or probably _any_ entrance criteria) to stage 0 doesn't help anything, and it introduces a new problem: what to call non-stage 0 proposals. you effectively introduce a new stage, and to what end?

this is a good question to ask people who believe that the status quo already contains what you're describing as far as the entrance criteria. It'd be nice to disambiguate this stuff, but yes definitely less important than practical how-to advice.

[11:42:46.0847] <littledan>
> <@littledan:matrix.org> I agree completely; that's the question from Tab that started all of this! I think I focused on less important things above, got off on a tangent.

in particular, if our answer is, "you can do whatever you want!" for things where we really should be suggesting something concrete, thereby setting people up for some future criticism, we're giving suboptimal advice.

[11:50:48.0180] <Chris de Almeida>
you're absolutely right; we should set those expectations

[11:51:31.0357] <Chris de Almeida>
sometimes we've set them already and short-term memories get the best of us..  like I'm realizing and thinking to myself "why are we talking about champions at stage 0" when a champion is a clear entrance criterion for stage 1 and is well-documented

[11:52:41.0289] <littledan>
multiple people said above they believed it was self-evident that there is that requirement. While this issue isn't very important, it might be a nice easy one to start with as we untangle differing beliefs about what our process is.

[11:54:42.0757] <Chris de Almeida>
certainly.  in matters where we have a Source of Truth‚Ñ¢Ô∏è, we can reference that when people have conflicting views.  that should resolve.  if people want to change what the process/guidance is, that's ok too, but that should at least clear up what the current state is

[13:26:44.0111] <shu>
man, this language

[13:27:55.0639] <shu>
%TypedArray%.from(array) on JS arrays caches the entire input array ahead of time because it treats it as an iterable

%TypedArray%.set(array) on JS arrays does not cache the input array ahead of time because it treats it as an array-like

[13:43:27.0881] <TabAtkins>
> <@softwarechris:matrix.org> for example, if we added entrance criteria for stage 0, such as "there must be a champion", how is this valuable or materially different than the status quo?  a champion is needed for the proposal to progress to stage 1 (and beyond) anyway. so adding this (or probably _any_ entrance criteria) to stage 0 doesn't help anything, and it introduces a new problem: what to call non-stage 0 proposals. you effectively introduce a new stage, and to what end?

Right, I don't think we need anything additional stage-wise. I think it's perfectly fine to treat all early proposals as 0, regardless of their quality/championship/etc. I just ran into the "when does the proposal get put into the `tc39` repo" question, which was unclear and is a little inconsistent currently.

[13:44:18.0078] <TabAtkins>
I think a rule of "it's definitely moved when the proposal is stage 1; it *can* be moved, at the champion's discretion, when a stage 0 proposal is intended for presentation at a meeting" sounds reasoanble and appears to match consensus?

[13:44:48.0539] <TabAtkins>
Tho also the criteria listed in <https://github.com/tc39/proposals/blob/main/stage-0-proposals.md> are stricter than "any idea you write down".

[13:45:59.0748] <Chris de Almeida>
> <@tabatkins:matrix.org> Tho also the criteria listed in <https://github.com/tc39/proposals/blob/main/stage-0-proposals.md> are stricter than "any idea you write down".

my understanding is those criteria are required to be listed on that md, but that should be made clear, for all the reasons above

[13:47:00.0208] <TabAtkins>
Ah, that sounds reasonable, I can PR some wording

[14:14:40.0332] <littledan>
> <@tabatkins:matrix.org> I think a rule of "it's definitely moved when the proposal is stage 1; it *can* be moved, at the champion's discretion, when a stage 0 proposal is intended for presentation at a meeting" sounds reasoanble and appears to match consensus?

IMO we should adopt the simpler version, ‚Äúthe tc39 org includes just Stage 1+ things‚Äù and adopt the interpretation ‚Äústage 0 isn‚Äôt really a thing, just some silly turn of phrase with no meaning in committee‚Äù.

[14:15:10.0656] <TabAtkins>
This would also be fine with me (but we do have some Stage 0s in the org currently, so they'd have to eitehr be ejected or grandfathered)

[14:15:32.0691] <littledan>
> <@tabatkins:matrix.org> This would also be fine with me (but we do have some Stage 0s in the org currently, so they'd have to eitehr be ejected or grandfathered)

Agreed (and I would vote eject after the champions have some time to propose for stage 1)

[14:15:35.0478] <ljharb>
i'm pretty sure disallowing stage 0's in the org would not be inline with ecma's archival desires

[14:15:54.0886] <ljharb>
if anything i'd think they'd want all stage 0's to be in the org

[14:16:14.0483] <TabAtkins>
Well, not *all*, random people propose "stage 0" things as well.

[14:16:21.0005] <TabAtkins>
Before ever getting a champion.

[14:16:22.0768] <littledan>
> <@ljharb:matrix.org> i'm pretty sure disallowing stage 0's in the org would not be inline with ecma's archival desires

Could you elaborate on this? Aki is working on improving our archival stuff so collecting all requirements will be useful.

[14:17:46.0952] <littledan>
> <@tabatkins:matrix.org> Well, not *all*, random people propose "stage 0" things as well.

Sure, random people *say* they are proposing things, but is it really at stage 0? OTOH did they establish precedent? More epistemology.

[14:20:25.0619] <Chris de Almeida>
> <@littledan:matrix.org> Could you elaborate on this? Aki is working on improving our archival stuff so collecting all requirements will be useful.

at the point the committee discusses a proposal, that discussion and the proposal are subject to archiving.  having that proposal outside of the org makes that messy, and subject to additional risk of tampering

[14:20:48.0686] <Chris de Almeida>
having it in the org isn't a panacea, but it goes a long way

[14:22:05.0905] <littledan>
Interesting, I don‚Äôt think we have been consistent about transferring all presented proposals, have we been?

[14:22:44.0811] <TabAtkins>
No, I don't think so - the list of Stage 0 proposals, at least, only has one presented Stage 0 in the org; the rest are still in personal repos.

[14:25:18.0989] <littledan>
What if we add all presented repos to a list to be archived?

[14:25:27.0467] <littledan>
Which sort of tampering are we concerned about?

[14:26:20.0419] <ljharb>
someone can delete their github account, for example

[14:26:22.0280] <ljharb>
or a repo

[14:26:47.0557] <littledan>
Right, this is the point of archiving 

[14:27:43.0694] <littledan>
I don‚Äôt know if we have a functional archival system at the moment, but if we did, what would we want it to do?

[14:27:47.0465] <ljharb>
we certainly haven't transferred everything that's been presented and not gotten stage 1, but that'd be a good thing to do.

[14:28:10.0462] <ljharb>
clone all the repos, back up all the issue and PR and wiki content, i suppose? like a "web archive" of it all

[14:28:13.0534] <littledan>
Are there reasons in addition to archival why we should do this transfer?

[14:28:25.0147] <ljharb>
it's better for history and research and whatnot.

[14:28:44.0136] <ljharb>
but that's why it's been ad hoc, because it's depended on the circumstances.

[14:28:50.0831] <ljharb>
(which has been fine so far)

[14:28:55.0769] <littledan>
> <@ljharb:matrix.org> clone all the repos, back up all the issue and PR and wiki content, i suppose? like a "web archive" of it all

Yeah let‚Äôs think about what functionality we want from the archive. I like your idea because it would be accessible from the web rather than just a mysterious Ecma server

[14:29:17.0056] <ljharb>
either way, "one person asked a question that generated discussion" isn't necessarily sufficient reason to do a bunch of work documenting something :-)

[14:29:24.0382] <ljharb>
 * either way, "one person asked a question that generated discussion" isn't necessarily sufficient reason to do a bunch of work documenting something :-) (but it's fine if we want to do that)

[14:31:29.0107] <littledan>
> <@ljharb:matrix.org> it's better for history and research and whatnot.

Sounds like use cases of an archive?

[14:32:49.0912] <ljharb>
oh sure, fair

[14:32:56.0731] <ljharb>
then yeah that's the main reason i guess

[14:34:49.0217] <littledan>
> <@littledan:matrix.org> Are there reasons in addition to archival why we should do this transfer?

Any other reasons? Anybody?

[14:43:06.0748] <Chris de Almeida>
> <@littledan:matrix.org> Any other reasons? Anybody?

to be clear, you're asking for reasons why stage 0 proposal repos should be owned by the tc39 GH org, right?

[15:05:47.0134] <littledan>
Yes

[16:48:02.0307] <ljharb>
what are the reasons why they shouldn't be?

[16:51:42.0142] <Michael Ficarra>
if they haven't been presented to TC39, they're effectively unrelated to our work

[16:52:04.0680] <Michael Ficarra>
they shouldn't be given an air of legitimacy

[16:52:38.0817] <Michael Ficarra>
can any old rando online make a repo, write "TC39 sux" in the README, and ask us to move it into our org?

[16:52:44.0359] <Michael Ficarra>
I would hope not

[16:53:15.0245] <bakkot>
prior to being approved by the committee for stage 1, it's one person's proposal, not TC39's proposal

[16:53:51.0004] <Michael Ficarra>
also Ecma doesn't care about archival of stuff that basically only happened in someone's head

[16:54:01.0131] <Michael Ficarra>
they care about archival of materials related to our work


2024-04-26
[17:11:58.0937] <ljharb>
sorry i should clarify my question :-) for something that's been presented or will be, what's the reason why they shouldn't be? (obviously "any random repo" shouldn't necessarily be)

[17:12:53.0421] <Michael Ficarra>
no objection to that

[17:13:11.0652] <Michael Ficarra>
in fact, Ecma would almost certainly prefer that to be the criteria for pulling it in

[09:25:37.0183] <Rob Palmer>
***Reminder:***  The **Helsinki meeting** is in 6.5 weeks time!

Please use [the in-person registration form](https://forms.gle/8KBez5X3Mz64awQPA) and then advertise yourself on [the Doodle](https://doodle.com/meeting/participate/id/b4WlzGVa) if you intend to attend in-person.

I recommend stocking up on Fazer chocolate whilst you are there.

[11:24:34.0704] <ptomato>
is there standard language for consulting the various tables in the spec?

[11:24:53.0139] <ptomato>
e.g. as in [UnicodeMatchProperty](https://tc39.es/ecma262/#sec-runtime-semantics-unicodematchproperty-p)

[11:25:47.0805] <ptomato>
when you have a value that's listed in a table column, and you want to find the other pieces of data in the same row

[11:26:22.0864] <ptomato>
if we have standard language for this, it'd be good to document it ‚Äî currently, esmeta can't make any sense of phrasing like in UnicodeMatchProperty

[11:47:47.0241] <bakkot>
I don't think there's standard language, no

[11:47:58.0454] <bakkot>
I did something vaguely similar, but not identical, in https://github.com/tc39/proposal-regex-escaping/pull/77/files

[11:48:23.0805] <bakkot>
```
          1. Else if _c_ is the code point listed in some cell of the ‚ÄúCode Point‚Äù column of <emu-xref href="#table-controlescape-code-point-values"></emu-xref>, then
            1. Return the string-concatenation of 0x005C (REVERSE SOLIDUS) and the string in the ‚ÄúControlEscape‚Äù column of the row whose ‚ÄúCode Point‚Äù column contains _c_.
```

[11:50:40.0835] <ptomato>
"of the row whose X column contains Y" ‚Äî that at least is more explicit than "corresponding row" referring back to some unspecified previous algorithm step


2024-04-27
[19:38:47.0319] <Aki>
Attention speakers from the April TC39 meeting: if you haven't recorded your conclusions yet, it is now too late. I mean, if you update the google docs no one will see them. Message me if you have edits to make to the notes

[20:44:05.0704] <Aki>
‚òπÔ∏è almost no one provided either a conclusion or a summary, not even the proposals with stage advancement got a summarized for the notes.

[20:49:07.0186] <Aki>
missing conclusion and/or summary

- All status updates (probably fine)
- Joint-iteration (Michael Ficarra) [continued on thursday, still lacks conclusion or summary]
- Promise.try for stage 2.7 (ljharb)
- ESM source phase status update and layering change (guybedford)
- Atomics.microwait for stage 2 (shu)
- AsyncContext Stage 2 updates (Justin Ridgewell)
- Deferred import evaluation (nicolo-ribaudo)
- Treeshakeable/deferred re-exports status update (nicolo-ribaudo)
- Iterator.range for stage 2.7 (Jack Works)
- Reality and spec differ on property key resolution timing for o[p] = f() ( rkirsling)
- Intl.MessageFormat status update (eemeli) [this one is confusing AF, maybe you can help ryzokuken?]
- Discard Bindings for Stage 2 (rbuckton)
- Extractors for Stage 2 (rbuckton) [continued, still lacks conclusion/summary]
- eval/new Function changes for Trusted Types as Normative PR or Stage 3 ( nicolo-ribaudo)
- Array.isTemplateObject next steps (littledan)
- Module sync assert for stage 2 (Jack Works)
- bringing back Error.isError, for stage 1 or 2 (ljharb)
- Decimal for stage 2 (Jesse)
- Shared Structs Discussion (shu)
- Strict Enforcement of 'using‚Äô (rbuckton)
- Stop Coercing Things pt 4 (bakkot)
- Signals for stage 1 (littledan  and Jatin Ramanathan)

[20:49:21.0509] <Aki>
enjoy your weekends and then message me on Monday

[20:54:50.0344] <rkirsling>
did I misunderstand a process change?

[20:55:04.0994] <rkirsling>
result for mine is just "got consensus"

[20:55:22.0096] <Aki>
cool! great! 

[20:56:21.0670] <Aki>
everyone who presented should always be glancing at the notes to make sure their thoughts are well-represented, and someone (a notetaker if the notetakers have the time and space to do it, the presenter if they do not) should just note that

[20:56:55.0593] <Aki>
maybe it's a bulleted list with a summary of stuff that came up. maybe it's "achieved consensus for stage 3"

[20:57:03.0712] <Aki>
i'm in archivist mode now

[20:57:43.0920] <Aki>
and if there's really no summary worth noting, just write that. "no summary" or whatever.

[20:57:57.0547] <Aki>
something to indicate someone glanced it before it goes on the record forever

[21:01:07.0697] <Aki>
also Ross consensus on _what_. can't deduce from your title + "got consenus". it doesn't have to be a novel, just like "got consensus to align with original declaration" or whatever (i have no idea, i missed that section and can't read _all_ the notes right now)

[21:08:29.0608] <rkirsling>
oh yeah no I mean

[21:09:01.0863] <rkirsling>
I fully rewrote my words

[21:09:51.0179] <rkirsling>
but I haven't presented in a while and I thought the conclusion was just sorta in there

[21:11:29.0276] <Aki>
It‚Äôs definitely super helpful from a paperwork standpoint to have it super clear without skimming the whole transcript

[21:35:29.0237] <Jack Works>
> <@akirose:matrix.org> missing conclusion and/or summary
> 
> - All status updates (probably fine)
> - Joint-iteration (Michael Ficarra) [continued on thursday, still lacks conclusion or summary]
> - Promise.try for stage 2.7 (ljharb)
> - ESM source phase status update and layering change (guybedford)
> - Atomics.microwait for stage 2 (shu)
> - AsyncContext Stage 2 updates (Justin Ridgewell)
> - Deferred import evaluation (nicolo-ribaudo)
> - Treeshakeable/deferred re-exports status update (nicolo-ribaudo)
> - Iterator.range for stage 2.7 (Jack Works)
> - Reality and spec differ on property key resolution timing for o[p] = f() ( rkirsling)
> - Intl.MessageFormat status update (eemeli) [this one is confusing AF, maybe you can help ryzokuken?]
> - Discard Bindings for Stage 2 (rbuckton)
> - Extractors for Stage 2 (rbuckton) [continued, still lacks conclusion/summary]
> - eval/new Function changes for Trusted Types as Normative PR or Stage 3 ( nicolo-ribaudo)
> - Array.isTemplateObject next steps (littledan)
> - Module sync assert for stage 2 (Jack Works)
> - bringing back Error.isError, for stage 1 or 2 (ljharb)
> - Decimal for stage 2 (Jesse)
> - Shared Structs Discussion (shu)
> - Strict Enforcement of 'using‚Äô (rbuckton)
> - Stop Coercing Things pt 4 (bakkot)
> - Signals for stage 1 (littledan  and Jatin Ramanathan)

I added mine

[21:35:42.0820] <Aki>
My hero!!

[21:46:44.0361] <Ashley Claymore>
I feel like there is a challenge with how we utilise time boxing. Is the time box only for presentation+discussion -
or should it also account for the extra few minutes of conclusion capturing?

[21:48:02.0082] <Ashley Claymore>
As we've been trying to capture conclusions for over a year now, I think we have strong evidence that if we don't do it live then it rarely is added "offline"

[21:54:40.0184] <Aki>
Truth. Though genuinely I think ‚Äúreview the notes for your presentation, however briefly‚Äù has been a request since time immemorial 

[21:57:19.0148] <rkirsling>
again, I thought it was "review what you said" not "add new content to the doc"

[21:57:27.0488] <rkirsling>
but I have added said new content

[22:17:26.0227] <ptomato>
I've found it helpful to write the conclusion that I _want_ ahead of time, and put it on the final slide. that makes a good starting point for adapting it to reflect the actual summary, as well as a natural reminder

[22:17:33.0520] <ptomato>
 * I've found it helpful to write the conclusion that I _want_ ahead of time, and put it on the final slide. that makes a good starting point for adapting it to reflect the actual summary, as well as a natural reminder to do it

[09:32:27.0684] <ljharb>
Aki: added those sections for my two items, day 1 and 3 i think

