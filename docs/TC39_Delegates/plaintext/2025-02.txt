2025-02-03
[10:33:34.0590] <nicolo-ribaudo>
Reading through https://news.ycombinator.com/item?id=42876840, it seems like the most wanted proposals are Records&Tuples and pattern matching

[10:59:20.0837] <littledan>
Let's do both of them!

[15:53:29.0839] <Rob Palmer>
It looks like we will get a **Community Event in Seattle** on the evening of **Thursday 20th February.**  Please can folk who are attending volunteer some talks!

- [**Call For Speakers**](https://github.com/tc39/Reflector/issues/550)

SeattleJS are asking us to provide all the content for the evening, so I hope we can deliver lots of exciting talks.


2025-02-05
[17:17:59.0577] <Mathieu Hofman>
Does anyone know why we decided not to look for private fields on the prototype chain of any object? This somewhat came up in 2 different proposal discussions lately: https://github.com/tc39/proposal-class-access-expressions/issues/26 and https://github.com/ljharb/proposal-error-stack-accessor/issues/3 (the latter is for a internal slot but same idea)

[17:21:16.0610] <Mathieu Hofman>
It would likely break a ton of  "brand checks" use cases, but really there isn't an easy way to even create a helper to search the prototype chain as one cannot get a "ref" for the private field.

[17:22:14.0304] <Mathieu Hofman>
* It would likely break a ton of  "brand checks" use cases, but the problem is that there isn't any way to even create a helper to search the prototype chain as one cannot get a "ref" for the private field.

[00:11:46.0608] <Ashley Claymore>
the helper would need to take a callback: `(o) => #p in o`

[06:26:14.0849] <littledan>
It's hard/impossible to truly preserve privacy while also working with prototype chains, especially if you want to stick strictly to object-like semantics and not invent on a new thing. Also, the SES crowd insisted on WeakMap analogy semantics in particular, which has no prototype chain walk.

[08:47:27.0208] <ljharb>
also if it used the prototype chain then they wouldn’t be private fields, they’d be public ones, because anything can extend anything else at any time

[08:47:38.0688] <ljharb>
* also if it used the prototype chain then they wouldn’t be _private_ fields, they’d be public ones, because anything can extend anything else at any time

[08:54:50.0475] <littledan>
well, the space of possibilities is large, but yeah we had trouble finding a mechanism that would preserve privacy, have inheritance *and* have a number of other properties that people were interested in

[12:39:40.0329] <Ashley Claymore>
> <@ljharb:matrix.org> also if it used the prototype chain then they wouldn’t be _private_ fields, they’d be public ones, because anything can extend anything else at any time

And wouldn't have been able to minify them with so much confidence. Local lexical lookup is great for AOT transforms 


2025-02-06
[19:00:39.0895] <Ashley Claymore>

Realising this wasn't about matching other private fields with the same, so the name of the field would all still be local and still minifiable.
it's more that the lookup would have fewer guarantees. Because proxies, walking the proto chain could have side effects and give different answers.
so couldn't assume AOT things like `#p in v === #p in v`

[02:02:06.0779] <Mathieu Hofman>
Yeah the fact that looking up a private field cannot trigger any user code is a nice property. Combined with the fact you wouldn't know which object the value came from is probably sufficient reason for this to have been the right choice.


2025-02-07
[07:49:25.0188] <nicolo-ribaudo>
This is super early, however — a few of us will be taking the train to go to the A Coruña meeting in May (mostly from NL and UK). If anybody traveling from somewhere in western Europe wants to join us please write me a message by the end of February :)

[09:55:25.0724] <Rob Palmer>
- **Reminder:**  The Feb 2025 Plenary deadline for Stage Advancement is in 24 hours!


2025-02-11
[17:14:45.0064] <shu>
do i read RegExp.escape correctly that it doesn't care about lone surrogates? it'll just escape them?

[17:28:11.0708] <bakkot>
yeah

[17:28:43.0991] <bakkot>
I don't know if that means "doesn't care" since it does explicitly handle them

[17:29:09.0286] <bakkot>
but it handles them by escaping them

[19:27:13.0806] <shu>
fair. by "doesn't care" i mean it doesn't error out if input is malformed

[19:27:24.0205] <shu>
malformed by having lone surrogates

[21:25:13.0507] <ljharb>
to me yesthat sounds right 

[21:25:18.0614] <ljharb>
* that sounds right to me yes


2025-02-12
[10:06:37.0764] <TabAtkins>
Given that lone surrogates are valid values in JS strings, that seems like the right behavior, rather than erroring.

[13:51:30.0616] <Mikhail Barash>
Reminder: The [TG5 Workshop](https://github.com/tc39/tg5/blob/main/workshops/2025/106.md) will be held on Friday 21st of February, the day after the plenary meeting. It'll be hosted by F5 (same venue as the plenary).
Among other items on the agenda, we'll have a visitor from UCSD to talk about [the MessageFormat study](https://github.com/tc39/tg5/issues/3) and identify other proposals that might benefit from user studies.
Registration link: https://forms.gle/jBn3XguosNwJsScy6


_What is TG5?_

TG5 is a task group of TC39 that:
- conducts scientific studies on proposals, either "commissioned" by TC39 (e.g., MessageFormat study - to be presented at the upcoming workshop in Seattle), or out of self-driven interest with a clear potential to applicability to TC39
- develops methods, approaches, tools to aid understanding / designing / specifying the language (e.g., executable spec, spec formalisms, navigation within the spec, Proposal Management Tool, etc.)
- considers TC39 within the larger ecosystem of programming language design, specification and standardization (e.g., cross-standards research, language drift, decision-making)


2025-02-13
[18:12:46.0535] <Rob Palmer>
Reminder: Please register for SeattleJS on Thursday evening 20th Feb if you wish to attend!

https://lu.ma/s97y24jd

[23:20:35.0923] <Jesse>
ah, thanks for the reminder!


2025-02-14
[07:55:40.0456] <Michael Ficarra>
if anyone would like to join an A/V test call for next week's meeting at 10:00A Pacific (about 2 hours from now), send me a DM

[08:03:30.0517] <Rob Palmer>
^^^one volunteer requested! 

[08:06:39.0601] <Anthony Bullard>
DM sent


2025-02-16
[19:38:53.0854] <Rob Palmer>
In case anyone has not received or accepted the invite, we have a Seattle Matrix channel for in-person logistics. Please say if you would like an invite.


2025-02-17
[14:36:00.0502] <Chris de Almeida>
📣 the draft schedule is available on the meeting issue in Reflector:  https://github.com/tc39/Reflector/issues/547


2025-02-18
[17:09:34.0583] <Chris de Almeida>
in case we forget to mention it tomorrow, please do not ever use the `I'm done speaking` button in TCQ.  thank you!

[17:50:52.0350] <rkirsling>
TC39 rule: never stop speaking

[17:53:36.0804] <Jesse (TC39 🇺🇸)>
can we remove the button?

[18:07:55.0392] <Chris de Almeida>
https://github.com/bterlson/tcq/pull/68

[22:57:15.0252] <bakkot>
whatever happened to the rewrite?

[02:02:03.0156] <eemeli>
Looks like Christian Ulbrich and Tom Kopp were working on it here at least up until last June: https://github.com/zalari/tcq/pull/7

[08:11:12.0311] <Rob Palmer>
Sign in form with video link will be posted around 9am PT. 

[09:09:54.0431] <keith_miller>
Is there an ETA for the video link? I still don't see one in the reflector.

[09:20:26.0115] <Rob Palmer>
Not quite.  Michael is still setting up AV.

[09:20:31.0334] <keith_miller>
Oh I forgot these start at 10 not 9 lol

[09:21:25.0553] <Rob Palmer>
correct - there is 38 minutes until go time

[09:46:51.0824] <Rob Palmer>
The video link will be posted on the Reflector very soon

[09:51:13.0229] <Rob Palmer>
The video link is now posted via [the Sign-in form on the Reflector!](https://github.com/tc39/Reflector/issues/547)

[10:03:48.0475] <ljharb>
maybe we should add an actual persistent temperature check to tcq

[10:05:02.0268] <canadahonk>
fwiw its PST (-8) not PDT

[10:05:23.0244] <canadahonk>
* fwiw its PST (-8) not PDT (-7)

[10:13:55.0630] <Aki>
SUMMARIES ARE GOOD

[10:13:57.0322] <Aki>
YAY SUMMARIES

[10:24:42.0596] <Rob Palmer>
If anyone would like to be the TC39 Liaison to IETF please let the Chairs know or reach out to Samina directly.

[10:25:12.0932] <ljharb>
* maybe we should add an actual persistent temperature check to tcq (like, physical room temperature)

[10:26:49.0908] <ryzokuken>
we already liason with the W3C i18n WG for TG2

[10:27:04.0603] <ryzokuken>
and some WGs from Unicode for that matter

[10:27:25.0697] <ryzokuken>
* we already keep track of the W3C i18n WG for TG2

[10:27:41.0170] <eemeli>
Only technically, mind. I've a recurring conflict with their call, and Ben has not been able to attend many of their meetings.

[10:29:02.0854] <Chris de Almeida>
please share resources for where folks should go to get involved in TC55 (matrix room, meeting info, etc)

[10:29:18.0637] <canadahonk>
https://wintertc.org

[10:29:48.0229] <canadahonk>
* https://wintertc.org + https://github.com/wintercg/admin

[10:31:23.0385] <Andreu Botella>
matrix room: #wintertc:matrix.org 

[10:32:15.0900] <Aki>
rock and roll

[10:32:54.0572] <nicolo-ribaudo>
Thanks a lot Aki again for all the help with making sure that our technical work follows what Ecma needs

[10:33:25.0987] <canadahonk>
thank you all ECMA folks 🙇

[10:36:45.0996] <kriskowal>
You’re audible, Aki 

[10:36:58.0039] <Chris de Almeida>
oh reminder, there should not be notes during this period

[10:37:09.0406] <Chris de Almeida>
so please remove them and/or tell the transcriptionist to pause

[10:37:13.0970] <Chris de Almeida>
* so please remove them and tell the transcriptionist to pause

[10:37:15.0134] <Ashley Claymore>
it has been paused

[10:37:40.0921] <nicolo-ribaudo>
Don't worry, we manage also with you out of the call!

[10:37:43.0068] <Chris de Almeida>
and don't discuss here 🙂

[10:37:53.0777] <nicolo-ribaudo>
* Don't worry, we do things right also with you out of the call!

[10:38:04.0238] <Chris de Almeida>
of this, I have no doubt 🙂

[10:38:32.0863] <nicolo-ribaudo>
You can come back

[10:41:12.0539] <ljharb>
can we make sure the transcription bot, and transcription human, have resumed?

[10:41:35.0032] <nicolo-ribaudo>
The human is back and apparently the bot was not running in the first place

[10:42:09.0404] <Aki>
Now that Google Docs has "export as markdown", is it time to update the agenda item template?

[10:45:28.0593] <Chris de Almeida>
say more

[10:47:15.0668] <Aki>
Allows us to use the standard document styles and get markdown as a result https://snaps.akiro.se/2502_ji3bx.png

[10:49:43.0277] <ljharb>
the only reason the notes items are they way they are, afaik, is for ease of markdown conversion, so it seems fine to change them?

[10:50:20.0533] <Chris de Almeida>
suggest validating the quality of the export first

[10:52:19.0640] <Ashley Claymore>
Maybe we could try on Thursday, when the agenda is light. To reduce 'risk' if the formatting needs manual fix up

[10:53:17.0422] <Aki>
I've used the export for notes for other committees

[10:53:20.0055] <Aki>
I'm very happy with it

[10:58:02.0640] <bakkot>
nicolo-ribaudo: re: linking other web specs, I bet we could figure out how to automatically generate ecmarkup-compatible biblios from web specs if we really want to

[10:58:08.0664] <bakkot>
the ecmarkup biblios are very simple

[10:58:29.0584] <shu>
gotta snipe tab into supporting it in bikeshed

[10:58:58.0974] <nicolo-ribaudo>
Right now we just need to link to URL and fetch so doing it manually is probably less effort than making it work automatically, but if we'll need to link to more stuff I'll look into it

[10:59:16.0474] <nicolo-ribaudo>
Currently we also rely on Infra, but as part of the rewrite we are just going to rely on ECMA-262 built-ins instead

[11:11:01.0538] <Ashley Claymore>
One thing we sometimes do is wrap parts of the transcription in backticks, e.g. when someone references `Object.is`.
Do you know if these would carry-through, or would we need to do this by changing the font?

[11:12:06.0283] <Aki>
it escapes them, but that's a very easy search & replace

[11:12:27.0986] <Aki>
y'all have no idea how many regex search & replaces I do on every meeting's notes

[11:13:14.0152] <bakkot>
have you considered just asking an LLM to "make it good" :D

[11:13:28.0899] <Aki>
🤮

[11:13:37.0454] <ljharb>
can't wait to find out what lovecraftian horrors end up being stage 4 due to that

[11:17:40.0453] <Michael Ficarra>
somehow I feel much more comfortable trusting the speech-to-text than I do a text transform, and I can't explain why

[11:18:28.0549] <nicolo-ribaudo>
Probably speach-to-text worst case writes nonsense, rather than plausible-looking wrong stuff

[11:18:47.0844] <bakkot>
the trick with text transforms is to have it generate a diff, which you can then easily review for correctness

[11:19:15.0634] <bakkot>
also no, modern speech-to-text definitely writes plausible-looking wrong stuff a lot

[11:19:31.0417] <Aki>
Eggma showed up a lot in the last TC55 meeting

[11:20:01.0761] <nicolo-ribaudo>
https://docs.google.com/presentation/d/1LjsJhdTIP3wgo1odtVa-qbfyGU5M1W9YMm0AtKnJJKk/edit#slide=id.p

[11:20:21.0239] <bakkot>
https://github.com/bakkot/transcribe-to-gdocs/blob/fb863c5a314d078f2a0c60d26cf8774f08dd068a/replacements.js#L35-L46

[11:20:57.0092] <Michael Ficarra>
eggma is a new one lol

[11:21:28.0735] <bakkot>
(though this list was when using google's old speech-to-text; whisper is much better and I hear gemini is better still although I have not yet gotten around to hooking it up)

[11:24:43.0741] <Aki>
eggman

[11:25:35.0267] <Michael Ficarra>
if Whisper wasn't already better than a human transcriptionist (it probably is), Gemini certainly is

[11:26:12.0574] <ljharb>
coo coo ca choo

[11:27:39.0811] <rbuckton>
Oh, I missed this in my constraints. I need to be present for the Decorators discussion, so if it can remain after the lunch break I would appreciate it. I will add this to the agenda as a late breaking constraint

[11:29:40.0942] <Michael Ficarra>
except for 100%, right?

[11:37:40.0576] <canadahonk>
🤓 as someone who has tried/done "professional" transcriptions a while ago, I think Whisper is good at speech-to-text but has terrible/no formatting last I looked

[11:39:13.0606] <bakkot>
50% of the human transcriptionists we've hired have actively harmful formatting (double spaces between sentences, linebreaks every few words, etc), so "no formatting" is still superior

[11:41:53.0931] <canadahonk>
yeah agree with that

[11:46:37.0493] <Ashley Claymore>
Not sure if still true today, but in the past the human transcriptionists seem to handle people talking over each other better. Giving each their own `>>` lines

[11:47:39.0509] <littledan>
Could someone record a conclusion on the chair election in the notes?

[11:48:01.0783] <littledan>
(I'm happy to share the doc link in a DM if anyone needs)

[11:49:02.0892] <canadahonk>
we already have it i believe

[11:51:07.0192] <nicolo-ribaudo>
Nope, this is it:

### Speaker's Summary of Key Points
* List
* of
* things
### Conclusion
* List
* of 
* things


[11:51:08.0712] <littledan>
please edit the notes and add a summary and conclusion section, saying who was elected. It is currently missing.

[11:51:22.0601] <littledan>
I mean, I just pasted that in

[11:51:33.0451] <littledan>
I'm not sure if someone people believe that the earlier text implies the summary/conclusion

[11:51:41.0987] <littledan>
but... I just can't make sense of it

[11:51:45.0756] <canadahonk>
oh I read conclusion as conclusion of opinion oops nvm

[11:51:57.0384] <canadahonk>
* <del>we already have it i believe</del>

[11:51:59.0731] <littledan>
we just don't have a list in the notes of who was elected

[11:52:13.0995] <canadahonk>
i'll do in break if no one else does

[11:52:28.0129] <littledan>
(this is normal -- almost nobody writes their own summary and conclusion without prompting, but I didn't know who to prompt for this topic)

[11:53:01.0177] <nicolo-ribaudo>
Done

[11:57:57.0245] <Chris de Almeida>
presenters!  please note, the topics in the overhead bins have shifted during flight:  https://hackmd.io/dp19kCC5QBeG1W37oESrfQ?view



[13:20:15.0193] <nicolo-ribaudo>
`@babel/plugin-proposal-decorators` is the most downloaded Babel plugin on npm for a proposal. It has (looking at some plugins for proposals that have been around for a while and are among the most downloaded ones):
- 100x the downloads of `@babel/plugin-proposal-explicit-resource-management`
- 40x the downloads of `@babel/plugin-proposal-throw-expressions`
- 80x the downloads of `@babel/plugin-proposal-pipeline-operator`

[13:21:29.0987] <nicolo-ribaudo>
What is the burden with shipping first? Is it that you are the one that's going to find compatibility bugs?

[13:22:40.0489] <eemeli>
littledan: Did you really mean Stage 3, or should that have been 2.7?

[13:23:31.0360] <ljharb>
3 is when it's time to implement and ship, so while ideally things would be blocked at 2.7 if there's no desire to implement, 3 would be fine too

[13:23:44.0619] <ljharb>
but it's definitely subpar to have something be stage 3 that nobody's prioritizing 

[13:23:47.0888] <bakkot>
re the isSafeNumeric item later, Number toString technically allows implementations a choice of outputs in some cases https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-tostring

[13:23:51.0503] <bakkot>
does anyone actually... do that

[13:25:40.0604] <James M Snell>
I will say that it's rather frustrating as someone tracking the decorators spec work for some time... what I heard is that implementers don't want to prioritize it because they don't want to be the first to ship, but that they don't want to be the first to ship because the work is not prioritized..... what I'm not hearing at all is do the implementers just not want to implement decorators at all? Is this just a delay tactic to ultimately kill the proposal?

[13:29:21.0623] <rbuckton>
For many syntax features, developers are often comfortable with using a build tool to transform new syntax under the expectation that that transformation step can be removed once evergreen browsers have been updated to support the feature, but that requires those browsers to continue to make progress on shipping those features. Many syntax transformations are fairly cheap, though that's not always the case. Async functions and generators required fairly significant transformations and helper libraries to support, which adds overhead to bundles. The transformed emit for stage 3 decorators can also be quite large, which has a negative impact on bundle size and initial load time.

[13:30:00.0734] <rbuckton>
Even if feature availability is lopsided across browsers, developers can use server-side UA sniffing (or even client side with `import()`) to ship a leaner bundle with native decorators on browsers that support them, and a transformed bundle on browsers that don't. 

[13:31:46.0518] <bakkot>
possible in principle and I wish people did it more, but in practice I have ~never seen server-side UA sniffing for serving scripts with downleveled features to browsers which don't support something

[13:32:44.0614] <ljharb>
i think facebook might do it, but i've never actually seen it

[13:32:47.0359] <rbuckton>
> <@bakkot:matrix.org> possible in principle and I wish people did it more, but in practice I have ~never seen server-side UA sniffing for serving scripts with downleveled features to browsers which don't support something

Isn't this essentially what anyone participating in an Origin Trial would need to do?

[13:33:03.0365] <Michael Ficarra>
> <@bakkot:matrix.org> possible in principle and I wish people did it more, but in practice I have ~never seen server-side UA sniffing for serving scripts with downleveled features to browsers which don't support something

we literally do that

[13:33:22.0427] <snek>
one of the npm-to-web cdns does it, idr the name

[13:33:35.0361] <bakkot>
origin trials are most often APIs which you can just make conditional within a script instead of UA sniffing

[13:34:26.0540] <bakkot>
we do a lot of weird things! but that's a one-off for a particular feature we needed, not a general mechanism for arbitrary features

[13:36:47.0385] <bakkot>
`polyfill.io` did for APIs but that's a slightly different thing than syntax

[13:37:16.0353] <bakkot>
I don't think many places are using npm-to-web CDNs in prod

[13:37:21.0200] <bakkot>
well, presumably lots of hobbyist stuff

[13:37:41.0296] <rbuckton>
> <@bakkot:matrix.org> possible in principle and I wish people did it more, but in practice I have ~never seen server-side UA sniffing for serving scripts with downleveled features to browsers which don't support something

Large scale applications definitely have used both server-side UA sniffing and client-side feature detection to dynamically load content in different engines for performance tweaks.

[13:38:14.0175] <bakkot>
I agree some people do it; we do it. But it's very very rare in my experience, looking at random retailers and hotels and so on.

[13:42:35.0748] <nicolo-ribaudo>
syg: What we are doing with import defer, is that deferred namespace objects guarantee that they will never have a .then property. This doesn't actually change the promises machinery, but makes sure that deferred namesapces are inhert to it

[13:42:38.0360] <rbuckton>
If decorator downlevel emit size is a significant concern, it might be worth that kind of temporary split to produce a leaner bundle when possible. Web performance optimization is a major area of focus for large scale applications.

[13:42:54.0410] <nicolo-ribaudo>
* syg: What we are doing with import defer, is that deferred namespace objects guarantee that they will never have a .then property. This doesn't actually change the promises machinery, but makes sure that deferred namesapces are inert to it. And we can do it because they are already very exotic objects

[13:43:15.0112] <shu>
thanks. still says to me there's a datapoint that we consider "then" a special evil worth special casing

[13:46:01.0179] <littledan>
We did already make Object.prototype be exotic (to have a frozen __proto__) but I agree that exotic with respect to then is an extra form of weirdness

[13:49:42.0084] <bakkot>
Mathieu Hofman: for the Promise.resolve constructor lookup, see https://github.com/tc39/proposal-faster-promise-adoption/issues/1

[13:49:53.0256] <littledan>
For the notes: every time someone says "object dot proto", they mean Object.prototype, right? Not Object.__proto__

[13:50:01.0518] <bakkot>
currently the check is `IsPromise(p) && p.constructor === C`; I think it should be `IsPromise(p) && GetPrototypeOf(p) === C.prototype`

[13:50:07.0052] <littledan>
* For the notes: every time someone says "object dot proto", they mean `Object.prototype`, right? Not `Object.__proto__`

[13:50:30.0595] <bakkot>
GetPrototypeOf usually triggers user code, but can't trigger user code once you pass the IsPromise test

[13:53:13.0977] <Mathieu Hofman>
Yes this is when the "SafePromiseResolve" issue came up last time

[13:54:16.0549] <nicolo-ribaudo>
Are firefox use counters public, with a list of example websites, like Chrome's?

[13:55:04.0843] <Mathieu Hofman>
I basically want to make this check into a "SafePromiseResolve" that fast path promises that do not re-enter, and delay by one tick the ones that may. Then anyone can use that operation, possibly even `await`.

[13:55:51.0309] <Mathieu Hofman>
That's not sufficient if someone overrides `%PromisePrototype%` properties

[13:56:01.0662] <bakkot>
isn't it?

[13:56:03.0529] <Mathieu Hofman>
* That's not sufficient if someone overrides `%PromisePrototype%` `then` and `constructor` properties

[13:56:14.0226] <bakkot>
Promise.resolve does not do a lookup of `.then` on things which pass that check

[13:56:39.0235] <Mathieu Hofman>
It does for `constructor` if I recall.

[13:56:54.0383] <bakkot>
Right, it does `IsPromise(p) && p.constructor === Promise`

[13:57:21.0737] <bakkot>
but if we make it `IsPromise(p) && GetPrototypeOf(p) === C.prototype` then it would not do anything user-observable (on real promises)

[13:57:29.0433] <bakkot>
and I bet we can get away with that

[13:57:50.0359] <bakkot>
this also applies to `await` since it uses the same machinery

[13:58:22.0574] <bakkot>
and `await`  also does not do an actual `.then` lookup at all, it just does a PromiseResolve and then uses the built-in PerformPromiseThen

[13:58:28.0766] <Mathieu Hofman>
`defineProperty(`Promise.prototype`, 'constructor', {get() {} }})`

[13:58:38.0140] <Mathieu Hofman>
* `defineProperty(Promise.prototype, 'constructor', {get() {} }})`

[13:58:45.0710] <Mathieu Hofman>
* `defineProperty(Promise.prototype, 'constructor', {get() {} })`

[13:58:55.0400] <bakkot>
I don't know what that's intended to be a response to

[13:59:08.0031] <bakkot>
I am proposing to change the machinery so nothing ever looks at `.constructor`

[13:59:23.0394] <snek>
what constitutes a brand check

[13:59:32.0831] <snek>
like what granularity 

[13:59:36.0838] <snek>
there are so many ways to organize objects

[13:59:49.0756] <nicolo-ribaudo>
A sync side-effect-free way to tell wether an object has a particular internal slot or not

[13:59:51.0093] <Mathieu Hofman>
Oh, if you think that's web compatible

[14:00:01.0075] <nicolo-ribaudo>
* A sync side-effect-free way to tell wether an object has a particular internal slot or not, for any slot

[14:00:11.0227] <snek>
for *every* internal slot?

[14:00:16.0045] <bakkot>
I give it reasonable odds

[14:00:35.0163] <bakkot>
since the only thing that happens if something starts failing the check is that they get another microtask tick

[14:00:42.0247] <nicolo-ribaudo>
Well, a brand check is for _one_ internal slot, and Jordan would like every internal slot to have a brand check

[14:00:57.0788] <snek>
yeah i mean my question is what the consensus applied to

[14:01:10.0425] <snek>
because there are a lot of internal slots, how does one decide which ones are relevant in this case

[14:01:39.0436] <sffc>
Frank is ill, and I will now be presenting his slides on Intl Locale Info. Rob Palmer Chris de Almeida ryzokuken 

[14:01:55.0301] <Mathieu Hofman>
Yeah I just need to think through the different cases of "subclassing" that the constructor check is meant to handle. 

[14:02:08.0825] <ryzokuken>
hope he recovers soon, thanks for the heads up

[14:02:20.0617] <ljharb>
every internal slot that has observably different behavior, i suppose

[14:02:35.0818] <Mathieu Hofman>
Anyway, I'd be happy with anything that allows anyone (spec or user code) to stop triggering sync code during Promise.resolve

[14:02:47.0438] <ljharb>
and luca's comment seems somewhat related, in that it relates to the overarching goal throughout ES6 of making DOM objects JS-implementable

[14:02:55.0190] <ljharb>
* and luca's comment seems somewhat related, in that it relates to the overarching committee goal throughout ES6 of making DOM objects JS-implementable

[14:03:17.0614] <bakkot>
I am very firmly convinced that the goal of making host things 100% doable in userland was a mistake

[14:03:27.0154] <bakkot>
that gave us Symbol.concatSpreadable and etc

[14:04:09.0117] <bakkot>
_mostly_ doable in userland is good but I think it's probably OK if you can't polyfill this particular behavior?

[14:04:27.0582] <ljharb>
i'm not personally invested in implementable in userland, fwiw

[14:04:27.0707] <bakkot>
like, people probably aren't going to start relying on being able to stick `.then` on your polyfilled webIDL thing

[14:04:39.0733] <ljharb>
are there no webIDL thenables?

[14:04:49.0190] <bakkot>
don't think so

[14:04:50.0423] <ljharb>
because being able to implement one of those seems important for engines implemented in JS?

[14:04:52.0670] <ljharb>
* because being able to implement one of those seems important for engines implemented in JS, if so

[14:04:53.0008] <James M Snell>
if it's not doable in JS then there are a ton of web platform APIs that node.js, deno, etc would have a difficult time implementing this for

[14:05:31.0721] <snek>
though engines implemented in js have their own object graph, so its kind of a moot point

[14:05:33.0287] <bakkot>
I think for node etc you could just have a built-in thing to mark objects as special in this way, and then mark them?

[14:05:46.0049] <bakkot>
as long as V8 exposes this as a bit you can set on an arbitrary object

[14:05:50.0234] <James M Snell>
Such built-in things become rather expensive from a perf cost

[14:06:11.0596] <bakkot>
hm, ok

[14:06:15.0143] <James M Snell>
anything that requires calling down into C++ becomes rather expensive in aggregate

[14:06:56.0408] <bakkot>
it could take a list of objects and just do a single call, if the concern is the number of times you cross the language barrier

[14:06:59.0176] <ljharb>
ones 100% implemented in JS yes, but not in eg node where they use JS to augment (and sometimes polyfill) standard features not implemented in JS

[14:07:06.0555] <shu>
do you need to mark objects often?

[14:07:06.0785] <Andreu Botella>
> <@jasnell:matrix.org> anything that requires calling down into C++ becomes rather expensive in aggregate

there's no reason V8 couldn't have a built-in that gives access to an object containing a lot of internal APIs that can be called from JS

[14:07:10.0049] <shu>
is it like, per instance?

[14:07:51.0182] <shu>
...why... would we do this?

[14:07:58.0526] <canadahonk>
fyi chairs I'm good to present math.clamp from now for scheduling

[14:08:03.0593] <James M Snell>
well, it's not *just* node.js itself. Also thinking about user-land provided polyfills of standardized apis 

[14:09:20.0407] <James M Snell>
at the very least, it seems we have consensus that there's a problem to address here. I think there's likely multiple ways to address it but I want to make sure we do not prematurely take JS polyfillability off the table

[14:10:00.0308] <canadahonk>
is it fine to do the login form twice or if not could someone dm the meeting link?

[14:10:31.0904] <bakkot>
how important do you think it is to be able to polyfill this specific weird behavior? because it feels not that important to me

[14:10:36.0615] <ljharb>
yes, it's fine to do it multiple times

[14:10:57.0415] <ljharb>
i mean hermes still needs to polyfill `Promise.resolve` for react native

[14:10:59.0804] <ljharb>
* i mean hermes still needs to polyfill `Promise.resolve` for react native, using JS

[14:11:18.0090] <James M Snell>
having experienced this issue before *with* a userland polyfilled implementation, I'd personally say it's important

[14:11:52.0607] <ljharb>
* i mean hermes still needs to polyfill `Promise.resolve` for react native, using JS, so they'd need it

[14:12:18.0242] <snek>
technically this does exist, there's a kitchen sink object called the "extras binding"

[14:12:33.0992] <James M Snell>
oh god, please don't expose this to users

[14:12:53.0505] <shu>
snek: for me it's like, can you, with a straight face, say a thing is intended to be a thenable? if not, it'd be nice if we disallowed it to be a thenable at a language level

[14:12:54.0785] <Chengzhong Wu>
it triggers an emotion to see "how important to be spec compliant" in a tc39 channel

[14:13:22.0074] <bakkot>
well like I don't think people should be trying to polyfill `document.all`

[14:13:25.0898] <bakkot>
the language has a lot of weird corners

[14:13:35.0622] <snek>
well with a straight face i would say that modules aren't intended to be thenable. but idk how many people agree with me on this

[14:13:37.0225] <ljharb>
(+1 that subclassing builtins was a mistake)

[14:14:04.0123] <bakkot>
I definitely agree but that ship has sailed

[14:14:08.0269] <bakkot>
we can't now make them not-thenable

[14:14:11.0590] <snek>
* well with a straight face i would say that modules aren't intended to be thenable. but idk how many people agree with me on this (well if anything, based on my original proposal being rejected, i know people don't agree with me)

[14:14:19.0329] <Ashley Claymore>
`.constructor.name.match(/promise|defer/i)`

[14:14:19.0530] <bakkot>
but we did for deferred namespace objects at least

[14:15:17.0239] <ljharb>
i'd love it if we used null proto more aggressively for new spec-created objects; it seems like it'd avoid a whole class of problems

[14:15:33.0105] <snek>
time to merge the `extends null` spec pr?

[14:16:10.0839] <rbuckton>
FYI on terminology, a "thenable" is any object with a `then` method, regardless as to whether it is a promise or matches the Promise/A+ specification. i.e., if `typeof x.then === "function"` it's a "thenable". Being a "thenable" doesn't make it Promise-like.

[14:16:40.0902] <snek>
i'm aware

[14:16:44.0003] <bakkot>
I want this but weren't there still unresolved questions?

[14:17:50.0722] <littledan>
yeah, the PR didn't work at all

[14:18:32.0019] <snek>
the pr /works/, people just don't agree on the behavior

[14:19:02.0497] <rbuckton>
I only mention it because I've been running afoul of developers making the wrong assumption, or assuming the meaning of "thenable" has changed over the years. I'm mostly making the point so it's on the record in the chat log.

[14:19:11.0379] <snek>
like we have a set of test cases (which you can read in the proposal), which delegates don't agree on the output of, or at least didn't last time it was brought up

[14:19:15.0325] <snek>
* like we have a set of test cases (which you can read in the pr), which delegates don't agree on the output of, or at least didn't last time it was brought up

[14:21:27.0706] <ljharb>
as i recall, the options atm are either:
1. `class extends null` not necessarily statically, but `super` is an error in what is syntactically a derived class
2. `class extends null` not necessarily statically, and `super` is a noop

(and i think also either option, but "only statically")

and i think both options had a number of folks whom received an "ick" from it

[14:22:05.0689] <ljharb>
* as i recall (disclaimer: i haven't read the PR in years), the options atm are either:

1. `class extends null` not necessarily statically, but `super` is an error in what is syntactically a derived class
2. `class extends null` not necessarily statically, and `super` is a noop

(and i think also either option, but "only statically")

and i think both options had a number of folks whom received an "ick" from it

[14:22:25.0970] <ljharb>
* as i recall (disclaimer: i haven't read the PR in years), the options atm are either:

1. `class extends null` not necessarily statically, but `super` is an error in what is syntactically a derived class
2. `class extends null` not necessarily statically, and `super` is a noop

(and i think also either option, but "only statically")

and i think each option had a number of folks whom received an "ick" from it

[14:23:02.0636] <nicolo-ribaudo>
Wow reading through that PR I really dislikes what some comments are proposing

[14:23:21.0844] <eemeli>
We're skipping the break?

[14:23:41.0528] <nicolo-ribaudo>
* Wow reading through that PR I really dislike what some comments are proposing

[14:24:01.0468] <ryzokuken>
the break is delayed

[14:24:11.0076] <ryzokuken>
we'll break for 30 at the end of this presentation

[14:24:18.0998] <nicolo-ribaudo>
Charis can you update the agenda item on tcq?

[14:24:35.0576] <ryzokuken>
done, thanks

[14:24:40.0299] <bakkot>
https://github.com/tc39/ecma262/pull/1321 is the `class extends null` PR

[14:24:46.0660] <bakkot>
in case anyone else wants to have opinions

[14:24:55.0419] <bakkot>
or clean it up and bring it back :D

[14:25:49.0474] <snek>
i'm happy to bring it back if people agree on something

[14:25:54.0496] <Rob Palmer>
(Personal opinion) Just going back to the Decorators browser stalemate of "willing-to-ship-but-not-be-first", it makes me worry a tiny bit about the quality of signal Stage 3 is sending to non-browsers.  If it gets unblocked, there's no worry.  If it remains blocked or gets demoted, we will have unfortunately transferred risk to TypeScript that has followed our process and shipped the proposal - which has been a major churn for users of the older version of TS Stage 1 Decorators.

[14:25:55.0769] <snek>
can't solve a paradox

[14:25:56.0766] <Rob Palmer>
  Maybe we could report on developer usage experience from Decorators TS to help inform/motivate browsers to begin shipping.

[14:26:47.0044] <snek>
well until they are open about why they're not shipping it, its kind of unclear what report they need, if any

[14:28:45.0090] <littledan>
This feature does not need to be a speedup to be useful, IMO. (Good to avoid false claims here though)

[14:29:24.0911] <bakkot>
I can't believe css shipped clamp in a different order than every other language

[14:29:32.0382] <bakkot>
that is such a bizarre developer-hostile decision

[14:30:02.0000] <snek>
i didn't know people put min after max

[14:30:06.0773] <bakkot>
is TabAtkins here, can we complain to him

[14:30:09.0445] <bakkot>
* is TabAtkins here, can we complain to them

[14:30:32.0186] <littledan>
CSS should have meeting minutes where they discussed this at some point...

[14:31:41.0942] <bakkot>
apparently a fairly common complaint https://github.com/w3c/csswg-drafts/issues/11427

[14:35:44.0320] <nicolo-ribaudo>
The minutes are at https://github.com/w3c/csswg-drafts/issues/2519#issuecomment-387803089. It seems like it was for alignment with a CSS function that ended up not actually existing (minmax with 3 arguments)

[14:35:57.0296] <bakkot>
uuuuuuuuuuuugh

[14:36:01.0133] <Michael Ficarra>
nice

[14:36:13.0651] <TabAtkins>
What up

[14:36:41.0817] <bakkot>
`clamp` has the wrong argument order, it is different from every other language, this probably means we can't have `Math.clamp`

[14:36:51.0104] <bakkot>
* css `clamp` has the wrong argument order, it is different from every other language, this probably means we can't have `Math.clamp`

[14:37:08.0516] <nicolo-ribaudo>
The question would be "does JS align with CSS, or with all the other non-web languages"

[14:37:09.0050] <snek>
the prior art used in this is painful

[14:37:14.0940] <TabAtkins>
As the issue says, there's both precedents

[14:37:34.0961] <shu>
i thought dbaron had adopted gen z slang but i see that `fr` is a unit :(

[14:38:56.0416] <nicolo-ribaudo>
`new Math.Clamper(min, max).clamp(value)`

[14:39:27.0462] <TabAtkins>
With hindsight, I agree the weight of precedent goes with val first

[14:39:37.0702] <ljharb>
`fr` fr

[14:39:50.0361] <ryzokuken>
`(new (new Math.ClamperFactory(min))(max)).clamp(val)`

[14:40:02.0541] <snek>
`NumberConstrainmentBuilder`

[14:40:12.0477] <ryzokuken>
problem solved

[14:40:20.0496] <ljharb>
don't forget the MathFactory

[14:40:32.0175] <kriskowal>
`BigMath`

[14:40:40.0899] <bakkot>
please take shitposting to tdz

[14:41:32.0299] <littledan>
I just don't think it's so useful to overthink this kind of thing

[14:41:41.0665] <littledan>
* I just don't think it's so useful to overthink this kind of thing (re sffc's comment)

[14:42:15.0682] <littledan>
hindsight? you just shipped this just now!

[14:42:29.0587] <littledan>
(anyway we've been there before)

[14:42:49.0817] <TabAtkins>
We resolved on it six years ago

[14:42:57.0987] <bakkot>
clamp is pretty old at this point https://developer.mozilla.org/en-US/docs/Web/CSS/clamp

[14:43:02.0479] <bakkot>
unfortunately...

[14:43:13.0820] <TabAtkins>
Anyway do the obvious thing in JS 

[14:43:32.0806] <TabAtkins>
Css round() looks nothing like Math.round either

[14:44:21.0722] <bakkot>
fair point!

[14:44:39.0387] <TabAtkins>
Really it's only on the simplest of cases (single argument, or all arguments semantically identical) that we match

[14:45:01.0690] <ljharb>
eemeli: only the ones that start with "to" :-p this one wouldn't

[14:45:31.0855] <eemeli>
It would still be a very radical change.

[14:45:50.0879] <TabAtkins>
Css even fixed JS's dumb mistake with mod() (but still shipped the bad behavior as rem())

[14:46:34.0834] <bakkot>
if we end up shipping rem with the other behavior that would be very funny

[14:46:47.0410] <ljharb>
i'm not sure it'd be "radical" - does anybody have the expectation that "all methods on a thing always return the same kind of thing"?

[14:46:48.0827] <TabAtkins>
I mean JS doesn't name either of them

[14:46:55.0288] <TabAtkins>
So that would be a self own 

[14:47:09.0316] <ljharb>
i'd expect people call one method, and don't know or care about the ones they aren't calling

[14:47:35.0664] <TabAtkins>
And I *did* do significant name research to settle on mod/rem as the name pair 

[14:49:01.0132] <bakkot>
someone used to push regularly for us to add those

[14:49:06.0247] <bakkot>
... possibly Brendan actually?

[14:50:31.0465] <TabAtkins>
We still should!

[14:51:11.0431] <snek>
Symbol.clamp

[14:51:15.0358] <snek>
* System.clamp

[14:51:33.0010] <ljharb>
sffc: being aligned on the motivation is for stage 1. are you objecting to that?

[14:51:33.0112] <eemeli>
Given that we already have `Math.min` and `Math.max`, I don't see how anything other than `Math.clamp` would be better.

[14:51:57.0936] <ljharb>
the main reason i see is that it'd also allow `BigInt.prototype.clamp`

[14:52:08.0942] <ljharb>
* the main reason i see is that it'd also allow `BigInt.prototype.clamp` (and i guess that it resolves the argument ordering question)

[14:52:11.0314] <TabAtkins>
Yeah please do Math.clamp(v, min, max), y'all

[14:52:30.0793] <ljharb>
what would the bigint clamp be then?

[14:52:39.0391] <bakkot>
`BigInt.clamp` 

[14:52:43.0590] <nicolo-ribaudo>
The reason I like a proposal for this is that there is a 50% chance to forget "when doing max(min(...), ...), I need to pass the min to max and the max to min". A built-in function for this is motivated if it makes it easier to pass the right number in the right place

[14:52:50.0634] <ljharb>
then y no `Number.clamp`?

[14:52:58.0768] <bakkot>
because Math is the namespace for the number stuff

[14:53:04.0216] <TabAtkins>
Oh, I'm not in the meeting at I didn't see the context. But yeah sure, BigInt.clamp()

[14:53:11.0262] <snek>
Math.clamp(number|bigint) pls

[14:53:13.0977] <TabAtkins>
And yeah, Math has precedent

[14:53:21.0697] <eemeli>
I think the question about clamping bigints needs to be answered simlutaneously with min() and max() for bigints.

[14:53:36.0922] <bakkot>
those also go on BigInt

[14:53:51.0581] <TabAtkins>
Or the "three bigint arguments" on Math. +1 to eemeli: 

[14:54:07.0348] <ljharb>
and in a world where we also have decimal, suddenly all the Math stuff "should" really be on Number, and Math is just weird legacy baggage?

[14:54:26.0381] <bakkot>
I think Number will always be privileged relative to any other numeric types

[14:54:27.0839] <snek>
are bigints not math

[14:54:29.0868] <bakkot>
so it is ok that it gets two namespaces

[14:54:38.0942] <littledan>
BigInts are not math

[14:54:45.0130] <bakkot>
re: `Math.max(bigint)`, https://github.com/tc39/proposal-bigint-math/issues/23#issuecomment-1275893064

[14:54:49.0548] <bakkot>
I think this is very compelling

[14:54:51.0322] <ljharb>
ah, but `3n + 4n` works

[14:55:00.0740] <bakkot>
> `1n + Math.max(...list)` will throw a TypeError if `list === []`

[14:55:46.0204] <snek>
1 + Math.max(...list) is -Infinity, is that more helpful in practice

[14:56:11.0321] <snek>
* 1 + Math.max(...list) is -Infinity, is that more helpful in practice (not that it isn't the correct thing to return)

[14:56:31.0321] <bakkot>
it's not necessarily more helpful but it is what your code is already designed for

[14:56:42.0098] <bakkot>
and unexpectedly getting a TypeError is pretty weird

[14:56:49.0264] <bakkot>
I don't like the return types of functions to depend on the types of their inputs

[14:56:57.0945] <bakkot>
* also, seperately, I don't like the return types of functions to depend on the types of their inputs

[14:57:01.0580] <bakkot>
* also, separately, I don't like the return types of functions to depend on the types of their inputs

[14:57:09.0138] <nicolo-ribaudo>
I did not mention it because throw-away objects are probably bad, but `Math.max(value, { min, max })` would also be a reasonable option

[14:57:12.0961] <nicolo-ribaudo>
* I did not mention it because throw-away objects are probably bad, but `Math.clamp(value, { min, max })` would also be a reasonable option

[14:57:23.0096] <snek>
but i think at a very high level if we want to continue to separate things out, prototype methods is a probably my preferred solution. cuz then `(a, b) => a.min(b)` works for any numeric types

[14:58:27.0948] <TabAtkins>
> <@nicolo-ribaudo:matrix.org> I did not mention it because throw-away objects are probably bad, but `Math.clamp(value, { min, max })` would also be a reasonable option

Note that the css clamp accepts "none" for its min/max arguments, so that would be a more consistent functionality

[14:59:01.0495] <snek>
this makes me wish again that js had named arguments, separate from option bags

[14:59:10.0095] <TabAtkins>
Allows you to optionally clamp either side without having to either branch your function name or supply infinity

[14:59:58.0147] <rbuckton>
`Math.BigInt.{ min, max, clamp, ...}` is always an option. It's a bit odd to have `Number`-related methods on `Math` but `BigInt` related methods on `BigInt`.

[15:00:00.0421] <eemeli>
Have we actually considered named arguments and dismissed them at some point?

[15:00:25.0589] <TabAtkins>
Yes, sorta

[15:00:34.0905] <TabAtkins>
It's fallen on syntax grounds

[15:01:08.0160] <rbuckton>
In the same vein, `Math.Decimal.{ min, max, clamp, ... }`...

[15:08:42.0087] <TabAtkins>
Specifically, the two obvious syntaxes are `foo(arg1: v)` and `foo(arg1=v)`, and both are problematic.

[15:09:47.0617] <Richard Gibson>
moar punctuation: `foo(arg1:: v)`

[15:09:47.0906] <rbuckton>
I thought it had fallen on "we already have `{ arg1: v }`" grounds

[15:10:56.0754] <rbuckton>
`foo(arg1=v)` definitely is, but why is `foo(arg1: v)` problematic? Something like `foo(arg1:= v)` would work too

[15:11:21.0048] <rbuckton>
Though in some languages, `:=` means "bind and initialize"

[15:11:25.0807] <TabAtkins>
while I was typing it i could recall what was bad about `arg:val`, actually

[15:11:30.0836] <TabAtkins>
* while I was typing it i couldn't recall what was bad about `arg:val`, actually

[15:11:43.0622] <TabAtkins>
i suspect it is just that object bags take the air out of the room

[15:13:03.0544] <rbuckton>
Except that they're extremely inefficient.

[15:13:13.0325] <TabAtkins>
oh yeah they're bad, i agree

[15:13:55.0008] <TabAtkins>
maybe `arg:val` was just becuas eof its nearness to the trinary operator being potentially confusing

[15:14:55.0785] <rbuckton>
C# has both `foo(arg1: x)` and `?:`, it's not especially confusing, IMO.

[15:15:09.0320] <Richard Gibson>
URL fragment directives use `:~:`; we can't do worse than that

[15:15:11.0689] <rbuckton>
Especially since arg binding can only happen at the start of an argument.

[15:16:56.0731] <rbuckton>
Named arguments was an issue that partial application ran up against. Partial application only wants to bind Argument positions, and `foo(x, { y: ? })` is not a valid Argument position, while `foo(x, y: ?)` would be.

[15:18:29.0188] <Ashley Claymore>
a little similar with parameter decorators, they don't work in the same vein for object-bag-as-named-argument-pattern

[15:20:47.0480] <eemeli>
I would find named arguments like `foo(arg: value)` to correspond rather well with the way we can already use `foo({ arg: value })`.

[15:21:46.0734] <TabAtkins>
yeah, it probably is the most natural syntax for js

[15:24:14.0563] <rbuckton>
I think the biggest issue with named arguments is that parameter names aren't preserved in the face of `.bind` and method replacement via decorators.

[15:25:07.0983] <TabAtkins>
i mean, they could be. it's unobservable right now.

[15:25:22.0213] <TabAtkins>
(source visibility doesn't contradict this)

[15:25:58.0099] <rbuckton>
`.bind` could. Decorators could not, not without additional reflection over the method being decorated and some way to dynamically define named arguments.

[15:27:18.0988] <TabAtkins>
tho Python gets by without having either of those preserve names, because it has *args and **kwargs

[15:27:49.0462] <bakkot>
named parameters working automatically (without opt-in from the callee) would break all minifiers which would be kind of a shame

[15:27:49.0577] <TabAtkins>
so a decorator can just take and pass `(*args, **kwargs)` and preserve the arg name beahvior

[15:28:12.0302] <littledan>
I want to repeat my request to the meeting organizers that we enable recording and publishing as a pattern for any presentation

[15:28:14.0549] <bakkot>
`arguments.named`

[15:28:32.0270] <littledan>
it is a very good practice, for transparency and inclusion

[15:28:43.0806] <littledan>
thank you Mark for bringing it in here

[15:29:05.0203] <bakkot>
fwiw I strongly dislike having any public recordings of my voice (though there is at least one now)

[15:29:15.0792] <bakkot>
but would feel somewhat awkward about personally opting out of recording my presentations every single time

[15:29:48.0483] <rbuckton>
for example:
```js
function ignore() {}
function dec(t, c) {
  return ignore
}
class C {
  @dec a(x) {}
  @dec b(y) {}
}
```
`a` and `b` both end up with the same function for the method.

[15:29:56.0222] <bakkot>
I guess we could have some practice of automatically overdubbing but that would be a lot more process

[15:29:59.0722] <kriskowal>
opt-in to record sgtm

[15:30:19.0814] <kriskowal>
opt-out to not-record sbtm

[15:30:33.0193] <rbuckton>
So yeah, named arguments would need to be passed along somehow.

[15:31:28.0641] <ljharb>
fwiw i am concerned about ephemeral spirited in-group discussion, or attempted whimsy in a slide deck, becoming like a conference talk that people can critique forever even as cultural standards shift

[15:31:40.0190] <ljharb>
* fwiw i am concerned about ephemeral spirited in-group discussion, or attempted whimsy spoken aloud, becoming like a conference talk that people can critique forever even as cultural standards shift

[15:31:50.0235] <ljharb>
* fwiw i am concerned about ephemeral spirited in-group discussion, or attempted whimsy spoken aloud, becoming like a conference talk that people can critique forever even as cultural standards shift. opt-in only covers that tho.

[15:32:30.0024] <ljharb>
* fwiw i am concerned about ephemeral spirited in-group discussion, or attempted whimsy spoken aloud, becoming like a conference talk that people can critique forever even as cultural standards shift. opt-in-only covers that tho.

[15:32:34.0603] <bakkot>
I don't think anyone was proposing recording the discussion, just the presentations

[15:32:44.0303] <littledan>
yes, this would be opt-in. (but generally I think the things which look bad in retrospect were already bad at the time.)

[15:33:53.0243] <kriskowal>
otoh, apologizing to forty people is tractable in a way that apologizing to everyone is not

[15:35:12.0410] <eemeli>
Yeah, that does make it sound like it'd break the web.

[15:35:29.0782] <bakkot>
well, not as we usually use the term

[15:36:09.0696] <bakkot>
but it would be pretty annoying for developers and also probably make all websites much larger eventually once the minifiers updated to preserve parameter names

[15:36:18.0027] <bakkot>
* but it would be pretty annoying for developers and also probably make all websites some amount larger eventually once the minifiers updated to preserve parameter names

[15:36:54.0925] <snek>
there are a lot of identifiers they have to preserve anyway

[15:37:10.0359] <Michael Ficarra>
there are?

[15:37:15.0830] <Michael Ficarra>
just `eval`

[15:37:17.0528] <Michael Ficarra>
what else?

[15:37:23.0331] <bakkot>
property names

[15:37:30.0676] <bakkot>
and options bag names

[15:37:34.0098] <Michael Ficarra>
those aren't identifiers, get out of here

[15:38:00.0774] <snek>
🤨 https://gc.gy/d5e67b97-d268-455e-8e3c-9d99b62e7208.png

[15:38:13.0641] <snek>
* 🤨 https://gc.gy/20c632fb-3230-4795-babd-ed57b11c0b22.png

[15:38:35.0092] <bakkot>
IdentifierName is, to be fair, technically not Identifier

[15:39:50.0016] <rbuckton>
imports from packages not bundled, exports exposed to end users, globals

[15:53:40.0713] <littledan>
FWIW I wouldn't mind normative text, requiring that hosts respect the immutability of immutability array buffers (but the assert reading makes sense too)

[15:58:14.0667] <bakkot>
I would probably do something like

> NOTE: Because canonical numeric index properties of a TypedArray backed by an immutable ArrayBuffer are nonconfigurable and nonwritable, the [essential object invariants](link goes here) mean that hosts are prohibited from modifying the values in an immutable ArrayBuffer by any means.

[15:58:36.0973] <waldemar>
If an assert failure makes the spec normatively incorrect, then an assert cannot be informative. Informative text cannot make a spec inconsistent.

[15:59:05.0961] <bakkot>
Why not?

[15:59:13.0391] <littledan>
but, it's text that implies no normative requirements on implementations


2025-02-19
[16:00:07.0645] <waldemar>
I just stated the reason. The definition of "informative" is any text that can be removed without affecting the normative parts of the spec.

[16:00:34.0032] <waldemar>
An assert doesn't fall into that category if it can make a spec normatively inconsistent.

[16:00:34.0749] <bakkot>
Informative text being incorrect seems like it definitionally means the spec is inconsistent.

[16:00:52.0713] <shu>
and assert failure does not make the spec normatively incorrect, it makes it incoherent. incorrect/correct as a category doesn't even arise because it's malformed

[16:01:14.0868] <littledan>
this was very fast advancement for such a significant proposal

[16:01:25.0136] <rbuckton>
An Assertion is a statement that the asserted condition is the only possible state based on how the algorithm is used elsewhere in the specification. It is essentially informative because its absence would have no impact on the spec itself, so long as the spec is coherent.

[16:01:27.0226] <littledan>
(I think that's a good thing -- we're able to act efficiently when it's a good idea)

[16:01:34.0438] <waldemar>
Incorrect = malformed in my comment above.

[16:01:48.0598] <shu>
i see, well, its removal still doesn't affect the malformedness

[16:01:58.0280] <shu>
the spec remains malformed if the only removal is the assert

[16:02:17.0078] <waldemar>
Yes, it does, because the spec might become well-formed with removal of asserts.

[16:02:57.0475] <littledan>
interestingly, the C++ standards committee is currently working through a similar epistemological debate, but at the level of assertions in source code -- should they execute? I heard they decided that the mode is determined by compiler flags (...a very different language philosophy from ours)

[16:03:09.0689] <littledan>
* interestingly, the C++ standards committee is currently working through a similar epistemological debate, but at the level of contracts in source code -- should they execute? I heard they decided that the mode is determined by compiler flags (...a very different language philosophy from ours)

[16:03:32.0467] <James M Snell>
excited to see immutable arraybuffers advancing. There are definitely a number of web API specs that will need to be updated to account for them. I mentioned Web Crypto crypto.randomValues() but BYOB ReadableStream is the other big one. That will need to be updated to reject immutable buffers on reader.read(buf). 

[16:03:45.0689] <canadahonk>
I plan to use compiler flags for whether to include spec asserts or not (I have none currently)

[16:04:21.0912] <James M Snell>
TextEncode encodeInto is another

[16:05:01.0699] <shu>
i guess the nuance here is the assert tells a story about the intended property of the spec. if it doesn't hold, we say the spec is malformed in the sense that the intention doesn't hold. it could be brought back into well-formedness by changing the intent (which is necessarily not reflectable within the text, only tacit). more often, we don't change the intention doesn't change, and it turns out the there is a bug in the spec

[16:05:19.0318] <shu>
* i guess the nuance here is the assert tells a story about the intended property of the spec. if it doesn't hold, we say the spec is malformed in the sense that the intention doesn't hold. it could be brought back into well-formedness by changing the intent (which is necessarily not reflectable within the text, only tacit). more often, we don't change the intention, and it turns out the there is a bug in the spec

[16:05:26.0834] <shu>
* i guess the nuance here is the assert tells a story about the intended property of the spec. if it doesn't hold, we say the spec is malformed in the sense that the intention doesn't hold. it could be brought back into well-formedness by changing the intent (which is necessarily not reflectable within the text, only tacit). more often, we don't change the intention, and it turns out there is a bug in the spec

[16:06:11.0200] <bakkot>
those fall out to SetValueInBuffer, so probably the fix is to update WebIDL to do something else? or make SetValueInBuffer fallible, though that would be a shame

[16:06:17.0622] <bakkot>
https://webidl.spec.whatwg.org/#arraybuffer-write is the relevant thing I think

[16:06:29.0249] <bakkot>
but we definitely need tests as well

[16:06:53.0979] <littledan>
I hope web integration can look into where immutable arraybuffers can be a benefit in some cases, e.g., by avoiding certain cloning when used.

[16:07:03.0513] <shu>
yes, WebIDL is good to call out to see how they want to go

[16:07:13.0279] <shu>
maybe they want an attribute to require buffer sources to be immutable

[16:07:39.0586] <bakkot>
also there are places which take a buffer as an argument and they do a defensive copy

[16:07:42.0969] <bakkot>
and should be updated to not do that

[16:08:16.0689] <shu>
though that's... mostly fine

[16:08:20.0609] <shu>
you can just as-if that away

[16:08:23.0590] <snek>
if an immutable arraybuffer can't be detached, copying it can just be not-copying it

[16:08:28.0785] <snek>
* if an immutable arraybuffer can't be detached, copying it can just be implemented as not-copying it

[16:08:38.0855] <TabAtkins>
Like I said, Python gets by without this happening explicitly, because it has *args and **kwargs, and it's common practice for decorators to make the wrapper function they return take `(*args, **kwargs)` and then call the inner function with the same. That preserves passed function names, without needing the runtime to actually track function names across decorator boundaries. We'd need to add the same to JS, I think, to do named args.

[16:09:10.0211] <littledan>
yes, I think this is important. Even if it's formally just an editorial change, calling out in various specs where they can avoid work in the case of immutable ArrayBuffers makes it more likely that browsers will implement the optimization.

[16:09:28.0948] <bakkot>
I think probably this consists of finding the places which refer to https://webidl.spec.whatwg.org/#dfn-get-buffer-source-copy and updating them

[16:09:31.0115] <rbuckton>
Python also has explicit syntax in the parameter list to denote named vs positional arguments

[16:09:34.0681] <shu>
also agreed there. the amount of as-if optimizations happening on the web spec side is surprisingly little, compared to JS algorithms

[16:09:58.0386] <littledan>
right, people are more likely to implement line-by-line there

[16:10:02.0691] <TabAtkins>
only recently (by default, all args are passable by both index and name), and that doesn't affect the pattern I mentioned anyway

[16:10:33.0961] <TabAtkins>
(but I do think we could apply Python's lessons and go ahead and add "index only" and "name only" arglist section, like they do)

[16:10:48.0682] <kriskowal>
As much as I love this feature of Python when writing Python, I think I would prefer to maintain JavaScript’s rustic aesthetic, rather than rewalk the path to realizing Python needed a delimiter between positional arguments and positional arguments that are eligible to be interpreted as kwargs.

[16:11:59.0174] <TabAtkins>
sure, JS having *just* index-only and name-only is a potential future I think woudl be okay, and means there would be a syntax opt-in for named args so minifiers wouldn't need to change by default

[16:12:20.0619] <TabAtkins>
(you'd have to write `function foo(posarg, **, kwarg1, kwarg2)`)

[16:12:24.0568] <TabAtkins>
or similar

[16:13:56.0974] <kriskowal>
I find it clearer to continue `function foo(posarg, {kwarg1, kwarg2} = {})`.

[16:14:19.0192] <kriskowal>
Given the degree of difference in practice.

[16:14:48.0333] <TabAtkins>
and that's the exact argument that's blocked it in the past ^_^

[16:16:20.0359] <littledan>
it's kind of annoying that keyword arguments have to take place at a particular indexed position... makes it harder to add positional arguments over time, but maybe that's OK.

[16:16:42.0420] <littledan>
but I'm not sure whether it'd be worth it to introduce a whole other named argument system

[16:17:00.0473] <littledan>
just seems like a lot of work

[16:17:08.0918] <Jesse (TC39 🇺🇸)>
`function foo(posarg1 ；{kwarg1, kwarg2} = {} ；posarg2)`

[16:17:47.0037] <TabAtkins>
as has been stated, the lack of named arguments is a minor blocker in a number of dimensions, but it's only a very minor improvement in the base case, so it's harder to argue for since the extra stuff can be dismissed more easily.

[16:19:56.0891] <Erik Marks>
This is a conspiracy by Big ESLint to add more rules to ESLint

[16:20:16.0324] <ljharb>
hey who told you about big eslint

[16:21:03.0657] <Jesse (TC39 🇺🇸)>
for fans only: look again at those semicolons

[16:21:32.0731] <bakkot>
fun fact `for` is a valid function name

[16:21:58.0087] <bakkot>
`function for(x; y=y+1; z) {}`

[16:22:11.0408] <nicolo-ribaudo>
Which JavaScript are you talking about

[16:22:42.0528] <bakkot>
jesse's thing above

[16:22:53.0485] <bakkot>
the `function foo(posarg1 ；{kwarg1, kwarg2} = {} ；posarg2)` one

[16:23:00.0368] <ljharb>
`const f = { for() {} }['for'];` :-P but `function for() {}` is a syntax error

[16:23:30.0620] <snek>
wrong javascript

[16:23:33.0522] <bakkot>
ugh

[16:23:44.0073] <bakkot>
yeah it needs to be a method not a declaration

[16:23:46.0820] <Ashley Claymore>
```
for(of of of);
```

[16:23:47.0315] <bakkot>
I always get that wrong

[16:24:35.0049] <snek>
this is one thing that really bothers me about rust, let me name fields `if` and `return` and such

[16:24:43.0754] <bakkot>
```
class X {
  for(x; y=y+1; z) {}
}
```

[16:24:55.0427] <snek>
not being able to have a field named `type` is enormously annoying. everyone uses `typ` or `r#type`

[16:25:27.0949] <bakkot>
I think that sailed once `await` became an operator which is indistinguishable from property access

[16:25:44.0507] <snek>
i love it and i hate it

[16:26:02.0206] <Richard Gibson>
feedback welcome: https://github.com/tc39/proposal-immutable-arraybuffer/pull/44

[16:26:04.0078] <bakkot>
it's grown on me

[16:32:36.0750] <bakkot>
waldemar re: "ToString is not unique" the spec does allow the last digit to vary, but I'm not sure if any implementations actually differ

[16:32:49.0225] <bakkot>
I think we might be able to fully specify it and thereby resolve that specific issue

[16:33:28.0170] <shu>
is the goal here round-tripping a string representation? and the thing that's stopping people from relying on that because we have some leeway technically?

[16:33:36.0534] <shu>
* is the goal here round-tripping a string representation? and the thing that's stopping people from relying on that is because we have some leeway technically?

[16:34:13.0943] <snek>
it sounds like the goal is "can this string be represented as a number" but semantic misunderstanding or disagreement about what "can be represented" means

[16:34:51.0032] <waldemar>
The problem here is that it's impossible to define a Number-to-String conversion such that the resulting string satisfies isSafeNumeric

[16:34:54.0293] <shu>
yeah, if the "can this be represented" means mathematical value that is... not useful

[16:35:36.0712] <Michael Ficarra>
oh I remember what I wanted to say: it seems inconsistent to say that larger integral values are not "safe" for this purpose

[16:35:45.0678] <Michael Ficarra>
doesn't make any sense

[16:36:37.0063] <littledan>
these sound like reasons to iterate on the definition (significantly) and maybe add a number-to-string-safe operation, but it feels like the stated motivations hold

[16:36:44.0629] <bakkot>
Is it? I think if our ToString fully specified the last digit it would work. The spec previously had a bad definition of isSafeNumeric but under the `MV(string) = MV(ToString(ToNumber(string))` I think it's coherent? Or at least the obvious examples like 0.1 don't fail.

[16:37:28.0946] <Michael Ficarra>
> <@devsnek:matrix.org> it sounds like the goal is "can this string be represented as a number" but semantic misunderstanding or disagreement about what "can be represented" means

yeah I think a lot of lay-people think "can be represented" means "the float represents this number only", which... just isn't the case

[16:37:32.0686] <bakkot>
It is very specific to our specific ToString but afaict that's what they're asking for

[16:37:53.0497] <littledan>
oh! yes, that didn't occur to me

[16:38:04.0692] <waldemar>
The definition of MAX_SAFE_INTEGER is that it's the largest Number x such that x+1 is representable exactly. But Number("0.00000000000000000000000000000025") + 1 is 1, while "0.00000000000000000000000000000025" is considered "safe" by this.

[16:38:11.0109] <Michael Ficarra>
> <@littledan:matrix.org> these sound like reasons to iterate on the definition (significantly) and maybe add a number-to-string-safe operation, but it feels like the stated motivations hold

I think the motivations are so confused, it's hard to say whether they hold or not

[16:38:51.0752] <littledan>
well, I wonder what we should do about the problem space (floats are confusing with respect to value-preserving conversion to/from string)

[16:39:22.0075] <kriskowal>
I would want this problem to be solved with a bank of functions that apply to specific number domains, e.g., `String.representsSafeInteger`, `String.representsSafeNumber`, `String.representsSafeBigInt`, which is less forgiving that the corresponding constructor or parse functions.

[16:39:33.0095] <Michael Ficarra>
> <@littledan:matrix.org> well, I wonder what we should do about the problem space (floats are confusing with respect to value-preserving conversion to/from string)

there's probably interesting things to think about here, but I don't yet see a specific problem being identified

[16:39:36.0160] <bakkot>
oh, yes, I think that conflating this with MAX_SAFE_INTEGER is just incoherent and that part of the proposal should be removed

[16:39:46.0346] <waldemar>
An example that fails: 10000000000000000 cannot be converted to any string for which isSafeNumeric, as defined in the presentation, returns true.

[16:39:48.0588] <littledan>
programmers definitely don't tend to think about floats as a range of underlying reals, even if that's the most sensible way to understand them. The MV tends to correspond more closely to the intuition, I think

[16:39:49.0464] <bakkot>
at least as I understand the proposal it is strictly about round-tripping values, not about doing arithmetic on them

[16:40:49.0586] <ljharb>
`+String(10000000000000000) === 10000000000000000` is true, am i missing some zeroes?

[16:41:08.0636] <ljharb>
i 100% agree that most programmers think about numerical syntax as if they're mathematical values

[16:41:10.0051] <rbuckton>
`string === ToString(ToNumber(string))` isn't the same as `MV(string) === MV(ToString(ToNumber(string)))` given that `MV("1.0")` and `MV("1.00")`  are the same mathematical values but different strings?

[16:41:16.0295] <bakkot>
`10000000000000000 > Number.MAX_SAFE_INTEGER`

[16:41:37.0759] <ljharb>
aha, that's a fair point, decimal/trailing zero normalization, as well as leading zeroes, would be different

[16:41:48.0839] <ljharb>
is that the problem statement here, dealing with those kinds of things?

[16:41:53.0022] <rbuckton>
I think the `MV` is to handle that normalization.

[16:42:02.0210] <snek>
this is likely why they reached for MV, but MV is not exactly that

[16:43:34.0236] <rbuckton>
I assume the goal of `isSafeNumeric` is to validate that the input string can be accurately represented as a `Number` without loss? It can probably be specified more directly.

[16:43:49.0185] <Richard Gibson>
I feel like this is missing a problem statement that differentiates it from https://xkcd.com/927/

[16:43:52.0436] <shu>
we're debating what the champion considers "without loss"

[16:43:57.0738] <waldemar>
When printing a Number into a string that satisfies isSafeNumeric you also have the issue of what to print for things like 1e40 or 1e-30, since this thing rejects exponential notation.

[16:44:12.0146] <shu>
because as strictly read, 0.1 fails (as do 0.2, 0.3 etc)

[16:44:25.0124] <bakkot>
no longer true

[16:44:27.0552] <Jesse (TC39 🇺🇸)>
I wonder if the use cases for this proposal are basically covered by decimal, in that one would just use decimals rather than numbers, but guarded (possibly many times) with `Number.isSafeNumeric`

[16:44:28.0121] <bakkot>
that was true but they fixed it

[16:44:33.0409] <shu>
oh how did they fix it?

[16:44:41.0133] <bakkot>
it's the thing on the screen

[16:44:43.0373] <Michael Ficarra>
see the current slide

[16:44:50.0499] <bakkot>
`MV(string) = MV(ToString(ToNumber(string))`

[16:44:51.0670] <shu>
ah

[16:44:55.0148] <bakkot>
that passes for the string `"0.1"`

[16:45:13.0438] <shu>
yeah then i'm back to jordan's question

[16:45:18.0815] <Michael Ficarra>
I just don't see what passing that is *useful* for

[16:45:19.0716] <shu>
why not do the string roundtripping...?

[16:46:26.0145] <bakkot>
well, consider the input string ".00000000000000000000001"

[16:46:46.0809] <canadahonk>
import attributes has been merged into the spec 🎉 (https://github.com/tc39/ecma262/pull/3057)

[16:47:13.0971] <snek>
its really hard to propose any particular behavior without understanding the intention more

[16:47:35.0646] <ljharb>
true, if you accept inconsistently formatted strings as input, then doing the normalization yourself is hard

[16:47:36.0401] <bakkot>
".00000000000000000000001" toStrings to `1e-23` so it does not satisfy `string === ToString(ToNumber(string)`

[16:48:07.0014] <ljharb>
* ~true, if you accept inconsistently formatted strings as input, then doing the normalization yourself is hard~ oh you weren't talking about the leading zero, nvm

[16:48:07.0479] <shu>
i see, thanks

[16:49:07.0133] <bakkot>
that said if you reject `"1e-23"` as input I'm not sure how you're supposed to produce values which are accepted by this

[16:49:10.0250] <bakkot>
I guess `toFixed`?

[16:49:47.0810] <Michael Ficarra>
> <@canadahonk:matrix.org> import attributes has been merged into the spec 🎉 (https://github.com/tc39/ecma262/pull/3057)

JSON modules incoming

[16:49:53.0183] <bakkot>
though it's hard to know how many digits to use

[16:49:58.0522] <shu>
so the thing i heard was an app would choose to represent input as a double, or to use a userland library. that seems kinda wild to me

[16:50:26.0989] <shu>
to choose representation at runtime like that, given floating point arithmetic

[16:53:28.0111] <shu>
i... don't know how to disentangle that problem statement from "i wish we didn't have floats"

[16:53:35.0483] <rbuckton>
Michael Ficarra: Not when validating input

[16:54:18.0790] <Chris de Almeida>
did Michael Ficarra press the forbidden button?

[16:54:51.0274] <Michael Saboff>
He jumped ahead, is that what the forbidden button does?

[16:55:18.0191] <Chris de Almeida>
`I'm done speaking` is the forbidden button.  otherwise I don't know how the queue jumped

[16:55:20.0733] <Michael Ficarra>
I think he means as if you did the maths on reals

[16:56:37.0280] <Michael Saboff>
Chris de Almeida: Note that I don’t have the forbidden button on my TCQ page.

[16:56:44.0007] <snek>
possible tg5 topic: understanding how ieee754 works

[16:56:52.0240] <Chris de Almeida>
you do if you're currently the one on the queue

[16:57:13.0763] <Chris de Almeida>
meaning 'Speaking`

[16:57:18.0368] <Chris de Almeida>
* meaning `Speaking\`

[16:57:24.0269] <Chris de Almeida>
* meaning `Speaking`

[16:57:36.0376] <Michael Saboff>
> <@softwarechris:matrix.org> you do if you're currently the one on the queue

Should I press it 😏

[16:57:51.0875] <Erik Marks>
Why is the button forbidden?

[16:57:57.0014] <rbuckton>
Slide 4 seems like the clearest example to me. `0.1234567890123456789` cannot be accurately represented in `Number` as it truncates to `0.123456789012345678`. Similarly, `9007199254740993` cannot be represented.

[16:57:58.0026] <Michael Ficarra>
I'm about to adblock the button

[16:58:19.0423] <shu>
rbuckton: suppose you can accurately represent something. what do you do with that number then?

[16:58:19.0580] <Michael Ficarra>
assuming Chrome still permits me to do that

[16:58:30.0091] <shu>
or i suppose, what do you do with that string

[16:58:47.0623] <nicolo-ribaudo>
There is a race condition between you pressing it and the chairs pressing it for you. If the speed at which the chair's signal to stop pressing travels from their eyes to their brain is slower than the hand movement, they are going to press it for the person after

[16:58:48.0505] <Michael Ficarra>
> <@rbuckton:matrix.org> Slide 4 seems like the clearest example to me. `0.1234567890123456789` cannot be accurately represented in `Number` as it truncates to `0.123456789012345678`. Similarly, `9007199254740993` cannot be represented.

see snek's comment above about what "can be represented" means

[16:58:57.0673] <rbuckton>
For me, if it can be accurately represented, the function returns true. If it can't you inform the user (hence the use case for input validation)

[16:59:10.0995] <nicolo-ribaudo>
* There is a race condition between you pressing it and the chairs pressing it for you. If the speed at which the chair's neurons signal to stop pressing travels from their eyes to their brain is slower than the hand movement, they are going to press it for the person after

[16:59:37.0175] <shu>
if it returns true, what do you do with the input?

[17:00:08.0276] <rbuckton>
A better approach, were we to keep the button, would be to just notify the chair that the user is finished.

[17:00:19.0030] <littledan>
Should we do breakout sessions at the end of the meeting? https://github.com/tc39/Reflector/issues/552

[17:00:50.0604] <shu>
would it be possible to have AV support for each breakout session for remote attendees?

[17:00:58.0827] <rbuckton>
You use it? Beyond validating the input, its up to the developer to determine if it can then be safely used with other mathematical operations.

[17:01:06.0963] <littledan>
Yeah, we should be able to do that

[17:01:18.0817] <shu>
i am highly skeptical of that claim

[17:01:21.0444] <littledan>
but we'd probably keep note-taking informal

[17:03:24.0609] <rbuckton>
It can be used for relational comparison at the least, and serialized via JSON. 

[17:03:49.0207] <Jesse (TC39 🇺🇸)>
I think the challenge is that you're stuck in the binary64 world; stuck in that world, things are safe and if you say things aren't safe, you have no recourse to a safe alternative

[17:04:15.0181] <Andreu Botella>
please everyone take a look at the transcription if you have time

[17:04:33.0655] <Andreu Botella>
at some points I was the only one helping with the notes, and I definitely missed a lot of stuff at various points

[17:06:03.0235] <Ashley Claymore>
thanks Andreu Botella !

[17:07:47.0418] <Chris de Almeida>
thank you for your help!  if you ever find that we are not keeping up with the notes properly, please raise a `Point of Order`, so we can pause to rectify 🙏

[17:21:43.0029] <Chris de Almeida>
many thanks to our note takers today 👏👏👏👏👏👏

Andreu Botella
Daniel Ehrenberg
Jesse Alama
Linus Groh
Oliver Medhurst
Shane Carr


[22:17:13.0018] <bakkot>
littledan or whoever else is interested: here's my doc for avoiding allocations in engines for the iterator protocol https://docs.google.com/document/d/1M5S-u3N3vQkVBGFCoaYt_ABPGl0EW16QQrvDBaY2FiE/edit?tab=t.0

[00:55:46.0169] <eemeli>
I missed the isSafeNumeric discussion due to being asleep at the time. If it gets a continuation, it'd be nice if it was earlier rather than later, but that's of course unlikely (mini-rant: For the last few years 4/6 TC39 meetings have been on North American timezones, with 2/6 on Pacific Time. This is not friendly to remote-participation from Europe. It'd be a little bit friendlier if at least the remote PDT meeting was moved to EDT or even further East).

So posting the comments here that I'd have mentioned out loud had I been there:
- I'm generally positive on enabling a developer to verify that WYSIWYG applies to their numeric string.
- I'm not sure that "safe" is the right word here, though we do already have `Number.isSafeInteger`. I was thinking that "precise" or "canonical" could be more apt. The attachment point could also be different, as all of the pre-existing `Number.is*` functions require their input to be a number.
- This seems to correlate very highly with the goals of Decimal, which, if accepted, would also expand the set of strings for which JS can provide a "safe" numerical representation. That proposal is specifically looking to improve the representation of values coming from the real world or elsewhere, which seems like the same domain as this.

[01:04:49.0138] <rkirsling>
interesting. if it's not good for Europe then it'd literally only work for the Americas

[01:07:27.0976] <rkirsling>
* interesting. if it's not good for Europe then it'd literally only work for the Americas
(...though I think you just mean that the last couple hours don't work, which is much better than the entire meeting not working)

[01:44:44.0742] <eemeli>
I'm on Eastern European Time, and this week's meetings start at 20:00 and end at 03:00 for me. I'm used to having plenty of calls with folks on Pacific Time, but those are all scheduled for the morning there; TC39 calls take up the whole day. Comparatively, a meeting on US Eastern Time ends at my midnight, which is still bad but not as horrible.

I do understand the benefits of running the meetings at different times, and the ones in Europe or Asia are about as much fun for North American participants, but it's the regularity of having all of the virtual meetings on North American timezones _and_ having one of them on Pacific Time that seems a bit extra.

[07:08:47.0086] <mgaudet>
(Sorry for late reply just finally getting through backchannel) Sadly, no. In principle I wish they were, but public front end for this has yet to be resourced. We do have -much- public telemetry data (https://glam.telemetry.mozilla.org), but Use Counters specifically don't have a public front end (and I currently have to make my own dashboard for every use counter probe). 

[08:39:13.0834] <Michael Ficarra>
you know, one way we might be able to resolve the "safe numeric string" proposal is for the champion to give us a large list of sample strings and whether they are "safe" and we work backwards from there to try to figure out what they mean

[08:42:46.0540] <Chris de Almeida>
ZiJian Liu: ☝️

[09:59:32.0439] <littledan>
Please nominate breakout session topics here: https://github.com/tc39/Reflector/issues/552

[10:06:00.0795] <bakkot>
it feels somewhat odd to use decimal numbers with imperial units

[10:06:24.0763] <bakkot>
no one says "1.375 inches", it's always "1 3/8 inches"

[10:07:18.0783] <nicolo-ribaudo>
Are those fractions always with a power of 2 as the denominator?

[10:07:58.0203] <snek>
no, they switch to thousandths 

[10:08:15.0922] <littledan>
and sometimes they are thirds!

[10:09:02.0561] <snek>
i'm a huge fan of unit apis. durations and sizes especially in computers.

[10:09:10.0541] <bakkot>
usually powers of 2 though

[10:09:16.0507] <bakkot>
thousandths are mostly only used by machinists

[10:09:37.0282] <Chris de Almeida>
*machinidths

[10:09:37.0441] <ljharb>
i've seen thirds for volumes, but usually for lengths i think i only really see powers of 2?=

[10:09:37.0955] <bakkot>
a thousandth of an inch is pronounced a "thou" and is arguably its own unit

[10:09:38.0665] <ljharb>
* i've seen thirds for volumes, but usually for lengths i think i only really see powers of 2

[10:09:48.0704] <snek>
i mean no one uses 128ths of inches

[10:10:07.0487] <ljharb>
* i've seen thirds for volumes (like ⅓ cup, etc), but usually for lengths i think i only really see powers of 2

[10:14:41.0091] <canadahonk>
whoever else is doing notes y'all are killing it

[10:14:43.0080] <Michael Ficarra>
> <@bakkot:matrix.org> thousandths are mostly only used by machinists

not just used by machinists but also those who employ them, writing specs and tolerances for parts/materials

[10:14:59.0620] <canadahonk>
* whoever else is doing notes y'all are killing it ❤️

[10:15:37.0394] <littledan>
yeah the captioners this meeting are amazing

[10:15:42.0357] <Michael Saboff>
I have woodworking tools that are capable of 1/128” adjustments.

[10:16:36.0687] <Michael Saboff>
And I have used that precision.

[10:17:32.0660] <Rob Palmer>
For folk wanting to attend the SeattleJS Community event in-person on Thursday evening, please respond to [this poll about the NDA requirement.](https://github.com/tc39/Reflector/issues/547#issuecomment-2669412895)
❄️

I need to provide the count and names of delegates by midday today in order to stand a chance of getting an exemption.

[10:19:05.0779] <Michael Saboff>
For some specialties, they’d say 20 thousandths.  

[10:21:12.0091] <Michael Ficarra>
Measure seems more appropriate for 402

[10:21:51.0295] <littledan>
I wouldn't be opposed to this, but worth considering why Temporal should be in 262 and Measure in 402

[10:23:44.0877] <snek>
...i thought temporal was in 402

[10:23:54.0410] <shu>
what are the applications and developers who want to use measure?

[10:24:09.0219] <Michael Ficarra>
> <@devsnek:matrix.org> ...i thought temporal was in 402

Temporal is in a proposal

[10:24:23.0758] <snek>
yeah i mean a proposal for 402

[10:24:34.0861] <littledan>
it's been proposed for addition to 262. The editors should say something if they want it to land in 402 instead...

[10:24:38.0844] <canadahonk>
i thought it was split between basically what needs/doesn't need CLDR

[10:24:40.0694] <Duncan MacGregor>
Think I’ll need to catch up on this committee meeting tomorrow via the notes. Trying to attend remotely in a different time zone is just too tiring after a full day of work.

[10:24:42.0379] <shu>
it's kinda split, some data-dependent stuff _are_ in 402. bulk of it is in 262

[10:25:13.0230] <canadahonk>
at least with test262 there is a load of tests not in 402

[10:25:35.0575] <snek>
idk if this matches with what the presenters want but personally i'd love stuff like `Measure("hours", 2).into("milliseconds")` for passing to timers, or `Measure("megabytes", 3).into("bytes")` for allocating buffers. stuff like that

[10:25:56.0580] <shu>
why do you think that should be in the language?

[10:25:57.0813] <snek>
* idk if this matches with what the presenters want but personally i'd love stuff like `Measure("hours", 2).into("milliseconds")` for passing to timers, or `Measure("megabytes", 3).into("bytes")` for allocating buffers. stuff like that, pretty much always as program constants.

[10:26:15.0084] <bakkot>
time and bytes come up a lot

[10:26:19.0945] <bakkot>
meters rather less so

[10:26:23.0248] <Michael Ficarra>
> <@shuyuguo:matrix.org> why do you think that should be in the language?

it's a common need

[10:26:45.0194] <bakkot>
(also Temporal durations already do the time part of this)

[10:26:53.0882] <shu>
having constant number of bytes is a common need, having a general measure isn't is my hunch

[10:27:50.0921] <snek>
yeah i mean i'd be fine with Duration and Size classes rather than a generalized Measure thing. i'm not against Measure though, especially if there's some sort of cldr-ish data to feed in it i think its generally nice.

[10:28:17.0165] <ljharb>
would Measure be significantly more complex to spec or implement than Duration + Size?

[10:28:19.0068] <snek>
whether 'generally nice' meets everyone bar for new apis is 🤷

[10:28:29.0347] <snek>
* whether 'generally nice' meets everyone's bar for new apis is 🤷

[10:28:31.0157] <Michael Ficarra>
yeah unifying it is a nice way to organise things to allow for further expansion

[10:29:00.0725] <shu>
and what about units that JS apps are more likely to want to manipulate that are not physical units?

[10:29:41.0193] <nicolo-ribaudo>
I believe wether Measure supports custom units or not is an open question, so the answer to "what about that" is "well we could support it"

[10:29:55.0408] <Michael Ficarra>
I think rates are another common one: bytes/time or count/time

[10:30:36.0331] <shu>
what i mean is, those seem to be more useful units for the domain than grams and inches

[10:30:43.0192] <bakkot>
shu I feel like these would be reasonable things to put on the queue

[10:30:57.0650] <Chris de Almeida>
#tc39-decimal:matrix.org 

[10:36:05.0656] <Chris de Almeida>
gentle reminder to please not use the `I'm done speaking` button in TCQ

[10:40:42.0838] <nicolo-ribaudo>
Chris de Almeida Could you push my queue item to the bottom? Ideally to 5 mins before the end

[10:41:19.0689] <Richard Gibson>
https://github.com/unicode-org/cldr/blob/54e3b840473a9fd9abc747de485355338e4618e0/common/supplemental/units.xml#L149-L392

[10:42:27.0021] <Richard Gibson>
* cf. https://github.com/unicode-org/cldr/blob/54e3b840473a9fd9abc747de485355338e4618e0/common/supplemental/units.xml#L149-L392 and https://github.com/unicode-org/cldr/blob/54e3b840473a9fd9abc747de485355338e4618e0/common/supplemental/units.xml#L149-L392

[10:43:04.0209] <Richard Gibson>
* cf. CLDR [`unitConstants`](https://github.com/unicode-org/cldr/blob/54e3b840473a9fd9abc747de485355338e4618e0/common/supplemental/units.xml#L149-L392) and [`convertUnits`](https://github.com/unicode-org/cldr/blob/54e3b840473a9fd9abc747de485355338e4618e0/common/supplemental/units.xml#L149-L392)

[10:43:48.0054] <snek>
`<convertUnit source='pinch' baseUnit='cubic-meter' factor='gal_to_m3/128*128' systems="ussystem"/>`

[10:44:07.0795] <nicolo-ribaudo>
What operations precedence to they use there

[10:48:01.0891] <kriskowal>
The Measure/Amount presentation zooms out far enough that I can imagine that `new Amount("1/3", "cup")` is in the picture, assuming Amount is a generically typed tuple of magnitude, unit, and precision, where Amount does not imply any arithmetic, unit conversion, currency conversion, or even interpretation of the type.

[10:48:16.0597] <canadahonk>
not point of order but could someone else help with notes please :)

[10:48:22.0779] <kriskowal>
* The Measure/Amount presentation zooms out far enough that I can imagine that `new Amount("1/3", "cup")` is in the picture, assuming Amount is a generically typed tuple of magnitude, unit, and precision, where Amount does not imply any arithmetic, unit conversion, currency conversion, propagation of precision, or even interpretation of the type.

[10:48:44.0552] <Chengzhong Wu>
i can help

[10:48:49.0655] <kriskowal>
* The Measure/Amount presentation zooms out far enough that I can imagine that `new Amount("1/3", "cup")` is in the picture, assuming Amount is a generically typed tuple of magnitude, unit, and precision, where Amount does not imply any arithmetic, unit conversion, currency conversion, propagation of precision, or even interpretation of the composite types.

[10:49:54.0915] <canadahonk>
(fine now, thanks all)

[10:55:00.0609] <nicolo-ribaudo>
snek Remember that for Duration we have temporal, we would probably not support time units in Measure

[10:56:00.0550] <kriskowal>
That suggests Measure would not support Currency if there were Currency.

[10:56:14.0383] <kriskowal>
And I think that’d be sensible.

[10:56:31.0157] <snek>
yeah i guess. it could also just be defined in terms of temporal.duration for duration units.

[10:57:04.0409] <snek>
i don't feel super strongly about it other than just having these things exist in some form

[10:57:05.0844] <kriskowal>
That is “Conversion” doesn’t mean the same thing for Measures (including Duration) and Currencies.

[10:57:21.0987] <shu>
yeah we can't do currencies

[10:57:30.0089] <shu>
err, currency conversions

[10:57:59.0857] <bakkot>
I am struggling to think of times when you actually need units other than time and bytes in JS applications

[10:58:10.0886] <bakkot>
except obviously in specific applications like a recipe site or a house planner

[10:58:32.0583] <bakkot>
which, those feel like they are adequately met by a library

[10:58:38.0620] <ljharb>
the girl scout cookie inventory system site has "cases" and "packages", but that's specific, as you said

[10:58:51.0242] <snek>
yeah time & bytes are the only two things i use

[10:59:06.0178] <Erik Marks>
Has there been a proposal for something like `Currency`?

[10:59:15.0899] <shu>
right, to complete my thought: if the answer to my question of "what about these other common units that JS apps actually use, like bytes and px and whatever" is "userland code, custom units", my response to that is "then use a userland library"?

[10:59:29.0278] <snek>
what does `Currency` do? does it have more stuff than just being a decimal type?

[10:59:49.0664] <bakkot>
ties a currency to a number

[10:59:50.0857] <littledan>
I think a lot of the time, the units are just kept implicit, people use bare numbers, and there are bugs when units are accidentally confused/mixed. But I'm not sure what would lead to a design of Measure that would ensure actual uptake to avoid those bugs.

[10:59:53.0271] <ljharb>
there is something to be said for having a standard object type that can hold a value and an arbitrary unit, so those libraries can interop more cleanly

[11:00:20.0919] <shu>
i understand that in the abstract, which is why i want to see what people do today

[11:00:40.0249] <littledan>
in some way, this is analogous to how the most popular representation of decimal is strings, not any of the decimal libraries.

[11:00:56.0618] <snek>
i think at the very least ones like time, bytes, pixels have some motivation from being units that js/dom have standard library features using

[11:01:34.0182] <shu>
i agree, which is why if we have a concept of built-in units, i'd care more about those being present than grams and inches

[11:01:57.0396] <shu>
but it seemed like the champions weren't so interested in that

[11:02:01.0641] <littledan>
well, the idea is, units are arbitrary, un-interpreted strings; unit conversions may be better as a separate thing, as Eemeli proposed

[11:02:02.0291] <bakkot>
if I am correct that people mostly only need these when building a specific application like a recipe site, then I don't think you are likely to need interop between libraries

[11:02:02.0567] <snek>
yeah i think i can agree with that

[11:02:15.0960] <snek>
* yeah i think i can agree with that (to shu)

[11:02:52.0806] <James M Snell>
well, I think this discussion is motivation for limiting the unit that are baked into the language and *possibly* motivating a mechanism for allowing users to specify their own unit definitions. 

[11:03:33.0354] <James M Snell>
```
const myUnit = new Unit({ ...});
const measure = new Measure(1.234, { unit: myUnit });
```

[11:04:57.0937] <kriskowal>
shu: The Amount type for currencies at Agoric is a tuple of a “brand” for the currency and a value that can be a bigint, or even an array of serial numbers. We pair Amounts with a corresponding AmountMath. Amounts are very domain-specific.

[11:07:44.0206] <nicolo-ribaudo>
Those that mentioned weaker parts of the space carrying other parts (e.g. Michael Ficarra, but also others with similar words), what do you mean by "weak part" and "strong part"? The answer doesn't seem to be consistent across delegates

[11:07:48.0979] <nicolo-ribaudo>
* Those that mentioned weaker parts of the space carrying other parts (e.g. Michael Ficarra, but also others with similar words), what do you mean by "weak part" and "strong part"? The answer doesn't seem to be consistent across the committee

[11:08:04.0469] <waldemar>
cf.format(1e12) is '1M'?

[11:09:44.0035] <canadahonk>
fyi taking break from notes but I think others are already helping \o/

[11:10:04.0444] <Michael Ficarra>
> <@nicolo-ribaudo:matrix.org> Those that mentioned weaker parts of the space carrying other parts (e.g. Michael Ficarra, but also others with similar words), what do you mean by "weak part" and "strong part"? The answer doesn't seem to be consistent across the committee

like which parts do I feel are weak vs strong, or what do those words mean?

[11:10:11.0140] <nicolo-ribaudo>
Yeah

[11:10:29.0888] <Michael Ficarra>
uhh that was an either-or question @nicolo-ribaudo:matrix.org

[11:11:05.0592] <nicolo-ribaudo>
Ohh I thought you were asking what else would _my_ words mean 😛
Which parts are weak and which are strong

[11:11:59.0846] <Michael Ficarra>
I don't have an opinion on which parts are weak and which are strong, just that I don't want the strong one carrying the weak one

[11:15:39.0648] <justingrant>
FYI, for duration, the format used in `Temporal.Duration.p.toString` is the same format proposed by eemeli 's stable formatting proposal. This is probably assumed by everyone, but wasn't mentioned in the presentation so figured I'd note it here. 

[11:16:05.0227] <Michael Ficarra>
why are we not stopping the meeting for the PoO?

[11:16:07.0262] <nicolo-ribaudo>
Chris de Almeida I'll help with notes

[11:19:28.0894] <littledan>
I'd encourage people to yell out such points of order for help with notes

[11:22:26.0343] <snek>
why would it use "null" instead of "zxx" if its called "zxx" elsewhere

[11:22:36.0227] <snek>
(i ask this not knowing much about these apis in general)

[11:23:04.0049] <canadahonk>
add to tcq? seems fair to me but also don't know much

[11:23:15.0015] <nicolo-ribaudo>
Justin added it to TCQ

[11:29:06.0178] <TabAtkins>
> <@littledan:matrix.org> in some way, this is analogous to how the most popular representation of decimal is strings, not any of the decimal libraries.

I think there's a strong argument to be made that this is due to strings being built in and those libraries not being. When math is needed on this decimal strings, the most popular behavior is also to just do a float parse and perform the bath with ordinary Number, which is terrible, but it's there and the library isn't.

[11:29:36.0272] <James M Snell>
Using "null" feels just slightly off given the prevalence of `null` returns in web apis. I'd generally prefer the use of `zxx`

[11:29:37.0192] <TabAtkins>
And both of these work reasonably well *often enough* that the pressure to use a library is light

[11:29:50.0917] <littledan>
exactly. For the same reason, having Measure will encourage more usage of it. (But it's true, Decimal libraries seem to be more popular already than Measure ones)

[11:30:12.0409] <snek>
did someone clarify the reasoning for this

[11:30:46.0791] <littledan>
I imagine this might be because it's sort of a layering violation for us to define something in the locale space

[11:31:20.0149] <canadahonk>
my other guess is maybe webcompat where `zxx` already behaves some way but `null` previously threw?

[11:31:37.0819] <snek>
> zxx - non linguistic content, such as onomatopoeia (animal sounds)

[11:31:42.0461] <snek>
i guess zxx is overloaded

[11:32:35.0782] <James M Snell>
I can just imagine some weird intesectional edge case where someone accidentally ends up passing `null` because that's what another api returned and that's coerced into `'null'` when that was not the intention. Not a blocking case but a possible quirk of the approach

[11:34:43.0757] <littledan>
that's a very funny description -- spelled-out animal sounds are clearly localized :)

[11:36:06.0252] <Michael Ficarra>
> <@littledan:matrix.org> that's a very funny description -- spelled-out animal sounds are clearly localized :)

I bet a lot of people without much exposure to other cultures believe this though

[11:36:41.0217] <James M Snell>
that is until they visit france and the dogs start saying ouaf ouaf!

[11:36:49.0996] <Michael Ficarra>
in the same way lot of people think "there's exactly X continents" is a universal truth

[11:41:01.0504] <nicolo-ribaudo>
Waldemar already asked, but is it correct that cf.format(1e12) returns 1M?

[11:42:59.0694] <blickly>
> <@nicolo-ribaudo:matrix.org> Waldemar already asked, but is it correct that cf.format(1e12) returns 1M?

eemeli: no, it returns 1T

[11:43:02.0099] <Jesse (TC39 🇺🇸)>
hmm, I get "1,000,000,000,000"

[11:43:46.0614] <nicolo-ribaudo>
Richard Gibson: fyi, your mic volume is very low

[11:44:52.0338] <Jesse (TC39 🇺🇸)>
(oops, forgot the `"compact"` bit sorry)

[12:03:47.0718] <eemeli>
Yeah, sorry, that was a typo.

[13:13:08.0647] <ljharb>
so who makes the benchmarks?

[13:13:17.0206] <ljharb>
* so who makes the benchmarks, or decides which ones matter?

[13:13:42.0200] <littledan>
https://github.com/WebKit/Speedometer/blob/main/Governance.md

[13:14:26.0576] <Justin Ridgewell>
Is the main point of contention here whether this needs to be a getter/data prop?

[13:15:12.0595] <Justin Ridgewell>
Or is it because anything was added to a TC39 owned class?

[13:15:37.0353] <Justin Ridgewell>
Isn't this the same as one of the browsers adding a new API?

[13:16:14.0024] <ljharb>
adding a new API outside a standards process, yes

[13:16:28.0625] <ljharb>
in all such cases it's helpful to get broader input as early in the process as possible

[13:17:12.0829] <Justin Ridgewell>
But they add new APIs to the global all the time.

[13:17:20.0842] <ljharb>
new non-standard ones, all the time?

[13:17:35.0150] <Justin Ridgewell>
Not standardized here.

[13:17:36.0557] <ljharb>
if so, i would think that's something that should concern both tc39 and whatwg

[13:17:44.0338] <ljharb>
right, standardized *somewhere* tho

[13:17:57.0950] <nicolo-ribaudo>
It's common for browsers to ship APIs at the same time as creating the equivalent of a stage 1 proposal in w3c/whatwg

[13:18:17.0876] <ljharb>
there is a qualitative difference between something developed with multiple stakeholders, and something one private company's team unilaterally decides to do

[13:19:09.0330] <nicolo-ribaudo>
Or at least, for one of the browsers

[13:21:59.0417] <shu>
i recommend people who care about this follow intents emails on Chromium and Mozilla's email lists, and read STP notes for Safari

[13:22:18.0491] <shu>
* i recommend people who care about keeping abreast of all things that ship to follow intents emails on Chromium and Mozilla's email lists, and read STP notes for Safari

[13:22:24.0315] <Michael Ficarra>
> <@nicolo-ribaudo:matrix.org> It's common for browsers to ship APIs at the same time as creating the equivalent of a stage 1 proposal in w3c/whatwg

this sounds like a really problematic process

[13:22:25.0394] <ljharb>
i definitely try to do that, but that is a large firehose of information

[13:22:43.0496] <ljharb>
* i definitely try to do that, but that is a large firehose of information, and much of it is not relevant to javascript

[13:22:44.0395] <bakkot>
https://x.com/intenttoship

[13:23:07.0183] <bakkot>
https://x.com/search?q=from%3Aintenttoship%20capturestacktrace&src=recent_search_click

[13:23:16.0209] <nicolo-ribaudo>
(or https://bsky.app/profile/intenttoship.dev)

[13:23:23.0237] <snek>
whatwg standards don't follow the same model as tc39. tc39 honestly has something very special in terms of how much weight non-implementors have in the process.

[13:23:25.0696] <bakkot>
(you do have to read the notes for Safari since they're not split out)

[13:23:36.0821] <Michael Ficarra>
yeah there's soooo much CSS and other stuff I just don't want to hear about coming through the intents

[13:26:23.0344] <ljharb>
i'm glad it's rare. rare makes it notable and worth mentioning.

[13:27:47.0522] <bakkot>
`Function.prototype.caller` :D

[13:27:54.0726] <bakkot>
there's still a few non-standard things out there

[13:27:56.0428] <ljharb>
(v8 changing how captureStackTrace works a few years back was also notable)

[13:30:15.0865] <snek>
🫠 https://github.com/nodejs/node/blob/f6ce48636b08292baac4fd443399ab9972e1a69b/lib/internal/errors.js#L148

[13:32:16.0712] <Michael Ficarra>
oh fun, another use of `SetterThatIgnoresPrototypeProperties`

[13:32:24.0076] <Michael Ficarra>
I was hoping to forget that AO existed

[13:33:32.0069] <nicolo-ribaudo>
`SetNoOverrideMistake`

[13:33:59.0403] <bakkot>
that's this afternoon's topic

[13:36:05.0211] <bakkot>
speaking of non-standard features, https://github.com/tc39/proposal-regexp-legacy-features has been stage 3 for ~8 years

[13:36:15.0823] <bakkot>
I don't know if actually matches what browsers do

[13:36:21.0286] <bakkot>
or if there's tests

[13:36:35.0256] <nicolo-ribaudo>
> This does not reflect what the implementations do, but what the editor thinks to be the least bad thing they ought to do in order to maintain web compatibility.

[13:36:51.0858] <Michael Saboff>
bakkot: I was thinking about that proposal during the prior discussion.

[13:36:52.0593] <bakkot>
ah

[13:41:39.0028] <nicolo-ribaudo>
ljharb It'd be great to have a note in the spec text saying that the reason those accessors are so weird is web compat, like the one at https://tc39.es/ecma262/#sec-set-iterator.prototype.constructor

[13:41:57.0225] <ljharb>
bakkot: fwiw DOMException is a true Error now in the web, thanks to Error.isError, if that answers your question

[13:42:08.0975] <ljharb>
sgtm, a PR would be appreciated :-D

[13:42:39.0454] <nicolo-ribaudo>
Damn I hate when asking other people to do more work backfires

[13:44:27.0626] <littledan>
it's slightly different

[13:44:33.0778] <littledan>
I think there are

[13:45:44.0063] <littledan>
browsers have said that they find that proposal to be very low priority, but at least Mozilla said they'd review a patch for them. I hope we can eventually make a collective decision about the proposal's future, though people didn't seem to like that idea when I brought it up in a proposal sweep

[13:48:27.0370] <bakkot>
`(new DOMException).stack // undefined`

[13:48:33.0008] <bakkot>
is the intention to change this?

[13:48:42.0493] <bakkot>
(Firefox actually has a stack here)

[13:48:44.0880] <ljharb>
waldemar: ```
> Object.getOwnPropertyDescriptor(e, 'stack').get === Object.getOwnPropertyDescriptor(e2, 'stack').get
true
> Object.getOwnPropertyDescriptor(e, 'stack').get.x = 1
1
> Object.getOwnPropertyDescriptor(e2, 'stack').get.x
1
> 
```

[13:48:50.0608] <ljharb>
* waldemar: \`\`\`

> Object.getOwnPropertyDescriptor(e, 'stack').get === Object.getOwnPropertyDescriptor(e2, 'stack').get
> true
> Object.getOwnPropertyDescriptor(e, 'stack').get.x = 1
> 1
> Object.getOwnPropertyDescriptor(e2, 'stack').get.x
> 1
```

[13:48:59.0020] <ljharb>
* waldemar: 
```
> Object.getOwnPropertyDescriptor(e, 'stack').get === Object.getOwnPropertyDescriptor(e2, 'stack').get
> true
> Object.getOwnPropertyDescriptor(e, 'stack').get.x = 1
> 1
> Object.getOwnPropertyDescriptor(e2, 'stack').get.x
> 1

```

[13:49:22.0242] <ljharb>
it's implementation-defined, so while i'd expect them to have a stack, it's up to the browser what's in it

[13:49:31.0693] <bakkot>
well it's actually undefined in Chrome

[13:49:34.0204] <bakkot>
not a string

[13:49:47.0389] <ljharb>
it'd have to become an empty string, i think, yes, as currently specified

[13:50:02.0366] <bakkot>
sgtm but that will need WPT tests

[13:50:15.0894] <ljharb>
sounds good, i can probably write those

[13:52:13.0166] <ljharb>
* waldemar:

```
> const e = new Error(), e2 = new Error();
> Error.captureStackTrace(e);
> Error.captureStackTrace(e2);
> Object.getOwnPropertyDescriptor(e, 'stack').get === Object.getOwnPropertyDescriptor(e2, 'stack').get
> true
> Object.getOwnPropertyDescriptor(e, 'stack').get.x = 1
> 1
> Object.getOwnPropertyDescriptor(e2, 'stack').get.x
> 1
```

[13:56:45.0068] <shu>
bakkot: it's weirder

[13:56:46.0548] <shu>
https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/bindings/core/v8/v8_throw_dom_exception.cc;l=61;drc=8b7ec5d99ad2d76762011a50ed1c14d754e3ff5f

[13:56:50.0302] <shu>
like, it depends on how it's thrown

[13:57:27.0411] <bakkot>
nice.

[13:58:00.0042] <Chris de Almeida>
witchcraft!

[13:58:47.0969] <Andreu Botella>
This would be a WebIDL PR, not HTML

[13:59:19.0456] <bakkot>
I'm not sure it's actually a change to any of the specs

[13:59:26.0921] <bakkot>
it would need WPT changes

[13:59:36.0906] <bakkot>
but stacks for DOMExceptions aren't spec'd anywhere afaik

[13:59:51.0483] <bakkot>
and this would apply to DOMExceptions as written automatically

[14:00:08.0333] <shu>
that's more headwinds really

[14:00:27.0255] <shu>
unclear how much appetite there is if it requires significant blink/Gecko/non-JSC webkit-side work

[14:00:37.0601] <Andreu Botella>
> <@bakkot:matrix.org> but stacks for DOMExceptions aren't spec'd anywhere afaik

WebIDL says that if any implementations have a stack property on errors, they must have it in DOMException: https://webidl.spec.whatwg.org/#js-exceptions

[14:00:50.0054] <Andreu Botella>
the stack is also structured clone

[14:00:53.0273] <Andreu Botella>
 * the stack is also structured cloned

[14:00:56.0095] <bakkot>
ah

[14:00:57.0305] <bakkot>
well

[14:01:01.0231] <bakkot>
browsers are not doing that already

[14:01:09.0204] <bakkot>
* browsers are not (always) doing that already

[14:01:21.0753] <bakkot>
oh, and structured clone would definitely need changes

[14:01:28.0402] <bakkot>
* oh, and structured clone would definitely need changes, if it's cloning stacks

[14:01:51.0774] <shu>
yeah

[14:03:16.0622] <bakkot>
> User agents should attach a serialized representation of any interesting accompanying data which are not yet specified, notably the stack property, to serialized.



[14:03:22.0817] <bakkot>
... sure

[14:05:09.0876] <snek>
what are week numbers

[14:05:28.0135] <Michael Ficarra>
sometimes I think ecma262 is too informal, and then I see some of the other web specs

[14:06:18.0301] <bakkot>
https://en.wikipedia.org/wiki/Week#Numbering

[14:06:33.0414] <snek>
wild

[14:06:39.0010] <snek>
"first thursday of the year" just wild

[14:06:49.0433] <Jesse (TC39 🇺🇸)>
> <@devsnek:matrix.org> what are week numbers

spend a bit of time in continental Europe and you'll know

[14:06:56.0398] <bakkot>
scandanavian countries use them colloquially apparently

[14:07:21.0619] <Michael Ficarra>
timeshares in the US use them

[14:07:31.0592] <snek>
i guess amsterdam isn't european enough for this

[14:07:41.0995] <rekmarks>
Can confirm ubiquitous in Sweden

[14:07:55.0643] <nicolo-ribaudo>
Screenshot from our secret Igalia documents

[14:07:59.0590] <nicolo-ribaudo>
That's a week number

[14:08:02.0592] <nicolo-ribaudo>
We use it all the time

[14:08:53.0145] <Michael Ficarra>
> <@nicolo-ribaudo:matrix.org> Screenshot from our secret Igalia documents

hmm, what could this "...mpilers team" at Igalia be? 🤔

[14:08:53.0649] <Chris de Almeida>
a... weekref, if you will

[14:08:57.0358] <nicolo-ribaudo>
Also fun fuct we call out big company-wide meetings like TV series

[14:08:58.0420] <Chris de Almeida>
whoops, not TDZ

[14:09:05.0298] <nicolo-ribaudo>
The next one is S25E02

[14:10:00.0887] <canadahonk>
decompilers team

[14:10:40.0593] <bakkot>
I suspect I am not alone in having absolutely no opinions about minutia of week numbering

[14:19:11.0933] <shu>
https://chromestatus.com/metrics/feature/timeline/popularity/5209

[14:19:15.0858] <shu>
i can't believe it's not zero

[14:19:25.0022] <shu>
i want to find these sites and i want to talk to them

[14:19:48.0058] <Michael Ficarra>
it's looooow

[14:19:55.0126] <snek>
0.000007

[14:20:14.0559] <canadahonk>
%?

[14:20:21.0741] <canadahonk>
* %? yeah

[14:20:30.0182] <Michael Ficarra>
yeah so 2 more `e`s

[14:20:58.0372] <nicolo-ribaudo>
shu Why is it not showing sample websites?

[14:21:18.0151] <shu>
i have no idea

[14:21:19.0130] <bakkot>
I know at least some people are (or were) using stamping to attach data to arbitrary objects

[14:21:22.0933] <snek>
probably sample is too small

[14:21:23.0002] <bakkot>
because of weakmaps being slow

[14:21:27.0060] <bakkot>
so it's probably that

[14:21:35.0201] <shu>
i think it only shows sample websites by correlating the use counters with crawling of HTTP archive

[14:21:42.0233] <littledan>
the return override thing is simply the design of ES6 classes. I get annoyed ever time I hear it referred to as a "mistake".

[14:21:46.0734] <Rob Palmer>
Are we also going to ban non-extensible objects from being weakmap keys to preserve the original equivalence of private fields and weakmaps?

[14:21:47.0846] <shu>
if there are no sites in HTTP archive that has the counter, i don't think we record other data

[14:22:11.0352] <shu>
my understanding is no, mark is giving up on that equivalence

[14:22:17.0560] <littledan>
oh but we're talking about the set thing

[14:22:18.0425] <nicolo-ribaudo>
I believe the reason Mark is now confident with proposing this is that we already lost that equivalence due to the window proxy

[14:22:19.0490] <Jesse (TC39 🇺🇸)>
sounds like an argument for decimal: being able to reliably compute extremely unpopular features in tracking dashboards

[14:22:20.0673] <snek>
can you install private fields on symbol instances

[14:22:31.0521] <shu>
the deciding factor here is in-line vs out-of-line storage

[14:22:37.0700] <ljharb>
on boxed ones sure

[14:22:50.0669] <snek>
they don't need to be boxed to be weakmap keys

[14:22:56.0822] <littledan>
the code that broke with the inherited Set thing is an old version of lodash. It was unclear how to fix it.

[14:23:16.0973] <littledan>
Allen Wirfs-Brock apparently put in the inherited Set behavior on purpose, FWIW

[14:23:22.0978] <ljharb>
hm, "symbols as weakmap keys" did not consider that weakable was supposed to imply field-stampable

[14:23:36.0124] <littledan>
(none of the rest of us were able to understand his explanation for why it was a good idea, though)

[14:23:38.0445] <Ashley Claymore>
can't return primitives from constructor right

[14:24:57.0603] <Richard Gibson>
it's independent of classes, though...

[14:25:31.0419] <littledan>
Right, this Set inherited non-writable thing is separate, sorry for my confusion

[14:25:37.0415] <Ashley Claymore>
wasn't it a custom elements thing?

[14:25:43.0817] <Ashley Claymore>
for the upgrade

[14:26:09.0447] <littledan>
well, CE was an argument for it, but it was also just an instance of keeping things kinda similar to ES5 classes

[14:26:53.0082] <littledan>
I guess my annoyance comes from people coming across it first in the context of fields, but it's really not because of fields

[14:30:12.0273] <littledan>
permanent inheritance is referred to as "immutable prototype exotic object" in the spec FWIW

[14:31:47.0696] <bakkot>
I would kind of like "rationalizing the behavior of" some weird web thing to generally not be a motivation

[14:31:57.0322] <bakkot>
it's kind of nice if we get that because of some other thing that we want

[14:32:09.0072] <bakkot>
but should not really be a goal in itself

[14:32:38.0255] <littledan>
we did consider this unbundling when immutable prototype was introduced, but concluded the same at the time, that it's not worth it to unbundle

[14:33:18.0539] <littledan>
How are we going to investigate whether the carveout works?

[14:33:28.0055] <rekmarks>
When / in which proposal was immutable prototype introduced?

[14:33:30.0849] <nicolo-ribaudo>
I love seeing proposal that end up being "actually, it can be reduced by 80%"

[14:33:51.0487] <littledan>
This was a PR to fix a Proxy security risk which delayed its shipping

[14:35:04.0612] <littledan>
https://github.com/tc39/ecma262/pull/308

[14:35:51.0803] <rekmarks>
tyvm

[14:37:16.0888] <bakkot>
huh, TIL it was not always immutable

[14:37:38.0894] <Michael Ficarra>
I refuse to believe that is new information to you

[14:38:31.0413] <bakkot>
I barely have room to remember the horrors we currently have in the language; no way I'm remembering the few we've actually fixed

[14:40:23.0671] <littledan>
I'm pretty sure you were there. IIRC this was literally the first thing I got into the language.

[14:40:46.0231] <Michael Ficarra>
I think it might predate Kevin by a couple meetings

[14:41:17.0394] <Michael Ficarra>
still, that's no excuse 😛

[14:44:59.0972] <Chris de Almeida>
sorry, did someone get dropped off TCQ?  nicolo-ribaudo maybe?

[14:45:06.0135] <dminor>
I am going to drop from the call at the break, mgaudet will be representing SpiderMonkey (at least until he has to drop as well)

[14:45:13.0606] <nicolo-ribaudo>
Yes but Dan asked the same question

[14:45:18.0684] <Chris de Almeida>
ok

[14:45:50.0819] <rbuckton>
Isn't it only a throwing behavior in strict mode?

[14:46:04.0436] <shu>
oh hmm

[14:46:13.0769] <shu>
does it go from silent no-op to different behavior? that's scarier

[14:46:58.0267] <nicolo-ribaudo>
Could we just "fix the override mistake" in strict mode?

[14:47:06.0613] <nicolo-ribaudo>
* Could we just "fix the override mistake" only in strict mode?

[14:47:34.0241] <littledan>
IIRC the lodash thing was in strict mode

[14:47:55.0910] <littledan>
like that's why it caused the throw that it depended on

[14:48:08.0397] <nicolo-ribaudo>
I mean that we do Justin's change, but also keep setting an inherited non-writable property as a no-op in sloppy mode, to avoid going to "silent noop to different behavior"

[14:48:12.0366] <nicolo-ribaudo>
Re Shu's message

[14:48:24.0210] <bakkot>
that would give up a lot

[14:48:24.0692] <shu>
i'm confused now. can we hope to fix it for sloppy mode at all? sounds like no

[14:48:43.0975] <littledan>
I dunno if we found any compat issue in sloppy mode

[14:48:52.0269] <littledan>
maybe we *will* find one, though

[14:49:33.0889] <bakkot>
node (and a lot of things) would like to have frozen intrinsics and probably cannot do so if the override mistake is only fixed in sloppy mode

[14:49:38.0028] <bakkot>
* node (and a lot of things) would like to have frozen intrinsics and probably cannot do so if the override mistake is only fixed in strict mode

[14:50:26.0915] <nicolo-ribaudo>
📣 **Announcement**

I added a "Stage 2.7 reviewers" column at https://github.com/tc39/proposals?tab=readme-ov-file#stage-2, go there and add reviewers for your proposals or proposals you are a reviewer of

[14:50:48.0292] <rbuckton>
Hmm. Sloppy mode seems to actually not have the override mistake?


[14:51:11.0084] <nicolo-ribaudo>
`object.constructor` would change to be the new function

[14:51:27.0248] <shu>
yeah that screenshot shows sloppy mode doing a silent no-op

[14:51:33.0178] <shu>
so we'd be changing one non-throwing behavior to another non-throwing behavior

[14:51:42.0519] <shu>
so there are two web compat questions: sloppy mode + toString

[14:52:36.0883] <rbuckton>
Ah, yes. it's showing `Object.constructor`.

[15:04:04.0322] <nicolo-ribaudo>
shu For the use counter, I believe after step 16 of https://tc39.es/ecma262/#sec-object.prototype.tostring you'd need to add:
```
1. If O has a [[ViewedArrayBuffer]] internal slot and _tag_ is not "DataView", trigger the counter.
1. Else, if O has a [[SetData]] internal slot and _tag_ is not "Set", trigger the counter.
1. Else, ... (for all the types listed in that issue)
```

[15:04:25.0306] <littledan>
I don't get it; what evidence do we have that we can't apply this in sloppy mode? I thought the only evidence we had was, we can't fix the mistake in strict mode

[15:04:55.0486] <bakkot>
we have no specific evidence either way, but a strong general intuition that making errors into non-errors is more likely to be web compat than changing behavior of non-error paths

[15:05:46.0334] <rbuckton>
The issue is that sloppy mode doesn't error, so other use cases aside from lodash may not be as obviously broken.

[15:05:56.0744] <shu>
it's just really hard to figure out

[15:05:59.0483] <shu>
we have no idea what breakage means

[15:06:28.0101] <littledan>
similarly, fixed leaves private fields mutable, right?

[15:06:56.0774] <shu>
it could be something non-local eventually throws, it could mean it behaves differently and you get a load of bug reports that are just like "site broke" "video doesn't play" "button doesn't work"

[15:07:48.0469] <Richard Gibson>
yes, e.g. `Object.fix(new Map()).set("foo", "bar").size === 1`

[15:07:50.0971] <shu>
thanks, will think on that

[15:08:27.0397] <shu>
anyway i am not sure if there's consensus that we should fix override mistake in strict mode only

[15:11:08.0736] <rbuckton>
Are we sold on calling this "fix"? I think a name more aligned with what it's actually doing might make more sense. "Fix" seems too general of a term, especially if the "fixed" behavior we were previously discussing gets rolled into "extensible".

[15:22:22.0894] <shu>
i would prefer a name other than fix, yes

[15:24:05.0408] <shu>
is mark in this channel, i can't find him via autocomplete

[15:28:54.0996] <kriskowal>
MarkM doesn’t patrol Matrix, no.

[15:29:06.0636] <kriskowal>
For that, he has minions.

[15:30:01.0371] <Ashley Claymore>
I liked Stable

[15:32:26.0449] <James M Snell>
> <@kriskowal:aelf.land> For that, he has minions.

MarkMinions?

[15:33:18.0405] <shu>
kriskowal: okay, i'll post to issue in the github

[15:36:35.0780] <Richard Gibson>
some possibilities raised at various points: Object.{crystallize,fix,lock,petrify,stabilize}

[15:37:06.0914] <bakkot>
I could also imagine an extra option to `Object.freeze`

[15:37:07.0541] <Michael Ficarra>
> <@gibson042:matrix.org> some possibilities raised at various points: Object.{crystallize,fix,lock,petrify,stabilize}

okay maybe fix isn't so bad

[15:37:15.0260] <bakkot>
`Object.freeze(x, { nontrapping: true })`

[15:37:21.0200] <shu>
i like that

[15:37:27.0798] <shu>
the options bag

[15:37:42.0925] <nicolo-ribaudo>
So many allocations

[15:37:58.0010] <bakkot>
do you not re-use your options bags? :)

[15:37:59.0373] <shu>
don't freeze where performance matters, ez

[15:38:27.0693] <Chris de Almeida>
it's `erights` ftr 

[15:38:42.0976] <nicolo-ribaudo>
What I don't like much about fix is that even if I know it's "fixed as in it cannot move" I keep thinking that objects are then either fixed or broken

[15:39:15.0666] <Andreu Botella>
`Object.isBroken`

[15:39:25.0977] <snek>
always returns true

[15:45:02.0639] <nicolo-ribaudo>
TCQ empty -> time to ask for Stage 3 for R&T

[15:48:58.0166] <Mathieu Hofman>
I still don't understand why? In principle, shouldn't freeze allow more optimization ?

[15:49:27.0694] <bakkot>
who is going to put in the work to write those optimizations instead of more heavily optimizing the common case?

[15:50:13.0967] <bakkot>
I am not totally clear if this vision is still keeping `${} === ${}`

[15:51:03.0490] <bakkot>
I am guessing no?

[15:51:21.0214] <snek>
i was told yes

[15:51:23.0967] <bakkot>
was that explained and I just missed it?

[15:51:25.0997] <bakkot>
hm

[15:51:27.0075] <bakkot>
I will ask

[15:51:34.0255] <Mathieu Hofman>
I think it cannot, I don't think we've gotten there yet

[15:51:53.0528] <littledan>
Let's continue the presentation; it answers bakkot's question

[15:51:54.0229] <ljharb>
it'd have to memoize the contents and keep the resulting object somewhere, so i'm not sure how it'd be practical

[15:51:59.0596] <bakkot>
ah, slides have an `Object.equalRecords`

[15:52:29.0897] <bakkot>
I did go through the slides and did not immediately see an answer to my question but I think the existence of `equalRecords` implies no

[15:52:31.0528] <rbuckton>
I think that may have been the next section before we broke for the queue? The slide mentioned composite keys

[15:52:41.0655] <bakkot>
composite keys don't have to be `===`

[15:52:48.0804] <bakkot>
if you make the collections special case them

[15:53:53.0770] <Mathieu Hofman>
there are some questions about backwards compat if that happens by default

[15:54:12.0318] <Mathieu Hofman>
(again we're jumping ahead of the presentation)

[15:54:24.0902] <bakkot>
I don't see how there can be back compat questions about new syntax?

[15:54:28.0592] <nicolo-ribaudo>
Not really backwards compat, as these things don't exist yet

[15:54:35.0077] <nicolo-ribaudo>
More "mixing old and new code"

[15:54:39.0108] <nicolo-ribaudo>
* More "mixing old and new code" might not work

[15:54:43.0376] <Mathieu Hofman>
right sorry

[15:54:56.0027] <snek>
i don't quite understand that, excited to see the slides ig

[15:55:12.0708] <Mathieu Hofman>
libraries using a Map assuming that putting 2 different object cannot result in the same entry in the map

[15:55:32.0070] <Michael Ficarra>
I *really* want this composite key feature built-in

[15:55:34.0393] <bakkot>
code often breaks when we add new concepts to the language

[15:55:45.0870] <snek>
this doesn't break that assumption, unless you mean specifically due to this having typeof "object"

[15:55:46.0877] <bakkot>
* code often breaks when we add new concepts to the language and you try to use them with old code

[15:56:44.0201] <rekmarks>
Isn't this already broken by `typeof null === 'object'` ?

[15:56:53.0719] <bakkot>
also: can you put one of these in a WeakMap?

[15:56:58.0084] <Michael Ficarra>
😠 SameValueZero

[15:57:09.0148] <bakkot>
I guess maybe only if it contains at least one thing which can be put in a WeakMap?

[15:57:17.0090] <nicolo-ribaudo>
The TC39 rule is "when somebody says `typeof x === "object"`, pretend they said `Object(x) === x`"

[15:57:19.0566] <Mathieu Hofman>
type doesn't matter. reality is that today if a !== b, then set.add(a) is distinct from set.add(b)

[15:57:48.0598] <nicolo-ribaudo>
NaN enters the room

[15:57:49.0898] <snek>
r&t should override === imo

[15:58:00.0209] <snek>
just really annoying otherwise

[15:58:06.0779] <bakkot>
no

[15:58:08.0542] <bakkot>
no no no

[15:58:16.0815] <bakkot>
please do not add attractive nuisances to the language

[15:58:17.0291] <Michael Ficarra>
counterpoint: yes?

[15:58:53.0678] <shu>
we don't want to overload ===?

[15:58:55.0518] <Mathieu Hofman>
That was the feedback from implementors: no can't do

[15:59:08.0216] <bakkot>
well

[15:59:11.0313] <bakkot>
it is not totally clear

[15:59:14.0648] <bakkot>
I think this vision is, no

[15:59:18.0610] <bakkot>
though some people would like to

[15:59:22.0140] <snek>
or just give me a System.goodEqual function which i can transpile every `===` into

[15:59:24.0037] <ljharb>
the only way it makes sense to have it, and not overload `===`, is if "same" objects are actually the same object

[15:59:33.0116] <rekmarks>
```
> const s = new Set()
undefined
> s.add(NaN)
Set(1) { NaN }
> s.add(NaN)
Set(1) { NaN }
```

[15:59:56.0293] <Mathieu Hofman>
but `NaN !== NaN`


2025-02-20
[16:00:06.0506] <Mathieu Hofman>
and yes I expected to be called out for that one

[16:00:07.0017] <bakkot>
counterpoint: i really want composite keys

[16:00:08.0676] <Michael Ficarra>
doesn't matter, we do the right thing

[16:00:25.0900] <ljharb>
i also want them, but i'm not sure why the two are linked

[16:00:34.0486] <Mathieu Hofman>
Manually building tries is a pain

[16:00:38.0230] <bakkot>
this proposal is just composite keys

[16:00:44.0518] <bakkot>
that is the whole proposal

[16:00:47.0514] <bakkot>
if I understand correctly

[16:00:47.0689] <ljharb>
oh

[16:01:14.0631] <ljharb>
right, but can't it just, like, do the nested weakmap + a finalization-registered weakref, in the spec?

[16:01:18.0547] <nicolo-ribaudo>
A goal of the presentation is for delegates to say "yeah let's just do composite keys", or "let's do R&T"

[16:01:19.0743] <Jesse (TC39 🇺🇸)>
I can't bother my pretty head with `NaN` and `-0`

[16:01:29.0392] <ljharb>
then a composite key of the same object will never observably be a different object

[16:01:32.0122] <bakkot>
then you can't do a composite key of only primtiives

[16:01:40.0318] <bakkot>
which is bad and dumb

[16:01:42.0966] <ljharb>
have a parallel Map for that?

[16:01:48.0725] <bakkot>
then you leak

[16:01:50.0656] <bakkot>
which is bad and dumb

[16:01:55.0282] <ljharb>
only primitives go in the Map

[16:02:03.0499] <snek>
yeah that leaks

[16:02:06.0068] <ljharb>
oh

[16:02:14.0443] <ljharb>
hm

[16:02:16.0370] <bakkot>
this space is well-expored in userland

[16:02:21.0929] <snek>
you can't ever collect those entries because they're forgable 

[16:02:27.0118] <ljharb>
then i guess we need `===` overloaded

[16:02:30.0609] <bakkot>
the links from the slides have a few different approaches

[16:02:47.0472] <bakkot>
* this space is well-explored in userland

[16:03:14.0874] <Luca Casonato>
if you do the finalizationregistry thing, it does not leak if a composite key of only primitives become unreachable, even with a map, no?

[16:04:12.0545] <snek>
is the implementor worry that it will slow down *all* `===` occurances

[16:04:23.0561] <Mathieu Hofman>
It has to, because the components of the composite key would always be forgeable, the composite of them is forgeable

[16:04:33.0774] <kriskowal>
Yeah, I defined a bunch of collections before Map was added to the language, where you brought your own contentEquals contentCompare, which I suppose is analogous to species.

[16:04:33.0791] <Michael Ficarra>
> <@devsnek:matrix.org> is the implementor worry that it will slow down *all* `===` occurances

I think that's the claim (in the past)

[16:04:42.0717] <Mathieu Hofman>
* It has to leak, because the components of the composite key would always be forgeable, the composite of them is forgeable

[16:04:53.0727] <bakkot>
I guess we could in principle say that a composite key of only primitives cannot be held weakly

[16:04:56.0105] <Luca Casonato>
what is this a response to?

[16:04:56.0933] <bakkot>
and maybe that solves the problem?

[16:05:16.0829] <Luca Casonato>
oh right yes obviously

[16:05:17.0925] <ljharb>
that seems perfectly reasonable

[16:05:26.0889] <Mathieu Hofman>
but what if it's an object ?

[16:05:32.0992] <ljharb>
(it makes an even stronger case for a built-in "isWeakable" predicate, ofc)

[16:05:39.0324] <nicolo-ribaudo>
I was expecting you to say "this breaks the predicate to check when I can put something in a weakmap)

[16:05:44.0949] <nicolo-ribaudo>
Oh there it is :)

[16:05:45.0839] <bakkot>
I do not understand the question

[16:05:53.0430] <nicolo-ribaudo>
* I was expecting you to say "this breaks the predicate to check when I can put something in a weakmap"

[16:06:17.0153] <ljharb>
having a non-weakable object is def weird too

[16:06:46.0294] <Mathieu Hofman>
See above discussion. An object is currently expected to be usable as a weak map key

[16:07:08.0410] <Michael Ficarra>
> <@ljharb:matrix.org> having a non-weakable object is def weird too

no weirder than registered symbols

[16:07:51.0311] <ljharb>
they're both differently weird. which is weirder in aggregate

[16:08:19.0633] <bakkot>
(this would also require the thing from the previous presentation where non-extensible objects could not get stamped with private fields, incidentally)

[16:09:45.0628] <Michael Ficarra>
ooooo composite keys would obviate `Array.prototype.uniqBy` 😮

[16:09:58.0208] <Michael Ficarra>
god I need this

[16:10:17.0665] <bakkot>
... would they?

[16:10:22.0283] <bakkot>
I feel like they'd make it better tbh

[16:11:24.0322] <Michael Ficarra>
well that was entirely coincidental

[16:11:49.0304] <canadahonk>
whats the 4th form of equality?

[16:12:06.0118] <bakkot>
`===`, `==`, `Object.is`, `SameValueZero`

[16:12:16.0198] <canadahonk>
ohh SameValueZero

[16:12:18.0691] <littledan>
I was imagining that this would replace SameValueZero

[16:12:35.0573] <nicolo-ribaudo>
Also in `[].includes`?

[16:12:54.0126] <bakkot>
I mean, yeah, if we're modifying existing APIs

[16:14:44.0056] <snek>
shu: is it still held that `===` for r&t is too expensive?

[16:14:52.0391] <shu>
yes

[16:15:04.0695] <snek>
😔

[16:15:51.0545] <bakkot>
also reminder of the old https://github.com/tc39/proposal-richer-keys/tree/master/compositeKey

[16:16:24.0628] <bakkot>
these were `===` via interning (and requiring at least one weak component) instead of modifying collections

[16:16:28.0430] <bakkot>
but same goal

[16:21:40.0197] <bakkot>
also, phrasing these as "composite keys" makes it clear that you shouldn't be using these all over the place

[16:21:55.0927] <bakkot>
e.g. a new Object.entries-like API would not return these

[16:23:19.0444] <shu>
if they are actually composite keys and composite keys only, is the recursive part of it needed?

[16:24:51.0576] <bakkot>
I would want it to, so I wouldn't have to manually flatten the results of my `.toKey` methods everywhere

[16:26:02.0651] <shu>
fair enough

[16:26:39.0658] <bakkot>
(and it's not like it's any slower to do it recursively vs me manually flattening. faster, probably, since you can have a fast path if I was using actually the same object)

[16:26:51.0257] <bakkot>
* (and it's not like it's any slower to do it recursively vs me manually flattening. faster, probably, since you can have a fast path if I was using actually the same inner object)

[16:28:40.0363] <bakkot>
libraries are allowed to have expectations and we're definitely allowed to break those expectations

[16:28:47.0382] <bakkot>
we added new `typeof`s!

[16:30:54.0047] <Michael Ficarra>
that was *not good* for some minifiers

[16:31:10.0008] <bakkot>
but that was ok

[16:31:33.0924] <Michael Ficarra>
only because I fixed them promptly

[16:32:12.0000] <Mathieu Hofman>
I expect this would be less brutal than new typeof

[16:32:13.0791] <ljharb>
p sure the forever goodness of new primitives outweighs one person's minifier fixing effort tho

[16:33:06.0458] <rekmarks>
Ashley Claymore: is there a repo for your r&t work? Is it just https://github.com/tc39/proposal-record-tuple?

[16:33:08.0003] <bakkot>
so, would <del>composite keys</del> this new vision of records normalize `-0` to `0` when using them in a map?

[16:33:13.0462] <bakkot>
presumably yes?

[16:33:15.0122] <littledan>
could we have more help from notetakers?

[16:33:21.0765] <nicolo-ribaudo>
I can help

[16:33:26.0321] <bakkot>
kind of annoying; that could be expensive. but I guess just don't have `-0`

[16:34:02.0103] <littledan>
why would it? it'd just normalize during calculation of the hashcode itself, and then do comparison SameValueZero-wise

[16:34:04.0374] <Chris de Almeida>
do we need a PoO?

[16:34:14.0577] <littledan>
no

[16:34:41.0710] <littledan>
oh, yeah... because that's what maps do with scalars...

[16:35:09.0649] <littledan>
maybe we should just skip it here, though, since it'd be weird if the identity didn't actually match the first one that put it in

[16:35:40.0239] <bakkot>
Iiiiiiiii guess that would be ok?

[16:35:58.0710] <bakkot>
but in that case it would be better if we didn't normalize `-0`

[16:36:02.0313] <bakkot>
too late for that though

[16:36:21.0159] <Aki>
PSA: The notes today are missing lots of summaries and conclusions. Please, speakers, make sure you record those while they're still fresh in your head. Take 5 minutes to save Samina & me thirty.

[16:36:47.0511] <Ashley Claymore>
I was exploring a slightly different design here: https://github.com/acutmore/proposal-keyby
what I presented today needs a home (maybe the existing R&T repo?)

[16:50:27.0278] <Justin Ridgewell>
Is this James Snell speaking?

[16:50:42.0231] <Michael Ficarra>
yes

[16:53:08.0096] <snek>
is implementation slowness the only thing holding back r&t `===` (and other operator overloads like decimal addition?)

[16:53:47.0446] <Ashley Claymore>
the feedback also included the risk of changing existing JIT code

[16:54:08.0065] <Ashley Claymore>
i.e. the one line spec change does not map to a one line c++ change

[16:54:18.0276] <shu>
usual complexity concerns if it incentivizes ever-more-complex interning schemes

[16:54:29.0870] <shu>
harder and harder to tune

[21:04:58.0575] <ljharb>
(please nobody be concerned that the notes doc is no longer accessible; turns out hackmds are all fully indexed by google)

[23:44:05.0371] <eemeli>
I trust that the notes doc will be made accessible again at some point?

[00:08:56.0500] <ZiJian Liu>
Hi, thank you for everyone's feedback, this is the problem-statement document of the proposal Number.isSafeNumeric. If there are any questions or suggestions, feel free to comment in the Github Issue. 

Link: https://github.com/Lxxyx/proposal-number-is-safe-numeric/issues/4

Chris de Almeida 

[05:48:25.0997] <snek>
what is the concrete implementation of `MV(str) is MV(F(MV(str)))`? Do you just have to check every possible "worthy"(?) serialization (e.g. scientific notation, `0.N` vs `.N`, etc...) of the floating point value?

[05:52:06.0489] <snek>
* what is the concrete implementation of `MV(str) is MV(F(MV(str)))`? Do you just have to check every possible "worthy"(?) serialization (e.g. unnormalized scientific notation, `0.N` vs `.N`, etc...) of the floating point value?

[06:14:08.0606] <ZiJian Liu>
1. MV(str) means mathematical value (aka the real number value) of the str, there is no specific implementation yet, just a conceptual statement, proving that the real number may change during string-number conversion.
2. When a string is converted to a number, the Runtime can obtain the exact number value, and perhaps a comparison could be made at this point (this is my speculation and has not been verified). If there are better solutions, please let me know.

[06:16:45.0852] <snek>
yeah I mean my point is that computers can't literally do MV(str) is MV(other str). (otherwise doubles wouldn't exist and we could all go home lol), so I imagine the only reasonable implementation to be a routine that switches through comparing different serializations depending on the format of the input.

[06:17:25.0361] <snek>
* yeah I mean my point is that computers can't literally do MV(str) is MV(other str) (otherwise floats wouldn't exist and we could all go home lol), so I imagine the only reasonable implementation to be a routine that switches through comparing different serializations depending on the format of the input.

[06:18:41.0041] <ZiJian Liu>
Thank you for the reply, yes, so this is pseudocode, not an actual implementation (just a convenient way to understand the problem, sorry for the confusion, I might need to make a special note about this formula)

[06:19:44.0737] <snek>
no it's fine to discuss abstractly, I'm just asking the room how they would approach concrete implementation

[06:23:21.0293] <snek>
* yeah I mean my point is that computers can't literally do MV(a) is MV(b) (otherwise floats wouldn't exist and we could all go home lol), so I imagine the only reasonable implementation to be a routine that switches through comparing different serializations depending on the format of the input.

[06:30:36.0554] <Jesse (TC39 🇺🇸)>
I might have an internal representation of digit strings that would allow me to at least do an equality check

[06:31:45.0547] <snek>
so you'd first attempt to canonicalize the input I guess?

[06:58:30.0491] <waldemar>
What happened to yesterday's notes document? I get Access Denied trying to review it.

[07:08:03.0284] <Jesse (TC39 🇺🇸)>
> <@devsnek:matrix.org> so you'd first attempt to canonicalize the input I guess?

yeah that would be my approach. That's essentially what the decimal proposal polyfill does when giving a string as input

[07:13:06.0441] <Michael Ficarra>
> <@waldemarh:matrix.org> What happened to yesterday's notes document? I get Access Denied trying to review it.

https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$KG586ubrdr9PCC6MsiQdItP_oPRxUWtGb2X-Kl40pow?via=matrix.org&via=mozilla.org&via=igalia.com

[07:42:22.0434] <Chris de Almeida>
The top secret notes document link (and TCQ link) were leaked, presumably by being present in the hackmd schedule, which gets indexed by search engines.  We will share a new notes doc link on the reflector issue for the meeting.  Also perhaps a new TCQ link.

[07:43:27.0999] <nicolo-ribaudo>
How do search engines find the hackmd document in the first place? Was it linked somewhere?

[07:45:45.0419] <Chris de Almeida>
not sure, but one way is that the hackmd links are sometimes shared in these public matrix channels, which get logged and those pages get indexed

[07:46:58.0601] <Chris de Almeida>
the hackmd pages themselves are not really a problem to be accessible (except maybe that anyone can edit them) -- but the fact the notes doc and tcq links appeared on them is the bigger issue

[09:03:21.0100] <Chris de Almeida>
new notes doc link is up on the reflector issue: https://github.com/tc39/Reflector/issues/547

[09:16:50.0220] <Chris de Almeida>
new TCQ link is up on the reflector issue as well

[09:48:57.0504] <Chris de Almeida>
as the prophecy foretold

[10:01:10.0293] <Chris de Almeida>
many thanks to our note-takers from yesterday!  👏👏👏👏👏👏👏

- Ben Lickly
- Chengzhong Wu
- Luis Fernando Pardo Sixtos
- Linus Groh
- Nicolò Ribaudo
- Oliver Medhurst
- Philip Chimento



[10:01:43.0601] <nicolo-ribaudo>
- Daniel Ehrenberg

[10:02:25.0134] <Chris de Almeida>
* many thanks to our note-takers from yesterday!  👏👏👏👏👏👏👏

- Ben Lickly
- Chengzhong Wu
- Daniel Ehrenberg
- Luis Fernando Pardo Sixtos
- Linus Groh
- Nicolò Ribaudo
- Oliver Medhurst
- Philip Chimento

[10:03:35.0848] <Michael Ficarra>
ooohh I actually didn't know we had the right to a minority report

[10:03:39.0657] <Michael Ficarra>
I appreciate that

[10:06:45.0888] <nicolo-ribaudo>
📣📣📣 **The new TCQ link is in the Reflector**

[10:09:18.0321] <hax (HE Shi-Jun)>
I don't think single blocker is the issue, the issue is "unequal authority".

[10:10:44.0391] <hax (HE Shi-Jun)>
Is there any example of minority report in our history??

[10:11:47.0185] <Michael Ficarra>
@haxjs:matrix.org I don't think it was common knowledge that we had that ability

[10:11:52.0616] <Michael Ficarra>
so I'm not aware of any

[10:15:28.0455] <canadahonk>
📣 don't forget to request more breakout session topics for this afternoon! https://github.com/tc39/Reflector/issues/552

[10:22:31.0187] <bakkot>
I like the canPlayAudio API!

[10:22:39.0465] <Michael Ficarra>
I believe it's empty string actually

[10:22:46.0658] <Michael Ficarra>
which is close-enough to false

[10:23:21.0166] <ljharb>
ah thanks, it was off the top of my head

[10:23:28.0816] <Michael Ficarra>
an equally non-committal kind of false

[10:32:33.0034] <bakkot>
ok but SABs are actually good

[10:32:42.0541] <bakkot>
people should pick examples which are unambiguously bad if they want to make this point

[10:32:46.0643] <littledan>
if we had blocked SharedArrayBuffer in TC39, it wouldn't've blocked it from shipping, just reduced TC39's scope as it was standardized somewhere else

[10:33:16.0057] <littledan>
right, invoking Crockford and ES4 is also fraught here...

[10:33:36.0968] <shu>
the counterfactuals that mark invokes would not be a better outcome

[10:33:46.0237] <shu>
* the counterfactuals that mark invoke would not be a better outcome

[10:34:42.0326] <shu>
we simply don't have agreed upon goals for the language

[10:35:06.0645] <shu>
a veto in TC39 does not change those goals, and they will be realized in another way

[10:35:10.0192] <littledan>
my understanding is, historically, Mark, Waldemar, Crockford, Dave Herman and Allen W-B innovated/invented the block during the ES4 process; it is not a historical constant in this committee

[10:35:30.0103] <ljharb>
however, sometimes that realization is not "good faith" participation.

[10:35:32.0735] <littledan>
sometimes, but yeah

[10:35:37.0647] <littledan>
definitely in the SAB case

[10:35:55.0377] <bakkot>
if base64 had taken a single additional meeting I was going to do it in whatwg

[10:36:00.0207] <bakkot>
I was very close already

[10:36:00.0474] <ljharb>
iow sometimes if an entity hacks around an objection in TC39, it's not actually a good faith action.

[10:36:04.0551] <shu>
is your end goal to make sure everyone participates in tc39 in good faith?

[10:36:14.0372] <shu>
or is your goal to evolve the language?

[10:36:14.0466] <ljharb>
hopefully we're already there.

[10:36:28.0435] <shu>
the whole enterprise of standardization at all is a means to an end

[10:36:30.0296] <ljharb>
"evolve the language" implies good change. all change is not good change.

[10:36:32.0621] <shu>
it is not the end

[10:36:42.0033] <littledan>
I don't think "good faith" is a very useful lens. The committee has already advanced a lot in that we're not constantly referring to "good faith", which I think is a sign of... good faith

[10:37:34.0884] <Aki>
But I agree with Mark that _generally_, the dissent isn't to solving the problem overall

[10:37:36.0108] <Michael Ficarra>
> <@littledan:matrix.org> I don't think "good faith" is a very useful lens. The committee has already advanced a lot in that we're not constantly referring to "good faith", which I think is a sign of... good faith

yes, this used to come up much more often

[10:37:49.0643] <bakkot>
one person's hacking around an objection in one standards body is another person's making progress in a less sclerotic organization 

[10:38:02.0759] <shu>
i don't think good or bad faith matters

[10:38:15.0071] <ljharb>
all progress is also not always good process.

[10:38:25.0655] <shu>
who's saying that?

[10:38:35.0013] <ljharb>
maybe nobody, just making sure it's explicit

[10:38:54.0399] <canadahonk>
should we interrupt for the POO

[10:39:02.0162] <littledan>
well, there are clearly hypothetical things people could do that are bad faith, like behaving anticompetitively with respect to the standard under discussion, which is prohibited by Ecma rules (as it is in all standards bodies). But I don't think that ever happens here.

[10:39:16.0565] <Aki>
(I also agree with Michael Saboff—it _has_ happened. It's just not usual)

[10:39:30.0973] <shu>
agreed, good clarification. that is a much dire form of bad faith that we basically never see here

[10:39:54.0793] <snek>
tc39 is the only standards committee i've interacted with where it feels like non-megacorps can drive any form of change. i don't think blocks are the only component of that but i think giving large equal power is definitely an important part of it. everything will have good faith and bad faith, and all you can do is strive for processes to be as non-destructive as possible.

[10:40:35.0007] <James M Snell>
Michael Saboff: if you'd like, I'm volunteering to collaborate on a concrete proposal for how the block process can be improved

[10:41:21.0266] <littledan>
equality is an important value of TC39; I don't think Michael's proposal questions that.

[10:41:32.0954] <canadahonk>
ngl i was onboard with this but this (great) view has completely changed my mind

[10:41:36.0582] <ljharb>
but it does lessen it, even if unintentionally

[10:41:44.0729] <canadahonk>
* ngl i was onboard with the proposal but this (great) view has completely changed my mind

[10:41:53.0018] <shu>
i don't understand mark's point

[10:42:11.0469] <canadahonk>
for the most part only big companies/browsers have more than 1 delegate

[10:42:19.0664] <bakkot>
mark thinks it is important that browser vendors not have more power than everyone else

[10:42:20.0601] <shu>
if you believe browsers have de facto veto, _no_ change to process (which is de jure) can change that

[10:42:37.0288] <bakkot>
since browser vendors necessarily have a veto, the only solution to keep parity is for everyone to have a veto

[10:42:39.0450] <canadahonk>
* for the most part only big companies/browsers have more than 1 delegate so they could block themselves but smaller companies could not

[10:43:00.0666] <shu>
ah, but, tc39 rules do not bound anybody to ship anything

[10:43:06.0157] <shu>
thus the disparity between de facto and de jure

[10:43:10.0466] <ljharb>
right, exactly

[10:43:24.0295] <snek>
oh of course i don't think it intentionally does. i would consider it more to be an emergent check against the power of implementors technically having their own "lone veto" anyway. not that i am accusing them of taking advantage of that at all.

[10:43:26.0743] <ljharb>
but the good faith part is that if browser makers provide consensus for stage 3, then they have committed to shipping it

[10:43:46.0864] <ljharb>
if they weren't going to ship it, or decide later not to, it's incumbent to block stage 3 or propose demotion

[10:43:54.0298] <Jesse (TC39 🇺🇸)>
I think this shoulnd't be a breakout topic

[10:44:14.0095] <bakkot>
strong +1, this is a topic for the whole committee

[10:44:33.0608] <ljharb>
* but the good faith part is that if browser makers provide consensus for stage 3, then they have in fact committed to shipping it

[10:44:37.0743] <canadahonk>
i can copy the queue into notes if people would like

[10:44:39.0401] <shu>
the current process actively is at odds with this mode IMO

[10:44:41.0035] <ljharb>
* if they weren't going to (or aren't able to commit to) ship it, or decide later not to, it's incumbent to block stage 3 or propose demotion

[10:44:47.0139] <shu>
i'll speak to it later on the queue if we get to it

[10:45:46.0906] <shu>
ah we're tabling this?

[10:45:59.0702] <littledan>
we are continuing this afternoon

[10:46:30.0805] <littledan>
we will have an overflow topic, at least to go through the queue

[10:47:03.0775] <shu>
ljharb: in short, my view is that the veto culture in TC39 in practice works out to that stage advancement can mean "can we live with this proposal", not necessarily "are we actively supporting this proposal"

[10:47:24.0126] <ljharb>
oh i agree. but "live with" imo includes "will ship" whether you support it or not

[10:47:31.0088] <bakkot>
I didn't add myself to the queue because it was clear that we weren't going to get there, but I did have a topic to add re: often there is only ~two active voices of support for a proposal so requiring (in some cases) >2 active voices to veto seems silly

[10:47:37.0212] <shu>
and if we can merely live with something but do not actively support something, the committment to shipping it ASAP is not there

[10:48:00.0414] <ljharb>
i guess i really don't understand why a browser wouldn't block it in that case

[10:48:14.0024] <ljharb>
the expectation is that basically everyone will ship it in stage 3

[10:48:16.0420] <shu>
there are many cases where we play catch up to reduce interop risk

[10:48:32.0401] <snek>
i will take merely live with over active support. like, the success rate seems pretty high?

[10:48:35.0166] <shu>
"will ship" on whose timeline?

[10:48:36.0503] <ljharb>
ok, so you're saying where you're gambling that others will ship it first, so that you're forced to play catchup?

[10:48:54.0472] <shu>
no

[10:48:55.0478] <littledan>
I wouldn't be opposed to increasing the support threshold. (But I also see the point about not making the veto threshold too high)

[10:49:02.0534] <ljharb>
i think it would be perfectly fine for a browser to say "consensus, but we won't ship first" - that way if every browser says that, we all know we have a problem

[10:49:11.0144] <Rob Palmer>
I wanted to push back on Mark's final statement that definitively stated "the rule we have is the only one that can work."  We should be open to suggestions for process improvement. And it sounds like James Snell has ideas.  And there are some the chair group has considerd too.  So I'd like to be open minded and not assume it's a problem we cannot solve.

[10:49:26.0781] <shu>
that's fair, if you want that to be more explicit, that's a concrete change to the process we can talk about

[10:49:34.0826] <shu>
but priorities change, product strategies change

[10:49:38.0186] <ljharb>
oh sure

[10:49:39.0896] <bakkot>
yeah, my preferred solution would be to require significantly more active support for a proposal to advance, and then also raise the threshold for a veto.

[10:49:46.0155] <shu>
you want us to be locked in to some direction, you want promises. there will be no promises

[10:49:48.0567] <bakkot>
the change to require at least 2 active supporters was good

[10:49:59.0714] <littledan>
ultimately, if all browsers don't want to ship something, we should figure out how to coordinate on what the language is and not leave things indefinitely ambiguous. It's OK if you change your mind and decide against something.

[10:50:07.0139] <ljharb>
and a change doesn't imply bad faith at all, but i think it's incumbent on a browser to notify the committee if the "will ship" status changes

[10:50:12.0569] <Andreu Botella>
> <@shuyuguo:matrix.org> but priorities change, product strategies change

"will implement" doesn't mean "will ship"

[10:50:16.0955] <bakkot>
but 2 active supporters and no active dissenters is _such_ a low bar for changes to the language, we should have a higher bar

[10:50:22.0064] <Andreu Botella>
someone else can implement the proposal

[10:50:38.0402] <shu>
huh?

[10:50:49.0819] <Michael Saboff>
The point that I wanted to make last night is that for me, stage three is not intent to ship, it is we should start implementing.  This is based on other priorities.

[10:50:58.0623] <ljharb>
maybe the reverse? "will ship" doesn't imply "will implement"?

[10:51:03.0411] <canadahonk>
2 supporters from different representations?

[10:51:10.0754] <rekmarks>
Has anything failed to make it from stage 3 to 4 due to lack of browser implementations?

[10:51:16.0545] <shu>
right, my position has been stage 3 is an option to ship

[10:51:20.0528] <nicolo-ribaudo>
Decorators

[10:51:21.0373] <shu>
we reserve the right but are not obligated

[10:51:32.0285] <bakkot>
well, https://github.com/tc39/proposal-regexp-legacy-features is 8 years old

[10:51:36.0651] <bakkot>
I don't know about "failed"

[10:51:41.0287] <ljharb>
we can't obligate anyone. but the *intention* should be to ship imo

[10:51:44.0194] <bakkot>
because at any time people could implement it

[10:51:50.0482] <Andreu Botella>
> <@shuyuguo:matrix.org> huh?

In decorators, V8 is blocking the proposal even though there's a complete implementation. Committing to ship isn't committing to implementing, and in the presence of implementers external to the company whose browser is the product, committing to ship is the thing that matters more.

[10:52:18.0478] <shu>
V8's position is we don't want to be the first to ship

[10:52:26.0464] <bakkot>
strictly speaking I don't think we said they had to be from different organizations but I don't think the question has actually arisen

[10:52:33.0251] <shu>
i take issue with that characterization

[10:52:38.0440] <ljharb>
that is fine but i think this is the first time that's been stated, and it's been stage 3 for a long time

[10:53:02.0295] <nicolo-ribaudo>
I mean, it's every browser's position. None of the browser is individually responsible, but it means that the proposal will not go to stage 4 unless somebody changes their mind

[10:53:04.0979] <Michael Ficarra>
> <@rekmarks:matrix.org> Has anything failed to make it from stage 3 to 4 due to lack of browser implementations?

in addition to Decorators, we've had a Stage 3 withdrawal

[10:53:07.0536] <littledan>
that's fine, but a major function of the standards committee is to coordinate expectations and plans; we can't force anyone to do anything, but I hope we can eventually understand each others' plans so we can help others in the JS ecosystem.

[10:53:15.0008] <littledan>
namely SIMD

[10:53:51.0743] <canadahonk>
<del>technically stage 4 doesn't require browser implementations</del>

[10:54:13.0701] <ljharb>
what stage 4 requires is intentionally vague because nobody agrees on it, happy to provide more context later

[10:54:15.0880] <shu>
my question is then why can no individual browser be convinced to be the first to ship?

[10:54:24.0688] <shu>
we have different leadership, different priorities too

[10:54:27.0889] <bakkot>
the actual concern is not the nominal stage, it's whether it goes in browsers

[10:54:35.0394] <kriskowal>
Also polymorphic covers `new Amount.from({value: "1/2", unit: "cup", precision: "1/16"})`

[10:54:36.0270] <bakkot>
something actually being stage 4 is pretty irrelevant

[10:54:51.0786] <littledan>
that's fine, so, eventually we should be able to digest all of that and figure out, OK so should we cancel the proposal

[10:54:55.0150] <Michael Ficarra>
> <@littledan:matrix.org> namely SIMD

I was thinking about Object.observe, but also taht

[10:55:01.0393] <Michael Ficarra>
* I was thinking about Object.observe, but also that

[10:55:08.0816] <ljharb>
that was stage 2

[10:55:11.0994] <rekmarks>
Stage 4 implies (requires?) browser implementations, though?

[10:55:21.0654] <littledan>
yeah this was a prominent block of Stage 3, by Yehuda

[10:55:24.0490] <snek>
the exact text is "implementations" not "browsers"

[10:55:26.0687] <littledan>
(and it was the right call!)

[10:55:40.0901] <Andreu Botella>
> <@shuyuguo:matrix.org> we have different leadership, different priorities too

in a situation where we have a fairly complete implementation, how much is priorization the thing that matters when deciding not to ship?

[10:55:48.0175] <rekmarks>
But doesn't that always mean browsers in practice?

[10:55:51.0415] <snek>
its purposely vague, and in practice if the 3 largest js implementations don't ship something its problematic to call it "standardized"

[10:55:58.0058] <shu>
i'm not sure i understand the question

[10:56:05.0475] <Michael Ficarra>
> <@rekmarks:matrix.org> Stage 4 implies (requires?) browser implementations, though?

https://tc39.es/process-document/

[10:56:06.0489] <canadahonk>
per process doc "Two compatible implementations which pass the Test262 acceptance tests... Significant in-the-field experience with shipping implementations, such as that provided by two independent VMs"

[10:56:09.0478] <Chengzhong Wu>
only two are required

[10:56:10.0482] <shu>
having an implementation is a very small part of the decision to ship something

[10:56:13.0392] <canadahonk>
but in practice browsers yes

[10:56:29.0350] <ljharb>
nobody will make something stage 4 if it has zero browser implementations, no matter what the process doc says

[10:56:48.0465] <bakkot>
we have always required at least one browser but IIRC we've allowed some trivial things to go forward with only one browser actually finished implementing, if there was an implementation in babel or something

[10:57:12.0676] <rekmarks>
Seems sensible 👍️

[10:57:18.0207] <bakkot>
for anything nontrivial we're going to need two browsers though yes

[10:58:01.0377] <shu>
these are not my words, but reflects on browser dynamics in W3C and WHATWG: https://ln.hixie.ch/?start=1721260117&count=1

[10:58:33.0713] <bakkot>
huh, I didn't realize hixie was still writing on web stuff

[10:58:44.0985] <shu>
the footnote made it seem like he was goaded into it :)

[10:59:22.0663] <Michael Ficarra>
@jesse:igalia.com Decimal as presented is normalised?

[10:59:30.0106] <ljharb>
> The users chose browsers

i'm not sure that's really true anymore tho :-/

[10:59:33.0430] <nicolo-ribaudo>
Yes

[11:02:18.0480] <bakkot>
it is definitely true that a user of Firefox will choose to use Chrome or Safari if web pages don't work in Firefox

[11:02:30.0108] <bakkot>
not clear that there are choices beyond that

[11:02:35.0774] <bakkot>
(which is very sad)

[11:03:02.0984] <ljharb>
right

[11:03:24.0097] <snek>
whatwg/ietf (for example) continue to exist because they are effectively just implementors and no one else. tc39 continues to exist because it only attempts to steer implementations, it doesn't throw random stuff in and just expect it to then be implemented. anything further than tc39 doesn't exist anymore because its irrelevant to our shared reality. finding a good place within this spectrum is difficult, and i think some perhaps underdiscussed component of these arguments is where people think tc39 should land on this.

[11:03:47.0938] <littledan>
I'm not sure if that describes IETF...

[11:04:50.0465] <ryzokuken>
IETF WGs vary rather widely to make that sort of a generalization 

[11:05:22.0901] <rekmarks>
This basically describes the power dynamics that exist between standards and implementors in cryptocurrency / blockchain as well (opportunity to coin the name of a Law here, folks)

[11:05:30.0412] <littledan>
do we have a link to the slides for this presentation?

[11:05:53.0827] <nicolo-ribaudo>
https://docs.google.com/presentation/d/1050DHlNOzcN-8LqJQ_6z8j-LryXgEqOcLfcVzkhJyEk/edit#slide=id.p, from the agenda

[11:06:38.0934] <rekmarks>
It's past tense 😉

[11:07:50.0462] <jschoi>
Perhaps it would be “Hixie’s Law”, but I suspect that Hixie has made many other statements that one could enshrine as “laws”. Or maybe Hixie would say someone else came up with it first and told him.

[11:08:58.0978] <rekmarks>
Rarely do the coiners get to choose the law they lend their name to

[11:09:07.0716] <rekmarks>
* Rarely do the coiners get to choose the law they lend their names to

[11:09:46.0297] <jschoi>
That smells like a new law to me…

[11:11:02.0584] <bakkot>
Stigler's Law of Eponymy, arguably

[11:11:20.0920] <canadahonk>
/me retires from note editing, could another person please aid

[11:13:11.0170] <jschoi>
> Stigler attributed the discovery of Stigler's law to sociologist Robert K. Merton, from whom Stigler stole credit so that it would be an example of the law. The same observation had previously also been made by many others.

Oh, thank goodness, I was hoping that it would be autological.

[11:13:31.0811] <nicolo-ribaudo>
Fyi, there is a proposed breakout session for Decimal/Measure/Amount

[11:13:44.0556] <Aki>
Still need another notetaker

[11:13:51.0191] <Aki>
i think

[11:14:04.0125] <ryzokuken>
will pause for volunteers after this topic

[11:14:11.0474] <jschoi>
I’ll do it, I’ll get in a minute.

[11:15:38.0276] <eemeli>
littledan: Regarding champion groups, I agree, but in this case the sole champion is not available.

[11:15:59.0590] <nicolo-ribaudo>
Agree, I think it's good going through the committee this time

[11:17:35.0463] <jschoi>
Could someone link the file with the speaker abbreviations?

[11:17:37.0218] <littledan>
sure, fine to discuss in committee if people want. I can see how in some cases it might be ambiguous whether a coworker in the same company is an appropriate choice.

[11:17:50.0383] <canadahonk>
https://github.com/tc39/notes/blob/main/delegates.txt

[11:17:50.0637] <ryzokuken>
https://github.com/tc39/notes/blob/main/delegates.txt

[11:19:34.0343] <jschoi>
Does anyone have slides for this new presentation?

[11:19:38.0294] <bakkot>
re: current topic, is the string "1234.5678000000000338332029059529304504394531251" supposed to be allowed?

[11:19:43.0015] <jschoi>
I'm assuming they're not on the agenda.

[11:19:43.0123] <shu>
i have a hard time finding "most people are not aware of ieee754" compelling. it permeates to too much of the language beyond just storing values

[11:19:44.0206] <bakkot>
* re: current topic, is the string "1234.567800000000033833202905952930450439453125" supposed to be allowed?

[11:19:57.0261] <ljharb>
they're on the hackmd (via the reflector)

[11:20:10.0057] <Chengzhong Wu>
it's the previous one

[11:20:17.0376] <Chengzhong Wu>
not the one is presenting?

[11:20:42.0552] <Michael Ficarra>
if it's just about u64, it should be parsed by `BigInt()`, not `Number()`

[11:20:49.0920] <ljharb>
oh

[11:21:14.0695] <Michael Ficarra>
> <@bakkot:matrix.org> re: current topic, is the string "1234.567800000000033833202905952930450439453125" supposed to be allowed?

it *has* to be, right?

[11:21:25.0086] <bakkot>
("1234.567800000000033833202905952930450439453125" is notable because it is the exact decimal representation of the float denominated by 1234.5678 in JS)

[11:21:31.0410] <bakkot>
well, as currently written it would not be

[11:21:46.0856] <Michael Ficarra>
don't pay attention to what is written, try to understand what they're going for

[11:22:01.0209] <shu>
this spreadsheet use case is very weird to me

[11:22:02.0874] <Michael Ficarra>
what is written has been wrong a dozen times in the last week

[11:22:06.0586] <bakkot>
I am unclear on what they're going for

[11:22:06.0992] <Jesse (TC39 🇺🇸)>
yes I think so?

[11:22:31.0986] <shu>
if your _initial_ input happens to be representable "exactly" as float64, then you opt into ieee754 _arithmetic_ on the sheet?

[11:22:42.0496] <shu>
if your initial input isn't, then you opt into big decimal arithmetic?

[11:22:53.0413] <bakkot>
"1234.567800000000033833202905952930450439453125" does arguably lose precision, in the sense that when you display the corresponding number to users it is going to be different than the input

[11:22:55.0147] <Michael Ficarra>
yeah that's weird

[11:23:03.0451] <kriskowal>
Last I checked, Uber’s JS API gateway is in this same exact world of pain.

[11:23:15.0926] <bakkot>
so if this is about losing precision _when displaying values_ not just when parsing them, that string should be rejected

[11:23:37.0765] <snek>
so i woke up at 3am and spent like two hours interrogating the examples and motivation and came to the conclusion that they want "MV(str) is MV(F(str))" (assuming that MV(str) is defined to exist).

[11:24:26.0591] <snek>
secondarily, i find the motivation... not motivating enough

[11:24:38.0698] <kriskowal>
I expect a solution to this problem to look more like “can this string be captured in a bigint” (rejecting strings with decimals) and “can this tring be captured in a float64” (rejecting apparent integers with more digits than fit in a mantissa)

[11:24:51.0181] <Michael Ficarra>
> <@devsnek:matrix.org> so i woke up at 3am and spent like two hours interrogating the examples and motivation and came to the conclusion that they want "MV(str) is MV(F(str))" (assuming that MV(str) is defined to exist).

not entirely tru if Kevin is correct above

[11:25:11.0164] <kriskowal>
Or maybe even specifically “can this string be captured in an int64” because that’s what’s going to be important to Java, Go, &c

[11:25:17.0595] <bakkot>
isn't that what they said in the last presentation

[11:25:28.0106] <Michael Ficarra>
> <@bakkot:matrix.org> isn't that what they said in the last presentation

no, read carefully

[11:25:29.0049] <bakkot>
and does that mean "1234.567800000000033833202905952930450439453125" is rejected?

[11:25:59.0647] <bakkot>
well, I guess last presentation also included Number.MAX_SAFE_INTEGER

[11:26:01.0463] <bakkot>
but other than that

[11:26:40.0420] <snek>
i believe that to be equiv

[11:26:57.0949] <snek>
* i believe that to be equiv (but more confusing cuz of the extra tostring decimal representation in the middle)

[11:27:07.0943] <ljharb>
can one currently implement `MV()` in JS in a practical sense?

[11:27:09.0525] <bakkot>
actually, wait, snek did you meant to write `MV(F(str))` or `MV(ToString(F(str))`

[11:27:11.0817] <Michael Ficarra>
I don't think so, because of the way we tostring

[11:27:12.0533] <bakkot>
on the RHS

[11:27:57.0755] <snek>
those are equiv if `Number(ToString(n)) is n` holds, no?

[11:28:01.0318] <ljharb>
ok so does this mean that the use case would be solved with _either_ "give me the MV string of this string" _or_ with a function that implements the screenshotted comparison?

[11:28:28.0978] <snek>
"give me the mv string of this string" is not... a thing

[11:28:34.0489] <Michael Ficarra>
> <@devsnek:matrix.org> those are equiv if `Number(ToString(n)) is n` holds, no?

no

[11:28:40.0455] <jschoi>
The slide link on the HackMD page’s Day 3 section seem to be to the old slides, unless I’m missing something.

[11:29:03.0765] <ljharb>
right, i'm asking if, should we provide such an API, would that suffice (not that i'm proposing that)

[11:29:09.0118] <nicolo-ribaudo>
ryzokuken: Advance the queue

[11:29:15.0010] <snek>
no i mean we can't provide such an api

[11:29:23.0911] <snek>
mv isn't a concrete thing, its the abstract idea of numbers

[11:29:29.0228] <Michael Ficarra>
chairs, please advance the queue

[11:30:54.0429] <Michael Ficarra>
I think we're getting at the key part here: this proposal is *both* about representing a float and presenting a float to the user

[11:31:11.0033] <bakkot>
we can absolutely provide it if we want to

[11:31:25.0539] <ljharb>
i assumed we could just provide a string representing it

[11:31:35.0253] <snek>
you mean just as the substring of the source code for that value?

[11:31:39.0858] <sffc>
My suggestion for the exact condition to determine if a number is safe: https://github.com/Lxxyx/proposal-number-is-safe-numeric/issues/3

[11:31:42.0471] <ljharb>
and then you can literally type `MV(str) === MV(String(+str))` in your code

[11:32:08.0023] <bakkot>
oh I meant we could provide "give me the string which is the exact decimal representation of this double"

[11:32:23.0673] <snek>
oh, i don't think that's what ljharb means

[11:32:25.0261] <bakkot>
or if we had decimal we could have it give you the decimal

[11:32:40.0193] <bakkot>
every double has a (very) finite decimal representation so it's feasible

[11:33:25.0474] <nicolo-ribaudo>
We have that, right? `.toFixed(n)` with the highest n that doesn't throw (34?)

[11:34:32.0665] <bakkot>
exact decimal representations don't have trailing zeros but you could trim those off I guess

[11:34:38.0834] <bakkot>
also you need more than 34

[11:34:53.0776] <Michael Ficarra>
I think it's bounded at 100

[11:35:18.0215] <Jesse (TC39 🇺🇸)>
maybe better would be toPrecision(34)

[11:35:23.0972] <bakkot>
you might need 1076

[11:35:26.0334] <bakkot>
so

[11:35:31.0421] <bakkot>
bounded at 100 is not going to do it

[11:35:43.0693] <ljharb>
(ES2018 bumped it up to 100)

[11:35:50.0477] <ljharb>
* (ES2018 bumped it up to 100, iirc)

[11:35:58.0298] <Michael Ficarra>
```
> 1234.5678.toFixed(101)
Uncaught RangeError: toFixed() digits argument must be between 0 and 100
    at Number.toFixed (<anonymous>)
```

[11:36:13.0460] <snek>
i'm fine with raising the limits of toFixed to any arbitrary amount. i find this proposal unconvincing though.

[11:36:16.0685] <Michael Ficarra>
looks like an implementation restriction

[11:36:20.0820] <bakkot>
(2.22507385850720187716e-308 is the smallest double and its representation has 1074 digits after the `0.`)

[11:36:36.0321] <nicolo-ribaudo>
But that's not a solution to this proposal, that check would return false for `0.1`

[11:36:36.0927] <bakkot>
* (2.22507385850720187716e-308 is the smallest normal double and its representation has 1074 digits after the `0.`)

[11:36:46.0752] <snek>
yes that's why i mentioned it separately

[11:39:41.0106] <Michael Ficarra>
we don't need a proposal to see if a string remains unchanged after round-tripping through floats, you can just do `String(+s) === s`

[11:40:01.0897] <nicolo-ribaudo>
That doesn't work with notations like `.1` and `1e4`

[11:40:21.0541] <Michael Ficarra>
`String(parseFloat(s)) === s`

[11:40:23.0496] <snek>
it also doesn't work for `0,1`, which this proposal doesn't solve

[11:40:45.0603] <bakkot>
you don't want "string remains unchanged", you want "MV of the string remains unchanged"

[11:40:49.0639] <bakkot>
which is harder!

[11:40:51.0536] <nicolo-ribaudo>
`String(parseFloat("1e1") === "10"`

[11:40:53.0930] <shu>
yeah i'm also not convinced the serialization use case can't be done with existing APIs

[11:41:08.0333] <Michael Ficarra>
> <@bakkot:matrix.org> you don't want "string remains unchanged", you want "MV of the string remains unchanged"

not for Kris's serialisation use case as I understand it

[11:42:17.0592] <Michael Ficarra>
> <@nicolo-ribaudo:matrix.org> `String(parseFloat("1e1") === "10"`

that's expected, right?

[11:42:28.0490] <bakkot>
I guess I did not understand that use case

[11:42:37.0079] <nicolo-ribaudo>
I would expect the solution to this proposal to return there in that case

[11:42:41.0840] <nicolo-ribaudo>
* I would expect the solution to this proposal to return true in that case

[11:46:15.0805] <bakkot>
also I keep mentioning this but in fact the spec allows freedom in some cases for what the ToString of a number even is, so this would not be the same on all platforms

[11:46:20.0452] <Michael Ficarra>
man, the word "represent" is really causing us some problems this meeting

[11:46:27.0508] <Michael Ficarra>
we keep using it in different ways

[11:46:40.0281] <Michael Ficarra>
"represent" often means "stands in for" (even if different)

[11:46:50.0417] <Michael Ficarra>
people keep using it to mean "is 1-1 with"

[11:46:53.0524] <snek>
we should stop having decimal be the default serialization of numbers in js

[11:46:57.0406] <Jesse (TC39 🇺🇸)>
"exact representation"

[11:46:59.0413] <snek>
just show the 64 bits

[11:47:46.0172] <Michael Ficarra>
> <@devsnek:matrix.org> just show the 64 bits

better yet, show the range of exact decimal values

[11:47:51.0675] <bakkot>
we should always have had the default serialization be the full exact value

[11:47:57.0878] <Jesse (TC39 🇺🇸)>
y'all making me cry

[11:48:07.0655] <bakkot>
that would also solve the `0.1 + 0.2` problem

[11:48:08.0269] <kriskowal>
I agree with shu  that using isSafeNumeric to decide whether it’s safe to capture a stringy number in either a number or decimal is unsound.

[11:48:18.0271] <bakkot>
because you'd write `0.1` in the console and it would print as something else

[11:48:31.0198] <ljharb>
as an f64, can you not use Float64Array to do that?

[11:48:40.0555] <bakkot>
you can use a Float64 array to read the bits, yes

[11:48:50.0679] <shu>
%a baby

[11:48:52.0230] <bakkot>
you can't use it to read the exact decimal representation

[11:48:53.0874] <bakkot>
that's harder

[11:48:58.0566] <ljharb>
no i mean, put the number in, pull it out, and compare the result?

[11:49:05.0349] <bakkot>
nnnnno

[11:49:07.0537] <littledan>
but it's not pretty enough!

[11:49:08.0079] <ljharb>
oh but you mean producing an f64 string is harder, gotcha

[11:49:14.0518] <bakkot>
putting a number into a Float64Array doesn't do... anything

[11:49:19.0958] <Jesse (TC39 🇺🇸)>
would be funny to have some kind of range semantics: you typed "x", but the best I can do is *this range of things here, pick one*

[11:49:36.0420] <ljharb>
oh

[11:49:46.0157] <kriskowal>
The alternate problem statement I proposed is much more consistent an int32 to Number parser that rejects integers in the int64 upper range, or an float64 to Number parser that rejects strings that express numbers that can only be faithfully captured in decimal

[11:49:47.0639] <bakkot>
it's already a Float64

[11:50:10.0236] <bakkot>
kriskowal: can you state your problem statement again?

[11:50:11.0714] <ljharb>
right

[11:50:16.0745] <shu>
i say this without judgment: i think nicolo's idea to get people to understand IEEE754 is the most actionable next step. i get the feeling people are ascribing utility to the proposal based on misunderstanding of how floats work

[11:50:32.0455] <shu>
utility at best, soundness at worst

[11:50:41.0559] <ljharb>
http://www.2ality.com/2012/04/number-encoding.html is a great read on the topic, i believe

[11:50:58.0529] <nicolo-ribaudo>
I see that the person who I would like to volunteer reacted with 👍️!

[11:51:35.0112] <bakkot>
that is a good article but does not sufficiently emphasize that the actual value represented by the JS number `0.1` is in fact a different mathematical number

[11:51:46.0156] <nicolo-ribaudo>
Maybe I'll give the presentation if nobody else wants to, but not at the next meeting

[11:52:01.0239] <bakkot>
and that float represents many different mathematical numbers

[11:52:07.0903] <bakkot>
* and that JS number represents many different mathematical numbers

[11:52:35.0677] <Andreu Botella>
i just want a presentation full of words like "recurring decimal in base 2"

[11:53:04.0854] <snek>
this is somewhat good but still misses out on some of the big aha moments i think https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html

[11:53:09.0847] <kriskowal>
For purposes of interoperating with other languages that are obliged to represent their native int64 and decimal types as strings for transmission through JSON, JavaScript would benefit from methods for parsing int32 to number and parsing float64 to number, rejecting strings that are out of the range that can be safely captured by those types.

[11:53:28.0186] <bakkot>
process point: if multiple people have expressed that they are uncomfortable with stage advancement, I would like chairs to not ask for stage advancement or ask if anyone is "withholding consensus"

[11:53:35.0214] <bakkot>
if multiple people have expressed that they are uncomfortable with stage advancement it is clear we do not have consensus

[11:53:36.0963] <Michael Ficarra>
> <@nicolo-ribaudo:matrix.org> I see that the person who I would like to volunteer reacted with 👍️!

furiously trying to recall whether I reacted with :+1: before this

[11:53:43.0131] <bakkot>
making people actually say "I personally am stopping this" is bad

[11:53:45.0326] <Michael Ficarra>
* furiously trying to recall whether I reacted with 👍️ before this

[11:54:56.0132] <bakkot>
what does "out of the range that can be safely captured by those types" mean

[11:55:01.0249] <bakkot>
does that include `"0.1"` or not

[11:55:15.0482] <Richard Gibson>
even this seems ill-defined... would such a function accept or reject `0.3`? What about `0.30000000000000004`?

[11:55:38.0044] <Richard Gibson>
* even this seems ill-defined... would such a function accept or reject `"0.3"`? What about `"0.30000000000000004"`?

[11:56:54.0558] <kriskowal>
I reject the problem of discriminating a safe subset of decimal or int64 for representation in float64. If the sender is using a string, a JavaScript program that manipulates it needs to use the corresponding native representation, albeit bigint for int64. I  accept that a function for serializing bigint to stringy representations of int64 is useful if it handles overflow either with throw or wrap.

[11:57:38.0012] <Jesse (TC39 🇺🇸)>
what's interesting about this is that there's such a concrete developer pain here but so hard to pin down what the problem is

[11:57:39.0866] <kriskowal>
And I also reject that it’s okay to capture decimal in a number for purposes of presenting the same precision to the user. For that, the original string should always suffice.

[11:58:40.0489] <littledan>
Please nominate breakout session topics at https://github.com/tc39/Reflector/issues/552

[11:58:42.0575] <shu>
my reluctance is that developer pain feels awfully close to the blanket "ieee754 is counterintuitive and a pain", which isn't a problem we can solve with a helper function

[11:59:06.0899] <kriskowal>
I agree, the problem of truncating int64 is much more interesting than mishandling string representations of decimal. Whether another language is providing a decimal or float64 is very clearly discriminated by whether it’s captured in a JSON string or number

[12:01:41.0406] <kriskowal>
That is, if you receive an integer as a string, the sender either represented that as int64 or decimal. The API proxy should be in a position to know which is which and parse it accordingly.

[12:02:36.0433] <kriskowal>
Yeah, I am resigned that even my generous interpretation suggests an underlying misunderstanding of the architecture problem.

[12:03:07.0238] <kriskowal>
Which is definitely common, but can’t be solved with more methods.

[12:05:35.0907] <kriskowal>
And I’m almost absolutely certain that every company using JavaScript as an API proxy for terminating HTTP JSON and forwarding or fanning out to Java and Go is also truncating enums that weren’t in the IDL whenever the API proxy was last deployed.

[12:09:19.0701] <Richard Gibson>
at what time is the meeting resuming?

[12:14:24.0346] <bakkot>
Presumably top of the hour

[12:14:49.0980] <ZiJian Liu>
Thank you all for the feedback on Number.isSafeNumeric, this has been a rare experience and journey for me, I will continue to improve the proposal, thank you all for your guidance 😆

[12:24:02.0165] <kriskowal>
Know that Alibaba is not alone. JavaScript’s mismatched number type tower with most languages is a headache felt everywhere.

[12:25:59.0114] <Chris de Almeida>
appreciate this feedback.  we need to be clear though.  it is common that people express reservations or dissent but do not intend to outright block advancement.  we also saw that some folks had modified their stances.  it is also common when someone is blocking to ask them to clearly state their reasons FTR. someone may say they are, e.g. "unconvinced" and sometimes this implies a block, and sometimes it does not.  we need to err on the side of being clear and unambiguous

[12:28:41.0492] <ZiJian Liu>
Yes, I have to deal with similar issues every day, which gives me a headache. Thank you for your feedback, it made me realize that I need to improve my perspective on the problem. Perhaps looking at the issue from the perspective of the entire JavaScript system would be a more suitable problem-statement.

[12:29:28.0623] <ljharb>
however, it's also better to err on the side of non-advancement - an easily fixable problem if there's consensus for it - rather than advancement, which is much harder to "fix" if there's not.

[12:31:15.0160] <Chris de Almeida>
sure.  in that case, you are referring to committee decision, correct?  (in any case, the stakes are much lower at stage 1, but I don't disagree)

[12:43:29.0243] <canadahonk>
📣 ~15 mins left to suggest breakout sessions https://github.com/tc39/Reflector/issues/552

[13:00:55.0316] <bakkot>
I don't think we ought to think of this in terms of "is there a block or not": that equates "consensus" with "no explicit blocking". I disagree with that. We say that "explicit blocking" implies "not consensus" but I don't think that this means "no explicit blocking" implies "consensus". And I think if at least two people have publicly stated they are not convinced (and there is not a huge upswell of support from everyone else), then this is clearly not consensus.

[13:01:48.0367] <bakkot>
Specifically, it can be the case that there is clearly not consensus _even if no one has explicitly stated that they are blocking_.

[13:01:57.0453] <bakkot>
And I don't think we ought to ask people if they are "blocking" in that case.

[13:02:36.0966] <bakkot>
A delegate can insist, of course, but it should not be the default.

[13:02:50.0301] <bakkot>
* A delegate can insist, but it should not be the default.

[13:03:04.0653] <Chris de Almeida>
there were several people who supported advancement, and there were some folks who changed from negative to positive positions.  in the end, the chairs are not comfortable making the decision for the committee, and we were not clear on what the result was

[13:05:20.0496] <bakkot>
That's fair, but even in such cases I would like to phrase this as asking the committee whether we have consensus, rather than asking specific people if they're blocking.

[13:06:06.0412] <bakkot>
I personally at least am much more comfortable saying "I don't think we have consensus" (even in cases when I support a proposal!), on the basis of people's expressed discomfort, than I am saying "I am blocking"

[13:06:10.0090] <ptomato>
what do you see as the material difference between those two things?

[13:06:51.0906] <bakkot>
"whether the committee has consensus" is something one can have an opinion on without necessarily having an opinion on the whole proposal

[13:06:56.0804] <Chris de Almeida>
I hear you.  but this is exactly the issue -- we sometimes get a response like "I don't think we have consensus".  that is not a definite conclusion

[13:06:58.0270] <bakkot>
* "whether the committee has consensus" is something one can have an opinion on without necessarily having an opinion on the proposal itself

[13:07:11.0805] <bakkot>
It is a definite conclusion unless someone disagrees with it

[13:07:40.0828] <Chris de Almeida>
so then we are getting a meta-consensus on whether we agree that we don't have consensus?

[13:08:41.0623] <bakkot>
if it comes to that, sure

[13:09:16.0505] <bakkot>
I don't think it is usually going to be the case that there is wide disagreement about whether we have consensus unless there was only one person who objected to something

[13:09:53.0235] <bakkot>
or if someone says "I think we have consensus" and other people say "no, actually I didn't like that and didn't speak up" or something

[13:09:56.0418] <bakkot>
which can happen!

[13:10:15.0173] <bakkot>
but that's a discovery of new information rather than a disagreement _per se_

[13:10:26.0857] <snek>
how do the "syntax bar is very high" folks feel about this possible statement on syntax

[13:10:51.0571] <bakkot>
well

[13:11:03.0247] <bakkot>
I would drop the "where desugarging is not possible" part

[13:33:23.0993] <Michael Ficarra>
what's the value of actually getting "consensus" here instead of just understanding this point?

[13:34:05.0898] <Michael Ficarra>
we're not binding ourselves to anything in particular, these are just suggestions about what we "should" think about

[13:34:36.0733] <Michael Ficarra>
I guess @nicolo-ribaudo:matrix.org's topic may cover this

[13:35:14.0741] <Ashley Claymore>
For `using`, the request is that the desugaring is simpler for engines.
But it sounded like shu said that if the desugaring is simple then that's a motivation to not implementing it at all?

[13:35:24.0431] <shu>
correct

[13:35:50.0397] <Ashley Claymore>
I interpret this to mean syntax should be neither simple or complex to transform

[13:35:54.0847] <bakkot>
incidentally the using issue is https://github.com/tc39/proposal-explicit-resource-management/issues/215

[13:36:06.0137] <bakkot>
it is _technically_ pure sugar but it's really annoying in this one edge case

[13:36:11.0405] <bakkot>
* incidentally the `using` issue is https://github.com/tc39/proposal-explicit-resource-management/issues/215

[13:36:52.0853] <bakkot>
so, maybe littledan's proposal should be understood to mean we eliminate this sharp not-quite-sugar edge that provides little corresponding benefit

[13:37:06.0342] <bakkot>
(or would do so were the proposal coming through the process now)

[13:37:28.0312] <shu>
i interpret it to mean that if you want a pure DX syntax that's a nice, easy, local transform, that sounds good, i see no reason for engine support there to get most of the benefit of such a proposal

[13:37:38.0761] <nicolo-ribaudo>
Would this mean consider transpiler "implementer feedback" as first class as browser implementer feedback during stage 3?

[13:37:41.0388] <shu>
but i'd support such a feature to be blessed as standard

[13:37:43.0138] <Michael Ficarra>
can somebody screenshare the captured queue?

[13:37:56.0808] <Michael Ficarra>
@robpalme:matrix.org ^?

[13:38:17.0464] <bakkot>
yes though also browsers are often basically transpilers for sugar, so there's not that much difference

[13:39:32.0867] <Michael Ficarra>
returning to overflow items is giving me whiplash

[13:39:40.0955] <Michael Ficarra>
people need to set better timeboxes

[13:39:50.0773] <Ashley Claymore>
that makes sense. I personally marry this with improved dev-tooling where the tooling transform can be made more transparent to the developer.

[13:43:42.0615] <ljharb>
"2 must support", when did we make that a requirement? i don't see it in the process doc

[13:43:57.0700] <ljharb>
i know it's ideal but it seems like it quietly evolved in people's minds to be a requirement over time

[13:44:16.0586] <bakkot>
we did make it explicit at some point

[13:44:19.0135] <nicolo-ribaudo>
I remeber having an explicit process discussion about it ~2 years ago

[13:44:19.0436] <bakkot>
should have written it down

[13:44:27.0109] <Chris de Almeida>
I recall this

[13:44:46.0981] <Chris de Almeida>
I don't recall where it got documented

[13:44:50.0542] <Chris de Almeida>
(or if)

[13:44:52.0140] <ljharb>
a notes link would be good, and someone should make a PR to the process doc then

[13:45:02.0906] <ljharb>
because i recall it coming up but my feeling is that it was never made a requirement, just a guideline/ideal

[13:45:38.0833] <littledan>
I did write it down somewhere, let me find it...

[13:45:38.0980] <bakkot>
here we go https://github.com/tc39/notes/blob/main/meetings/2023-01/jan-30.md#a-procedure-for-multiple-active-supporters-in-committee-to-achieve-consensus

[13:45:51.0800] <bakkot>
it's still in PR, linked from that notes section

[13:46:12.0316] <ljharb>
https://github.com/tc39/notes/blob/main/meetings/2023-01/jan-30.md#conclusionresolution is the conclusion

[13:46:26.0565] <littledan>
ah sorry about that... https://github.com/tc39/how-we-work/pull/122

[13:46:34.0431] <littledan>
does anyone want to pick this up?

[13:46:58.0741] <Chris de Almeida>
I nominated JHD

[13:47:12.0992] <Chris de Almeida>
* I nominate JHD

[13:47:14.0758] <ljharb>
ahhh voluntold

[13:48:28.0720] <littledan>
I did ask in that PR whether it should move into the process-document and no one answered. Any thoughts here?

[13:48:52.0829] <ljharb>
i think probably polishing the wording in how-we-work, and then separately, adding a quick sentence to the process doc that links to it?

[13:49:07.0406] <Michael Ficarra>
> <@ljharb:matrix.org> i think probably polishing the wording in how-we-work, and then separately, adding a quick sentence to the process doc that links to it?

yeah that sounds right

[13:49:33.0615] <littledan>
OK sure sounds good thanks

[13:55:58.0303] <littledan>
last call on additional breakout session topics: https://github.com/tc39/Reflector/issues/552

[13:56:26.0934] <Michael Ficarra>
when do we vote?

[13:56:59.0240] <Michael Ficarra>
* when do we vote on breakout sessions?

[13:58:00.0972] <littledan>
right after this session

[13:58:18.0992] <littledan>
actually you can already vote if you feel like it, since the last call on breakout session topics was an hour ago in principle

[13:59:01.0982] <littledan>
the voting link is a comment in that thread

[14:00:35.0280] <Michael Ficarra>
have we ever had a single-member veto for Stage 4 advancement?

[14:00:46.0883] <shu>
yeah what are we solving for there

[14:00:47.0902] <shu>
i'm confused

[14:00:54.0293] <ljharb>
yes, on two occasions.

[14:01:00.0256] <shu>
oh really?

[14:01:19.0398] <ljharb>
but as i said to mark, i don't think that "3 → 4" is actually the problem michael and sympathizers are trying to solve

[14:02:58.0416] <shu>
i really want to hear what chip has to say

[14:03:05.0037] <shu>
very ominous phrasing

[14:03:09.0098] <nicolo-ribaudo>
> <@ljharb:matrix.org> yes, on two occasions.

What were they?

[14:03:14.0634] <snek>
i feel like really bad moments in the process are rare enough in comparison to all the time that it works that they are a better fit for e.g. per-occurrence CoC as mentioned before, rather than full rule changes.

[14:03:19.0096] <snek>
* i feel like really bad moments in the current process are rare enough in comparison to all the time that it works that they are a better fit for e.g. per-occurrence CoC as mentioned before, rather than full rule changes.

[14:03:22.0355] <ljharb>
dynamic import, and private fields `in`

[14:03:24.0618] <littledan>
yeah no we figured this out during class fields

[14:03:48.0244] <ljharb>
the former was good faith and ended up being bypassed by shipping on the web outside the committee, the latter ended up being resolved by updating the process doc.

[14:03:56.0194] <ljharb>
* the former was good faith and ended up being bypassed by shipping on the web outside the committee during the intervening years, the latter ended up being resolved by updating the process doc.

[14:04:04.0090] <snek>
was that the 360 thing? 

[14:04:07.0986] <ljharb>
yes

[14:05:27.0453] <shu>
look of course nobody wants rules

[14:05:43.0450] <shu>
but this is the only technology we have to scale social interaction! this is like, the history of civilization!

[14:07:18.0493] <Michael Ficarra>
> <@devsnek:matrix.org> was that the 360 thing? 

360 thing?

[14:07:23.0981] <shu>
my disagreement with mark is that mark's world is great is everyone was a mark

[14:07:28.0702] <shu>
which is very much not the case

[14:07:38.0833] <snek>
the member org was called 360

[14:07:46.0965] <bakkot>
this is what dan is currently saying

[14:07:49.0531] <bakkot>
I agree also

[14:08:21.0171] <bakkot>
browser markers also have a de-facto anti-veto

[14:08:25.0360] <bakkot>
they can just implement things if they want to!

[14:08:32.0751] <bakkot>
cf `import()`

[14:08:44.0972] <nicolo-ribaudo>
Do browsers have a veto? Like, if Goggle and Mozilla were to implement something, would Apple keep refusing?

[14:08:54.0032] <nicolo-ribaudo>
* Do browsers have a veto? Like, if Google and Mozilla were to implement something, would Apple keep refusing?

[14:08:58.0497] <ljharb>
that'd be up to market pressures

[14:08:59.0885] <jschoi>
Tail-call optimization.

[14:09:01.0625] <bakkot>
*cough* PTC *cough*

[14:09:01.0879] <shu>
browsers as a category do not have a unitary veto, it is unstable for that exact reason. interop risk is real

[14:09:02.0286] <jschoi>
* Tail-call optimization, right?

[14:09:19.0121] <shu>
i think that speaks more to PTC the feature than the general pressure

[14:09:27.0664] <bakkot>
yeah that's a special case

[14:09:31.0841] <shu>
like, you know, see captureStackTrace

[14:10:18.0330] <littledan>
oops, we really should've put msaboff's topic before mine

[14:10:23.0362] <littledan>
I didn't realize he was leaving right now

[14:12:06.0740] <bakkot>
I am probably also going to have to leave before getting to my point, which is this: we should consider requiring a higher bar to block proposals which have a higher level of support. if only one or two people are enthusiastic a feature, then a single person who is anti-enthusiastic ought to be enough to stop it going forward. if many people are enthusiastic about a feature, possible we should require more than single person who is anti-enthusiastic to stop it going forward.

[14:12:16.0541] <littledan>
+1 to what Erik Marks says

[14:15:55.0619] <canadahonk>
if someone really wanted to they could argue all browser vendors are one financial entity

[14:16:23.0497] <snek>
several governments are doing that rn

[14:16:36.0434] <Michael Ficarra>
we all derive our livelihoods from web technologies existing

[14:16:48.0299] <canadahonk>
that's not what i meant :P

[14:16:49.0188] <Michael Ficarra>
is this collusion?

[14:17:17.0239] <shu>
standardization is literally legal collusion, yes

[14:17:33.0468] <shu>
that's why we do it, so it's not illegal

[14:17:39.0083] <shu>
we = all of us, not google

[14:18:04.0730] <littledan>
yeah, antitrust law has specific carveouts to encourage standards

[14:18:19.0176] <jschoi>
“Big Tech” as homogenous monolith.

[14:18:37.0524] <rekmarks>
Much like "Government"

[14:18:39.0614] <littledan>
it was initially unclear whether companies could even collaborate on open source, whether that would consist of an antitrust violation. We're all past that now, though

[14:18:54.0518] <canadahonk>
big government want to take away your javascript!!

[14:19:07.0590] <jschoi>
“All standards must be de facto.
“No, actually, de facto standards are collusion too.”

[14:19:24.0370] <jschoi>
* “All standards must be de facto.
“No, actually, de facto standards are collusion too. Every company must design their own power plug.”

[14:19:45.0829] <littledan>
yeah, standards bodies organize themselves to have uniformly open membership and such so that they don't constitute collusion

[14:20:04.0076] <snek>
uniformly open to those with deep pockets

[14:20:14.0939] <snek>
oh sorry this is not tdz

[14:21:40.0043] <littledan>
well, Ecma, Unicode and W3C genuinely have membership open

[14:22:11.0358] <littledan>
and we all genuinely do the technical development work through committees of membership

[14:22:49.0477] <jschoi>
* “All standards must be de facto. No, actually, de facto standards are collusion too. Every company must design their own power plug.”

[14:23:28.0435] <littledan>
(the WHATWG antitrust legal argument is more subtle, though...)

[14:25:56.0956] <nicolo-ribaudo>
Reflector link for breakout sessions: https://github.com/tc39/Reflector/issues/552

[14:26:12.0373] <canadahonk>
📣 https://github.com/tc39/Reflector/issues/552#issuecomment-2672116236 vote 🫵

[14:32:10.0376] <Chengzhong Wu>
 do we still use the tcq during the breakout sessions? 

[14:33:13.0258] <nicolo-ribaudo>
Probably depends on the size of each session. Creating TCQ meeting is open, so facilitators can do it 

[14:35:11.0947] <rbuckton>
I'm unclear as to which sessions are overlapping, as I'd like to participate in both the TS discussion and the pattern matching one

[14:43:54.0113] <rbuckton>
Can we post the final list of breakouts somewhere for the remote attendees? 

[14:44:32.0028] <rekmarks>
Will there be zoom meetings for the breakouts?

[14:49:13.0166] <nicolo-ribaudo>
These are the ones happening 

[14:49:28.0982] <Rob Palmer>
If anyone wants to dial-in to the workgroup on Type Annotations that Mark Miller has proposed, please dial into the zoom that we used for plenary now.  It will run for the next 40 mins until 15:30PT.

[14:49:30.0117] <nicolo-ribaudo>
1 starting soon, and 2 later

[14:49:46.0142] <nicolo-ribaudo>
Facilitators will share a call link

[14:49:54.0150] <rbuckton>
So annotations and pattern matching overlap? That's unfortunate.

[14:50:00.0336] <shu>
i have no idea what's happening for remotes

[14:50:10.0514] <Rob Palmer>
Remotes can dial in.

[14:50:14.0246] <shu>
does anyone would like me to attend any of the sessions

[14:50:23.0973] <shu>
* does anyone want me to attend any of the sessions

[14:51:46.0334] <shu>
lol what is that map

[14:51:49.0613] <littledan>
attend whichever session you're interested in. I'd be happy if you joined the JSSugar discussion

[14:51:50.0731] <shu>
is that a map of intenstines

[14:52:00.0015] <shu>
* is that a map of intestines

[14:52:08.0024] <nicolo-ribaudo>
That's my art

[14:52:23.0398] <sffc>
Small JS Engines meet link https://meet.google.com/csp-utwi-cqy

[14:53:43.0509] <littledan>
Is anyone interested in pattern matching? It's just Luca and me here; we'll close this session if no one wants to join

[14:54:32.0353] <rbuckton>
I would join remotely

[14:54:43.0861] <littledan>
OK perfect, I'll set up a zoom now

[14:55:08.0324] <littledan>
pattern matching call: https://bloomberg.zoom.us/j/93962399209?pwd=Uwg6q9dCYMWBNRTCux51qgKgW2uah4.1

[15:09:59.0453] <rekmarks>
Is there a tcq for type stripping?

[15:11:31.0246] <nicolo-ribaudo>
Rob Palmer^

[15:14:18.0227] <canadahonk>
when does breakout session #1 officially end?

[15:14:31.0078] <littledan>
3:20

[15:14:58.0024] <Rob Palmer>
[Type Annotations discussion doc](https://docs.google.com/document/d/1zh4qMrO3PPWXd6ro4e2jZSSZXMrYsDx5gO2fosQax0M/edit?tab=t.0)

[15:16:25.0024] <Michael Ficarra>
ecma262 PR burn-down break-out session video call: https://f5networks.zoom.us/j/2545766102

[15:16:33.0006] <Michael Ficarra>
starting in 9 minutes

[15:23:18.0446] <naugtur>
There will likely be pressure on the engines to do the erasing transparently like Deno supporting TS created pressure on Node.js to do something, so eventually it will happen.
If the syntax allowed the parser to, after finding an opening sequence, ignore all characters until a specific character or short sequence is reached, that would make the cost of ignoring it similar to leaving whitespace in.
Is that option on the table at all?

[15:23:41.0449] <sffc>
Stdlib breakout notes: https://docs.google.com/document/d/17u9l-TRdEasF5cKHJnTmcBUNRqGQpsYxLNraV8sChfw/edit?tab=t.0

[15:25:46.0711] <littledan>
session two starting now

[15:26:33.0430] <littledan>
Continuation of layering/JSSugar discussion starting now in https://bloomberg.zoom.us/j/98987937963?pwd=fSfw9H9kwiZ3269am0s5v3bT9k4TRO.1

[15:26:49.0112] <littledan>
shu: it'd be great if you joined 

[15:27:03.0860] <shu>
is that happening now?

[15:27:09.0359] <rekmarks>
Ashley Claymore: what is the turbofish thing? Is it documented anywhere?

[15:27:09.0955] <shu>
this is already different from the photo of the whiteboard

[15:28:07.0218] <rekmarks>
> <@shuyuguo:matrix.org> this is already different from the photo of the whiteboard

It turned out some of the intestines were vestigial

[15:30:04.0323] <Ashley Claymore>
I'll find a link. But it's:

TypeScript: `new Set<T>([])`, would be written as `new Set::<T>([])`

[15:30:20.0981] <Ashley Claymore>
because `new Set<T>([])` is already valid JS

[15:30:30.0815] <ljharb>
would TS add a setting to require the syntax and forbid the old?

[15:30:55.0131] <Ashley Claymore>
I can't speak for TS but I think that would add a lot of value

[15:31:05.0776] <ljharb>
if TS users were pushed into only using the erasable subset then that might actually approach the “unfork” goal

[15:31:16.0475] <ljharb>
otherwise i don’t think it achieves it

[15:32:05.0535] <Ashley Claymore>
danielrosenwasser and I were talking about transforms that VSCode (and other IDEs) could do when a file is renamed from `.js` to `.ts`.
The turbofish could be one that is applied when renaming `.ts` to `.js`

[15:32:36.0476] <Ashley Claymore>
as one idea

[15:32:49.0160] <Anthony Bullard>
That should be a LSP thing, not VSCode

[15:33:07.0267] <ljharb>
unforking can’t happen without a clear/likely path to.ts and .tsx etc dying out

[15:34:03.0842] <Anthony Bullard>
And getting rid of enums

[15:34:07.0672] <rekmarks>
“unfork” meaning “it all literally is the same language”?

[15:34:21.0096] <rekmarks>
(while ensuring no runtime costs for engines)

[15:34:27.0921] <ljharb>
yep

[15:34:38.0075] <Anthony Bullard>
rekmarks: I think it means TypeScript is an implementation of a Type system for JavaScript and nothing else 

[15:34:46.0108] <ljharb>
that TS users are only using tsc to typecheck, basically

[15:35:01.0580] <ljharb>
it could be an optional downleveler, i suppose

[15:35:20.0993] <ljharb>
presumably there’d also be an easy transform from tsdoc to this new syntax

[15:35:35.0156] <rekmarks>
Getting erasure-only as a `tsc` compiler option would be an amazing start

[15:35:55.0043] <ljharb>
there’s other issues beyond that, but one of the primary goals is unforking, and i can’t see how that end state isn’t a requirement for unforking to be achieved.

[15:36:20.0041] <Anthony Bullard>
> <@ljharb:matrix.org> presumably there’d also be an easy transform from tsdoc to this new syntax

This is a relatively trivial transform to write today, and would be surprised to find that one does not exist in the wild today

[15:50:50.0932] <Anthony Bullard>
Strangely the only ones I can find covert JSDoc to d.ts files and not inline

[15:51:58.0656] <rbuckton>
There's been some interest from some of the NodeJS maintainers about trying to bring `enum` back to TC39, in part so that it could be used in a type-stripping only mode, just based on the sheer number of TS developers using `enum`.

[15:53:02.0319] <rbuckton>
`enum` does have some advantages over `{}`, especially when working with numbers/bitflags.

[15:54:33.0067] <Anthony Bullard>
Enum with its current TS implementation is considered an anti-pattern today, not to say that a native enum implementation in ES would not be much better (since most C-like languages have them)

[15:55:06.0043] <James M Snell>
> <@rbuckton:matrix.org> There's been some interest from some of the NodeJS maintainers about trying to bring `enum` back to TC39, in part so that it could be used in a type-stripping only mode, just based on the sheer number of TS developers using `enum`.

My feelings are..... Mixed. I think it would be unfortunate to bring back but also there would be definite advantages

[15:55:20.0287] <rbuckton>
Which parts are what you'd consider an anti-pattern?

[15:55:48.0739] <James M Snell>
Largely just in terms of expanding language syntax

[15:59:00.0615] <rbuckton>
`enum` has the benefit of defining a closed domain of values. You can do that in a limited way with `{}`, but without some of the convenience like:
```ts
enum Flags {
  None,
  Flag1 = 1 << 0,
  Flag2 = 1 << 1,
  Mask = Flag1 | Flag2,
}
// vs
const Flags = {
  None: 0,
  Flag1: 1 << 0,
  Flag2 : 1 << 1,
  Mask: (1 << 0) | (1 << 1)
}
// or
Flags.Mask = Flags.Flag1 | Flags.Flag2;
```


2025-02-21
[16:01:19.0107] <rbuckton>
And I do think there's a world where `enum` could be extended to support ADTs, e.g.:
```ts
enum Message {
  Quit,
  Write(text),
  Move({x, y}),
}
```

[16:01:33.0260] <canadahonk>
Rob Palmer: do you have the link to the stdlib breakout session notes?

[16:02:41.0373] <canadahonk>
* Rob Palmer: do you have the link to the stdlib breakout session notes? nvm

[16:04:40.0515] <bakkot>
did you mean https://devblogs.microsoft.com/typescript/announcing-typescript-5-8-rc/#the---erasablesyntaxonly-option ?

[16:08:08.0286] <canadahonk>
📣 come back to the main plenary room for a summary of breakouts

[16:09:00.0955] <rekmarks>
> <@bakkot:matrix.org> did you mean https://devblogs.microsoft.com/typescript/announcing-typescript-5-8-rc/#the---erasablesyntaxonly-option ?

Another reason I love TypeScript is that they frequently know what I want—and give it to me—before I do

[16:10:20.0907] <sffc>
I'll take notes of the summaries of the presentatoins in https://docs.google.com/document/d/17u9l-TRdEasF5cKHJnTmcBUNRqGQpsYxLNraV8sChfw/edit?tab=t.0

[16:13:17.0013] <rekmarks>
> <@anthonybullard:matrix.org> Enum with its current TS implementation is considered an anti-pattern today, not to say that a native enum implementation in ES would not be much better (since most C-like languages have them)

+1, although current TS enums have some nice properties, they are ultimately inessential

[16:16:17.0072] <rbuckton>
I'd still like to hear feedback as to what exactly is considered an anti-pattern regarding `enum`? The two things I've heard have been:
- Don't use `enum` in TS because it's not in ES
- `enum` defaulting to numbers and not something like `Symbol()`



[16:17:05.0948] <ljharb>
(considering the alternative is manually defining a fixed set of forgeable strings, or unforgeable but inconvenient objects or symbols, and manually validating those)

[16:17:06.0281] <Ashley Claymore>
Maybe the merging too?

[16:17:22.0741] <rbuckton>
Merging? as in `enum A { ... } enum A { ... }`?

[16:17:45.0374] <Ashley Claymore>
I'd be suprised if a 262 version had that

[16:18:24.0163] <rbuckton>
I agree that's an anti-pattern and is something we probably wouldn't want to carry forward.

[16:21:15.0585] <bakkot>
enums being numbers is also bad, in my opinion

[16:22:38.0574] <bakkot>
it makes it too easy for adding new values to accidentally be a breaking change

[16:23:00.0495] <rbuckton>
Regarding Number vs String vs Symbol, my version of the proposal had a solution to that:

```ts
enum Color of String {
  Red, // "Red"
  Green, // "Geen"
  Blue, // "Blue"
}

enum Kind of Symbol {
  A, // Symbol("A')
  B, // Symbol("B")
}

enum BigFlags of BigInt {
  None, // 0n
  Flag1 = 1n << 0n,
  Flag2 = 1n << 1n,
}

// etc.
```

[16:23:10.0501] <bakkot>
I would be ok with them being strings but at that point you might as well just use strings

[16:23:26.0363] <ljharb>
it's still helpful to simplify validation and enumeration

[16:24:00.0820] <rbuckton>
Numeric enums are the most common in C-like languages, and being numbers might be necessary for TS compat. 

[16:24:24.0510] <bakkot>
yeah the experience from C-like languages is one of the main reasons I am opposed to them being numbers

[16:24:50.0752] <rbuckton>
Due to how existing .d.ts files work, it would be almost impossible to change that default behavior for TS.

[16:25:25.0010] <bakkot>
understandable, and I wouldn't want to add enums which conflicted with TS, but the conclusion I'd draw is that we should not add enums to JS at all

[16:27:05.0333] <ljharb>
would a TS user notice the value of the enum in typical usage? or is it just that a JS consumer would be using it

[16:27:21.0021] <rekmarks>
Re: “enums are an antipattern”, I haven’t verified all of the claims in this myself but have experienced / agree with a plurality of them: https://dev.to/ivanzm123/dont-use-enums-in-typescript-they-are-very-dangerous-57bh

[16:30:43.0480] <rekmarks>
> <@ljharb:matrix.org> would a TS user notice the value of the enum in typical usage? or is it just that a JS consumer would be using it

IME no

[16:32:01.0144] <rekmarks>
> <@rekmarks:matrix.org> Re: “enums are an antipattern”, I haven’t verified all of the claims in this myself but have experienced / agree with a plurality of them: https://dev.to/ivanzm123/dont-use-enums-in-typescript-they-are-very-dangerous-57bh

Note that I can’t replicate the enum type unsafety example in this and have not encountered it previously

[16:33:13.0836] <rekmarks>
* Re: “enums are an antipattern”, I haven’t verified all of the claims in this myself (and it’s a bit sensationalist) but have experienced / agree with a plurality of them: https://dev.to/ivanzm123/dont-use-enums-in-typescript-they-are-very-dangerous-57bh

[16:37:36.0398] <rbuckton>
> <@rekmarks:matrix.org> Re: “enums are an antipattern”, I haven’t verified all of the claims in this myself (and it’s a bit sensationalist) but have experienced / agree with a plurality of them: https://dev.to/ivanzm123/dont-use-enums-in-typescript-they-are-very-dangerous-57bh

Some of those reasons are no longer true. I'll read through and follow up after dinner. 

[16:41:26.0705] <canadahonk>
https://github.com/linusg/ecmascript-wiki

[16:57:03.0720] <rbuckton>
1. Enum's emit code - is irrelevant if `enum` exists natively
2. Numeric types unsafe - this has since been fixed
3. String ENUM's are named types - this does seem to be an odd behavior, though its specific to TS type checking and would be irrelevant to an ES enum

There is an issue with TS `enum` where there are a few cases where an enum member value's emit can be type-directed, but I think that's fixable in TS and wouldn't impact an ES enum.

[17:02:19.0357] <rbuckton>
Also, I still think `Number` values make the most sense for the default, especially when working with `Atomics` (e.g., `.load()`, `.xor()`, etc.) and I/O (protocols, headers, etc.), not to mention bitmasks. I also imagine number comparisons to be generally more efficient than string comparisons. I imagine they're also more readily inlineable into something like a jump table for use with `switch`. Numbers generally just work in most places.

[17:04:09.0028] <rbuckton>
One "compatible" approach I've also considered is that an ES `enum` might *require* the `of` clause if there are any members that are missing initializers. TS `enum` could elide it (as it does today), but emit `enum E of Number {}` to JS.

[17:09:18.0514] <rbuckton>
* One "compatible" approach I've also considered is that an ES `enum` might _require_ the `of` clause if there are any members that are missing initializers. TS `enum` could elide it (as it does today), but emit `enum E of Number {}` to JS, or in the case of auto-numbering, emit `enum E { A = 0, B = 1, ... }` and populate the auto-numbered enums during emit.

[17:45:23.0941] <Ashley Claymore>
do we need the `of Type` ? If an MVP was that the values had to be explicitly assigned, no auto-increment.

```
const MyFlags = enum {
   None: 0,
   A: 1,
   B: 2,
   AB: enum.A & enum.B
};
```

[17:48:41.0612] <Ashley Claymore>
as ADT wouldn't need them right?

[17:48:48.0927] <rbuckton>
The `of Type` syntax is a convenience for those who specifically prefer something like a string or symbol by default for enums. In those cases, the repetition of `enum E { A = Symbol(), B = Symbol(), ... }` would be unnecessarily unwieldy.

[17:49:50.0739] <rbuckton>
It also provides a convenient way to describe the defaulting behavior for both auto numbered enums as well as string and numeric enums: https://github.com/rbuckton/proposal-enum?tab=readme-ov-file#evaluation

[17:50:52.0196] <Ashley Claymore>
if it's a connivence could it be a follow on?

[17:51:44.0429] <rbuckton>
IMO, the above syntax is a non-starter. `const x = enum` certainly doesn't help the "erasable syntax" case for TS, and `enum.A` would prevent future use of `enum` for any other metaproperty, which was a blocking issue for the the `class.x` syntax as well.

[17:52:31.0505] <Ashley Claymore>
I'd personally be ok with the bare `A` resolving the the member

[17:52:38.0653] <Ashley Claymore>
* I'd personally be ok with the bare `A` resolving to the member

[17:52:41.0425] <rbuckton>
I would not, unfotunately.

[17:53:09.0237] <Ashley Claymore>
how comes? you're early example had it bare

[17:53:10.0248] <rbuckton>
`enum.A` would have the exact same issue as `class.A`, and I've come around to agreeing with that position.

[17:53:14.0264] <Ashley Claymore>
* how comes? your early example had it bare

[17:54:03.0610] <rbuckton>
One of the motivations for an `enum` proposal would be to reduce the runtime syntax friction between TS and ES. Proposing a wholly different syntax does not address that concern and would make adoption very difficult.

[17:57:12.0057] <Ashley Claymore>
makes sense. but we potentially need the syntax to be at least slightly different  if the semantics are not identical?

[17:57:24.0435] <rbuckton>
Also, the mechanism for explicit autonumbering as part of emit ends up not being truly "eraseable" as it requires the introduction of temporaries to handle initializers, i.e.:

```ts
import { x } from "./other.js";
enum E {
  A = x,
  B,
  C
}
```
This is also an example of the problematic type-directed emit in TS today that I hope to fix in the future. I cannot statically know what the value of `x` is without type checking, and thus could not reliably emit the auto-incremented values for B and C without additional overhead, i.e.:

```js
var _a;
enum E {
  A = _a = x,
  B = ++_a,
  C = ++_a,
}
```

[17:58:06.0765] <rbuckton>
The `of` syntax is an invocation of an explicit mapper function that handles defining the default initializer of each value.

[17:58:48.0157] <rbuckton>
Ideally, I would prefer a native syntax where `enum E {}` is the equivalent of `enum E of Number {}`, and thus the syntax could be identical in both cases.

[17:59:59.0339] <rbuckton>
This would also allow those who have a specific preference around using strings or symbols to express that via, e.g., a linter, while preserving the predominant base case of using numbers.

[18:02:15.0197] <Ashley Claymore>
I'm probably in the minority, I prefer the values being explicit. Even if it is repetitive

[18:03:25.0759] <Ashley Claymore>
are there other languages where the enum delegates to a runtime protocol to construct the values?

[18:03:28.0028] <rbuckton>
The other caveat of TS vs ES enums to address would be the reverse mapping aspect of TS enums, which is great for diagnostics purposes but unreliable for serialization/deserialization use cases. That's why my version of the enum proposal offloads reverse mappings to a symbol protocol and is made accessible via the `Enum` API. It introduces a more reliable and formal mechanism for parsing and serializing.

[18:03:51.0807] <rbuckton>
Python does

[18:04:04.0615] <Ashley Claymore>
thanks, I'll check that out

[18:05:12.0912] <rbuckton>
```py
class E(Enum):
  A = auto()
  B = auto()
```

[18:05:21.0227] <Ashley Claymore>
the parts I like the most about the proposal is the self reference during initialisation, and the object being frozen.

[18:05:55.0626] <rbuckton>
Also, while not quite runtime, Go uses `iota`. C# enums use a similar auto-numbering mechanism to the one defined in TypeScript, but are also handled at compile-time.

[18:09:48.0145] <rbuckton>
The other benefit to a syntactic `enum` type would be future support for decorators for things like control over serialization, formatting, and marshalling, e.g.:

```ts
enum Position of Symbol {
  @JSONSerializer.Alias("emp")
  @JSONSerializer.SerializeAs("employee")
  Employee,

  @JSONSerializer.Alias("mgr")
  @JSONSerializer.SerializeAs("employee")
  Manager,

  ...
}
```

[18:11:20.0563] <rbuckton>
* ```py
from enum import Enum, auto
class E(Enum):
  A = auto()
  B = auto()
```

[18:14:43.0785] <rbuckton>
This is also a hard comparison to make, considering the ratio of dynamic to static languages. By nature of JS being dynamic, more things often need to be done at runtime or are expressed via runtime operations (i.e., `Object.defineProperty`, `Reflect.*`, etc.).

[18:17:56.0192] <rbuckton>
I also hold out hope that a syntactic `enum` might be able to establish an object shape for the enum declaration that could eventually be used by bytecode generators for specific performance tuning, much like how we hope the fixed shape nature of `struct` could be utilized. For example, a `switch` over cases of `E.A`, `E.B` could potentially inline those values if it is known that `E` is an enum with a fixed shape, and thus convert the `switch` to a jump table.

[18:19:02.0785] <rbuckton>
As mentioned in one of the talks today, that's not something we can depend on, but its potentially feasible w/o needing any kind of whole program optimization on the part of the bytecode generator.

[18:19:22.0867] <Ashley Claymore>
if enums are mostly static I can see minifiers being able to inline the values

[18:19:36.0962] <Ashley Claymore>
the constructs might make that too hard

[18:19:40.0061] <Ashley Claymore>
* the constructors might make that too hard

[18:19:41.0809] <rbuckton>
That's already the case in tools like `esbuild`

[18:19:57.0442] <Ashley Claymore>
right, but there isn't a symbol protocol today

[18:20:42.0022] <rbuckton>
But that depends on whole program optimization. The `enum`-ness of `E` could be encoded into its map/shape and is thus available when collecting type feedback on a `switch` case

[18:21:52.0002] <Ashley Claymore>
doesn't need to be whole program, only need to see the two modules

[18:22:00.0271] <Ashley Claymore>
follow the import and look at the export

[18:22:28.0975] <rbuckton>
Are you referring to the `@@toEnum` symbol? 

[18:23:05.0377] <Ashley Claymore>
I'm not sure if the proposal changed since I last looked

[18:23:11.0613] <Ashley Claymore>
I thought the `of T` looked up a symbol on T

[18:23:38.0295] <rbuckton>
We could make those frozen on built-in constructors, so for the most common use cases it can be determined statically. Edge cases using a custom `@@toEnum` would be slower, but thats pay-to-play. Also, the performance cost is only during startup.

[18:24:32.0955] <Ashley Claymore>
I thought we had a rule that we couldn't freeze intrinsics

[18:24:55.0602] <rbuckton>
I mean `{ writable: false, configurable: false }`

[18:25:18.0030] <Ashley Claymore>
I'd have to defer to TG3 if that fits their model

[18:25:19.0992] <rbuckton>
And if that's not viable, then an opt-out if it differs from the expected value.

[18:27:18.0855] <Ashley Claymore>
I'd personally be Ok with the possible patterns being baked in statically, without ways to create custom constructors. For strings if someone wanted a constructor that created lowercase or uppercase strings for example doesn't feel like enough of a motivation to introduce the dynamic lookup

[18:27:35.0055] <Ashley Claymore>
number+string+symbol sounds more than enough :)

[18:27:51.0532] <rbuckton>
Also bigint

[18:28:00.0074] <Ashley Claymore>
interesting

[18:28:06.0312] <rbuckton>
Also flags, and eventually ADT enums

[18:28:14.0737] <Ashley Claymore>
flags are numbers though right

[18:28:40.0590] <rbuckton>
Yes, but the auto-numbering behavior differs

[18:28:41.0151] <Ashley Claymore>
is bigint for when needing a larger domain of possible flags?

[18:29:26.0780] <rbuckton>
Yes, if bigint were fast enough I'd have plenty of TS `enum`s that I'd make into bigints. In TS we regularly have to worry about running out of space in an SMI

[18:29:38.0071] <Ashley Claymore>
I do see the wins, but I also feel like explicit assignment is unambiguious as to what will happen. It's "just JavaScript" :D

[18:29:55.0825] <Ashley Claymore>
and the repeitiveness feels like a small price to pay

[18:30:08.0389] <rbuckton>
Flags enums would autonumber as `0`, `1 << 0`, `1 << 1`, `1 << 2`, ...

[18:30:22.0481] <Ashley Claymore>
I really hope we get the enum proposal and it feels like that's more likely to happen if it's kept simpler

[18:30:37.0204] <rbuckton>
Explicit assignment just isn't backwards compatible with TS, unfortunately.

[18:31:04.0957] <Ashley Claymore>
could tooling help here, I'd happily write the codemod!

[18:32:06.0124] <Ashley Claymore>
also thanks for helping answer my queries, much appreciated

[18:32:22.0809] <rbuckton>
The problem is the thousands of existing .d.ts files. Hand-generated .d.ts files can contain `enum E { A, B }` even though we normally emit them with hardcoded initializers.

[18:32:34.0662] <Ashley Claymore>
gotcha

[18:32:53.0214] <rbuckton>
We have over a decade of legacy to deal with that ties our hands in many ways.

[18:33:02.0555] <Ashley Claymore>
so would need a way to mark the 'new' enums when generating `.d.ts`

[18:33:22.0822] <rbuckton>
No, *generating* a .d.ts is fine since we always generate with hard-coded initializers.

[18:33:36.0219] <rbuckton>
We have no control over hand-rolled .d.ts files

[18:34:12.0631] <Ashley Claymore>
I mean we'd preserve the auto-increment type inference for existing `.d.ts` 

[18:34:18.0217] <rbuckton>
i.e., much of DefinitelyTyped, any code that's behind the firewall, etc.

[18:35:42.0446] <Ashley Claymore>
JS enums could be `enum E # {}` to differentiate? 

[18:35:47.0450] <Ashley Claymore>
* JS enums could be `enum E #{}` to differentiate?

[18:35:48.0988] <rbuckton>
That's only possible if we preserve auto-incrementing numbers for native enums by default.\

[18:36:12.0799] <rbuckton>
Why though? What value does that bring? `of T` at least has some benefits.

[18:36:21.0368] <rbuckton>
* That's only possible if we preserve auto-incrementing numbers for native enums by default.

[18:36:26.0872] <Ashley Claymore>
it's simpler

[18:36:41.0997] <Ashley Claymore>
no dynamic lookup

[18:37:02.0388] <rbuckton>
Why is dynamic lookup bad for `enum E of T {}` but ok for `class C of B {}`?

[18:37:28.0316] <rbuckton>
* Why is dynamic lookup bad for `enum E of T {}` but ok for `class C extends B {}`?

[18:37:52.0008] <rbuckton>
I'd put forth that `class C extends B` is worse because it requires dynamic lookup during `new`

[18:37:57.0957] <Ashley Claymore>
because classes need to extend from an infinite set

[18:38:11.0214] <rbuckton>
`Number` is an infinite set.

[18:38:12.0756] <Ashley Claymore>
enums can be a few built in types

[18:38:18.0125] <Ashley Claymore>
I mean the set of types

[18:38:21.0105] <Ashley Claymore>
not the set of values

[18:38:40.0027] <Ashley Claymore>
we can't hard code that classes can only extend from number/string/symbol

[18:38:46.0101] <Ashley Claymore>
we can for enum

[18:39:26.0473] <rbuckton>
What good does hard coding it do? `of T` doesn't enforce any constraints on the values of each enum member, it only affects auto-numbering.

[18:39:36.0941] <Ashley Claymore>
it's simpler

[18:39:39.0741] <rbuckton>
You could say `enum E of Number { A = "foo" }`

[18:40:04.0197] <rbuckton>
I don't think this kind of simpler will pass muster for others on the committee.

[18:40:32.0935] <Ashley Claymore>
I think the complexity of `of` is also not aligned with the feedback we are currently getting in committee to keep proposals simpler

[18:40:39.0362] <Ashley Claymore>
for other proposals

[18:40:40.0659] <rbuckton>
"simpler" would be `enum E { A, B }` produces auto-numbered values. That is a tried and true implementation that matches what TS has been doing for a decade

[18:42:01.0413] <Ashley Claymore>
Lots of code uses plain object literals for enums today, the biggest downside is not being able to self reference

[18:42:03.0129] <rbuckton>
IMO, auto-numbering is a very important part of the feature and is something a large number of existing TS developers rely on.

[18:43:36.0626] <rbuckton>
And without some form of auto-numbering, we have no way of making `enum` work with a pure "erasable types" solution as it would still require additional downlevel emit.

[18:43:41.0513] <Ashley Claymore>
I'd be OK if un-initalized names were auto-incrementing

[18:43:56.0277] <Ashley Claymore>
strings would need explicit assignment

[18:44:07.0697] <rbuckton>
Yes, but ljharb and bakkot would not.

[18:44:34.0001] <rbuckton>
`of` is designed to find a compromise between those positions.

[18:44:42.0317] <ljharb>
i don’t mind auto increment. But i mildly prefer only explicit

[18:45:35.0450] <Ashley Claymore>
if `of` is the only way to resolve the comittee's constraints I get that. But I'd really like to be sure we've exhausted 'simpler' options.

[18:45:56.0813] <rbuckton>
The other benefit to `of` is to specify the backing type for auto-increment behavior, such that you could have `enum E of BigInt { None, A, B }` produce bigints instead of numbers.

[18:46:13.0823] <ljharb>
the value is imo in covering enumeration and validation, i don’t care about the one time that might have to be explicitly written. read > write and all that

[18:46:17.0690] <Ashley Claymore>
that benefit seems small

[18:46:33.0497] <Ashley Claymore>
* that benefit seems small (incrementing bigint)

[18:46:49.0673] <rbuckton>
enumeration and validation are important, but only a small piece of the pie.

[18:47:01.0060] <ljharb>
for me it’s like 99% of it

[18:47:02.0628] <bakkot>
My preference continues to be not having enums, rather than trying to rationalize TS enums as a JS feature.

[18:47:20.0351] <rbuckton>
Yes, but for me its maybe like 40% of it.

[18:47:42.0673] <ljharb>
what’s the rest? Surely it’s not “not having to type out a few numbers and/or strings”

[18:48:21.0443] <ljharb>
types i guess, but im assuming a JS context here :-)

[18:48:59.0681] <rbuckton>
My major use cases have been ordered ranges, bitflags/bitmasks, and binary serialization formats (network I/O, binary file/section headers, etc.)

[18:49:41.0397] <ljharb>
bitflags only work if you can increment by powers of two, and i don’t see how that’s doable automatically 

[18:49:45.0520] <rbuckton>
`SyntaxKind`, for example, uses auto-numbering and pre-defined ranges for fast comparison of AST node kinds.

[18:49:49.0857] <ljharb>
and formats are strings which are explicit

[18:50:32.0036] <rbuckton>
Its doable with `of`.

[18:50:34.0160] <ljharb>
auto numbering does seem like it make unintentional breaking changes highly likely 

[18:50:35.0203] <bakkot>
I would be enthusiastic about a native BitSet, possibly backed by an arraybuffer 

[18:51:19.0160] <bakkot>
(not with syntax though)

[18:51:43.0652] <rbuckton>
You can do something similar in Go a well: 
```go
type Foo int32
const (
  FooA E = 1 << iota // E(1)
  FooB // E(2)
  FooC // E(4)
)
```

[18:52:13.0966] <rbuckton>
* You can do something similar in Go as well:

```go
type Foo int32
const (
  FooA E = 1 << iota // E(1)
  FooB // E(2)
  FooC // E(4)
)
```

[18:53:43.0518] <rbuckton>
As would any unintentional change to your public API.

[18:54:05.0021] <ljharb>
sure. But those are harder to do by accident.

[18:54:07.0555] <bakkot>
Zig's support for fixed-width ints of any width, with packing into binary representations, is quite nice

[18:55:29.0875] <rbuckton>
I would argue that banning auto-numbering, or requiring `of String` or `of Symbol`, is something a lint rule could handle, but it isn't a rule I would enforce by default.

[18:56:44.0421] <ljharb>
implicitness should be either allowed or prohibited, it shouldn’t be pushed to linters

[18:58:08.0214] <rbuckton>
I would, in general, be fine with a MVP version that has no `@@toEnum` and explicitly checks if the expression passed to `of` is one of the built-in `Number`, `String`, `Symbol`, or `BigInt` constructors, as that leaves room for future extensibility (i.e., `of Enum.BitFlags`, `of Enum.ADT`, etc.)

[18:58:39.0229] <ljharb>
stuff it’s ok to push to linters is when it’s a preference; this is different imo. Autonumbering is either fine, or a footgun, so we’d have to make a call

[18:58:57.0191] <rbuckton>
I believe the implicitness should be allowed, and is essential for compatibility.

[18:59:33.0300] <rbuckton>
Even without `of`, you can always enforce explicitness if you need, but `enum E { A, B }` producing numbers would be essential for compatibility.

[18:59:44.0151] <ljharb>
what kind of compatibility?

[18:59:55.0321] <ljharb>
TS can transpile to explicit numbers

[19:00:25.0271] <rbuckton>
Not without running into problems with "legacy" .d.ts files hand written before native enums existed.

[19:00:42.0930] <rbuckton>
Its the TS version of "this is already legal JS"

[19:02:34.0400] <rbuckton>
You also can't transpile to explicit numbers without either whole program analysis or introducing temporary variables.

[19:03:27.0296] <Ashley Claymore>
I'm not following this bit still. Legacy `.d.ts` would only impact the types, not the emit right?

[19:05:01.0617] <rbuckton>
The types describe the runtime behavior. 

[19:05:46.0176] <Ashley Claymore>
I mean, the exiting interpretation of those files doesn't need to change

[19:08:04.0654] <rbuckton>
It does if we adopt an interpretation of `enum` for ES that requires explicit initializers, and then adopts some other behavior for auto-initialization later. 

[19:08:06.0585] <Ashley Claymore>
* I mean, the existing interpretation of those files doesn't need to change

[19:09:35.0070] <rbuckton>
Either way, not having auto numbering is incompatible with "erasable types" (i.e., such as ts-blank-space) as we have to inject initializers, or manually auto-number as in the example I mentioned above:

```js
var _a;
enum E {
  A = _a = x,
  B = ++_a,
  C = ++_a,
}
```

[19:10:09.0848] <Ashley Claymore>
`ts-blank-space` only erases the parts with no runtime semantics. So it would preserve enums as written

[19:10:20.0161] <Ashley Claymore>
as they would be valid 262

[19:11:06.0126] <rbuckton>
Maybe it gets us half way, and if you run with `--erasableSyntaxOnly` you have to explicitly number your enum values, but I'd still prefer to have auto-numbering.

[19:11:25.0080] <ljharb>
right, the point is to make enums non erasable

[19:11:56.0794] <rbuckton>
It would not be pleasant to introduce a new `*Keyword` entry into `SyntaxKind` and have to shift 250+ entries up one integer.

[19:12:01.0004] <ljharb>
prefer is fine, but then it’s not a compat issue?

[19:12:13.0706] <ljharb>
> <@rbuckton:matrix.org> It would not be pleasant to introduce a new `*Keyword` entry into `SyntaxKind` and have to shift 250+ entries up one integer.

breaking changes are supposed to be unpleasant to add

[19:12:27.0413] <ljharb>
feature not bug

[19:12:36.0942] <rbuckton>
I wholeheartedly disagree

[19:12:53.0103] <ljharb>
why would it be relevant what number backs the ast nodes?

[19:13:06.0771] <rbuckton>
Because we group those nodes for fast comparisons.

[19:13:10.0346] <ljharb>
other than to consumers who wouldn’t want the numbers to shift

[19:13:29.0807] <ljharb>
you’re implying that neighboring integers compare faster in engines?

[19:13:32.0566] <rbuckton>
i.e., `node.kind >= SyntaxKind.FirstKeyword && node.kind <= SyntaxKind.LastKeyword`

[19:13:37.0200] <ljharb>
ah

[19:13:50.0179] <Ashley Claymore>
how comes we need a new syntax kind?

[19:13:59.0284] <ljharb>
so, good api design would suggest designing groups initially that had enough gaps to never run into that problem?

[19:14:04.0615] <bakkot>
I think the SyntaxKind use case is quite specific to TS's code base

[19:14:11.0650] <rbuckton>
Years ago it was suggested to write a function that converts them to ints, but that's only making the problem 100% worse and killing the performance of that check.

[19:14:22.0924] <rbuckton>
I assure you it isn't.

[19:14:33.0944] <Ashley Claymore>
alternative would be to add a new flag to the existing syntax kind

[19:14:36.0865] <Ashley Claymore>
* alternative would be to add a new flag to the existing syntax kind node

[19:14:55.0002] <rbuckton>
That is terrible for memory usage. 

[19:17:11.0553] <bakkot>
How many programs are making more than a dozen different tagged variants of one kind of thing?

[19:17:37.0502] <bakkot>
I have literally only ever done that when writing parsers or general purpose binary formats.

[19:18:03.0170] <rbuckton>
Anything using `jsdom`?

[19:18:26.0716] <rbuckton>
Any DSL involving a tree of disjoint nodes? 

[19:18:28.0767] <bakkot>
Jsdom itself, yes. Things using it, no.

[19:18:48.0710] <bakkot>
How many programs are making DSLs?

[19:18:48.0778] <rbuckton>
Games in Unity, or any other JS framework?

[19:18:54.0600] <ljharb>
most programs don’t deal with a DSL or a tree in first party code

[19:18:57.0570] <Ashley Claymore>
wouldn't it only be an extra 64bits * number of enums in program? i.e. orders of magnitudes less impact than adding a prop to the identifier nodes

[19:19:56.0648] <rbuckton>
Storing an extra field on every Node just to group the kind of node? This is empirically terrible. We're regularly trying to claw back memory by removing fields we can infer rather than store.

[19:20:42.0094] <rbuckton>
And how would you store something like that on the enum itself without having to do some kind of comparison/hashtable lookup just to pull out the group? 

[19:20:49.0635] <Ashley Claymore>
it's not every node, I think I'm not following the original issue

[19:23:29.0119] <rbuckton>
At least in TypeScript's case, ordered integer enum values are a major performance feature. Being able to do fast math on `node.kind` is essential. That would apply to any application focusing on performance optimization, not just TS.

[19:23:47.0682] <rbuckton>
* At least in TypeScript's case, ordered integer enum values are a major performance feature. Being able to do fast math on `node.kind` is essential. That would apply to any application focusing on performance optimization, not just the TS compiler.

[19:24:25.0004] <bakkot>
That does not apply to any application for using on performance, just those with dozens of variants of one kind. Which is very very unusual outside of a parser, which most JS programs do not contain.

[19:24:51.0094] <ljharb>
also even if the TS codebase can’t use native enums, that doesn’t mean it’s not a valuable feature for the majority of programs

[19:25:57.0574] <Ashley Claymore>
nicolo-ribaudo: explained it to me. I thought the new syntaxKind was to represent these new enum syntax.

[19:26:10.0401] <Ashley Claymore>
as opposed to just the general TS change of needing to add any new syntax

[19:26:19.0156] <Ashley Claymore>
caught up. sorry for confusion

[19:26:46.0394] <rbuckton>
I don't disagree, but I'm trying to thread the needle of:
- convenient syntax
- avoiding unnecessary compat risks
- aligning with "erasable types"
- fast math
- allowing non-numeric enumerated values

[19:27:20.0921] <ljharb>
if all can be achieved then great. But some of those don’t matter to the majority of codebases, so they should be the first to be sacrificed if needed

[19:28:02.0579] <Ashley Claymore>
auto-increment in userland with AOT inlining could be done with a magic comment :D

[19:28:31.0337] <Ashley Claymore>
I agree not lovely to build a custom tool for the project

[19:28:43.0255] <Ashley Claymore>
but I think the case of these huge enums with 100s of values is rare

[19:29:19.0081] <bakkot>
Extremely rare

[19:29:33.0788] <rbuckton>
All of those bullets are currently satisfied by the *current* TS enum syntax. The only case that would not be would be something like "Symbol by default" or "String by default", which would break all but the last bullet point.

[19:30:02.0944] <rbuckton>
the `of T` syntax was suggested to make "Symbol by default" or "String by default" far easier.

[19:30:29.0237] <ljharb>
of T seems fine to me fwiw

[19:30:40.0426] <Ashley Claymore>
symbol and strings needing to be explicit assignment seems like an OK compromise

[19:31:21.0820] <rbuckton>
And that's exactly how current TS enums work (for String, at least. Symbol isn't currently supported, but could be)

[19:31:28.0971] <ljharb>
(implicit strings is actually fine with me too, there’s no footgun there)

[19:31:49.0865] <bakkot>
For almost all programs, the benefit of having something which does not make it trivial to introduce breaking changes outweighs the benefit of auto-incrementing values. So the default should not be auto incrementing integers.

[19:32:27.0837] <Ashley Claymore>
I like current TS enums! (minus the merging and not being 262)

[19:33:18.0351] <rbuckton>
In a world where you had, say Symbol by default, how would that differ from auto-incrementing integers if you never explicitly tried to hard code the value of an enum?

[19:33:26.0515] <rbuckton>
* In a world where you had Symbol by default how would that differ from auto-incrementing integers if you never explicitly tried to hard code the value of an enum?

[19:33:35.0506] <ljharb>
because the symbols and strings aren’t ordered 

[19:33:43.0195] <rbuckton>
That doesn't matter

[19:33:47.0851] <ljharb>
The very ordering/grouping property you went with numbers is why it’s a footgun

[19:33:56.0673] <ljharb>
it’s the only thing that matters afaict?

[19:34:07.0647] <rbuckton>
If you consider the value to be a black box, which is what Symbol by default implies, then whether the integers are ordered is irrelevant.

[19:34:13.0489] <ljharb>
adding a thing shouldn’t change other things

[19:34:27.0148] <ljharb>
that’s the concern

[19:34:44.0897] <ljharb>
that concern only exists with auto increment, not with implicit values

[19:34:56.0674] <rbuckton>
the ordering/grouping property is a performance optimization, not a footgun. If they were Symbols by default, there is no way I could have the same performance optimizaiton.

[19:35:02.0917] <rbuckton>
* the ordering/grouping property is a performance optimization, not a footgun. If they were Symbols by default, there is no way I could have the same performance optimization.

[19:35:14.0173] <ljharb>
it’s both

[19:35:30.0646] <rbuckton>
For "Symbol by default", the initialized values change on every application startup

[19:35:33.0096] <ljharb>
nobody objects to the perf part from what i can tell, but it’s inseparable from the footgun part.

[19:35:50.0459] <ljharb>
> <@rbuckton:matrix.org> For "Symbol by default", the initialized values change on every application startup

that’s in observable tho since it’s just identity. So it’s fine.

[19:35:57.0568] <ljharb>
> <@rbuckton:matrix.org> For "Symbol by default", the initialized values change on every application startup

 * that’s unobservable tho since it’s just identity. So it’s fine.

[19:36:02.0676] <bakkot>
> <@rbuckton:matrix.org> the ordering/grouping property is a performance optimization, not a footgun. If they were Symbols by default, there is no way I could have the same performance optimization.

Sure there would! It just wouldn't be the default.

[19:37:13.0934] <bakkot>
Even without enums you could do what I do and have a generated file with the mapping of kinda to integers and regenerate whenever it changes.

[19:37:22.0512] <bakkot>
This is such a specialized use case.

[19:37:38.0496] <rbuckton>
Symbol by default wouldn't work with shared memory multithreading, though Auto-numbering and strings by default would.

[19:37:38.0953] <bakkot>
*kinds not kinda

[19:39:37.0711] <rbuckton>
Auto-numbering works because the nature of `shared struct` correlation depends on the module resolution cache, so you can be fairly confident that the enum is evaluated in the same way in both the main and worker threads. Strings work because they would be the same. Symbols would not because they would result in unique values in each thread.

[19:41:11.0867] <rbuckton>
This requires something like a hashtable lookup to produce the integer for comparison, which has a major impact on performance. It wouldn't be a solution for this case.

[19:43:00.0520] <rbuckton>
e.g., you go from something that is essentially `5 >= 1 && 5 <= 15` to `map[sym] >= 1 && map[sym] <= 15`, or `x = map[sym]; x >= 1 && x <= 15`, which requires more steps and more stack space in a tight loop/hot path

[19:43:48.0484] <bakkot>
I think you misunderstand. The mapping is just like `export const DECL_KIND = 12`

[19:44:40.0081] <rbuckton>
That's a compatibility issue, and again blows up the first four bullet points above.

[19:45:42.0662] <bakkot>
Right. It only satisfies TS's very niche use case. But other use cases do not have the auto-incrementing constraint.

[19:46:43.0212] <bakkot>
Auto-incrementing is a very unusual thing to want and is harmful to most programs. We should not make it easy to reach for.

[19:52:17.0031] <rbuckton>
It's getting late. I need to think on this more and chat with my team tomorrow. Unfortunately, the auto-numbering concern has been the biggest blocker for years, IMO.

[21:17:54.0156] <rkirsling>
oh man, it hurts that someone has chosen REK for their signifier, given that those are my actual initials 😆

[23:03:25.0668] <rekmarks>
> <@rkirsling:matrix.org> oh man, it hurts that someone has chosen REK for their signifier, given that those are my actual initials 😆

I would’ve picked REKM but I was told to pick three letters 😛

[09:28:52.0347] <snek>
can i come to the tg5 event if i didn't register?

[09:31:39.0485] <snek>
Michael Ficarra: ^

[09:32:26.0960] <Michael Ficarra>
yep

[11:07:44.0835] <Jack Works>
> <@rbuckton:matrix.org> I'd still like to hear feedback as to what exactly is considered an anti-pattern regarding `enum`? The two things I've heard have been:
> - Don't use `enum` in TS because it's not in ES
> - `enum` defaulting to numbers and not something like `Symbol()`
> 
> 

auto-incrementing is bad because if library authors use it it becomes a footgun. at least it should be opt-in

[11:10:07.0270] <nicolo-ribaudo>
Potentially stupid question, but when we say "auto-increment should be opt-in", can it just be "opt-in" like this?
```js
let counter = 0;
enum TokenType {
  Arrow = counter++,
  Identifier = counter++,
  ParenL = counter++,
  ParenR = counter++,
  // ...
}
```

[11:11:39.0417] <nicolo-ribaudo>
Or, for binary flags,
```js
let counter = 1;
enum TokenType {
  Arrow = counter <<=1,
  Identifier = counter <<=1,
  ParenL = counter <<=1,
  ParenR = counter <<=1,
  // ...
}
```

[11:12:37.0667] <Jack Works>
> <@nicolo-ribaudo:matrix.org> Potentially stupid question, but when we say "auto-increment should be opt-in", can it just be "opt-in" like this?
> ```js
> let counter = 0;
> enum TokenType {
>   Arrow = counter++,
>   Identifier = counter++,
>   ParenL = counter++,
>   ParenR = counter++,
>   // ...
> }
> ```

maybe `auto enum T {}` or `enum T with Number { a; }` (compared to `enum T { a = 1 }`)

[11:12:40.0612] <nicolo-ribaudo>
* Or, for binary flags,

```js
let counter = 1;
enum TokenType {
  Arrow = counter <<=1,
  Identifier = counter <<=1,
  ParenL = counter <<=1,
  ParenR = counter <<=1,
  // ...
  Paren = ParenL | ParenR
}
```


2025-02-22
[16:17:26.0631] <shu>
rbuckton: riddle me this

[16:17:48.0995] <shu>
i see in your explicit resource management test262 PR you have a test that `for (using of of [1,2,3]) {}` isn't supposed the parse

[16:18:19.0662] <shu>
the grammar as i read it says that for the production

for ( [lookahead ≠ using of] ForDeclaration[?Yield, ?Await, +Using] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]



[16:18:57.0206] <shu>
because of the negative lookahead, `for (using of of [1,2,3]) {}` is always parsed as

for ( [lookahead ∉ { let, async of }] LeftHandSideExpression[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return]


[16:19:36.0018] <shu>
but `for (using of of [1,2,3]) {}` _does_ parse as that: `using` is an identifier, the first `of` is the of in the for-of, and `of[1,2,3]` is an assignment expression of a computed property access on the identifier `of`

[16:19:41.0415] <shu>
what am i missing

[16:19:46.0584] <shu>
or is this language getting more cursed every day

[16:29:38.0938] <Luca Casonato>
Wow that is cursed

[16:30:22.0048] <nicolo-ribaudo>
The way we implemented it in Babel matches your reading

[16:53:29.0031] <TabAtkins>
Why are the whitespace rules so incredibly lax/cursed, omg

[19:17:44.0225] <snek>
this is a feature 

