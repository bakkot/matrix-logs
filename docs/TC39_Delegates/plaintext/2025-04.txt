2025-04-01
[21:20:55.0671] <ljharb>
the ES2025 candidate has been prepared:
https://github.com/tc39/ecma262/releases/tag/es2025-candidate-2025-03-31
https://github.com/tc39/Reflector/issues/557

[22:35:29.0753] <jschoi>
linusg has kindly made a pull request to proposal-array-from-async (https://github.com/tc39/proposal-array-from-async/pull/48). It makes mostly editorial updates to the proposal spec to match ECMA-262 changes. There‚Äôs also a small proposal spec bugfix.

Way back in 2022, the proposal spec received pre-Stage-3 reviews from ljharb and nicolo-ribaudo. Should I ask them for repeated reviews before merging the pull request, or should I be okay with merging it unilaterally?

(I do plan on kickstarting the proposal back up soon, maybe all the way to Stage¬†4.)

[01:01:51.0633] <nicolo-ribaudo>
I'm happy to take another look next week


2025-04-03
[19:01:46.0722] <jschoi>
Is there a particular reason why withdrawn [proposal-operator-overloading](https://github.com/tc39/proposal-operator-overloading)‚Äôs repository hasn‚Äôt been archived? littledan withdrew it about a year ago, but various people have still been posting to it.

[19:02:11.0578] <jschoi>
* Is there a particular reason why withdrawn [proposal-operator-overloading](https://github.com/tc39/proposal-operator-overloading)‚Äôs repository hasn‚Äôt been archived? littledan withdrew it about a year ago, but various people have still been posting to it since.

[19:03:55.0098] <jschoi>
(It would also be good to link prominently to https://github.com/tc39/notes/blob/main/meetings/2023-11/november-28.md#withdrawing-operator-overloading from the explainer.)

[19:04:30.0305] <jschoi>
Ditto goes for [proposal-extended-numeric-literals](https://github.com/tc39/proposal-extended-numeric-literals).

[19:04:46.0571] <jschoi>
* Ditto goes for [proposal-extended-numeric-literals](https://github.com/tc39/proposal-extended-numeric-literals), though that‚Äôs been getting less community traffic.

[01:14:51.0828] <Ashley Claymore>
Good spot. A withdrawn proposal could be re-started. So I don't necessarily think they need to be archived, unless the champions wish to. But an updated README and a pinned issue makes a lot of sense 

[04:38:53.0781] <eemeli>
Renaming the repo with a `withdrawn-` or similar prefix would make the status a bit clearer.

[04:51:26.0966] <Jesse>
AFAIU the tc39 organization in GitHub can define a label (e.g., `withdrawn`) that can be used on repos within the organization

[06:00:49.0657] <ryzokuken>
Hi everyone! For folks interested in visiting us for the hybrid plenary in May, we're working on organizing a community event in collaboration with local communities along the same lines as the recent SeattleJS event you might remember from the last hybrid meeting in Seattle. I've posted a call for participation here: https://github.com/tc39/Reflector/issues/556, which allows you to volunteer for a talk or a panel but we're also open to new ideas. Basically if you're up for it, let us know through the spreadsheet form or just informally since it'd help us plan.

[09:32:50.0576] <ljharb>
they should be, it just slipped through the cracks. repos can be unarchived if needed

[10:16:42.0912] <Chris de Almeida>
üì¢ REMINDER! üì¢ The deadline for advancement for the April meeting is just ~20 hours from now!

[12:31:37.0029] <jschoi>
It‚Äôs been a long time for me, sorry‚Äîwhat‚Äôs the deadline for new agenda items that do not advance a proposal?

[12:32:39.0856] <ptomato>
before the draft schedule is published?

[12:46:29.0980] <Rob Palmer>
We still encourage early posting.

[13:11:09.0301] <Michael Ficarra>
we formally accept an agenda at the beginning of a meeting, but that hasn't stopped us from making updates during the meeting

[13:11:34.0104] <Michael Ficarra>
> 3. Adoption of the agenda

[13:22:33.0322] <shu>
do we really

[13:22:44.0802] <shu>
like does someone say "are there any objections to adopting this agenda"

[13:38:27.0895] <bakkot>
at literally every meeting, yes

[13:39:49.0987] <shu>
i evict memories of the start of tc39 meetings almost immediately after they occur

[14:06:13.0272] <bakkot>
that's what the notes are for https://github.com/tc39/notes/blob/main/meetings/2024-12/december-02.md#:~:text=.%20Are%20there%20any%20objections%20against%20proceeding%20with%20the%20current%20agenda%3F%20None%3F%20Okay.%20We%20have%20adopted%20the%20agenda.

[14:08:16.0480] <shu>
look, i'm not even in the list of attendees, it checks out

[15:43:57.0227] <Michael Ficarra>
there's a lot of things on the agenda for stage advancement with no links

[15:44:51.0468] <Michael Ficarra>
reminder @mhofman:matrix.org @erights:matrix.org that links to review materials should be provided before the advancement deadline

[15:46:03.0656] <kriskowal>
Mark‚Äôs been working to produce material all week. I‚Äôll pass on the reminder, and you can expect links soon.


2025-04-04
[06:32:48.0093] <nicolo-ribaudo>
Could we give back to delegates permission to merge in the agenda repo, at least when CI on a PR is green?

[06:34:04.0607] <nicolo-ribaudo>
I understand that ljharb would like to merge the PRs to make sure they conform to the nice commit format (i.e. `YYYY.MM: description`, single commit, squash locally and then merge withuot squashing), but:
- many delegates are trying to respect this format by ourselves too
- many delegates don't care about it and have write access anyway

[06:34:14.0413] <nicolo-ribaudo>
* I understand that ljharb would like to merge the PRs to make sure they conform to the nice commit format (i.e. `YYYY.MM: description`, single commit, squash locally and then merge withuot squashing), but:

- many delegates are trying to respect this format by ourselves too
- multiple delegates don't care about it and have write access anyway

[06:50:58.0363] <nicolo-ribaudo>
(sorry Jordan for putting you on the spot if the reason I lost merge access is not this one üòÖ)

[07:01:46.0384] <Chris de Almeida>
nicolo-ribaudo: delegates have write access

[07:02:12.0963] <Chris de Almeida>
this hasn't changed.. not sure what issue you are running into

[07:02:28.0307] <littledan>
I do not have write access

[07:02:57.0341] <Chris de Almeida>
do you have a couple minutes to hop on a call to investigate?

[07:03:46.0113] <littledan>
sure

[07:14:08.0828] <ljharb>
? you should have that permission already on the agenda repo, yes

[07:14:22.0295] <ljharb>
PRs aren‚Äôt even a requirement

[07:14:25.0174] <Chris de Almeida>
I fixed it

[07:18:32.0375] <Chris de Almeida>
nicolo-ribaudo: fixed

[07:20:08.0098] <nicolo-ribaudo>
Ok thank you :)

[07:21:48.0960] <ljharb>
(also merely having an open PR means you hit the deadline, so this sort of thing wouldn't impact that, at least)

[07:23:39.0447] <Chris de Almeida>
gentle reminder that even though PRs are not required, they are greatly appreciated because people who have notifications on will know there is something new on the agenda


2025-04-07
[19:51:00.0595] <jschoi>
[Math.sqrt](https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.sqrt) says, ‚ÄúReturn ùîΩ(the square root of ‚Ñù(n)),‚Äù but [Math.cbrt](https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.cbrt) says, ‚ÄúReturn an implementation-approximated Number value representing the cube root of ‚Ñù(n).‚Äù Does anyone know why their language is different?

[19:53:35.0440] <bakkot>
jschoi: https://github.com/tc39/ecma262/pull/3345

[19:53:58.0625] <bakkot>
basically we know that everyone is using a correct sqrt because wasm requires it but we don't know this about cube root and it's a pain to find out

[19:56:22.0949] <jschoi>
Ah‚Ä¶so it‚Äôs because there‚Äôs no cbrt instruction.

[19:57:23.0068] <jschoi>
* Ah‚Ä¶so it‚Äôs because there‚Äôs no cbrt instruction in WASM. A shame.

[20:01:55.0607] <jschoi>
* Ah‚Ä¶so it‚Äôs because there‚Äôs no cbrt instruction in WASM. That seems like an unfortunate omission.

[20:01:58.0037] <jschoi>
I presume that BigInt.sqrt should also use the ‚Äúimplementation-approximated‚Äù language, since it‚Äôs not trying to match a f32/364 WASM instruction.

[20:02:17.0691] <jschoi>
* I presume that BigInt.sqrt should also use the ‚Äúimplementation-approximated‚Äù language, since it‚Äôs not trying to match a f32/364 WASM instruction but rather something like [Waldemar‚Äôs novel implementation](https://github.com/waldemarhorwat/integer-roots).

[20:04:00.0309] <jschoi>
* I presume that BigInt.sqrt should also use the ‚Äúimplementation-approximated‚Äù language, since it‚Äôs not trying to match a f32/364 WASM instruction but rather something like [Waldemar‚Äôs novel implementation](https://github.com/waldemarhorwat/integer-roots) over an unbounded ‚Ñï domain.

[20:31:37.0198] <bakkot>
no, if it's straightforward for everyone to have the right answer, then we should require the right answer

[20:31:46.0130] <bakkot>
and waldemar's is exact

[20:32:08.0099] <bakkot>
we only do implementation-approximated if getting the exact right answer is difficult or expensive

[20:38:34.0408] <jschoi>
Oh, so then *both* BigInt.sqrt and BigInt.cbrt should say, ‚ÄúReturn ‚Ñ§(the square/cube root of ‚Ñù(n))‚Äù.

[20:39:10.0319] <jschoi>
* Oh, so then _both_ BigInt.sqrt and BigInt.cbrt should say something like, ‚ÄúReturn ‚Ñ§(the square/cube root of ‚Ñù(n)), truncated toward 0‚Äù.

[20:39:12.0272] <jschoi>
* Oh, so then _both_ BigInt.sqrt and BigInt.cbrt should say something like, ‚ÄúReturn ‚Ñ§(the square/cube root of ‚Ñù(n)), truncated toward 0.‚Äù

[20:45:13.0979] <bakkot>
yes although the ‚Ñ§ operator takes an integer as input so it would have to be more like ‚ÄúReturn ‚Ñ§(the square/cube root of ‚Ñù(n) truncated toward 0)‚Äù

[20:45:19.0534] <bakkot>
though probably clearer as two steps

[20:48:11.0593] <jschoi>
Editorially, would
‚ÄúLet _root_ be the integer part of the square/cube root of ‚Ñù(n)‚Äù or
‚ÄúLet _root_ be the square/cube root of ‚Ñù(n), truncated toward 0‚Äù
be preferable?

[20:48:22.0243] <jschoi>
* Editorially, would
‚ÄúLet _root_ be the integer part of the square/cube root of ‚Ñù(_n_)‚Äù or
‚ÄúLet _root_ be the square/cube root of ‚Ñù(_n_), truncated toward 0‚Äù
be preferable?

[20:49:47.0006] <jschoi>
* Editorially, do you have an opinion about whether
‚ÄúLet _root_ be the integer part of the square/cube root of ‚Ñù(_n_); return ‚Ñ§(_root_)‚Äù,
‚ÄúLet _root_ be the square/cube root of ‚Ñù(_n_), truncated toward 0; return ‚Ñ§(_root_)‚Äù,
‚ÄúLet _root_ be the square/cube root of ‚Ñù(_n_); return ‚Ñ§(the integer part of _root_)‚Äù, or
‚ÄúLet _root_ be the square/cube root of ‚Ñù(_n_); return ‚Ñ§(_root_ truncated toward 0)‚Äù
be preferable?

[20:50:40.0154] <jschoi>
* Editorially, do you have an opinion about which would be preferable?
1. Let _root_ be the integer part of the square/cube root of ‚Ñù(_n_). Return ‚Ñ§(_root_).
2. Let _root_ be the square/cube root of ‚Ñù(_n_), truncated toward 0. Return ‚Ñ§(_root_).
3. Let _root_ be the square/cube root of ‚Ñù(_n_). Return ‚Ñ§(the integer part of _root_).
4. Let _root_ be the square/cube root of ‚Ñù(_n_). Return ‚Ñ§(_root_ truncated toward 0).

[20:58:04.0786] <jschoi>
* Editorially, do you have an opinion about which would be preferable?

1. Let _root_ be the integer part of the square/cube root of ‚Ñù(_n_). Return ‚Ñ§(_root_).
2. Let _root_ be the square/cube root of ‚Ñù(_n_), truncated toward 0. Return ‚Ñ§(_root_).
3. Let _root_ be the square/cube root of ‚Ñù(_n_). Return ‚Ñ§(the integer part of _root_).
4. Let _root_ be the square/cube root of ‚Ñù(_n_). Return ‚Ñ§(_root_ truncated toward 0).

Hm, I see MakeFullYear does already use ‚Äúthe integer part of‚Äù. There is nowhere in the spec that uses ‚Äútoward 0/+‚àû/-‚àû‚Äù.


2025-04-08
[09:37:58.0505] <Michael Ficarra>
Do we have an in-person sign-up form or location information for the May (Igalia/A Coru√±a) meeting yet? I would like to book travel soon to avoid higher fares. /cc @usharma:igalia.com

[09:40:12.0898] <ryzokuken>
We do, let me publish something on the reflector soon.

[09:40:26.0520] <ryzokuken>
* We do but it was a bit WIP around some details, let me publish something on the reflector soon.

[09:43:35.0504] <Michael Ficarra>
The things I need most urgently are just the address of the meeting and some hotel recommendations.

[10:53:08.0629] <Richard Gibson>
We don't have "toward 0/+‚àû/-‚àû", but we do have [truncate](https://tc39.es/ecma262/multipage/notational-conventions.html#eqn-truncate), which I would prefer:
1. Let _root_ be the square/cube root of ‚Ñù(_n_).
2. Return ‚Ñ§(truncate(_root_)).

[14:04:45.0658] <jschoi>
Richard Gibson: Thanks for pointing out that there is a truncate; I don‚Äôt know how I missed that. 
Two other people marked that they wanted ‚ÄúLet root be the integer part of the square/cube root of ‚Ñù(n). Return ‚Ñ§(root),‚Äù but your suggestion seems cleaner to me.


2025-04-09
[19:33:48.0057] <TabAtkins (Vacation until May)>
FYI, I'm on vacation until nearly the end of the month.

[08:05:42.0807] <Duncan MacGregor>
Does anybody know if there is something in test262 covering the ordering of the  steps in [sec-function-calls-runtime-semantics](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-function-calls-runtime-semantics-evaluation) and [sec-evaluatecall](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-evaluatecall), specifically resolving if ref, then evaluating the arguments, and then checking if the _func_ is an function?

[08:06:33.0537] <Duncan MacGregor>
I couldn't find anything, and was surprised, and I thought it would be a good idea to check with everybody before trying to write a PR for this.

[08:43:26.0713] <bakkot>
Duncan MacGregor one way to check is to take engine262, run test262, then modify engine262 to have the wrong semantics and see if any tests start failing

[08:43:38.0009] <bakkot>
modifying engine262 for that sort of thing is usually trivial

[09:10:13.0486] <Duncan MacGregor>
bakkot: I'll give that a go, it should be trivial to make that change, nad see what breaks. I think that even if it does break something I may still submit something new for test262 that is more obivously tied those parts of the spec.


2025-04-10
[04:32:06.0353] <Duncan MacGregor>
Okay, there is actually a reasonable amount of testing round this (under its es5 section id), but it's all the `TypeError` cases rather than checking that the arguments are not evaluated if the evaluation of the reference expression itself caused a `ReferenceError` to be raised.


2025-04-11
[17:39:21.0026] <jschoi>
I‚Äôm disappointed to see that Observables didn‚Äôt end up on the April plenary agenda. I wonder what happened there. 
I was looking forward to that one, particularly about its role versus ES Signals.

[17:40:09.0532] <jschoi>
* I‚Äôm disappointed to see that Observables didn‚Äôt end up on the April plenary agenda. I wonder what happened there. 
I was looking forward to that one, particularly about the potential for them to return from WHATWG to TC39 and the intersection of their role versus ES Signals‚Äô.

[18:25:44.0650] <jschoi>
* I‚Äôm disappointed to see that Observables didn‚Äôt end up on the April plenary agenda, at which Dominic Farolino had asked to present. I wonder what happened there. 
I was looking forward to that presentation, particularly about the potential for them to return from WHATWG to TC39 and the intersection of their role versus ES Signals‚Äô.

[05:42:24.0895] <Rob Palmer>
jschoi: DominicF said he will send a PR to put this on the agenda. I just sent him a second reminder to do so.


2025-04-13
[14:47:35.0333] <Chris de Almeida>
The draft schedule is up. Link is available in [the reflector issue](https://github.com/tc39/Reflector/issues/554).

Unfortunately, due to the scope of the constraints, it was not possible to accommodate them all. Furthermore, as scheduling is fluid throughout the meeting, as we move topics up when possible, it is possible that existing met constraints will not necessarily remain that way.

For folks who supplied constraints, *it would be a great help, if at all possible, to reduce the scope of your constraints, either by removing topics, or by increasing your availability during the meeting.* Thank you.

[14:47:42.0666] <Chris de Almeida>
* The draft schedule is up. Link is available in [the reflector issue](https://github.com/tc39/Reflector/issues/554).

Unfortunately, due to the scope of the constraints, it was not possible to accommodate them all. Furthermore, as scheduling is fluid throughout the meeting, as we move topics up when possible, it is possible that existing met constraints will not necessarily remain that way.

For folks who supplied constraints, __it would be a great help, if at all possible, to reduce the scope of your constraints, either by removing topics, or by increasing your availability during the meeting.__ Thank you.

[14:48:39.0785] <Chris de Almeida>
* The draft schedule is up. Link is available in [the reflector issue](https://github.com/tc39/Reflector/issues/554).

Unfortunately, due to the scope of the constraints, it was not possible to accommodate them all. Furthermore, as scheduling is fluid throughout the meeting, as we move topics up as time allows, it is possible that existing met constraints will not necessarily remain that way.

For folks who supplied constraints, **it would be a great help, if at all possible, to reduce the scope of your constraints, either by removing topics, or by increasing your availability during the meeting.** Thank you.

[15:01:47.0217] <jschoi>
How may I get access to the draft schedule on HackMD? (I couldn‚Äôt find instructions in how-we-work or the Matrix logs.)

[15:07:00.0007] <Chris de Almeida>
hold please, looks like I need to fix permissions

[15:07:28.0362] <jschoi>
* How may I get access to the draft schedule on HackMD? The website gives a 403. (I couldn‚Äôt find instructions in how-we-work or the Matrix logs. I made a HackMD account with a username ‚ÄúJSChoi‚Äù.)

[15:07:44.0697] <jschoi>
* How may I get access to the draft schedule on HackMD? The website gives a 403. (I couldn‚Äôt find instructions in how-we-work or the Matrix logs.)

[15:27:27.0018] <Chris de Almeida>
looks like some hackmd bug (which I submitted to them just now). so I'll need to copy into a new doc in my account

[15:29:35.0428] <Chris de Almeida>
link on reflector updated. try now

[15:32:06.0547] <jschoi>
Chris de Almeida: It works now, thank you.

[15:34:05.0202] <nicolo-ribaudo>
Chris de Almeida If AsyncContext cannot be scheduled outside of day 2, could it be at least moved to the morning? I can try to find some time, the earlier the better.

[15:36:05.0766] <nicolo-ribaudo>
Looking at the constraints, it could be swapped (together with the R&T topic, to make 60 mins) with Mark's topic

[15:37:45.0934] <Chris de Almeida>
moved to day 1 am

[15:40:19.0273] <Chris de Almeida>
sorry, I missed that you were also a presenter on that topic


2025-04-14
[20:32:39.0765] <jschoi>
FYI: A late-breaking pull request has been opened for Observables with slides. 
https://github.com/tc39/agendas/pull/1846, https://docs.google.com/presentation/d/1i5_zneksrU7i7ZHcl5EQRzUHGkmXRIQKd-bLfrPRNXY/edit?usp=sharing

[06:51:05.0574] <ryzokuken>
@room starting in 10 minutes!

[07:12:07.0945] <Jesse>
please add yourself to the attendees list in the doc if you're here!

[07:12:38.0299] <Jesse>
(I'm not exactly a newbie when taking notes, but I don't know everyone's abbreviation 100%, I usually go to the attendee list when I'm unsure)

[07:12:49.0595] <dminor>
Question about the next meeting, are we confident enough that A Coru√±a will be in person that delegates can start making travel plans?

[07:13:45.0621] <Michael Ficarra>
it's easier to just keep https://github.com/tc39/notes/blob/main/delegates.txt open

[07:14:22.0674] <Michael Ficarra>
I've already booked my travel üò¨

[07:14:36.0460] <ryzokuken>
yes

[07:15:12.0802] <ryzokuken>
sorry I have no idea why it seemed unclear on the chairs' end: this is most certainly a confirmed meeting, please feel free to book travel

[07:15:33.0476] <ryzokuken>
the interest survey was sent out earlier than usual

[07:16:29.0048] <Michael Ficarra>
it seems weird to have a domain-agnostic "structured data" TC

[07:16:46.0286] <littledan>
tell that to TC49, "programming languages"

[07:16:56.0482] <Michael Ficarra>
I imagine it would require participation from experts in each of the respective (and disparate) domains

[07:17:18.0986] <littledan>
it would, yes. We won't fully found it if we don't get those experts, but initial discussion with the open source communities tends positive

[07:17:22.0680] <Michael Ficarra>
yeah, that's weird and obviously too broad

[07:17:42.0738] <littledan>
well... it's just normal. We also feed into ISO/IEC JTC1 SC22, which is also programming languages...

[07:17:55.0484] <littledan>
note that this TC proposal hasn't been announced publicly

[07:18:03.0865] <littledan>
(at Ecma's request)

[07:18:17.0377] <Michael Ficarra>
I guess you'll have separate TGs that basically don't overlap at all?

[07:21:22.0236] <shu>
what is the upshot of ecma involvement in C#, if that's an analogy here?

[07:22:00.0002] <jschoi>
I‚Äôve been excited about this initiative ever since I heard about it last plenary. 

[07:22:42.0345] <littledan>
the development of C# takes place in https://github.com/dotnet/csharplang yet we standardize it in TC49 later

[07:22:59.0470] <littledan>
TC39's model of doing development in committee is just one possible model, which some TCs follow and others don't

[07:23:01.0090] <shu>
what does one get out of the standardization in TC49

[07:23:52.0324] <Michael Ficarra>
maybe obscure government requirements?

[07:24:00.0987] <littledan>
I don't know much about C#, but for CycloneDX and JSON Schema, there's also need to normatively reference things from other specs, and we've also seen in CycloneDX that creating a standards committee can attract engineering effort to do detailed reviews which just weren't happening on the open source side alone

[07:24:58.0937] <littledan>
I'm very hopeful that we'll get this last sort of value out of the JSON Schema effort, and also that it will help people rally around this version

[07:25:46.0831] <littledan>
yeah but there's also proposed to be a "methodology" TC to find common requirements for such languages and schemas (schemata?)

[07:33:40.0883] <jschoi>
> ECMA404 Status Updates (15m)
> 15m

[07:33:52.0650] <jschoi>
> 15m

[07:34:21.0362] <jschoi>
* It always amuses me how fifteen minutes are allowed to Chip‚Äôs ‚Äúupdate‚Äù.

[07:35:18.0327] <Chris de Almeida>
oh, the agenda numbers for the boilerplate stuff should probably get updated. on the schedule and TCQ it is `1m`

[07:35:49.0284] <Aki>
when i was handling scheduling I used it as agenda timeslot breathing room

[07:36:44.0357] <Steve Hicks>
Chris de Almeida: Not sure what the procedure is or if I'm too late, but I can loosen my constraint to include availability the first hour of Day 4, which if we can swap the two topics that morning would unblock all constraints for Disposable AsyncContext.

[07:37:35.0012] <jschoi>
ü´Å 

[07:42:18.0127] <Chris de Almeida>
ok, we'll see what we can do.  please submit a PR to the agendas repo to update your constraint  üôÇ 

[07:58:07.0218] <Michael Ficarra>
I agree with @shuyuguo:matrix.org: Nicol√≤ is really good at giving clear presentations

[08:06:58.0541] <shu>
i still don't understand mark's concern

[08:07:04.0305] <shu>
it's the promises themselves escaping?

[08:07:10.0214] <shu>
it doesn't seem like a performance thing he's worried about

[08:07:33.0539] <Michael Ficarra>
if a value escapes 262 via a host hook, I consider it accessible to user code

[08:08:12.0266] <shu>
what is the problem in this case if this promise becomes accessible to user code?

[08:08:43.0190] <Michael Ficarra>
no idea

[08:10:32.0913] <littledan>
I'm not sure what Mark meant by "Mathieu will be present at the plenary"--this is the plenary

[08:10:43.0458] <littledan>
more note-takers would be nice!

[08:13:11.0017] <Michael Ficarra>
I understood it as "at some other point during plenary, but not now"

[08:13:40.0377] <Chris de Almeida>
yeah I think he expected him to be here, but is not currently for whatever reason

[08:15:28.0755] <shu>
did he say V8 already does this? sweet

[08:19:42.0197] <Aki>
could the transcriber not be adding all the newlines? 

[08:19:55.0232] <Aki>
or is that a technical constraint for some transcribers but not others?

[08:19:55.0829] <littledan>
we could interrupt the meeting to ask them

[08:20:05.0974] <littledan>
yeah some transcribers have more broken setups than others

[08:20:09.0764] <ryzokuken>
should I?

[08:20:12.0465] <littledan>
and asking them to change it usually leads to confusion on their part

[08:20:16.0838] <littledan>
maybe we should do it anyway?

[08:20:25.0847] <littledan>
we also have some quality variability; this transcriber seems not as good as others

[08:20:43.0811] <littledan>
but we can't tell the person "be better"; we can just tell the company "transcription was good at this time and bad at that time"

[08:21:03.0660] <littledan>
sure, and also say that they can ask for people to go more slowly or for clarification

[08:21:12.0104] <ryzokuken>
okay

[08:21:29.0035] <ryzokuken>
I'll interrupt the presentation after this slide

[08:22:55.0831] <ryzokuken>
let us know if issues persist

[08:22:57.0422] <littledan>
let's write an email to the company. Ujjwal, do you have their contact?

[08:23:02.0842] <ryzokuken>
during the break we could email them

[08:23:04.0280] <ryzokuken>
yeah

[08:23:15.0307] <Jesse>
no notes atm?

[08:23:19.0820] <littledan>
let's also tell them about this quality variability

[08:23:22.0136] <Jesse>
nvm

[08:23:29.0176] <ryzokuken>
are they back Jesse ?

[08:23:31.0592] <Jesse>
yes

[08:23:34.0690] <ryzokuken>
great

[08:24:04.0508] <littledan>
they seem increasingly delayed

[08:24:15.0121] <littledan>
this is a technical issue that they have had previously and fixed...

[08:24:29.0361] <littledan>
eh maybe not so far behind

[08:25:53.0864] <nicolo-ribaudo>
dminor: Could we get to your point at the end of the presentation? (there are still a couple slides not about use cases)

[08:26:05.0552] <nicolo-ribaudo>
* dminor: Could we get to your point at the end of the presentation? (there are still a couple slides not about use cases, specifically about the web integration)

[08:26:17.0823] <dminor>
Ok, sorry, I thought everything had been presented

[08:28:13.0703] <littledan>
To note takers: you can edit the notes to make everything more clear; they are very inaccurate and have a lot of errors. If you put in complete sentences that get across the point, that's better than nonsensical words that might be closer to what was actually said.

[08:35:15.0740] <nicolo-ribaudo>
shu Imagine you have two separate functions: one that takes a callback, and another to actually run the callback taken by the first one.

Old mental model: the context is propagated from the one that takes the callback
New mental model: the context is propagated from the one that runs the callback

[08:35:44.0301] <shu>
that part i got, but i don't understand how the new mental model works with the setTimeout example Andreu gave

[08:35:58.0384] <shu>
how can the new mental model work for setTimeout if the timeout callback isn't the one that captures the AsyncContext?

[08:37:06.0957] <nicolo-ribaudo>
setTimeout both takes the callback, and is the API that you call to ask the browser to at some point run that API. It flows across the awaits, rather than together with the callback

[08:38:52.0326] <ryzokuken>
> When we switched to the next writer, I see that they do not have the correct template in place. I have sent a note off, but she may not see that until this block is completed. I will make sure she has the correct setup in place for the next session.

[08:39:19.0432] <littledan>
that's their response?

[08:39:30.0238] <ryzokuken>
no they emailed me first

[08:39:39.0258] <ryzokuken>
I CC'd you on my response

[08:42:19.0463] <Chris de Almeida>
what's ironic is that Ujjwal's email contains excessive linebreaks üòÑ 

[08:43:01.0991] <ryzokuken>
wait really? it's just two lines total üòõ 

[08:43:13.0297] <ryzokuken>
and my name I guess that's a third line

[08:43:54.0192] <Chris de Almeida>
on my client it's 4 lines 

[08:44:21.0285] <ryzokuken>
oh I guess it's trying to wrap to a certain character limit

[08:52:25.0382] <littledan>
For more on the web integration for AsyncContext: https://github.com/tc39/proposal-async-context/blob/master/WEB-INTEGRATION.md

[08:53:01.0260] <littledan>
For more testimonials from frontend frameworks: https://github.com/tc39/proposal-async-context/blob/master/FRAMEWORKS.md

[08:58:21.0424] <ptomato>
shu: issues that I mentioned: https://github.com/tc39/proposal-intl-era-monthcode/issues/32, https://github.com/tc39/proposal-intl-era-monthcode/issues/30, https://github.com/tc39/proposal-intl-era-monthcode/issues/27, plus various bikeshedding threads about updating the era codes provided by CLDR

[09:17:42.0769] <ljharb>
oof, hard wraps bad

[09:18:21.0875] <ryzokuken>
not my client! I get wrapping while typing and no wrapping while viewing personally.

[09:21:48.0199] <Aki>
Regular reminder to provide Summary and Conclusion in notes. Protip: your summary is generally going to be the summary of what you presented. That means in theory you should be able to write it at the same time you write your slides.

[09:21:48.0948] <Chris de Almeida>
the original email sent was not wrapped.  your response wrapped both the original email in the chain and your new one...  ü§∑

[09:22:57.0225] <jschoi>
I can see the point of https://sembr.org/ at least in version control.

[09:23:25.0550] <ryzokuken>
I love the idea from ptomato where you put the proposed summary as your last slide

[09:23:41.0683] <ptomato>
I didn't do it this time, sorry

[09:23:46.0052] <ryzokuken>
saves you time and you get it 80% or more correct anyway

[09:23:58.0136] <ryzokuken>
you're too cool for it already /s

[09:24:22.0257] <ryzokuken>
but yeah I actually stole the idea from your previous presentations because it made so much sense

[09:30:17.0704] <ljharb>
yeah i'd never heard of that before until tab referenced it in a pattern matching call.

i love hard breaking after the end of a sentence - but i think hard breaking in the middle of a sentence is too arbitrary

[09:30:42.0837] <ljharb>
that really only works for updates tho, right, since you can't safely predict the outcome of advancement?

[09:31:23.0910] <ryzokuken>
skip the advancement but you can still summarize the contents of your presentation 

[09:32:15.0430] <littledan>
yes and the summary should also include the main discussion points that people brought up

[09:32:44.0393] <littledan>
well I like how ptomato put his hoped-for conclusions on consensus in there too

[09:33:46.0854] <ryzokuken>
this but it's a "good ending/bad ending/pacifist ending" type meme video

[09:36:26.0105] <jschoi>
When moving to the next agenda item, should it be a point of order when the second-to-most-recent agenda item has no main discussion points written yet? This would force all agenda items except the most-recent item to have discussion points written down.

[09:43:27.0360] <Michael Ficarra>
please no

[09:43:39.0775] <ljharb>
we've talked about that before, but the general feeling was that that'd be too disruptive and slow down plenary too much

[09:43:48.0410] <Michael Ficarra>
sometimes you're too busy participating in the next topic but can get to it at break or after the meeting

[09:44:03.0596] <Michael Ficarra>
we just don't need hard rules here

[09:44:04.0668] <Chris de Almeida>
_<insert joke about stop coercing things>_

[09:44:22.0876] <ljharb>
the only thing that *must* be written down imo is the outcome of a decision if one is made, the rest is just very very nice to have

[09:44:37.0614] <ljharb>
* the only thing that _must_ be written down imo is the outcome of a decision if one is made (or not made), the rest is just very very nice to have

[09:44:52.0440] <Chris de Almeida>
we have, in the past, paused to actually do it, but we had mixed results and some folks very much did not like it

[09:45:38.0231] <Aki>
false. accurate minutes have to be produced.

[09:45:47.0285] <jschoi>
It could be‚Ä¶a point of order at the next day‚Äôs meeting. (This would not work for the last day‚Äôs meeting.)

[09:46:07.0462] <ljharb>
but they don't have to be verbatim, such that we'd need to pause the meeting to get them down, do they?

[09:46:18.0787] <ljharb>
also isn't the transcriptionist mostly covering that?

[09:46:33.0747] <Aki>
no

[09:46:37.0919] <Aki>
they do not

[09:46:41.0204] <Aki>
no

[09:46:46.0042] <Aki>
the notes are not the minutes

[09:46:57.0522] <Aki>
the minutes are a summary of what was discussed

[09:47:11.0537] <ljharb>
ah ok

[09:49:22.0687] <jschoi>
https://github.com/tc39/notes/blob/af9ce7e48fbb35190b24a042c9b6172ce5c8a1f5/meetings/2024-12/december-04.md#speakers-summary-of-key-points


[09:49:24.0173] <jschoi>
What did the minutes say for this one?

[09:50:06.0973] <jschoi>
Were merely the ‚ÄúConclusions‚Äù (which, unlike the Speaker‚Äôs Summary, were filled out) used?

[09:55:40.0069] <littledan>
no because almost all of the time, none of this is written until after the meeting, but it does get written

[09:55:59.0033] <littledan>
the point of order should be more about whether we have consensus and such

[09:56:19.0528] <littledan>
people generally don't end up wanting to dictate a good summary during the meeting (when they do dictate it, it doesn't tend to be good enough)

[09:57:04.0540] <littledan>
the most helpful thing would be if more people helped with fixing up the notes, both during and after the meeting

[09:57:24.0337] <littledan>
the goal is to be coherent and intelligible and make the important points -- it's OK if you change words to make this happen

[10:00:05.0120] <jschoi>
‚ÄúYou are an amazing technical copyeditor. The following input text is transcribed notes from a technical standards meeting, formatted in Markdown. Reword the dialogue to be coherent, intelligent, and make the important points. It‚Äôs OK if you change words to make this happen. Do not change the acronyms at the beginning of each paragraph. Do not change the headings. <input-text>‚Ä¶‚Äù ü•≤

[10:00:47.0763] <Aki>
actually _not allowed_ believe it or not

[10:00:54.0309] <Aki>
ISO is very clear about this

[10:00:56.0803] <ljharb>
shitposting is for tdz :-p

[10:05:26.0659] <littledan>
the new notetaker is good again!

[10:06:50.0417] <ljharb>
* yeah i'd never heard of that before until tab referenced it in a pattern matching call last year.

i love hard breaking after the end of a sentence - but i think hard breaking in the middle of a sentence is too arbitrary

[10:33:35.0989] <bakkot>
kinda like the idea of having a conventional `.composite()` method which gives you a composite representation of your object

[10:34:16.0189] <bakkot>
when your object is conceptually immutable like Temporal objects then it could cache the result internally

[10:34:50.0212] <Michael Ficarra>
does a chair wanna shift my topics down so they're back-to-back? /cc @softwarechris:matrix.org @usharma:igalia.com

[10:34:54.0334] <jschoi>
bakkot: Did you mean to put a summary about #2600 / Array.fromAsync into the ‚ÄúNormative: Mark sync module evaluation promise as handled‚Äù section?

[10:35:00.0010] <bakkot>
oops

[10:35:12.0929] <Michael Ficarra>
protocol please!

[10:35:28.0634] <bakkot>
fixed

[10:35:30.0426] <ryzokuken>
wait where's your next topic

[10:35:40.0808] <bakkot>
Michael Ficarra: even if there's a protocol it should have a conventional string name

[10:35:55.0022] <Michael Ficarra>
@usharma:igalia.com I mean TCQ

[10:35:56.0892] <bakkot>
but yeah a protocol that `Composite` used could be fun

[10:36:10.0179] <ryzokuken>
oops sorry I moved Kevin's

[10:36:17.0362] <bakkot>
so you look up the symbol key first and if it's there you use that and if not you do the factory function thing

[10:36:21.0088] <ryzokuken>
done

[10:36:26.0774] <ryzokuken>
sorry for the confusion

[10:36:40.0947] <Michael Ficarra>
thanks

[10:37:15.0116] <Michael Ficarra>
TCQ topics should have a "push me lower in the queue" button

[10:39:09.0144] <Chris de Almeida>
https://github.com/bterlson/tcq/issues/8

[10:39:46.0306] <Michael Ficarra>
https://github.com/bterlson/tcq/issues/69

[10:40:15.0814] <Michael Ficarra>
not edit/remove, just move down, it's different

[10:40:34.0181] <Chris de Almeida>
there's also https://github.com/bterlson/tcq/issues/16

[10:41:08.0508] <Chris de Almeida>
I wonder how that TCQ reloaded project is going ü§î

[10:41:59.0709] <Michael Ficarra>
it's a web app, how hard could it possibly be?

[10:52:23.0241] <bakkot>
littledan re "ways to avoid people using these for deep immutable structures", not having syntax will go a long way I think

[10:52:51.0439] <littledan>
I agree, but I also don't know what the bad part is about the possible future evolution that Ashley mentioned

[10:53:07.0865] <littledan>
(I understand "this makes canonicalization unworkable")

[10:54:45.0639] <littledan>
I'm still wondering about the GC thing even if we don't allow them in WeakMaps and WeakRefs. Won't it still be hard to manage the interning table's memory, so you can collect unused things?

[10:56:49.0960] <littledan>
I don't think symbol sorting is a fatal flaw of canonicalization -- we can just ban unregistered symbol keys, like R&T did.

[10:57:35.0142] <bakkot>
Michael Ficarra: your point about "this should use -0 because it's observable" is directly contradicted by your immediately preceding "we don't need to sort because it's only Composite.equals not actual equality"

[10:57:43.0342] <bakkot>
* Michael Ficarra: your point about "this should use SameValue because it's observable" is directly contradicted by your immediately preceding "we don't need to sort because it's only Composite.equals not actual equality"

[10:57:59.0154] <ljharb>
we don't need to sort because the order in which the keys are compared doesn't matter

[10:58:19.0608] <bakkot>
if we don't care about key order for use of set/map/etc, even though it's observable, then we _definitely_ don't have to care about -0 vs 0 in the same context, even though it's observable

[10:58:58.0145] <ljharb>
it's not about ordering for me for -0, it's that you can't get a `-0` key *out* of a Map or value out of a Set, but you can get it out of a Composite.

[10:59:05.0324] <bakkot>
sorry, was having trouble with my mic

[10:59:13.0324] <bakkot>
you can get the ordered keys out too

[10:59:30.0391] <jschoi>

eemeli: Your video is on, just in case this was accidental.

[10:59:59.0580] <bakkot>
* if we don't care about key order for use in set/map/etc, even though it's observable, then we _definitely_ don't have to care about -0 vs 0 in the same context, even though it's observable

[11:00:07.0316] <littledan>
we had such a big fight about people insisting that R&T use SameValueZero, not SameValue, and this made canonicalization and implementations more complex, which was a big factor in the proposal not moving forward. I'm kind of astounded that, after that, we're talking about going in the other direction, when nothing has changed with respect to -0 from that previous proposal.

[11:00:12.0433] <ljharb>
sure. but you can't ever have a `-0` key in a Map, or a `-0` value in a set

[11:00:18.0565] <bakkot>
ok?

[11:00:29.0758] <ljharb>
but you can get a `-0` key out of a Composite

[11:00:30.0231] <bakkot>
I don't know why that implies anything about whether this should use SameValue or SameValueZero

[11:01:04.0574] <littledan>
we could also define canonicalization for Composites and drive things on that, but I don't see the point

[11:01:13.0369] <littledan>
* we could also define normalization in terms of +0 for Composites and drive things on that, but I don't see the point

[11:01:21.0023] <bakkot>
we definitely don't want to canonicalize -0 in composites

[11:01:33.0025] <littledan>
I mean, we could do it just when used as Map/Set keys

[11:01:37.0546] <littledan>
but yeah I agree, that'd be silly

[11:01:45.0228] <ljharb>
to be clear there's at least 2 of us that think that Map/Set using SameValueZero was a mistake, and that we shouldn't further that mistake here

[11:02:14.0212] <littledan>
we should be establishing such understandings of mistakes by consensus, like we did via @@species. Other people feel the opposite way, I think.

[11:02:40.0111] <ljharb>
that would be ideal, sure, but each of us is allowed to hold those kinds of beliefs and use them to inform our positions

[11:02:44.0967] <ljharb>
* that would be ideal, sure, but each of us is allowed to hold those kinds of beliefs and use them to inform our positions even sans consensus

[11:03:45.0164] <Justin Ridgewell>
Isn't it weird that `new Set([0]).has(-0)` and `new Set([Composite(0)]).has(Composite(-0))` would be different?

[11:03:52.0867] <bakkot>
it is a little weird

[11:04:04.0318] <bakkot>
* it is a lot weird

[11:04:20.0094] <ljharb>
a composite is a brand new thing

[11:04:39.0137] <nicolo-ribaudo>
Fyi Mark, `let x = {}; new Object(x) === x` is true

[11:04:47.0730] <bakkot>
the point of a composite is that it _composes_ multiple values for use in Sets etc

[11:05:00.0038] <bakkot>
it should not also change how those things are compared in Sets

[11:05:11.0966] <ljharb>
(also `Promise(promise) === promise` for any promise)

[11:05:14.0378] <ljharb>
* (also `Promise.resolve(promise) === promise` for any promise)

[11:05:33.0025] <ljharb>
composing IS changing that

[11:05:39.0179] <bakkot>
no it isn't

[11:05:56.0667] <Michael Ficarra>
it's not, you've been fooled by the coercion in the example

[11:06:16.0827] <bakkot>
from a users point of view the fact that the coercion happens is irrelevant

[11:06:35.0860] <littledan>
maybe this should be part of our process discussion

[11:06:37.0662] <Michael Ficarra>
it's not because you can look at the Set and see that it does not in fact have `-0`

[11:06:37.0731] <bakkot>
the way users can and do think of this is that Set/Map compare `-0` as equal to `0`

[11:06:47.0484] <ljharb>
that's a strange statement from "stop coercing things" :-p

[11:06:51.0700] <bakkot>
something which ~ no people do

[11:07:08.0060] <ljharb>
if you want to run a topic on it sure, but it's entirely distinct from the consensus topic, if that's what you mean

[11:07:14.0281] <Michael Ficarra>
if you want an actual understanding of what's going on, you do, and that's who we're talking about right now

[11:07:16.0701] <ljharb>
* if you want to run a topic on it in a future plenary sure, but it's entirely distinct from the consensus topic, if that's what you mean

[11:07:35.0346] <bakkot>
no, we're talking about the behavior of `new Set([Composite(0)]).has(Composite(-0))`

[11:08:05.0465] <Michael Ficarra>
that is a statement that appears to me to be *obviously false*

[11:08:11.0773] <Michael Ficarra>
like, look, they're different things

[11:08:14.0327] <bakkot>
just you though

[11:08:40.0990] <Michael Ficarra>
they're symbolically different!

[11:08:47.0385] <bakkot>
who cares?

[11:08:55.0742] <bakkot>
`0 === -0` and Composites are for composing equality for Sets

[11:09:01.0632] <Michael Ficarra>
something weird has to happen to make them the same

[11:09:12.0575] <bakkot>
the weird thing is that `0 === -0`

[11:09:17.0925] <bakkot>
but that thing has already happened

[11:09:33.0732] <shu>
yeah the weird thing is a well known cross-language, widely known IEEE fact?

[11:09:36.0736] <bakkot>
`Composite({ x: 0, y: 1 })` and `Composite({ y: 1, x: 0 })` are also symbolically different

[11:09:51.0996] <bakkot>
but as you very correctly point out, they should still be considered equal for purposes of `Set`

[11:09:58.0434] <bakkot>
because the point of Composites is to compose equality

[11:10:03.0158] <bakkot>
not to also do some weird key ordering stuff

[11:10:22.0681] <ljharb>
right, but what kind of equality. we have 4 i think

[11:10:28.0643] <ljharb>
and the one maps and sets use is the weird one

[11:10:30.0642] <bakkot>
SameValueZero

[11:10:33.0926] <bakkot>
the kind Sets use

[11:10:37.0935] <littledan>
Michael Ficarra: What did you think about all of this when we were discussing R&T previously?

[11:10:39.0966] <ljharb>
right but that's the weird one.

[11:10:52.0448] <bakkot>
we're talking about Sets

[11:10:58.0671] <bakkot>
and other things which already use SameValueZero

[11:10:58.0758] <littledan>
also ljharb I thought you wanted this behavior too?

[11:11:01.0417] <ljharb>
R&T was syntax at that point

[11:11:04.0784] <ljharb>
* R&T was syntax at that point, this is different

[11:11:13.0101] <littledan>
What does it being syntax change?

[11:11:21.0025] <littledan>
you didn't need to use R&T syntax to use the feature

[11:11:22.0694] <ljharb>
composites and R&T are different beasts, i'm not sure why those discussions dictate these

[11:11:31.0162] <ljharb>
sorry, not syntax, primitives

[11:11:53.0567] <littledan>
ah OK thanks for clarifying

[11:11:58.0367] <littledan>
so... why does that change what's appropriate?

[11:12:13.0448] <littledan>
Not saying the discussions dictate it, just trying to follow the logic

[11:12:24.0252] <Michael Ficarra>
these have identity and we're talking about a built-in function, not SameValue or strict equality as applied to them

[11:12:32.0785] <ljharb>
R&T were Map and Set analogues. Composite isn't.

[11:12:49.0486] <ljharb>
so it's not so clear-cut that they match what Map and Set do.

[11:13:04.0434] <ljharb>
* so it's not so clear-cut that they must match what Map and Set do.

[11:13:22.0338] <littledan>
what are Map and Set analogues?

[11:13:24.0486] <bakkot>
the whole point of Composite is for use in Map and Set

[11:13:58.0748] <littledan>
OK, could you trace the next step in the logic here for how it connects to what Map and Set should do?

[11:14:13.0086] <bakkot>
(and things like `includes` which also use SameValueZero)

[11:14:34.0463] <Michael Ficarra>
@bakkot:matrix.org there's nothing like `includes`, it's the only thing in the spec that uses it

[11:14:42.0325] <ljharb>
yeah includes is also weird :-/ `[0].includes(-0)` is obviously wrong, because they're different things

[11:14:45.0515] <Michael Ficarra>
again, SameValueZero is *weird*

[11:15:02.0443] <ljharb>
it's also very very easy to *get* SameValueZero semantics if you want them; it's very very hard to *unget* them

[11:15:06.0300] <bakkot>
it is obviously right because `-0 === 0`

[11:15:11.0010] <ljharb>
* it's also very very easy to _get_ SameValueZero semantics if you want them; it's very very hard to _unget_ them if you don't

[11:15:18.0555] <ljharb>
sure, so `[NaN].includes(NaN)` must be false then?

[11:15:42.0837] <ljharb>
the obviousness isn't about `===` it's about what the literal values are

[11:15:46.0873] <bakkot>
no because if you're asking if something includes NaN, and it does, then the answer is "yes" not "no"

[11:16:02.0345] <ljharb>
and `[0]` doesn't include a negative zero

[11:16:10.0143] <ljharb>
the question is using "is" semantics, not "===" semantics

[11:16:23.0645] <bakkot>
but it does include a zero and -0 is a zero

[11:16:35.0754] <bakkot>
anyway, this ship has sailed

[11:16:38.0676] <ljharb>
* and `[0]` doesn't include a negative zero, it only has a positive zero in it

[11:16:46.0848] <bakkot>
I don't care to convince you that Map and `includes` have the right semantics

[11:17:00.0697] <ljharb>
for the existing things ofc. i'm explaining why they're weird and shouldn't be followed for new things

[11:17:03.0109] <bakkot>
only that they do have the semantics that they do, and that the point of Composite is to compose existing things not change how they work

[11:17:18.0047] <ljharb>
and `-0` and `0` are observably different existing things.

[11:17:31.0104] <ljharb>
i don't see Composites as only for Map and Set, maybe that's the difference

[11:17:43.0470] <ljharb>
it's not `CollectionComposite` or something, it's "compose multiple values"

[11:18:00.0861] <bakkot>
`Composite({ x: 0, y: 1 })` and `Composite({ y: 1, x: 0 })` are also observably different

[11:18:18.0452] <ljharb>
* it's not `CollectionComposite` or something, it's "compose multiple values", which is much broader

[11:18:19.0196] <Michael Ficarra>
Map and Set are not precedent for SameValueZero because 1) they don't use it and 2) there is no observable difference between the cases where they would use them

[11:18:37.0073] <bakkot>
compose for what purpose? to use as a key in a Map or Set

[11:18:39.0328] <kriskowal>
My intuition is that if 0 and -1 are not meaningfully different in the relevant domain, 0n is right there.

[11:18:44.0351] <bakkot>
if you aren't putting them in a Map or Set you can just use a regular object

[11:18:57.0210] <Michael Ficarra>
not via Composite.equals they're not

[11:19:14.0324] <ljharb>
not if i want trivial equality checks like Composite.equal

[11:19:22.0314] <kriskowal>
* My weak intuition is that if 0 and -1 are not meaningfully different in the relevant domain, 0n is right there.

[11:19:35.0265] <bakkot>
well, neither are `Composite({ x: -0 })` and `Composite({ x: 0 })`

[11:20:05.0411] <Michael Ficarra>
we have a choice there, and I say those should be different

[11:20:14.0530] <bakkot>
your argument is circular

[11:20:24.0632] <Michael Ficarra>
we have a completely unconstrained choice, we should not choose to go down the SameValueZero route

[11:20:28.0696] <bakkot>
you say they should be different because they're observably different because you want them to be different

[11:20:45.0107] <bakkot>
* you say they should be different because they're observably different via `Composite.equals` because you want them to be different

[11:20:47.0131] <Michael Ficarra>
yes! I want them to be different!

[11:21:11.0670] <bakkot>
ok but you can't make the argument based on `Composite.equals`

[11:21:22.0746] <bakkot>
because you are arguing what the behavior of `Composite.equals` should be

[11:22:08.0128] <bakkot>
my point is that we all agree that `Composite({ x: 0, y: 1 })` and `Composite({ y: 1, x: 0 })` are observably different, but that this does not imply they should be different for the purposes of `Composite.equals`

[11:22:29.0475] <bakkot>
so "these valeus are observably different" is not sufficient to argue that things should be different from `.equals`

[11:22:47.0727] <Michael Ficarra>
I am not making the argument base on Composite.equals, I am saying that 1) for composites, we need not take into account their SameValue or strict equality when deciding whether keys need to be observably in the same order for Composite.equals, and 2) all non-Composite values should be compared using SameValue because there's nothing else constraining us and that's the best choice

[11:22:50.0789] <bakkot>
* so "these values are observably different" is not sufficient to argue that things should be different from `.equals`

[11:23:26.0311] <bakkot>
the thing constraining us is how Map and Set already work

[11:23:35.0882] <Michael Ficarra>
it's not, and I've explained that quite clearly

[11:23:42.0848] <ljharb>
the way ashley described the argument to `Composite` to me is that the object is just a named list of positional arguments - it could also be `Composite(0, 1)` or `Composite([0, 1])` and be conceptually the same

[11:23:43.0527] <bakkot>
no

[11:23:45.0907] <bakkot>
you have asserted otherwise

[11:23:47.0737] <bakkot>
and yes I know they do not mechanically work that way anymore

[11:23:55.0594] <ljharb>
meaning that conceptually the top-level order is irrelevant for comparison

[11:23:58.0648] <bakkot>
but again, this is completely irrelevant for users

[11:24:17.0789] <ljharb>
for some number of them. but we're users too.

[11:24:21.0838] <bakkot>
for users, you think of Map and  Set as using SameValueZero

[11:24:27.0416] <bakkot>
we even added an editorial note about that

[11:24:28.0033] <Michael Ficarra>
it's unobservable which comparison operation Maps and Sets use! how can it be precedent?

[11:24:30.0379] <ljharb>
and Composite isn't Map or Set.

[11:24:32.0688] <bakkot>
because this is the correct mental model for users to have

[11:24:46.0746] <ljharb>
then that's probably a core point of disagreement

[11:25:39.0916] <shu>
are there key sorting concerns with -0, or just anonymous symbol keys?

[11:25:48.0835] <bakkot>
just anonymous symbol keys

[11:26:02.0105] <ljharb>
that concern only applies if equality is order-dependent, tho, yes?

[11:26:02.0738] <bakkot>
anonymous or same-named

[11:26:16.0612] <Michael Ficarra>
@shuyuguo:matrix.org I don't think anyone wants keys to be sorted, either for comparison or for enumeration

[11:26:24.0435] <bakkot>
well, Shu wanted canonicalization

[11:26:28.0195] <shu>
am i anyone

[11:26:29.0655] <bakkot>
and you can't canonicalize without ordering

[11:26:40.0490] <shu>
i don't think i _want_ ordering per se

[11:26:43.0468] <Michael Ficarra>
ah, fair, I thought we had given up on that

[11:26:46.0659] <shu>
but i also don't care about global communication channel here

[11:27:07.0822] <shu>
so if i strengthen my position on canonicalization we might need to find another way to compromise on that, or be at an impasse

[11:27:11.0530] <ljharb>
so wait, did composite not get stage 1?

[11:27:18.0210] <shu>
it did

[11:27:23.0691] <shu>
these aren't stage 1 concerns afaict?

[11:27:31.0486] <ljharb>
oh ok cool, it's not in the notes yet

[11:27:33.0687] <ljharb>
correct

[11:29:05.0196] <bakkot>
Michael Ficarra ^

[11:29:29.0162] <shu>
man f'ing matrix

[11:29:31.0534] <shu>
can't see the image

[11:29:38.0217] <ljharb>
yes that's the one place

[11:29:46.0276] <bakkot>
see the right hand side

[11:29:52.0328] <bakkot>
where we say "as in Map and Set methods"

[11:29:55.0176] <ljharb>
Map and Set *could* be specified to use it, instead they canonicalize to `+0`, but they're semantically equivalent

[11:30:01.0486] <bakkot>
specifically we did this because it is how users understand it to work

[11:30:06.0830] <Michael Ficarra>
yeah like `has`

[11:30:07.0269] <bakkot>
and it is how users _should_ understand it to work

[11:30:10.0410] <ljharb>
(fwiw i don't think it's relevant that Map/Set aren't written to use it)

[11:30:21.0387] <ljharb>
* (fwiw i don't think it's relevant that Map/Set aren't written to use the AO, they still use SameValueZero)

[11:30:25.0535] <ljharb>
* (fwiw i don't think it's relevant that Map/Set aren't written to use the AO, they still use SameValueZero conceptually)

[11:31:36.0287] <ljharb>
did we even debate that? it was in es2016, and it was only deferred from 2015 for mootools - i suspect the choice was made from the same (imo wrong) intuition that led to Map and Set using it

[11:31:58.0993] <bakkot>
it's a picture of the description of Number::SameValueZero where we say it is "to test for value equality, ignoring the difference between +0 and -0, as in Array, Map, and Set methods"

[11:32:03.0172] <ljharb>
iow i think all 3 of those places were chosen at the same time, pre-ES6, and thus invented a new kind of equality

[11:32:19.0190] <waldemar>
That capybara likes to live dangerously

[11:32:21.0554] <bakkot>
they invented a new, better kind of equality

[11:32:39.0546] <bakkot>
`===` is almost the thing you want, except for `NaN`

[11:32:44.0004] <littledan>
I think the first thing to resolve is whether the overall model that Ashley put out there is a good one (Shu raised doubts which we need to work through), and then the SameValue vs SameValueZero question is a smaller one within that.

[11:32:55.0796] <littledan>
so I'd really like to hear more concerns about that broader question

[11:33:29.0072] <waldemar>
* That capybara (on the slide) likes to live dangerously

[11:33:37.0436] <Michael Ficarra>
replaceability is the right kind of equality

[11:34:07.0727] <littledan>
this would only be met by identity-wise canonicalization as Shu proposed

[11:34:49.0431] <shu>
to repeat: my broader stage 1 question is how commital are people, really, about the keys vs immutable use case? big part of V8's performance feedback was contradictory performance expectations were in play. if you leave the design space flexible enough for a glorious immutable data future, then we're back in the same place

[11:35:17.0582] <shu>
* to repeat: my broader stage 1 question is how commital are people, really, about the keys vs immutable data use case? big part of V8's performance feedback was contradictory performance expectations were in play. if you leave the design space flexible enough for a glorious immutable data future, then we're back in the same place

[11:35:47.0520] <bakkot>
I personally would like to commit to the "composite key" case

[11:35:51.0604] <bakkot>
makes a lot of things simpler

[11:35:54.0162] <bakkot>
no prototypes, for example

[11:36:01.0967] <shu>
and my view is composite keys is cool w/ me. highly skeptical of immutable data

[11:36:08.0314] <littledan>
Queue: 1
Reply: this contradicts your previous topic
Kevin Gibbons
2
New Topic: Why not "new Composite()"?
Eemeli Aro (@mozilla)
3
New Topic: Should either lean in or out more; e.g. "Key" or "Record" rather than "Composite".
Eemeli Aro (@mozilla)
4
New Topic: +1 for stage 1 <EOM, won't be present when this is read>
Jordan Harband (@herodevs @tc39 )
5
New Topic: support stage 1 </end>
Chris de Almeida (@IBM)
6
New Topic: SpiderMonkey team supports Stage 1 <eom>
Daniel Minor (Mozilla Corporation)

[11:37:49.0338] <jschoi>
Invited experts can‚Äôt block; can they give support?

[11:38:11.0634] <shu>
to be frank, my read of ashley's answer on "in the future i'd like my keys and data to be one and the same" is champions aren't completely committed

[11:38:19.0706] <shu>
* to be frank, my read of ashley's answer of "in the future i'd like my keys and data to be one and the same" is champions aren't completely committed

[11:38:31.0143] <shu>
IME you do not design hash table keys to be the same as your data

[11:38:45.0685] <shu>
you need to do work to figure out what are the things you key on

[11:38:49.0430] <bakkot>
not writing a lot of Java huh?

[11:38:57.0957] <shu>
wow do they really do that?

[11:38:58.0088] <littledan>
yes definitely

[11:39:18.0560] <bakkot>
well, Java you define hash and equals and that is the normal way of things

[11:39:35.0619] <bakkot>
and you do that for your normal values

[11:39:39.0423] <Michael Ficarra>
on *everything*, it's ludicrous

[11:39:39.0843] <bakkot>
and then stick them in maps

[11:39:49.0744] <shu>
and you... just key on arbitrarily complex graph-of-objects?

[11:39:57.0747] <bakkot>
uh huh

[11:40:13.0083] <shu>
wtf

[11:40:24.0020] <shu>
what are they doing over there

[11:40:50.0568] <littledan>
I'd like to understand the implications better here

[11:41:26.0467] <rbuckton>
C# is similar, though you also have `IEqualityComparer`

[11:41:36.0479] <littledan>
I mean, how does this differ from keying off an arbitrarily long string?

[11:42:00.0858] <littledan>
(as Ashley explained, there are no cycles, and I guess ropes are dags in general too)

[11:42:07.0020] <shu>
it's what i was saying, but based on my priors that surely, given complex data, one would take care to figure out a _separate_ key structure so you don't walk your entire data on hash collisions, or you don't walk your entire data to compute the hash

[11:42:28.0547] <littledan>
right, agreed

[11:42:46.0077] <waldemar>
TCQ shuffling has been having issues today. My topic got deleted twice. I thought that was intentional and didn't want to add it a third time. MAH resurrected it.

[11:42:50.0682] <littledan>
but, if people just use one of these things as an immutable data structure and not as a key, what's the problem?

[11:43:33.0488] <shu>
oh, because how we implement and optimize the keys use case, which is about shallower DAGs with fewer objects, is very different with deeper DAGs with many objects

[11:43:40.0300] <shu>
and i think they're somewhat opposing

[11:43:47.0666] <Michael Ficarra>
I think maybe it was on purpose because we were running low on time at the end of that topic.

[11:43:50.0981] <shu>
you asked for specifics i had in mind other than canonicalization, and i don't at this time

[11:44:00.0082] <littledan>
yeah I want to dig into this opposition somehow

[11:44:00.0847] <shu>
* you (littledan) asked for specifics i had in mind other than canonicalization, and i don't at this time

[11:44:23.0472] <littledan>
like how this relates to long strings

[11:44:49.0391] <shu>
let me redirect it back to you, do you think canonicalization by itself isn't sufficiently convincing to make the proposal more inflexible?

[11:46:31.0239] <littledan>
I don't quite understand the case for canonicalization. I was wondering about writing a microbenchmark with sets and other affected operations to see how bad it is to add another case to the condition, when it's not taking.

[11:46:40.0086] <littledan>
* I don't quite understand the case for canonicalization. I was wondering about writing a microbenchmark with sets and other affected operations to see how bad it is to add another case to the condition, when it's not taken.

[11:47:18.0325] <shu>
it's not just maps and sets, but also all future algorithms and library designs, right?

[11:49:23.0366] <shu>
one facet of the "don't overload ===" concern from implementers was diffuse cost that make the feature not "pay as you go". this current direction imagines a future where the message to library authors and stdlib algorithms is, "the new === is === + Composite.equals". that future does not penalize _old_ code, which is great! but that future still does not bottleneck the cost to truly only users of Composites, if the new pattern is adopted at scale

[11:49:59.0506] <littledan>
well, I'm having some mental lack of creativity to figure out what future things it will affect. For example, it's not a factor in queues.

[11:49:59.0649] <shu>
that's what i'm thinking through. it is still a strictly better situation than the old one, tbc

[11:50:16.0729] <shu>
well, neither was === an issue in queues...

[11:50:22.0845] <littledan>
I guess in real-world performance, the oldest stuff matters the most

[11:50:43.0014] <littledan>
sure, queues is just an example of "I can't think of anything", maybe you can

[11:50:59.0716] <shu>
so the case for canonicalization is that it very explicitly bottlenecks the performance to the `Composite` constructor

[11:51:15.0257] <shu>
and seems to be a fine tradeoff to me if we truly believe the keys use case

[11:51:18.0473] <Ashley Claymore>
Note: you would only need to walk the entire data on hash collisions if every part of the tree was also a hash collision, as each node would have an individual hash

[11:51:38.0080] <bakkot>
yeah but you do need to do that in the "things are equal" case

[11:51:40.0875] <bakkot>
which comes up a lot

[11:51:47.0095] <shu>
(mark's global communication channel concern notwithstanding, that's a specific technical thing i have no comment on atm)

[11:52:07.0656] <nicolo-ribaudo>
With the captioners we are not using regexps on the notes anymore, right? I'm currently replacing manually a lot of "model"s with "module"s

[11:53:08.0636] <Ashley Claymore>
yeah, the equals case is always the slowest case.
Though you also need to walk the whole thing to canonicalize it.

[11:53:22.0395] <ryzokuken>
btw reflector for the next plenary is posted: https://github.com/tc39/Reflector/issues/558

[11:53:30.0848] <Ashley Claymore>
and you could canonicalize under the hood

[11:53:33.0732] <shu>
yeah, i'm not saying there is a better algorithm available

[11:53:37.0912] <shu>
it's about where that cost shows up

[11:53:49.0993] <Ashley Claymore>
yeah. I think it's a great point

[11:53:51.0711] <shu>
you can't canonicalize under the hood, that's very visible via object identity, no?

[11:54:00.0929] <Ashley Claymore>
I mean internally

[11:54:04.0694] <ryzokuken>
along with a link to the sign-up form within which includes some pretty important questions that would help us organize stuff so please check it out and sign-up if you plan to attend in person.

[11:54:07.0389] <shu>
not sure what you mean

[11:54:08.0327] <Ashley Claymore>
have a seperate pointer

[11:54:13.0282] <shu>
ah

[11:54:14.0088] <ryzokuken>
we'll add more details over the next few days

[11:54:53.0491] <nicolo-ribaudo>
Well ashley I hope for your discussion we didn't have any "model Records", because they have all been Ctrl+H'ed away

[11:55:55.0693] <bakkot>
even for the case of keys I am not convinced it makes sense to pay up front

[11:55:58.0251] <jschoi>
I did want Records for my data models.

[11:56:06.0931] <bakkot>
like `emptySet.has(Composite({ x, y, z }))`

[11:56:41.0346] <littledan>
We told them about this; they should be reflecting that; we should point them to this again and ask them to do better ryzokuken 

[11:57:02.0677] <bakkot>
many languages have composite keys for maps in some form (often through user-provided hash+equals functions) and I think ~ none of them use canonicalization

[11:57:24.0069] <littledan>
can you elaborate on this?

[11:57:24.0417] <bakkot>
so if we bill this as composite keys I think users will expect similar performance characteristics to those languages

[11:57:36.0290] <shu>
hm, i see. like python's tuples you're thinking of?

[11:57:40.0693] <littledan>
are there any particular examples you have in mind?

[11:57:42.0152] <bakkot>
or C++ maps

[11:57:48.0131] <bakkot>
or Java

[11:57:54.0870] <bakkot>
or C#

[11:57:58.0621] <shu>
C++ maps have fully hookable everything

[11:58:10.0534] <shu>
there's just no need to make that decision at the language level is my understanding

[11:58:25.0264] <shu>
but that siad, it's still a signal that popular stdlibs don't provide such functionality

[11:58:37.0018] <bakkot>
fair but the normal way I see people using a C++ map is to have hash and equals functions which compute those values on the fly

[11:58:54.0012] <bakkot>
and maybe cache the hash in the object, depending

[11:59:14.0024] <bakkot>
where "on the fly" means "when the functions are invoked called by the map"

[11:59:16.0219] <Ashley Claymore>
that's what the polyfill does, computes the hash on the first request for it

[11:59:16.0553] <bakkot>
* where "on the fly" means "when the functions are invoked by the map"

[12:00:01.0323] <littledan>
it sounds hard GC-wise to deal with canonicalization--how do you decide whether something is still relevant to include in your global table? I guess the values are all WeakRefs and then you sweep it for tombstones? I thought that would have its own cost.

[12:00:15.0132] <shu>
yeah, it'd be a weak table you'd have to sweep

[12:00:31.0874] <shu>
it has cost in a vaccuum, but it's "just another such table" since this pattern shows up all over the place in v8

[12:00:33.0024] <littledan>
weak by value though, right?

[12:00:33.0481] <shu>
and i imagine other engines

[12:00:37.0975] <shu>
weak by value, yes

[12:01:02.0688] <shu>
but good point on the cost, it ups the barrier of entry

[12:01:35.0543] <littledan>
? Python isn't popular?

[12:02:11.0704] <littledan>
I thought Bradley had a whole list of these things

[12:02:46.0074] <shu>
wat

[12:02:59.0603] <shu>
that was responding to about C++

[12:02:59.0744] <littledan>
Python has composite key functionality, via tuples

[12:03:24.0438] <shu>
my view is python's performance culture as an ecosystem is just... very different

[12:03:24.0840] <littledan>
oh ok

[12:03:37.0704] <shu>
i don't wish to dismiss it out of hand but they deal with performance issues very differently (write c++ libs)

[12:04:11.0057] <littledan>
yes but also, we (Bloomberg) are working with others in the Python community on a JIT...

[12:04:30.0404] <littledan>
(not PyPy, but rather a less cool one that preserves all the things that make Python work well in practice)

[12:04:39.0894] <littledan>
* (not PyPy, but rather a less cool one that preserves all the things that make CPython work well in practice)

[12:05:08.0005] <shu>
sounds fun

[12:06:56.0066] <Michael Ficarra>
I don't like these short days during remote meetings, my work day is pretty much shot anyway, we should just have more meeting time per day and give me back my Thursday

[12:07:44.0136] <Ashley Claymore>
I really like the shorter remote plenary days. I don't have your stamina Michael

[12:08:04.0966] <littledan>
<del>un</del>popular opinion: immutability is good actually and people should use it where it makes sense, rather than making everything mutable by default just because, so we should make it convenient somehow or other (even if it's not through the Composite proposal)

[12:08:35.0963] <littledan>
it's a case of using a less powerful construct because you don't need that extra power

[12:12:14.0580] <jschoi>
JS performance culture in ten years: ‚ÄúWrite WASM libs.‚Äù

[12:12:42.0583] <jschoi>
(This is a joke that I should have put in TDZ.)

[12:12:47.0868] <shu>
then we can design the language differently in 10 years

[12:13:23.0664] <littledan>
what do you mean?

[12:20:19.0164] <jschoi>
Presumably that JavaScript engines deal with performance differently than Python because there is no good recourse for developers that need fast JavaScript. Python has C; JavaScript has WASM. But WASM‚ÄìJavaScript interoperability is still very early, unlike Python and C, and for the foreseeable future the buck for JavaScript performance stops with JavaScript engines. I am guessing on behalf of Shu.

[12:21:14.0740] <eemeli>
> <@michaelficarra:matrix.org> I don't like these short days during remote meetings, my work day is pretty much shot anyway, we should just have more meeting time per day and give me back my Thursday

I'd also prefer longer remote days -- provided that they're based in a European time zone. This week's meetings are ending at 22:00 local time for me, and I'd really rather not work any later.

[12:23:22.0304] <Michael Ficarra>
We all have to make a sacrifice at some point. The next meeting is at 01:00 to 08:00 for our West coast American friends, which seems a lot worse than working past 22:00 to me.

[12:28:11.0501] <jschoi>
Do we not have any notes for the withdrawal of Records/Tuples?

[12:28:12.0963] <Ashley Claymore>
@syg am I right in thinking that v8 already needs to load pointers when doing object equality because the pointer tags don't store if the values might be strings? Or am I mixing up the different engine nan tagging schemes 

[12:29:00.0507] <littledan>
sometimes you have to refresh the google doc

[12:29:31.0162] <Ashley Claymore>
> <@aclaymore:matrix.org> @syg am I right in thinking that v8 already needs to load pointers when doing object equality because the pointer tags don't store if the values might be strings? Or am I mixing up the different engine nan tagging schemes 

shu  is what I meant 

[12:29:44.0730] <Ashley Claymore>
Brain trying to at acronyms 

[12:57:20.0548] <jschoi>
Editors: Should I write the new Array.fromAsync pull request against https://github.com/tc39/ecma262/pull/2942 as it is now, or should I wait until #2942‚Äôs conflicts are resolved? 

[13:24:55.0227] <bakkot>
jschoi we'll talk about it next week, sorry for the lack of guidance

[13:36:40.0361] <bakkot>
ljharb Michael Ficarra: let me make the argument a different way. Suppose I have a game and I'm keeping track of points already visited on a 2D grid by storing `{ x, y }` Composites in a Set. One of the operations in this game is "flip my position across the X or Y axis", implemented of course by negating that coordinate.

If we design this feature such that this results in the origin being duplicated in the "has been visited" Set up to three extra times, we have completely abdicated our responsibility as language designers to make the language usable.

[13:45:33.0929] <Ashley Claymore>
yeah that was one of the examples in the R&T issue thread (if I can find it).

[13:45:59.0955] <Ashley Claymore>
It's a good example of how -0 can easily emerge 

[13:48:18.0454] <Ashley Claymore>
The "easy fix" to this is that we normalize 0, though this is not pleasing for the cases that want to store the sign

[13:49:30.0444] <Ashley Claymore>
Which is why we went with SMZ, it allows the storage but keeps the equality.

[13:52:37.0663] <eemeli>
The next TC39 meeting will be the only one this year that's based on a European timezone, and in November we'll be in Japan. The other four meetings will be on North American time, and half again of those are on Pacific time. If we're going to continue having six meetings a year, participation from Europe would be significantly easier if at least the virtual ones were scheduled on US Eastern Time, if they don't also rotate globally.

[14:04:33.0435] <eemeli>
* The next TC39 meeting will be the only one this year that's based on a European timezone, and in November we'll be in Japan. The other four meetings will be on North American time, and half again of those are on Pacific time. If we're going to continue having six meetings a year, participation from Europe would be significantly easier if at least the virtual ones were scheduled on US Eastern Time and did not extend later than they currently do, if they don't also rotate globally.

[14:25:19.0318] <shu>
for objects there's no additional loads, no: https://source.chromium.org/chromium/chromium/src/+/main:v8/src/codegen/code-stub-assembler.cc;l=15540;drc=3b2367f544f1fbf07f2790c81b02546f73f47467

[14:31:28.0268] <ljharb>
and for your use case and SV, you'd have to check for zero before negating, which is annoying to be sure, and those that want SV would be good.

for your use case and SVZ, you're good, but the ones who want SV have *no recourse*.

so i'm not sure why "SVZ" wouldn't be the one designing the language in an unusable way, because it's the difference between "slightly annoying" and "impossible".

[14:32:04.0103] <bakkot>
one of these causes innocent developers to have to be aware of -0, one of them doesn't

[14:32:10.0927] <bakkot>
-0 is an incredibly niche, specialist thing

[14:32:31.0113] <bakkot>
the complexity of handing it should fall on those incredibly niche specialist applications, not on literally everyone else

[14:33:00.0337] <bakkot>
also "no recourse" is just straightforwardly false; it is trivial to handle by mapping -0 to some other value before creating your composites

[14:33:00.0608] <ljharb>
i agree, *when it's possible to handle it*. but in this case it's not possible to handle it

[14:33:07.0433] <ljharb>
oh hm

[14:33:12.0387] <ljharb>
i mean in your game use case yes, that would work

[14:33:22.0484] <bakkot>
the game use case should not have to think about -0 at all

[14:33:29.0198] <ljharb>
but in a use case where the possible values are "any JS value", it's impossible, because any value needs to be storeable

[14:33:37.0680] <bakkot>
no, you make your own value

[14:33:43.0964] <bakkot>
`let minus_zero = {}`

[14:33:48.0871] <bakkot>
no one else has that specific value

[14:33:50.0072] <bakkot>
done

[14:33:58.0922] <ljharb>
they do as soon as i pass around the composite

[14:34:02.0824] <ljharb>
and they need that value if they want to pass me one

[14:34:14.0550] <bakkot>
you do the mapping at the boundary of your API

[14:34:32.0192] <ljharb>
that wouldn't allow them to use the composite the same way i do

[14:34:42.0992] <ljharb>
iow it's everyone that needs to be able to do this, not just my api

[14:34:49.0799] <ljharb>
(every user of my API, at least)

[14:34:55.0952] <bakkot>
I don't understand what that means

[14:35:01.0019] <bakkot>
can you give an example?

[14:35:29.0869] <ljharb>
i want to give someone a composite like `{ x: -0 }` and have it treated as inequality to `{ x: 0 }`, *and* for `.x` to yield `-0` when appropriate

[14:35:53.0196] <bakkot>
you don't get to decide what equality semantics other people are using?

[14:35:59.0377] <bakkot>
* you don't get to decide what equality semantics other people are using

[14:36:03.0378] <bakkot>
so this desire confuses me

[14:36:12.0865] <ljharb>
hax made a comment about having an "opaque composite"; if that were a thing, then i could make my special -0 sentinel and make a composite for that, and just tell everyone to use that instead of -0 directly.

[14:36:50.0804] <ljharb>
what i mean is, i want an application using my library to be able to use the ergonomics of Composite without forcing them to know about "my placeholder for -0"

[14:37:02.0511] <ljharb>
which imo is worse than the equally rare game scenario people knowing about actual -0

[14:37:23.0193] <bakkot>
right, so you map -0 to minus_zero when they give you something, and map it back when you give it back

[14:37:24.0862] <ljharb>
it's not bad for devs to be aware of things that exist.

[14:37:49.0723] <bakkot>
it's bad to force people to deal with -0 if they are not the incredibly niche cases which actually care

[14:40:28.0447] <ljharb>
i find your contrived game example pretty niche too tbh

[14:40:45.0948] <bakkot>
you find "I want to negate numbers and store pairs of them in a Map" contrived?

[14:40:53.0725] <bakkot>
because that's like... a pretty normal thing to happen

[14:41:07.0764] <ljharb>
what are some other use cases?

[14:41:25.0467] <bakkot>
for... negating numbers?

[14:41:49.0749] <ljharb>
for storing pairs of them in a map, and needing to negate those

[14:42:07.0747] <bakkot>
it doesn't have to be pairs for this to be relevant, it's just "as a component of some larger thing"

[14:44:20.0937] <ljharb>
tbh i'm not convinced that's all that common, people don't really use Maps/Sets at all unless they have object keys. and i'm skeptical naive negation is a common need even when keying on numbers (in any structure). but i'll think more about it

[14:44:56.0500] <bakkot>
people will use Maps / Sets a lot more when we have Composites because that is the whole point of them

[14:45:14.0184] <bakkot>
they become much more useful when we have Composites

[14:52:02.0209] <littledan>
I'm just baffled by the -0 discussion. We spent so long on it previously and arrived at what I thought was the sort of perfect solution (in terms of semantics people wanted -- maybe not perfect for engines given how it messes up canonicalization)

[14:52:10.0577] <littledan>
* I'm just baffled by the -0 discussion. We spent so long on it previously and arrived at what I thought was the sort of perfect solution (in terms of semantics people wanted -- maybe not perfect for engines given how it messes up interning)

[14:52:25.0748] <littledan>
* I'm just baffled by the -0 discussion. We spent so long on it previously and arrived at what I thought was accepted as the perfect solution (in terms of semantics people wanted -- maybe not perfect for engines given how it messes up interning)

[14:52:58.0145] <littledan>
I argued a lot for what ljharb is now saying, and ljharb argued for treating -0 and 0 as equal!

[14:53:23.0029] <littledan>
the use case is the same now as in the previous discussion

[14:58:34.0078] <Michael Ficarra>
@littledan:matrix.org I do think that this is a related but different discussion than R&T though

[14:58:57.0966] <Michael Ficarra>
with R&T we were talking about how SameValue, strict equality, etc would behave with R&Ts

[14:59:19.0886] <Michael Ficarra>
for composites we know how they'll behave: composites have identity and are all inequal to each other

[14:59:56.0879] <Michael Ficarra>
the question is instead about how a built-in function compares them, with the function expected to be used as the comparator for Map/Set

[15:00:19.0852] <Michael Ficarra>
but crucially not for strict equality generally, Object.is, etc

[15:00:43.0537] <littledan>
yes, that's true, so it's all a lower-stakes discussion. but in any case, the use case we're talking about, where the spec uses SameValueZero, coincides.

[15:01:14.0420] <Michael Ficarra>
people have got to stop saying the spec uses SameValueZero for Map/Set, I am going to go insane

[15:01:46.0440] <Michael Ficarra>
https://matrix.to/#/#tc39-delegates:matrix.org/$5S9AmLOrMkmYVQfILr39ydh4fKIe2B-MeJWzlCRE8R8

[15:02:06.0346] <littledan>
OK yes sorry but that's still the case we're talking about

[15:02:35.0407] <littledan>
we still reasoned that, it'd be useful for Maps and Sets to do what's proposed here with respect to this kind of thing

[15:03:23.0704] <Michael Ficarra>
yes, if we have composites, we want Map/Set key comparison to be the same thing that Composite.equal does

[15:03:39.0402] <Michael Ficarra>
but that's in no way constraining us to use SameValueZero

[15:03:50.0016] <Michael Ficarra>
it's constraining us to use *either* SameValue or SameValueZero

[15:04:01.0085] <Michael Ficarra>
and between those two choices, SameValue is better IMO

[15:04:50.0959] <bakkot>
Michael Ficarra https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$y9UQ_IgANImhZBZRwefEUXaCl5pYC8t6YXCpbT51sZU?via=matrix.org&via=mozilla.org&via=igalia.com

[15:04:52.0624] <littledan>
it felt previously like we had consensus (until implementer pushback) to use SameValueZero for this case for R&T. Why did that make sense there but not here?

[15:05:19.0217] <littledan>
(I can't get these message links to work in my Matrix client)

[15:05:26.0515] <Michael Ficarra>
yes yes we can talk about that later

[15:06:07.0348] <bakkot>
(sorry, it's a link to my comment with the example with negation)

[15:06:38.0722] <Michael Ficarra>
right now, I'm trying to make sure we're on the same page that we're *NOT* constrained by Map/Set precedence to use SameValueZero and that the equality we're talking about right now is different than what we were talking about for R&T so that discussion also doesn't constrain us

[15:06:59.0695] <Michael Ficarra>
* right now, I'm trying to make sure we're on the same page that we're *NOT* constrained by Map/Set precedent to use SameValueZero and that the equality we're talking about right now is different than what we were talking about for R&T so that discussion also doesn't constrain us

[15:07:36.0775] <littledan>
ah, OK, so what changed was that the feeling that Map and Set are bad has expanded to more people and so maybe we want to apply that here, and this would be the case regardless of whether it's R&T vs composites (?)

[15:07:49.0495] <Michael Ficarra>
what we *are* constrained by is not breaking current Map/Set semantics if we want it to use Composite.equals, which means that we must use either SameValue or SameValueZero

[15:08:11.0396] <bakkot>
we are not on the same page about this, to be clear

[15:08:17.0485] <bakkot>
I hold that we are constrained by Map/Set precedent

[15:08:20.0046] <bakkot>
I understand you disagree

[15:09:01.0469] <Michael Ficarra>
yes @ljharb:matrix.org pointed out earlier that this was our point of disagreement

[15:09:10.0441] <Michael Ficarra>
that there's some sore of pedagogical argument here about 0/-0

[15:09:42.0112] <Michael Ficarra>
and I don't value that as much as I value how difficult and costly it will be to work around SameValueZero

[15:10:13.0046] <Michael Ficarra>
"difficult" in terms of engineering effort and "costly" in terms of runtime costs

[15:10:15.0495] <bakkot>
well, my main point of disagreement is the thing about exposing `-0` insanity to innocent developers, but the Map/Set precedent is sufficient on its own in my mind

[15:11:27.0328] <Ashley Claymore>
> <@michaelficarra:matrix.org> "difficult" in terms of engineering effort and "costly" in terms of runtime costs

It cuts both ways. If someone wants to create SVZMap if composite equality is SV. That's now difficult and costly 

[15:12:37.0409] <littledan>
the main thing is, almost everyone will use the default, so we need that to work well in practice

[15:13:11.0095] <littledan>
it doesn't really matter what you could implement on top (it matters some, but we also need a good default)

[15:13:22.0803] <Michael Ficarra>
that's true, but that's also more likely to be someone with domain knowledge about what they're putting in rather than a library developer trying to create something generically useful

[15:13:50.0227] <Michael Ficarra>
so in Kevin's example, that would be a game developer who is using floats knowing that floats have a sign bit

[15:14:01.0851] <Michael Ficarra>
that's... not unreasonable to me

[15:14:24.0578] <bakkot>
why would they know about -0?

[15:14:33.0766] <Michael Ficarra>
they're using floats

[15:14:33.0984] <bakkot>
-0 only comes up if you're doing trig or similar

[15:14:43.0449] <Michael Ficarra>
or negation?

[15:14:46.0375] <bakkot>
and only in weird edge cases even then

[15:14:56.0915] <bakkot>
no, I mean, you never have to think about it

[15:15:13.0015] <bakkot>
the value arises but you don't have to think about it unless you're doing like `atan2` or division by zero or whatever 

[15:15:30.0434] <Michael Ficarra>
you never have to think about it when doing arithmetic, but you have to think about it when passing it to APIs that take arbitrary values

[15:15:42.0097] <Michael Ficarra>
well, most arithmetic

[15:16:41.0554] <bakkot>
why?

[15:16:58.0508] <bakkot>
I have never done thought about it and it has never been a problem

[15:17:09.0990] <iain>
FWIW, I have seen this specific pattern while analyzing performance hotspots in SpiderMonkey multiple times, and it's one of the reasons that SM decided to explicitly support this proposal for stage 1. Currently people tend to write `x + ":" + y` and use string keys, which is Not Great.

[15:17:14.0922] <bakkot>
because everything in the language is designed to ensure that remains true

[15:17:16.0844] <Ashley Claymore>
Considering:
0 === -0 and [-0].includes(0), I feel like the vast majority of developers will not expect them to not be equal in Composites 

[15:17:22.0309] <bakkot>
* I have never thought about it and it has never been a problem

[15:18:38.0314] <Michael Ficarra>
I think these are poor arguments because they cut the opposite way with NaNs

[15:19:09.0069] <Michael Ficarra>
that same person will be surprised about NaN not being found, switch to `Object.is`, and now zeroes are inequal

[15:19:20.0940] <bakkot>
NaN will be found with `includes`

[15:19:22.0187] <Michael Ficarra>
üôÉ

[15:19:27.0294] <bakkot>
and with Sets


2025-04-15
[18:23:42.0293] <ljharb>
`Object.is` is the only equality that makes any sense intuitively. the rest are just "it matches <legacy baggage>"

[18:28:08.0828] <bakkot>
you say this but in fact I am pretty sure very nearly everyone would be surprised by a notion of equality in which 0 ‚â† -0

[18:28:27.0541] <bakkot>
so, no, I think you just straightforwardly wrong about that unless your claim is about only your own intuition

[18:28:42.0714] <bakkot>
in which case fine whatever but we should not design the language around your intuition

[19:10:34.0060] <ljharb>
i think everyone's assumption there is because of `==` and `===` and `SameValueZero`'s behavior. `-0` and `0` are obviously different things, so without that baggage (or IEEE's), i claim everyone would assume they're different.

[19:10:47.0602] <ljharb>
tbf, without that baggage there'd be no -0 to begin with

[19:26:04.0101] <bakkot>
the expectation isn't because of `0 === -0`, it's because they expect the result of negating zero to be equal to zero, because that's how it always works

[19:26:31.0125] <bakkot>
IEEE requires that `0 === -0` as a consequence of that, not the other way around

[19:26:51.0677] <bakkot>
the result is that almost no one needs to know about -0 because it behaves identically to 0 except in a few very obscure circumstances

[19:27:38.0363] <bakkot>
if you didn't know that -0 was a special value, and you should not have to know that -0 is a special value unless you are one of the people who cares about those very obscure circumstances, then you would assume that `0 === -0` because you would assume that negating 0 didn't do anything, which assumption is very close to being correct

[19:28:23.0559] <bakkot>
* if you didn't know that -0 was a special value, and you should not have to know that -0 is a special value unless you are one of the people who cares about those very obscure circumstances, then you would assume that `0 === -0` because you would assume that negating 0 didn't do anything the same way `0 === +0`, which assumption is very close to being correct

[19:46:07.0331] <Michael Ficarra>
I would counter that only people who are working with floats should have to think about (and make special accommodations for) the weirdness of floats. People writing generic libraries or using foundational built-in data structures should be able to reason algebraically. It's not worth abandoning that to smooth out the sharp edges of floats for people who arguably will need to learn about them eventually anyway.

[19:54:56.0771] <bakkot>
there are a lot more people who are working with numbers in javascript than there are people writing generic libraries which need to distinguish between -0 and 0

[19:55:48.0827] <bakkot>
people who are using foundational built-in data structures _can_ reason algebraically as long as they don't care about the difference between -0 and 0

[19:55:58.0093] <bakkot>
people who do care about that difference have to care anyway

[19:57:24.0873] <bakkot>
in practice what happens is that the people writing generic libraries or using these data structures do not distinguish between 0 and -0 and this works out for everyone

[19:58:57.0238] <bakkot>
I suspect you could on one hand the total number of people, ever, who both a.) had a case where the difference between 0 and -0 was important to them for reasons other than idealogical purity and b.) were surprised that Sets do not consider those distinct values 

[19:58:59.0761] <bakkot>
possibly on zero hands

[19:59:20.0087] <bakkot>
* I suspect you could count on one hand the total number of people, ever, who both a.) had a case where the difference between 0 and -0 was important to them for reasons other than idealogical purity and b.) were surprised that Sets do not consider those distinct values 

[20:12:52.0784] <justingrant>
Negative zero hands!

[20:13:14.0652] <justingrant>
* Negative zero hands! Which is very different, of course.

[21:44:58.0617] <jschoi>
For what it‚Äôs worth, I checked today with a friend in game dev‚Äîsome who works on physic engines as their job, mostly within Unreal Engine‚Äôs C++/Blueprint APIs, for the past decade. He routinely works with floating points in his physics work. 

He did not know what negative zero was, and he doubted any of his colleagues knew either; he said it seemed like trivia that would never affect his team and that hopefully never need to care about. (He seems to deal with trigonometric discontinuities in other ways before ever encountering a negative zero. Or maybe Unreal has abstracted it away enough that they‚Äôve never needed to care.)

He said he would find it quite annoying if he had to care when a zero is positive or negative while using it as a key in an Unreal TMap container. But he would never use a float as a key anyway and instead would a strict integer type for keys instead. We are not so lucky in JavaScript... 

This of course was a mere convenience sample. Take it for what it‚Äôs worth. 

[21:46:18.0648] <jschoi>
> <@michaelficarra:matrix.org> so in Kevin's example, that would be a game developer who is using floats knowing that floats have a sign bit

For what it‚Äôs worth, I checked today with a friend in game dev‚Äîsome who works on physic engines as their job, mostly within Unreal Engine‚Äôs C++/Blueprint APIs, for the past decade. He routinely works with data structures containing floating points in his physics work.

He did not know what negative zero was, and he doubted any of his colleagues knew either; he said it seemed like trivia that would never affect his team and that hopefully never need to care about. (He seems to deal with trigonometric discontinuities in other ways before ever encountering a negative zero. Or maybe Unreal has abstracted it away enough that they‚Äôve never needed to care.)

He said he would find it quite annoying if he had to care when a zero is positive or negative while using it as a key in an Unreal TMap container. But he would never use a float as a key anyway and instead would a strict integer type for keys instead. We are not so lucky in JavaScript...

This of course was a mere convenience sample. Take it for what it‚Äôs worth.

[21:57:43.0171] <jschoi>
> <@michaelficarra:matrix.org> so in Kevin's example, that would be a game developer who is using floats knowing that floats have a sign bit

 * Regarding Kevin‚Äôs gamedev example and game developers‚Äô domain knowledge of -0:

I checked today with a friend in game dev‚Äîsome who works on physic engines as their job, mostly within Unreal Engine‚Äôs C++/Blueprint APIs, for the past decade. He routinely works with data structures containing floating points in his physics work.

He did not know what negative zero was, and he doubted any of his colleagues knew either; he said it seemed like trivia that would never affect his team and that hopefully never need to care about. (He seems to deal with trigonometric discontinuities in other ways before ever encountering a negative zero. Or maybe Unreal has abstracted it away enough that they‚Äôve never needed to care.)

He said he would find it quite annoying if he had to care when a zero is positive or negative while using it as a key in an Unreal TMap container. But he would never use a float as a key anyway and instead would a strict integer type for keys instead. We are not so lucky in JavaScript...

This of course was a mere convenience sample. Take it for what it‚Äôs worth.

