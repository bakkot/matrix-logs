2022-12-01
[01:00:41.0942] <shu>
what is the last item scheduled for today?

[01:03:59.0268] <Rob Palmer>
ShadowRealm

[01:04:20.0889] <Rob Palmer>
but it may move slightly if time magically opens up

[01:05:19.0833] <shu>
i should like to be present for shadowrealms but tbqh i don't know if i'll be able to stay awake until then

[01:08:43.0504] <ljharb>
 * can someone let me in to the meet? Rob Palmer ryzokuken bterlson 

[01:09:42.0465] <Luca Casonato>
bakkot: can you add `amazing iterator` -> `async iterator`?

[01:19:01.0217] <ljharb>
bterlson: advance queue?

[01:23:17.0533] <Rob Palmer>
As Michael Saboff said, please add your name, abbreviation and organization to today's meeting notes.  Link here:  https://github.com/tc39/Reflector/issues/446

[01:24:41.0614] <Rob Palmer>
Please could everyone avoid sharing direct URLs to our notes or meeting URLs in this publicly logged room.  These are all linked from the Reflector post so that they are kept private.

[01:28:35.0651] <Michael Ficarra>
already 15 min ahead!

[01:37:47.0951] <Christian Ulbrich>
Wouldn't this be also the first time, that we would have a ~_keyword_~operator being extended / giving a `.` ? `await` is not a normal function but sth. _magical_ like `delete`?

[01:37:58.0172] <Christian Ulbrich>
 * Wouldn't this be also the first time, that we would have a ~_keyword_~operator being extended / giving a `.` ? `await` is not a normal function but sth. _magical_ like `delete`?

[01:38:14.0029] <ljharb>
no, we have `new.target`

[01:38:16.0649] <ljharb>
and `super.whatever`

[01:38:24.0849] <rbuckton>
and `import.meta`

[01:38:29.0365] <ljharb>
metaproperties are already A Thing

[01:40:01.0298] <Christian Ulbrich>
`super.whatever` is used like a magical function and `new.target` is a magical property. `import.meta` a magical global.

[01:40:21.0431] <yulia>
speaking of research -- anyone wanna take over running that call?

[01:42:11.0843] <Christian Ulbrich>
I can relate to the idea of hiding Promises, but it would come at the cost of having - IMO - at the cost of another magical thing, that we do not have so far.

[01:43:37.0048] <Christian Ulbrich>
 * `super.whatever` is used like a _magical_ **function** and `new.target` is a _magical_ **property**. `import.meta` a _magical_ **global**.

[01:44:40.0090] <ljharb>
it could be an `awaitAll` keyword and it'd be the same

[01:44:44.0490] <yulia>
we have issues with sound in the room?

[01:44:58.0460] <ljharb>
`await.all` isn't magical, it's just a way to nest keywords under keyords in this case

[01:44:58.0678] <bakkot>
`await.all [a, b, c]` just doesn't seem that different from `await Promise.all([a, b, c])` to me

[01:45:00.0480] <rbuckton>
async/await isn't about hiding promises. It's about taking continuation passing style code and allowing you to write it as linear code so that you can maintain the benefit of existing control flow constructs like `continue`/`break`/`return`/`yield`.

[01:45:20.0890] <yulia>
what is being highlighted right now is the issue of breaking consistency in a language -- new developers will have a hard time keeping two things in mind

[01:45:30.0278] <ljharb>
> <@bakkot:matrix.org> `await.all [a, b, c]` just doesn't seem that different from `await Promise.all([a, b, c])` to me

sure, i do the latter all the time, but in my experience devs in fact consider those quite different, and avoid the latter in favor of `await a; await b; await c` *constantly*

[01:45:31.0280] <yulia>
I would question teaching async/await before promises for this reason

[01:45:45.0867] <yulia>
i don't think the solution here is syntax

[01:46:00.0430] <Christian Ulbrich>
In other words, is there so far any `await`-like thing with a `.`?

[01:46:18.0765] <ljharb>
Christian Ulbrich: no, in that respect it'd be something new, but almost every new syntax feature has that :-)

[01:46:30.0645] <ljharb>
yulia: i totally agree this doesn't fix the education problem. to me it's fixing an ergonomics problem.

[01:46:33.0799] <Alex Vincent>
DevMo has a great example of how to do promises in sequence via Array.prototype.reduce

[01:46:36.0953] <bakkot>
ljharb I definitely see people do `await a; await b; await c` over `await Promise.all` but I have generally assumed it was because of thinking serially rather than because of wanting to avoid `Promise`?

[01:46:46.0696] <yulia>
> <@ljharb:matrix.org> yulia: i totally agree this doesn't fix the education problem. to me it's fixing an ergonomics problem.

the ergonomics issue is relying on learners to make its poinit

[01:46:48.0438] <bakkot>
"wanting to avoid `Promise`" seems like a problem we should not be trying to solve for them

[01:46:49.0924] <yulia>
you just did so as well

[01:46:55.0423] <Kris Kowal>
I imagine `for await all` would take a lot of pressure off of `await.all`.

[01:46:57.0868] <yulia>
i don't agree that this is a solution

[01:47:02.0745] <ljharb>
> <@bakkot:matrix.org> ljharb I definitely see people do `await a; await b; await c` over `await Promise.all` but I have generally assumed it was because of thinking serially rather than because of wanting to avoid `Promise`?

my experience is that most of the time they don't need to be serial, and that they didn't want to deal with the ceremony of Promise.all

[01:47:12.0974] <Christian Ulbrich>
Motivate a change to "unconfuse" developers from Promises by adding a totally new syntax, should be well-thought of.

[01:47:13.0824] <shu>
> <@bakkot:matrix.org> ljharb I definitely see people do `await a; await b; await c` over `await Promise.all` but I have generally assumed it was because of thinking serially rather than because of wanting to avoid `Promise`?

this rings true to me

[01:48:00.0795] <shu>
i reckon beginners are not at a place that _would_ reach for parallel combinators but for a more discoverable way to do so, like syntax, or something

[01:48:08.0880] <shu>
they're just not at a place to reason about things in parallel

[01:48:21.0279] <Christian Ulbrich>
Concerning the hiding motivation, it actually is a problem that have all the time with junior developers, they already do not know, that they are using promises...

[01:48:49.0535] <Kris Kowal>
I agree with Yulia that promises should be taught before async/await. I agree with rbuckton that the latter is not to hide the former.

[01:49:11.0153] <HE Shi-Jun>
if the main problem is await all, should we only add `await.all` without `await.race` and others? Or even just introduce a special syntax (eg. `await* promises`)?

[01:49:15.0358] <shu>
first we must teach one of the First Mistakes -- the existence of the microtask queue

[01:49:22.0678] <Christian Ulbrich>
shu: The whole Playwright API is heavily _async_...

[01:49:48.0922] <shu>
Christian Ulbrich: sorry what's the context of that comment? i don't know what that means

[01:50:07.0352] <Kris Kowal>
 * I agree with @yulia that promises should be taught before async/await. I agree with rbuckton that the latter is not to hide the former.

[01:51:06.0460] <ljharb>
> <@haxjs:matrix.org> if the main problem is await all, should we only add `await.all` without `await.race` and others? Or even just introduce a special syntax (eg. `await* promises`)?

that would still be better than the status quo, but i think that'd be an unfortunate inconsistency

[01:51:43.0848] <Alex Vincent>
"do nothing" is always an option.

[01:51:46.0985] <HE Shi-Jun>
ljharb: if syntax, there is no inconsistency?

[01:52:37.0597] <ljharb>
the inconsistency would be 3 of the promise combinators lacking syntax, but 1 having it

[01:55:21.0091] <HE Shi-Jun>
I mean, if 80% usage of combinators is just Promsie.all, is it ok to only add syntax for it?

[01:58:15.0628] <ljharb>
should we only add a subset of + - * /, because some of them get more usage than the others?

[01:58:45.0317] <yulia>
i remain adamant that consistency is important for learnability of a language, 20% is a pretty big chunk, but i think we are  just pulling numbers from the air right now. 

[02:00:02.0228] <Jack Works>
> <@yulia:mozilla.org> speaking of research -- anyone wanna take over running that call?

Sad to see you cannot attend 

[02:00:17.0478] <yulia>
> <@jackworks:matrix.org> Sad to see you cannot attend

wanna take over?

[02:00:38.0941] <yulia>
you can bug felienne

[02:00:55.0202] <yulia>
or we can go without a research call for a while

[02:10:05.0658] <ljharb>
bterlson: it'd be really helpful to plan my sleep if the hackmd could be updated with an estimated plan for the rest of the day üôè

[02:10:42.0349] <Jack Works>
> <@shuyuguo:matrix.org> they're just not at a place to reason about things in parallel

Sounds true. For beginners they need to be taught to be aware of parallel. But for me, I sometimes drop parallelism because I'm lazy to write Promise.all()

[02:11:35.0547] <Rob Palmer>
ljharb: hackmd is constantly kept as up to date as we can make it - as we approach the end of the meeting it generally becomes more reliable as uncertainty decreases

[02:11:46.0447] <Kris Kowal>
I think Promise.all is the tip of the lazy iceberg. To go from lazy about parallelism to rigorous usually means converting a for loop to a map, or accumulating an array of promises in a for loop.

[02:11:50.0966] <ljharb>
thanks, appreciate whatever you can do!

[02:12:32.0391] <shu>
Jack Works: have you tried to use editor abbreviations?

[02:12:36.0005] <Jack Works>
> <@alex.vincent:matrix.org> "do nothing" is always an option.

I'm prepared and think it's ok if the committee dont like this idea 

[02:12:53.0268] <shu>
like this seems like an easier problem to solve than through the language

[02:13:15.0633] <Kris Kowal>
A much bolder improvement would be parallel for await loops.

[02:15:12.0807] <Jack Works>
> <@ljharb:matrix.org> should we only add a subset of + - * /, because some of them get more usage than the others?

OOT: imo some operators (| & %) do not deserve a single character operator because they're not used so often (than || &&)

[02:15:58.0712] <rbuckton>
> <@jackworks:matrix.org> OOT: imo some operators (| & %) do not deserve a single character operator because they're not used so often (than || &&)

As someone that does a fair amount of bit twiddling, I disagree

[02:16:25.0074] <Kris Kowal>
> <@jackworks:matrix.org> OOT: imo some operators (| & %) do not deserve a single character operator because they're not used so often (than || &&)

K&R‚Äôs Regret. They got to bitwise first.

[02:16:32.0906] <sffc>
I would like 10 minutes of plenary time to discuss an additional question regarding Intl NumberFormat v3. I have added a slide at the end of the deck I used on Tuesday

[02:16:42.0360] <Jack Works>
> <@yulia:mozilla.org> wanna take over?

I have little knowledge about how to do research... I can join the meeting but I don't think I can take the charge üëÄ

[02:16:53.0843] <apaprocki>
sffc: have you proposed strings for the eras anywhere?

[02:17:06.0777] <yulia>
i think the only person who really knows what they are doing is felienne

[02:19:13.0014] <shu>
i know how to confirm my priors and ignore counter evidence

[02:19:32.0216] <Jack Works>
> <@shuyuguo:matrix.org> Jack Works: have you tried to use editor abbreviations?

Oh

[02:20:55.0921] <Jack Works>
One of the main pain point is when I'm using for...of loop and I want to use await in the loop body

[02:20:57.0975] <yulia>
> <@shuyuguo:matrix.org> i know how to confirm my priors and ignore counter evidence

sounds like ‚ú®science‚ú®

[02:21:05.0970] <sffc>
apaprocki: All context and work on this should be available on the proposal repository; e.g. https://github.com/FrankYFTang/proposal-intl-era-monthcode/issues/1 ... my colleague Manish has a proposal that has been presented to CLDR. There is still room to evolve before they are written down. Would like your feedback if interested!

[02:21:09.0575] <Jack Works>
> <@jackworks:matrix.org> One of the main pain point is when I'm using for...of loop and I want to use await in the loop body

Does anyone have the same feeling about this? 

[02:22:33.0369] <rbuckton>
slides aren't showing on meet

[02:22:36.0497] <yulia>
blank screen

[02:22:39.0421] <yulia>
 * blank screen

[02:22:46.0644] <HE Shi-Jun>
I can't see the slide

[02:26:19.0071] <Jack Works>
* you don't need to understand what membrane is to know the motivation of this proposal

[02:26:57.0910] <Jack Works>
TLDR: we have tons of revocable Proxies and we need to revoke them in an ergonomic way. 

[02:28:28.0974] <rkirsling>
I mean you kind of do if you've never encountered proxy revocation before (I merely know that it's a thing that exists that I've not needed to investigate to any depth)

[02:30:09.0993] <Jack Works>
today:

```js
for (const p of proxiesToRevoke) revokerMap.get(p)()
```

You need to store tons of revoker functions and call them one by one

[02:31:56.0121] <rbuckton>
I'm curious if `DisposableStack` can help here, either:
```js
const { proxy, revoke } = Proxy.revocable(...);
stack.defer(revoke);
return proxy;

// later

stack.dispose(); // mass revocation
```

Or make the return value of `Proxy.revocable` itself a disposable.

[02:32:59.0252] <Jack Works>
Cannot help.

[02:33:20.0847] <Jack Works>
Proxy does not have a prototype to store @@disposable

[02:33:32.0420] <rbuckton>
I'm not sure how I see how

[02:34:17.0438] <ljharb>
the confusing name of `defer` aside, that seems like it'd work

[02:34:31.0104] <Christian Ulbrich>
Is the memory argument really so strong?

[02:35:39.0872] <Michael Ficarra>
I don't think we need to determine whether DisposableStack would be sufficient today

[02:35:57.0745] <Michael Ficarra>
this can reach stage 1 and later we don't advance to stage 2 because we realise DisposableStack is a fine solution

[02:36:08.0411] <Christian Ulbrich>
/me has never _revoked_ a proxy, why would I? I want all of them to go through **my** _proxy_ :)

[02:37:12.0529] <HE Shi-Jun>
> <@jackworks:matrix.org> Proxy does not have a prototype to store @@disposable

DisposableStack defer still could work

[02:37:49.0649] <rbuckton>
And I meant that its not the proxy that is disposable, but the `{ proxy, revoke }` object

[02:38:30.0478] <HE Shi-Jun>
I think DisposableStack could work, but the proposed api seems much easy to use.

[02:39:06.0432] <Christian Ulbrich>
I also had the https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal in mind...

[02:40:31.0056] <HE Shi-Jun>
yeah, cross realm seems a requirement of this proposal?

[02:41:14.0405] <Mathieu Hofman>
I think wrapped revokers could also be optimized in theory, but would any engine realistically perform all these optimizations?

[02:42:20.0804] <Christian Ulbrich>
Proxies now have some heavy uses... they are used by recent Vue3 and libs implementing _immutability_.

[02:42:45.0271] <Christian Ulbrich>
I still wonder though, whether they are actually _revoking_ their Proxies...

[02:42:59.0966] <HE Shi-Jun>
Not sure whether Vue3/Mobx use revoke...

[02:43:01.0605] <rkirsling>
hard to disagree with shu here as my point above was that I've never actually _used_ a Proxy, let alone thought about revoking one

[02:43:38.0829] <Mathieu Hofman>
you may not have used one directly, but lots of libraries / frameworks do leverage them under the hood

[02:43:45.0110] <rkirsling>
(not that I'm objecting to anything :P my point above was that without membranes, there isn't an obvious context of usage)

[02:44:16.0925] <Jack Works>
> <@haxjs:matrix.org> yeah, cross realm seems a requirement of this proposal?

don't know maybe we need ask caridy 

[02:44:24.0280] <Mathieu Hofman>
I would like to see usage trackers from web browsers (which do not cover the usages in non browser environments)

[02:44:42.0797] <Jack Works>
> <@rbuckton:matrix.org> And I meant that its not the proxy that is disposable, but the `{ proxy, revoke }` object

oh that works.

[02:45:05.0022] <Christian Ulbrich>
Membranes are just a mental model around Proxies. Their are many use cases for Proxies, it does not matter, whether they are actually membranes. 

[02:45:38.0513] <Mathieu Hofman>
 * I would like to see usage numbers from web browsers (which do not cover the usages in non browser environments)

[02:46:15.0320] <Christian Ulbrich>
 * Membranes are just a mental model around Proxies. There are many use cases for Proxies, it does not matter, whether they are actually membranes. 

[02:47:49.0097] <shu>
Vue is proxying objects to implement immutability?

[02:47:52.0347] <shu>
they expect this to be performant?

[02:48:21.0351] <Christian Ulbrich>
@shu They use it to implement reactivity.

[02:48:40.0205] <HE Shi-Jun>
> <@shuyuguo:matrix.org> Vue is proxying objects to implement immutability?

Not immutablitity, but use proxy for reactivity

[02:49:11.0665] <Christian Ulbrich>
I have skimmed through the source, looks like they never revoke them.

[02:49:19.0362] <shu>
interesting, i see

[02:49:32.0124] <Jack Works>
```js
const disposable = new DisposableStack()
function createProxy() {
    const {proxy, revoke} = Proxy.revocable(...)
    disposable.defer(revoke)
    return proxy
    // at this point, revoke only hold by the DisposableStack.
    // engine can GC `revoke` and knowing the Proxy is being revoked after the DisposableStack disposes
}
```

[02:51:35.0477] <rkirsling>
so do we have a non-theoretical go-to use case of revocation then?

[02:52:19.0075] <Christian Ulbrich>
rkirsling: So far not, because at least Vue, does not seem to use _revocation_

[02:52:28.0029] <Mathieu Hofman>
Jack Works: according to the definition of liveness, clearing out the proxy target is not necessary, as the target's identity would be unobservable to the program through the proxy already

[02:52:30.0266] <rbuckton>
> <@jackworks:matrix.org> ```js
> const disposable = new DisposableStack()
> function createProxy() {
>     const {proxy, revoke} = Proxy.revocable(...)
>     disposable.defer(revoke)
>     return proxy
>     // at this point, revoke only hold by the DisposableStack.
>     // engine can GC `revoke` and knowing the Proxy is being revoked after the DisposableStack disposes
> }
> ```

I mean, something like `new Proxy(target, handlers, { revocationStack: disposables })` might be feasible, but prefer this approach in general

[02:53:51.0065] <Jack Works>
> <@mhofman:matrix.org> Jack Works: according to the definition of liveness, clearing out the proxy target is not necessary, as the target's identity would be unobservable to the program through the proxy already

the [[ProxyHandler]] might get access to [[ProxyTarget]] when the internal slot is called right

[02:54:01.0183] <Mathieu Hofman>
> <@rkirsling:matrix.org> so do we have a non-theoretical go-to use case of revocation then?

membranes are not theoretical

