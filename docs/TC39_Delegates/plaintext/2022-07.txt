2022-07-05
[09:30:28.0818] <ljharb>
shouldn't `var r = Proxy.revocable({}, {}); r.revoke(); Array.isArray(r)` throw, per spec? it doesn't in jsc or v8 or firefox. what am i missing?

[09:33:40.0748] <bakkot>
ljharb: you want `Array.isArray(r.proxy)`

[09:33:42.0831] <bakkot>
which does throw

[09:33:48.0181] <ljharb>
ahhh thanks

[09:34:04.0434] <ljharb>
knew i had to be missing something :-)

[09:36:48.0206] <ljharb>
does look like the error message is wrong tho for `var r = Proxy.revocable({}, {}); r.revoke(); Object.prototype.toString.call(r.proxy)` in jsc and v8. filed https://bugs.webkit.org/show\_bug.cgi?id=242342 and https://bugs.chromium.org/p/v8/issues/detail?id=13037 ¬Ø\\\_(„ÉÑ)\_/¬Ø

[09:36:49.0571] <ljharb>
 * does look like the error message is wrong tho for `var r = Proxy.revocable({}, {}); r.revoke(); Object.prototype.toString.call(r.proxy)` in jsc and v8

[09:39:51.0174] <ljharb>
 * does look like the error message is wrong tho for `var r = Proxy.revocable({}, {}); r.revoke(); Object.prototype.toString.call(r.proxy)` in jsc and v8. filed https://bugs.webkit.org/show_bug.cgi?id=242342 and https://bugs.chromium.org/p/v8/issues/detail?id=13037 ¬Ø\_(„ÉÑ)_/¬Ø 

[09:39:54.0740] <ljharb>
 * does look like the error message is wrong tho for `var r = Proxy.revocable({}, {}); r.revoke(); Object.prototype.toString.call(r.proxy)` in jsc and v8. filed https://bugs.webkit.org/show\_bug.cgi?id=242342 and https://bugs.chromium.org/p/v8/issues/detail?id=13037 ¬Ø\\\_(„ÉÑ)\_/¬Ø

[10:23:26.0910] <Rob Palmer (back 4 July)>
The July TC39 plenary meeting is two weeks away. 

This is a gentle reminder that the deadline for adding agenda items that are requesting stage advancement is in less than 4 days time! July 9th, 10:00 PDT

We have a capacity for 15 hours of content during the meeting. Currently we have 4 hours of content, meaning there are 11 hours unallocated. I encourage you to add items to make good use of the time. Content additions after the deadline are also possible but may not qualify for stage advancement.

There are currently 14 remaining in-person places available. So if you intend to attend in-person, please fill in the In-Person Reservation Form soon.

https://github.com/tc39/Reflector/issues/437


2022-07-06
[06:54:28.0349] <Jack Works>
üëÄ I want to do a temperature check on the range proposal (discussion https://github.com/tc39/proposal-Number.range/issues/17 )

Do you think it should be a Iterator (1Ô∏è‚É£) or an Iterable object (üî¢)?


2022-07-07
[08:04:30.0283] <zbraniecki>
Can you explain what are the tangible implications of choosing Iterator here?

[08:31:45.0850] <rbuckton (OOF: 7/5 - 7/16)>
> <@jackworks:matrix.org> üëÄ I want to do a temperature check on the range proposal (discussion https://github.com/tc39/proposal-Number.range/issues/17 )
> 
> Do you think it should be a Iterator (1Ô∏è‚É£) or an Iterable object (üî¢)?

I generally prefer Iterable, so that a range can be reused:
```js
const oneToTen = Number.range(1, 10);
// prints: 1\n2\n...
for (const x of oneToTen) console.log(x);
// prints: ??? 
for (const x of oneToTen) console.log(x);
```
Its rare that someone will manually step through an iterator rather than use `for..of` or `...`, and the latter will exhaust the iterator, making a range useless after it has been used once.
If you need to step over it manually, you could still use `Symbol.iterator`, so Iterable is vastly more flexible. 
That said, the iterator helpers proposal depends on Iterator (which I still disagree with in principle), but relevant methods could be lifted to a Range as well.
I'm still hoping we could someday have a standalone range/slice syntax like `a..b`, though that can (hopefully) come later. 

[08:32:52.0746] <rbuckton (OOF: 7/5 - 7/16)>
* I generally prefer Iterable, so that a range can be reused:

```js
const oneToTen = Number.range(1, 10);
// prints: 1\n2\n...
for (const x of oneToTen) console.log(x);
// prints: ??? 
for (const x of oneToTen) console.log(x);
```


Its rare that someone will manually step through an iterator rather than use `for..of` or `...`, and the latter will exhaust the iterator, making a range useless after it has been used once.

If you need to step over it manually, you could still use `[Symbol.iterator]()`, so Iterable is vastly more flexible. 
That said, the iterator helpers proposal depends on Iterator (which I still disagree with in principle), but relevant methods could be lifted to a Range as well.
I'm still hoping we could someday have a standalone range/slice syntax like `a..b`, though that can (hopefully) come later. 

[08:32:53.0180] <rbuckton (OOF: 7/5 - 7/16)>
* I generally prefer Iterable, so that a range can be reused:
```js
const oneToTen = Number.range(1, 10);
// prints: 1\n2\n...
for (const x of oneToTen) console.log(x);
// prints: ??? 
for (const x of oneToTen) console.log(x);
```
Its rare that someone will manually step through an iterator rather than use `for..of` or `...`, and the latter will exhaust the iterator, making a range useless after it has been used once.
If you need to step over it manually, you could still use `Symbol.iterator`, so Iterable is vastly more flexible. 
That said, the iterator helpers proposal depends on Iterator (which I still disagree with in principle), but relevant methods could be lifted to a Range as well.
I'm still hoping we could someday have a standalone range/slice syntax like `a..b`, though that can (hopefully) come later. 

[08:34:19.0837] <rbuckton (OOF: 7/5 - 7/16)>
(and I am not very good at avoiding work when I'm supposed to be on PTO) 

[09:58:31.0616] <ljharb>
you can reuse it by sticking ()=> in front of it

[10:05:32.0054] <rbuckton (OOF: 7/5 - 7/16)>
That's not reuse, that's recreating it each time. It also potentially reevaluates each argument, which could have side effects/performance implications. 

[10:07:35.0485] <rbuckton (OOF: 7/5 - 7/16)>
i.e., `const r = () => Number.range(0, f())`. Beginners could easily overlook the `f()`

[10:09:08.0225] <rbuckton (OOF: 7/5 - 7/16)>
Maybe PFA could help, but it's also not something a beginner would likely reach for immediately, nor is the `() =>` trick 

