2022-07-05
[09:30:28.0818] <ljharb>
shouldn't `var r = Proxy.revocable({}, {}); r.revoke(); Array.isArray(r)` throw, per spec? it doesn't in jsc or v8 or firefox. what am i missing?

[09:33:40.0748] <bakkot>
ljharb: you want `Array.isArray(r.proxy)`

[09:33:42.0831] <bakkot>
which does throw

[09:33:48.0181] <ljharb>
ahhh thanks

[09:34:04.0434] <ljharb>
knew i had to be missing something :-)

[09:36:48.0206] <ljharb>
does look like the error message is wrong tho for `var r = Proxy.revocable({}, {}); r.revoke(); Object.prototype.toString.call(r.proxy)` in jsc and v8. filed https://bugs.webkit.org/show\_bug.cgi?id=242342 and https://bugs.chromium.org/p/v8/issues/detail?id=13037 ¬Ø\\\_(„ÉÑ)\_/¬Ø

[09:36:49.0571] <ljharb>
 * does look like the error message is wrong tho for `var r = Proxy.revocable({}, {}); r.revoke(); Object.prototype.toString.call(r.proxy)` in jsc and v8

[09:39:51.0174] <ljharb>
 * does look like the error message is wrong tho for `var r = Proxy.revocable({}, {}); r.revoke(); Object.prototype.toString.call(r.proxy)` in jsc and v8. filed https://bugs.webkit.org/show_bug.cgi?id=242342 and https://bugs.chromium.org/p/v8/issues/detail?id=13037 ¬Ø\_(„ÉÑ)_/¬Ø 

[09:39:54.0740] <ljharb>
 * does look like the error message is wrong tho for `var r = Proxy.revocable({}, {}); r.revoke(); Object.prototype.toString.call(r.proxy)` in jsc and v8. filed https://bugs.webkit.org/show\_bug.cgi?id=242342 and https://bugs.chromium.org/p/v8/issues/detail?id=13037 ¬Ø\\\_(„ÉÑ)\_/¬Ø

[10:23:26.0910] <Rob Palmer (back 4 July)>
The July TC39 plenary meeting is two weeks away. 

This is a gentle reminder that the deadline for adding agenda items that are requesting stage advancement is in less than 4 days time! July 9th, 10:00 PDT

We have a capacity for 15 hours of content during the meeting. Currently we have 4 hours of content, meaning there are 11 hours unallocated. I encourage you to add items to make good use of the time. Content additions after the deadline are also possible but may not qualify for stage advancement.

There are currently 14 remaining in-person places available. So if you intend to attend in-person, please fill in the In-Person Reservation Form soon.

https://github.com/tc39/Reflector/issues/437


2022-07-06
[06:54:28.0349] <Jack Works>
üëÄ I want to do a temperature check on the range proposal (discussion https://github.com/tc39/proposal-Number.range/issues/17 )

Do you think it should be a Iterator (1Ô∏è‚É£) or an Iterable object (üî¢)?


2022-07-07
[08:04:30.0283] <zbraniecki>
Can you explain what are the tangible implications of choosing Iterator here?

[08:31:45.0850] <rbuckton (OOF: 7/5 - 7/16)>
> <@jackworks:matrix.org> üëÄ I want to do a temperature check on the range proposal (discussion https://github.com/tc39/proposal-Number.range/issues/17 )
> 
> Do you think it should be a Iterator (1Ô∏è‚É£) or an Iterable object (üî¢)?

I generally prefer Iterable, so that a range can be reused:
```js
const oneToTen = Number.range(1, 10);
// prints: 1\n2\n...
for (const x of oneToTen) console.log(x);
// prints: ??? 
for (const x of oneToTen) console.log(x);
```
Its rare that someone will manually step through an iterator rather than use `for..of` or `...`, and the latter will exhaust the iterator, making a range useless after it has been used once.
If you need to step over it manually, you could still use `Symbol.iterator`, so Iterable is vastly more flexible. 
That said, the iterator helpers proposal depends on Iterator (which I still disagree with in principle), but relevant methods could be lifted to a Range as well.
I'm still hoping we could someday have a standalone range/slice syntax like `a..b`, though that can (hopefully) come later. 

[08:32:52.0746] <rbuckton (OOF: 7/5 - 7/16)>
* I generally prefer Iterable, so that a range can be reused:

```js
const oneToTen = Number.range(1, 10);
// prints: 1\n2\n...
for (const x of oneToTen) console.log(x);
// prints: ??? 
for (const x of oneToTen) console.log(x);
```


Its rare that someone will manually step through an iterator rather than use `for..of` or `...`, and the latter will exhaust the iterator, making a range useless after it has been used once.

If you need to step over it manually, you could still use `[Symbol.iterator]()`, so Iterable is vastly more flexible. 
That said, the iterator helpers proposal depends on Iterator (which I still disagree with in principle), but relevant methods could be lifted to a Range as well.
I'm still hoping we could someday have a standalone range/slice syntax like `a..b`, though that can (hopefully) come later. 

[08:32:53.0180] <rbuckton (OOF: 7/5 - 7/16)>
* I generally prefer Iterable, so that a range can be reused:
```js
const oneToTen = Number.range(1, 10);
// prints: 1\n2\n...
for (const x of oneToTen) console.log(x);
// prints: ??? 
for (const x of oneToTen) console.log(x);
```
Its rare that someone will manually step through an iterator rather than use `for..of` or `...`, and the latter will exhaust the iterator, making a range useless after it has been used once.
If you need to step over it manually, you could still use `Symbol.iterator`, so Iterable is vastly more flexible. 
That said, the iterator helpers proposal depends on Iterator (which I still disagree with in principle), but relevant methods could be lifted to a Range as well.
I'm still hoping we could someday have a standalone range/slice syntax like `a..b`, though that can (hopefully) come later. 

[08:34:19.0837] <rbuckton (OOF: 7/5 - 7/16)>
(and I am not very good at avoiding work when I'm supposed to be on PTO) 

[09:58:31.0616] <ljharb>
you can reuse it by sticking ()=> in front of it

[10:05:32.0054] <rbuckton (OOF: 7/5 - 7/16)>
That's not reuse, that's recreating it each time. It also potentially reevaluates each argument, which could have side effects/performance implications. 

[10:07:35.0485] <rbuckton (OOF: 7/5 - 7/16)>
i.e., `const r = () => Number.range(0, f())`. Beginners could easily overlook the `f()`

[10:09:08.0225] <rbuckton (OOF: 7/5 - 7/16)>
Maybe PFA could help, but it's also not something a beginner would likely reach for immediately, nor is the `() =>` trick 

[10:14:22.0364] <zbraniecki>
My mental model is aligned with rbuckton (PTO: 7/5 - 7/16) - `oneToTen` should produce an iterator when used in a loop. I probably am projecting how Rust does it where `Range` implements `IntoIterator`

[10:20:24.0540] <ljharb>
i don't think beginners will expect to reuse it either tho.

[10:37:54.0187] <rbuckton (PTO: 7/5 - 7/16)>
I think beginners are more likely to reuse it than not, just as you could reuse an array, or map, or set, or typed array. This is especially true if we do ever have a range/slice syntax in the future. 

[10:41:08.0250] <rbuckton (PTO: 7/5 - 7/16)>
I'm still of the opinion that the iterator helpers proposal has a very short-sighted view by focusing on Iterator and not Iterable, and I'd rather not repeat the mistake of leveraging the wrong level of abstraction in more places if we can potentially avoid it. That said, Iterator is probably fine for `Number.range()` on its own, but I would be strongly opposed to the same behavior for any potential Range/slice syntax in the future. 

[10:57:18.0677] <bakkot>
sidebar: I am now ~half of the agenda items for the next meeting. hope everyone is prepared to talk about dumb corner cases for an entire meeting.

[11:08:53.0451] <shu>
please cover them on wednesday, when i cannot be there

[11:32:39.0229] <ljharb>
iterable isn‚Äôt a thing, it‚Äôs a trait.

[11:32:57.0609] <ljharb>
whereas an iterator is a thing

[12:37:25.0846] <ptomato>
> <@bakkot:matrix.org> sidebar: I am now ~half of the agenda items for the next meeting. hope everyone is prepared to talk about dumb corner cases for an entire meeting.

I will add an item on Temporal, but unfortunately it's also all dumb corner cases

[12:56:57.0922] <littledan>
Are people thinking of breakout sessions for the upcoming TC39 meeting, given our possibly somewhat light schedule when finally meeting partly in person/hybrid?

[12:57:09.0019] <littledan>
 * Are people thinking of breakout sessions for the upcoming TC39 meeting, given our possibly somewhat light schedule when finally meeting partly in person/hybrid?

[12:58:48.0390] <littledan>
I could imagine one breakout session on modules, one on inclusion, and maybe one on Ecma, if people are interested. I imagine that other people may have other interesting topics.

[13:00:18.0055] <jschoi>
(For what it‚Äôs worth, I am still planning to add along with Hemanth H.M three agenda items for a once function, a memoize function, and built-in cache maps/sets, so the agenda will fill up a little more than it is now. I might also fill in more time with some chartered incubator topics that haven‚Äôt yet had their incubator meetings, like Array.fromAsync, BigInt Math, bind-this and pipe/topic. I‚Äôm not sure whether those would be more appropriate as breakout sessions or as ordinary agenda topics.)

[13:01:01.0550] <jschoi>
 * (For what it‚Äôs worth, I am still planning to add along with Hemanth H.M three agenda items for a once function, a memoize function, and built-in cache maps/sets, so the agenda will fill up a little more than it is now. I might also fill in more time with some chartered incubator topics that haven‚Äôt yet had their incubator meetings, like Array.fromAsync, BigInt Math, bind-this and pipe/topic. I‚Äôm not sure whether those would be more appropriate as breakout sessions or as ordinary agenda topics.)

[13:01:21.0460] <littledan>
oh yes please keep adding agenda items! those definitely are higher priority than the open-ended discussions I was suggesting.

[13:02:37.0954] <jschoi>
Some of the incubator topics are, for better or for worse, open-ended, especially discussion regarding dataflow syntaxes (including pipe/topic and bind-this). Also, I didn‚Äôt get to mention this at last plenary, but it‚Äôs good to see you again; hope you had a good past year.

[13:02:51.0645] <littledan>
yeah good to see you too!

[13:02:52.0999] <littledan>
I'd suggest that overflow incubator items could be breakout sessions, rather than agenda items

[13:03:20.0021] <littledan>
(I mean, unless someone really does want to present a proposal for them)

[13:07:46.0276] <littledan>
> <@jschoi:matrix.org> (For what it‚Äôs worth, I am still planning to add along with Hemanth H.M three agenda items for a once function, a memoize function, and built-in cache maps/sets, so the agenda will fill up a little more than it is now. I might also fill in more time with some chartered incubator topics that haven‚Äôt yet had their incubator meetings, like Array.fromAsync, BigInt Math, bind-this and pipe/topic. I‚Äôm not sure whether those would be more appropriate as breakout sessions or as ordinary agenda topics.)

those new proposals sound interesting! they seem like tricky things to make built-in since caches/memoization sometimes have domain-specific retention policies; are you proposing hooks for those?

[13:07:54.0518] <jschoi>
As champion / co-champion of four out of the five chartered incubator items (https://github.com/tc39/incubator-agendas/issues/25), I do not plan to advance any of them next meeting, haha. There‚Äôs just too much contention around them right now. But maybe decorator metadata might be ready‚Ä¶

[13:08:37.0093] <littledan>
of course once should be a template tag, ```once`${f}`(x)``` to take advantage of location-based caching ;)

[13:08:49.0186] <littledan>
 * of course once should be a template tag, `once``${f}``(x)` to take advantage of location-based caching ;)

[13:09:02.0602] <littledan>
 * of course once should be a template tag, ```once`${f}`(x)``` to take advantage of location-based caching ;)

[13:09:04.0982] <jschoi>
> <@littledan:matrix.org> those new proposals sound interesting! they seem like tricky things to make built-in since caches/memoization sometimes have domain-specific retention policies; are you proposing hooks for those?

Oh yeah, that‚Äôs the third proposal: maps and sets with cache-replacement policies, for the sake of memoizing but also other stuff. I‚Äôm undecided whether to bundle memoization with CRP maps/sets into one proposal or not; I think we‚Äôre going to probably separate them.

[13:09:35.0043] <littledan>
I'm glad to see that you've gotten more involved over the past year!

[13:09:55.0273] <jschoi>
https://github.com/js-choi/proposal-function-memo
https://github.com/js-choi/proposal-policy-map-set


[13:09:59.0195] <jschoi>
Yeah, thanks!

[13:10:29.0475] <shu>
jschoi: apologies, doesn't look like i'll have enough cycles this cycle to do an incubator call :(

[13:12:00.0839] <jschoi>
Yeah, it‚Äôs no problem; I think we‚Äôre all very thankful of you managing the incubators. Hopefully we‚Äôll knock some stuff out during plenary.

[13:13:09.0611] <shu>
yes, might be a good one to do it with such a light schedule

[14:07:22.0205] <rbuckton (PTO: 7/5 - 7/16)>
> <@ljharb:matrix.org> iterable isn‚Äôt a thing, it‚Äôs a trait.

That's the case in every language/library that is prior art for iterator helpers. Python has itertools. C# has Enumerable+extension methods. F# has pipelines (and so will we). All operate on the "Iterable" not the "iterator". 

[14:17:38.0160] <bakkot>
Java's streams are pretty similar to iterators and are where all of Java's equivalents of these methods are.

[14:20:09.0527] <bakkot>
also Rust's methods are all on the Iterator trait

[14:20:46.0800] <bakkot>
Boost (the C++ library) has `filter_iterator` and so on which are, obviously, on iterators

[14:21:03.0498] <bakkot>
 * Boost (the C++ library has `filter_iterator` and so on whic are, obviously, on iterators

[14:21:08.0994] <bakkot>
 * Boost (the C++ library) has `filter_iterator` and so on whic are, obviously, on iterators

[14:21:35.0635] <bakkot>
 * Boost (the C++ library) has `filter_iterator` and so on which are, obviously, on iterators

[14:23:09.0590] <bakkot>
Scala's AbstractIterator has `filter` and so on

[14:23:14.0598] <bakkot>
I dunno I feel like this is a lot of languages

[14:23:55.0116] <bakkot>
 * Scala's AbstractIterator has `filter` and so on

[14:34:24.0713] <Ashley Claymore>
If range returned an iterator could the return value still include additional properties (start, end, step), similar to if it returned a ‚Äúrange instance‚Äù? Or should it only have next?

[15:10:31.0100] <ljharb>
prior art is informative, not constraining, and never automatically the right choice for JS.

[16:29:28.0224] <ljharb>
absolutely it could; whether it should is a different question


2022-07-08
[23:27:21.0425] <Jack Works>
All I know is, if you try to reuse it in Rust, it will be rejected by the compiler üòÇ

```rust
fn main() {
   let a = (1..5).into_iter();
   //   for i in &a {} NOT WORK
   for i in a {}
   for i in a {} // Error: Use moved value a
}
```

[00:16:12.0250] <ljharb>
In general, iterators aren‚Äôt reusable, with very few exceptions (notably, builtins like array) - i just don‚Äôt think people are going to consistently have the intuition that they will be.

[04:02:08.0646] <Rob Palmer>
For those who will be in SF for TC39 in 12 days time, @sffc has organized a Community event on the Wednesday 20th evening at 17:30.

  https://github.com/tc39/Reflector/issues/437#issuecomment-1177199594

Please let Shane know if you would like to give a presentation or participate in the panel.

[04:03:39.0948] <Rob Palmer>
Also, if you wish to put an item on the Plenary agenda for stage advancement, you have a little over 24 hours to do so.

https://github.com/tc39/Reflector/issues/437#issuecomment-1178843643

[07:33:23.0693] <zbraniecki>
> <@jackworks:matrix.org> All I know is, if you try to reuse it in Rust, it will be rejected by the compiler üòÇ
> 
> ```rust
> fn main() {
>    let a = (1..5).into_iter();
>    //   for i in &a {} NOT WORK
>    for i in a {}
>    for i in a {} // Error: Use moved value a
> }
> ```

but you can do:

```rust
fn main() {
  let a = 1..5;
  for i in a {} // implicitly calls into_iter()
  for i in a {} // implicitly calls into_iter()
}
```

[08:26:46.0568] <littledan>
Looks like the TC39 calendar and the agenda page disagree on when the agenda deadline is

[08:27:13.0734] <littledan>
Should we say that the agenda page is authoritative here? That one is later (tomorrow)

[08:50:57.0104] <Rob Palmer>
The agenda is authoritative.

[10:06:52.0227] <ljharb>
i'll fix the calendar, not sure where the current deadline event came from

[10:36:49.0264] <littledan>
thanks for fixing it ljharb !

[12:36:12.0906] <jschoi>
A doodle of something I might propose tomorrow for Stage¬†1: generic `Object.equiv` and `Object.diff` functions. https://gist.github.com/js-choi/b8b1a1c1388354d1b4384bea8a1fca0a

[12:36:18.0333] <jschoi>
 * A doodle of something I might propose tomorrow for Stage¬†1: generic `Object.equiv` and `Object.diff` functions. https://gist.github.com/js-choi/b8b1a1c1388354d1b4384bea8a1fca0a

[12:36:54.0955] <jschoi>
It‚Äôs functionally a superset of https://github.com/tc39/proposal-array-equality.

[12:36:56.0572] <jschoi>
 * It‚Äôs kind of a superset of https://github.com/tc39/proposals/blob/main/stage-1-proposals.md.

[12:37:09.0719] <jschoi>
 * It‚Äôs functionally a superset of https://github.com/tc39/proposals/blob/main/stage-1-proposals.md.

[12:38:14.0694] <bakkot>
jschoi: I think that second link is not the correct link?

[12:39:16.0290] <jschoi>
* It‚Äôs functionally a superset of https://github.com/tc39/proposal-array-equality.

[12:39:23.0742] <jschoi>
Fixed, thanks. 

[12:49:45.0361] <bakkot>
jschoi: It's a fun idea but for asking for stage 1 people mostly want a problem statement rather than a concrete possible solution, so you might consider presenting this as "i want to compare objects, ideally in a way where the objects can say how to compare themselves. stage 1?" and then after that discussion "also, having gotten stage 1, I want feedback on this direction I was considering, which I am not asking for stage advancement for"

[12:50:38.0171] <jschoi>
Yeah, agreed. 

[12:50:52.0198] <jschoi>
Thanks for feedback. : )

[12:50:55.0124] <bakkot>
though you could also consider seeing if the array equality champions would consider something like this in scope, in which case you wouldn't necessarily need to ask for stage 1 again for a separate thing

[13:17:44.0239] <rbuckton (PTO: 7/5 - 7/16)>
> <@jschoi:matrix.org> A doodle of something I might propose tomorrow for Stage¬†1: generic `Object.equiv` and `Object.diff` functions. https://gist.github.com/js-choi/b8b1a1c1388354d1b4384bea8a1fca0a

I've wanted to handle object equality for awhile (including use as keys in Map and Set). I created the `@esfx/equatable` package as a possible sketch (along with `@esfx/collections-hashmap` and `@esfx/collections-hashset`). https://esfx.js.org/#collections

[13:34:14.0127] <jschoi>
For what it‚Äôs worth, I think that diffing (not just testing with a boolean result) is a pretty common use case‚Äîevery time you want to assert that two objects are equal, it is useful to be able to quickly see why are not the same.
Imagine how many times you‚Äôve added a temporary `console.log(thingA, thingYouExpectedToBeTheSameAsThingA)` line while debugging, but found that the things were very large and you had to painstakingly find the difference. I‚Äôve even copied and pasted debugging output to text-diffing applications.
Of course, assertion and test-runner libraries nowadays include such functionality for the same reasons. 
Anyways, any equality can be defined in terms of an empty a diff, so it‚Äôs a good opportunity to visit this. I‚Äôll be talking with Hemanth H.M and ljharb about whether to tack this onto array-equality in another Matrix room.

[13:34:29.0677] <jschoi>
 * For what it‚Äôs worth, I think that diffing (not just testing with a boolean result) is a pretty common use case‚Äîevery time you want to assert that two objects are equal, it is useful to be able to quickly see why are not the same.
Imagine how many times you‚Äôve added a temporary `console.log(thingA, thingYouExpectedToBeTheSameAsThingA)` line while debugging, but found that the things were very large and you had to painstakingly find the difference. I‚Äôve even copied and pasted debugging output to text-diffing applications.
Of course, assertion and test-runner libraries nowadays include such functionality for the same reasons. 
Anyways, any equality can be defined in terms of an empty a diff, so it‚Äôs a good opportunity to visit this. I‚Äôll be talking with Hemanth H.M and ljharb about whether to tack this onto array-equality in another Matrix room.

[13:46:31.0105] <ljharb>
for some prior art, see https://npmjs.com/is-equal, and import/require `is-equal/why`, you'll get a string explaining why they're different (but not a full diff)

[13:53:02.0809] <jschoi>
 * For what it‚Äôs worth, I think that diffing (not just testing with a boolean result) is a pretty common use case‚Äîevery time you want to assert that two objects are equal, it is useful to be able to quickly see why are not the same.
Imagine how many times you‚Äôve added a temporary `console.log(thingA, thingYouExpectedToBeTheSameAsThingA)` line while debugging, but found that the things were very large and you had to painstakingly find the difference. I‚Äôve even copied and pasted debugging output to text-diffing applications.
Of course, assertion and test-runner libraries nowadays include such functionality for the same reasons.
Anyways, any equality can be defined in terms of an empty diff, so it‚Äôs a good opportunity to visit this. I‚Äôll be talking with Hemanth H.M and ljharb about whether to tack this onto array-equality in another Matrix room.


2022-07-09
[02:19:19.0162] <HE Shi-Jun>
> <@bakkot:matrix.org> also Rust's methods are all on the Iterator trait

I think I already commented that several times: Rust (and D) use iterator-like semantic, because these languages use value type semantic on iterator. So they don't suffer the reuse problem. And Rust have a very strong compiler which won't allow u reuse a iterator twice by default (you need to assign it to a separate var and with value type copy semantic, it give u a two iterator instances). Obviously JS do not have  that merits. (Even I really hope we could have value type one day, I very doubt we can have value type semantic iterator in JS.)

[02:20:32.0925] <HE Shi-Jun>
> <@ljharb:matrix.org> i'll fix the calendar, not sure where the current deadline event came from

I guess it used the wrong timezone. :)

[11:40:14.0795] <bakkot>
> <@haxjs:matrix.org> I think I already commented that several times: Rust (and D) use iterator-like semantic, because these languages use value type semantic on iterator. So they don't suffer the reuse problem. And Rust have a very strong compiler which won't allow u reuse a iterator twice by default (you need to assign it to a separate var and with value type copy semantic, it give u a two iterator instances). Obviously JS do not have  that merits. (Even I really hope we could have value type one day, I very doubt we can have value type semantic iterator in JS.)

This is true, but the fundamental fact remains: in Rust the helpers are on the one-shot thing.

Yes, in Rust the compiler will prevent you from making this particular mistake, whereas in JS you are more likely to get bit by it, so yes, there's a significant downside to using iterators that Rust does not have (though all the other languages I named do - nothing prevents you from trying to re-use a Java stream, e.g.).

But the most important question is whether the helpers are usable and clear when used _correctly_, and on that question, the compiler checks are irrelevant.

(And there's similar problems with accidentally re-using helpers on _iterables_ in other non-rust languages, for that matter - see e.g. the second half of https://stackoverflow.com/a/28513908, which discusses the downsides of C#'s IEnumerable design which were explicitly considered when designing Java's Streams. We're all jealous of Rust's compile-time checks but we still have to design a language which works without them.)

[12:03:44.0851] <jschoi>
I vaguely remember that someone a few years ago (was it Domenic Denicola?) trying to figure out in a GitHub Issue if we could ever have chained numeric comparisons like `x <= y < z`‚Äîand that sadly the person found that there was no way. Does anyone have a link to that thread?

[14:59:21.0589] <snek>
i just heard about the sf js meetup

[14:59:31.0913] <snek>
is there anything i need to do to be able to go to that

[16:08:15.0219] <bakkot>
snek: assuming you are talking about https://www.meetup.com/jsmeetup/events/287033071/, it says on  https://github.com/tc39/Reflector/issues/437 that delegates are not required to RSVP


2022-07-10
[06:34:47.0624] <HE Shi-Jun>
I think Java Streams is ok, but we should note it is intentionally named as "Stream", to make it clear it's not Iterable/Iterator. If we follow Java design, we should also consider change iterator helpers to "Stream". Actually I think Emitter proposal is a very similar and more powerful Stream-like API, a good alternative to iterator helpers.

[06:55:39.0655] <HE Shi-Jun>
bakkot: And the original question is whether number range() should be iterable/iterator, this is a separate question, not direct relate to the design choice of iterator helpers or iterable helpers or stream... Generally speaking I prefer iterable. I'm ok with iterator/stream version if it is make clear that's a iterator/stream (eg. naming it as `Iterator.integers()` or Java-like `IntStream.range()`). See https://github.com/tc39/proposal-Number.range/issues/57

[10:19:36.0523] <bakkot>
Java's Streams happened after they'd already defined their `Iterator` interface and could no longer redefine it as a class; I don't think the naming there is that informative

[10:19:51.0737] <bakkot>
other languages like Scala and Rust did not make that choice

[10:20:37.0863] <bakkot>
anyway I agree with you about the particular question of `Number.range`, I'm mostly objecting to the assertion that every language which has an equivalent of iterator helpers has them for iterables rather than iterators

[10:20:40.0640] <bakkot>
 * anyway I agree with you about the particular question of `Number.range`, I'm mostly objecting to the assertion that every language which has an equivalent of iterator helpers has them for iterables rather than iterators

[11:08:23.0876] <HE Shi-Jun>
> <@bakkot:matrix.org> Java's Streams happened after they'd already defined their `Iterator` interface and could no longer redefine it as a class; I don't think the naming there is that informative

Not sure what's the diff of interface/class in this case, Stream/IntStream is also interface in Java...

[12:05:12.0168] <bakkot>
Oh, yeah, ok

[12:05:13.0730] <bakkot>
Yeah I dunno

[12:08:27.0917] <bakkot>
possibly it's because java iterators support `.remove` and such

[14:54:57.0092] <jschoi>
bakkot, Michael Ficarra, nicolo-ribaudo: Can you check whether this Gist (about Array.fromAsync and AsyncIterator.prototype.toArray) matches your understanding? https://gist.github.com/js-choi/5b49b350995c5a44571be3d314e38162

[15:00:58.0141] <jschoi>
 * bakkot, Michael Ficarra, nicolo-ribaudo: Can you check whether this Gist (about Array.fromAsync and AsyncIterator.prototype.toArray) matches your understanding? I plan to post it in proposal-array-from-async#19 and refer to it from proposal-iterator-helpers#168. https://gist.github.com/js-choi/5b49b350995c5a44571be3d314e38162 I 

[15:02:09.0924] <jschoi>
 * bakkot, Michael Ficarra, nicolo-ribaudo: Can you check whether this Gist (about Array.fromAsync and AsyncIterator.prototype.toArray) matches your understanding? I plan to post it in proposal-array-from-async#19 and refer to it from proposal-iterator-helpers#168. https://gist.github.com/js-choi/5b49b350995c5a44571be3d314e38162 

[15:06:43.0180] <jschoi>
 * bakkot, Michael Ficarra, nicolo-ribaudo: Can you check whether this Gist (about Array.fromAsync and AsyncIterator.prototype.toArray) matches your understanding?  https://gist.github.com/js-choi/5b49b350995c5a44571be3d314e38162

(I plan to post it in proposal-array-from-async#19 and refer to it from proposal-iterator-helpers#168.)

[15:12:04.0551] <bakkot>
jschoi: lgtm

[15:12:23.0002] <bakkot>
though this line is a bit weird:

> Bakkot points out that the ‚Äúidentity function‚Äù of Array.fromAsync does not have to be x => x. In actuality, it is async x => x.

[15:12:33.0019] <bakkot>
I don't know what "identity function" means there

[15:12:34.0217] <jschoi>
Yeah, I just revised it. Refresh the page?

[15:12:49.0300] <bakkot>
ah, sure

[15:13:04.0153] <bakkot>
I would change `the ‚Äúidentity function‚Äù of Array.fromAsync` to `the ‚Äúdefault mapping function‚Äù of Array.fromAsync`

[15:13:21.0501] <jschoi>
Will do. Thanks for checking!

[15:13:25.0812] <bakkot>
or something like that. "identity function" is a property of values, not of functions like "fromAsync"

[15:13:56.0879] <jschoi>
Hopefully now we will have all our ducks in a row with regards to consistency between `Array.fromAsync`, iterator-helpers, and `for await`.

[15:14:04.0326] <jschoi>
 * Hopefully now we will have all our ducks in a row with regards to consistency between `Array.fromAsync`, iterator-helpers, and `for await`.

[15:16:15.0716] <bakkot>
I believe so!

[15:16:52.0017] <bakkot>
I have an agenda item about similarly lining up `yield*` in async generators (https://github.com/tc39/ecma262/pull/2819)

[15:16:56.0345] <bakkot>
working on slides for it now


2022-07-11
[10:45:26.0060] <bakkot>
does anyone who actually knows how `Set`s are implement know if it is possible to use the internal data structure to efficiently implement something like "order this list, which is a subset of the elements in some `Set`, according to the order the values in the list would be emitted when iterating the `Set`"

[10:45:44.0922] <bakkot>
"efficiently" meaning something like "with time proportional to the size of the list, not the size of the `Set`"

[10:45:56.0024] <bakkot>
I am guessing no but I have no idea what the actual implementation looks like

[10:50:08.0758] <shu>
what is the subset?

[10:52:02.0161] <bakkot>
uh

[10:52:05.0789] <bakkot>
like it's some elements of a set

[10:52:48.0802] <bakkot>
you have 1) a `Set` _x_ and 2) a list of some (but not necessarily all, and often much less than all) elements from _x_, which are not ordered according to the order in _x_

[10:52:59.0687] <bakkot>
 * you have 1) a `Set` _x_ and 2) a list of some elements from _x_, which are not ordered according to the order in _x_

[10:53:22.0530] <bakkot>
and you want to sort the list according to the order of the elements in _x_

[10:53:55.0962] <bakkot>
 * you have 1) a `Set` _x_ and 2) a list of some (but not necessarily all, and often much less than all) elements from _x_, which are not ordered according to the order in _x_

[10:54:16.0489] <bakkot>
the list is spec-internal, to be clear, so there's no side effects or anything happening during the process

[11:01:31.0788] <shu>
i do not understand the use case still, is there something concrete i can read?

[11:05:50.0398] <shu>
anyway maybe you can get some insight from https://wiki.mozilla.org/User:Jorend/Deterministic_hash_tables

[11:06:01.0058] <bakkot>
you don't understand the use case, or you don't understand the ask?

[11:06:06.0100] <shu>
i don't understand the use case

[11:06:21.0695] <shu>
is the sublist static, always same size? is it dynamic?

[11:06:26.0119] <shu>
what determines membership in the sublist?

[11:06:58.0195] <shu>
v8 continues to use roughly the same thing as described in jorendorff's wiki page there

[11:07:16.0163] <shu>
insertion order is simply the ascending order of the Entry array

[11:07:23.0997] <bakkot>
the use case is to get consistent order for `Set.prototype.intersection` - depending on which of `this` vs `other` is larger, you might be iterating `this` or `other`, and it would be nice if the order of the resulting set did not depend on which set was being iterated.

[11:07:33.0150] <shu>
i see

[11:07:56.0146] <bakkot>
and the obvious way to do that is to ensure the elements of the resulting set are ordered according to their order in `this`

[11:08:31.0638] <bakkot>
but if `this` is much larger than `other`, and performing said ordering takes time proportional to the size of `this` even when the intersection is small, that's bad

[11:08:52.0064] <shu>
you have two total orders, but how do you compose them into another total order?

[11:09:02.0128] <bakkot>
for intersection in particular, you don't need to

[11:09:11.0203] <shu>
ah it's intersection, right i see

[11:09:28.0528] <shu>
okay, i understand the use case now

[11:09:46.0140] <shu>
i have no idea how you do this efficiently in the current implementations of Set

[11:10:15.0290] <bakkot>
I haven't thought through all the other methods yet; it's possible this ordering wouldn't work for some of them. (others, like `union`, don't have this problem because the optimal algorithm does not produce a result whose order depends on the sizes of the input.)

[11:10:27.0736] <bakkot>
ok, alas.

[11:10:39.0642] <shu>
at the cost of either space or time everything is possible

[11:10:46.0775] <bakkot>
sure

[11:11:31.0103] <shu>
in this case, ISTM the shortest path would be to also store the index in the hash table `Entry` struct

[11:11:40.0735] <shu>
 * in this case, ISTM the shortest path would be to also store the index in the hash table `Entry` struct

[11:12:10.0503] <bakkot>
(Ashley Claymore has suggested in https://github.com/tc39/proposal-set-methods/issues/70#issuecomment-1179692731 another option which adds a constant factor number of additional calls (not observable when it's a native Set) to get a deterministic if kind of strange order, which is my current leading alternative)

[11:12:19.0607] <shu>
you can then straightforwardly sort the list of indices pointed to by the elements in the intersection, and the indices in either of the source Sets would work

[11:12:28.0445] <shu>
but that's an extra int in every entry

[11:12:30.0280] <shu>
and that seems bad

[11:12:35.0530] <bakkot>
yeah

[11:14:15.0802] <shu>
well, wait a second now

[11:14:49.0728] <shu>
one of the properties of that particular implementation strategy of an ordered hash table is that the `Entry`s are allocated contiguously in an `Entry[]` array

[11:15:11.0469] <shu>
if you build an auxiliary list of the found `Entry`s in the intersection, you can presumably do address comparison

[11:15:44.0895] <shu>
i hope that falls out from most implementation languages' array allocation guarantees

[11:15:57.0854] <bakkot>
ooh, love me some pointer comparisons

[11:16:24.0039] <shu>
mind you i am not excited to recommend that in a non-normative note

[11:16:29.0604] <shu>
i don't know how you'd get UB to bite you, but it will

[11:16:41.0118] <bakkot>
the spec currently doesn't suggest any implementation strategy at all

[11:16:57.0549] <shu>
right, i'm just saying it seems very particular

[11:16:58.0744] <bakkot>
actually it might, I forget

[11:17:01.0363] <shu>
and a touch too clever

[11:17:03.0630] <bakkot>
yeah

[11:17:26.0865] <shu>
there are footguns there i'm worried about like

[11:17:32.0903] <shu>
what if the table is rehashed in the middle of performing the intersection

[11:17:38.0689] <shu>
is that even possible, i hope not but maybe

[11:20:03.0910] <shu>
okay so pointer comparison is my final answer and i'm sticking to it

[11:20:07.0850] <shu>
probably fine

[11:20:49.0276] <bakkot>
I would expect rehashing not to affect the `dataTable` itself, just the `chain` pointers within it, so I'd expect that to be fine

[11:21:54.0667] <shu>
yes true, so the entry addresses would be stable

[11:36:41.0601] <bakkot>
I am pretty sure you can replace the `Entry*` pointers in this document with indices into `dataTable` (both the `chain` pointer and the elements of the `hashTable` array), which makes it more obvious that this works and would work even languages which don't expose pointers

[11:37:04.0331] <shu>
yes

[11:37:21.0455] <shu>
but you don't want 2 loads

[11:37:41.0820] <shu>
unless you are using an inferior "safe" language

[11:37:45.0547] <bakkot>
sure

[11:51:19.0225] <Ashley Claymore>
What do we expect the order to be if the receiver is modified during the method call?

[11:51:38.0450] <bakkot>
as a user I don't have an expectation of what the order would be in that case

[11:52:01.0441] <bakkot>
so I'm just going to write down the thing which is easiest to implement, namely, elements are ordered according to their position in the list of entries when the algorithm queries them

[11:52:13.0127] <bakkot>
 * so I'm just going to write down the thing which is easiest to implement, namely, elements are ordered according to their position in the list of entries when the algorithm queries them

[11:58:38.0130] <bakkot>
doing this sorting does add a `log(r)` factor overhead to theoretical performance (where `r` is the size of the result) in the case that `other` is smaller than `this`, but I expect that to be much cheaper than the overhead of doing more user-observable calls in most cases, so I'm not bothered about it

[12:09:02.0462] <shu>
i feel like that's fine

[12:09:08.0088] <shu>
logs aren't real

[12:09:25.0218] <bakkot>
that is also my belief

[12:10:45.0767] <shu>
though my beliefs might be incoherent because i believe constant factors are very real

[12:14:29.0198] <littledan>
as a strict constructivist, I don't believe sets are real

[12:14:36.0030] <littledan>
so this whole conversation has been moot

[12:50:29.0914] <TabAtkins>
Sets obviously aren't real, but Maps are.

[12:50:58.0796] <jschoi>
I assert that Maps aren‚Äôt real either, because Maps are not the actual territory.

[12:51:07.0969] <TabAtkins>
damn

[13:47:41.0497] <shu>
how do folks feel about Temporal updates as part of plenary?

[13:48:28.0972] <shu>
no offense meant to ptomato who's doing the important work, but i mostly don't understand or am in a position to have opinions about the normative updates

[13:49:12.0013] <littledan>
We currently have a pattern that normative updates to Stage 3 proposals need consensus in committee; maybe the timebox should be shortened if people don't actually want to review them and just rubber-stamp?

[13:49:21.0291] <shu>
 * no offense meant to ptomato who's doing the important work, but i mostly don't understand or am in a position to have opinions about the normative updates

[13:49:49.0319] <shu>
yes, that sounds good. if it is non-domain-specific, e.g. behaviors about options bags, then they should be presented

[13:50:10.0405] <shu>
but something like "we had to update this because the grammar upstream at ISO did this or that" is completely non-actionable for me

[13:50:20.0046] <littledan>
maybe this can just be during the presentation, that the presenter can ask, "do people want me to go into these details?"

[13:50:41.0396] <shu>
that might make scheduling harder

[13:50:45.0366] <littledan>
what would be unfortunate is if Temporal got held back because people said, "this doesn't have committee consensus yet; you can't ship this change" because we were trying to save time

[13:51:26.0890] <littledan>
Stage 3 makes getting this all nailed down high priority for committee

[13:51:58.0967] <shu>
i'd like to lean on the temporal champions' judgment on if it's something that runs the risk of that failure mode

[13:52:25.0821] <shu>
the pattern for the past few meetings doesn't seem like a productive use of time to me

[13:52:38.0370] <littledan>
> <@shuyuguo:matrix.org> i'd like to lean on the temporal champions' judgment on if it's something that runs the risk of that failure mode

well, they put this on the agenda; you're the one pushing back

[13:53:15.0861] <shu>
i don't follow

[13:53:30.0447] <shu>
it's not the pattern today that we skip normative updates for stage 3 processes as you said

[13:53:40.0778] <littledan>
I mean, if you want to defer to their judgement on whether to present it to committee... they communicated their judgement by putting this on the agenda

[13:53:56.0549] <shu>
i'm saying let's change the pattern, and the new pattern would be to lean on the temporal champions' judgment on what normative updates are worth presenting instead of every one

[13:54:11.0371] <shu>
oh, i wasn't under the impression they were already saying these are the list of updates worth presenting

[13:54:15.0203] <shu>
if so then i retract

[13:54:19.0322] <littledan>
OK, sorry, I shouldn't speak for them; they can clarify

[13:54:32.0327] <shu>
and will just leave with the comment that i don't find them actionable and i zone out

[13:56:56.0139] <shu>
 * it's not the pattern today that we skip normative updates for stage 3 proposals as you said

[13:58:38.0262] <littledan>
I guess if we wanted to address this issue at a broader level we'd work on creating TGs that have the authority to make decisions on things. We could have a Temporal TG that can just decide fully on these changes without bothering plenary, and everyone who may have an opinion is expected to attend. I'd be in favor of this process change, but we haven't done it yet.

[13:59:19.0109] <shu>
i would also be in favor, and last time we brushed up against it there certainly were headwinds

[13:59:23.0203] <littledan>
or concretely we'd probably give TG2 (402) this authority and task them with reviewing Temporal even though it's not in 402

[13:59:33.0760] <littledan>
 * or concretely we'd probably give TG2 (402) this authority and task them with Temporal even though it's not in 402

[13:59:49.0838] <littledan>
 * or concretely we'd probably give TG2 (402) this authority and task them with reviewing Temporal even though it's not in 402

[14:00:04.0759] <shu>
agreed on TG2

[14:00:13.0851] <shu>
chip has raised concerns about other domains as well

[14:00:19.0507] <shu>
regexps was it?

[14:01:07.0930] <littledan>
so far we've said, those domains need to come back to plenary, their discussions are just advisory. Remember that I faced significant resistance when I just proposed that we meet in totally non-binding subgroups.

[14:01:49.0673] <shu>
yes, and similar resistance and concerns when incubator calls were proposed in their initial form

[14:02:43.0841] <littledan>
well, I think Temporal is doing the right thing for this meeting, and we should probably keep pushing with giving subgroups the power to make decisions

[14:02:54.0481] <littledan>
but, like, chartered subgroups, not random champion groups, IMO

[14:03:13.0910] <shu>
yes, agreed on chartered subgroups

[14:03:58.0543] <shu>
i mean i'd still like to reduce plenary time, but that's probably not a shared goal

[14:04:11.0945] <shu>
not reduce overall deliberation time over the set of all TC39 proposals mind you, but plenary time

[14:04:31.0043] <shu>
 * not reduce overall deliberation time over the set of all TC39 proposals mind you, but plenary time

[14:29:07.0449] <littledan>
Yeah I guess I'm neutral on that, or like it's not my top priority to reduce plenary time; top priority is to make good decisions inclusively, and plenary vs subgroups is more of a means to an end; all else being equal, good to use fewer person-hours, sure

[16:29:26.0320] <ptomato>
> <@shuyuguo:matrix.org> oh, i wasn't under the impression they were already saying these are the list of updates worth presenting

is the question whether we have pre-filtered the updates that I put in the slides?

[16:30:19.0311] <ptomato>
(we haven't)

[16:31:54.0180] <shu>
ptomato: yeah, that was part of the question

[16:32:36.0571] <shu>
the other (to the broader committee) was do we feel comfortable leaning on the judgment of the Temporal champions to do the filtering, so only items of broad interest are presented, and we trust to rubber-stamp the rest

[16:32:54.0297] <ptomato>
well I asked this question previously and the answer was no

[16:32:58.0878] <shu>
since i don't know enough of the domain to, like, do anything other than rubberstamp

[16:33:08.0017] <shu>
oh too bad, i had forgotten

[16:33:25.0633] <ptomato>
yes, I'd love to skip the items that I know nobody cares about

[16:33:51.0837] <shu>
perhaps i can bring this up again to re-take the temperature

[16:33:56.0392] <shu>
what was the reasoning last time?

[16:35:39.0968] <ptomato>
I will look

[16:36:13.0248] <ptomato>
(FWIW, the status quo is better than the previous status quo, where the answer was "depends on who you ask")

[16:39:55.0560] <ptomato>
https://github.com/tc39/notes/blob/main/meetings/2022-01/jan-24.md#process-clarification - this is slightly different from what I remembered, good thing we have notes! I guess the "yes, we want this requirement" must have come from conversations before the plenary, the agenda item was only about making the unofficial requirement official

[16:58:17.0039] <shu>
yeah, i think there's a meaningful difference between "giving up plenary sign-off for normative changes" and "rubberstamp, trust domain experts to follow-up/review"

[16:58:26.0986] <shu>
the power still rests with plenary in the second case, and is more practical imo...

[16:58:40.0963] <shu>
 * the power still rests with plenary in the second case, but one is more practical imo...

[16:58:49.0417] <shu>
 * the power still rests with plenary in the second case, and is more practical imo...


2022-07-12
[17:04:47.0556] <ptomato>
it does fit with the idea of TC39 as 'standing athwart history, yelling Stop' which seems to be one of the dominant mental models within committee

[17:06:58.0969] <ptomato>
(not one that I agree with, to be clear)

[17:24:55.0930] <shu>
i am not even interested in asking for a broad change currently, just for Temporal

[17:25:24.0732] <jschoi>
(This is the first time in years I‚Äôve seen ‚Äúathwart‚Äù. It is a great word.)

[17:25:27.0606] <jschoi>
 * (This is the first time in years I‚Äôve seen ‚Äúathwart‚Äù. It is a great word.)

[17:25:31.0238] <shu>
i would invite folks with that mental model to contemplate if they would actually yell "stop" to a normative fix you present, ptomato 

[17:39:15.0196] <Kris Kowal>
> <@littledan:matrix.org> as a strict constructivist, I don't believe sets are real

I believe some numbers are real, but not all of them.

[17:41:45.0531] <Kris Kowal>
Or rather, most of them are not real. Pretty sure there‚Äôs proof to that effect.

[17:44:32.0454] <jschoi>
Sounds pretty complex to me.

[17:45:55.0930] <shu>
i...

[17:53:34.0081] <Kris Kowal>
> <@jschoi:matrix.org> Sounds pretty complex to me.

not necessarily

[19:03:43.0324] <ljharb>
tbh i think the requirement to present everything to plenary is actually a useful barrier; it means that all the things that get presented end up being obvious/boring

[19:04:38.0618] <ljharb>
and considering how many times it was brought up by littledan  to demote `global` to stage 2 based on the name change, that nobody's considering Temporal to need demotion is a bit confusing

[07:11:39.0049] <littledan>
idk maybe that was a mistake... ultimately I am still not really happy about the process global used. I think champions should be more transparent with the committee.

[07:11:55.0332] <littledan>
so I'm a little wary of using that experience as an example that we should follow

[07:13:40.0828] <littledan>
in the case of global, the whole proposal was only a name, and the stage 3 status was actively being used by multiple JS implementations/environments as a reason to ship exactly that (even after compat issues were discovered). So demoting was one way to send the signal that this wasn't the final state, though there would've been other ways.

[07:14:01.0276] <littledan>
 * in the case of global, the whole proposal was only a name, and the stage 3 status was actively being used by multiple JS implementations/environments as a reason to ship exactly that (even after compat issues were discussed). So demoting was one way to send the signal that this wasn't the final state, though there would've been other ways.

[07:14:08.0124] <littledan>
 * in the case of global, the whole proposal was only a name, and the stage 3 status was actively being used by multiple JS implementations/environments as a reason to ship exactly that (even after compat issues were discovered). So demoting was one way to send the signal that this wasn't the final state, though there would've been other ways.

[07:15:36.0298] <littledan>
The tweaks being made to Temporal are much smaller in proportion to the size of the proposal. It is good that we aren't revisiting names, for example

[08:03:05.0549] <shu>
yes, i strongly agree the bar for demotion is something like "if it is no longer clear what needs to be implemented" and "if keeping stage 3 means shipping the wrong thing"

[08:03:37.0217] <shu>
temporal, while noisy, seems like all bugfixes to me, a bunch of which only (realistically) was going to be found after someone started implementing

[08:03:47.0717] <shu>
so demotion would be the exact wrong thing to do here

[08:04:32.0256] <shu>
for something of temporal's size, the bugfix noise is pretty unavoidable

[08:14:18.0047] <littledan>
Procedurally, my understanding that the requirement for demotion, like promotion, is consensus.

[08:23:22.0647] <shu>
mine as well

[08:23:55.0864] <littledan>
we achieved that with global, and with static class features, so things were above board, but it's possible to object to demotion, I think

[08:25:32.0029] <shu>
yeah, i'm explaining the expectation of the bar i'd be judging proposals by if something came up for demotion

[08:25:46.0353] <littledan>
yeah, I agree with your bar

[08:25:54.0488] <littledan>
that this is what delegates should keep in mind

[08:26:10.0941] <littledan>
maybe it's time for a how-we-work PR?

[11:42:35.0461] <rkirsling>
also Temporal is the size of a new spec unto itself so it's really not fair to compare it to a run-of-the-mill small proposal

[12:07:45.0778] <justingrant>
rkirsling: that's a really good point!  What makes Temporal hard is that the proposal is a family of related types rather than individual types or functions that can be added incrementally and individually. It's hard to imagine any other problem domain being added to the language that would require such a large surface area, with the possible exception of file I/O if that's ever added to the standard library. 

[12:07:49.0599] <ljharb>
i totally agree demotion requires the same consensus advancement does, and that temporal isn't really stage 2 (nor was global at the time), but also neither is/was truly stage 3. i wish we had some kind of stage 3.5

[12:07:57.0834] <ljharb>
 * i totally agree demotion requires the same consensus advancement does, and that temporal isn't really stage 2 (nor was global at the time), but also neither is/wa truly stage 3. i wish we had some kind of stage 3.5

[12:07:59.0535] <ljharb>
 * i totally agree demotion requires the same consensus advancement does, and that temporal isn't really stage 2 (nor was global at the time), but also neither is/was truly stage 3. i wish we had some kind of stage 3.5

[12:10:24.0788] <littledan>
yeah, we talked about something after stage 3 in this room; I think it'd be good to bring that to committee at some point for further discussion. We agreed on a lot of things (e.g., that by default, something is "shippable" when promoted to Stage 3 unless otherwise specified) and we identified a point of disagreement whether the champion can just unilaterally document whether something is "shippable", or whether this is subject to review/consensus/objections by the rest of the committee.

[12:21:44.0401] <littledan>
Stenography support may be coming to the next plenary! If you get a chance, editing the glossary will help the captioner. https://github.com/tc39/how-we-work/blob/main/terminology.md

[12:49:22.0216] <shu>
yeah, i'm positive on a stage 3.5 with relatively little oversight

[12:49:50.0953] <shu>
i.e. a little more formalism than what's happening today which is like a browser saying "hey btw let's not ship this until we iron out this issue" and everyone else nodding

[14:21:39.0124] <jschoi>
Would Stage¬†3.5 occur on all proposals or just ‚Äúspecial‚Äù ones similar to Temporal?

[14:22:59.0808] <littledan>
The idea is to have a column in the proposals repo which is whether something is "shippable" (or maybe inversely, whether it has open questions which block shipping). In the normal course, the shippable bit is set at the same time as going to Stage 3. All proposals would have this bit, not just ones which are un-shippable.

[14:23:09.0302] <littledan>
 * The idea is to have a column in the proposals repo which is whether something is "shippable" (or maybe inversely, whether it has open questions which block shipping). In the normal course, the shippable bit is set at the same time as going to Stage 3. All proposals would have this bit, not just ones which are un-shippable.

[14:23:49.0166] <littledan>
there would be no real contract associated with the shippable bit; it's just a piece of advice from the champion to implementers and everyone else, in my (and Shu's, maybe) vision of how this works

[14:24:12.0275] <shu>
there's like, a social contract, in the world

[14:24:16.0512] <shu>
there's no formal contract in committee

[14:24:16.0732] <littledan>
right

[14:24:45.0716] <littledan>
brb preparing a docusign

[14:24:59.0087] <littledan>
of the social contract

[14:25:15.0956] <shu>
can you imagine, changing consensus process straight to docusign

[14:25:19.0369] <shu>
45 counterparties

[14:25:44.0650] <jschoi>
Would tweaks be needed to the current definition of Stage¬†3 saying, ‚ÄúThe solution is complete and no further work is possible without implementation experience, significant usage and external feedback‚Äù?

[14:26:17.0382] <littledan>
I wasn't picturing any stage process definition tweaks as part of this

[14:26:57.0279] <littledan>
I think we could clarify the process wording but that's a big separate thing

[14:27:12.0921] <littledan>
 * I wasn't picturing any stage process definition tweaks as part of this

[14:27:15.0272] <jschoi>
I suppose the difference between ‚Äúthe solution is complete and [needs] implementation experience‚Äù (Stage¬†3 without the ‚Äúshippable‚Äù checkmark) and ‚Äúthis is ready for serious implementation‚Äù (Stage¬†3 with the ‚Äúshippable‚Äù checkmark) seems a bit subtle.

[14:27:33.0643] <jschoi>
I‚Äôm imagining what it means in general to be at Stage¬†3 but to not have the shippable checkmark.

[14:27:34.0168] <littledan>
we've had way too many arguments about this; I don't want to discuss it right now

[14:27:41.0843] <littledan>
sorry

[14:27:46.0472] <jschoi>
Ah, okay, sounds good; don‚Äôt let me open the Pandora box.

[14:30:42.0260] <littledan>
I documented what makes sense to do at each stage in https://github.com/tc39/how-we-work/blob/main/champion.md#moving-through-the-stages-in-committee

[14:31:35.0886] <littledan>
I think we should move towards pointing people to how-we-work more frequently, and the formal process document doesn't need to be how we explain the process in practice to people all the time (since it just leaves so many things out which are important to understand)

[14:31:58.0060] <littledan>
it's too hard to maintain how-to documentation in a consensus-seeking way

[14:40:32.0425] <rkirsling>
> <@littledan:matrix.org> The idea is to have a column in the proposals repo which is whether something is "shippable" (or maybe inversely, whether it has open questions which block shipping). In the normal course, the shippable bit is set at the same time as going to Stage 3. All proposals would have this bit, not just ones which are un-shippable.

yeah I was thinking this too; some notion of a "bit" makes more sense than asking whether a tiny feature is "going right to 3.5"

[14:49:01.0912] <shu>
i'm most excited about how i can apply my newly found, most likely incorrect knowledge of contract law thanks to Elon's antics to tc39

[14:49:11.0205] <shu>
 * i'm most excited about how i can apply my newly found, most likely incorrect knowledge of contract law thanks to Elon's antics to tc39

[14:51:17.0871] <littledan>
wait, is our alternate copyright policy not accompanied by a matching alternative patent policy saying the same thing but for patents?

[14:51:26.0469] <littledan>
maybe it's not possible to do that, I dunno

[14:52:13.0201] <shu>
i did not know there was an analogue for patents

[14:57:22.0582] <littledan>
ah probably it's not important. Both the Ecma and WHATWG policy limits the patent grant to current and future implementations of the standard (which might imply not forks). Probably broadening it would require bringing in lawyers and isn't necessary in practice

[14:58:05.0635] <littledan>
sorry for the noise

[14:58:34.0426] <rkirsling>
> <@shuyuguo:matrix.org> i'm most excited about how i can apply my newly found, most likely incorrect knowledge of contract law thanks to Elon's antics to tc39

misparsed this with [Elon's antics to TC39] and got worried for a sec

[14:59:07.0009] <rkirsling>
#longrangedependencyproblems

[15:36:13.0666] <rkirsling>
does anybody else find terminology.md hard to read due to skipping second-level headings

[15:36:26.0723] <rkirsling>
er

[15:36:31.0896] <rkirsling>
I mean https://github.com/tc39/how-we-work/blob/main/terminology.md of course

[15:37:11.0369] <rkirsling>
third-level headings are not prominent enough and would require \<hr>s for delineation...or y'know, we could just use second-level headings

[15:38:59.0202] <rkirsling>
 * third-level headings are not prominent enough and would require \<hr>s for delineation...or y'know, we could just use second-level headings

[15:42:41.0724] <rkirsling>
(I wonder if GH's stylesheet changed somewhere along the line; I don't remember being so bothered when editing this document in the past)

[16:19:33.0653] <rkirsling>
https://github.com/tc39/how-we-work/pull/109

[16:37:49.0913] <shu>
reviewing temporal patches is just like

[16:37:53.0417] <shu>
date time handling is so cursed

[16:50:23.0564] <jschoi>
This champion.md document is great. To be honest‚Ä¶I had never seen it before. I don‚Äôt know why; I feel like I should have noticed it when I looked through how-we-work‚Ä¶And, yes, I had always relied on the process document as my primary reference on what to do at each stage.

[16:50:43.0885] <jschoi>
> <@littledan:matrix.org> I think we should move towards pointing people to how-we-work more frequently, and the formal process document doesn't need to be how we explain the process in practice to people all the time (since it just leaves so many things out which are important to understand)

 * This champion.md document is great. To be honest‚Ä¶I had never seen it before. I don‚Äôt know why; I feel like I should have noticed it when I looked through how-we-work‚Ä¶And, yes, I had always relied on the process document as my primary reference on what to do at each stage.


2022-07-13
[10:40:19.0331] <rkirsling>
> <@rkirsling:matrix.org> https://github.com/tc39/how-we-work/pull/109

can I get an approval here? would like to merge before defining stuff

[15:19:53.0228] <rkirsling>
restructured so that the page is cleanly divided into Glossary and Contributing:
https://github.com/tc39/how-we-work/pull/110


2022-07-14
[09:17:55.0940] <Chris de Almeida>
https://github.com/tc39/how-we-work/pull/111

[09:18:24.0458] <Chris de Almeida>
PR to fix a bunch of markdown issues and move the template code to a code block

[09:19:10.0260] <Chris de Almeida>
next one I will have will fix the alpha order of terms (and add the alpha order requirement in the contribution section)

[09:53:02.0084] <bakkot>
if markdownlint is actually good (I have not used it), we should maybe set it up in CI?

[10:15:43.0160] <rkirsling>
yeah this was the first I'd heard of it but it seems wise

[11:02:57.0616] <Chris de Almeida>
I've been using it for 6 years or so.  it's great, but I've never bothered to add it to any CI because it's md and not quite "code", but that's a good idea

[11:07:31.0971] <Kris Kowal>
Missed opportunity for ‚ÄúLint, M.D.‚Äù pun.

[11:22:23.0644] <ljharb>
+1 for adding it to CI; i use `evalmd` in many of my projects in CI to ensure that code examples execute successfully, and linting markdown also seems useful

[11:47:14.0794] <Chris de Almeida>
I wouldn't mind setting it up, but I lack the requisite permissions on the repo

[11:48:00.0161] <bakkot>
you should be able to just send a PR adding a github action? I don't think you need permissions beyond that

[11:49:31.0627] <Chris de Almeida>
ah, true.  I was thinking more about configuring status checks, etc

[12:02:17.0622] <ljharb>
i can configure them once it's merged

[13:40:53.0994] <Chris de Almeida>
https://github.com/tc39/how-we-work/runs/7347701399?check_suite_focus=true

[13:41:32.0105] <Chris de Almeida>
linting github action added.  see test result ‚òùÔ∏è

[13:41:38.0974] <Chris de Almeida>
 * linting github action added.  see test result ‚òùÔ∏è


2022-07-17
[14:51:35.0747] <jschoi>
I‚Äôm looking at simplifying Ecma262‚Äôs definition of Array.from to use %Array.prototype.values%, like how https://tc39.es/proposal-array-from-async/#sec-array.fromAsync uses %Array.prototype.values%. As far as I can tell, this should be editorial, but, if so, would it still deserve to be presented as a 2022-09 plenary agenda item? 

[15:21:04.0287] <bakkot>
jschoi: anything strictly editorial does not need to be presented in plenary

[15:21:54.0541] <bakkot>
but, `Array.prototype.values` produces an iterator which uses the _current_ value of `%ArrayIteratorPrototype%.next`, which is not what `Array.from` does

[15:22:18.0816] <bakkot>
so it's not a totally straightforward refactoring

[15:23:46.0578] <jschoi>
This might be a problem for the currently proposed Array.fromAsync algorithm too, then.

[15:24:03.0110] <jschoi>
 * This might be a problem for the currently proposed Array.fromAsync algorithm too, then.

[15:39:09.0685] <bakkot>
yup


2022-07-18
[12:04:40.0039] <ryzokuken>
could someone with access to the TC39 calendar please delete the event today?

[12:56:27.0802] <ljharb>
> <@usharma:igalia.com> could someone with access to the TC39 calendar please delete the event today?

yep, on it

[12:56:49.0515] <ljharb>
actually wait, i deleted that awhile ago

[12:56:54.0330] <ljharb>
it‚Äôs not there now

[12:57:15.0667] <ryzokuken>
weird, must be my client then. 

[12:57:19.0284] <ljharb>
if you‚Äôre not using Google calendar tho the deletion might not propagate on a recurring event

[12:57:29.0201] <ryzokuken>
I see

[14:29:12.0282] <rkirsling>
ooh a set methods discussion

[15:08:16.0519] <Rob Palmer>
Hey all, if anyone is in town (San Francisco) for plenary and would like to meet for dinner this evening, please say.  There's a bunch of us (me, RobinR, AshleyC, LittleDan, RobertPamely, maybe AndrewP) already here and so we'll find somewhere.  All are welcome.

[15:09:19.0644] <rkirsling>
interesting

[15:10:10.0964] <rkirsling>
I'm down in San Mateo so I'd need to take a train up there but how can I say no? :D

[15:20:19.0766] <Rob Palmer>
 * Hey all, if anyone is in town (San Francisco) for plenary and would like to meet for dinner this evening, please say.  There's a bunch of us (me, RobinR, AshleyC, LittleDan, RobertPamely) already here and so we'll find somewhere.  All are welcome.

[16:57:15.0437] <Rob Palmer>
The draft schedule (never a promise, purely a guide) is now posted on the Reflector:  https://github.com/tc39/Reflector/issues/437

Please do **not** post the URL here because this channel is public and logged.


2022-07-19
[17:11:55.0529] <shu>
Rob Palmer: you have my 5m item scheduled on the day i can't attend

[17:20:07.0498] <Rob Palmer>
Fixed

[17:26:15.0281] <shu>
ty

[17:44:30.0577] <Rob Palmer>
Retweets on the Community Event invitation are appreciated:  https://twitter.com/TC39/status/1549192175891652608

[17:50:05.0155] <Rob Palmer>
A headsup for tomorrow's plenary meeting:  We are going to use Google Meet for dial-in (instead of Jitsi)

We will open the call at 09:30 so folk can test their AV setup.

https://github.com/tc39/Reflector/issues/437#issuecomment-1188456766

[17:51:03.0686] <Rob Palmer>
If anyone is attending plenary in-person in SF tomorrow, please ensure you have read the entirety of the Reflector main post, otherwise you risk getting denied entry.

https://github.com/tc39/Reflector/issues/437#issuecomment-1188456766

[17:59:26.0326] <Rob Palmer>
Also, breakfast is provided.  So you have an incentive to arrive at 09:20.

[20:13:58.0717] <Hemanth H.M>
Anyone here driving through or around Fremont tomorrow? ü§ì 

[08:35:26.0106] <Rob Palmer>
Hello all, the meeting begins in 90 minutes. The signup sheet is now linked from [the Reflector](https://github.com/tc39/Reflector/issues/437) which you can use to get the Google Meet URL. The Google Meet call will be available for entry from ~45 mins before the meeting onward. If you are attending in person please remember your photo ID, proof of vaccination, and mask.

[09:02:39.0734] <Michael Ficarra>
Rob Palmer: The draft schedule has a video call link. You should probably remove it.

[09:19:30.0809] <rkirsling>
are we meant to come to the Folsom st door?

[09:20:44.0008] <rkirsling>
* which lobby are we meant to come to?

[09:21:25.0275] <rkirsling>
I'm at the Spear Lobby Visitor Entrance

[09:28:00.0491] <Rob Palmer>
You are correct. 

[09:32:54.0412] <Rob Palmer>
ok, we have 8 people in thephysical room

[09:41:45.0863] <rkirsling>
are people eating elsewhere or something?

[09:42:12.0787] <yulia>
oh my gosh, in person meetings!

[09:46:07.0474] <rkirsling>
it's very confusing; Dan came in here and yelled at me and then immediately left and it's like

[09:46:31.0034] <rkirsling>
I don't why I'm the only one eating here but I'm eating so geez

[09:49:12.0159] <Rob Palmer>
All, Google Meet does not let you change your name to the desired form `<name> (<affiliation>)` so please use Incognito/Private browsing mode - then it will allow you

[09:54:27.0016] <Chris de Almeida>
I find the video conf section of the doc confusing

[09:54:32.0220] <Chris de Almeida>
 * I find the video conf section of the doc confusing

[09:54:53.0235] <Chris de Almeida>
is `https://meetings.igalia.com/tc39plenary` accurate?  is that the google meet meeting?  is jitsi/8x8 used or not?

[09:55:31.0447] <Ashley Claymore>
To get the link to the gmeet you'll need to fill in the sign in form

[09:55:36.0859] <rickbutton>
no, check the reflector

[09:55:44.0450] <Chris de Almeida>
this is #437 btw .. in the reflector

[09:55:53.0807] <rickbutton>
also please delete links from this channel, it is logged publicly

[09:56:11.0949] <rickbutton>
 * also please delete links from this channel, it is logged publicly

[09:56:30.0691] <Chris de Almeida>
oh.. the issue has been updated, I'm looking at an email from 8 June.. ü§¶

[09:56:38.0757] <Ashley Claymore>
easily done!

[10:01:56.0982] <Rob Palmer>
The meeting is now starting

[10:01:58.0395] <rkirsling>
yeah so that clarification would've been helpful much earlier

[10:02:13.0794] <rkirsling>
so that I wouldn't've had to be yelled at 

[10:02:20.0215] <rkirsling>
I didn't appreciate that

[10:03:40.0976] <Michael Ficarra>
is somebody speaking? I have no audio

[10:04:29.0397] <Ashley Claymore>
Others are getting audio ok (we got thumbs up)

[10:04:59.0448] <Michael Ficarra>
I did the audio test in meet and it plays fine but I'm getting no call audio

[10:05:04.0066] <Michael Ficarra>
I will try reconnecting

[10:05:25.0001] <Michael Ficarra>
rejoining worked

[10:05:25.0944] <Michael Ficarra>
strange

[10:06:08.0771] <bakkot>
computers /shrug

[10:09:17.0678] <msaboff>
Roughly how many people are in the room?

[10:09:28.0020] <snek>
20ish

[10:12:19.0279] <Michael Ficarra>
the microphone seems highly directional

[10:22:34.0276] <Michael Ficarra>
oh wow, I forgot about introductions!

[10:25:29.0606] <yulia>
congrats rkirsling  on the big  move!

[10:25:40.0419] <rkirsling>
thank you!!

[10:27:14.0659] <rkirsling>
ü¶Ü

[10:28:36.0456] <yulia>
congrats nicolo-ribaudo  on the upgrade :D

[10:30:42.0575] <Robin Ricard>
Congrats on the GPU Yulia

[10:32:10.0697] <rickbutton>
important question: what games are you putting on that GPU?

[10:32:24.0756] <Robin Ricard>
Sorry, I should have posted in tes

[10:32:30.0431] <Robin Ricard>
TDZ*

[10:33:35.0460] <Luca Casonato>
> <@rick.button:matrix.org> important question: what games are you putting on that GPU?

Factorio :)

[10:35:04.0927] <snek>
gaming? on a gpu? i thought those were for generating funny pictures

[10:35:14.0380] <yulia>
> <@lucacasonato:matrix.org> Factorio :)

satisfactory

[10:35:24.0972] <yulia>
*waggles eyebrows*

[10:35:33.0981] <yulia>
*in the direction of tdz*

[10:37:45.0032] <Rob Palmer>
there are 21 people here in the room in SF

[10:38:40.0128] <Chris de Almeida>
TCQ agenda/speaker not working

[10:39:10.0051] <Chris de Almeida>
thanks

[10:39:58.0432] <Rob Palmer>
thanks, Chris - i fixed it now

[10:46:21.0814] <rkirsling>
what was the deal with the "nice" thing

[10:46:58.0266] <yulia>
we have ugly pdfs i hear

[10:47:51.0121] <bakkot>
the current editors have not prioritized the pdfs, it is true

[10:48:09.0959] <ljharb>
another way to say it is, the only people who care about the PDF quality haven't prioritized it until now

[10:48:15.0453] <rkirsling>
I guess I was just curious what specifically Allen did

[10:49:46.0621] <bakkot>
rkirsling: https://twitter.com/awbjs/status/1548072759741124609

[10:50:02.0123] <Michael Ficarra>
attending a UTC+1 meeting remotely from the US is going to suuuuuuuck

[10:50:18.0402] <rkirsling>
thanks! I missed that thread

[10:50:38.0097] <littledan>
You should expect a presentation from the inclusion group and/or chairs about the NVC funding issue in a future meeting. We just didn't have time to prepare such a presentation before this meeting.

[10:51:04.0943] <ljharb>
6pm-1am in PT isn't too bad, but in CT that'd be rough

[10:51:32.0463] <littledan>
I'd prefer that Istvan coordinate on these presentations a bit more; if he has questions, he can ask those involved.

[10:52:40.0922] <rkirsling>
those points really do seem to suggest a fundamental misunderstanding of the purpose of the training üòï

[10:52:49.0018] <Michael Ficarra>
> <@ljharb:matrix.org> 6pm-1am in PT isn't too bad, but in CT that'd be rough

I think you're doing the conversion wrong. A 10:00A meeting in Norway starts at 2:00A for me, 1:00A for you

[10:53:57.0726] <shu>
time to exercise "letting go"

[10:54:07.0540] <shu>
not sure i wanna have a 5 hour meeting at 1am

[10:54:22.0298] <bakkot>
didn't we have one earlier this year?

[10:54:23.0440] <bakkot>
or last year

[10:54:25.0064] <bakkot>
or the one before

[10:54:29.0805] <shu>
yeah and it was not fun

[10:54:31.0547] <bakkot>
(for people in PT)

[10:54:33.0970] <littledan>
We have a number of delegates calling in from Asia at this point, so it seems only fair to give them a break for once

[10:54:40.0924] <littledan>
or twice

[10:55:28.0010] <snek>
how about we compromise and have all meetings in my personal timezone wherever i am

[10:57:14.0649] <nicolo-ribaudo>
According to google it takes 335 days to walk around the globe, you could start walking and the meetings would be mostly equally distributed in one year

[10:57:27.0267] <nicolo-ribaudo>
> <@devsnek:matrix.org> how about we compromise and have all meetings in my personal timezone wherever i am

 * According to google it takes 335 days to walk around the globe, you could start walking and the meetings would be mostly equally distributed in one year

[10:57:32.0237] <rkirsling>
ecma 262 is on summer mode lol

[10:57:53.0276] <ljharb>
oh i was thinking tokyo

[10:57:57.0128] <ljharb>
yeah norway's going to be very rough

[10:57:59.0240] <ljharb>
 * yeah norway's going to be very rough

[10:58:05.0167] <Michael Ficarra>
> <@nicolo-ribaudo:matrix.org> According to google it takes 335 days to walk around the globe, you could start walking and the meetings would be mostly equally distributed in one year

much faster if you start at one of the poles

[10:58:48.0435] <snek>
lol

[11:00:02.0821] <Michael Ficarra>
Korea Advanced Institute of Science & Technology (KAIST)

[11:00:13.0487] <rkirsling>
neat

[11:00:20.0318] <bakkot>
Robin Ricard: ^

[11:00:33.0417] <Michael Ficarra>
see https://github.com/es-meta/esmeta

[11:02:00.0064] <jasew>
has the bot stopped?

[11:02:01.0941] <Luca Casonato>
The list of teams: https://github.com/orgs/tc39/teams/delegates/teams

[11:02:09.0727] <jasew>
nvm

[11:02:14.0961] <Luca Casonato>
 * The list of teams: https://github.com/orgs/tc39/teams/delegates/teams

[11:02:29.0363] <ljharb>
Github teams for member orgs: https://github.com/orgs/tc39/teams/delegates/teams

[11:02:57.0360] <bakkot>
btw if you are presenting this meeting, are on a mac, and have not given your slideshow software (e.g. chrome) permission to present, you may want to do that now

[11:03:07.0169] <Hemanth H.M>
Ah, just https://github.com/orgs/tc39/teams/ didn't list it. 

[11:04:54.0058] <Hemanth H.M>
Ah, just https://github.com/orgs/tc39/teams/ didn't list it.

[11:06:27.0140] <ljharb>
it's underneath "delegates" which is underneath "eligible meeting participants"

[11:09:18.0700] <yulia>
thats very useful to have the version

[11:09:22.0421] <yulia>
 * thats very useful to have the version

[11:09:35.0616] <Michael Ficarra>
sffc: You should see if it's feasible to generate polyfills using KAIST's esmeta

[11:10:04.0854] <Michael Ficarra>
they are apparently able to generate a reference implementation for most of 262, so 402 should be a breeze

[11:10:20.0394] <Michael Ficarra>
sorry, didn't mean to ping while you were presenting

[11:12:00.0340] <bakkot>
most of 402 is locale stuff, but I guess it's possible you could wire up something with ICU

[11:13:23.0604] <Michael Ficarra>
are the polyfills not bring-your-own-ICU-data?

[11:13:29.0966] <Michael Ficarra>
they bundle that data?

[11:13:35.0378] <waldemar>
ljharb: Bill Budge is no longer at Google

[11:14:41.0929] <ljharb>
https://github.com/tc39/Admin-and-Business/issues/259

[11:15:17.0745] <bakkot>
ljharb: do CoC updates go in the notes? I forget

[11:15:53.0849] <ljharb>
yeah, it's fine, anything that can't go in the notes, we can't tell plenary either

[11:22:17.0096] <bakkot>
TA has subarray, which is the thing I want

[11:22:35.0616] <bakkot>
i never want non-contiguous subarrays of a TA

[11:24:36.0966] <bakkot>
note that TAs also do not have flatmap

[11:24:42.0659] <bakkot>
'cause like

[11:24:44.0960] <bakkot>
why do you want that

[11:24:49.0454] <bakkot>
flatmap is also non-mutating, though, so it's possible in the same sense as toSpliced

[11:24:58.0182] <bakkot>
 * flatmap is also non-mutating, though, so it's possible in the same sense as toSpliced

[11:25:17.0836] <shu>
yeah

[11:25:30.0795] <shu>
the ES6-era thing of just having all the Array stuff on TAs is just not the right call

[11:25:38.0390] <shu>
why are you sorting your bytes??

[11:25:46.0385] <snek>
lol i just posted that tweet in tdz shu

[11:25:51.0662] <snek>
 * lol i just posted that tweet in tdz shu

[11:26:13.0940] <shu>
 * the ES6-era thing of just having all the Array stuff on TAs is just not the right call

[11:26:15.0941] <snek>
people do run interesting algorithms on TA data, but very rarely are they written in terms of high level operations like flatmap

[11:26:20.0733] <rkirsling>
wait, like, if it exists, it would have to be called toSpliced, no? since that what the operation is
(I'm for excluding it, but yeah)

[11:26:24.0092] <sffc>
> <@michaelficarra:matrix.org> sffc: You should see if it's feasible to generate polyfills using KAIST's esmeta

Could you suggest this in https://github.com/tc39/ecma402/issues/700 ?

[11:26:36.0287] <rkirsling>
 * wait, like, if it exists, it would have to be called toSpliced, no? since that what the operation is
(I'm for excluding it, but yeah)

[11:26:41.0031] <bakkot>
do i want typedarray to be learnable

[11:27:11.0289] <snek>
i think typedarray should be learnable, its not one of those evil features like atomics

[11:27:25.0924] <rkirsling>
detachment is arguably evil

[11:27:27.0769] <rkirsling>
lol

[11:27:39.0619] <snek>
once we have resizing 

[11:27:42.0811] <snek>
üôè

[11:31:23.0191] <bakkot>
the name is fine by me

[11:31:33.0159] <littledan>
OK, so, how do we draw a conclusion here?

[11:31:33.0744] <bakkot>
i mean splice is already a gross name but it exists, having another name is worse

[11:31:47.0112] <littledan>
Do people feel convinced by the champion's arguments?

[11:31:58.0936] <ryzokuken>
temperature check?

[11:32:58.0802] <HE Shi-Jun>
> <@bakkot:matrix.org> i mean splice is already a gross name but it exists, having another name is worse

yes but we always have the option that do not add "toSpliced" method at all, so we won't spread the gross name more.

[11:33:34.0950] <bakkot>
yeah but you need it on tuples

[11:33:42.0615] <bakkot>
you really need it on tuples

[11:34:05.0988] <rickbutton>
is there any interest in moving just `TypedArray.prototype.toSpliced` to a follow on?

[11:34:13.0149] <rickbutton>
to resolve this?

[11:34:17.0742] <rkirsling>
ehh I think this could be resolved now

[11:34:31.0186] <shu>
littledan: i'd rather we follow res judicata if there is any sentiment to keep toSpliced, we keep it, because it's already stage 3. bar to make stage 3 normative changes should be high

[11:34:44.0495] <shu>
to me TAs are just special

[11:35:04.0113] <bakkot>
yeah

[11:35:12.0865] <rkirsling>
res judicata
> An issue that has already been decided by another court, and therefore must be dismissed.

[11:35:28.0425] <snek>
tc39 common law

[11:35:28.0598] <shu>
oh i guess i used it incorrectly then

[11:35:34.0975] <bakkot>
we should only add methods on TAs when they actually make sense for TAs specifically

[11:35:37.0117] <shu>
i meant more like we decided earlier

[11:35:58.0889] <HE Shi-Jun>
> <@bakkot:matrix.org> yeah but you need it on tuples

I suggested a different api: https://github.com/tc39/proposal-change-array-by-copy/issues/80

[11:37:00.0716] <HE Shi-Jun>
What each emoji mean?

[11:37:56.0466] <Luca Casonato>
:+1: = you like toSplice for TA
üòï = you don't like toSplice for TA

[11:38:57.0636] <HE Shi-Jun>
I don't know which one I should choose, because I dislike toSpliced at all, but if we must have it, it seems TA should also have it...

[11:39:07.0026] <yulia>
well, unconvinced is a pretty good description of my feling

[11:43:51.0997] <yulia>
I'll be off for 15 min

[11:44:01.0359] <yulia>
dminor can field anything for mozilla

[11:46:23.0724] <rkirsling>
<del>ah yes, the saddest of all keys</del>

[11:46:27.0612] <rkirsling>
 * ~~ah yes, the saddest of all keys~~

[11:46:34.0823] <rkirsling>
 * -ah yes, the saddest of all keys-

[11:46:50.0143] <rkirsling>
(for crying out loud, how do I strikethrough, Matrix)

[11:47:01.0803] <ryzokuken>
`<del></del>`

[11:47:09.0626] <ryzokuken>
<del>like this</del>

[11:47:18.0785] <rkirsling>
 * <del>ah yes, the saddest of all keys</del>

[11:48:24.0551] <snek>
its totally up to each client

[11:49:02.0902] <Hemanth H.M>
https://github.com/tc39/test262/pull/3525 

[11:52:14.0531] <snek>
as the maintainer of engine262 i support this change lol

[11:53:27.0150] <Michael Ficarra>
snek: congratulations on your faithful implementation which is now incorrect

[11:53:38.0883] <snek>
such is life

[11:56:02.0656] <bakkot>
just to be clear we're back in 65 minutes?

[11:56:05.0774] <bakkot>
64 now

[11:56:14.0029] <littledan>
yes

[11:56:15.0375] <Robert Pamely>
corect

[13:03:02.0338] <Kris Kowal>
Have we retrieved all delegates from the patio? I believe that‚Äôs the last place I saw Peter Hoddie during lunch.

[13:04:57.0362] <ryzokuken>
we're on time, but in the future maybe we could call out for delegates still busy with lunch?

[13:06:08.0404] <littledan>
Sorry for our delay!

[13:06:16.0684] <Kris Kowal>
 * <del>Have we retrieved all delegates from the patio? I believe that‚Äôs the last place I saw Peter Hoddie during lunch.</del>

[13:15:34.0907] <HE Shi-Jun>
I feel `parseImmutable` should be `parsePrimitive` ?

[13:15:51.0827] <littledan>
HE Shi-Jun: Can you say why?

[13:16:54.0297] <HE Shi-Jun>
immutable is a little bit broad word, it could be immutable object. and it also make us impossible to make tuple/record become mutable value type (just like swift)

[13:17:07.0771] <HE Shi-Jun>
in the future

[13:17:56.0113] <littledan>
I feel fine committing to making record/tuple not becoming a mutable value type like in Swift; to avoid making way too many copies, Swift depends on compiler optimizations that would be infeasible for JS

[13:19:43.0878] <HE Shi-Jun>
I think we need more investigation on value type, at least we shouldn't add constraint in current status by naming it "immutable"

[13:21:04.0059] <HE Shi-Jun>
Swift use CoW optimization, it seems js engines still can use such tech, for example, I believe JavaScriptCore use CoW heavily?

[13:21:39.0852] <nicolo-ribaudo>
Regardless of compiler optimizations, immutability has been one of the core goals of this proposal since the beginning

[13:22:14.0669] <ryzokuken>
I think this proposal loses a lot of its value if we move away from immutability.

[13:23:01.0931] <rbuckton>
"one time", except for Array

[13:23:16.0324] <HE Shi-Jun>
> <@nicolo-ribaudo:matrix.org> Regardless of compiler optimizations, immutability has been one of the core goals of this proposal since the beginning

Value type do not need to be "immutable".  I think we start with immutable, because in the languages without value type, we have to use immutable objects. But we shouldn't mix the concepts.

[13:24:01.0392] <littledan>
> <@littledan:matrix.org> I feel fine committing to making record/tuple not becoming a mutable value type like in Swift; to avoid making way too many copies, Swift depends on compiler optimizations that would be infeasible for JS

HE Shi-Jun:  If you have an idea for how to get past this issue, I'd be interested to hear it.

[13:24:22.0963] <Michael Ficarra>
`__proto__` not being allowed is unfortunate but understandable

[13:24:47.0466] <HE Shi-Jun>
> <@littledan:matrix.org> HE Shi-Jun:  If you have an idea for how to get past this issue, I'd be interested to hear it.

What issue? 

[13:25:20.0099] <littledan>
the issue where, to use a Swift-like approach for CoW immutable things without tons of copies, you need to determine when there is *not* a reference to the original value, which is fundamentally hard in JS

[13:25:49.0904] <littledan>
(e.g., the environment record may reference the object, and so you need to prove that this reference is dead, which is easier to do in Swift than in JS)

[13:27:36.0543] <littledan>
also the runtime version of CoW depends on reference counting, also easier in Swift

[13:30:46.0683] <HE Shi-Jun>
I'm not sure I fully understand your question. IMO, the problem is always there, the idea of "mutable" tupe/record could be easily think as a syntax sugar of creating a new tuple/record. For example, `let x = #[1]; x[0]++` could be think as sugar of `x = #[x[0]+1]`

[13:31:29.0216] <bakkot>
ljharb: i feel like the symbol protocol _is_ the icky hardcoded special case

[13:31:40.0761] <bakkot>
it's only there for historical reasons

[13:31:49.0523] <ljharb>
it could have been an internal slot that HTML sets too tho

[13:33:47.0426] <nicolo-ribaudo>
How do I change my company on TCQ?

[13:33:51.0774] <bakkot>
we went this route because ES6 specifically was trying to make all special behavior explicable in terms of user-exposed mechanisms

[13:33:55.0760] <bakkot>
this was a mistake

[13:33:58.0521] <bakkot>
(IMO)

[13:34:02.0972] <ryzokuken>
> <@nicolo-ribaudo:matrix.org> How do I change my company on TCQ?

by changing it on github

[13:34:07.0363] <snek>
it would be nice if any implementors could share their view here. concat spreadable being a bailout condition in multiple engines seems to speak very accutely to the fact that no one is using this or really cares about it

[13:34:39.0468] <snek>
 * it would be nice if any implementors could share their view here. concat spreadable being a bailout condition in multiple engines seems to speak very accutely to the fact that no one is using this or really cares about it

[13:34:43.0198] <shu>
i have not heard any contrary evidence that it's some widely useful protocol

[13:34:54.0156] <shu>
so it remains a protector in V8 with the cliff

[13:35:21.0752] <littledan>
note that this isn't a JIT cliff but rather a switch among multiple implementations of the function, the slow version and the fast one

[13:35:25.0756] <nicolo-ribaudo>
Ashley Claymore: That's exactly what I meant, thank you!

[13:35:41.0877] <shu>
littledan: it's not just that in V8, it's one of those protector things

[13:35:49.0551] <shu>
there's a protector on prototype lookups of @@isConcatSpreadable

[13:35:57.0721] <ljharb>
to be fair all my personal use cases are or will be around concat-spreading arrays and tuples only, not generic spreadable objects. but it seems like a weird deviation from an established protocol.

[13:36:07.0843] <littledan>
right, and the protector switches you globally into the slow version

[13:36:13.0666] <shu>
right

[13:36:17.0249] <littledan>
but regardless of JIT stage

[13:36:21.0686] <shu>
correct

[13:36:21.0853] <snek>
the thing that interests me is that they consider it acceptable to treat it as a slow path, implying to me that it really has no usage in practice and we should not bother trying to bring it forward.

[13:36:27.0975] <snek>
 * the thing that interests me is that they consider it acceptable to treat it as a slow path, implying to me that it really has no usage in practice and we should not bother trying to bring it forward.

[13:38:13.0734] <HE Shi-Jun>
> <@littledan:matrix.org> also the runtime version of CoW depends on reference counting, also easier in Swift

So the CoW optimizations are similar. If runtime know there is no `x` shared, they could just modify the value of `x`, if it's shared, it just copy `x` and modify on new `x`. Of coz engines could choose always copy `x`, do not need ref counting. 

[13:38:13.0777] <Michael Ficarra>
I'll move my queue items to the issue tracker to  save time

[13:39:15.0257] <bakkot>
to be clear, these exotic wrappers only come up when you invoke a method (presumably with `.call`) in sloppy code with the record or tuple as its `this`

[13:39:28.0210] <bakkot>
it's a very narrow case and I don't much care about sloppy-mode code

[13:39:37.0748] <bakkot>
(if my understanding is wrong please correct me)

[13:39:50.0345] <shu>
what's the problem with hard coding things?

[13:40:27.0146] <snek>
> <@bakkot:matrix.org> (if my understanding is wrong please correct me)

this sounds correct to me

[13:40:27.0648] <Michael Ficarra>
rickbutton: I don't think Jordan's concerned about the verbosity of the spec

[13:41:00.0394] <rickbutton>
oh thats what I interpreted it as (in addition to the JS-side problems)

[13:41:05.0013] <Michael Ficarra>
bakkot: they also come up when doing `Object(record)` explicitly, right?

[13:41:35.0954] <bakkot>
sure I guess

[13:42:02.0632] <bakkot>
I also don't much care about that code

[13:42:51.0199] <rickbutton>
strings are containers of characters

[13:43:05.0665] <snek>
that's a loaded sentence

[13:43:08.0810] <Luca Casonato>
strings are containers of strings 

[13:43:10.0873] <rickbutton>
so much so that you can make something that looks a lot like a string with a tuple

[13:43:17.0628] <nicolo-ribaudo>
numbers are containers of bits

[13:43:19.0754] <Luca Casonato>
oh this isn't tdz

[13:43:33.0189] <bakkot>
yeah I don't think these should pass an `isRecord` check

[13:43:34.0774] <Luca Casonato>
 * oh this isn't tdz

[13:43:37.0390] <bakkot>
 * yeah I don't think these should pass an `isRecord` check

[13:44:06.0180] <bakkot>
in fact it is not totally clear to me why (or if) this is different from just making a new, regular, frozen object with properties and prototype being copied

[13:44:19.0369] <bakkot>
I guess invoking methods on tuples works, is the main difference?

[13:44:30.0876] <bakkot>
but you can have the tuple methods check for the special wrapper

[13:44:41.0960] <snek>
r&t have new `typeof` values right

[13:44:47.0090] <bakkot>
yes

[13:45:04.0042] <snek>
yeah i feel very unmotivated about the whole object wrapper situation lol

[13:45:19.0134] <nicolo-ribaudo>
> <@devsnek:matrix.org> yeah i feel very unmotivated about the whole object wrapper situation lol

I _hate_ object wrappers

[13:45:25.0309] <bakkot>
you need _some_ sort of wrapper for sloppy code here

[13:45:27.0604] <bakkot>
well

[13:45:38.0455] <bakkot>
I guess you technically don't but you probably should

[13:45:47.0305] <littledan>
I don't think the word "axiom" makes much sense here

[13:45:52.0883] <littledan>
more like "true statement"

[13:46:12.0091] <bakkot>
i feel like Object(record) should make a copy of the record with all the keys

[13:46:14.0673] <bakkot>
that seems better

[13:46:16.0872] <nicolo-ribaudo>
> <@bakkot:matrix.org> I guess you technically don't but you probably should

We considered hiding wrappers for R&T and it's possible, but it would be different from what every other primitive does

[13:46:22.0720] <bakkot>
that's like being a wrapper

[13:46:29.0226] <bakkot>
nicolo-ribaudo: that's fine by me

[13:46:34.0756] <snek>
wrapper existing and wrapper having dedicated apis are different levels of caring about the wrapper and i'm feeling more on the former 

[13:46:44.0405] <Michael Ficarra>
I think the current wrapper semantics are fine

[13:46:58.0621] <bakkot>
I don't like `isRecord` for the wrapper semantics

[13:46:59.0898] <Michael Ficarra>
snek: same

[13:47:04.0126] <bakkot>
otherwise I'm fine with it

[13:47:31.0313] <littledan>
well, the wrapper semantics are the entire point of `isRecord` existing

[13:47:37.0030] <bakkot>
right

[13:47:44.0963] <bakkot>
so, don't have that

[13:48:00.0485] <littledan>
I'd be OK with omitting this operation; I'd also be OK with adding a weird predicate Record.isRecordWrapper

[13:48:14.0821] <snek>
i'm personally fine with the `is` methods existing under the assumption that i will never see them being used outside of occasionally reading code from jordan's es-whatever packages

[13:48:39.0843] <bakkot>
yeah, `isRecordWrapper` is certainly a lot more palatable

[13:48:44.0701] <snek>
 * i'm personally fine with the `is` methods existing under the assumption that i will never see them being used outside of occasionally reading code from jordan's es-whatever packages

[13:49:04.0038] <bakkot>
wait yeah try-catch does this already

[13:49:05.0748] <snek>
isRecordObject

[13:49:07.0471] <bakkot>
try-catch solves this perfectly

[13:49:09.0558] <bakkot>
we should do that 100%

[13:49:13.0443] <littledan>
how?

[13:49:36.0700] <snek>
console.log in node can use native apis from v8

[13:49:40.0234] <snek>
we don't need Record.isRecord

[13:49:45.0013] <littledan>
yes

[13:50:04.0712] <nicolo-ribaudo>
> <@devsnek:matrix.org> console.log in node can use native apis from v8

It could also just print record wrappers as normal objects

[13:50:06.0772] <Luca Casonato>
and it already does for things like the isProxy detection code

[13:50:19.0520] <bakkot>
`isRecord(x)` is exactly `typeof x === 'record' || try { Record.omit.call(x, 'a'); return true; } catch { return false }`

[13:50:32.0949] <bakkot>
if I understand correctly

[13:50:33.0851] <snek>
yeah we like, reach into weakmaps and stuff to print out their values, we are very far from needing stdlib support for stuff :P

[13:50:37.0196] <nicolo-ribaudo>
bakkot: The proposal doesn't currently include `.omit`

[13:50:48.0193] <bakkot>
true

[13:50:51.0936] <bakkot>
but if it did that would work

[13:50:54.0342] <rbuckton>
Is there a mechanism to unwrap a Record wrapper if there's no `.valueOf`?

[13:51:02.0858] <ljharb>
> <@bakkot:matrix.org> to be clear, these exotic wrappers only come up when you invoke a method (presumably with `.call`) in sloppy code with the record or tuple as its `this`

also an explicit `Object()` call

[13:51:08.0063] <nicolo-ribaudo>
> <@rbuckton:matrix.org> Is there a mechanism to unwrap a Record wrapper if there's no `.valueOf`?

If wrappers are immutable, `Record(wrapper)`

[13:51:28.0624] <rbuckton>
Ah, thanks.

[13:51:36.0490] <nicolo-ribaudo>
> <@bakkot:matrix.org> but if it did that would work

True (and maybe it would be nicer than `.isRecordWrapper`)

[13:51:43.0660] <bakkot>
rkirsling: did you volunteer to review?

[13:51:51.0273] <bakkot>
trying to capture reviewers in the notes

[13:52:05.0334] <ljharb>
> <@littledan:matrix.org> more like "true statement"

> a statement or proposition which is regarded as being established, accepted, or self-evidently true.

yes, that's what axiom means

[13:52:25.0255] <bakkot>
no, "happens to be true" is very different from "is an axiom"

[13:52:32.0589] <shu>
yes

[13:52:36.0855] <rbuckton>
> <@nicolo-ribaudo:matrix.org> If wrappers are immutable, `Record(wrapper)`

Not 100% sure why that is a requirement:
```js
var obj = Object(1);
obj.x = 2;
obj.x; // 2
var i = Number(obj);
i; // 1
i.x; // undefined
```

[13:52:39.0366] <ljharb>
> <@nicolo-ribaudo:matrix.org> If wrappers are immutable, `Record(wrapper)`

that would work whether they're mutable or immutable.

[13:52:51.0443] <nicolo-ribaudo>
Because `Record(...)` just copies the enumerable keys from the argument

[13:53:02.0511] <nicolo-ribaudo>
 * Because `Record(...)` just copies the enumerable keys from the argument

[13:53:13.0387] <ljharb>
it shouldn't, if it's passed a wrapper

[13:53:14.0695] <rbuckton>
Then it's not "unwrapping" the wrapper, its constructing a new record, which is not the same.

[13:53:20.0780] <ljharb>
it should just extract the slot and return it. if not, that's a bug

[13:53:32.0264] <nicolo-ribaudo>
> <@rbuckton:matrix.org> Then it's not "unwrapping" the wrapper, its constructing a new record, which is not the same.

How is that different since two records with the same contents are the same record?

[13:53:38.0890] <snek>
the slide should say `mod instanceof WebAssembly.Module` i believe

[13:53:45.0599] <snek>
 * the slide should say `import module foo from "./bar.wasm"` i believe

[13:54:10.0984] <rbuckton>
Its different for the exact reason mentioned above. if it copies enumerable keys then it might construct a *new* record if its mutable, so its not unwrapping in that case.

[13:54:12.0405] <snek>
 * the slide should say `mod instanceof WebAssembly.Module` i believe

[13:54:35.0607] <nicolo-ribaudo>
> <@ljharb:matrix.org> it should just extract the slot and return it. if not, that's a bug

```js
let myStr = new String("abc")
myStr.toString = () => "def";
String(myStr) // "def"
```
```js
Boolean(Object(false)) // true
```

[13:54:42.0369] <rickbutton>
there is no difference between a "new record" with the same values, and the old record

[13:54:45.0798] <rickbutton>
they are the same value

[13:54:53.0996] <nicolo-ribaudo>
> <@rbuckton:matrix.org> Its different for the exact reason mentioned above. if it copies enumerable keys then it might construct a *new* record if its mutable, so its not unwrapping in that case.

So it only matters if they are mutable

[13:55:01.0371] <ljharb>
filed https://github.com/tc39/proposal-record-tuple/issues/329

