2022-07-05
[09:30:28.0818] <ljharb>
shouldn't `var r = Proxy.revocable({}, {}); r.revoke(); Array.isArray(r)` throw, per spec? it doesn't in jsc or v8 or firefox. what am i missing?

[09:33:40.0748] <bakkot>
ljharb: you want `Array.isArray(r.proxy)`

[09:33:42.0831] <bakkot>
which does throw

[09:33:48.0181] <ljharb>
ahhh thanks

[09:34:04.0434] <ljharb>
knew i had to be missing something :-)

[09:36:48.0206] <ljharb>
does look like the error message is wrong tho for `var r = Proxy.revocable({}, {}); r.revoke(); Object.prototype.toString.call(r.proxy)` in jsc and v8. filed https://bugs.webkit.org/show\_bug.cgi?id=242342 and https://bugs.chromium.org/p/v8/issues/detail?id=13037 ¬Ø\\\_(„ÉÑ)\_/¬Ø

[09:36:49.0571] <ljharb>
 * does look like the error message is wrong tho for `var r = Proxy.revocable({}, {}); r.revoke(); Object.prototype.toString.call(r.proxy)` in jsc and v8

[09:39:51.0174] <ljharb>
 * does look like the error message is wrong tho for `var r = Proxy.revocable({}, {}); r.revoke(); Object.prototype.toString.call(r.proxy)` in jsc and v8. filed https://bugs.webkit.org/show_bug.cgi?id=242342 and https://bugs.chromium.org/p/v8/issues/detail?id=13037 ¬Ø\_(„ÉÑ)_/¬Ø 

[09:39:54.0740] <ljharb>
 * does look like the error message is wrong tho for `var r = Proxy.revocable({}, {}); r.revoke(); Object.prototype.toString.call(r.proxy)` in jsc and v8. filed https://bugs.webkit.org/show\_bug.cgi?id=242342 and https://bugs.chromium.org/p/v8/issues/detail?id=13037 ¬Ø\\\_(„ÉÑ)\_/¬Ø

[10:23:26.0910] <Rob Palmer (back 4 July)>
The July TC39 plenary meeting is two weeks away. 

This is a gentle reminder that the deadline for adding agenda items that are requesting stage advancement is in less than 4 days time! July 9th, 10:00 PDT

We have a capacity for 15 hours of content during the meeting. Currently we have 4 hours of content, meaning there are 11 hours unallocated. I encourage you to add items to make good use of the time. Content additions after the deadline are also possible but may not qualify for stage advancement.

There are currently 14 remaining in-person places available. So if you intend to attend in-person, please fill in the In-Person Reservation Form soon.

https://github.com/tc39/Reflector/issues/437


2022-07-06
[06:54:28.0349] <Jack Works>
üëÄ I want to do a temperature check on the range proposal (discussion https://github.com/tc39/proposal-Number.range/issues/17 )

Do you think it should be a Iterator (1Ô∏è‚É£) or an Iterable object (üî¢)?


2022-07-07
[08:04:30.0283] <zbraniecki>
Can you explain what are the tangible implications of choosing Iterator here?

[08:31:45.0850] <rbuckton (OOF: 7/5 - 7/16)>
> <@jackworks:matrix.org> üëÄ I want to do a temperature check on the range proposal (discussion https://github.com/tc39/proposal-Number.range/issues/17 )
> 
> Do you think it should be a Iterator (1Ô∏è‚É£) or an Iterable object (üî¢)?

I generally prefer Iterable, so that a range can be reused:
```js
const oneToTen = Number.range(1, 10);
// prints: 1\n2\n...
for (const x of oneToTen) console.log(x);
// prints: ??? 
for (const x of oneToTen) console.log(x);
```
Its rare that someone will manually step through an iterator rather than use `for..of` or `...`, and the latter will exhaust the iterator, making a range useless after it has been used once.
If you need to step over it manually, you could still use `Symbol.iterator`, so Iterable is vastly more flexible. 
That said, the iterator helpers proposal depends on Iterator (which I still disagree with in principle), but relevant methods could be lifted to a Range as well.
I'm still hoping we could someday have a standalone range/slice syntax like `a..b`, though that can (hopefully) come later. 

[08:32:52.0746] <rbuckton (OOF: 7/5 - 7/16)>
* I generally prefer Iterable, so that a range can be reused:

```js
const oneToTen = Number.range(1, 10);
// prints: 1\n2\n...
for (const x of oneToTen) console.log(x);
// prints: ??? 
for (const x of oneToTen) console.log(x);
```


Its rare that someone will manually step through an iterator rather than use `for..of` or `...`, and the latter will exhaust the iterator, making a range useless after it has been used once.

If you need to step over it manually, you could still use `[Symbol.iterator]()`, so Iterable is vastly more flexible. 
That said, the iterator helpers proposal depends on Iterator (which I still disagree with in principle), but relevant methods could be lifted to a Range as well.
I'm still hoping we could someday have a standalone range/slice syntax like `a..b`, though that can (hopefully) come later. 

[08:32:53.0180] <rbuckton (OOF: 7/5 - 7/16)>
* I generally prefer Iterable, so that a range can be reused:
```js
const oneToTen = Number.range(1, 10);
// prints: 1\n2\n...
for (const x of oneToTen) console.log(x);
// prints: ??? 
for (const x of oneToTen) console.log(x);
```
Its rare that someone will manually step through an iterator rather than use `for..of` or `...`, and the latter will exhaust the iterator, making a range useless after it has been used once.
If you need to step over it manually, you could still use `Symbol.iterator`, so Iterable is vastly more flexible. 
That said, the iterator helpers proposal depends on Iterator (which I still disagree with in principle), but relevant methods could be lifted to a Range as well.
I'm still hoping we could someday have a standalone range/slice syntax like `a..b`, though that can (hopefully) come later. 

[08:34:19.0837] <rbuckton (OOF: 7/5 - 7/16)>
(and I am not very good at avoiding work when I'm supposed to be on PTO) 

[09:58:31.0616] <ljharb>
you can reuse it by sticking ()=> in front of it

[10:05:32.0054] <rbuckton (OOF: 7/5 - 7/16)>
That's not reuse, that's recreating it each time. It also potentially reevaluates each argument, which could have side effects/performance implications. 

[10:07:35.0485] <rbuckton (OOF: 7/5 - 7/16)>
i.e., `const r = () => Number.range(0, f())`. Beginners could easily overlook the `f()`

[10:09:08.0225] <rbuckton (OOF: 7/5 - 7/16)>
Maybe PFA could help, but it's also not something a beginner would likely reach for immediately, nor is the `() =>` trick 

[10:14:22.0364] <zbraniecki>
My mental model is aligned with rbuckton (PTO: 7/5 - 7/16) - `oneToTen` should produce an iterator when used in a loop. I probably am projecting how Rust does it where `Range` implements `IntoIterator`

[10:20:24.0540] <ljharb>
i don't think beginners will expect to reuse it either tho.

[10:37:54.0187] <rbuckton (PTO: 7/5 - 7/16)>
I think beginners are more likely to reuse it than not, just as you could reuse an array, or map, or set, or typed array. This is especially true if we do ever have a range/slice syntax in the future. 

[10:41:08.0250] <rbuckton (PTO: 7/5 - 7/16)>
I'm still of the opinion that the iterator helpers proposal has a very short-sighted view by focusing on Iterator and not Iterable, and I'd rather not repeat the mistake of leveraging the wrong level of abstraction in more places if we can potentially avoid it. That said, Iterator is probably fine for `Number.range()` on its own, but I would be strongly opposed to the same behavior for any potential Range/slice syntax in the future. 

[10:57:18.0677] <bakkot>
sidebar: I am now ~half of the agenda items for the next meeting. hope everyone is prepared to talk about dumb corner cases for an entire meeting.

[11:08:53.0451] <shu>
please cover them on wednesday, when i cannot be there

[11:32:39.0229] <ljharb>
iterable isn‚Äôt a thing, it‚Äôs a trait.

[11:32:57.0609] <ljharb>
whereas an iterator is a thing

[12:37:25.0846] <ptomato>
> <@bakkot:matrix.org> sidebar: I am now ~half of the agenda items for the next meeting. hope everyone is prepared to talk about dumb corner cases for an entire meeting.

I will add an item on Temporal, but unfortunately it's also all dumb corner cases

[12:56:57.0922] <littledan>
Are people thinking of breakout sessions for the upcoming TC39 meeting, given our possibly somewhat light schedule when finally meeting partly in person/hybrid?

[12:57:09.0019] <littledan>
 * Are people thinking of breakout sessions for the upcoming TC39 meeting, given our possibly somewhat light schedule when finally meeting partly in person/hybrid?

[12:58:48.0390] <littledan>
I could imagine one breakout session on modules, one on inclusion, and maybe one on Ecma, if people are interested. I imagine that other people may have other interesting topics.

[13:00:18.0055] <jschoi>
(For what it‚Äôs worth, I am still planning to add along with Hemanth H.M three agenda items for a once function, a memoize function, and built-in cache maps/sets, so the agenda will fill up a little more than it is now. I might also fill in more time with some chartered incubator topics that haven‚Äôt yet had their incubator meetings, like Array.fromAsync, BigInt Math, bind-this and pipe/topic. I‚Äôm not sure whether those would be more appropriate as breakout sessions or as ordinary agenda topics.)

[13:01:01.0550] <jschoi>
 * (For what it‚Äôs worth, I am still planning to add along with Hemanth H.M three agenda items for a once function, a memoize function, and built-in cache maps/sets, so the agenda will fill up a little more than it is now. I might also fill in more time with some chartered incubator topics that haven‚Äôt yet had their incubator meetings, like Array.fromAsync, BigInt Math, bind-this and pipe/topic. I‚Äôm not sure whether those would be more appropriate as breakout sessions or as ordinary agenda topics.)

[13:01:21.0460] <littledan>
oh yes please keep adding agenda items! those definitely are higher priority than the open-ended discussions I was suggesting.

[13:02:37.0954] <jschoi>
Some of the incubator topics are, for better or for worse, open-ended, especially discussion regarding dataflow syntaxes (including pipe/topic and bind-this). Also, I didn‚Äôt get to mention this at last plenary, but it‚Äôs good to see you again; hope you had a good past year.

[13:02:51.0645] <littledan>
yeah good to see you too!

[13:02:52.0999] <littledan>
I'd suggest that overflow incubator items could be breakout sessions, rather than agenda items

[13:03:20.0021] <littledan>
(I mean, unless someone really does want to present a proposal for them)

[13:07:46.0276] <littledan>
> <@jschoi:matrix.org> (For what it‚Äôs worth, I am still planning to add along with Hemanth H.M three agenda items for a once function, a memoize function, and built-in cache maps/sets, so the agenda will fill up a little more than it is now. I might also fill in more time with some chartered incubator topics that haven‚Äôt yet had their incubator meetings, like Array.fromAsync, BigInt Math, bind-this and pipe/topic. I‚Äôm not sure whether those would be more appropriate as breakout sessions or as ordinary agenda topics.)

those new proposals sound interesting! they seem like tricky things to make built-in since caches/memoization sometimes have domain-specific retention policies; are you proposing hooks for those?

[13:07:54.0518] <jschoi>
As champion / co-champion of four out of the five chartered incubator items (https://github.com/tc39/incubator-agendas/issues/25), I do not plan to advance any of them next meeting, haha. There‚Äôs just too much contention around them right now. But maybe decorator metadata might be ready‚Ä¶

[13:08:37.0093] <littledan>
of course once should be a template tag, ```once`${f}`(x)``` to take advantage of location-based caching ;)

[13:08:49.0186] <littledan>
 * of course once should be a template tag, `once``${f}``(x)` to take advantage of location-based caching ;)

[13:09:02.0602] <littledan>
 * of course once should be a template tag, ```once`${f}`(x)``` to take advantage of location-based caching ;)

[13:09:04.0982] <jschoi>
> <@littledan:matrix.org> those new proposals sound interesting! they seem like tricky things to make built-in since caches/memoization sometimes have domain-specific retention policies; are you proposing hooks for those?

Oh yeah, that‚Äôs the third proposal: maps and sets with cache-replacement policies, for the sake of memoizing but also other stuff. I‚Äôm undecided whether to bundle memoization with CRP maps/sets into one proposal or not; I think we‚Äôre going to probably separate them.

[13:09:35.0043] <littledan>
I'm glad to see that you've gotten more involved over the past year!

[13:09:55.0273] <jschoi>
https://github.com/js-choi/proposal-function-memo
https://github.com/js-choi/proposal-policy-map-set


[13:09:59.0195] <jschoi>
Yeah, thanks!

[13:10:29.0475] <shu>
jschoi: apologies, doesn't look like i'll have enough cycles this cycle to do an incubator call :(

[13:12:00.0839] <jschoi>
Yeah, it‚Äôs no problem; I think we‚Äôre all very thankful of you managing the incubators. Hopefully we‚Äôll knock some stuff out during plenary.

[13:13:09.0611] <shu>
yes, might be a good one to do it with such a light schedule

[14:07:22.0205] <rbuckton (PTO: 7/5 - 7/16)>
> <@ljharb:matrix.org> iterable isn‚Äôt a thing, it‚Äôs a trait.

That's the case in every language/library that is prior art for iterator helpers. Python has itertools. C# has Enumerable+extension methods. F# has pipelines (and so will we). All operate on the "Iterable" not the "iterator". 

[14:17:38.0160] <bakkot>
Java's streams are pretty similar to iterators and are where all of Java's equivalents of these methods are.

[14:20:09.0527] <bakkot>
also Rust's methods are all on the Iterator trait

[14:20:46.0800] <bakkot>
Boost (the C++ library) has `filter_iterator` and so on which are, obviously, on iterators

[14:21:03.0498] <bakkot>
 * Boost (the C++ library has `filter_iterator` and so on whic are, obviously, on iterators

[14:21:08.0994] <bakkot>
 * Boost (the C++ library) has `filter_iterator` and so on whic are, obviously, on iterators

[14:21:35.0635] <bakkot>
 * Boost (the C++ library) has `filter_iterator` and so on which are, obviously, on iterators

[14:23:09.0590] <bakkot>
Scala's AbstractIterator has `filter` and so on

[14:23:14.0598] <bakkot>
I dunno I feel like this is a lot of languages

[14:23:55.0116] <bakkot>
 * Scala's AbstractIterator has `filter` and so on

[14:34:24.0713] <Ashley Claymore>
If range returned an iterator could the return value still include additional properties (start, end, step), similar to if it returned a ‚Äúrange instance‚Äù? Or should it only have next?

[15:10:31.0100] <ljharb>
prior art is informative, not constraining, and never automatically the right choice for JS.

[16:29:28.0224] <ljharb>
absolutely it could; whether it should is a different question


2022-07-08
[23:27:21.0425] <Jack Works>
All I know is, if you try to reuse it in Rust, it will be rejected by the compiler üòÇ

```rust
fn main() {
   let a = (1..5).into_iter();
   //   for i in &a {} NOT WORK
   for i in a {}
   for i in a {} // Error: Use moved value a
}
```

[00:16:12.0250] <ljharb>
In general, iterators aren‚Äôt reusable, with very few exceptions (notably, builtins like array) - i just don‚Äôt think people are going to consistently have the intuition that they will be.

[04:02:08.0646] <Rob Palmer>
For those who will be in SF for TC39 in 12 days time, @sffc has organized a Community event on the Wednesday 20th evening at 17:30.

  https://github.com/tc39/Reflector/issues/437#issuecomment-1177199594

Please let Shane know if you would like to give a presentation or participate in the panel.

[04:03:39.0948] <Rob Palmer>
Also, if you wish to put an item on the Plenary agenda for stage advancement, you have a little over 24 hours to do so.

https://github.com/tc39/Reflector/issues/437#issuecomment-1178843643

[07:33:23.0693] <zbraniecki>
> <@jackworks:matrix.org> All I know is, if you try to reuse it in Rust, it will be rejected by the compiler üòÇ
> 
> ```rust
> fn main() {
>    let a = (1..5).into_iter();
>    //   for i in &a {} NOT WORK
>    for i in a {}
>    for i in a {} // Error: Use moved value a
> }
> ```

but you can do:

```rust
fn main() {
  let a = 1..5;
  for i in a {} // implicitly calls into_iter()
  for i in a {} // implicitly calls into_iter()
}
```

[08:26:46.0568] <littledan>
Looks like the TC39 calendar and the agenda page disagree on when the agenda deadline is

[08:27:13.0734] <littledan>
Should we say that the agenda page is authoritative here? That one is later (tomorrow)

[08:50:57.0104] <Rob Palmer>
The agenda is authoritative.

[10:06:52.0227] <ljharb>
i'll fix the calendar, not sure where the current deadline event came from

[10:36:49.0264] <littledan>
thanks for fixing it ljharb !

[12:36:12.0906] <jschoi>
A doodle of something I might propose tomorrow for Stage¬†1: generic `Object.equiv` and `Object.diff` functions. https://gist.github.com/js-choi/b8b1a1c1388354d1b4384bea8a1fca0a

[12:36:18.0333] <jschoi>
 * A doodle of something I might propose tomorrow for Stage¬†1: generic `Object.equiv` and `Object.diff` functions. https://gist.github.com/js-choi/b8b1a1c1388354d1b4384bea8a1fca0a

[12:36:54.0955] <jschoi>
It‚Äôs functionally a superset of https://github.com/tc39/proposal-array-equality.

[12:36:56.0572] <jschoi>
 * It‚Äôs kind of a superset of https://github.com/tc39/proposals/blob/main/stage-1-proposals.md.

[12:37:09.0719] <jschoi>
 * It‚Äôs functionally a superset of https://github.com/tc39/proposals/blob/main/stage-1-proposals.md.

[12:38:14.0694] <bakkot>
jschoi: I think that second link is not the correct link?

[12:39:16.0290] <jschoi>
* It‚Äôs functionally a superset of https://github.com/tc39/proposal-array-equality.

[12:39:23.0742] <jschoi>
Fixed, thanks. 

[12:49:45.0361] <bakkot>
jschoi: It's a fun idea but for asking for stage 1 people mostly want a problem statement rather than a concrete possible solution, so you might consider presenting this as "i want to compare objects, ideally in a way where the objects can say how to compare themselves. stage 1?" and then after that discussion "also, having gotten stage 1, I want feedback on this direction I was considering, which I am not asking for stage advancement for"

[12:50:38.0171] <jschoi>
Yeah, agreed. 

[12:50:52.0198] <jschoi>
Thanks for feedback. : )

[12:50:55.0124] <bakkot>
though you could also consider seeing if the array equality champions would consider something like this in scope, in which case you wouldn't necessarily need to ask for stage 1 again for a separate thing

[13:17:44.0239] <rbuckton (PTO: 7/5 - 7/16)>
> <@jschoi:matrix.org> A doodle of something I might propose tomorrow for Stage¬†1: generic `Object.equiv` and `Object.diff` functions. https://gist.github.com/js-choi/b8b1a1c1388354d1b4384bea8a1fca0a

I've wanted to handle object equality for awhile (including use as keys in Map and Set). I created the `@esfx/equatable` package as a possible sketch (along with `@esfx/collections-hashmap` and `@esfx/collections-hashset`). https://esfx.js.org/#collections

[13:34:14.0127] <jschoi>
For what it‚Äôs worth, I think that diffing (not just testing with a boolean result) is a pretty common use case‚Äîevery time you want to assert that two objects are equal, it is useful to be able to quickly see why are not the same.
Imagine how many times you‚Äôve added a temporary `console.log(thingA, thingYouExpectedToBeTheSameAsThingA)` line while debugging, but found that the things were very large and you had to painstakingly find the difference. I‚Äôve even copied and pasted debugging output to text-diffing applications.
Of course, assertion and test-runner libraries nowadays include such functionality for the same reasons. 
Anyways, any equality can be defined in terms of an empty a diff, so it‚Äôs a good opportunity to visit this. I‚Äôll be talking with Hemanth H.M and ljharb about whether to tack this onto array-equality in another Matrix room.

[13:34:29.0677] <jschoi>
 * For what it‚Äôs worth, I think that diffing (not just testing with a boolean result) is a pretty common use case‚Äîevery time you want to assert that two objects are equal, it is useful to be able to quickly see why are not the same.
Imagine how many times you‚Äôve added a temporary `console.log(thingA, thingYouExpectedToBeTheSameAsThingA)` line while debugging, but found that the things were very large and you had to painstakingly find the difference. I‚Äôve even copied and pasted debugging output to text-diffing applications.
Of course, assertion and test-runner libraries nowadays include such functionality for the same reasons. 
Anyways, any equality can be defined in terms of an empty a diff, so it‚Äôs a good opportunity to visit this. I‚Äôll be talking with Hemanth H.M and ljharb about whether to tack this onto array-equality in another Matrix room.

[13:46:31.0105] <ljharb>
for some prior art, see https://npmjs.com/is-equal, and import/require `is-equal/why`, you'll get a string explaining why they're different (but not a full diff)

[13:53:02.0809] <jschoi>
 * For what it‚Äôs worth, I think that diffing (not just testing with a boolean result) is a pretty common use case‚Äîevery time you want to assert that two objects are equal, it is useful to be able to quickly see why are not the same.
Imagine how many times you‚Äôve added a temporary `console.log(thingA, thingYouExpectedToBeTheSameAsThingA)` line while debugging, but found that the things were very large and you had to painstakingly find the difference. I‚Äôve even copied and pasted debugging output to text-diffing applications.
Of course, assertion and test-runner libraries nowadays include such functionality for the same reasons.
Anyways, any equality can be defined in terms of an empty diff, so it‚Äôs a good opportunity to visit this. I‚Äôll be talking with Hemanth H.M and ljharb about whether to tack this onto array-equality in another Matrix room.


2022-07-09
[02:19:19.0162] <HE Shi-Jun>
> <@bakkot:matrix.org> also Rust's methods are all on the Iterator trait

I think I already commented that several times: Rust (and D) use iterator-like semantic, because these languages use value type semantic on iterator. So they don't suffer the reuse problem. And Rust have a very strong compiler which won't allow u reuse a iterator twice by default (you need to assign it to a separate var and with value type copy semantic, it give u a two iterator instances). Obviously JS do not have  that merits. (Even I really hope we could have value type one day, I very doubt we can have value type semantic iterator in JS.)

[02:20:32.0925] <HE Shi-Jun>
> <@ljharb:matrix.org> i'll fix the calendar, not sure where the current deadline event came from

I guess it used the wrong timezone. :)

[11:40:14.0795] <bakkot>
> <@haxjs:matrix.org> I think I already commented that several times: Rust (and D) use iterator-like semantic, because these languages use value type semantic on iterator. So they don't suffer the reuse problem. And Rust have a very strong compiler which won't allow u reuse a iterator twice by default (you need to assign it to a separate var and with value type copy semantic, it give u a two iterator instances). Obviously JS do not have  that merits. (Even I really hope we could have value type one day, I very doubt we can have value type semantic iterator in JS.)

This is true, but the fundamental fact remains: in Rust the helpers are on the one-shot thing.

Yes, in Rust the compiler will prevent you from making this particular mistake, whereas in JS you are more likely to get bit by it, so yes, there's a significant downside to using iterators that Rust does not have (though all the other languages I named do - nothing prevents you from trying to re-use a Java stream, e.g.).

But the most important question is whether the helpers are usable and clear when used _correctly_, and on that question, the compiler checks are irrelevant.

(And there's similar problems with accidentally re-using helpers on _iterables_ in other non-rust languages, for that matter - see e.g. the second half of https://stackoverflow.com/a/28513908, which discusses the downsides of C#'s IEnumerable design which were explicitly considered when designing Java's Streams. We're all jealous of Rust's compile-time checks but we still have to design a language which works without them.)

[12:03:44.0851] <jschoi>
I vaguely remember that someone a few years ago (was it Domenic Denicola?) trying to figure out in a GitHub Issue if we could ever have chained numeric comparisons like `x <= y < z`‚Äîand that sadly the person found that there was no way. Does anyone have a link to that thread?

[14:59:21.0589] <snek>
i just heard about the sf js meetup

[14:59:31.0913] <snek>
is there anything i need to do to be able to go to that

[16:08:15.0219] <bakkot>
snek: assuming you are talking about https://www.meetup.com/jsmeetup/events/287033071/, it says on  https://github.com/tc39/Reflector/issues/437 that delegates are not required to RSVP


2022-07-10
[06:34:47.0624] <HE Shi-Jun>
I think Java Streams is ok, but we should note it is intentionally named as "Stream", to make it clear it's not Iterable/Iterator. If we follow Java design, we should also consider change iterator helpers to "Stream". Actually I think Emitter proposal is a very similar and more powerful Stream-like API, a good alternative to iterator helpers.

[06:55:39.0655] <HE Shi-Jun>
bakkot: And the original question is whether number range() should be iterable/iterator, this is a separate question, not direct relate to the design choice of iterator helpers or iterable helpers or stream... Generally speaking I prefer iterable. I'm ok with iterator/stream version if it is make clear that's a iterator/stream (eg. naming it as `Iterator.integers()` or Java-like `IntStream.range()`). See https://github.com/tc39/proposal-Number.range/issues/57

[10:19:36.0523] <bakkot>
Java's Streams happened after they'd already defined their `Iterator` interface and could no longer redefine it as a class; I don't think the naming there is that informative

[10:19:51.0737] <bakkot>
other languages like Scala and Rust did not make that choice

[10:20:37.0863] <bakkot>
anyway I agree with you about the particular question of `Number.range`, I'm mostly objecting to the assertion that every language which has an equivalent of iterator helpers has them for iterables rather than iterators

[10:20:40.0640] <bakkot>
 * anyway I agree with you about the particular question of `Number.range`, I'm mostly objecting to the assertion that every language which has an equivalent of iterator helpers has them for iterables rather than iterators

[11:08:23.0876] <HE Shi-Jun>
> <@bakkot:matrix.org> Java's Streams happened after they'd already defined their `Iterator` interface and could no longer redefine it as a class; I don't think the naming there is that informative

Not sure what's the diff of interface/class in this case, Stream/IntStream is also interface in Java...

[12:05:12.0168] <bakkot>
Oh, yeah, ok

[12:05:13.0730] <bakkot>
Yeah I dunno

[12:08:27.0917] <bakkot>
possibly it's because java iterators support `.remove` and such

[14:54:57.0092] <jschoi>
bakkot, Michael Ficarra, nicolo-ribaudo: Can you check whether this Gist (about Array.fromAsync and AsyncIterator.prototype.toArray) matches your understanding? https://gist.github.com/js-choi/5b49b350995c5a44571be3d314e38162

[15:00:58.0141] <jschoi>
 * bakkot, Michael Ficarra, nicolo-ribaudo: Can you check whether this Gist (about Array.fromAsync and AsyncIterator.prototype.toArray) matches your understanding? I plan to post it in proposal-array-from-async#19 and refer to it from proposal-iterator-helpers#168. https://gist.github.com/js-choi/5b49b350995c5a44571be3d314e38162 I 

[15:02:09.0924] <jschoi>
 * bakkot, Michael Ficarra, nicolo-ribaudo: Can you check whether this Gist (about Array.fromAsync and AsyncIterator.prototype.toArray) matches your understanding? I plan to post it in proposal-array-from-async#19 and refer to it from proposal-iterator-helpers#168. https://gist.github.com/js-choi/5b49b350995c5a44571be3d314e38162 

[15:06:43.0180] <jschoi>
 * bakkot, Michael Ficarra, nicolo-ribaudo: Can you check whether this Gist (about Array.fromAsync and AsyncIterator.prototype.toArray) matches your understanding?  https://gist.github.com/js-choi/5b49b350995c5a44571be3d314e38162

(I plan to post it in proposal-array-from-async#19 and refer to it from proposal-iterator-helpers#168.)

[15:12:04.0551] <bakkot>
jschoi: lgtm

[15:12:23.0002] <bakkot>
though this line is a bit weird:

> Bakkot points out that the ‚Äúidentity function‚Äù of Array.fromAsync does not have to be x => x. In actuality, it is async x => x.

[15:12:33.0019] <bakkot>
I don't know what "identity function" means there

[15:12:34.0217] <jschoi>
Yeah, I just revised it. Refresh the page?

[15:12:49.0300] <bakkot>
ah, sure

[15:13:04.0153] <bakkot>
I would change `the ‚Äúidentity function‚Äù of Array.fromAsync` to `the ‚Äúdefault mapping function‚Äù of Array.fromAsync`

[15:13:21.0501] <jschoi>
Will do. Thanks for checking!

[15:13:25.0812] <bakkot>
or something like that. "identity function" is a property of values, not of functions like "fromAsync"

[15:13:56.0879] <jschoi>
Hopefully now we will have all our ducks in a row with regards to consistency between `Array.fromAsync`, iterator-helpers, and `for await`.

[15:14:04.0326] <jschoi>
 * Hopefully now we will have all our ducks in a row with regards to consistency between `Array.fromAsync`, iterator-helpers, and `for await`.

[15:16:15.0716] <bakkot>
I believe so!

[15:16:52.0017] <bakkot>
I have an agenda item about similarly lining up `yield*` in async generators (https://github.com/tc39/ecma262/pull/2819)

[15:16:56.0345] <bakkot>
working on slides for it now


2022-07-11
[10:45:26.0060] <bakkot>
does anyone who actually knows how `Set`s are implement know if it is possible to use the internal data structure to efficiently implement something like "order this list, which is a subset of the elements in some `Set`, according to the order the values in the list would be emitted when iterating the `Set`"

[10:45:44.0922] <bakkot>
"efficiently" meaning something like "with time proportional to the size of the list, not the size of the `Set`"

[10:45:56.0024] <bakkot>
I am guessing no but I have no idea what the actual implementation looks like

[10:50:08.0758] <shu>
what is the subset?

[10:52:02.0161] <bakkot>
uh

[10:52:05.0789] <bakkot>
like it's some elements of a set

[10:52:48.0802] <bakkot>
you have 1) a `Set` _x_ and 2) a list of some (but not necessarily all, and often much less than all) elements from _x_, which are not ordered according to the order in _x_

[10:52:59.0687] <bakkot>
 * you have 1) a `Set` _x_ and 2) a list of some elements from _x_, which are not ordered according to the order in _x_

[10:53:22.0530] <bakkot>
and you want to sort the list according to the order of the elements in _x_

[10:53:55.0962] <bakkot>
 * you have 1) a `Set` _x_ and 2) a list of some (but not necessarily all, and often much less than all) elements from _x_, which are not ordered according to the order in _x_

[10:54:16.0489] <bakkot>
the list is spec-internal, to be clear, so there's no side effects or anything happening during the process

[11:01:31.0788] <shu>
i do not understand the use case still, is there something concrete i can read?

[11:05:50.0398] <shu>
anyway maybe you can get some insight from https://wiki.mozilla.org/User:Jorend/Deterministic_hash_tables

[11:06:01.0058] <bakkot>
you don't understand the use case, or you don't understand the ask?

[11:06:06.0100] <shu>
i don't understand the use case

[11:06:21.0695] <shu>
is the sublist static, always same size? is it dynamic?

[11:06:26.0119] <shu>
what determines membership in the sublist?

[11:06:58.0195] <shu>
v8 continues to use roughly the same thing as described in jorendorff's wiki page there

[11:07:16.0163] <shu>
insertion order is simply the ascending order of the Entry array

[11:07:23.0997] <bakkot>
the use case is to get consistent order for `Set.prototype.intersection` - depending on which of `this` vs `other` is larger, you might be iterating `this` or `other`, and it would be nice if the order of the resulting set did not depend on which set was being iterated.

[11:07:33.0150] <shu>
i see

[11:07:56.0146] <bakkot>
and the obvious way to do that is to ensure the elements of the resulting set are ordered according to their order in `this`

[11:08:31.0638] <bakkot>
but if `this` is much larger than `other`, and performing said ordering takes time proportional to the size of `this` even when the intersection is small, that's bad

[11:08:52.0064] <shu>
you have two total orders, but how do you compose them into another total order?

[11:09:02.0128] <bakkot>
for intersection in particular, you don't need to

[11:09:11.0203] <shu>
ah it's intersection, right i see

[11:09:28.0528] <shu>
okay, i understand the use case now

[11:09:46.0140] <shu>
i have no idea how you do this efficiently in the current implementations of Set

[11:10:15.0290] <bakkot>
I haven't thought through all the other methods yet; it's possible this ordering wouldn't work for some of them. (others, like `union`, don't have this problem because the optimal algorithm does not produce a result whose order depends on the sizes of the input.)

[11:10:27.0736] <bakkot>
ok, alas.

[11:10:39.0642] <shu>
at the cost of either space or time everything is possible

[11:10:46.0775] <bakkot>
sure

[11:11:31.0103] <shu>
in this case, ISTM the shortest path would be to also store the index in the hash table `Entry` struct

[11:11:40.0735] <shu>
 * in this case, ISTM the shortest path would be to also store the index in the hash table `Entry` struct

[11:12:10.0503] <bakkot>
(Ashley Claymore has suggested in https://github.com/tc39/proposal-set-methods/issues/70#issuecomment-1179692731 another option which adds a constant factor number of additional calls (not observable when it's a native Set) to get a deterministic if kind of strange order, which is my current leading alternative)

[11:12:19.0607] <shu>
you can then straightforwardly sort the list of indices pointed to by the elements in the intersection, and the indices in either of the source Sets would work

[11:12:28.0445] <shu>
but that's an extra int in every entry

[11:12:30.0280] <shu>
and that seems bad

[11:12:35.0530] <bakkot>
yeah

[11:14:15.0802] <shu>
well, wait a second now

[11:14:49.0728] <shu>
one of the properties of that particular implementation strategy of an ordered hash table is that the `Entry`s are allocated contiguously in an `Entry[]` array

[11:15:11.0469] <shu>
if you build an auxiliary list of the found `Entry`s in the intersection, you can presumably do address comparison

[11:15:44.0895] <shu>
i hope that falls out from most implementation languages' array allocation guarantees

[11:15:57.0854] <bakkot>
ooh, love me some pointer comparisons

[11:16:24.0039] <shu>
mind you i am not excited to recommend that in a non-normative note

[11:16:29.0604] <shu>
i don't know how you'd get UB to bite you, but it will

[11:16:41.0118] <bakkot>
the spec currently doesn't suggest any implementation strategy at all

[11:16:57.0549] <shu>
right, i'm just saying it seems very particular

[11:16:58.0744] <bakkot>
actually it might, I forget

[11:17:01.0363] <shu>
and a touch too clever

[11:17:03.0630] <bakkot>
yeah

[11:17:26.0865] <shu>
there are footguns there i'm worried about like

[11:17:32.0903] <shu>
what if the table is rehashed in the middle of performing the intersection

[11:17:38.0689] <shu>
is that even possible, i hope not but maybe

[11:20:03.0910] <shu>
okay so pointer comparison is my final answer and i'm sticking to it

[11:20:07.0850] <shu>
probably fine

[11:20:49.0276] <bakkot>
I would expect rehashing not to affect the `dataTable` itself, just the `chain` pointers within it, so I'd expect that to be fine

[11:21:54.0667] <shu>
yes true, so the entry addresses would be stable

