2022-05-02
[13:10:48.0779] <shu>
jschoi: does May 6 8:00 - 9:00 PT work for you for the incubator call?

[13:47:17.0269] <jschoi>
> <@shuyuguo:matrix.org> jschoi: does May 6 8:00 - 9:00 PT work for you for the incubator call?

This time works for me, thank you.

[13:47:33.0680] <jschoi>
I will try to have an agenda ready by tomorrow.

[14:42:10.0269] <shu>
excellent, thank you

[15:13:51.0547] <shu>
jschoi: argh, oops, i misread the doodle

[15:14:09.0676] <shu>
i meant May 6 9:00 - 10:00 PT, 1 hour later


2022-05-03
[06:11:35.0580] <jschoi>
> <@shuyuguo:matrix.org> i meant May 6 9:00 - 10:00 PT, 1 hour later

No worries; I can make that too. Thanks for arranging!

[15:14:50.0385] <ljharb>
`Array(Math.pow(2, 32) - 1).concat(1)` throws a RangeError about "too large" in node; in Safari it throws an OOM RangeError; in FF it seems to just hang. the spec seems to say it should throw a TypeError (https://tc39.es/ecma262/#sec-array.prototype.concat step 5.b.iii). am i reading it right? if so i can make a test262 test for it.

[15:22:50.0245] <shu>
that's not my reading

[15:23:21.0508] <shu>
OOMs are implementation-defined and can really happen anywhere. the spec says a `TypeError` should be thrown for lengths that exceed that length, even without an implementation-defined OOM error

[15:23:34.0576] <shu>
so Safari is certainly allowed to throw an OOM

[15:23:58.0652] <shu>
as for FF hanging, that's fine too, i think, from a compliance perspective

[15:24:19.0213] <shu>
it might be undesirable to hang, but i don't think that's breaking compliance with the spec

[15:25:12.0997] <shu>
a test262 here test can test that either a TypeError or an OOM RangeError is thrown, i'd think

[15:25:41.0992] <shu>
actually i'm not sure implementation-defined OOM errors are required to be `RangeError`s or can be anything

[15:25:48.0949] <shu>
so maybe the test is just that it must throw _something_

[15:27:55.0264] <shu>
 * OOMs are implementation-defined and can really happen anywhere. the spec says a `TypeError` should be thrown for lengths that exceed that value, even without an implementation-defined OOM error

[15:33:46.0983] <ljharb>
oh the OOM part and the hanging part yes, ofc

[15:34:05.0824] <ljharb>
but chrome/node doesn't throw an OOM - it throws a RangeError with a message. but the spec says it should be a TypeError

[15:34:23.0074] <ljharb>
thinking about it, it should really just be a RangeError anyways. so maybe it'd be a better web reality change to change the spec?

[15:34:40.0960] <shu>
hm, maybe, agreed that it feels like a rangeerror

[15:35:05.0887] <shu>
i feel like OOMs and resource limit-related errors are usually Range, not Type

[15:40:03.0602] <shu>
seems like all the array methods throw `TypeError` for `> 2^53 - 1`

[15:40:36.0787] <shu>
but ljharb, V8/node does throw an OOM

[15:40:53.0551] <ljharb>
hm

[15:40:56.0745] <shu>
it's throwing on trying to create an array with length `> 2^32 - 1`

[15:41:02.0830] <shu>
not throwing on a length `> 2^53 - 1`

[15:41:13.0623] <ljharb>
in node 18 i get `Uncaught RangeError: Invalid array length`

[15:41:16.0734] <shu>
yeah

[15:41:18.0780] <ljharb>
ohhh i see what you mean

[15:41:40.0184] <shu>
it throws before it gets to the check for typeerror

[15:41:54.0472] <ljharb>
`[1].concat({ length: Math.pow(2, 53) - 1, [Symbol.isConcatSpreadable]: true })` indeed does throw a TypeError

[15:41:54.0684] <shu>
or, no, it just doesn't hit that

[15:41:59.0964] <shu>
yeah

[15:42:06.0757] <ljharb>
thanks, that clears it up


2022-05-05
[12:15:05.0406] <bakkot>
TabAtkins: the way you've written https://webidl.spec.whatwg.org/#es-map-iterator implies that `(new Map)[Symbol.iterator]().next.call(webIdlMapLike)` would work, which is... maybe not a thing you intended?

[12:15:28.0329] <bakkot>
I don't know where webidl map-likes are used though

[12:16:25.0165] <TabAtkins>
Hmmmmm, I dunno if that's a problem?

[12:16:31.0586] <TabAtkins>
(For an example usage, see https://tabatkins.github.io/css-toggle/#dom)

[12:18:19.0163] <bakkot>
I think that is... probably not desirable, at least for implementations?

[12:18:31.0726] <TabAtkins>
.next() isn't usable directly on a Map, right? You'd still have to actually extract an iterator, which has .next() from its proto.

[12:19:14.0420] <bakkot>
oh, yeah, so `(new Map)[Symbol.iterator]().next.call(webIdlMapLike[Symbol.iterator]())` 

[12:19:23.0224] <bakkot>
I think you probably do not want to require that that work

[12:19:47.0525] <TabAtkins>
Why not? Making it not work would presumably require us to *not* use MapIteratorPrototype at all, right?

[12:20:11.0481] <bakkot>
oh, I missed that you are intending to use MapIteratorPrototype

[12:20:16.0569] <TabAtkins>
(That was already required before my edits, btw.)

[12:21:01.0917] <TabAtkins>
Yeah we're manually reproducing Map's proto methods by hand, but there's no reason for us to do the same for its iterator.

[12:22:28.0421] <bakkot>
it's conceptually kind of weird? a "real" map iterator uses the [[MapData]] internal slot

[12:23:15.0411] <bakkot>
I don't think it's going to cause problems for users (or even be noticed), but it might trip up implementations

[12:23:48.0185] <bakkot>
when we wrote https://github.com/tc39/ecma262/pull/2045 the thinking was that brands would be single-use

[12:24:17.0083] <TabAtkins>
If that's problematic, the spec shouldn't be written in a way that implies it's pluggable. ^_^

[12:24:41.0416] <bakkot>
the spec is not an API

[12:24:51.0176] <TabAtkins>
what's this about brands?

