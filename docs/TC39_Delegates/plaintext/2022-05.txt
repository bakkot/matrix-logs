2022-05-02
[13:10:48.0779] <shu>
jschoi: does May 6 8:00 - 9:00 PT work for you for the incubator call?

[13:47:17.0269] <jschoi>
> <@shuyuguo:matrix.org> jschoi: does May 6 8:00 - 9:00 PT work for you for the incubator call?

This time works for me, thank you.

[13:47:33.0680] <jschoi>
I will try to have an agenda ready by tomorrow.

[14:42:10.0269] <shu>
excellent, thank you

[15:13:51.0547] <shu>
jschoi: argh, oops, i misread the doodle

[15:14:09.0676] <shu>
i meant May 6 9:00 - 10:00 PT, 1 hour later


2022-05-03
[06:11:35.0580] <jschoi>
> <@shuyuguo:matrix.org> i meant May 6 9:00 - 10:00 PT, 1 hour later

No worries; I can make that too. Thanks for arranging!

[15:14:50.0385] <ljharb>
`Array(Math.pow(2, 32) - 1).concat(1)` throws a RangeError about "too large" in node; in Safari it throws an OOM RangeError; in FF it seems to just hang. the spec seems to say it should throw a TypeError (https://tc39.es/ecma262/#sec-array.prototype.concat step 5.b.iii). am i reading it right? if so i can make a test262 test for it.

[15:22:50.0245] <shu>
that's not my reading

[15:23:21.0508] <shu>
OOMs are implementation-defined and can really happen anywhere. the spec says a `TypeError` should be thrown for lengths that exceed that length, even without an implementation-defined OOM error

[15:23:34.0576] <shu>
so Safari is certainly allowed to throw an OOM

[15:23:58.0652] <shu>
as for FF hanging, that's fine too, i think, from a compliance perspective

[15:24:19.0213] <shu>
it might be undesirable to hang, but i don't think that's breaking compliance with the spec

[15:25:12.0997] <shu>
a test262 here test can test that either a TypeError or an OOM RangeError is thrown, i'd think

[15:25:41.0992] <shu>
actually i'm not sure implementation-defined OOM errors are required to be `RangeError`s or can be anything

[15:25:48.0949] <shu>
so maybe the test is just that it must throw _something_

[15:27:55.0264] <shu>
 * OOMs are implementation-defined and can really happen anywhere. the spec says a `TypeError` should be thrown for lengths that exceed that value, even without an implementation-defined OOM error

[15:33:46.0983] <ljharb>
oh the OOM part and the hanging part yes, ofc

[15:34:05.0824] <ljharb>
but chrome/node doesn't throw an OOM - it throws a RangeError with a message. but the spec says it should be a TypeError

[15:34:23.0074] <ljharb>
thinking about it, it should really just be a RangeError anyways. so maybe it'd be a better web reality change to change the spec?

[15:34:40.0960] <shu>
hm, maybe, agreed that it feels like a rangeerror

[15:35:05.0887] <shu>
i feel like OOMs and resource limit-related errors are usually Range, not Type

[15:40:03.0602] <shu>
seems like all the array methods throw `TypeError` for `> 2^53 - 1`

[15:40:36.0787] <shu>
but ljharb, V8/node does throw an OOM

[15:40:53.0551] <ljharb>
hm

[15:40:56.0745] <shu>
it's throwing on trying to create an array with length `> 2^32 - 1`

[15:41:02.0830] <shu>
not throwing on a length `> 2^53 - 1`

[15:41:13.0623] <ljharb>
in node 18 i get `Uncaught RangeError: Invalid array length`

[15:41:16.0734] <shu>
yeah

[15:41:18.0780] <ljharb>
ohhh i see what you mean

[15:41:40.0184] <shu>
it throws before it gets to the check for typeerror

[15:41:54.0472] <ljharb>
`[1].concat({ length: Math.pow(2, 53) - 1, [Symbol.isConcatSpreadable]: true })` indeed does throw a TypeError

[15:41:54.0684] <shu>
or, no, it just doesn't hit that

[15:41:59.0964] <shu>
yeah

[15:42:06.0757] <ljharb>
thanks, that clears it up


2022-05-05
[12:15:05.0406] <bakkot>
TabAtkins: the way you've written https://webidl.spec.whatwg.org/#es-map-iterator implies that `(new Map)[Symbol.iterator]().next.call(webIdlMapLike)` would work, which is... maybe not a thing you intended?

[12:15:28.0329] <bakkot>
I don't know where webidl map-likes are used though

[12:16:25.0165] <TabAtkins>
Hmmmmm, I dunno if that's a problem?

[12:16:31.0586] <TabAtkins>
(For an example usage, see https://tabatkins.github.io/css-toggle/#dom)

[12:18:19.0163] <bakkot>
I think that is... probably not desirable, at least for implementations?

[12:18:31.0726] <TabAtkins>
.next() isn't usable directly on a Map, right? You'd still have to actually extract an iterator, which has .next() from its proto.

[12:19:14.0420] <bakkot>
oh, yeah, so `(new Map)[Symbol.iterator]().next.call(webIdlMapLike[Symbol.iterator]())` 

[12:19:23.0224] <bakkot>
I think you probably do not want to require that that work

[12:19:47.0525] <TabAtkins>
Why not? Making it not work would presumably require us to *not* use MapIteratorPrototype at all, right?

[12:20:11.0481] <bakkot>
oh, I missed that you are intending to use MapIteratorPrototype

[12:20:16.0569] <TabAtkins>
(That was already required before my edits, btw.)

[12:21:01.0917] <TabAtkins>
Yeah we're manually reproducing Map's proto methods by hand, but there's no reason for us to do the same for its iterator.

[12:22:28.0421] <bakkot>
it's conceptually kind of weird? a "real" map iterator uses the [[MapData]] internal slot

[12:23:15.0411] <bakkot>
I don't think it's going to cause problems for users (or even be noticed), but it might trip up implementations

[12:23:48.0185] <bakkot>
when we wrote https://github.com/tc39/ecma262/pull/2045 the thinking was that brands would be single-use

[12:24:17.0083] <TabAtkins>
If that's problematic, the spec shouldn't be written in a way that implies it's pluggable. ^_^

[12:24:41.0416] <bakkot>
the spec is not an API

[12:24:51.0176] <TabAtkins>
what's this about brands?

[12:25:10.0913] <bakkot>
the string argument to CreateIteratorFromClosure is a brand

[12:25:32.0501] <bakkot>
which is intended to prevent users from using `.next` from one kind of iterator with a different kind of iterator

[12:25:53.0638] <bakkot>
 * which is intended to prevent users from using `.next` from one kind of iterator with a different kind of iterator

[12:26:01.0600] <TabAtkins>
Oh, if that's the issue we can change that.

[12:26:15.0081] <TabAtkins>
It didn't look like something I *needed* to change, is all.

[12:26:34.0426] <bakkot>
if you change it you'll also need a new prototype, though

[12:27:12.0935] <bakkot>
the way it works is, `CreateIteratorFromClosure` specifies a brand, which is stored on the iterator, and then the various `.next` methods check that brand

[12:27:50.0381] <ljharb>
please do not reuse MapIteratorPrototype on something that's not a Map, that's not right

[12:28:31.0292] <bakkot>
so `CreateMapIterator` and `%MapIteratorPrototype%.next ( )` both specify the `"%MapIteratorPrototype%"` brand, which is how we achieve that only the MapIterator `.next` works with map iterators

[12:29:16.0512] <ljharb>
and it would be a bug if that brand check passed on something that wasn't a Map instance

[12:29:46.0362] <bakkot>
ljharb: the brand check is only for Map _iterators_, not Map instances

[12:30:05.0796] <ljharb>
oh right sorry

[12:30:12.0551] <ljharb>
ok, Map iterator instance then :-p

[12:30:25.0351] <ljharb>
(obv that's way less important to brand check)

[12:31:20.0080] <bakkot>
TabAtkins: anyway, if you want to avoid re-implementing stuff, while also not pretending to be an _actual_ Map iterator, I think the simplest thing would be to pretend to be a userland generator - i.e. inherit from `Generator` rather than `MapIterator`, and use `~empty~` as the brand

[12:31:53.0476] <bakkot>
this has the bonus that it would allow implementations to implement the iterator as a JS generator

[12:31:58.0474] <bakkot>
 * this has the bonus that it would allow implementations to implement the iterator as a JS generator

[12:32:20.0775] <TabAtkins>
Hm, that would mean that future things put on MapIteratorPrototype wouldn't apply then, right?

[12:33:07.0294] <bakkot>
well, so

[12:33:46.0599] <bakkot>
as long as MapIteratorPrototype is written as a spec generator, it can't really have more things put on it - the state is all internal to the closure created in CreateMapIterator

[12:34:11.0858] <bakkot>
so if we wanted to add more stuff, we'd have to revert the change from https://github.com/tc39/ecma262/pull/2045 anyway

[12:34:39.0355] <bakkot>
and go back to using specialized slots on the iterator instance to store the state of the iterator

[12:34:48.0567] <bakkot>
which would break this part of webidl anyway

[12:35:32.0962] <ljharb>
why would MapIteratorPrototype ever get something added to it? iterator helpers would be on a superclass, and generator-made iterators would have those too, i think

[12:35:47.0855] <bakkot>
java's iterators have a `remove` method which is occasionally handy, e.g.

[12:35:56.0252] <bakkot>
I don't think we'd want to add it but we conceptually could

[12:36:06.0986] <bakkot>
for iterators for collections in particular, and not for arbitrary generators/iterators

[12:36:18.0452] <TabAtkins>
Right, I was thinking about iterator helpers. But if they'll all show up on something that all userland generators get too, then I suppose my concern is moot.

[12:36:25.0370] <ljharb>
`it.remove()` as a shorthand for "get the key and remove it directly from the collection"?

[12:36:37.0175] <ljharb>
 * `it.remove()` as a shorthand for "get the key and remove it directly from the collection"?

[12:36:43.0750] <bakkot>
yup, iterator helpers add things to the root iterator prototype, which is shared by MapIterator and also the iterators produced by userland generators

[12:37:12.0949] <bakkot>
ljharb: in java it means "remove the last thing yielded"

[12:37:27.0027] <bakkot>
 * yup, iterator helpers add things to the root iterator prototype, which is shared by MapIterator and also the iterators produced by userland generators

[12:37:46.0173] <ljharb>
weird, ok

[12:37:50.0216] <TabAtkins>
def weird

[12:38:06.0725] <bakkot>
TabAtkins: actually wait, forget my suggestion about inheriting from generator, though

[12:38:16.0990] <bakkot>
that would have other consequences which are bad

[12:38:42.0599] <bakkot>
because generators also have `.return` which injects a return completion at the current `yeild`, which is... not a thing you want, almost certainly

[12:40:08.0636] <TabAtkins>
I mean, userland generators have to deal with that too, right? Is there a simple way I can, like, intercept and either ignore it or bail or something?

[12:40:53.0978] <TabAtkins>
(I'm willing to do a lot if it means (a) I don't have to redefine the entire interator infrastructure from ES and (b) iterator helpers will still work.)

[12:41:19.0602] <ljharb>
i think you probably should just make your own iterator thing that inherits from Iterator.prototype (which will make helpers work), just like map/string/set/etc are their own thing

[12:41:19.0867] <bakkot>
userland generators do have to deal with it but the problem is that you have to think about it at all

[12:41:24.0781] <bakkot>
`.return` just doesn't exist on map iterators

[12:41:32.0163] <bakkot>
anyway yeah, I think I would just add a new iterator prototype, like MapIteratorPrototype. that's what the language would do at least.

[12:42:16.0820] <bakkot>
you can copy-paste the whole of the MapIteratorPrototype clause; it's actually quite short now

[12:42:30.0302] <TabAtkins>
yeah, https://tc39.es/ecma262/#sec-%mapiteratorprototype%-object is doable

[12:42:51.0511] <TabAtkins>
okay, sigh, thought i was done with this edit but back into the breach

[12:45:15.0813] <bakkot>
apologies

[12:52:50.0521] <TabAtkins>
So just to be clear, the overriding issue here is that, in practice, the second and third arguments to CreateIteratorFromClosure (giving the brand and prototype) should be unique per call site, more or less?

[13:05:16.0569] <bakkot>
I would put it a different way: if the second and third arguments are _not_ different, you are saying that these two things are actually the same thing, even though they have different behavior, and you should be really sure you want that


2022-05-06
[07:05:43.0364] <jschoi>
The BigInt Math incubator call (https://github.com/tc39/Reflector/issues/433) is happening in two hours. 

I've just added an agenda (https://github.com/tc39/incubator-agendas/blob/main/2022/05-06.md) and am almost done with the slides (https://docs.google.com/presentation/d/1og0dwgl_0kQiOubsdwgI1X0ug0A7EEZYIJ2qv2ZDqVw/edit#slide=id.g1281fa65b8c_1_67). Hope to see as many people as possible there. : )

[10:27:35.0034] <Rob Palmer>
hey delegates, a new in-person plenary attendance survey for July 2022 is awaiting your input here:  https://github.com/tc39/Reflector/issues/434

[10:55:03.0045] <shu>
jschoi: something i didn't comment about during the call

[10:55:32.0297] <shu>
why are you doing `Math.abs` on timestamps? are there no monotonic timestamps available?

[10:55:41.0773] <shu>
both `performance.now()` and `Date.now()` are monotonic afaik

[11:07:12.0330] <ptomato>
happily, `Temporal.Duration` would be good for that use case, and it has an `abs()` method

[11:31:07.0310] <jschoi>
> <@shuyuguo:matrix.org> why are you doing `Math.abs` on timestamps? are there no monotonic timestamps available?

It’s been a while since I touched that code, but I believe that I was actually comparing high-resolution time *intervals* to intervals, rather than time instants to instants per se; intervals may be greater or less than each other. The code in the slides was an oversimplification. 

[11:31:16.0943] <jschoi>
* > <@shuyuguo:matrix.org> why are you doing `Math.abs` on timestamps? are there no monotonic timestamps available?

I believe that I was actually comparing high-resolution time intervals to time intervals; the code in the slides was an oversimplification. 

[11:31:24.0957] <jschoi>
* > <@shuyuguo:matrix.org> why are you doing `Math.abs` on timestamps? are there no monotonic timestamps available?

It’s been a while, but I believe that I was actually comparing high-resolution time intervals to time intervals; the code in the slides was an oversimplification. 

[11:31:47.0478] <jschoi>
Afterward, I was formatting the interval differences for display as a fixed-width plain-text table in a CLI’s console output, with the decimal places aligned. I needed to check for the presence of a minus sign in order to make the minus sign not contribute to the table columns’ text alignment.

[11:32:13.0349] <jschoi>
* I was then formatting them for display as a fixed-width plain-text table in a CLI’s console output.

[11:32:23.0390] <jschoi>
* > <@shuyuguo:matrix.org> why are you doing `Math.abs` on timestamps? are there no monotonic timestamps available?

It’s been a while since I touched that code, but I believe that I was actually comparing high-resolution time intervals to time intervals; the code in the slides was an oversimplification. 

[11:33:12.0366] <jschoi>
* > <@shuyuguo:matrix.org> why are you doing `Math.abs` on timestamps? are there no monotonic timestamps available?

It’s been a while since I touched that code, but I believe that I was actually comparing high-resolution time *intervals* to intervals, rather than time instants to instants per se; the code in the slides was an oversimplification. 

[11:33:40.0832] <jschoi>
* > <@shuyuguo:matrix.org> why are you doing `Math.abs` on timestamps? are there no monotonic timestamps available?

It’s been a while since I touched that code, but I believe that I was actually comparing high-resolution time *intervals* to intervals, rather than time instants to instants per se; intervals may be greater or less than each other. The code in the slides was an oversimplification. 

[11:34:00.0475] <jschoi>
* Afterward, I was formatting the interval differences for display as a fixed-width plain-text table in a CLI’s console output.

[11:34:53.0160] <jschoi>
* Afterward, I was formatting the interval differences for display as a fixed-width plain-text table in a CLI’s console output, with the decimal places aligned. I needed to check for the presence of a minus sign in order to make the minus sign not contribute to the table columns’ text alignment.

[11:35:16.0945] <jschoi>
There was some other BigInt statistical analysis I was doing on those intervals—quartiles, deviations, that sort of thing—which I also was formatting for display in the CLI output’s digit-aligned plain-text table.

[11:35:56.0689] <jschoi>
* There was some other BigInt statistical analysis I was doing on those intervals—quartiles, deviations, that sort of thing—which I also was formatting for display in the CLI output’s digit-aligned plain-text table.

[11:36:24.0464] <shu>
i see, thanks

[11:41:56.0426] <shu>
also what is `clz32` used for?

[11:42:00.0842] <shu>
and why do you want that to work on bigints...?

[11:42:16.0724] <jschoi>
I don’t really. Someone on GitHub mentioned it. I have no concrete use cases. I would be happy to remove it.

[11:42:30.0433] <jschoi>
I think it was about clzN.

[11:42:42.0644] <shu>
yes, bitLength is a different proposal, and seems appropriate for `BigInt`

[11:42:43.0286] <jschoi>
Arbitrary bases. Possibly useful in e.g. binary data compression?…

[11:42:47.0722] <shu>
clz32 does not

[11:42:48.0623] <jschoi>
Yeah.

[11:42:59.0729] <shu>
`bitLength` has uses for like, using bigints as arbitrarily large bit vectors

[11:43:08.0397] <shu>
 * `bitLength` has uses for like, using bigints as arbitrarily large bit vectors

[11:43:47.0771] <jschoi>
Yes. I myself am trying to compress all Unicode character names into a succinct data structure (for Fun), so I have needed bit lengths (and I *need* bit rank and select).

[11:44:24.0417] <jschoi>
But those will come later. Well, the Unicode code space fits in Number safe integers anyway, so I guess rank and select aren’t blocked on BigInt Math…

[11:45:50.0090] <jschoi>
* Yes. I myself am trying to compress all Unicode character names into a succinct lookup data structure (for Fun), so I have needed bit lengths (and I *need* bit rank and select).

[11:46:29.0772] <jschoi>
…Anyways, Shu, I will remove BigInt clz32 and cbrt from this proposal, since WH isn’t blocking on those.

[11:48:23.0559] <jschoi>
* But those will come later. Well, the Unicode code space fits in Number safe integers anyway, so I guess my Unicode name needs don’t need BigInts, so I need Numbers rank/select, not BigInt rank/select…

[11:52:03.0732] <jschoi>
* But those will come later. Well, the Unicode code space fits in Number safe integers anyway, so I guess my Unicode name needs don’t need BigInts, so I Numbers rank/select would work for me, not BigInt rank/select…though BigInt rank/select would certainly make it easier.


2022-05-08
[21:44:08.0148] <Jack Works>
Is it possible to add a Symbol.unthenable and attach it to the module namespace object? 

[13:45:04.0108] <ljharb>
> <@jackworks:matrix.org> Is it possible to add a Symbol.unthenable and attach it to the module namespace object?

technically yes, but that exact proposal was basically rejected in 2018 https://github.com/devsnek/proposal-symbol-thenable

[14:52:10.0585] <Justin Ridgewell>
It sounds like this is the opposite direction. Instead of proactively marking as thenable, you assume thenable and mark as unthenable 


2022-05-09
[19:17:38.0454] <Jack Works>
Unlucky 

[19:17:39.0125] <Jack Works>
What's the reason it being rejected? 

[20:28:08.0557] <devsnek>
it was considered to be adding too much complexity

[20:28:59.0680] <devsnek>
ultimately i think that was a mistake (i still see people run into the dynamic import problem in the wild) but what can ya do 🤷

[20:30:42.0011] <devsnek>
hmm here are the notes https://github.com/tc39/notes/blob/main/meetings/2018-05/may-24.md#symbolthenable-for-stage-1-or-2

[21:04:52.0510] <Mathieu Hofman>
> <@jackworks:matrix.org> Is it possible to add a Symbol.unthenable and attach it to the module namespace object? 

I think unfortunately that ship has definitely sailed. At this point adding such a symbol to the language wouldn't accomplish anything. You can't add such a symbol automatically to all module namespace objects as it'd be Web incompatible. And developers can't add such a symbol themselves (only string identifiers can be exports) before they'd get tripped by a dynamic import.

[00:26:21.0148] <Rob Palmer>
Just some history... the hazard of dynamic import resolving thenables was known ahead of time.  I tried to point it out but it didn't end up going anywhere as it was framed as yet-another-instance of an existing hazard.

https://github.com/tc39/proposal-dynamic-import/issues/48

[11:59:44.0083] <ljharb>
> <@mhofman:matrix.org> I think unfortunately that ship has definitely sailed. At this point adding such a symbol to the language wouldn't accomplish anything. You can't add such a symbol automatically to all module namespace objects as it'd be Web incompatible. And developers can't add such a symbol themselves (only string identifiers can be exports) before they'd get tripped by a dynamic import.

why would it be web incompatible? exports can't provide symbols there, specifically so we CAN add a new symbol to module namespace objects at any time.

[12:00:57.0935] <ljharb>
or do you just mean, making it unthenable would be incompatible

[12:01:00.0266] <Mathieu Hofman>
I meant adding a symbol such as unthenable by default to all module namespace objects. There are modules in the wild that do expect this thenable behavior

[12:01:33.0999] <ljharb>
right, true enough. altho probably not a ton, since having a thenable module is broken in node (i forget if it's broken just in the repl, or just not in the repl)

[12:04:41.0932] <Mathieu Hofman>
It definitely works in the browser, I have personally (ab)used this mechanism

[12:41:42.0955] <Justin Ridgewell>
Ooo boy, did anyone realize we don't actually follow the Promises A+ spec?

[12:42:04.0166] <Justin Ridgewell>
We pass the spec's tests, only because it forgot to test a behavior.

[12:42:39.0474] <Justin Ridgewell>
Step 13-15 of https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-promise-resolve-functions

[12:43:13.0625] <Justin Ridgewell>
We create a new job to handle a thenable passed to `resovle` in `new Promise(res => res(thenable))`

[12:43:19.0495] <Justin Ridgewell>
That's not correct

[12:43:43.0172] <Justin Ridgewell>
https://promisesaplus.com/#point-56

[12:44:16.0037] <Justin Ridgewell>
> If then is a function, call it with x as this, first argument resolvePromise, and second argument rejectPromise, where...

[12:44:26.0925] <Justin Ridgewell>
It makes no mention of a new job for thenables

[12:44:39.0977] <Justin Ridgewell>
 * It makes no mention of a new job for thenables

[12:45:06.0223] <Justin Ridgewell>
This is the root cause of both https://github.com/tc39/ecma262/issues/2770 and https://github.com/tc39/ecma262/issues/1250

[12:47:02.0452] <Justin Ridgewell>
`thenable.then(resolve)` and `resolve(thenable)` are supposed to take the same number of ticks.

[12:48:05.0217] <Justin Ridgewell>
But because `resolve(thenable)` creates a new job for doing the `then.call(prom, onFul, onRej)` and the `then` internally creates a new job before calling `onFul`/`onRej`, we get 2 ticks instead of 1.

[12:48:25.0757] <Justin Ridgewell>
 * But because `resolve(thenable)` creates a new job for doing the `then.call(prom, onFul, onRej)` and the `then` internally creates a new job before calling `onFul`/`onRej`, we get 2 ticks instead of 1.

[13:05:19.0891] <Mathieu Hofman>
It might be tricky to untangle this. `Promise.resolve()` should most likely not call `.then` in the same tick (It's already unfortunate it does a `[[Get]]` of the `constructor` and `then`). Maybe there is a way to not use a new callback job if we're already inside then callback job? I haven't thought this through yet.

[13:10:10.0351] <Justin Ridgewell>
Are you thinking about throws?

[13:11:05.0912] <Justin Ridgewell>
Note that `Promise.resolve` isn't part of A+, so we could diverge and do an tick before invoking the thenable's `then`

[13:11:13.0452] <Mathieu Hofman>
I'm wondering how you could test this though. The `.then` call would always happen when no user code is on the stack. Maybe the test could create a resolved promise and attach a fulfillment handler (as a "next tick" detection) before returning the test thenable, and ensure that the `.then` is called before the "next tick" ?

[13:14:31.0790] <Justin Ridgewell>
It's easy, I think:
```
new Promise(res => {
  let sync = true;
  res({
    then(onFul) {
      onFul(called);
    }
  });
  sync = false;
});
```

[13:15:07.0036] <Mathieu Hofman>
ah right, the constructor calls the resolve step, silly me

[13:16:00.0306] <Justin Ridgewell>
Can you explain why `Promise.resolve(thenable)` shouldn't call `thenable.then` sync?

[13:16:19.0403] <Justin Ridgewell>
 * Can you explain why `Promise.resolve(thenable)` shouldn't call `thenable.then` sync?

[13:18:24.0675] <Mathieu Hofman>
It's just a non-obvious reentrancy hazard. Basically the only way to protect yourself from an evil promise is to do `Promise.resolve(() => thenable)`

[13:18:59.0227] <Justin Ridgewell>
Promise A+ handles reentrancy

[13:19:29.0518] <Mathieu Hofman>
Which means you're always losing a tick when you don't know where a potential thenable is coming from.

[13:19:59.0591] <Mathieu Hofman>
I'm talking about user code trying to protect itself from reentrancy induced by evil promises

[13:19:59.0592] <Justin Ridgewell>
The `onFul` and `onRej` passed to the thenable's `then` are already job deferred callbacks

[13:20:16.0677] <Justin Ridgewell>
They can only be called once

[13:20:42.0411] <Justin Ridgewell>
And if `then` throws, then it'll be caught and `onRej` will be called (if neither `onFul` nor `onRej` have already been called)

[13:21:18.0763] <Mathieu Hofman>
Aye, we're not talking about the same thing.

[13:24:44.0004] <Mathieu Hofman>
calling `fooResult.then()` can cause synchronous reentrancy in your code if you can't trust where `fooResult` comes from. And there is simply no way to brand check for a native promise without causing similar hazard (`Promise.resolve` will trigger `constructor` and `then` get logic)

[13:25:45.0402] <Justin Ridgewell>
Sorry, I'm still not getting it

[13:26:35.0463] <Justin Ridgewell>
If you can't trust `fooResult`, then `Promise.resolve(fooResult)` would give you a trusted promise (and I assume you're already doing this because `fooResult` isn't trusted)

[13:27:01.0842] <Justin Ridgewell>
So we haven't introduced a new tick?

[13:27:02.0966] <bakkot>
I don't think code should be trying to protect itself from reentrancy induced by evil promises

[13:27:10.0275] <bakkot>
except in extremely unusual cases

[13:28:28.0195] <Mathieu Hofman>
`Promise.resolve({ get then() { doSomethingEvil(); return () => {}; } })` will call `doSomethingEvil` synchronously.

[13:28:52.0969] <Mathieu Hofman>
> <@bakkot:matrix.org> I don't think code should be trying to protect itself from reentrancy induced by evil promises

Depends on what kind of code you're working on ;)

[13:29:07.0755] <bakkot>
> except in extremely unusual cases

[13:30:20.0826] <Justin Ridgewell>
Given `get then() { doSomethingEvil() }`, is sync calling `then() { doSomethingEvil() }` something we need to protect against?

[13:32:18.0674] <Mathieu Hofman>
Anyway, we're off topic for Justin's topic. I just wish we had a way to brand check native promises so that something like `brandCheck(p) && Reflect.getPrototypeOf(p) === Promise.prototype && !Reflect.getOwnPropertyDescriptor(p)` would be sufficient to know I can safely call `p.then`

[13:33:12.0047] <Mathieu Hofman>
(given that `Promise.prototype` is frozen of course)

[14:04:10.0499] <ljharb>
yes, it is, because `Promise.resolve({ then: class {} })` shouldn't throw, it should reject

[14:07:39.0330] <Justin Ridgewell>
It would still reject with the correct A+ behavior

[14:07:50.0731] <Justin Ridgewell>
Throws are caught

[15:56:46.0927] <ljharb>
i'd love a stamp on https://github.com/tc39/notes/pull/197 if someone has a sec

[16:07:34.0240] <rbuckton>
Rather than adding a symbol to the module, could we allow a user to add a built-in symbol to a function they export named `then` that would indicate it shouldn't be used for Promise fulfillment? Non-native promises might not understand it, but it would still work for imports. 

