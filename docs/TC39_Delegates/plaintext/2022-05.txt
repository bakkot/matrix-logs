2022-05-02
[13:10:48.0779] <shu>
jschoi: does May 6 8:00 - 9:00 PT work for you for the incubator call?

[13:47:17.0269] <jschoi>
> <@shuyuguo:matrix.org> jschoi: does May 6 8:00 - 9:00 PT work for you for the incubator call?

This time works for me, thank you.

[13:47:33.0680] <jschoi>
I will try to have an agenda ready by tomorrow.

[14:42:10.0269] <shu>
excellent, thank you

[15:13:51.0547] <shu>
jschoi: argh, oops, i misread the doodle

[15:14:09.0676] <shu>
i meant May 6 9:00 - 10:00 PT, 1 hour later


2022-05-03
[06:11:35.0580] <jschoi>
> <@shuyuguo:matrix.org> i meant May 6 9:00 - 10:00 PT, 1 hour later

No worries; I can make that too. Thanks for arranging!

[15:14:50.0385] <ljharb>
`Array(Math.pow(2, 32) - 1).concat(1)` throws a RangeError about "too large" in node; in Safari it throws an OOM RangeError; in FF it seems to just hang. the spec seems to say it should throw a TypeError (https://tc39.es/ecma262/#sec-array.prototype.concat step 5.b.iii). am i reading it right? if so i can make a test262 test for it.

[15:22:50.0245] <shu>
that's not my reading

[15:23:21.0508] <shu>
OOMs are implementation-defined and can really happen anywhere. the spec says a `TypeError` should be thrown for lengths that exceed that length, even without an implementation-defined OOM error

[15:23:34.0576] <shu>
so Safari is certainly allowed to throw an OOM

[15:23:58.0652] <shu>
as for FF hanging, that's fine too, i think, from a compliance perspective

[15:24:19.0213] <shu>
it might be undesirable to hang, but i don't think that's breaking compliance with the spec

[15:25:12.0997] <shu>
a test262 here test can test that either a TypeError or an OOM RangeError is thrown, i'd think

[15:25:41.0992] <shu>
actually i'm not sure implementation-defined OOM errors are required to be `RangeError`s or can be anything

[15:25:48.0949] <shu>
so maybe the test is just that it must throw _something_

[15:27:55.0264] <shu>
 * OOMs are implementation-defined and can really happen anywhere. the spec says a `TypeError` should be thrown for lengths that exceed that value, even without an implementation-defined OOM error

[15:33:46.0983] <ljharb>
oh the OOM part and the hanging part yes, ofc

[15:34:05.0824] <ljharb>
but chrome/node doesn't throw an OOM - it throws a RangeError with a message. but the spec says it should be a TypeError

[15:34:23.0074] <ljharb>
thinking about it, it should really just be a RangeError anyways. so maybe it'd be a better web reality change to change the spec?

[15:34:40.0960] <shu>
hm, maybe, agreed that it feels like a rangeerror

[15:35:05.0887] <shu>
i feel like OOMs and resource limit-related errors are usually Range, not Type

[15:40:03.0602] <shu>
seems like all the array methods throw `TypeError` for `> 2^53 - 1`

[15:40:36.0787] <shu>
but ljharb, V8/node does throw an OOM

[15:40:53.0551] <ljharb>
hm

[15:40:56.0745] <shu>
it's throwing on trying to create an array with length `> 2^32 - 1`

[15:41:02.0830] <shu>
not throwing on a length `> 2^53 - 1`

[15:41:13.0623] <ljharb>
in node 18 i get `Uncaught RangeError: Invalid array length`

[15:41:16.0734] <shu>
yeah

[15:41:18.0780] <ljharb>
ohhh i see what you mean

[15:41:40.0184] <shu>
it throws before it gets to the check for typeerror

[15:41:54.0472] <ljharb>
`[1].concat({ length: Math.pow(2, 53) - 1, [Symbol.isConcatSpreadable]: true })` indeed does throw a TypeError

[15:41:54.0684] <shu>
or, no, it just doesn't hit that

[15:41:59.0964] <shu>
yeah

[15:42:06.0757] <ljharb>
thanks, that clears it up


2022-05-05
[12:15:05.0406] <bakkot>
TabAtkins: the way you've written https://webidl.spec.whatwg.org/#es-map-iterator implies that `(new Map)[Symbol.iterator]().next.call(webIdlMapLike)` would work, which is... maybe not a thing you intended?

[12:15:28.0329] <bakkot>
I don't know where webidl map-likes are used though

[12:16:25.0165] <TabAtkins>
Hmmmmm, I dunno if that's a problem?

[12:16:31.0586] <TabAtkins>
(For an example usage, see https://tabatkins.github.io/css-toggle/#dom)

[12:18:19.0163] <bakkot>
I think that is... probably not desirable, at least for implementations?

[12:18:31.0726] <TabAtkins>
.next() isn't usable directly on a Map, right? You'd still have to actually extract an iterator, which has .next() from its proto.

[12:19:14.0420] <bakkot>
oh, yeah, so `(new Map)[Symbol.iterator]().next.call(webIdlMapLike[Symbol.iterator]())` 

[12:19:23.0224] <bakkot>
I think you probably do not want to require that that work

[12:19:47.0525] <TabAtkins>
Why not? Making it not work would presumably require us to *not* use MapIteratorPrototype at all, right?

[12:20:11.0481] <bakkot>
oh, I missed that you are intending to use MapIteratorPrototype

[12:20:16.0569] <TabAtkins>
(That was already required before my edits, btw.)

[12:21:01.0917] <TabAtkins>
Yeah we're manually reproducing Map's proto methods by hand, but there's no reason for us to do the same for its iterator.

[12:22:28.0421] <bakkot>
it's conceptually kind of weird? a "real" map iterator uses the [[MapData]] internal slot

[12:23:15.0411] <bakkot>
I don't think it's going to cause problems for users (or even be noticed), but it might trip up implementations

[12:23:48.0185] <bakkot>
when we wrote https://github.com/tc39/ecma262/pull/2045 the thinking was that brands would be single-use

[12:24:17.0083] <TabAtkins>
If that's problematic, the spec shouldn't be written in a way that implies it's pluggable. ^_^

[12:24:41.0416] <bakkot>
the spec is not an API

[12:24:51.0176] <TabAtkins>
what's this about brands?

[12:25:10.0913] <bakkot>
the string argument to CreateIteratorFromClosure is a brand

[12:25:32.0501] <bakkot>
which is intended to prevent users from using `.next` from one kind of iterator with a different kind of iterator

[12:25:53.0638] <bakkot>
 * which is intended to prevent users from using `.next` from one kind of iterator with a different kind of iterator

[12:26:01.0600] <TabAtkins>
Oh, if that's the issue we can change that.

[12:26:15.0081] <TabAtkins>
It didn't look like something I *needed* to change, is all.

[12:26:34.0426] <bakkot>
if you change it you'll also need a new prototype, though

[12:27:12.0935] <bakkot>
the way it works is, `CreateIteratorFromClosure` specifies a brand, which is stored on the iterator, and then the various `.next` methods check that brand

[12:27:50.0381] <ljharb>
please do not reuse MapIteratorPrototype on something that's not a Map, that's not right

[12:28:31.0292] <bakkot>
so `CreateMapIterator` and `%MapIteratorPrototype%.next ( )` both specify the `"%MapIteratorPrototype%"` brand, which is how we achieve that only the MapIterator `.next` works with map iterators

[12:29:16.0512] <ljharb>
and it would be a bug if that brand check passed on something that wasn't a Map instance

[12:29:46.0362] <bakkot>
ljharb: the brand check is only for Map _iterators_, not Map instances

[12:30:05.0796] <ljharb>
oh right sorry

[12:30:12.0551] <ljharb>
ok, Map iterator instance then :-p

[12:30:25.0351] <ljharb>
(obv that's way less important to brand check)

[12:31:20.0080] <bakkot>
TabAtkins: anyway, if you want to avoid re-implementing stuff, while also not pretending to be an _actual_ Map iterator, I think the simplest thing would be to pretend to be a userland generator - i.e. inherit from `Generator` rather than `MapIterator`, and use `~empty~` as the brand

[12:31:53.0476] <bakkot>
this has the bonus that it would allow implementations to implement the iterator as a JS generator

[12:31:58.0474] <bakkot>
 * this has the bonus that it would allow implementations to implement the iterator as a JS generator

[12:32:20.0775] <TabAtkins>
Hm, that would mean that future things put on MapIteratorPrototype wouldn't apply then, right?

[12:33:07.0294] <bakkot>
well, so

[12:33:46.0599] <bakkot>
as long as MapIteratorPrototype is written as a spec generator, it can't really have more things put on it - the state is all internal to the closure created in CreateMapIterator

[12:34:11.0858] <bakkot>
so if we wanted to add more stuff, we'd have to revert the change from https://github.com/tc39/ecma262/pull/2045 anyway

[12:34:39.0355] <bakkot>
and go back to using specialized slots on the iterator instance to store the state of the iterator

[12:34:48.0567] <bakkot>
which would break this part of webidl anyway

[12:35:32.0962] <ljharb>
why would MapIteratorPrototype ever get something added to it? iterator helpers would be on a superclass, and generator-made iterators would have those too, i think

[12:35:47.0855] <bakkot>
java's iterators have a `remove` method which is occasionally handy, e.g.

[12:35:56.0252] <bakkot>
I don't think we'd want to add it but we conceptually could

[12:36:06.0986] <bakkot>
for iterators for collections in particular, and not for arbitrary generators/iterators

[12:36:18.0452] <TabAtkins>
Right, I was thinking about iterator helpers. But if they'll all show up on something that all userland generators get too, then I suppose my concern is moot.

[12:36:25.0370] <ljharb>
`it.remove()` as a shorthand for "get the key and remove it directly from the collection"?

[12:36:37.0175] <ljharb>
 * `it.remove()` as a shorthand for "get the key and remove it directly from the collection"?

[12:36:43.0750] <bakkot>
yup, iterator helpers add things to the root iterator prototype, which is shared by MapIterator and also the iterators produced by userland generators

[12:37:12.0949] <bakkot>
ljharb: in java it means "remove the last thing yielded"

[12:37:27.0027] <bakkot>
 * yup, iterator helpers add things to the root iterator prototype, which is shared by MapIterator and also the iterators produced by userland generators

[12:37:46.0173] <ljharb>
weird, ok

[12:37:50.0216] <TabAtkins>
def weird

[12:38:06.0725] <bakkot>
TabAtkins: actually wait, forget my suggestion about inheriting from generator, though

[12:38:16.0990] <bakkot>
that would have other consequences which are bad

[12:38:42.0599] <bakkot>
because generators also have `.return` which injects a return completion at the current `yeild`, which is... not a thing you want, almost certainly

[12:40:08.0636] <TabAtkins>
I mean, userland generators have to deal with that too, right? Is there a simple way I can, like, intercept and either ignore it or bail or something?

[12:40:53.0978] <TabAtkins>
(I'm willing to do a lot if it means (a) I don't have to redefine the entire interator infrastructure from ES and (b) iterator helpers will still work.)

[12:41:19.0602] <ljharb>
i think you probably should just make your own iterator thing that inherits from Iterator.prototype (which will make helpers work), just like map/string/set/etc are their own thing

[12:41:19.0867] <bakkot>
userland generators do have to deal with it but the problem is that you have to think about it at all

[12:41:24.0781] <bakkot>
`.return` just doesn't exist on map iterators

[12:41:32.0163] <bakkot>
anyway yeah, I think I would just add a new iterator prototype, like MapIteratorPrototype. that's what the language would do at least.

[12:42:16.0820] <bakkot>
you can copy-paste the whole of the MapIteratorPrototype clause; it's actually quite short now

[12:42:30.0302] <TabAtkins>
yeah, https://tc39.es/ecma262/#sec-%mapiteratorprototype%-object is doable

[12:42:51.0511] <TabAtkins>
okay, sigh, thought i was done with this edit but back into the breach

[12:45:15.0813] <bakkot>
apologies

[12:52:50.0521] <TabAtkins>
So just to be clear, the overriding issue here is that, in practice, the second and third arguments to CreateIteratorFromClosure (giving the brand and prototype) should be unique per call site, more or less?

[13:05:16.0569] <bakkot>
I would put it a different way: if the second and third arguments are _not_ different, you are saying that these two things are actually the same thing, even though they have different behavior, and you should be really sure you want that


2022-05-06
[07:05:43.0364] <jschoi>
The BigInt Math incubator call (https://github.com/tc39/Reflector/issues/433) is happening in two hours. 

I've just added an agenda (https://github.com/tc39/incubator-agendas/blob/main/2022/05-06.md) and am almost done with the slides (https://docs.google.com/presentation/d/1og0dwgl_0kQiOubsdwgI1X0ug0A7EEZYIJ2qv2ZDqVw/edit#slide=id.g1281fa65b8c_1_67). Hope to see as many people as possible there. : )

[10:27:35.0034] <Rob Palmer>
hey delegates, a new in-person plenary attendance survey for July 2022 is awaiting your input here:  https://github.com/tc39/Reflector/issues/434

[10:55:03.0045] <shu>
jschoi: something i didn't comment about during the call

[10:55:32.0297] <shu>
why are you doing `Math.abs` on timestamps? are there no monotonic timestamps available?

[10:55:41.0773] <shu>
both `performance.now()` and `Date.now()` are monotonic afaik

