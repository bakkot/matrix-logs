2024-12-02
[06:59:39.0008] <ryzokuken üá∑üá∏>
Draft Schedule is up on the Reflector: https://github.com/tc39/Reflector/issues/545

[08:58:29.0533] <Rob Palmer>
The meeting begins in 1 minute!!!

[09:00:49.0545] <Michael Ficarra>
FYI we still don't have a TCQ link

[09:03:23.0929] <nicolo-ribaudo>
If Google meet is stuck on "Getting ready... You'll be able to join in just a moment", is it a problem on my side?

[09:03:27.0659] <ljharb>
https://tcq.app/meeting/RKti

[09:03:39.0836] <ljharb>
probably, there's a bunch of us in it

[09:04:10.0051] <nicolo-ribaudo>
Ok thanks, time to restart everything

[09:12:48.0157] <nicolo-ribaudo>
Chairs, last minute change. It seems like I will be the one presenting the TG4 status report

[09:40:01.0142] <littledan>
I like Samina‚Äôs idea to have a liaison from TC39 to IETF, analogous to our close relationship with W3C and Unicode. Is anyone interested in playing this role?

[09:45:32.0045] <saminahusain>
In the past, I think 2021, Mathew Miller was the liaison contact from  tc39

[09:49:54.0455] <bakkot>
sorry, I forgot to add to the agenda constraints that I'm not available the first hour today

[09:50:19.0099] <bakkot>
hope we can get to my iterator closing topic after that

[09:54:17.0645] <nicolo-ribaudo>
Did Chris change which diff he's showing?

[09:54:46.0548] <Michael Ficarra>
yes

[09:57:35.0768] <Michael Ficarra>
whoever is doing notes right now, please refer to https://github.com/tc39/notes/blob/main/delegates.txt for abbreviations, don't just make something up

[10:15:32.0849] <Michael Ficarra>
@eemeli:mozilla.org please add a link to the slides in the notes

[10:22:30.0844] <nicolo-ribaudo>
I always assumed the motivation on this proposal was about ergonomics and not really about performance

[10:22:37.0172] <nicolo-ribaudo>
 * I always assumed the motivation for this proposal was about ergonomics and not really about performance

[10:27:36.0120] <eemeli>
> <@michaelficarra:matrix.org> @eemeli:mozilla.org please add a link to the slides in the notes

There were no slides. The presented material was the readme of the proposal repo.

[10:28:26.0775] <eemeli>
https://github.com/eemeli/proposal-intl-currency-display-choices

[10:29:51.0544] <rbuckton>
We don't throw when you mutate a Map while iterating. I'd almost rather `getOrInsertComputed` just overwrites the key, whether it was set or deleted during the callback. If you want full locking, you can implement it yourself?

[10:30:10.0744] <shu>
rbuckton: that IS my understanding of the non-throwing approach

[10:30:11.0704] <shu>
is it not?

[10:31:41.0742] <bakkot>
the four options:

```
// common prefix
if (map.has(key)) return key;
let value = callback(key);

// option 1
if (map.has(key)) throw;

// option 2
map.set(key, value);
return value;

// option 3 (not proposed)
if (map.has(key)) return map.get(key);
map.set(key, value);
return value;

// option 4 (not proposed): change `Map.prototype.set` to check if we're currently in a `getOrInsertComputed` for this map
```

sounds like people 

[10:31:55.0553] <bakkot>
 * the four options:

```
// common prefix
if (map.has(key)) return key;
let value = callback(key);

// option 1
if (map.has(key)) throw;

// option 2
map.set(key, value);
return value;

// option 3 (not proposed)
if (map.has(key)) return map.get(key);
map.set(key, value);
return value;

// option 4 (not proposed): change `Map.prototype.set` to check if we're currently in a `getOrInsertComputed` for this map
```

sounds like people like option 2 (which I'm also happy with)

[10:32:05.0426] <nicolo-ribaudo>
I dislike these names but I have no constructive suggestion

[10:32:49.0647] <rbuckton>
I personally prefer `getOrAdd`/`getOrCreate`, but I've been too busy over the last few weeks to comment on the issue :/

[10:33:02.0763] <ljharb>
bakkot: option 3 would basically be "actual upsert"?

[10:33:16.0343] <ljharb>
 * bakkot: option 3 would basically be "actual upsert"? or is that something else

[10:33:25.0049] <bakkot>
no

[10:33:36.0429] <bakkot>
we're accounting for mutation during the callback

[10:33:40.0165] <bakkot>
not passing new values to the callback

[10:33:53.0660] <ljharb>
ah k

[10:35:14.0071] <bakkot>
 * the four options:

```
// common prefix
if (map.has(key)) return key;
let value = callback(key);

// option 1
if (map.has(key)) throw;
map.set(key, value);
return value;

// option 2
map.set(key, value);
return value;

// option 3 (not proposed)
if (map.has(key)) return map.get(key);
map.set(key, value);
return value;

// option 4 (not proposed): change `Map.prototype.set` to check if we're currently in a `getOrInsertComputed` for this map
```

sounds like people like option 2 (which I'm also happy with)

[10:35:43.0363] <rbuckton>
Regarding the naming, neither of these methods are actually an "upsert", which normally consists of either "updating an existing value" or "inserting a new value", hence the portmanteau of "update" and "insert". 

[10:45:12.0149] <Mikhail Barash>
University of Bergen's students have written a tutorial on `upsert` proposal prototype implementations in SpiderMonkey and V8. The current preliminary (rough) draft is available here: https://github.com/bldl/emplace-spidermonkey . It currently lacks the description of the implementation in V8; this will be added soon. 

[10:47:30.0897] <ljharb>
https://github.com/tc39/proposal-is-error/issues/7

[10:47:52.0013] <bakkot>
chairs: can you make sure my "iterator helpers close receiver on argument validation failure (10m, Kevin Gibbons)" topic doesn't get lost? currently it's up above the other items on the agenda

[10:48:07.0265] <bakkot>
 * chairs: can you make sure my "iterator helpers close receiver on argument validation failure (10m, Kevin Gibbons)" topic doesn't get lost? currently it's up with the already-presented items on the agenda

[11:00:04.0429] <Aki>
ljharb: reminder to record your summary/conclusion

[11:00:27.0138] <Aki>
bakkot: see üëÜüèª

[11:01:24.0594] <nicolo-ribaudo>
You can get an AsyncContext candy

[11:58:43.0486] <Rob Palmer>
Plenary resumes in one minute!

[12:08:42.0184] <nicolo-ribaudo>
Can we get the transcriptioner to disable automatic-newline?

[12:09:03.0388] <ryzokuken üá∑üá∏>
how bad is it? should I file a POO?

[12:09:16.0131] <nicolo-ribaudo>
It's just annoying

[12:09:27.0092] <nicolo-ribaudo>
Because if I add a newline anywhere then the line is too short and looks  bad

[12:09:28.0109] <ljharb>
(also more than one space after a period)

[12:20:14.0479] <nicolo-ribaudo>
This note taker is very good

[12:20:19.0831] <nicolo-ribaudo>
They are even adding parentheses in function calls

[12:43:13.0211] <nicolo-ribaudo>
The results of the temp check are "we should flip a coin"

[12:45:34.0586] <bakkot>
I can't speak but note:

[12:45:40.0228] <rbuckton>
My concern is that reuse promotes weird corner cases

[12:45:48.0242] <bakkot>
htis means can't implement concat with a generator

[12:45:58.0944] <rbuckton>
i.e., accessors, proxies, etc.

[12:45:58.0948] <bakkot>
 * this means you can't implement concat with a generator

[12:46:05.0578] <shu>
yeah i'm confused by the flipped polarity

[12:46:17.0927] <shu>
why are agoric folks okay with concat doing reuse?

[12:46:23.0975] <nicolo-ribaudo>
> <@bakkot:matrix.org> this means you can't implement concat with a generator

```js
function* concat(...iterators) {
  for (const it of iterators) yield* it;
}
```

[12:46:29.0253] <nicolo-ribaudo>
Since yield re-uses

[12:46:34.0907] <nicolo-ribaudo>
 * Since yield* re-uses

[12:46:38.0161] <bakkot>
ah, true

[12:46:41.0877] <shu>
oh i see

[12:46:54.0865] <bakkot>
ok then i am indifferent

[12:46:55.0483] <rbuckton>
> <@bakkot:matrix.org> this means you can't implement concat with a generator

If we don't reuse, we can use a generator but not `yield*`

[12:47:07.0329] <bakkot>
though `return` is trickier

[12:47:19.0302] <bakkot>
 * though `return` is a little trickier

[12:47:25.0454] <rbuckton>
```js
function* concat(...iterators) {
  for (const it of iterators) 
    for (const el of it)
      yield el;
}
```

[13:00:07.0739] <Michael Ficarra>
> <@nicolo-ribaudo:matrix.org> Since yield* re-uses

(except in JSC and LibJS)

[13:02:04.0143] <Chris de Almeida>
https://github.com/tc39/proposal-shadowrealm/issues/393

[13:17:57.0274] <nicolo-ribaudo>
waldemar There is also random which is technically I. I guess the actual principle is "web APIs don't expose I/O other than what is already exposed by ECMAScript itself"

[13:28:53.0762] <shu>
brother i don't know of any API that doesn't allocate memory

[13:30:45.0063] <Richard Gibson>
> <@shuyuguo:matrix.org> brother i don't know of any API that doesn't allocate memory

`destroy()`

[13:31:04.0838] <shu>
where do you think the stack space needed to push the frames to make the call comes from?

[13:31:19.0205] <Richard Gibson>
lol

[13:33:04.0049] <Chris de Almeida>
should we consider elaborating on stage 3 acceptance criteria re: tests being merged?

[13:33:24.0809] <shu>
Chris de Almeida: i honestly thought that was already the case

[13:33:32.0091] <Chris de Almeida>
it's hand-wavy

[13:33:34.0948] <shu>
like what's the point of having tests that are floating out there but not merged

[13:33:36.0814] <Chris de Almeida>
> The feature has sufficient testing and appropriate pre-implementation experience

[13:34:02.0203] <shu>
sorry, i meant i thought it was the case that being merged is a necessary condition for being considered "sufficient testing"

[13:34:09.0927] <shu>
not just that some tests were written, somewhere

[13:34:42.0361] <Chris de Almeida>
I understand; the question is, would it help to make the text more explicit?

[13:34:53.0875] <ljharb>
i think we've generally considered merging a requirement

[13:35:18.0184] <ljharb>
but we also don't usually block advancements on procedural things that are unambiguous - we usually grant conditional advancement pending that thing

[13:35:31.0932] <ljharb>
 * but we also don't usually block advancements on procedural things whose completion is unambiguous - we usually grant conditional advancement pending that thing

[13:36:13.0063] <ljharb>
 * but we also don't usually block advancements on procedural things whose completion is unambiguous - we usually grant conditional advancement pending that thing (a PR review, a PR merge, etc)

[13:36:23.0887] <ljharb>
 * but we also don't usually block advancements on procedural things whose completion is unambiguous - we usually grant conditional advancement pending that thing (a PR review, a PR merge, resolving an open question between known stakeholders, etc)

[13:40:11.0670] <Chris de Almeida>
generally speaking, is the status quo that tests have been merged before asking for stage 3?  

[13:40:21.0522] <ljharb>
for non-large proposals, yes.

[13:40:47.0907] <ljharb>
 * for non-large proposals, yes, i believe so

[13:42:19.0749] <shu>
i think how much leniency we give definitely will vary case-by-case. in the particular case of ShadowRealms, it got to stage 3 the first time on that promise that the integration work will be done, and the ball got dropped

[13:52:46.0154] <bakkot>
ptomato I am happy to open an issue about crypto.subtle somewhere if you'd like. is the shadowrealm proposal the right place for that kind of bikeshedding issue? also if you want to just look at it without bothering with an issue that's fine

[14:10:48.0879] <ptomato>
> <@bakkot:matrix.org> ptomato I am happy to open an issue about crypto.subtle somewhere if you'd like. is the shadowrealm proposal the right place for that kind of bikeshedding issue? also if you want to just look at it without bothering with an issue that's fine

thanks! in proposal-shadowrealm is fine, but if you don't want to bother with an issue that's also fine; I've got it on my todo list

[14:13:39.0271] <bakkot>
dminor: mozilla doesn't usually bother with standards-positions on TC39 proposals, yeah? https://github.com/mozilla/standards-positions/issues/1133

[15:04:41.0795] <Michael Ficarra>
> <@shuyuguo:matrix.org> sorry, i meant i thought it was the case that being merged is a necessary condition for being considered "sufficient testing"

IMO, the (significantly) more important bit is just that someone has done the elaboration of all of the edge cases and confirmed that we are indeed specifying the thing we want to specify

[15:07:04.0845] <Michael Ficarra>
and if someone has reviewed and said "yes, these look both correct and exhaustive to me", then it has met that criterion

[15:15:18.0680] <shu>
i'm hoping the delta between that last bit, where someone has reviewed and +1'd it, and merging it into a test suite, is trivial

[15:15:26.0712] <shu>
if it isn't then we should rework the test suite workflow

[15:29:07.0450] <Michael Ficarra>
well atm the test262 maintainers group holds those keys and they may have additional criteria that they need to review for before it gets merged

[15:37:22.0207] <dminor>
> <@bakkot:matrix.org> dminor: mozilla doesn't usually bother with standards-positions on TC39 proposals, yeah? https://github.com/mozilla/standards-positions/issues/1133

Correct, we don't normally do this


2024-12-03
[08:53:42.0611] <littledan>
Should we do this for ShadowRealms though?

[09:12:50.0865] <dminor>
https://github.com/mozilla/standards-positions/issues/997

[09:22:07.0676] <shu>
i thought porffor was an engine, it's a runtime as well?

[09:22:50.0650] <ljharb>
what's the difference between those two to you?

[09:23:10.0690] <ljharb>
 * what's the difference between those two, to you?

[09:23:13.0195] <shu>
the difference between Node and V8

[09:23:34.0587] <ljharb>
d8 is a runtime tho, no?

[09:23:42.0164] <shu>
hahahahaha

[09:23:42.0715] <shu>
no

[09:24:04.0644] <snek>
you could call d8 a test262 runtime

[09:24:05.0865] <littledan>
I think porffor is working on developing into a runtime, yes

[09:24:12.0849] <littledan>
canadahonk: ^

[09:24:27.0078] <ljharb>
so what's the concrete rubric that node passes but d8 doesn't?

[09:24:38.0435] <ljharb>
(genuinely asking, tbc)

[09:24:39.0220] <littledan>
the intentions of the maintainers?

[09:24:54.0260] <shu>
at the very least, a desire and goal to actually support workloads beyond "the bare minimum needed to run tests"

[09:24:54.0787] <ljharb>
i mean if that's all it is then that's simple enough

[09:25:20.0864] <littledan>
in particular, TC55 is for server-type environments, which Node is intended to be, and d8 isn't

[09:25:33.0406] <shu>
like there is little rhyme or reason for "features" that exist in d8, how they work, beyond "whatever's bare minimum needed to run our tests and the test262 harness"

[09:25:38.0245] <ljharb>
porffor tho makes standalone executables, so is that not a runtime?

[09:25:59.0386] <shu>
no, IMO it needs a set of APIs and intention as dan says

[09:26:05.0076] <shu>
otherwise every engine is also a runtime

[09:26:06.0922] <shu>
and obviously we're not

[09:26:07.0545] <Chris de Almeida>
porffor famously does not ship a runtime

[09:26:22.0446] <snek>
unless you reference `globalThis`

[09:26:33.0663] <littledan>
yeah porffor isn't ready yet; this is about goals

[09:26:34.0342] <Rob Palmer>
Technically Porffor refers to itself as a compiler, rather than an engine.  And the resulting programs are more useful than base ecma262 allows, e.g.  io.

https://porffor.dev/

[09:26:47.0622] <canadahonk>
oh no I regret not joining the call now

[09:27:11.0901] <littledan>
please come to the GA and vote in favor of chartering TC55, everyone!

[09:27:16.0186] <nicolo-ribaudo>
The definition of "runtime" is "whatever people consider to be a runtime"

[09:27:26.0939] <Rob Palmer>
Don't worry canadahonk , it was barely mentioned in plenary.

[09:27:28.0314] <canadahonk>
currently I would call it a compiler and engine

[09:27:43.0318] <canadahonk>
it is as much a runtime as d8 currently

[09:27:54.0958] <Rob Palmer>
(the conversation here in the matrix is the main part)

[09:28:23.0943] <ljharb>
ok thanks, that clarifies the meanings for me

[09:28:34.0940] <ljharb>
(and "runtime" clearly has a very hand-wavy one)

[09:29:35.0545] <canadahonk>
(long-term yeah I'd like it to be more like node in terms of api/io capability but that is far away for now)

[09:30:03.0506] <canadahonk>
 * (long-term yeah I'd like it to be more like node in terms of api/io capability but that is far away for now. there a few apis providing i/o but they are largely proof-of-concept rather than nice for now)

[09:31:51.0915] <canadahonk>
on this point yeah, it will not include anything engine or runtime unless you use it. eg, if you have no usage of `Map`, in the binary there will be 0 checks for if the type as you know it wasn't used at compile-time

[09:31:57.0851] <Michael Ficarra>
@canadahonk:matrix.org you gonna just implement the wasi APIs?

[09:32:35.0268] <canadahonk>
I'd like to have node(/deno/etc)-like wrappers to make them nicer ideally

[09:32:56.0063] <canadahonk>
 * I'd like to have node(/deno/etc)-like wrappers to make them nicer ideally (also to provide stability with my own API since WASI isn't)

[09:32:56.0743] <littledan>
It will be great to have people working on the correspondence between these things!

[09:34:14.0559] <Michael Ficarra>
personally, I would rather the engine just provide the wasi primitives and then I can pull in a library that adapts them to the high-level node/deno/whatever APIs

[09:34:38.0718] <canadahonk>
fair enough that makes sense to me too, we'll see :)

[09:36:24.0821] <canadahonk>
also fun fact, even worst case using `globalThis`, so including 100% of engine, the output Wasm is still only <500kb ;)

[09:37:13.0206] <canadahonk>
 * also fun fact, even worst case using `globalThis`, so including 100% of engine, the output Wasm is still only \<500kb and native \<300kb ;)

[09:39:28.0718] <bakkot>
that reminds me I need to pester the wasi people about https://github.com/WebAssembly/wasi-clocks/pull/71 again

[09:39:52.0755] <bakkot>
wasi v2 seems promising but there's still a bunch of warts and it doesn't seem to be moving as fast as I'd hoped

[09:49:13.0070] <Rob Palmer>
I did not realize that return-override stamping objects with private fields degrades their performance.

[09:50:11.0646] <littledan>
Note that the current semantics of private fields was heavily based on Mark's strongly stated goal of private fields being consistently analogous to WeakMaps in semantics.

[09:53:30.0430] <bakkot>
all of these things mark is proposing are things where, it would be nice if the language worked like this, but I am not convinced adding a new and less convenient kind of object with the new semantics is worth doing

[09:59:59.0468] <keith_miller>
Did anyone else's audio fall out?

[10:00:16.0333] <ljharb>
i mean i'd definitely make every object i ever produce non-trapping, because i don't want people to use proxy :-p

[10:16:49.0670] <shu>
bakkot: what are your thoughts on changing non-extensible to include no-private-field-stamping? is that an extra bit of complexity in your view?

[10:17:47.0409] <ljharb>
that would mean sealed and frozen also have that trait, which seems a lot more likely to cause issues

[10:17:53.0916] <shu>
that's correct

[10:18:05.0761] <shu>
right, it's all contingent on being web compat

[10:18:11.0619] <shu>
i don't know of people who are actually doing that

[10:18:18.0983] <ljharb>
private field stamping?

[10:18:26.0388] <shu>
on non-extensibles?

[10:18:37.0765] <ljharb>
oh true, that's a subset of a subset if anything

[10:18:44.0544] <shu>
right

[10:18:56.0076] <ljharb>
but like, if that's low enough that it's web compat, what about return override from `class` constructors itself?

[10:19:12.0157] <shu>
i'm open to that but i think that _does_ break stuff

[10:19:16.0975] <shu>
with people subclassing html elements or some crap

[10:19:50.0792] <ljharb>
gotcha

[10:20:17.0069] <ljharb>
yeah custom elements seems to need a lot of really weird userland code :-/

[10:21:17.0793] <Ashley Claymore>
> <@robpalme:matrix.org> I did not realize that return-override stamping objects with private fields degrades their performance.

My understand is that it's another shape change (in v8 at least) as it's adding a hidden symbol prop. I had assumed it the same perf hit as adding a public symbol. Maybe that's not the case

[10:21:35.0367] <Ashley Claymore>
> <@robpalme:matrix.org> I did not realize that return-override stamping objects with private fields degrades their performance.

 * My understand is that it's another shape change (in v8 at least) as it's adding a hidden symbol prop. I had assumed it is the same perf hit as adding a public symbol. Maybe that's not the case

[10:22:12.0703] <shu>
yeah i don't think it's any worse than adding any other property

[10:23:31.0097] <bakkot>
> <@shuyuguo:matrix.org> bakkot: what are your thoughts on changing non-extensible to include no-private-field-stamping? is that an extra bit of complexity in your view?

I think the whole private-field-stamping thing is something we should simply not tell developers about, so changing how it works does not particularly add complexity

[10:23:38.0055] <bakkot>
so I'm fine with that

[10:24:36.0590] <Ashley Claymore>
I have been wondering if we could have a way to disable proxy hooks, and if that would allow proxies to get a stable shape for ICs.
like
const [proxy, disableTraps] = Proxy.temporary(target, handler);
...
disableTraps();

[10:24:56.0435] <Mathieu Hofman>
I am really worried that people out there, possibly in libraries, did build WeakMap equivalent widgets that use the return override private field stamping trick, and that it would break if we unilaterally prevented return overrides proxy stamping. It's possible that non extensible objects are currently rare enough that they wouldn't break any deployed code. 

[10:25:57.0890] <bakkot>
> <@aclaymore:matrix.org> I have been wondering if we could have a way to disable proxy hooks, and if that would allow proxies to get a stable shape for ICs.
> like
> const [proxy, disableTraps] = Proxy.temporary(target, handler);
> ...
> disableTraps();

I would prefer we just tell people to stop using proxies ever, instead of adding new methods which try to make them a little bit more performant

[10:27:03.0534] <Jack Works>
> <@aclaymore:matrix.org> I have been wondering if we could have a way to disable proxy hooks, and if that would allow proxies to get a stable shape for ICs.
> like
> const [proxy, disableTraps] = Proxy.temporary(target, handler);
> ...
> disableTraps();

you can remove proxy traps after the creation.

```js
const trap = { ... }
const proxy = new Proxy(obj, trap)
// after some time
delete trap.get
```

[10:27:32.0583] <ljharb>
yeah that live binding behavior is bonkers to me

[10:27:48.0515] <ljharb>
i wonder if it'd be web compatible to eagerly cache the traps at proxy creation time

[10:28:45.0915] <Mathieu Hofman>
Proxies are an integral part of being able to construct transparent membranes.

[10:29:13.0143] <ljharb>
sure but that's a thing that likely only double digits of humans on the planet ever need to think about

[10:29:17.0075] <Ashley Claymore>
Yeah. But engines wouldn't know that the trap isn't going to be added back. Even if it has prevent extensions the handler itself could be a proxy with a get trap üôÅ

[10:29:43.0813] <ljharb>
 * sure but that's a thing that likely only double digits of humans on the planet ever need to think about (not that we'd remove proxies, just tell the majority not to use them)

[10:29:46.0436] <bakkot>
> <@mhofman:matrix.org> Proxies are an integral part of being able to construct transparent membranes.

I am aware of that and nevertheless strongly stand by my position.

[10:30:04.0564] <Mathieu Hofman>
Guilty of making the handler a proxy. However the engine does know if the handler is a proxy and could opt out of optimizations in that case

[10:30:39.0092] <Jack Works>
> <@ljharb:matrix.org> sure but that's a thing that likely only double digits of humans on the planet ever need to think about

I use proxy to trap `[[Get]]` to provide object that every property is defined and functional based on their name

[10:31:26.0771] <Ashley Claymore>
yeah. Maybe the spec already allows engines to optimize for the case I'm interested in. But that doesn't mean it's worth implementing, and even having a dedicated API for it doesn't mean that it has to be implemented in a way that adds a performance win 

[10:31:37.0388] <ljharb>
i'd be curious to see it, but i still don't think there's even 100 people on the planet that need to be using proxy directly

[10:31:38.0516] <Jack Works>
> <@jackworks:matrix.org> I use proxy to trap `[[Get]]` to provide object that every property is defined and functional based on their name

in a library called async-call-rpc to provide good DX

[10:32:13.0240] <ljharb>
ah, i have‚Ä¶ feelings ‚Ä¶ about RPC and SOAP and whatnot so i probably wouldn't be able to be objective :-)

[10:32:47.0499] <bakkot>
you can definitely do a lot of cool stuff with proxies, don't get me wrong

[10:32:48.0130] <Ashley Claymore>
Immer is quite popular? Thought maybe that doesn't fall under "using proxies directly"

[10:32:52.0796] <Jack Works>
also immer.js uses proxy too üòá

[10:35:18.0380] <Mathieu Hofman>
Yeah I have a half dozen use cases of Proxy that are not part of a membrane. I still find Proxy very useful, but we just need a way to be able to better reason about their hooks.

[10:48:04.0966] <ljharb>
right but that's just 1 maintainer, the users don't count because they don't know about proxy :-)

[10:49:25.0500] <bakkot>
nicolo-ribaudo I found this presentation very helpful!

[10:49:34.0413] <bakkot>
I have not been following all the various things and it was good to catch up

[10:50:16.0144] <nicolo-ribaudo>
Ok thank you! :)

[11:58:22.0876] <Rob Palmer>
We resume plenary in 1 minute!!!

[12:15:12.0513] <bakkot>
nicolo-ribaudo: question about the upcoming `import.defer` topic. how does the "hiding `then`" solution work given the "`'unknown' in ns` triggers evaluation" resolution from earlier in the slides?

[12:17:09.0862] <nicolo-ribaudo>
> <@bakkot:matrix.org> nicolo-ribaudo: question about the upcoming `import.defer` topic. how does the "hiding `then`" solution work given the "`'unknown' in ns` triggers evaluation" resolution from earlier in the slides?

`'then'` would actually be handled like symbols and _not_ trigger in that case. The idea is that wether something triggers or not depends only on the key you are checking, and not wether or not that key is exposed by the module

[12:17:27.0449] <nicolo-ribaudo>
> <@bakkot:matrix.org> nicolo-ribaudo: question about the upcoming `import.defer` topic. how does the "hiding `then`" solution work given the "`'unknown' in ns` triggers evaluation" resolution from earlier in the slides?

 * `'then'` would actually be handled like symbols and _not_ trigger in that case (same as `ns[Symbol.toStringTag]` does not trigger). The idea is that wether something triggers or not depends only on the key you are checking, and not wether or not that key is exposed by the module

[12:17:42.0065] <bakkot>
ah, ok, so it's special-cased in the evaluation logic, not just the namespace object MOP

[12:17:43.0394] <bakkot>
cool

[12:17:53.0656] <nicolo-ribaudo>
Yes

[12:18:27.0221] <nicolo-ribaudo>
Well, mechanically it's special cased in the MOP, as it's the various methods that decide when to evaluate based

[12:18:30.0511] <nicolo-ribaudo>
But yes

[12:18:57.0391] <nicolo-ribaudo>
 * Well, mechanically it's special cased in the MOP, as it's the various methods that decide when to evaluate based on the key you pass them

[12:20:13.0451] <bakkot>
ah, sure

[12:20:30.0002] <bakkot>
I do like the "hiding `then`" solution best of the considered options

[12:27:59.0767] <snek>
how is this different from subarray if the source is immutable?

[12:28:42.0192] <bakkot>
subarray on TAs gives you access to the full underlying buffer

[12:29:18.0987] <bakkot>
(and there is no subarray on ArrayBuffer)

[12:31:28.0750] <snek>
ok

[13:00:44.0821] <bakkot>
I may not be able to speak for my topic; if I'm not responding someone please read the following: "I like having a way to check if a deferred NS object is evaluated yet, but really don't like having a new well-known symbol like `Symbol.evaluated` for this. I'd be happier with a new global function, or a new DeferredModuleNamespace class with a static "isEvaluated" method or something. also we could add this capability in a followup; doesn't need to be included immediately if we're not sure it's worth doing."

