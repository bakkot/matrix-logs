2024-10-01
[17:49:40.0899] <Mathieu Hofman>
I really hope over time the spec is allowed to change the number of ticks some things take. I believe we did so for async function return already

[21:41:49.0861] <rkirsling>
shu: did you mean to leave this needs-consensus topic just titled by its number on the agenda? ü§î

[21:41:53.0252] <rkirsling>
https://github.com/tc39/agendas/commit/870dd57707700201cc6893d4b7bbb1b133a2e51a

[21:48:52.0350] <ljharb>
yes, that‚Äôs intentional 

[22:31:15.0770] <rkirsling>
these map.emplace slides are so pretty

[22:31:23.0839] <rkirsling>
nice work dminor 

[01:13:35.0007] <rkirsling>
and shu's presentation is totally gonna be a show-stealer, I'm excited for this üòÅ

[13:44:09.0692] <Chris de Almeida>
copypasting Rob's message from the reflector:

[13:44:48.0527] <Chris de Almeida>
The agenda continues to fill with content and is beyond our capacity. There's roughly 20 hours of agenda content and 16 hours of meeting time to fit it in. So we are over budget by about 4 hours. Sometimes we recover an hour or two, but not four.

## Actions

### More Time

Our hosts are happy for us to continue until 5pm each day, so I propose we extend Thursday to finish at 5pm instead of finishing at 4pm.

### Less Content

To everyone that has placed items on the agenda, please consider voluntary actions to mitigate the capacity problem. For example you could:

- Mark your item as low priority by adding a ‚¨áÔ∏è icon to the agenda.
  - This means we will only get to it if time permits.
- Reduce the timebox.
  - You can express the timebox as a range if you wish. The upper limit of which should ideally not be higher than the original request.
- Remove the item entirely if there is no harm deferring it to the next meeting which is at the start of December.

[15:27:17.0123] <Michael Ficarra>
alright I added lower bounds to my items' timeboxes, hope that helps with scheduling


2024-10-05
[17:31:30.0361] <Chris de Almeida>
draft schedule is up:  https://github.com/tc39/Reflector/issues/537#issuecomment-2394818520

[17:42:59.0965] <bakkot>
Rob Palmer: the notes signup link mentions speech-to-google-docs; is that a leftover from before the transcriptionist?

[17:43:37.0702] <bakkot>
I do still have the bot but haven't been running it

[23:37:25.0606] <Michael Ficarra>
you should run it so we can refer to it while editing

[23:37:32.0343] <Michael Ficarra>
I find it very useful

[00:45:04.0981] <Rob Palmer>
I deleted that stale comment


2024-10-06
[20:13:03.0836] <rkirsling>
btw if anybody else didn't get added to the Tokyo 2024 channel, please do speak up!

[22:15:05.0486] <Andreu Botella (üïê JST)>
> <@rkirsling:matrix.org> btw if anybody else didn't get added to the Tokyo 2024 channel, please do speak up!

Could you add me?

[22:53:05.0173] <rkirsling>
done!

[23:13:06.0352] <Ashley Claymore>
Also me please üôè 

[05:08:36.0023] <Anthony Bullard>
Me please (or is this only for in-person attendees?)

[05:50:38.0379] <rkirsling>
Yeah it's for coordination surrounding any activities external to plenary

[05:51:02.0752] <rkirsling>
plenary discussion will be in this channel and TDZ as usual


2024-10-07
[15:28:21.0049] <Rezvan>
Hi. When the sign-in form with video link will be posted?

[15:28:46.0536] <Rezvan>
Or it is posted somewhere and I am missing it?

[15:30:22.0196] <Rob Palmer>
It will be posted an hour ahead of the meeting starting.

[15:30:42.0667] <Rezvan>
Great, thanks!

[15:48:13.0608] <Rob Palmer>
(actually I just posted it - though no one will be in the Teams call yet)

[16:11:05.0235] <Rezvan>
Thank you


2024-10-08
[17:12:09.0289] <yusukesuzuki>
> <@rkirsling:matrix.org> btw if anybody else didn't get added to the Tokyo 2024 channel, please do speak up!

Oh! Could you add me too? Thanks!

[17:44:40.0228] <Rob Palmer>
Has anyone dialled in yet?

[17:45:41.0693] <rkirsling>
> <@yusukesuzuki:matrix.org> Oh! Could you add me too? Thanks!

It says you've already been added!

[17:46:17.0415] <yusukesuzuki>
Oops! Thank you!!

[17:50:38.0881] <Rob Palmer>
We are prepping to start.  If you wish to help, please sign up to a session for Note Editing!

https://github.com/tc39/Reflector/issues/537#issuecomment-2394180693

[17:54:11.0820] <Rob Palmer>
The Teams call is up! Please rember to NOT sign into Teams itself. Join the call as a guest.

[18:27:21.0381] <littledan>
We have 4 slots for non-ordinary members in ExeCom

[18:27:42.0569] <littledan>
there are more slots than current members. I encourage everyone to join!

[18:32:13.0120] <shu>
Chris de Almeida: the wintercg vote

[18:34:14.0911] <Chris de Almeida>
shu: maybe DE can elaborate, but my understanding is that they are going to fully move to Ecma, rather than have the split of the CG vs WG

[18:34:38.0630] <Chris de Almeida>
the IPR concerns were due to doing some things in w3c and then some things in ecma and that was problematic

[18:34:57.0430] <shu>
last time that move was voted on and the vote failed due to IPR concerns. i am asking a clarification on what has changed since then

[18:35:08.0329] <shu>
because what i hear internally is "it's pending legal review", and aki's presentation makes it sound like it's a done thing

[18:35:10.0815] <canadahonk>
I can talk on this if people want

[18:35:32.0586] <canadahonk>
> <@softwarechris:matrix.org> shu: maybe DE can elaborate, but my understanding is that they are going to fully move to Ecma, rather than have the split of the CG vs WG

but this is the tl;dr yeah

[18:36:10.0733] <littledan>
If you're interested in the founding documents, please let me know and I'll send them to you. I've already sent to Chris Wilson and Tantek Celik, in addition to the Ecma ExeCom.

[18:36:40.0005] <shu>
specifically i'm wondering are you doing the thing where you're sending all the contributors IP transfer documents or whatever

[18:36:59.0953] <littledan>
> <@shuyuguo:matrix.org> specifically i'm wondering are you doing the thing where you're sending all the contributors IP transfer documents or whatever

yes, and this is OK since it's a one-time thing rather than an ongoing operation

[18:37:12.0198] <shu>
is that thign pending legal review from the original folks who raised the IP concerns

[18:38:33.0123] <littledan>
> <@shuyuguo:matrix.org> is that thign pending legal review from the original folks who raised the IP concerns

I don't know who it's pending legal review from. The people who raised concerns previously who I've been able to follow up with were positive about this version. I haven't been able to follow up with everyone.

[18:40:04.0866] <shu>
i'm assuming at least mozilla and google legal

[18:43:04.0757] <bakkot>
fwiw the audio sounds fine on the call

[18:45:57.0350] <Aki>
Someone wanna drop that screenshot of TCQ questions for me so I can answer them here?

[18:46:20.0301] <Chris de Almeida>
we shouldn't paste here

[18:46:23.0512] <shu>
(mine was answered in the chat just now)

[18:47:11.0163] <canadahonk>
> <@akirose:matrix.org> Someone wanna drop that screenshot of TCQ questions for me so I can answer them here?

I don't think there was anything else not already answered here (just re tc55 original proposal ipr things)

[18:47:58.0417] <Aki>
Chris de Almeida sent me the screenshot (thanks!)

[18:48:13.0405] <Ashley Claymore>
Ben: when you get a chance could you add a slides link to the agenda

[18:48:23.0462] <Ben>
Doing now

[18:48:39.0665] <littledan>
suggestion for Mozilla's concerns about being able to review the agenda: We require all agenda items to be added before the deadline, unless there is a particular "emergency"/reason for why the addition was delayed. We strongly encourage slides, repos or other supporting materials to be added to the agenda before the deadline or soon after it, with their contents done as early as possible.

[18:56:37.0462] <yulia>
the suggestions dan made above (slides & content must be available) makes a lot of sense. I would also suggest (to avoid issues in the future) that we move the deadline to 14 days (in line with ecma), and we have an indication of the amount of work (in hours) so far added to the meeting. We can't approve what we don't review, and we want to make sure that the output of tc39 is as high as possible. I think that is a shared goal. If we can plan our meeting a bit better I think it would help. 

[18:57:06.0918] <yulia>
I am not sure if many delegates are reviewing all proposal before the meeting, but it is a requirement for us as implementers, because if something lands and we didn't really think about it -- we are left holding the bag

[18:57:40.0756] <Chris de Almeida>
Ecma rules say 21 days

[18:57:45.0205] <ljharb>
fwiw those suggestions are already the case. supporting materials that aren't in by the deadline allows prodecural blocking

[18:57:46.0944] <yulia>
ah my mistake

[18:57:50.0440] <ljharb>
 * fwiw those suggestions are already the case. supporting materials that aren't in by the deadline allows procedural blocking

[18:58:04.0285] <ljharb>
 * fwiw those suggestions are already the case. supporting materials that aren't in by the deadline allows for procedural blocking

[18:58:20.0553] <littledan>
we've confirmed with Ecma in the past that TC39 may adopt its own deadline (otherwise I would've worked on getting the rules changed). But 14 days seems reasonable to me.

[18:58:22.0130] <shu>
at least for proposals 2.7+ i think an earlier deadline makes sense

[18:58:28.0969] <Aki>
yeah i was having a conversation the other day about this and surprised to discover TC39's deadline was different from Ecma's, i totally forgot

[18:58:31.0934] <yulia>
the current 5 working days that we have to fully review all of the proposals was not enough

[18:58:32.0267] <ljharb>
i'm not sure how we could calculate how much review work is needed, because it won't correlate with timebox time

[18:59:18.0434] <ljharb>
> <@shuyuguo:matrix.org> at least for proposals 2.7+ i think an earlier deadline makes sense

i'd assume the largest review is needed for a stage 2 advancement, and the smallest for a stage 0 ‚Üí 1 or 2.7 ‚Üí 3 or 3 ‚Üí 4

[18:59:33.0328] <ljharb>
> <@shuyuguo:matrix.org> at least for proposals 2.7+ i think an earlier deadline makes sense

 * i'd assume the largest review is needed for 1 ‚Üí 2 or 2 ‚Üí 2.7, and the smallest for a stage 0 ‚Üí 1 or 2.7 ‚Üí 3 or 3 ‚Üí 4

[19:00:00.0430] <shu>
> <@ljharb:matrix.org> i'd assume the largest review is needed for 1 ‚Üí 2 or 2 ‚Üí 2.7, and the smallest for a stage 0 ‚Üí 1 or 2.7 ‚Üí 3 or 3 ‚Üí 4

the 2->2.7 is the biggest one IMO, because that's starting to approach the "impls left holding the bag in case of things missed during review"

[19:00:16.0250] <shu>
so at least in terms of irreversible consequences

[19:00:26.0603] <yulia>
yeah 2->2.7 is the biggest, that means that things that are not that, end up getting the short end of the stick

[19:00:26.0967] <ljharb>
so given that, requiring an earlier deadline for attempting to enter 2 or 2.7 might make sense

[19:00:37.0776] <bakkot>
fwiw I also did not notice that the agenda item contained "TG4: Source Map Specification, 2024 edition approval (30m, Jonathan Kuperman)"

[19:00:39.0185] <ljharb>
 * so given that, requiring an earlier deadline for attempting to enter 2 or 2.7 might make sense (no need to require it for the others)

[19:00:47.0641] <bakkot>
mostly because I do not look at the task group updates section

[19:00:48.0049] <Chris de Almeida>
I don't have strong feelings on this but I do not want a complex rules engine for which deadlines apply to which stages

[19:01:05.0947] <yulia>
same, i would say just an earlier deadline allowing more than 5 days of review time

[19:01:10.0217] <shu>
then we probably do want to move the deadline up earlier for all proposals

[19:01:17.0648] <littledan>
> <@softwarechris:matrix.org> I don't have strong feelings on this but I do not want a complex rules engine for which deadlines apply to which stages

I agree, I'd prefer to have a single deadline to apply to all agenda items, not just advancement requests

[19:01:35.0666] <Chris de Almeida>
+1

[19:01:37.0222] <ljharb>
we have never had a deadline for non-advancements and i don't think we should start now

[19:01:50.0487] <yulia>
i believe we are only discussing advancement deadlines

[19:02:04.0364] <Chris de Almeida>
I think it would remain a 'best effort' thing, not a 'you missed the boat, sorry' thing

[19:02:19.0777] <ljharb>
the word "deadline" refers to the latter ime

[19:02:30.0323] <Chris de Almeida>
but it's very helpful if everything is in before the given date

[19:02:33.0239] <ljharb>
 * the word "deadline" refers to the latter ime ("dead" being a somewhat final state)

[19:02:34.0472] <littledan>
well, I raised non-advancement-requests, but I can accept if we don't adopt the policy that I suggested

[19:02:41.0892] <Chris de Almeida>
and the later things get added, the more problems it creates

[19:02:55.0388] <yulia>
yeah, with the risk of something beling blocked -- i mean it would be the same situation as now, but with 2 weeks (10 days of working time, if there are no holidays) would go a long way here 

[19:03:20.0286] <littledan>
adding something to the TC39 agenda is asking everyone to take time to focus together on a topic, so I think it's not too much for it to apply to everything. It will help us to be more effective if we have all supporting materials for all items ahead of a deadline.

[19:03:21.0926] <ljharb>
part of the reason we wanted to keep the deadline short in the past is that there's only 2 months between plenaries

[19:03:42.0781] <ljharb>
those extra 4 days have been very helpful in the past to get ducks in a row for an upcoming plenary

[19:07:04.0495] <yulia>
That said, since we meet so frequently, spilling over to the next meeting isn't a huge delay.

[19:07:18.0080] <rkirsling>
> <@bakkot:matrix.org> fwiw I also did not notice that the agenda item contained "TG4: Source Map Specification, 2024 edition approval (30m, Jonathan Kuperman)"

I am actually confused whether this is the appropriate timing for a topic of this nature

[19:07:30.0343] <ljharb>
2 months is a significant delay, but 4 days doesn't seem like one to me

[19:07:31.0796] <rkirsling>
like, 30m topic in the 5m topics section

[19:07:48.0632] <Ashley Claymore>
Current doc for advancement to Stage 1 says:

> Such proposals must link to a proposal repository and they *should* link to supporting materials when possible.

[19:07:56.0985] <yulia>
the time taken in those 4 days, vs incomplete review and missing something, the cost of the latter is much higher

[19:08:10.0559] <Ashley Claymore>
maybe we should make that should a must

[19:08:17.0677] <littledan>
> <@ljharb:matrix.org> those extra 4 days have been very helpful in the past to get ducks in a row for an upcoming plenary

I think that logic made sense at the time, but as the committee grew and we got more topics on the agenda, the tradeoff shifts, as yulia says

[19:08:45.0733] <nicolo-ribaudo>
I'm not following the chat,   but if it's for source map: it would be a 6 months delay and not 2 months, due to the GA meeting twice per year

[19:08:53.0119] <rkirsling>
> <@aclaymore:matrix.org> maybe we should make that should a must

I feel like I remember having a conversation in which I suggested this and we landed on "should" instead somehow...or something

[19:08:57.0831] <Michael Ficarra>
> <@aclaymore:matrix.org> maybe we should make that should a must

I think it's fine to have reduced requirements for Stage 1

[19:09:42.0954] <Aki>
> <@nicolo-ribaudo:matrix.org> I'm not following the chat,   but if it's for source map: it would be a 6 months delay and not 2 months, due to the GA meeting twice per year

Two months here refers to stage advancement

[19:10:19.0447] <littledan>
overall, the wording in the agenda doc has encouraged people to not bother to especially try to get things into the agenda ahead of time, even when they maybe could've. It's been confusing for me to explain to people that they really should put everything there earlier, and I've had to clarify that lots of times.

[19:10:25.0143] <nicolo-ribaudo>
littledan Btw, the reason we were thinking about the license for the spec itself, is that both ECMA-262 and ECMA-402 are published underm Ecma's BSD version

[19:10:32.0632] <nicolo-ribaudo>
 * littledan Btw, the reason we were thinking about the license for the spec itself, is that both ECMA-262 and ECMA-402 are published under Ecma's BSD version

[19:15:05.0242] <littledan>
> <@nicolo-ribaudo:matrix.org> littledan Btw, the reason we were thinking about the license for the spec itself, is that both ECMA-262 and ECMA-402 are published under Ecma's BSD version

Ecma has one BSD version for test262 at https://ecma-international.org/policies/by-ipr/ecma-international-policy-on-submission-inclusion-and-licensing-of-software/ ; the alternative copyright notice at https://ecma-international.org/policies/by-ipr/ecma-text-copyright-policy/ (second section) seems broadly BSD-like, but somewhat different text, which is why I was confused. I imagine you're working on the latter relicensing (I don't really understand why it's not implicit based on Google+Mozilla's agreements with Ecma, but the lawyers will known better)

[19:16:42.0832] <Chengzhong Wu>
do we have a slides link to TG5 Report?

[19:17:46.0233] <yulia>
https://docs.google.com/presentation/d/156wJbnrIEt-hbkhh0paVAIjrG9L7oe_R9z211yS0bIA/edit#slide=id.g308ab6c6cfb_0_25

[19:17:58.0158] <bakkot>
yulia: would you put a brief summary of the TG5 presention in the notes? there's a spot for it

[19:18:07.0212] <bakkot>
I could generate one but it's best of the speakers do it

[19:18:11.0446] <bakkot>
 * I could generate one but it's best if the speakers do it

[19:18:44.0351] <littledan>
> <@bakkot:matrix.org> I could generate one but it's best if the speakers do it

when you say "generate", do you mean you'd write it?

[19:18:49.0702] <bakkot>
yes

[19:23:12.0241] <bakkot>
I strongly agree with Michael's point that we should never switch on iterability for any reason other than to throw for non-iterables

[19:23:14.0180] <rbuckton>
auto-wrapping is a footgun that required a special symbol to workaround for Array.prototype.concat. We shouldn't repeat that mistake

[19:24:40.0979] <ljharb>
that isn't why isConcatSpreadable exists, it exists so DOM NodeLists can explain their special array concat behavior

[19:25:21.0576] <keith_miller>
I thought isConcatSpreadable existed to make me suffer as a new hire :P

[19:25:26.0473] <ljharb>
iow that symbol is not relevant to this proposal.

[19:25:33.0673] <ljharb>
 * iow that symbol is not relevant to this proposal, whether it autowraps or not

[19:25:33.0795] <rbuckton>
It also likely wouldn't have been necessary if Array.prototype.concat did not have the auto-wrapping behavior

[19:25:38.0117] <ljharb>
that too!

[19:25:49.0124] <ljharb>
someone made sure that "make keith suffer" was redacted from the notes

[19:25:59.0579] <ljharb>
it would still have been necessary.

[19:26:07.0371] <ljharb>
because NodeLists aren't arrays and did have special concat behavior

[19:26:24.0609] <ljharb>
without the autowrapping, NodeLists would have thrown instead of spread

[19:26:42.0797] <ljharb>
 * without the autowrapping, NodeLists would have thrown instead of been added without spreading

[19:26:47.0235] <rbuckton>
Either way, auto-wrapping is a footgun. it also doesn't align with our recent decision to cut back on coercing things

[19:26:50.0862] <ljharb>
but NodeLists spread, thus the symbol. nothing to do with autowrapping whatsoever.

[19:27:27.0155] <hax (HE Shi-Jun)>
What's the special behavior of NodeList?

[19:29:21.0206] <hax (HE Shi-Jun)>
> <@rbuckton:matrix.org> Either way, auto-wrapping is a footgun. it also doesn't align with our recent decision to cut back on coercing things

I guess the behavior of Array.p.concat is come from perl. Though perl have the sigil to indicate whether it's a scalar or list.

[19:32:15.0618] <nicolo-ribaudo>
As a committee, we should adopt the principle of "making it hard to accidentally do the wrong thing". When user intention is ambiguous, let's ask users to be explicit 

[19:33:35.0997] <littledan>
In TC39, the bare minimum is "web compatibility", which is a much weaker property than "breaking change". As Jordan explained, basically anything that we do can be considered breaking.

[19:36:58.0384] <Bradford Smith>
Iterable helpers that flatten their arguments are implicitly branching on iterability and likely to be used a lot in future.

[19:38:54.0648] <bakkot>
which iterable helpers flatten their arguments?

[19:39:22.0399] <Bradford Smith>
Maybe my memory is faulty. I thought there was at least one API that did this.

[19:39:29.0177] <rbuckton>
IIRC, `Iterator.prototype.flatMap` does not coerce non-iterator/non-iterable

[19:39:48.0947] <bakkot>
it rejects non-iterators

[19:40:42.0093] <rbuckton>
If you consider `Iterator.concat` to essentially be `(...args) => args.values().flatMap(x => x)`, then we should also throw for non-iterators

[19:41:00.0413] <ljharb>
in general as well, something being iterable is a massively impactful "trait" of it - something changing from being "a thing" to being "a container of things" isn't and shouldn't be a common thing. if we're talking about good API design, good API design wouldn't make this change, i'd think

[19:41:08.0775] <ljharb>
 * in general as well, something being iterable is a massively impactful "trait" of it - something changing between being "a thing" to being "a container of things" isn't and shouldn't be a common thing. if we're talking about good API design, good API design wouldn't make this change, i'd think

[19:42:12.0933] <bakkot>
> <@rbuckton:matrix.org> If you consider `Iterator.concat` to essentially be `(...args) => args.values().flatMap(x => x)`, then we should also throw for non-iterators

to be really explicit, this proposal only accepts _iterables_, not iterators

[19:42:24.0171] <bakkot>
accepting _iterators_ turns out to get really awkward

[19:42:32.0129] <bakkot>
because you have to take responsibility for closing them

[19:44:31.0666] <rbuckton>
I'm not saying it must be implemented as such, but a naive implementation using `flatMap` would throw, not coerce.

[19:45:08.0919] <ljharb>
that naive implementation would eagerly exhaust the iterators, which this doesn't do

[19:45:37.0995] <rbuckton>
Again, I'm talking about consistency. `Iterator` generally doesn't coerce

[19:46:29.0463] <ljharb>
true, that's what `Iterator.from` is for

[19:46:30.0775] <rbuckton>
I'm not concerned, there are plenty of bad API designs on Array we shouldn't carry forward, even if we carry forward the concept to other APIs

[19:46:34.0881] <Justin Ridgewell>
@ljharb:matrix.org very weakly yes, but I got over it quickly in Rust

[19:47:21.0900] <Justin Ridgewell>
Used a whole bunch of `once(foo)`, but it‚Äôs much easier in JS because you can wrap in an array without screwing with types.

[19:47:24.0273] <rbuckton>
For instance, iterator helper methods don't take a `thisArg` despite the array prototype methods of the same name doing so.

[19:49:05.0022] <ljharb>
sure, but array concat's behavior isn't bad.

[19:49:13.0888] <ljharb>
 * sure, but array concat's behavior isn't bad. (ignoring isConcatSpreadable ofc)

[19:49:24.0925] <ljharb>
 * sure, but array concat's behavior isn't bad. (ignoring isConcatSpreadable ofc) the `thisArg` is useless since arrows and bind exist

[19:50:12.0795] <nicolo-ribaudo>
Rob Palmer If Ron finishes early, you can move ahead my import attributes discussion (the constraint on the agenda is mine)

[19:50:27.0897] <Rob Palmer>
Thank you, Nicolo

[19:50:29.0852] <nicolo-ribaudo>
 * Rob Palmer If Ron finishes early, you can move forward my import attributes discussion (the constraint on the agenda is mine)

[20:01:47.0258] <rbuckton>
Rob Palmer with the deadpan "wheee" üòÇ

[20:02:03.0550] <jkup>
hahahahahahahaha

[20:03:47.0238] <bakkot>
lots of stage 4!

[21:00:23.0265] <Rob Palmer>
The schedule has been updated significantly!  Today's afternoon session now looks very different

[21:02:35.0274] <rkirsling>
oh whoa apparently the rap battle is happening today

[21:03:07.0976] <Aki>
GIRD YOUR LOINS EVERYONE

[21:16:31.0345] <yulia>
clarifying question for someone here who probably knows the answer (otherwise when guybedford has time): This proposal is mostly to make worker imports of modules more statically analyzable right? why are new methods necessary on the Module Source object for this? https://tc39.es/proposal-esm-phase-imports/#sec-module-source-objects

[21:18:37.0600] <yulia>
 * clarifying question for someone here who probably knows the answer (otherwise when guybedford has time): This proposal is mostly to make worker imports of modules more statically analyzable right [1])https://github.com/tc39/proposal-esm-phase-imports?tab=readme-ov-file#problem-statement_? why are new methods necessary on the Module Source object for this? https://tc39.es/proposal-esm-phase-imports/#sec-module-source-objects

[21:18:37.0940] <nicolo-ribaudo>
Yes that was the primary use case, but people then tried to think about how to use this for static analysis (basically exposing the metadata that the engine already has to collect)

[21:18:46.0989] <yulia>
 * clarifying question for someone here who probably knows the answer (otherwise when guybedford has time): This proposal is mostly to make worker imports of modules more statically analyzable right? why are new methods necessary on the Module Source object for this? https://tc39.es/proposal-esm-phase-imports/#sec-module-source-objects

[21:18:51.0786] <nicolo-ribaudo>
I think this would mostly be useful in Node.js as it is

[21:19:13.0426] <nicolo-ribaudo>
The browser utility is more marginal, unless we get something like the module constructor

[21:19:28.0171] <shu>
yeah i'm not clear on imports() and exports() utility either

[21:19:45.0561] <yulia>
yeah its a little hard to see a justification for this in browsers right now

[21:20:00.0989] <yulia>
but thats not related to the update, this is a general concern about the proposal

[21:20:11.0018] <nicolo-ribaudo>
Can one of you go on the queue?

[21:20:56.0310] <nicolo-ribaudo>
thanks :)

[21:32:33.0845] <rbuckton>
erights: As stated on a previous slide, there is no return override capability.

[21:33:35.0054] <Mathieu Hofman>
rbuckton: I think Mark's question (who isn't on Matrix) is whether a class can use a struct as the returned object in a return override to stamp fields on the struct

[21:33:50.0500] <rbuckton>
Ah. No, it cannot

[21:33:53.0958] <ljharb>
why not?

[21:33:58.0712] <ljharb>
if it's an object it should work

[21:34:08.0653] <ljharb>
just as if i can weakly hold it

[21:34:11.0135] <Mathieu Hofman>
I mean I'd love that, but yes, why, what's the mechanism ?

[21:34:30.0554] <ljharb>
it's an object. all objects (except `window`) can have fields stamped on them via return override.

[21:34:31.0373] <rbuckton>
No, the fields must be statically known at construction time for one-shot initialization

[21:34:49.0349] <Mathieu Hofman>
> <@ljharb:matrix.org> if it's an object it should work

I am very against this line of logic. A WeakMap capability should not be syntactic

[21:34:59.0328] <ljharb>
"adding a private field" is the same as "putting an object in a weakmap"

[21:35:04.0814] <ljharb>
that's explicitly how private fields were designed

[21:35:14.0752] <ljharb>
return override isn't syntactic

[21:35:49.0701] <ljharb>
it is currently an invariant that if it is an object (modulo window) you can stamp private fields onto it via return override. we shouldn't break that invariant.

[21:35:56.0604] <Mathieu Hofman>
return override + private field stamping is a syntactic capability that is not deniable or virtualizable, unlike WeakMap

[21:35:58.0027] <ljharb>
 * it is currently an invariant that if it is an object (modulo window) you can stamp private fields onto it via return override, and hold it weakly. we shouldn't break that invariant.

[21:36:10.0205] <ljharb>
that's already the case for all objects, it's a consequence of being an object.

[21:36:19.0551] <rbuckton>
private fields, if/when supported, will also have a fixed layout.

[21:36:21.0975] <Mathieu Hofman>
and it was a huge mistake

[21:36:30.0905] <Mathieu Hofman>
and I strongly believe we should not hold this as an invariant

[21:36:33.0018] <ljharb>
doesn't mean we should create inconsistency by deviating from it

[21:36:44.0329] <rbuckton>
it is necessary to achieve the performance characteristics we want for structs/shared structs

[21:36:50.0294] <ljharb>
to me this is an obstacle to stage 2, to be clear.

[21:37:09.0342] <bakkot>
can you `class extends Struct {}`? if so you can surely put a private filed in that class?

[21:37:13.0629] <nicolo-ribaudo>
> <@rbuckton:matrix.org> private fields, if/when supported, will also have a fixed layout.

The fixed layout is so that struct methods can "quickly" access them, right? Those installed via return override would not be private fields that belong to the struct, so they wouldn't go through that fast path

[21:39:44.0433] <rbuckton>
Yes and no. The fixed layout is partially so that implementations can properly optimize field accesses in ways that they cannot with normal fields today. For shared structs, we want private fields to be shared memory as well

[21:39:52.0464] <Mathieu Hofman>
> <@bakkot:matrix.org> can you `class extends Struct {}`? if so you can surely put a private filed in that class?

That is technically not necessary for for stamping private field

[21:40:08.0158] <Mathieu Hofman>
> <@bakkot:matrix.org> can you `class extends Struct {}`? if so you can surely put a private filed in that class?

 * That is technically not necessary for for stamping private fields

[21:40:43.0363] <bakkot>
right but... can you do that thing?

[21:45:55.0171] <rbuckton>
> <@bakkot:matrix.org> can you `class extends Struct {}`? if so you can surely put a private filed in that class?

We could possibly allow this by storing the private fields of a struct/shared struct differently than those added by a class, where private fields added by a class are more weakmap like, while those added by a shared struct maintain fixed layout to be portable across agents.

[21:46:39.0867] <ljharb>
that sounds like the only option to resolve it tbh

[21:46:45.0060] <bakkot>
I am OK with it being impossible to `class extends Struct {}`, to be clear

[21:46:51.0233] <bakkot>
just asking if that would work

[21:47:06.0773] <ljharb>
i'm not ok with being unable to stamp fields onto it.

[21:47:29.0357] <rbuckton>
I'd be fine `class extends struct` not working

[21:47:45.0753] <hax (HE Shi-Jun)>
As the current proposal, struct seems like a weakened version of class. Perceptually, the difference between struct and class is much smaller than the difference between struct and shared struct. I mean, it seems easy to rewrite a class to struct, but very hard to modify a struct to become a shared struct. This make me feel weird that "struct" and "shared struct" use similar name and syntax...

[21:48:37.0707] <bakkot>
if (and only if) it is impossible to `class extends Struct {}` then I am also ok with the return-override trick not allowing you to return a struct

[21:48:49.0891] <bakkot>
in which case, as a consequence, you could not stamp additional private fields on an existing struct

[21:49:17.0450] <littledan>
Correlation is also important even if you just have one object, and want the methods to work after sharing it to the other side

[21:51:06.0851] <rbuckton>
`struct` is a restricted form of `class`, partly because `class` polymorphism is expensive and slow and cannot be fully optimized via ICs. the fixed layout of structs is partly intended to improve performance due to the well known layout. Basically: `class` is more flexible but slower, `struct` is more restrictive but faster.

[21:54:24.0448] <rkirsling>
did I blink and miss an explanation of function coloring

[21:55:12.0838] <rbuckton>
> <@rkirsling:matrix.org> did I blink and miss an explanation of function coloring

Function coloring is a function being aware of whether it is invoked inside of an `unsafe` block. 

[21:55:16.0574] <rkirsling>
I _think_ I understand what it means (like "an async function is fundamentally different from a sync function") but I don't see what shu is saying

[21:55:18.0613] <ljharb>
https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/

[21:55:25.0178] <rkirsling>
> <@rbuckton:matrix.org> Function coloring is a function being aware of whether it is invoked inside of an `unsafe` block.

ohhh

[21:55:36.0283] <rkirsling>
> <@ljharb:matrix.org> https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/

ooh a Bob post

[21:55:38.0593] <bakkot>
we should add that to the glossary

[21:55:59.0607] <hax (HE Shi-Jun)>
rbuckton: Yeah, I mean it seems we should use syntax like ` sealed class { } ` to make it clear (though `sealed` is not a correct keyword) that it's a better but restricted class. And let shared struct just use `struct {}` ...

[21:56:02.0616] <ljharb>
the queue has 13 items btw

[21:56:10.0041] <danielrosenwasser>
Basically if you have a function `f` that contains an `unsafe {}` block, callers of `f` don't need to wrap it in an `unsafe {}` block.

[21:56:20.0988] <danielrosenwasser>
 * Basically if you have a function `foo` that contains an `unsafe {}` block, callers of `foo` don't need to wrap it in an `unsafe {}` block.

[21:56:33.0148] <ljharb>
so i'd be able to write a "am i in an unsafe block" predicate?

[21:56:43.0452] <ljharb>
 * so i'd be able to write an "am i in an unsafe block" predicate?

[21:56:49.0674] <rbuckton>
> <@haxjs:matrix.org> rbuckton: Yeah, I mean it seems we should use syntax like ` sealed class { } ` to make it clear (though `sealed` is not a correct keyword) that it's a better but restricted class. And let shared struct just use `struct {}` ...

Shu and the v8 team have other reasons to want `struct`, including the unique construction semantics. struct and shared struct construction differs significantly from `class`.

[21:57:09.0642] <danielrosenwasser>
> <@ljharb:matrix.org> so i'd be able to write an "am i in an unsafe block" predicate?

oh no

[21:57:13.0269] <rbuckton>
> <@ljharb:matrix.org> so i'd be able to write an "am i in an unsafe block" predicate?

With function coloring, yes. As specified, no and we do not think it should be added.

[21:57:22.0508] <ljharb>
gotcha thanks

[21:57:23.0833] <danielrosenwasser>
> <@danielrosenwasser:matrix.org> oh no

and by that I mean "ugh yes"

[21:57:28.0642] <Mathieu Hofman>
> <@ljharb:matrix.org> so i'd be able to write an "am i in an unsafe block" predicate?

as a property access on a proxy, maybe, depending on the open question

[21:57:42.0973] <Mathieu Hofman>
but as a predicate that has the shape of a function, no

[21:57:58.0469] <ljharb>
if you can't write such a predicate i'm not sure how you could virtualize shared structs

[21:58:34.0055] <hax (HE Shi-Jun)>
> <@rbuckton:matrix.org> Shu and the v8 team have other reasons to want `struct`, including the unique construction semantics. struct and shared struct construction differs significantly from `class`.

I understand from the engine viewpoint (or spec viewpoint) it's true, but I guess from developer concept model, it's too different.

[21:58:34.0112] <Mathieu Hofman>
you can with proxy

[21:58:42.0819] <ljharb>
ok, then you can, and functions can be colored?

[21:58:48.0514] <Mathieu Hofman>
it'd just be a boolean flag passed to the trap

[21:58:48.0984] <ljharb>
 * ok, then you can, and functions can be colored manually?

[21:59:10.0613] <hax (HE Shi-Jun)>
> <@haxjs:matrix.org> I understand from the engine viewpoint (or spec viewpoint) it's true, but I guess from developer concept model, it's too different.

Maybe TG5 could investigate it

[21:59:58.0114] <nicolo-ribaudo>
> <@ljharb:matrix.org> so i'd be able to write an "am i in an unsafe block" predicate?

You can try/catch around reading from a shared struct that you have, right?

```js
shared struct Test { x }

{
  try { new Test().x } catch { console.log("not unsafe block") }
}

unsafe {
  try { new Test().x; console.log("unsafe block") } catch { }
}
```

[22:00:01.0225] <rbuckton>
> <@haxjs:matrix.org> I understand from the engine viewpoint (or spec viewpoint) it's true, but I guess from developer concept model, it's too different.

Even from a developer point of view, the construction semantics of a `struct` differ enough from `class` that making it differ purely based on a modifier would trip up developers. 

[22:00:24.0756] <ljharb>
> <@nicolo-ribaudo:matrix.org> You can try/catch around reading from a shared struct that you have, right?
> 
> ```js
> shared struct Test { x }
> 
> {
>   try { new Test().x } catch { console.log("not unsafe block") }
> }
> 
> unsafe {
>   try { new Test().x; console.log("unsafe block") } catch { }
> }
> ```

ok, but can i run that try/catch inside a function that someone else invokes in, or not in, an unsafe block?

[22:00:29.0272] <danielrosenwasser>
ah I've misunderstood - so is the following disallowed?

```
function foo() {
    unsafe {
        bar();
    }
}

function bar(sharedInstance) {
    sharedInstance.property = 123;
}
```

[22:00:42.0249] <nicolo-ribaudo>
> <@ljharb:matrix.org> ok, but can i run that try/catch inside a function that someone else invokes in, or not in, an unsafe block?

No, but that function's body is always running in "safe" mode

[22:00:49.0310] <nicolo-ribaudo>
It's like checking if your caller is strict or loose

[22:00:50.0770] <nicolo-ribaudo>
You can't

[22:00:51.0220] <rbuckton>
> <@danielrosenwasser:matrix.org> ah I've misunderstood - so is the following disallowed?
> 
> ```
> function foo() {
>     unsafe {
>         bar();
>     }
> }
> 
> function bar(sharedInstance) {
>     sharedInstance.property = 123;
> }
> ```

Yes, this does not work.

[22:01:04.0573] <bakkot>
I would like to see a lot more examples what code is/is not legal `using`, somewhere

[22:01:10.0568] <bakkot>
it is probably good I just don't understand it yet

[22:01:11.0335] <rbuckton>
`bar` does not magically get colored as `unsafe` when called. it must be lexically scoped within the block.

[22:01:22.0193] <rbuckton>
`using` or `unsafe`?

[22:01:23.0513] <bakkot>
 * I would like to see a lot more examples what code is/is not legal for `unsafe`, somewhere

[22:01:26.0602] <bakkot>
`unsafe`, sorry

[22:02:01.0549] <rbuckton>
`unsafe` only controls the ability to get/set a field on a shared struct instance, and only applies to code lexically scoped within the `unsafe {}` block.

[22:02:30.0989] <bakkot>
ok, that sounds straightforward; I think I got confused by all the discussion of coloring

[22:02:31.0568] <Mathieu Hofman>
`unsafe` only changes the behavior of get/set lexically contained in the block.

[22:02:43.0990] <bakkot>
but I am confused about the discussion of the APIs, then

[22:02:50.0764] <bakkot>
like `Reflect.get` etc

[22:03:20.0858] <Mathieu Hofman>
Should `Reflect.get` have some way to access the value (regardless of where the call happens)

[22:03:26.0756] <rbuckton>
The problem with `Reflect.get` is that it either must always succeed or always throw when reading a shared struct field.

[22:03:59.0156] <bakkot>
or we thread a parameter about unsafe-ness through, per the slides

[22:04:05.0247] <rbuckton>
Which means a Proxy must also either always succeed or always fail, or passing a get through a proxy trap becomes inconsistent when it passes through Reflect.get.

[22:04:10.0747] <rbuckton>
Yes, that's the third option.

[22:04:54.0371] <Mathieu Hofman>
get/set behavior is pretty straightforward. Where it gets funky is with own prop MOPs

[22:05:22.0334] <rbuckton>
My point is more that Reflect.get cannot magically know its in an `unsafe` block

[22:05:36.0186] <bakkot>
ack

[22:06:09.0943] <rbuckton>
It either must always succeed, always fail, or be explicitly informed via a parameter.

[22:11:35.0200] <danielrosenwasser>
Maybe I'm misunderstanding - but if you view it as an object which has been sealed, the behavior seems consistent with other objects, right?

[22:12:08.0700] <bakkot>
given a choice between "make it practical to write shared-memory parallelism in JS" and "preserve the property about things being in WeakMaps", I cannot _imagine_ thinking the second thing is as important

[22:12:17.0036] <bakkot>
it is like, several orders of magnitude less important

[22:16:30.0529] <bakkot>
this is not to say that I don't see the real cost to having more complex rules for developers. it's just that making it practical for pages to have shared-memory parallelism is of incredible, massive value to every user of the web, measured in nontrivial fractions of our lives spent waiting for slow pages that didn't have to be slow. and against that, "JS developers have more complexity to learn" just does not rate

[22:16:47.0977] <bakkot>
ideally, of course, we would find something that allows us to get both

[22:16:58.0990] <littledan>
Yeah this seems like a clear case of what Yulia mentioned as a philosophical concern 

[22:17:06.0547] <bakkot>
but if it comes down to a choice between those two, we cannot choose the "we don't get practical parallelism" one.

[22:17:52.0577] <rbuckton>
I'd much rather have shared memory multithreading than consistency with WeakMap keys. We already have this violation with symbols.

[22:17:58.0852] <ljharb>
symbols aren't objects.

[22:19:04.0280] <rbuckton>
There are other synchronization primitives and concurrency mechanisms I'd like to add, but none meet the bar for an MVP proposal, we hope to propose them as follow-ons later.

[22:19:13.0362] <rbuckton>
 * There are other synchronization primitives and concurrency mechanisms we'd like to add, but none meet the bar for an MVP proposal, we hope to propose them as follow-ons later.

[22:19:14.0606] <Mathieu Hofman>
sorry I spoke too quickly, there is currently no spec behavior that allows a host to prevent object keys to be added to WeakMap, but there is to allow them to refuse any private field stamping

[22:19:59.0901] <ljharb>
> <@mhofman:matrix.org> sorry I spoke too quickly, there is currently no spec behavior that allows a host to prevent object keys to be added to WeakMap, but there is to allow them to refuse any private field stamping

sure but that language was only added recently *for window specifically*

[22:20:35.0078] <rbuckton>
There is also the possibility that structs and shared structs are more primitive-like than object-like, especially given that shared struct per-realm prototype lookup is likely to be very much like primitive prototype lookup.

[22:21:06.0457] <ljharb>
yes, i remain surprised they're not primitives personally

[22:21:27.0086] <Mathieu Hofman>
primitives shouldn't be mutable

[22:21:31.0593] <ljharb>
oh true

[22:21:55.0382] <ljharb>
Mathieu Hofman: re the host hook, it's only allowed in a web browser https://tc39.es/ecma262/#sec-privatefieldadd

[22:22:09.0387] <rkirsling>
I am also worried about this topic but unlike Waldemar, I feel a lack of expertise on the subject lol

[22:22:11.0297] <ljharb>
 * Mathieu Hofman: re the host hook, it's only allowed in a web browser https://tc39.es/ecma262/#sec-privatefieldadd and that was very very intentional, since the expectation was that only `window` would ever use it

[22:22:13.0578] <rbuckton>
In a way, they are essentially "structured primitives" in that they have own fields. I'm not opposed to them having primitive-like behavior for `typeof` and `Object()`, but we'd need to discuss more among the champions.

[22:22:20.0008] <Mathieu Hofman>
that would be a much bigger problem for existing programs, a new type that has object like bahviors

[22:22:49.0649] <ljharb>
`"use unsafe";`

[22:22:54.0423] <rbuckton>
> <@mhofman:matrix.org> that would be a much bigger problem for existing programs, a new type that has object like bahviors

Record was originally proposed to do this, but I see your point.

[22:23:29.0612] <rkirsling>
> <@ljharb:matrix.org> `"use unsafe";`

`"extra sloppy";`

[22:23:32.0761] <Mathieu Hofman>
right and we only considered it because R/T are immutable

[22:23:51.0803] <bakkot>
the value of `unsafe` blocks is definitely much lessened if `unsafe`-ness is not part of the type system. we could make it so, though? in the sense of, functions could be tagged with `unsafe`-ness, which is on by default if you use `unsafe {}` blocks, and then have some explicit mechanism for saying "this function uses an `unsafe` block but is actually safe"

[22:24:09.0611] <bakkot>
and if you call an `unsafe` function and do not have `unsafe {}` in your call stack then it throws

[22:24:21.0231] <bakkot>
disclaimer, I have not thought about this idea for more than 30 seconds

[22:25:03.0790] <rkirsling>
one concern that immediately rises in my mind (thinking about the cross-language notion of `unsafe`) is:
is this the only thing we'd ever want `unsafe` to _mean_ in JS?

[22:25:12.0918] <rkirsling>
 * one concern that immediately rises in my mind (thinking about the cross-language use of `unsafe`) is:
is this the only thing we'd ever want `unsafe` to _mean_ in JS?

[22:25:19.0469] <rkirsling>
 * one concern that immediately rises in my mind (thinking about the cross-language use of a `unsafe` keyword) is:
is this the only thing we'd ever want `unsafe` to _mean_ in JS?

[22:25:28.0315] <rbuckton>
> <@bakkot:matrix.org> and if you call an `unsafe` function and do not have `unsafe {}` in your call stack then it throws

This becomes function coloring, which makes things even more complicated.

[22:25:40.0024] <shu>
yeah other names have been proposed, like `volatile`, i think?

[22:25:42.0086] <bakkot>
yes, but with a way to opt-out, which matters a lot

[22:25:42.0604] <rkirsling>
 * one concern that immediately rises in my mind (thinking about the cross-language use of an `unsafe` keyword) is:
is this the only thing we'd ever want `unsafe` to _mean_ in JS?

[22:25:42.0704] <shu>
re: "unsafe"

[22:25:52.0701] <bakkot>
the reason `async` is annoying is because you can't go from async to sync

[22:25:54.0895] <bakkot>
and here you could

[22:25:55.0223] <Mathieu Hofman>
> <@bakkot:matrix.org> and if you call an `unsafe` function and do not have `unsafe {}` in your call stack then it throws

you're describing function coloring

[22:26:04.0576] <rbuckton>
`unsafe {}` isn't necessary at all for shared memory semantics, it is purely a guardrail to discourage unintended misuse

[22:27:02.0705] <bakkot>
function coloring is annoying only because you can't use async from sync. here you could as long as you explicitly opt in to enforcing the invariants yourself.

[22:27:02.0911] <rkirsling>
I do like `volatile`, maybe. either way I'm glad to here that naming is being thought of

[22:27:07.0832] <rkirsling>
 * I do like `volatile`, maybe. either way I'm glad to hear that naming is being thought of

[22:27:19.0560] <rbuckton>
> <@shuyuguo:matrix.org> yeah other names have been proposed, like `volatile`, i think?

Yes, `volatile {}` was a suggestion from the TypeScript team as an alternative, and we're welcome to discussing others if there is a better option.

[22:27:24.0823] <Bradford Smith>
Personal take: The benefit of private fields is guaranteed encapsulation. I see the reverse WeakMap used to implement it to be an unfortunate implementation detail, not something to take advantage of. I would expect and hope that 99% of developers will not even be aware of it. Given that, it would be really weird if you could add private fields to structs after construction - which are supposed to be of a fixed shape.

[22:27:47.0537] <Mathieu Hofman>
You also basically end up with a 1 bit dynamic scoping for unsafeness of the call

[22:30:26.0218] <rbuckton>
ljharb: (a) is mostly figured out amongst the stakeholders, and we believe (b), (c), and (d) will not significantly impact whether this proposal will advance beyond stage 2. (b) could obviously have some limitations in the long term.

[22:31:10.0674] <nicolo-ribaudo>
What does "contamination" mean in this case? Isn't it solved by "no function coloring"?

[22:31:27.0977] <rbuckton>
I don't understand what "contamination" means here

[22:31:42.0584] <rbuckton>
`unsafe` is very local, it doesn't spread virally like `async`/`await`.

[22:31:58.0675] <Justin Ridgewell>
Does it need to be unsafe blocks?

[22:32:28.0916] <Justin Ridgewell>
Could it be `Reflect.getUnsafe()` and have it be explicit accesses without carrying a bit throughout the spec and ecosystem

[22:32:40.0639] <danielrosenwasser>
Is `accessor` allowed in a `shared struct`? Can I just avoid `unsafe` with that?

[22:33:15.0767] <rbuckton>
That level of indirection would be a major performance bottleneck for a performance-critical feature.

[22:34:23.0198] <rbuckton>
> <@rbuckton:matrix.org> That level of indirection would be a major performance bottleneck for a performance-critical feature.

This was in response to `Reflect.getUnsafe()`

[22:34:36.0718] <rkirsling>
I don't feel like it's that rare for a Stage 2 proposal to die...?

[22:34:47.0912] <rkirsling>
am I crazy

[22:34:52.0857] <Mathieu Hofman>
R/T comes to mind

[22:35:19.0677] <rkirsling>
I don't want R/T to be dead though üò≠

[22:35:47.0723] <bakkot>
i gotta say, given that we can already do `sharedArrayBuffer[0] = 42` wherever we want, I really do not understand the hard constraint of `unsafe` blocks from mark

[22:36:05.0765] <bakkot>
like, yes, it would be nice to have some help from the language to call out when there's spooky stuff happening

[22:36:09.0119] <bakkot>
but we already do not have that

[22:36:23.0837] <ljharb>
> <@rkirsling:matrix.org> I don't want R/T to be dead though üò≠

then convince the browsers to make new primitives

[22:36:23.0954] <Justin Ridgewell>
> <@rbuckton:matrix.org> This was in response to `Reflect.getUnsafe()`

How is it a level of indirection, this can be optimized the same as `foo.bar`

[22:36:38.0485] <ljharb>
> <@rkirsling:matrix.org> I don't want R/T to be dead though üò≠

 * then convince the browsers to make new primitives (ie, convince that the adoption and value will be sufficient to be worth the work)

[22:36:58.0403] <yulia>
congrats on stage 2 shu 

[22:37:09.0406] <shu>
thank you but why am i so unhappy

[22:37:18.0485] <Mathieu Hofman>
> <@bakkot:matrix.org> i gotta say, given that we can already do `sharedArrayBuffer[0] = 42` wherever we want, I really do not understand the hard constraint of `unsafe` blocks from mark

object access with different kind of values is very different in usage from a SAB, which may be denied from the environment (API not syntax)

[22:37:32.0020] <rkirsling>
> <@shuyuguo:matrix.org> thank you but why am i so unhappy

"snapshots of TC39"

[22:37:36.0872] <yulia>
> <@shuyuguo:matrix.org> thank you but why am i so unhappy

yeah that was a rough one, but i believe the landscape is workable

[22:37:49.0671] <yulia>
and shared memory will happen, having support for it in JS is important and this is the right shape

[22:37:52.0764] <rbuckton>
> <@jridgewell:matrix.org> How is it a level of indirection, this can be optimized the same as `foo.bar`

Even if it can, I don't really want to write `Reflect.getUnsafe(Reflect.getUnsafe(x, "y"), "z")` on a regular basis, that's terrible DX. 

[22:37:59.0116] <bakkot>
> <@mhofman:matrix.org> object access with different kind of values is very different in usage from a SAB, which may be denied from the environment (API not syntax)

I am OK with making these deniable in the environment, if that's the concern? have like a `SharedStruct` which everyone needs to extend and which can be deleted

[22:38:06.0930] <bakkot>
> <@mhofman:matrix.org> object access with different kind of values is very different in usage from a SAB, which may be denied from the environment (API not syntax)

 * I am OK with making these deniable in the environment, if that's the concern? have like a `SharedStruct` which every shared struct needs to extend and which can be deleted

[22:38:20.0554] <shu>
oh i didn't think about that as a way to deny syntax, that's interesting

[22:38:24.0695] <bakkot>
does that solve the problem for you?

[22:38:49.0796] <rbuckton>
> <@bakkot:matrix.org> I am OK with making these deniable in the environment, if that's the concern? have like a `SharedStruct` which every shared struct needs to extend and which can be deleted

In the stakeholders call we have discussed deniability in the environment just being that you can't actually share the value across agents.

[22:38:53.0532] <Justin Ridgewell>
> <@rbuckton:matrix.org> Even if it can, I don't really want to write `Reflect.getUnsafe(Reflect.getUnsafe(x, "y"), "z")` on a regular basis, that's terrible DX. 

I don‚Äôt really wanna write `unsafe {}` everywhere either

[22:39:11.0435] <bakkot>
or just like when a `shared struct` is evaluated it checks `globalThis.canMakeSharedStructs` and then if you want to turn that off you make that nonwritable-nonconfigurable `false`

[22:39:12.0824] <rbuckton>
> <@jridgewell:matrix.org> I don‚Äôt really wanna write `unsafe {}` everywhere either

Neither do I, but its far more convenient than `Reflect.getUnsafe()`.

[22:39:15.0076] <bakkot>
or... several other options

[22:39:29.0863] <ljharb>
> <@bakkot:matrix.org> or just like when a `shared struct` is evaluated it checks `globalThis.canMakeSharedStructs` and then if you want to turn that off you make that nonwritable-nonconfigurable `false`

*laughs in GIL*

[22:39:31.0725] <bakkot>
denying `postMessage` and similar sharing-across-agent capabilities works just as well, yes

[22:39:50.0589] <yulia>
can we do unsafe functionName () {} and just make it like async/await? (not a serious suggestion)

[22:40:08.0806] <Justin Ridgewell>
> <@rbuckton:matrix.org> Neither do I, but its far more convenient than `Reflect.getUnsafe()`.

We need JSSugar to automatically transpile gets/sets into `getUnsafe()`

[22:40:13.0428] <bakkot>
(anyway I really really gotta go to sleep, will read messages in the morning and leave transcription bot running for now, later all)

[22:40:14.0716] <ljharb>
> <@bakkot:matrix.org> or just like when a `shared struct` is evaluated it checks `globalThis.canMakeSharedStructs` and then if you want to turn that off you make that nonwritable-nonconfigurable `false`

 * _laughs in python's GIL_

[22:40:34.0453] <rbuckton>
> <@yulia:mozilla.org> can we do unsafe functionName () {} and just make it like async/await? (not a serious suggestion)

I did propose this, but not like async/await, more as a way to avoid doubly nested blocks. Alternatively, `function foo() unsafe {}`

[22:40:54.0081] <rbuckton>
Keep in mind that unlike async/await, `unsafe` does not spread virally to your callers

[22:41:08.0760] <ljharb>
i mean, async/await doesn't directly do that either

[22:41:13.0192] <ljharb>
only indirectly by returning a promise

[22:41:21.0144] <yulia>
async/await results in very viscous refactoring situations

[22:41:28.0440] <littledan>
I think it‚Äôs good that our process allows significant questions to be open during Stage 2. It would be bad if champions were incentivized to hide debates until later. But more importantly, the signal to invest significantly in a proposal is important to be able to dedicate the work to solve the problem.

[22:41:34.0147] <rbuckton>
> <@ljharb:matrix.org> i mean, async/await doesn't directly do that either

In any meaningful way, it does. 

[22:41:35.0746] <yulia>
you have to update all callers, or end up with a fire and forget situation

[22:41:41.0658] <Justin Ridgewell>
> <@rbuckton:matrix.org> I did propose this, but not like async/await, more as a way to avoid doubly nested blocks. Alternatively, `function foo() unsafe {}`

Is @waldemarh:matrix.org's concern that `unsafe` exists as a concept, or that it‚Äôs implemented as a block?

[22:41:45.0359] <yulia>
so yeah unsafe would not be that viscuous

[22:41:55.0424] <Justin Ridgewell>
If the second, than unsafe functions don‚Äôt really solve it.

[22:42:06.0937] <waldemar>
> <@rbuckton:matrix.org> I don't understand what "contamination" means here

`unsafe` will contaminate generic abstractions and algorithms, which will be pressured to wrap themselves inside `unsafe` blocks just so that folks can pass shared structs into them. Most don't really care about consistency and we already have the same problem with accessors, callbacs, and proxies. Wrapping one of these in `unsafe` will just become boilerplate practice.

[22:42:41.0192] <yulia>
the function solution would be implemented the same way as the block, and would have the same complexity concern i had earlier, which is why i wasn't so serious with it

[22:43:07.0700] <yulia>
so its not really a solution, we would need something else, that doesn't require marking the get/set with a flag

[22:43:12.0686] <shu>
waldemar: yulia: Mathieu Hofman (i can't find mark in this channel) ljharb PTAL at the conclusions in the notes to see if it's explicit enough for your liking

[22:43:18.0248] <Justin Ridgewell>
* If the second, then unsafe functions don‚Äôt really solve it.

[22:43:21.0985] <rbuckton>
> <@waldemarh:matrix.org> `unsafe` will contaminate generic abstractions and algorithms, which will be pressured to wrap themselves inside `unsafe` blocks just so that folks can pass shared structs into them. Most don't really care about consistency and we already have the same problem with accessors, callbacs, and proxies. Wrapping one of these in `unsafe` will just become boilerplate practice.

shared memory multithreading is more of a power-user feature, I doubt every npm package is going to start enclosing their sources in `unsafe {}` at the top level as a workaround. That's just bad practice.

[22:44:19.0431] <rbuckton>
And it should be discouraged.

[22:44:44.0019] <Mathieu Hofman>
> <@waldemarh:matrix.org> `unsafe` will contaminate generic abstractions and algorithms, which will be pressured to wrap themselves inside `unsafe` blocks just so that folks can pass shared structs into them. Most don't really care about consistency and we already have the same problem with accessors, callbacs, and proxies. Wrapping one of these in `unsafe` will just become boilerplate practice.

But generic abstractions and algorithms shouldn't be unsafely dealing with shared structs, that's the point. They are likely not able to operate generically on the object.

[22:45:06.0828] <rbuckton>
I would encourage anyone who has interest or concerns in the shared structs proposal to join our regularly scheduled stakeholders calls, we've been making a lot of positive progress in all areas.

[22:46:21.0225] <waldemar>
> <@rbuckton:matrix.org> shared memory multithreading is more of a power-user feature, I doubt every npm package is going to start enclosing their sources in `unsafe {}` at the top level as a workaround. That's just bad practice.

We have no viable story for how to handle abstractions that apply to unshared structs.

[22:46:43.0777] <waldemar>
> <@rbuckton:matrix.org> shared memory multithreading is more of a power-user feature, I doubt every npm package is going to start enclosing their sources in `unsafe {}` at the top level as a workaround. That's just bad practice.

 * We have no viable story for how to handle abstractions that apply to shared structs.

[22:47:55.0687] <waldemar>
How do you tell an abstraction that can apply to both shared and unshared structs that this usage is safe and that usage is unsafe?

[22:48:41.0113] <Mathieu Hofman>
To be honest the only thing I can think of (besides unsafe blocks) to enable correct shared fields access is to only allow private shared fields, which would require methods / accessors

[22:49:06.0919] <ljharb>
that would give you immutable structs right out of the gate, no?

[22:49:15.0997] <shu>
> <@rbuckton:matrix.org> I would encourage anyone who has interest or concerns in the shared structs proposal to join our regularly scheduled stakeholders calls, we've been making a lot of positive progress in all areas.

important to call this out ^^

[22:49:29.0701] <Mathieu Hofman>
> <@waldemarh:matrix.org> How do you tell an abstraction that can apply to both shared and unshared structs that this usage is safe and that usage is unsafe?

What abstractions do you imagine can safely but non explicitly deal with shared memory access ?

[22:49:32.0700] <waldemar>
> <@mhofman:matrix.org> But generic abstractions and algorithms shouldn't be unsafely dealing with shared structs, that's the point. They are likely not able to operate generically on the object.

Many, if not most, can and should. Almost the same problem already arises with getters, setters, proxies, callbacks mutating state, etc.

[22:49:52.0730] <rbuckton>
> <@ljharb:matrix.org> that would give you immutable structs right out of the gate, no?

"immutable" if you squint hard. 

[22:49:57.0631] <shu>
reading the back log, i agree with Mathieu Hofman that return override w/ private field stamping really really should not rise to the level of a design invariant that consciously aim to keep

[22:50:15.0668] <ljharb>
> <@rbuckton:matrix.org> "immutable" if you squint hard.

lol i mean, a shared struct with no setters, then, would be immutable from without at least?

[22:50:41.0005] <rbuckton>
Yes, I picked up on that.

[22:50:56.0446] <waldemar>
In practice there is very little delta between the mischief shared objects can get into and what ordinary callbacks, accessors, proxies, etc. can do.

[22:51:22.0078] <waldemar>
The differences are primarily of interest to experts, not causal users.

[22:51:37.0454] <waldemar>
 * The differences are primarily of interest to experts, not casual users.

[22:51:48.0808] <shu>
> <@waldemarh:matrix.org> In practice there is very little delta between the mischief shared objects can get into and what ordinary callbacks, accessors, proxies, etc. can do.

i agree, but i also don't know how to address mark's requirement that the app-wide opt-in/out switch like COOP/COEP is insufficient

[22:52:02.0522] <Mathieu Hofman>
yet somehow shared memory programs have a lot more race type bugs than async or callback code

[22:52:05.0008] <waldemar>
> <@shuyuguo:matrix.org> i agree, but i also don't know how to address mark's requirement that the app-wide opt-in/out switch like COOP/COEP is insufficient

I don't either.

[22:52:37.0449] <waldemar>
> <@mhofman:matrix.org> yet somehow shared memory programs have a lot more race type bugs than async or callback code

They do. Unsafe blocks won't fix that.

[22:52:49.0606] <rbuckton>
I'd rather not have `unsafe {}`, to be honest. But I'd rather have `unsafe {}` if that means we can get usable shared memory multithreading. I'm open to other suggestions so long as they don't negatively impact performance in a meaningful way.

[22:53:17.0219] <shu>
though i don't think we've fully engaged with bakkot's idea that there _be_ a programmatic way to deny shared structs, even if they're syntax?

[22:56:01.0188] <rbuckton>
Given that JS has proxies and getters, any property access could conceivably change underneath you.

[22:56:17.0474] <shu>
waldemar: is it a fair characterization to say your skepticism of unsafe {} boils down to SABs already must be grandfathered in, so it's a false guardrail?

[22:56:29.0336] <shu>
+ what you said about getters/setters/proxies etc

[22:56:45.0511] <shu>
wtf is wrong with matrix

[22:56:48.0093] <rbuckton>
Also, its possible to write abstractions that work with shared and unshared objects equally, so long as they do so through callbacks since those callbacks can be lexically scoped within an `unsafe {}` block.

[22:56:56.0638] <shu>
if i start a message with a `+` it turns it into a `-` and then a bullet point??

[22:57:06.0980] <ryzokuken>
> <@shuyuguo:matrix.org> wtf is wrong with matrix

markdown

[22:57:33.0582] <yulia>
> <@shuyuguo:matrix.org> though i don't think we've fully engaged with bakkot's idea that there _be_ a programmatic way to deny shared structs, even if they're syntax?

yeah im interested in this can we expand on it?

[22:58:47.0617] <shu>
i'm not sure if it actually addresses agoric's concerns though, should ask

[23:03:02.0154] <waldemar>
> <@shuyuguo:matrix.org> waldemar: is it a fair characterization to say your skepticism of unsafe {} boils down to SABs already must be grandfathered in, so it's a false guardrail?

That's part of it. A bigger part is that:
- unsafe blocks will contaminate generic code merely because someone wants to use it with shared structs
- we don't have a story for how to indicate which user API calls are safe and which are unsafe, so it's a false guardrail.

[23:03:18.0386] <Mathieu Hofman>
> <@shuyuguo:matrix.org> i'm not sure if it actually addresses agoric's concerns though, should ask

Mark is there with you, time to chat with him ;_)

[23:03:23.0649] <Mathieu Hofman>
> <@shuyuguo:matrix.org> i'm not sure if it actually addresses agoric's concerns though, should ask

 * Mark is there with you, time to chat with him ;)

[23:05:13.0368] <nicolo-ribaudo>
How does `unsafe` work in Rust? I know that it's a different type of unsafe, but I assume some of the same concerns about "virality" and "false guardrail" still apply?

[23:06:58.0176] <rbuckton>
Rust has a borrow checker and full type system, so it can enforce the guardrail via the API

[23:07:29.0180] <rbuckton>
In JS, we have "call your function `fooUnsafe()`"

[23:07:36.0014] <rbuckton>
 * In JS, we have "name your function `fooUnsafe()`"

[23:07:47.0357] <nicolo-ribaudo>
Re the "everybody would use unsafe just to be sure", maybe instead of `unsafe` we can use a different property access operator. e.g. `obj.foo` only works for non-shared objects, and `obj‚ö†Ô∏è.foo` would only work fore shared structs

[23:08:11.0793] <nicolo-ribaudo>
So you cannot use it "just in case", and if you want to write code that works with both you have to introduce your own abstractions

[23:08:35.0161] <nicolo-ribaudo>
 * Re the "everybody would use unsafe just to be sure", maybe instead of `unsafe` we can use a different property access operator. e.g. `obj.foo` only works for non-shared objects, and `obj‚ö†Ô∏è.foo` would only work for shared structs

[23:10:52.0356] <nicolo-ribaudo>
> <@rbuckton:matrix.org> In JS, we have "name your function `fooUnsafe()`"

This seems to be an argument for actually introducing "unsafe functions", and making it a new colour

[23:11:18.0416] <danielrosenwasser>
> <@nicolo-ribaudo:matrix.org> How does `unsafe` work in Rust? I know that it's a different type of unsafe, but I assume some of the same concerns about "virality" and "false guardrail" still apply?

From [here](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html):

> To switch to unsafe Rust, use the unsafe keyword and then start a new block that holds the unsafe code. You can take five actions in unsafe Rust that you can‚Äôt in safe Rust, which we call unsafe superpowers. Those superpowers include the ability to:
>
> - Dereference a raw pointer
> - Call an unsafe function or method
> - Access or modify a mutable static variable
> - Implement an unsafe trait
> - Access fields of a union

So my understanding is that basically expressions allowed in an unsafe context are:

> - Dereference a raw pointer
> - Access or modify a mutable static variable
> - Call an unsafe function or method
> - Access fields of a union

The other two are basically markers at the declaration site, and they push the work onto the caller to either contain the code in an `unsafe` block, or mark the containing function as unsafe. Because you have both options, function coloring isn't mandatory.

[23:12:08.0469] <danielrosenwasser>
> <@nicolo-ribaudo:matrix.org> How does `unsafe` work in Rust? I know that it's a different type of unsafe, but I assume some of the same concerns about "virality" and "false guardrail" still apply?

 * From [here](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html):

> To switch to unsafe Rust, use the unsafe keyword and then start a new block that holds the unsafe code. You can take five actions in unsafe Rust that you can‚Äôt in safe Rust, which we call unsafe superpowers. Those superpowers include the ability to:
> 
> - Dereference a raw pointer
> - Call an unsafe function or method
> - Access or modify a mutable static variable
> - Implement an unsafe trait
> - Access fields of a union

So my understanding is that basically the operations allowed in an unsafe expression context are:

> - Dereference a raw pointer
> - Access or modify a mutable static variable
> - Call an unsafe function or method
> - Access fields of a union

The other two are basically markers at the declaration site, and they push the work onto the caller to either contain the code in an `unsafe` block, or mark the containing function as unsafe. Because you have both options, function coloring isn't mandatory.

[23:13:24.0189] <nicolo-ribaudo>
It sounds much more similar to the one proposed for shared structs than I expected! "Access fields of a union" is kinda like our use case, even if it's unsafe for different reasons

[23:13:57.0619] <nicolo-ribaudo>
But the difference is that whether you need unsafe or not is not determined by your caller, because as Ron said there is a type checker

[23:17:19.0057] <rkirsling>
now entering the spice zone

[23:17:43.0159] <rkirsling>
super appreciative of that disclaimer actually

[23:17:44.0957] <Chris de Almeida>
the first rule of spice club...

[23:18:05.0153] <Ben>
everyone, please, it is crucial to walk without rhythm while in the spice zone

[23:29:51.0843] <nicolo-ribaudo>
I'm curious about that logical assignment CVE

[23:30:12.0331] <nicolo-ribaudo>
Isn't it something that can be implemented just in the bytecode emitter, relying on existing ops?

[23:30:13.0393] <rkirsling>
I looked that one up too because it blew my mind

[23:30:23.0853] <Michael Ficarra>
I want to know what portion of these CVEs would have been impossible had they been implemented in a memory safe language

[23:30:25.0326] <rkirsling>
it was specific to SM's initial implementation 

[23:30:56.0272] <ljharb>
> <@michaelficarra:matrix.org> I want to know what portion of these CVEs would have been impossible had they been implemented in a memory safe language

esp given the v8 team's pushback to openssf on switching to one

[23:31:31.0233] <Michael Ficarra>
Obviously "more C++ code" means "more memory bugs". That does not mean we should do less language development. It means that we should write less C++ code.

[23:31:35.0773] <yulia>
> <@michaelficarra:matrix.org> I want to know what portion of these CVEs would have been impossible had they been implemented in a memory safe language

We tried implementing the parser in rust, but ran into performance issues

[23:32:12.0452] <yulia>
rust isn't as heavily optimized yet, and also certain areas of the engine such as garbage collection don't really work in rust

[23:32:13.0904] <nicolo-ribaudo>
Maybe we could just write engines in JS and compile them to native with Porffor

[23:32:17.0322] <Michael Ficarra>
oh I didn't realise performance was more important than security

[23:32:36.0438] <yulia>
if it wasn't a balance, we would not have jits.

[23:33:27.0404] <ryzokuken>
> <@nicolo-ribaudo:matrix.org> Maybe we could just write engines in JS and compile them to native with Porffor

I mean if this isn't Torque idk what is

[23:35:02.0676] <yulia>
we are trying to approach this in an open way, so that we can come to a solution together. The vast majority of monetary investment, in making JS work, is on implementers shoulders. Being told to stop complaining and that our concerns are invalid is not a way forward. We, as equal delegates, can just say no to all features going forward. We aren't doing that, instead we are inviting dialogue.

[23:35:17.0536] <yulia>
 * we are trying to approach this in an open way, so that we can come to a solution together. The vast majority of monetary investment, in making JS work, is on implementers shoulders. As is the risk, and responsibility when things go wrong. Being told to stop complaining and that our concerns are invalid is not a way forward. We, as equal delegates, can just say no to all features going forward. We aren't doing that, instead we are inviting dialogue.

[23:35:51.0977] <yulia>
also, JSSugar is one solution, coming from v8 -- not all of the vendors are aligned on it

[23:36:17.0288] <yulia>
I personally see another, more powerful way forward that will enable language evolution

[23:36:35.0482] <yulia>
 * I personally see another way forward, tackling a different surface, that will enable language evolution

[23:36:46.0918] <Michael Ficarra>
Oh totally agreed, and I'm actually really supportive of the JSSugar approach. I just don't buy the security motivation basically at all.

[23:37:26.0833] <Andreu Botella (at TC39, üïê JST)>
browser vendors aren't the only implementers

[23:37:45.0685] <yulia>
I didn't speak of browsers, but implementers. Moddable is a cosigner

[23:38:16.0114] <Michael Ficarra>
And I'm also really bitter that browsers (and OS vendors) continue to write more code in a memory-unsafe language that I have to run on my computer.

[23:39:15.0096] <yulia>
well, if we make some really radical moves maybe we can make it more feasible to do 1) more of the language in memory safe languages regardless of the browser engine, and 2) allow more competitors 

[23:39:33.0436] <yulia>
let's talk about it after because its a big idea that won't be discussed now (im still talking to stakeholders about it)

[23:40:21.0922] <Andreu Botella (at TC39, üïê JST)>
> <@yulia:mozilla.org> I didn't speak of browsers, but implementers. Moddable is a cosigner

Okay, I meant vendors, not specifically browser vendors. Igalia is an implementer who works on engines built by other vendors. Although we're probably in a unique position

[23:40:30.0973] <yulia>
some parts, at least at present (GC in particular) aren't feasible in a safe language, just because of what you are doing 

[23:40:53.0325] <yulia>
 * some parts, at least at present (GC in particular) aren't feasible (right now) in a safe language, just because of what you are doing 

[23:41:06.0580] <rkirsling>
> <@abotella:igalia.com> Okay, I meant vendors, not specifically browser vendors. Igalia is an implementer who works on engines built by other vendors. Although we're probably in a unique position

hey, I co-signed as a JSC implementer from Sony ;)

[23:41:12.0821] <Marja H√∂ltt√§>
Michael Ficarra: the most chrome / v8 bugs are not because our C++ is doing memory management wrong, they are because we have a logic bug in generating machine code or because our invariants are extremely complex and one part might make a change which violates an invariant somewhere else. happy to talk more about this. interestingly, a huge proportion of the CVEs listed on shu's slide were in my code, and none of my bugs were because of C++, and would've happened even if V8 was written in a memory safe language.

[23:42:31.0776] <yulia>
also part of the context here is the unshippability of the things that we spec, see my upcoming presentation on species

[23:42:42.0039] <yulia>
species being one of the worst offenders from a sec perspective

[23:42:45.0486] <yulia>
and performance perspective

[23:42:48.0676] <Marja H√∂ltt√§>
the basic problem being: "logic bug in a normal application ->  typically a bug, not a security issue" whereas "logic bug in a compiler -> a security bug"

[23:43:16.0780] <keith_miller>
> <@marjakh:matrix.org> Michael Ficarra: the most chrome / v8 bugs are not because our C++ is doing memory management wrong, they are because we have a logic bug in generating machine code or because our invariants are extremely complex and one part might make a change which violates an invariant somewhere else. happy to talk more about this. interestingly, a huge proportion of the CVEs listed on shu's slide were in my code, and none of my bugs were because of C++, and would've happened even if V8 was written in a memory safe language.

100% agreed almost none of them are out of bounds memory accesses. Some of them are UAFs but most memory safe languages wouldn't solve the ones as they're GC related.

[23:43:31.0244] <keith_miller>
> <@marjakh:matrix.org> Michael Ficarra: the most chrome / v8 bugs are not because our C++ is doing memory management wrong, they are because we have a logic bug in generating machine code or because our invariants are extremely complex and one part might make a change which violates an invariant somewhere else. happy to talk more about this. interestingly, a huge proportion of the CVEs listed on shu's slide were in my code, and none of my bugs were because of C++, and would've happened even if V8 was written in a memory safe language.

 * 100% agreed almost none of them are out of bounds memory accesses. Some of them are UAFs but most memory safe languages wouldn't solve those ones as they're GC related.

[23:43:56.0845] <Michael Ficarra>
> <@yulia:mozilla.org> also part of the context here is the unshippability of the things that we spec, see my upcoming presentation on species

Do you think that's something we still risk today with our current stage process?

[23:44:03.0674] <keith_miller>
For the most part they're because generated machine code is just wrong

[23:44:39.0129] <yulia>
> <@michaelficarra:matrix.org> Do you think that's something we still risk today with our current stage process?

yes, as bigint went through the process, and it is one of the other major offenders 

[23:44:47.0424] <Michael Ficarra>
okay then maybe JITs are the real evil

[23:44:49.0671] <keith_miller>
So you'd have to have a proof-carrying compiler, which is, AFAIK, still mostly in academia only

[23:45:14.0551] <yulia>
no disagreement that the performance requirements of the web also drive complexity

[23:45:32.0832] <rkirsling>
> <@michaelficarra:matrix.org> okay then maybe JITs are the real evil

a necessary, ingenious sort of evil, yeah

[23:45:33.0066] <yulia>
however, moddable which has a much simpler implementation has also had similar issues. it is not browser only

[23:45:38.0805] <canadahonk>
> <@keith_miller:matrix.org> So you'd have to have a proof-carrying compiler, which is, AFAIK, still mostly in academia only

something something wasm kind of somewhat does this?

[23:45:45.0326] <rkirsling>
(we have JIT totally disabled on PS for security reasons)

[23:46:02.0415] <yulia>
 * however, moddable which has a much simpler implementation has also had similar issues. it is not browser/jit only

[23:46:06.0960] <keith_miller>
> <@canadahonk:matrix.org> something something wasm kind of somewhat does this?

No, it passes it off to the wasm runtime

[23:46:17.0742] <rkirsling>
(it was a HUGE attack surface on PS4)

[23:46:27.0249] <Michael Ficarra>
@keith_miller:matrix.org yeah but it's a much smaller language at that point

[23:47:09.0837] <Michael Ficarra>
> <@rkirsling:matrix.org> (it was a HUGE attack surface on PS4)

I want to see your PS4 threat model. Who is the adversary? Games publishers?

[23:47:25.0677] <ryzokuken>
crackers maybe?

[23:47:40.0892] <rkirsling>
I am not a security expert

[23:47:56.0801] <rkirsling>
I just know that there were whole twitter accounts dedicated to it

[23:48:56.0651] <Rob Palmer>
I assume this slide on "The bar" is a logical OR rather than AND

[23:49:16.0350] <canadahonk>
> <@rkirsling:matrix.org> (we have JIT totally disabled on PS for security reasons)

(this is one of the use-cases for porffor btw ;))

[23:49:19.0019] <nicolo-ribaudo>
Rob it's the implication symbol

[00:01:14.0217] <hax (HE Shi-Jun)>
I lost connection and after reconnect I can't see the shared screen, does anyone have similar issue?

[00:01:42.0530] <jkup>
This happened to me earlier but after a minute I could see it again

[00:02:10.0132] <hax (HE Shi-Jun)>
> <@jkup:matrix.org> This happened to me earlier but after a minute I could see it again

thank u, so let me wait a minute :P

[00:02:24.0096] <hax (HE Shi-Jun)>
yeah, it comes back

[00:07:53.0424] <hax (HE Shi-Jun)>

I guess runtimes can bake it, eg. deno/nodejs? 

[00:09:55.0797] <nicolo-ribaudo>
> <@haxjs:matrix.org> I guess runtimes can bake it, eg. deno/nodejs?

Yeah, I would hope we don't make it illegal to implement JSSugar in engines, just optional

[00:10:04.0198] <nicolo-ribaudo>
> <@haxjs:matrix.org> I guess runtimes can bake it, eg. deno/nodejs?

 * Yeah, I would hope we wouldn't make it illegal to implement JSSugar in engines, just optional

[00:11:36.0226] <yulia>
waldemar: sorry i couldn't respond fast enough: the problem statement is very broad, and we so far haven't addressed the point that you made, so if you have any ideas on this they are very very welcome

[00:11:52.0998] <yulia>
maybe we can talk async about it

[00:13:20.0156] <waldemar>
I'm unhappy about the framing of this as a tension between users, developers, and implementors. In most cases we can reduce complexity for all three; existing complexity is a result of past decisions that benefited none of these three.

[00:15:49.0081] <Chris de Almeida>
I'm trying to keep an open mind, but at the end of the day this forks the language and I would just not use the sugar features.  yes people use tooling but not exclusively all the time, and a lot of workflows rely on the language being available directly in the browser

[00:16:09.0126] <yulia>
> <@waldemarh:matrix.org> I'm unhappy about the framing of this as a tension between users, developers, and implementors. In most cases we can reduce complexity for all three; existing complexity is a result of past decisions that benefited none of these three.

thats certainly the case for something like species, but bigint is an independent proposal that had a similar effect

[00:16:31.0596] <canadahonk>
> <@waldemarh:matrix.org> I'm unhappy about the framing of this as a tension between users, developers, and implementors. In most cases we can reduce complexity for all three; existing complexity is a result of past decisions that benefited none of these three.

yeah I think the (probably unintended) us vs them framing of the slides is my biggest problem with it personally

[00:16:52.0315] <yulia>
On the other hand, something like nullish coallescing resulted in _more efficient_ code in the end, but (for firefox) we had users who suffered from stability

[00:17:17.0328] <yulia>
this is because syntax in particular is not forward compatible. you can't shim it, you have to transpile it. 

[00:17:44.0928] <yulia>
 * On the other hand, something like nullish coallescing resulted in _more efficient_ code in the end, but (for firefox) we had users who suffered from stability (in particular we had bugs coming in from users who could no longer load sites, but also couldn't update their browser)

[00:18:12.0993] <waldemar>
> <@yulia:mozilla.org> thats certainly the case for something like species, but bigint is an independent proposal that had a similar effect

A lot of folks are making points about low BigInt usage, but we'd be hurting if something like that weren't in the language ‚Äî it comes up rarely in APIs, but, when it does come up, hacking around the lack of BigInt would have made a bigger mess.

[00:18:25.0552] <rbuckton>
pipeline desugaring is a bad example because it's so dead simple

[00:19:26.0833] <Michael Ficarra>
> <@waldemarh:matrix.org> A lot of folks are making points about low BigInt usage, but we'd be hurting if something like that weren't in the language ‚Äî it comes up rarely in APIs, but, when it does come up, hacking around the lack of BigInt would have made a bigger mess.

Right, it's a coordination point, and the language is the responsible party for providing those.

[00:19:28.0361] <rbuckton>
```js
x = a |> b(%) |> %.c()
```
is just
```js
var _;
x = (_ = a, _ = b(_), _.c());
```

[00:19:29.0384] <Mathieu Hofman>
we use BigInt a LOT

[00:19:41.0412] <yulia>
> <@waldemarh:matrix.org> A lot of folks are making points about low BigInt usage, but we'd be hurting if something like that weren't in the language ‚Äî it comes up rarely in APIs, but, when it does come up, hacking around the lack of BigInt would have made a bigger mess.

this is certainly a benefit for a developer who is using BigInt, ideally you would only pay the price of the features you use

[00:19:52.0767] <yulia>
and i think there is a future where we could have that

[00:19:57.0012] <Mathieu Hofman>
I don't think any financial application could work without BigInt

[00:20:08.0684] <nicolo-ribaudo>
> <@yulia:mozilla.org> this is because syntax in particular is not forward compatible. you can't shim it, you have to transpile it.

How is this relevant? Those websites would have broken even if there was a missing runtime API. The developer would have still chosen to ship the polyfill for that browser version, similarly to how they could have shipped with the transpiled code

[00:20:17.0816] <rbuckton>
BigInt is also quite important to Azure

[00:20:33.0211] <Michael Ficarra>
> <@mhofman:matrix.org> I don't think any financial application could work without BigInt

that's a really broad statement

[00:21:05.0944] <Mathieu Hofman>
maybe it's not seen in the instrumentation of browsers, but there are a lot of backend use cases for BigInt

[00:21:12.0086] <yulia>
> <@nicolo-ribaudo:matrix.org> How is this relevant? Those websites would have broken even if there was a missing runtime API. The developer would have still chosen to ship the polyfill for that browser version, similarly to how they could have shipped with the transpiled code

shims are lightweight to ship, you can't ship a shim for syntax. it requires tooling, shims don't

[00:22:24.0122] <nicolo-ribaudo>
> <@yulia:mozilla.org> shims are lightweight to ship, you can't ship a shim for syntax. it requires tooling, shims don't

This presentation is based on the assumption that tooling is required anyway

[00:22:37.0746] <yulia>
the second half is, yes

[00:22:58.0256] <nicolo-ribaudo>
Oh, I'll be curious to hear the Mozilla proposed solution when it's ready

[00:23:02.0849] <yulia>
but that is v8's position, mozilla didn't co-sign that

[00:23:17.0323] <yulia>
not that JSSugar isn't a potential solution, we are just unsure about it

[00:23:21.0392] <ljharb>
> <@yulia:mozilla.org> thats certainly the case for something like species, but bigint is an independent proposal that had a similar effect

imo the reason bigint didn't get adoption is because it's not smoothly interoperable with Number, and thus only devs with bigint-specific use cases use bigints. which isn't many.

[00:23:32.0252] <yulia>
> <@nicolo-ribaudo:matrix.org> Oh, I'll be curious to hear the Mozilla proposed solution when it's ready

I'm working on getting the approval for it

[00:23:37.0703] <Chris de Almeida>
I don't have data to support this, but I really think the presentation overestimates the use of build/compilation tooling, and disregards the abundance of... not using those things, or in the same way

[00:23:52.0973] <rbuckton>
Tooling can't address `eval`, `new Function`, other evaluators, or `new RegExp()` which would need the tooling to be run _in browser_ to support these transformations. 

[00:24:13.0915] <yulia>
> <@nicolo-ribaudo:matrix.org> Oh, I'll be curious to hear the Mozilla proposed solution when it's ready

 * I'm working on getting the approval for it & roping in all of the stake holders, should come soon

[00:24:57.0648] <rbuckton>
It's already a problem when transpiling today.

[00:25:17.0510] <rkirsling>
> <@softwarechris:matrix.org> I don't have data to support this, but I really think the presentation overestimates the use of build/compilation tooling, and disregards the abundance of... not using those things, or in the same way

I would say that'd be my focal point of disagreement with the proposed solution

[00:25:24.0240] <rkirsling>
...as a co-signer of the first half

[00:26:24.0384] <Michael Ficarra>
> <@rbuckton:matrix.org> Tooling can't address `eval`, `new Function`, other evaluators, or `new RegExp()` which would need the tooling to be run _in browser_ to support these transformations. 

please don't do these things

[00:27:16.0891] <rbuckton>
> <@michaelficarra:matrix.org> please don't do these things

Would you be fine with RegExp syntax that works for `/.../` but not `new RegExp("...")`?

[00:28:15.0485] <Michael Ficarra>
I don't really care either way about regexp. Don't use eval or Function.

[00:28:47.0431] <rbuckton>
And the `eval` case was an important discussion point re: decorators raised by Mark Miller, so it's come up before in plenary.

[00:28:56.0798] <canadahonk>
`...` and `eval(...)` differing completely in support feels ü•¥

[00:29:16.0733] <Rob Palmer>
> <@softwarechris:matrix.org> I don't have data to support this, but I really think the presentation overestimates the use of build/compilation tooling, and disregards the abundance of... not using those things, or in the same way

The nuance that I feel like I've never managed to successfully communicate is that tooling is a spectrum but we usually frame it as a dichotomy.  Even folk that can't go tool-free benefit from tool-lite.  It's also about the % of scenarios that benefit from a % of features working tool-free.

[00:31:17.0139] <rbuckton>
> <@canadahonk:matrix.org> `...` and `eval(...)` differing completely in support feels ü•¥

You can sort of make it work, but it requires knowing the intricacies of the language. e.g., transpiling
```js
@decorator
class C {
}
```
and expecting `eval(C.toString())` to produce the same result won't work, but
```js
function f() {
  @decorator
  class C {
  }
  return C;
}
```
and `eval(f.toString())()` would purely because the function body would capture the entire transpiled result. It's a mess, so definitely not recommended.

[00:33:15.0479] <nicolo-ribaudo>
Node.js shipping a TS compiler is the proof that people hate using tooling

[00:33:19.0540] <Chengzhong Wu>
"Many people using tools" doesn't mean that "many people like using tools"

[00:35:38.0476] <rbuckton>
> <@nicolo-ribaudo:matrix.org> Node.js shipping a TS compiler is the proof that people hate using tooling

NodeJS would also like other TS features to come to JS so transpiling is less necessary (`enum`, parameter properties, etc.)

[00:37:37.0602] <littledan>
Yulia: Wasm is in scope for source maps. Considering other serializations is as well, though the group has decided so far that this type of efficiency isn‚Äôt the most pressing concern.

[00:38:14.0719] <yulia>
Source maps is just too heavy. it doesn't scale. WASM was using dwarf but there were issues with that as well (i believe for supporting all languages)

[00:38:32.0847] <Rob Palmer>
> <@nicolo-ribaudo:matrix.org> Node.js shipping a TS compiler is the proof that people hate using tooling

I would use a weaker word than "hate".

It's more about the hierarchy of abstractions - ideas > design patterns > tools > runtimes > language.  The more fundamental/essential the functionality, the more folk benefit from pushing it down the hierarchy to codify it and make it more accessible.  Folk like types being even more accessible.

[00:38:41.0067] <yulia>
I think that the current source maps group doesn't have any overlap with the WASM debugging wg, but the issue of debugging information in JS was part of that as well

[00:39:33.0009] <littledan>
We are definitely focusing on the mapping to Wasm from source maps. Are there any participants from the previous effort that we should recruit to join?

[00:39:57.0995] <yulia>
have you had fitzgen come by at all?

[00:40:16.0605] <yulia>
I don't know if he will have time but he was on both

[00:41:28.0368] <rbuckton>
Many if not most syntax proposals will require runtime functionality to work. `using` requires `Symbol.dispose`, pattern matching requires `Symbol.customMatcher` as methods on a number of built-ins, so a single feature requires changes to both JS0 and JSSugar.

[00:44:23.0824] <jkup>
> <@yulia:mozilla.org> have you had fitzgen come by at all?

Nope, not to any of our recent meetings at least! Would love it if he had time. For WASM the effort has mostly been lead by Kotlin, Chrome DevTools and Tauri so far.

[00:44:45.0525] <jkup>
> <@yulia:mozilla.org> have you had fitzgen come by at all?

 * Nope, not to any of our recent meetings at least! Would love it if he had time. For Wasm the effort has mostly been lead by Kotlin, Chrome DevTools and Tauri so far.

[00:45:19.0003] <keith_miller>
Why couldn't `using` be desuggared? `Symbol.dispose ??= Symbol{)` would be the init sequence for the shared symbol

[00:45:30.0523] <yulia>
So if you didn't have the history: we tried to standardize source maps before. That is what became the wasm debugging group

[00:46:05.0829] <rbuckton>
That's not the same as a built-in symbol, plus the `using` proposal has other API changes as well.

[00:46:09.0977] <keith_miller>
 * Why couldn't `using` be desuggared? `Symbol.dispose ??= Symbol()` would be the init sequence for the shared symbol

[00:46:24.0312] <jkup>
> <@yulia:mozilla.org> So if you didn't have the history: we tried to standardize source maps before. That is what became the wasm debugging group

Is this the group? https://github.com/WebAssembly/debugging (trying to catch up on the history here)

[00:46:28.0243] <yulia>
i'll see if i can get fitzgen to come, ill try to come by as well

[00:46:31.0771] <yulia>
yes thats it

[00:46:47.0534] <rbuckton>
TS will downlevel `using`, but expects the developer to supply the shim for runtime functionality.

[00:46:48.0370] <yulia>
it fell apart, it was mostly chrome that had time for it. yury on the sm team also has some of the history

[00:47:37.0446] <yulia>
 * it fell apart (maybe it started up again?), it was mostly chrome that had time for it. yury on the sm team also has some of the history

[00:47:37.0626] <rbuckton>
`using` may be a trivial example, but pattern matching is not. 

[00:47:42.0546] <ljharb>
that's a really good point. if eslint doesn't support syntax by default then users won't adopt it; if it's going to change, they won't support it

[00:47:47.0441] <ljharb>
 * that's a really good point. if eslint doesn't support syntax by default then users won't adopt it; if it's going to change, eslint won't support it

[00:47:53.0845] <hax (HE Shi-Jun)>
nicolo-ribaudo: I think we can cover Babel cost by forcing champion implement it in Babel üòâ 

[00:48:43.0142] <rkirsling>
the problem there is that Babel would become a singular blessed tool

[00:48:45.0473] <Michael Ficarra>
set up GoFundMes for TC39 proposals

[00:50:27.0714] <Michael Ficarra>
or just get the community to pay Igalia I guess

[00:51:55.0367] <shu>
the cost isn't in implementation

[00:51:59.0188] <shu>
the cost is maintenance in perpetuity

[00:52:13.0076] <ljharb>
given the current state of voluntary payments to "free" software projects that are important to society, i'm not optimistic about browser crowdfunding either

[00:52:46.0152] <ljharb>
 * given the current state of voluntary payments to "free" software projects that are important to society/security/humans, i'm not optimistic about browser crowdfunding either

[00:53:16.0578] <nicolo-ribaudo>
shu I understand that you don't want to "demote" any proposal, but it would be a good exercise to pretend that this presentation happened 5-10 years ago, and show how the current proposals would have evolved under this framing

[00:53:48.0738] <shu>
are you asking me to actively invite psychic damage to myself

[00:54:25.0565] <nicolo-ribaudo>
It's part of the cost of proposing such a big change :P

[00:55:18.0717] <hax (HE Shi-Jun)>
> <@rkirsling:matrix.org> the problem there is that Babel would become a singular blessed tool

So let's just ask champions to implement it in at least 2 or 3 or 4 tools as the requirements of stage 3?üòÖ

[00:56:22.0708] <Justin Ridgewell>
Does Mozilla not have someone attending TG2 meetings?

[00:57:11.0103] <ryzokuken>
> <@jridgewell:matrix.org> Does Mozilla not have someone attending TG2 meetings?

they do

[00:59:37.0558] <linusg>
> <@mhofman:matrix.org> maybe it's not seen in the instrumentation of browsers, but there are a lot of backend use cases for BigInt

Is there bigint instrumentation in browsers? I looked on chromestatus.com/metrics earlier and it doesn't seem to have any related counters

[01:04:01.0039] <rbuckton>
Is bit math still slower on BigInt compared Number? I've wanted to switch to bigint for some of our flags in the TS compiler, but we only recently changed our minimum target to one that supports bigint natively.

[01:08:39.0282] <Mathieu Hofman>
> <@rbuckton:matrix.org> Tooling can't address `eval`, `new Function`, other evaluators, or `new RegExp()` which would need the tooling to be run _in browser_ to support these transformations.

That was a point I wanted to raise on the queue. That or somehow admit that any dynamically evaluated code will have to be compiled ahead of time.

[01:09:31.0541] <Chris de Almeida>
shu: yulia I captured the queue for JSSugar.  do you want a continuation if we have time later?

[01:09:50.0809] <yulia>
I've already spoken with them, they are fine with it. But due to issues brought up from other parts of the web platform, regarding what TG2 has been standardizing, we are under heavier scrutiny. So, i'm just double checking with our internal stake holders.

[01:11:16.0663] <Mathieu Hofman>
> <@michaelficarra:matrix.org> I don't really care either way about regexp. Don't use eval or Function.

eval is not evil. there are ways to safely evaluate untrusted code.

[01:11:54.0061] <rbuckton>
> <@mhofman:matrix.org> eval is not evil. there are ways to safely evaluate untrusted code.

In a sandbox, out of process, on another machine...

[01:12:06.0232] <shu>
> <@softwarechris:matrix.org> shu: yulia I captured the queue for JSSugar.  do you want a continuation if we have time later?

sure, i want people to say their piece

[01:13:40.0384] <yulia>
I also reacted before seeing the issues, they look really minor

[01:14:01.0535] <yulia>
i honestly can't stress enough how having more time to review would help...

[01:14:45.0143] <nicolo-ribaudo>
I get excited whenever I see well organized data

[01:14:47.0147] <Ashley Claymore>
Maybe that proposal would have been split in two in the same way? Browsers initially only implement the Symbol and add implementations of the methods to the right web APIs. But the syntax part stays at JSSugar (at least initially)

[01:15:20.0593] <Ashley Claymore>
And then in the future Browsers implement the syntax part too when it's the right time for that to happen

[01:15:32.0070] <Chris de Almeida>
this is really cool... I know it's been a long day but...  üëÄ

[01:16:37.0059] <ljharb>
i'm also excited about the possibility of creating a polyfill for API things on-the-fly using es-abstract, so you can get an in-editor REPL for your spec change

[01:17:29.0129] <Mathieu Hofman>
> <@rbuckton:matrix.org> In a sandbox, out of process, on another machine...

no in the same process, either different realm (ShadowRealm) or even same realm (Compartment in hardened Realm). Salesforce uses realms, we use Compartments in production, and Moddable uses compartments too in their devices. Let's not claim there is no way to securely run 3rd party JS in the same process

[01:18:23.0788] <shu>
https://github.com/tc39/Reflector/issues/539

[01:19:39.0171] <rbuckton>
> <@mhofman:matrix.org> no in the same process, either different realm (ShadowRealm) or even same realm (Compartment in hardened Realm). Salesforce uses realms, we use Compartments in production, and Moddable uses compartments too in their devices. Let's not claim there is no way to securely run 3rd party JS in the same process

ShadowRealm and Compartment are sandboxes. I'm stating that any combination of the three are ways to safely eval.

[01:20:04.0148] <Mathieu Hofman>
Ah yes, I thought you asked for all 3 ;)

[01:20:50.0020] <rkirsling>
> <@shuyuguo:matrix.org> https://github.com/tc39/Reflector/issues/539

awesome, though it seems that I can't access it in its current state (maybe that's okay if it's still undergoing org transfer?)

[01:21:00.0786] <shu>
are you getting an error?

[01:21:04.0488] <shu>
ljharb: ^

[01:21:22.0556] <ljharb>
it should work fine. i'll check to make sure you're invited to the tc39-transfer org

[01:21:39.0986] <Mathieu Hofman>
It's a common reaction we hear from the browser implementors, but lots of production systems run untrusted JS code same process in some fashion.

[01:21:49.0258] <ljharb>
 * it should work fine. i'll check to make sure you're invited to the tc39-transfer org ‚Ä¶ invite sent.

[01:22:28.0520] <Mathieu Hofman>
 * It's a common reaction we hear from the browser implementors, but lots of production systems run untrusted JS code same process in some fashion, with some kind of sandbox of course

[01:22:31.0341] <rbuckton>
> <@mhofman:matrix.org> Ah yes, I thought you asked for all 3 ;)

out of process and on a separate machine are mutually exclusive

[01:23:10.0354] <ljharb>
if it's on a separate machine it's definitely out of process :-p

[01:23:14.0764] <rbuckton>
or maybe I should have clarified OOP (same machine)

[01:23:16.0872] <ljharb>
 * if it's on a separate machine it's definitely also out of process :-p

[01:23:21.0399] <Marja H√∂ltt√§>
Mathieu Hofman: what's the one-sentence summary wrt how they get around Spectre & co when running in the same process?

[01:24:02.0705] <Mathieu Hofman>
> <@marjakh:matrix.org> Mathieu Hofman: what's the one-sentence summary wrt how they get around Spectre & co when running in the same process?

deny any API that allow measuring time

[01:25:21.0379] <Mathieu Hofman>
also that's if you're concerned about confidentiality. integrity doesn't need denying time tools

[01:25:22.0505] <ljharb>
does that include all i/o? because presumably you could approximate time measurements that way, but maybe it wouldn't be granular enough to matter

[01:25:46.0531] <Mathieu Hofman>
> <@marjakh:matrix.org> Mathieu Hofman: what's the one-sentence summary wrt how they get around Spectre & co when running in the same process?

 * deny or virtualize any API that allow measuring time

[01:26:43.0180] <Mathieu Hofman>
Yes and no. For example Cloudflare Workers pretend time only advances when making external requests. The time is updated to the time the request is processed.

[01:28:36.0301] <Mathieu Hofman>
From what I understand they have some smart logic when you make a request from one worker to another to avoid colluding workers measuring time

[01:28:38.0548] <justingrant>
I had the same question/concern: other than purely "sugar" features like pipeline, most interesting new JS features seem like they'd need some help from the lower-level runtime to have adequate performance and functionality.

It'd be good to have some case studies of a few proposals to see what a JSSugar implementation would actually look like in practice. 

[01:29:03.0147] <ljharb>
fancy

[10:22:12.0224] <bakkot>
proposal to move the https://github.com/tc39/proposal-type-annotations to https://github.com/tc39/proposal-types-as-comments? people are continually confused about it

[10:34:06.0175] <Rob Palmer>
Can we create a redirect? TaC is the old name.

[11:50:23.0117] <Rob Palmer>
Separate: Please could someone unmute Marja H√∂ltt√§: 

[11:54:53.0303] <Eli Grey>
wasn't able to make day 1 but I'll be available remotely for days 2 & 3 -- could someone help forward remote attendance info?

[11:57:12.0261] <Eli Grey>
 * wasn't able to participate yet but I'll be available remotely for days 2 & 3 -- could someone help forward remote attendance info?

[12:03:11.0521] <keith_miller>
It's in the reflector for the meeting https://github.com/tc39/Reflector/issues/537 there's a sign-in form that gives you the link

[13:15:53.0184] <Eli Grey>
thanks, I see it now

[15:29:00.0511] <Chris de Almeida>
> <@robpalme:matrix.org> Separate: Please could someone unmute Marja H√∂ltt√§: 

that was addreesed yesterday 


2024-10-09
[18:05:15.0486] <Chris de Almeida>
please add yourself to the attendees list at the top of today's notes doc.  (and yesterday's if you missed).  thank you üôè

[18:27:21.0285] <Chris de Almeida>
I captured the queue

[18:30:26.0266] <rkirsling>
7 years

[18:30:34.0498] <rkirsling>
 * 7 years, wow

[18:39:14.0452] <Ashley Claymore>
Fun co-incidence. The 'toSorted' spec bug was caught by a Japanese developer

[18:41:35.0359] <Jack Works>
"Summing a list is a very common operation and is one of the few remaining use cases for Array.prototype.reduce."

[18:41:46.0660] <Jack Works>
are we going to discouraging use of [].reduce?

[18:43:01.0545] <rkirsling>
no, because you don't necessarily want the new behavior

[18:43:22.0117] <jkup>
The reduce will be faster still, right?

[18:44:10.0006] <Michael Ficarra>
@jkup:matrix.org an equivalent loop will, at least

[18:44:19.0156] <Michael Ficarra>
but you REALLY don't want to do that

[18:44:41.0910] <Michael Ficarra>
your result can accumulate a ton of error

[18:44:43.0897] <Jack Works>
the wording sounds like reduce is a bad thing (actually yes in most cases it _reduce_ the code readability)

[18:45:48.0139] <Jack Works>
but I'm not expecting that we should have a proposal to solve "the few remaining use cases of reduce", other motivations are ok thou

[18:46:27.0840] <rkirsling>
> <@michaelficarra:matrix.org> but you REALLY don't want to do that

I mean, in a specific case you might know that you're just adding e.g. a couple dozen single-digit ints or something though

[18:46:42.0829] <rkirsling>
just depends on the guarantees you're working with

[18:47:07.0181] <shu>
did you know reduce is pronounced re-doo-che

[18:47:27.0354] <Michael Ficarra>
@rkirsling:matrix.org if the number of values you're summing is small enough, the difference in perf between compensated and uncompensated is negligible anyway

[18:47:38.0628] <rkirsling>
touch√©!

[18:47:57.0336] <Michael Ficarra>
and once it gets large enough to care about perf, you should also care about error accumulation

[18:47:59.0652] <Jack Works>
> <@shuyuguo:matrix.org> did you know reduce is pronounced re-doo-che

not re-diu-s, or it's a ghoti joke?

[18:48:49.0009] <rkirsling>
it is neither, it's just a "let's pronounce this word in a silly way" joke

[18:49:32.0084] <rkirsling>
...the silly way in this case being like Italian, presumably :D

[18:53:36.0241] <Chris de Almeida>
the contents of the schedule may have shifted in flight.  presenters please review and let us know if any issues

[18:54:49.0766] <bakkot>
> <@jkup:matrix.org> The reduce will be faster still, right?

I would guess this will actually be faster because the reduce has to do callbacks. at least in the case where the engine knows it's a list of numbers already, `sumPrecise` can avoid a lot of work, which may make up for the difference

[18:58:01.0480] <hax (HE Shi-Jun)>
I feel `setdefault` is ok. Not sure why people prefer callback...

[18:58:15.0771] <ljharb>
because sometimes the default is expensive to compute.

[18:58:18.0901] <Michael Ficarra>
the callback can be lifted outside a loop, I'm not too worried about it

[18:58:19.0174] <Jack Works>
`getOrSet`

[18:58:55.0236] <bakkot>
it's true that people _can_ avoid re-creating the callback, but they're not going to

[18:58:59.0587] <shu>
yeah

[18:59:00.0294] <ljharb>
i am also skeptical that prepending `() =>` would have a noticeable perf hit, but have no way to argue that

[18:59:14.0145] <bakkot>
allocating throwaway closures is a lot more expensive than `0`

[18:59:16.0914] <shu>
it will have a noticeable perf hit in a hot loop for sure?

[18:59:20.0233] <shu>
allocation + call

[18:59:34.0563] <rbuckton>
> <@bakkot:matrix.org> allocating throwaway closures is a lot more expensive than `0`

```
function returnZero() { return 0; }
```

[18:59:45.0730] <shu>
yeah people aren't gonna do that, i agree with kevin there

[18:59:48.0968] <shu>
people will write ()=>0

[18:59:53.0527] <bakkot>
100% of the time

[18:59:56.0937] <Michael Ficarra>
@shuyuguo:matrix.org @bakkot:matrix.org when it's `[]`, you're creating tons of thrown-away arrays instead of just not calling a callback

[19:00:08.0752] <shu>
when what is []?

[19:00:08.0878] <bakkot>
but at least you don't have to call anything

[19:00:19.0680] <ljharb>
in Iterator.concat the throwaway arrays were supposed to be nbd

[19:00:20.0117] <bakkot>
> <@shuyuguo:matrix.org> when what is []?

when that's the default value

[19:00:24.0435] <Michael Ficarra>
people who care about perf already know to lift regexps outside of loops for example, this is the same thing

[19:00:27.0647] <hax (HE Shi-Jun)>
> <@ljharb:matrix.org> because sometimes the default is expensive to compute.

But current `map.set` has similar issue?

[19:00:29.0954] <shu>
if the default value is [], presumably you want a different empty array?

[19:00:55.0533] <ljharb>
> <@haxjs:matrix.org> But current `map.set` has similar issue?

currently you'd have to do your own has/get/set, and the set would be conditionally evaluated, so it'd always be the same as a callback (or better)

[19:01:01.0725] <Michael Ficarra>
> <@ljharb:matrix.org> in Iterator.concat the throwaway arrays were supposed to be nbd

we're talking about vastly different numbers of throwaway arrays here

[19:01:07.0954] <hax (HE Shi-Jun)>
> <@shuyuguo:matrix.org> if the default value is [], presumably you want a different empty array?

map.setdefault(key, []) already give u a diff empty array?

[19:01:19.0518] <shu>
yes

[19:01:28.0161] <shu>
that's why i don't understand michael's point

[19:01:28.0726] <Eli Grey>
insert should be the value and use a getter for the function use case in emplace imo

[19:01:35.0897] <shu>
you _can't_ have a single [] be the default

[19:01:39.0783] <shu>
unless you have copy-on-write []

[19:01:59.0833] <Michael Ficarra>
@shuyuguo:matrix.org I'm talking about doing this operation in a loop

[19:02:14.0748] <shu>
how can you lift out a default [] out of a loop?

[19:02:25.0222] <shu>
you want all the default empty arrays to be the literal same array object, which can be mutated?

[19:02:35.0768] <Michael Ficarra>
@shuyuguo:matrix.org you can't, that's the point, you make it a callback and lift that out

[19:02:43.0875] <shu>
wat

[19:02:48.0806] <shu>
why would you make a callback at all

[19:02:55.0846] <shu>
setdefault(k, []) does the right thing?

[19:03:27.0696] <Michael Ficarra>
@shuyuguo:matrix.org it would be more performant

[19:03:34.0289] <shu>
_what_

[19:03:48.0999] <Jack Works>
(joke) I guess we have to materialize ParseNode.

```
.emplace(key, complexExpression)
function emplace(key, value) { if (!this.has(key)) this.set(key, eval value); return this.get(key) }
```

[19:03:52.0005] <shu>
are you saying doing a call on a const function that returns [] is faster than directly passing in []?

[19:03:55.0959] <Michael Ficarra>
a shared callback that is almost never called is more performant than tons of empty arrays that end up getting GC'd

[19:03:59.0080] <Jack Works>
* (joke) I guess we have to materialize ParseNode.

```
.emplace(key, complexExpression)
function emplace(key, value) {if (!this.has(key)) this.set(key, eval value); return this.get(key) }
```

[19:04:12.0345] <Jack Works>
* (joke) I guess we have to materialize ParseNode.

```js
.emplace(key, complexExpression)
function emplace(key, value) {
    if (!this.has(key)) this.set(key, eval value);
    return this.get(key)
}
```

[19:04:13.0505] <shu>
oh, i see, i missed the assumption that it's rarely a hit

[19:04:20.0704] <shu>
or, rarely a miss

[19:04:40.0852] <shu>
that depends on whether your loop mostly hits or mostly misses, right?

[19:04:47.0042] <ljharb>
that's the benefit of using a callback in the API as well; that the default fn would almost never be called, for when it's expensive

[19:04:51.0436] <Michael Ficarra>
correct @shuyuguo:matrix.org

[19:05:04.0947] <shu>
but a callback version would be more expensive when it is mostly misses

[19:05:09.0412] <shu>
so it 'just depends'

[19:05:09.0948] <Jack Works>
well, what react do is good, but bad

[19:05:22.0248] <Jack Works>
they call it when it is a function

[19:05:23.0218] <Anthony Bullard>
Is it not possible to do both? 

[19:05:29.0259] <Michael Ficarra>
@ljharb:matrix.org they're worried that people will write the callback inline so instead we'll be creating tons of fresh functions that need to get GC'd

[19:05:36.0503] <Jack Works>
> <@anthonybullard:matrix.org> Is it not possible to do both? 

like react do to `useState`

[19:05:44.0502] <bakkot>
both is good

[19:05:46.0722] <Jack Works>
most cases it's good, some cases it's footgun

[19:05:50.0612] <shu>
yeah i'm fine with both

[19:05:52.0032] <Anthony Bullard>
I can‚Äôt attend tonight, just following chat

[19:05:59.0539] <Michael Ficarra>
I'm fine with both

[19:06:00.0985] <ljharb>
both is fine too

[19:06:01.0835] <Anthony Bullard>
I guess I should say allow either

[19:06:09.0945] <shu>
computeIfAbsentViaThisCallbackHere

[19:06:27.0181] <ljharb>
i've called it `getOrSetIfAbsent` before but that name is horrible

[19:06:45.0368] <Michael Ficarra>
is that in Java‚Ñ¢Ô∏è 23?

[19:06:48.0106] <bakkot>
I like `getOrInit` or `getOrInsert`

[19:06:52.0828] <shu>
maybe getOrSetIfAbsentOrPresent

[19:07:02.0305] <bakkot>
the computed one is `computeIfAbsent` in java, which... works...

[19:07:07.0001] <bakkot>
 * the callback one is `computeIfAbsent` in java, which... works...

[19:07:19.0281] <Jack Works>
`getWhenHasOrSetFromCallbackAndFinallyGetAgain`

[19:07:37.0579] <Anthony Bullard>
I just meant the arg can be either a value or a function to return the value

[19:07:55.0870] <Anthony Bullard>
Obviously an issue if the value you want is a function

[19:08:01.0273] <Jack Works>
> <@anthonybullard:matrix.org> I just meant the arg can be either a value or a function to return the value

yes, react do this and sometimes it's a footgun

[19:08:09.0784] <bakkot>
oh, absolutely not that

[19:08:16.0249] <bakkot>
functions are valid values to store in a map

[19:08:19.0525] <hax (HE Shi-Jun)>
java have both:`putIfAbsent` ( = python setdefault), `computeIfAbsent` is callback version.

[19:08:29.0482] <Anthony Bullard>
But yeah emplace and emplaceWith

[19:08:33.0802] <Anthony Bullard>
Is better

[19:08:38.0383] <Jack Works>
> <@bakkot:matrix.org> functions are valid values to store in a map

hIGh oRDeR functions obviously 

[19:08:42.0264] <Michael Ficarra>
> <@anthonybullard:matrix.org> I just meant the arg can be either a value or a function to return the value

WHY DO PEOPLE KEEP DOING THIS TO THEMSELVES?!

[19:09:03.0492] <Anthony Bullard>
> <@michaelficarra:matrix.org> WHY DO PEOPLE KEEP DOING THIS TO THEMSELVES?!

Yeah I thought of this after the fact

[19:09:22.0423] <Jack Works>
when you're in react and `useState` value might be a function, you do `useState(() => fn)`

[19:09:55.0165] <Anthony Bullard>
But other languages aren‚Äôt afraid of having separate methods/functions for value args and function args

[19:10:14.0588] <Jack Works>
how do you like extractors

[19:10:20.0506] <bakkot>
> <@haxjs:matrix.org> java have both:`putIfAbsent` ( = python setdefault), `computeIfAbsent` is callback version.

I don't like `putIfAbsent` because it doesn't suggest that it gives you the current value in the case that it's present

[19:10:49.0987] <bakkot>
`computeIfAbsent` doesn't really either but I guess it's more obviously going to return _something_ because "compute" suggests returning something

[19:10:57.0670] <Anthony Bullard>
Go for instance has many doSomething(arg1, value) doSomethingFunc(arg1, fn) pairs

[19:11:34.0772] <ljharb>
in ruby i think you'd have it take a block vs take a function, but most langs don't have blocks like that iirc

[19:11:36.0708] <Anthony Bullard>
The naming doesn‚Äôt align obviously with ES style, but the pairing is fine and easy to grok

[19:12:00.0271] <Jack Works>
well naming is that hard, let's call it `Map.prototype['007ae09e-b0e5-4939-b6f0-210e46f70538']`

[19:12:30.0465] <Eli Grey>
getters are good

[19:12:43.0017] <Anthony Bullard>
setDefault and setDefaultWith

[19:12:57.0326] <Eli Grey>
 * getters are good for this imo

[19:12:59.0114] <Eli Grey>
 * getters are good for this

[19:13:03.0081] <bakkot>
> <@jackworks:matrix.org> well naming is that hard, let's call it `Map.prototype['007ae09e-b0e5-4939-b6f0-210e46f70538']`

advantage of this is that people will inevitably alias that string to something useful, and then we can just look at whatever name people are actually using

[19:13:15.0253] <rkirsling>
lol

[19:13:21.0354] <Anthony Bullard>
> <@bakkot:matrix.org> advantage of this is that people will inevitably alias that string to something useful, and then we can just look at whatever name people are actually using

Pave the cow paths indeed

[19:13:25.0651] <rkirsling>
"delegated bikeshedding"

[19:13:41.0090] <Ashley Claymore>
"the masses have spoken"

[19:13:56.0529] <Anthony Bullard>
I think we have a new standard for APIs we can‚Äôt name

[19:13:58.0215] <Jack Works>
> <@bakkot:matrix.org> advantage of this is that people will inevitably alias that string to something useful, and then we can just look at whatever name people are actually using

this reminds me, does delegate investigated similar utilities on npm?

[19:14:13.0860] <Anthony Bullard>
Someone will still be mad about the UUID we chose

[19:14:51.0637] <hax (HE Shi-Jun)>
> <@bakkot:matrix.org> `computeIfAbsent` doesn't really either but I guess it's more obviously going to return _something_ because "compute" suggests returning something

So it's just naming issue? To be honest, in many cases I always expect `Map.set` would return the value instead of the map itself ü§® 

[19:15:15.0840] <Michael Ficarra>
> <@jackworks:matrix.org> this reminds me, does delegate investigated similar utilities on npm?

I think people mostly just do this pattern inline rather than rely on an npm package for it

[19:15:34.0996] <Jack Works>
> <@anthonybullard:matrix.org> Someone will still be mad about the UUID we chose

map['2024-10-09T02:14:57.500Z'](key, value)

[19:15:59.0512] <Jack Works>
> <@michaelficarra:matrix.org> I think people mostly just do this pattern inline rather than rely on an npm package for it

yes I write this inline, but we have `is-odd` on npm so definitely we'll have emplace on npm

[19:16:07.0794] <hax (HE Shi-Jun)>
> <@ljharb:matrix.org> in ruby i think you'd have it take a block vs take a function, but most langs don't have blocks like that iirc

Really hope JS can have block. Does "Block param" proposal still alive?

[19:16:16.0708] <ljharb>
not that i know of

[19:16:43.0865] <Jack Works>
> <@haxjs:matrix.org> Really hope JS can have block. Does "Block param" proposal still alive?

realize a block is also a kind of "function"

[19:16:56.0164] <Jack Works>
it contains context and can be executed right?

[19:17:01.0313] <Anthony Bullard>
> <@haxjs:matrix.org> Really hope JS can have block. Does "Block param" proposal still alive?

Neither a ruby or smalltalk guy, what‚Äôs the advantage of blocks?

[19:18:06.0912] <Jack Works>
> <@anthonybullard:matrix.org> Neither a ruby or smalltalk guy, what‚Äôs the advantage of blocks?

IMO mostly syntax sugar, may look like

```js
x.map { it + 1 }
```

[19:18:43.0413] <Anthony Bullard>
> <@jackworks:matrix.org> IMO mostly syntax sugar, may look like
> 
> ```js
> x.map { it + 1 }
> ```

Ah shorthand a la Kotlin, Scala, etc

[19:21:17.0396] <ljharb>
but it doesn't have a function stack frame/overhead

[19:21:21.0266] <ljharb>
 * but it doesn't have a function stack frame/overhead, ideally

[19:21:24.0575] <hax (HE Shi-Jun)>
The difference between the arrow function and real block may be the real block might support non-local jump (I believe block param proposal has the issue to discuss that, also do expression proposal)

[19:22:45.0106] <Anthony Bullard>
> <@ljharb:matrix.org> but it doesn't have a function stack frame/overhead, ideally

How do you close over then?  Or can it not?

[19:23:02.0273] <ljharb>
it does close over things, true

[19:23:25.0066] <Jack Works>
> <@haxjs:matrix.org> The difference between the arrow function and real block may be the real block might support non-local jump (I believe block param proposal has the issue to discuss that, also do expression proposal)

non-local jump sound worse

[19:24:03.0935] <Anthony Bullard>
In Kotlin { it + 1 } just desugars to (X) -> X + 1

[19:24:41.0029] <Michael Ficarra>
> <@jackworks:matrix.org> non-local jump sound worse

tell that to the people who want do expressions to have it

[19:25:11.0887] <bakkot>
huh apparently safari tech preview is already shipping Math.sumPrecise, nice

[19:25:21.0387] <bakkot>
unfortunately a port of my dumb polyfill to C++ instead of something faster

[19:25:48.0247] <Jack Works>
> <@michaelficarra:matrix.org> tell that to the people who want do expressions to have it

I also against do expression with `return/break/continue`

[19:25:59.0605] <hax (HE Shi-Jun)>
> <@jackworks:matrix.org> non-local jump sound worse

maybe i am wrong about that. I mean something like `a.map {  if (it != null) compute(it); else break }`

[19:26:16.0080] <hax (HE Shi-Jun)>
> <@jackworks:matrix.org> I also against do expression with `return/break/continue`

But it's useful in many cases.

[19:26:21.0545] <bakkot>
> <@bakkot:matrix.org> unfortunately a port of my dumb polyfill to C++ instead of something faster

(apparently the library I linked fails some of my tests; I'll need to try it and see if it can be fixed)

[19:26:23.0453] <Michael Ficarra>
> <@jackworks:matrix.org> I also against do expression with `return/break/continue`

yes but unfortunately there's people who are adamant that it allow them

[19:26:35.0779] <bakkot>
also they don't have a fast-path for "array of all numbers" which, I don't know if JSC has a concept of "array of all numbers"

[19:26:59.0642] <Anthony Bullard>
> <@haxjs:matrix.org> maybe i am wrong about that. I mean something like `a.map {  if (it != null) compute(it); else break }`

So you want a loop, but make it feel functional?

[19:27:05.0422] <bakkot>
(the proposal was designed to avoid any user code in the hot loop specifically so that you could have that optimization)

[19:27:17.0245] <bakkot>
 * (sumPrecise was designed to avoid any user code in the hot loop specifically so that you could have that optimization)

[19:27:22.0078] <rkirsling>
this is a very good question and a very good answer

[19:28:41.0227] <Michael Ficarra>
> <@anthonybullard:matrix.org> So you want a loop, but make it feel functional?

more like "you want reduce but you want to call it map"

[19:29:31.0912] <hax (HE Shi-Jun)>
> <@anthonybullard:matrix.org> So you want a loop, but make it feel functional?

As I understand, block param proposal has the motivation to make JS more DSL friendly. As such motivate, I say yes.

[19:30:01.0554] <Jack Works>
```js
const { id: Number(id) } = JSON.parse(str)
```

[19:30:22.0936] <Chris de Almeida>
ljharb: help me understand better stack trace there?  that sounds harder to debug

[19:31:06.0287] <ljharb>
currently it gives a stack trace that points to the validation function, and then below that, the validator callsite. there's a possibility for a clearer error imo that points to the function signature and references extractors in the messag

[19:31:07.0744] <ljharb>
 * currently it gives a stack trace that points to the validation function, and then below that, the validator callsite. there's a possibility for a clearer error imo that points to the function signature and references extractors in the message

[19:31:21.0983] <Chris de Almeida>
hmm

[19:31:25.0372] <Anthony Bullard>
> <@haxjs:matrix.org> As I understand, block param proposal has the motivation to make JS more DSL friendly. As such motivate, I say yes.

I‚Äôm all for desugaring syntax, but I don‚Äôt want to get to F# computed expressions levels of complexity 

[19:33:07.0791] <hax (HE Shi-Jun)>
> <@michaelficarra:matrix.org> more like "you want reduce but you want to call it map"

If only name issue, let's change `map` to something else , eg. `collect`? üòÇ 

[19:39:13.0378] <Anthony Bullard>
Is it just me (not on the call), but when the chat dies out suddenly, do you wonder if Matrix just tipped over or was there a break?

[19:41:15.0942] <ptomato>
or everyone is paying real close attention to the slides...

[19:41:28.0595] <Rob Palmer>
Syntactically correct TypeScript will emit JS even if the type checks fail.  (And sometimes it will emit JS even if the syntax is invalid.)

[19:42:46.0019] <shu>
right

[19:42:54.0609] <shu>
but that doesn't conflict with what i'm asking

[19:46:46.0493] <hax (HE Shi-Jun)>
> <@robpalme:matrix.org> Syntactically correct TypeScript will emit JS even if the type checks fail.  (And sometimes it will emit JS even if the syntax is invalid.)

yeah , last week someone tell me it's surprise to see `import {x} "path"` (missing `from`) still work in ts...

[19:47:22.0347] <Rob Palmer>
My favourite is automatic brace insertion in ts.

[19:47:36.0227] <canadahonk>
> <@robpalme:matrix.org> My favourite is automatic brace insertion in ts.

what

[19:48:10.0092] <Rob Palmer>
(sorry this is a distraction from current topic - it should be in TDZ)

[19:48:14.0708] <danielrosenwasser>
if you write

```
if (x) {
//forgot a brace here
```

TypeScript gracefully parses, tells you you forgot a brace, and just re-prints it the right way

```
if (x) {
}
```

[19:48:24.0825] <Anthony Bullard>
> <@robpalme:matrix.org> My favourite is automatic brace insertion in ts.

Not the ABI we are looking for

[19:48:39.0029] <danielrosenwasser>
 * if you write

```
if (x) {
//forgot a brace here
```

TypeScript gracefully recovers parsing, tells you you forgot a brace, and just re-prints it the right way

```
if (x) {
}
```

[19:57:46.0298] <Ashley Claymore>
Found this one recently. TS supports Python scoping

```
function f() {
    if (true)
        type s = string;
        console.log("s" as s);
}
```

[19:58:49.0583] <danielrosenwasser>
> <@aclaymore:matrix.org> Found this one recently. TS supports Python scoping
> 
> ```
> function f() {
>     if (true)
>         type s = string;
>         console.log("s" as s);
> }
> ```

Can you file a bug?

[19:59:24.0144] <danielrosenwasser>
Or I'll file a bug if I can

[19:59:31.0697] <danielrosenwasser>
Either way nice find!

[20:00:37.0342] <Ashley Claymore>
will do!

[20:01:23.0648] <bakkot>
.... what do you even do about that case

[20:01:37.0446] <bakkot>
parse error, I guess?

[20:02:13.0843] <danielrosenwasser>
possibly

[20:02:42.0152] <Rob Palmer>
it's a graceful parser

[20:02:50.0460] <littledan>
Seems like we should have more discussions in TC39 about the architectures of various implementations, both tools and native

[20:03:12.0988] <danielrosenwasser>
 * possibly - we'd probably do it at checking, it gets treated more like an early error

[20:03:13.0567] <littledan>
Like presentations explaining this

[20:04:09.0483] <Michael Ficarra>
@danielrosenwasser:matrix.org allow it, add a grammar alternative like `Statement : TypeDeclaration Statement`

[20:04:26.0423] <danielrosenwasser>
lmao

[20:04:39.0568] <Michael Ficarra>
üòêÔ∏è this is my serious face

[20:04:55.0840] <danielrosenwasser>
Statement ::
  Statement Statement

[20:06:00.0195] <danielrosenwasser>
Likewise, I think it could be helpful to see concretely what the performance concerns are, why certain optimizations are difficult for engine implementers, etc.

[20:06:53.0117] <littledan>
Yeah this feature is as expensive as a method call + array destructuring; I understand the concern about array destructuring being expensive but I don‚Äôt know what else engines are imagining that tools would do

[20:07:38.0016] <littledan>
I dont think we should block all features where people have posited impractical optimizations. We certainly would not have done iterator helpers if that were a requirement 

[20:08:13.0312] <Ashley Claymore>
> <@danielrosenwasser:matrix.org> Can you file a bug?

https://github.com/microsoft/TypeScript/issues/60175

[20:10:03.0994] <danielrosenwasser>
But I think there's a legitimate "pit of despair" concern. Like imagine you are writing a tool that you want to be reasonably fast and you posit that pattern matching should be as fast as a `switch` on the class or something like that

[20:20:53.0520] <keith_miller>
I think the concern here is that we're (potentially) offering a very clean but expensive abstraction/idiom that people are trained from other languages to be zero-cost.

[20:21:28.0833] <keith_miller>
If this idiom is no worse than what people would do otherwise then I'm not concerned

[20:21:42.0293] <keith_miller>
 * If this idiom is no worse in terms of performance than what people would do otherwise then I'm not concerned

[20:22:54.0500] <keith_miller>
But I think adding or encouraging idioms that have known to be bad performance isn't in browser user's interest and that's what I'm trying to reflect.

[20:23:07.0327] <rbuckton>
Summary has been added.

[20:24:17.0987] <rbuckton>
> <@keith_miller:matrix.org> If this idiom is no worse in terms of performance than what people would do otherwise then I'm not concerned

The expectation is that `const Point(x, y) = p` is no more expensive than `const [x, y] = Point[Symbol.customMatcher](p, "list")`

[20:25:06.0519] <rbuckton>
though if we end up not finding a solution to iterator destructuring performance and end up going with array-as-object destructuring, `const Point(x, y) = p` is potentially *faster*

[20:25:18.0170] <keith_miller>
But it might be more expensive than: `if (p instanceof Point) { let x = p.x; let y = p.y ...}`

[20:25:43.0403] <keith_miller>
So that's the bar to compare against

[20:27:10.0977] <keith_miller>
And devs just might structure their code differently without this, potentially in a way that's more performant. I'm saying that I want to be convinced they're not.

[20:27:21.0762] <rbuckton>
That doesn't have the expressivity we're seeking. The motivations include custom validation.

[20:27:54.0814] <rbuckton>
The `Point` example from my slides used brand checking via private names

[20:28:04.0314] <keith_miller>
That's a bummer and I would like to have that validation too but not really my concern, unfortunately.

[20:28:42.0322] <littledan>
I understand the performance concern ‚Äúthis will encourage people to use more array destructuring‚Äù. There are a number of possible remedies to that

[20:30:03.0567] <littledan>
One is using this alternative Array-like destructuring semantics, as Rob mentioned. If we want to avoid the allocation altogether, we could also limit extractors to a single argument, and then any nested array destructuring would be explicit.

[20:30:09.0623] <littledan>
* One is using this alternative Array-like destructuring semantics, as Ron mentioned. If we want to avoid the allocation altogether, we could also limit extractors to a single argument, and then any nested array destructuring would be explicit.

[20:30:34.0285] <keith_miller>
It's not just the array destructuring although that's part of the concern. It's if the idiom makes sense as a whole.

[20:30:49.0673] <littledan>
The discussion got a bit abstract as to which performance concerns people had. What other ones were there apart from array destructuring cost?

[20:31:34.0316] <littledan>
Or whether the idiom makes sense‚Ä¶ it is really common across languages and I have found it useful, so I am wondering if people can make their concerns more concrete.

[20:32:02.0922] <keith_miller>
What other dynamic languages have this?

[20:32:15.0870] <littledan>
Pattern matching/extractors are definitely not linked to static typing. Python and Racket have versions 

[20:32:25.0863] <rbuckton>
Python, though they do something slightly different that the pattern matching champions group does not agree with.

[20:32:37.0590] <littledan>
It is just random cultural history that they are linked to functional/statically typed languages 

[20:33:03.0603] <littledan>
Erlang is dynamically typed and does tons of pattern matching

[20:33:38.0168] <littledan>
Prolog for that matter, untyped and the ancestor of a lot of these ideas 

[20:35:10.0853] <littledan>
Elixir https://hexdocs.pm/elixir/pattern-matching.html#the-match-operator

[20:35:31.0874] <keith_miller>
But are those idioms performant in those languages? Or are they just a cost people are willing to pay for convenience? 

[20:35:59.0657] <rbuckton>
Its not really a static vs dynamic language feature. C# uses `Deconstruct()` for custom extraction, and static type information to do overload disambiguation and argument matching, but compared to this the main difference is that C# uses `out` parameters, which we don't have, rather than something like iterator destructuring.

[20:37:03.0257] <keith_miller>
I'm not debating the convenience of the idiom. Only its potential performance impact with use.

[20:38:13.0570] <littledan>
I haven‚Äôt heard anyone talk about pattern matching as an expensive feature outside of the array destructuring issue in any other language. Some functional statically typed languages do fancy things optimizing trees of conditionals for pattern matching but others don‚Äôt.

[20:38:44.0218] <rbuckton>
The pattern matching proposal has some interesting mechanisms it plans to employ related to caching that have the side benefit of improving performance in a disjunction or multiple match-legs.

[20:39:17.0176] <keith_miller>
Then that should make proving it's performant easy!

[20:39:48.0784] <keith_miller>
I'm not saying it's not performant only that I'd like to see real world use cases benchmarked.

[20:39:50.0576] <rbuckton>
So in pattern matching something like :
```js
match (x) {
  Point(0, 0): ...,
  Point(>0, 0): ...,
}
```
could potentially only evaluates the custom matcher once and reuse the extracted elements on both match legs.

[20:40:02.0778] <rbuckton>
 * So in pattern matching something like :

```js
match (x) {
  Point(0, 0): ...,
  Point(>0, 0): ...,
}
```

could potentially only evaluate the custom matcher once and reuse the extracted elements on both match legs.

[20:40:12.0840] <keith_miller>
 * I'm not saying it's not performant only that I'd like to see non-trivial real world use cases benchmarked.

[20:40:35.0237] <littledan>
Ruby pattern matching: https://docs.ruby-lang.org/en/master/syntax/pattern_matching_rdoc.html

[20:42:23.0005] <littledan>
> <@keith_miller:matrix.org> I'm not saying it's not performant only that I'd like to see non-trivial real world use cases benchmarked.

Yeah this is a reasonable and good request but to be able to do it, it would help to understand what people think could go wrong. Ron has posited some possible complex optimizations but those cases could be optimized or made slower with or without pattern matching.

[20:42:25.0413] <rbuckton>
Pattern matching caching is something I'm *not* looking forward to desugaring mostly due to the emit size of the desugaring. I'm hoping I can stash a lot of it in emit helpers in `tslib` to cut down on bundle size.

[20:44:12.0121] <littledan>
> <@rbuckton:matrix.org> So in pattern matching something like :
> 
> ```js
> match (x) {
>   Point(0, 0): ...,
>   Point(>0, 0): ...,
> }
> ```
> 
> could potentially only evaluate the custom matcher once and reuse the extracted elements on both match legs.

I guess this is something we will debate in the broader pattern matching proposal. I was hoping we wouldn‚Äôt do the kind of complex caching that some versions of pattern matching had‚Äîthis might add more cost than value, given that it has to be deterministic and consistent

[20:44:43.0537] <littledan>
And the >0 syntax is a whole other topic!

[20:45:02.0158] <rbuckton>
It's not part of the core proposal, to be clear. Its something I'd like to see but we're saving it for a follow-on.

[20:45:16.0782] <rbuckton>
It's extremely useful in C#

[20:45:44.0440] <rbuckton>
 * It's not part of the core proposal, to be clear. Its something I'd like to see but we're pushing it to a follow-on.

[20:50:32.0872] <littledan>
If array destructuring is expensive and impractical to optimize, should we in TC39 be discouraging its use? For example, by encouraging transpilers to transform it into object destructuring (treating it as array-like)?

[20:51:18.0240] <littledan>
I don‚Äôt like this idea personally but if this is such a big problem that we can‚Äôt build other features on it‚Ä¶

[21:00:21.0643] <bakkot>
yes, code which cares about performance does specifically write `{ 0: foo, 1: bar }` instead of `[foo, bar]`

[21:00:31.0048] <bakkot>
transpilers can't do this without type information

[21:00:47.0388] <bakkot>
 * yes, code which cares about performance does specifically write `{ 0: foo, 1: bar } =` instead of `[foo, bar] =`

[21:01:00.0518] <Ashley Claymore>
I wonder if it be web-compat, and also more performant, to change iterator destructuring to be specced as property access if the RHS passes `Array.isArray` ? i.e. assume the array's iterator will be the default one

[21:01:45.0709] <rbuckton>
It's significantly faster to do `const { 0: x, 1: setX } = useState()` in React, but its rare to see that done.

[21:02:08.0119] <keith_miller>
That's an interesting idea! No idea if it's compatible though.

[21:02:18.0660] <bakkot>
> <@aclaymore:matrix.org> I wonder if it be web-compat, and also more performant, to change iterator destructuring to be specced as property access if the RHS passes `Array.isArray` ? i.e. assume the array's iterator will be the default one

... tempting... and I would guess probably compatible?

[21:02:44.0655] <bakkot>
though it might need to be "`isArray` and also not a proxy", potentially

[21:02:50.0004] <bakkot>
proxies :(

[21:03:00.0502] <canadahonk>
> <@aclaymore:matrix.org> I wonder if it be web-compat, and also more performant, to change iterator destructuring to be specced as property access if the RHS passes `Array.isArray` ? i.e. assume the array's iterator will be the default one

I do this internally (sorry spec)

[21:03:36.0881] <canadahonk>
> <@aclaymore:matrix.org> I wonder if it be web-compat, and also more performant, to change iterator destructuring to be specced as property access if the RHS passes `Array.isArray` ? i.e. assume the array's iterator will be the default one

 * I do basically this internally (sorry spec)

[21:04:02.0649] <canadahonk>
it definitely fails some test262 tests though

[21:04:34.0336] <rbuckton>
How many people use `for..of` over arrays today? I assume that still isn't optimized for Array vs other iterators.

[21:05:34.0254] <bakkot>
I am almost certain that's optimized in JSC, at least

[21:05:49.0102] <bakkot>
and would kind of expect it to be in V8 but it's been a while since I looked

[21:05:57.0353] <shu>
we suck at it still i think

[21:06:22.0490] <rbuckton>
If you can optimize `for..of` why not `const [x, y]`?

[21:06:28.0896] <rbuckton>
 * If you can optimize `for..of` why not `const [x, y] =`?

[21:07:43.0894] <shu>
why can do _something_ for `const [x,y]` probably, but it's not going to be parity with object destructuring, will have a perf cliff for non-Arrays and a bunch of other bailout paths

[21:07:56.0896] <shu>
there're a lot of undesirables hidden behind "why not optimize this other pattern"

[21:08:20.0386] <shu>
 * why can do _something_ for `const [x,y]` probably, but it's not going to be parity with object destructuring, will have a perf cliff for non-Arrays and a bunch of other bailout paths (which is also a increased attack surface)

[21:08:40.0553] <shu>
 * we can do _something_ for `const [x,y]` probably, but it's not going to be parity with object destructuring, will have a perf cliff for non-Arrays and a bunch of other bailout paths (which is also a increased attack surface)

[21:09:25.0863] <rbuckton>
I expect most destructuring is array to array, but I don't have metrics to back that up.

[21:09:54.0290] <rbuckton>
I'd be perfectly happy with Array being fast and other iterators being slower, since the alternative is both are slower.

[21:10:43.0238] <shu>
yeah i agree it's worth optimizing that?

[21:10:48.0839] <rbuckton>
React alone should be enough of a reason to optimize array to array destructuring, but I'm working on some benchmarking to get and understanding of the actual effect it has.

[21:10:55.0789] <rbuckton>
 * React alone should be enough of a reason to optimize array to array destructuring, but I'm working on some benchmarking to get an understanding of the actual effect it has.

[21:11:02.0800] <keith_miller>
It is very optimized in JSC (modulo the iterator object itself being allocated)

[21:11:25.0197] <Rob Palmer>
I thought V8 had already done that

[21:11:40.0031] <justingrant>
> <@rkirsling:matrix.org> 7 years, wow

You think it's wow from the outside, imagine feeling those years from the inside!  Although I only joined the Temporal champion 4.5 years ago so I'm still a fresh n00b. üòÄ

[21:11:43.0117] <shu>
i don't actually know, lemme see

[21:11:44.0522] <littledan>
> <@bakkot:matrix.org> transpilers can't do this without type information

Yes they can‚Äîtsc does it in some emit modes unconditionally!

[21:12:03.0357] <bakkot>
sorry, without also breaking some other code

[21:12:07.0113] <Jack Works>
> <@rbuckton:matrix.org> How many people use `for..of` over arrays today? I assume that still isn't optimized for Array vs other iterators.

almost all of my code is `for..of` even it might be slow. readibility > performance when the code is not in a hot path

[21:12:11.0255] <Ashley Claymore>
https://docs.google.com/document/d/1hWb-lQW4NSG9yRpyyiAA_9Ktytd5lypLnVLhPX9vamE/edit?tab=t.0#heading=h.9ss45aibqpw2

[21:12:16.0065] <rbuckton>
TSC only does that for `--target ES5` where there is no expectation of `Symbol.iterator`.

[21:12:37.0013] <littledan>
> <@bakkot:matrix.org> sorry, without also breaking some other code

If you care about breaking other code, then you might need runtime support to check that no one messed with Array.prototype

[21:12:39.0579] <rbuckton>
And we have `--downevelIteration` to emulate actual ES2015+ semantics.

[21:13:03.0479] <littledan>
> <@bakkot:matrix.org> transpilers can't do this without type information

 * Yes they can‚Äîtsc does it in some emit modes unconditionally! (When emitting es5)

[21:13:22.0545] <littledan>
Yes sorry that wasn‚Äôt meant as a tsc critique

[21:13:59.0873] <littledan>
But generally: if we want transpilers to do unsound things (like around TDZ) that is something we as a committee can say

[21:14:14.0651] <rbuckton>
Even in the `--downlevelIteration` case we use a runtime helper to emulate an iterator over an array, rather than bake that into the actual loop.

[21:14:30.0357] <rbuckton>
so the emit remains the same regardless as to the type of the iterated object

[21:14:41.0441] <shu>
> <@aclaymore:matrix.org> https://docs.google.com/document/d/1hWb-lQW4NSG9yRpyyiAA_9Ktytd5lypLnVLhPX9vamE/edit?tab=t.0#heading=h.9ss45aibqpw2

oh cool. looks like we didn't actually land any of the talked about solutions though? the bytecode still looks pretty bad to me

[21:14:48.0418] <littledan>
I dunno if we should do such unsound downlevelings but I don‚Äôt know what else would actually meet what the browsers seem to be expecting

[21:14:59.0685] <shu>
the quickest way to make sure that happens is to make it show up in speedometer or the new jetstream

[21:15:12.0034] <Ashley Claymore>
is it a really bad idea to have a 3rd form of destructuring for array-like?

```
const |a, b, c| = multiReturnFunction(); // probably a better token is available
// is
const { 0: a, 1: b, 2: c } = multiReturnFunction();
```

[21:16:28.0025] <keith_miller>
> <@rbuckton:matrix.org> The expectation is that `const Point(x, y) = p` is no more expensive than `const [x, y] = Point[Symbol.customMatcher](p, "list")`

Sorry getting back to this but while yes `const Point(x, y) = p` isn't more expensive than that `const Optional.Some(Point.2D(x, y)) = o` would likely decode to 20-30 byte codes in JSC

[21:16:33.0353] <rbuckton>
`let |a, ` is ambiguous

[21:17:07.0352] <Ashley Claymore>
one R&T design was `[| a, b, c |]`, maybe could be more like that?

[21:18:05.0097] <ljharb>
> <@keith_miller:matrix.org> Sorry getting back to this but while yes `const Point(x, y) = p` isn't more expensive than that `const Optional.Some(Point.2D(x, y)) = o` would likely decode to 20-30 byte codes in JSC

why not to `const [x, y] = Optional.some[Symbol.customMatcher](Point[Symbol.customMatcher](p, 'list'), 'list');`?

[21:18:30.0064] <shu>
i'll be somewhat blunt: i continue to see the line of argument from extractor-proponents to be "for these technical reasons it's unrealistic to do this in tools"

that's fine! but that doesn't imply "engines will do it"

[21:18:55.0593] <shu>
i think the counterfactual that "people will write things that are even slower" is also just not true in this case, because pattern matching and extractors don't exist?

[21:19:08.0834] <ljharb>
the things those will be used for are already done, just in other ways

[21:19:19.0083] <shu>
and if they don't want to write that verbose example that jordan posted above, that's good! the grossness of the example correlates with the slowness

[21:19:31.0546] <ljharb>
pattern matching is done with function calls and if/else and/or switch, extractors with separate function calls

[21:19:39.0580] <shu>
that seems good to me

[21:19:47.0317] <shu>
their verbosity gives a hint to the work they're doing

[21:20:15.0108] <ljharb>
i'm not sure the point of programming languages is to have verbosity correlate to cost?

[21:20:18.0272] <nicolo-ribaudo>
> <@shuyuguo:matrix.org> i'll be somewhat blunt: i continue to see the line of argument from extractor-proponents to be "for these technical reasons it's unrealistic to do this in tools"
> 
> that's fine! but that doesn't imply "engines will do it"

Extractors are actually something that would be easy to do in Babel, just not fast/small

[21:20:22.0451] <rbuckton>
Pattern matching results in far more readable code than the current approach.

[21:20:33.0782] <shu>
if a terser and more readable thing can be a near zero-cost abstraction, that's great

[21:20:39.0889] <rbuckton>
The verbosity makes it harder to reason over.

[21:20:45.0582] <shu>
if it can't be, we gave our position yesterday on the cost to users

[21:21:20.0108] <Bradford Smith>
My concern with Extractors is that they seem overly clever to me. They hide what's happening from the developer too much, leading them to incorrect ideas about how expensive they are.

[21:21:29.0115] <shu>
> <@ljharb:matrix.org> i'm not sure the point of programming languages is to have verbosity correlate to cost?

the point of programming languages is to write applications that have some value to users of the applications

[21:21:33.0908] <ljharb>
indeed

[21:21:38.0196] <rbuckton>
pattern matching can be more efficient than the alternative if we have sufficient caching and reuse across multiple branches of the pattern.

[21:21:39.0266] <keith_miller>
Sure but that's still 48 byte codes in JSC today:
```
[x, y] = Optional.some[Symbol.customMatcher](Point[Symbol.customMatcher](p, 'list'), 'list');
<global>#BS5CtO:[0x130538130->0x10e071188, NoneGlobal, 265]: 48 instructions (0 16-bit instructions, 0 32-bit instructions, 27 instructions with metadata); 361 bytes (96 metadata bytes); 1 parameter(s); 20 callee register(s); 5 variable(s); scope at loc4

bb#1
Predecessors: [ ]
[   0] enter
[   1] mov                dst:loc5, src:Undefined(const0)
[   4] resolve_scope      dst:loc7, scope:loc4, var:0, resolveType:GlobalProperty, localScopeDepth:0
[  11] get_from_scope     dst:loc8, scope:loc7, var:0, getPutInfo:2048<ThrowIfNotFound|GlobalProperty|NotInitialization|NotStrictMode>, localScopeDepth:0, offset:0, valueProfile:1
[  20] get_by_id          dst:loc6, base:loc8, property:1, valueProfile:2
[  26] resolve_scope      dst:loc8, scope:loc4, var:2, resolveType:GlobalProperty, localScopeDepth:0
[  33] get_from_scope     dst:loc9, scope:loc8, var:2, getPutInfo:2048<ThrowIfNotFound|GlobalProperty|NotInitialization|NotStrictMode>, localScopeDepth:0, offset:0, valueProfile:3
[  42] get_by_id          dst:loc7, base:loc9, property:3, valueProfile:4
[  48] get_by_val         dst:loc5, base:loc6, property:loc7, valueProfile:5
[  54] mov                dst:loc10, src:loc6
[  57] resolve_scope      dst:loc11, scope:loc4, var:4, resolveType:GlobalProperty, localScopeDepth:0
[  64] get_from_scope     dst:loc11, scope:loc11, var:4, getPutInfo:2048<ThrowIfNotFound|GlobalProperty|NotInitialization|NotStrictMode>, localScopeDepth:0, offset:0, valueProfile:6
[  73] resolve_scope      dst:loc13, scope:loc4, var:2, resolveType:GlobalProperty, localScopeDepth:0
[  80] get_from_scope     dst:loc14, scope:loc13, var:2, getPutInfo:2048<ThrowIfNotFound|GlobalProperty|NotInitialization|NotStrictMode>, localScopeDepth:0, offset:0, valueProfile:7
[  89] get_by_id          dst:loc12, base:loc14, property:3, valueProfile:8
[  95] get_by_val         dst:loc9, base:loc11, property:loc12, valueProfile:9
[ 101] mov                dst:loc14, src:loc11
[ 104] resolve_scope      dst:loc13, scope:loc4, var:5, resolveType:GlobalProperty, localScopeDepth:0
[ 111] get_from_scope     dst:loc13, scope:loc13, var:5, getPutInfo:2048<ThrowIfNotFound|GlobalProperty|NotInitialization|NotStrictMode>, localScopeDepth:0, offset:0, valueProfile:10
[ 120] mov                dst:loc12, src:String (atomic),8Bit:(1),length:(4): list, StructureID: 16976(const1)
[ 123] call               dst:loc9, callee:loc9, argc:3, argv:20, valueProfile:11
[ 130] mov                dst:loc8, src:String (atomic),8Bit:(1),length:(4): list, StructureID: 16976(const1)
[ 133] call               dst:loc5, callee:loc5, argc:3, argv:16, valueProfile:12
[ 140] get_by_id          dst:loc8, base:loc5, property:6, valueProfile:13
[ 146] mov                dst:loc10, src:loc5
[ 149] iterator_open      iterator:loc6, next:loc7, symbolIterator:loc8, iterable:loc10, stackOffset:16, iterableValueProfile:14, iteratorValueProfile:15, nextValueProfile:16
[ 159] mov                dst:loc10, src:loc6
[ 162] iterator_next      done:loc8, value:loc9, iterable:loc5, next:loc7, iterator:loc10, stackOffset:16, nextResultValueProfile:17, doneValueProfile:18, valueValueProfile:19
[ 173] jfalse             condition:loc8, targetLabel:6(->179)
Successors: [ #3 #2 ]

bb#2
Predecessors: [ #1 ]
[ 176] mov                dst:loc9, src:Undefined(const0)
Successors: [ #3 ]

bb#3
Predecessors: [ #1 #2 ]
[ 179] resolve_scope      dst:loc10, scope:loc4, var:7, resolveType:GlobalProperty, localScopeDepth:0
[ 186] put_to_scope       scope:loc10, var:7, value:loc9, getPutInfo:1050624<DoNotThrowIfNotFound|GlobalProperty|NotInitialization|NotStrictMode>, symbolTableOrScopeDepth:0, offset:0
[ 194] jtrue              condition:loc8, targetLabel:20(->214)
Successors: [ #5 #4 ]

bb#4
Predecessors: [ #3 ]
[ 197] mov                dst:loc10, src:loc6
[ 200] iterator_next      done:loc8, value:loc9, iterable:loc5, next:loc7, iterator:loc10, stackOffset:16, nextResultValueProfile:20, doneValueProfile:21, valueValueProfile:22
[ 211] jfalse             condition:loc8, targetLabel:6(->217)
Successors: [ #6 #5 ]

bb#5
Predecessors: [ #3 #4 ]
[ 214] mov                dst:loc9, src:Undefined(const0)
Successors: [ #6 ]

bb#6
Predecessors: [ #4 #5 ]
[ 217] resolve_scope      dst:loc10, scope:loc4, var:8, resolveType:GlobalProperty, localScopeDepth:0
[ 224] put_to_scope       scope:loc10, var:8, value:loc9, getPutInfo:1050624<DoNotThrowIfNotFound|GlobalProperty|NotInitialization|NotStrictMode>, symbolTableOrScopeDepth:0, offset:0
[ 232] jtrue              condition:loc8, targetLabel:31(->263)
Successors: [ #10 #7 ]

bb#7
Predecessors: [ #6 ]
[ 235] get_by_id          dst:loc9, base:loc6, property:9, valueProfile:23
[ 241] jundefined_or_null value:loc9, targetLabel:22(->263)
Successors: [ #10 #8 ]

bb#8
Predecessors: [ #7 ]
[ 244] mov                dst:loc12, src:loc6
[ 247] call               dst:loc10, callee:loc9, argc:1, argv:18, valueProfile:24
[ 254] is_object          dst:loc13, operand:loc10
[ 257] jtrue              condition:loc13, targetLabel:6(->263)
Successors: [ #10 #9 ]

bb#9
Predecessors: [ #8 ]
[ 260] throw_static_error message:String (atomic),8Bit:(1),length:(43): Iterator result interface is not an object., StructureID: 16976(const2), errorType:TypeError
Successors: [ ]

bb#10
Predecessors: [ #6 #7 #8 ]
[ 263] end                value:loc5
Successors: [ ]


Identifiers:
  id0 = Optional
  id1 = some
  id2 = Symbol
  id3 = customMatcher
  id4 = Point
  id5 = p
  id6 = Symbol.iterator
  id7 = x
  id8 = y
  id9 = return

Constants:
   k0 = Undefined
   k1 = String (atomic),8Bit:(1),length:(4): list, StructureID: 16976
   k2 = String (atomic),8Bit:(1),length:(43): Iterator result interface is not an object., StructureID: 16976
```

[21:21:50.0798] <ljharb>
and readable code correlates to that value, imo often more highly than the performance of that application

[21:21:59.0292] <shu>
i disagree _so_ strongly on that point

[21:22:04.0261] <ljharb>
that is clear :-)

[21:23:09.0305] <bakkot>
I might believe that claim in C, which is hard to write correctly and where bugs can do arbitrarily bad things, but I certainly do not agree with that claim for web apps written in JS

[21:24:04.0529] <keith_miller>
> <@bakkot:matrix.org> I might believe that claim in C, which is hard to write correctly and where bugs can do arbitrarily bad things, but I certainly do not agree with that claim for web apps written in JS

Are you agreeing with Jordan or Shu? lol

[21:24:07.0033] <ljharb>
it's not a claim that it's always the case, to be clear, and obv _some_ threshold of slowness will always cancel out the other benefits,

[21:24:11.0830] <ljharb>
 * it's not a claim that it's always the case, to be clear, and obv _some_ threshold of slowness will always cancel out the other benefits.

[21:24:37.0036] <keith_miller>
Which is a *lot* by JSC standards 

[21:24:52.0696] <keith_miller>
This function would be invalid for inlining from one binding alone

[21:25:27.0789] <bakkot>
I am agreeing with shu

[21:26:16.0405] <bakkot>
I think that webapps being slow is the cause of much more pain than webapps being unclear to their maintainers

[21:26:50.0677] <keith_miller>
> <@ljharb:matrix.org> why not to `const [x, y] = Optional.some[Symbol.customMatcher](Point[Symbol.customMatcher](p, 'list'), 'list');`?

Pulling this into the main channel. This would be sufficiently complex (48 byte codes) that this would be no longer considered for inlining under JSC's current heuristic.

[21:27:03.0046] <keith_miller>
From one statement

[21:27:50.0889] <keith_miller>
Which I *don't* think devs would expect

[21:28:20.0583] <rbuckton>
JSC inlining is limited to the statement level?

[21:28:38.0581] <keith_miller>
It's limited by the number of bytes in the instruction stream

[21:28:58.0404] <keith_miller>
IIRC, it's 170 bytes

[21:30:32.0165] <Michael Ficarra>
> <@aclaymore:matrix.org> is it a really bad idea to have a 3rd form of destructuring for array-like?
> 
> ```
> const |a, b, c| = multiReturnFunction(); // probably a better token is available
> // is
> const { 0: a, 1: b, 2: c } = multiReturnFunction();
> ```

`const Array(a, b, c) = ...`?

[21:31:09.0955] <rbuckton>
If extractors ends up needing to use array-as-object destructuring, then yeah, that's a possibility.

[21:31:17.0155] <rbuckton>
 * If extractors end up needing to use array-as-object destructuring, then yeah, that's a possibility.

[21:33:01.0345] <keith_miller>
A lot of that is resolving the various properties needed though not the array destructuring

[21:34:15.0866] <keith_miller>
I encourage you to look at that bytecode sequence and *really* think about all the subtle work that has to happen to resolve that binding.

[21:35:24.0583] <shu>
i feel like folks haven't really internalized the "complexity is moved, not removed" point we tried to make yet

[21:36:18.0508] <rbuckton>
And the bytecode for `const [[[x, y]]] = foo` given it results in three lookups to `Symbol.iterator`? I understand extractors do that as well, I'm just curious.

[21:36:36.0702] <Michael Ficarra>
@shuyuguo:matrix.org this could literally be a special form that *does* remove the complexity, different from `const window.Array(a, b, c) = ...`

[21:37:02.0068] <keith_miller>
```

[21:37:08.0249] <keith_miller>
 * >>> const [[[x, y]]] = foo
<global>#CzC5ob:[0x130538220->0x10e071488, NoneGlobal, 285]: 59 instructions (0 16-bit instructions, 0 32-bit instructions, 22 instructions with metadata); 381 bytes (96 metadata bytes); 1 parameter(s); 26 callee register(s); 5 variable(s); scope at loc4

bb#1
Predecessors: [ ]
[   0] enter
[   1] mov                dst:loc5, src:Undefined(const0)
[   4] resolve_scope      dst:loc6, scope:loc4, var:0, resolveType:GlobalProperty, localScopeDepth:0
[  11] get_from_scope     dst:loc6, scope:loc6, var:0, getPutInfo:2048<ThrowIfNotFound|GlobalProperty|NotInitialization|NotStrictMode>, localScopeDepth:0, offset:0, valueProfile:1
[  20] get_by_id          dst:loc9, base:loc6, property:1, valueProfile:2
[  26] mov                dst:loc10, src:loc6
[  29] iterator_open      iterator:loc7, next:loc8, symbolIterator:loc9, iterable:loc10, stackOffset:16, iterableValueProfile:3, iteratorValueProfile:4, nextValueProfile:5
[  39] mov                dst:loc12, src:loc7
[  42] iterator_next      done:loc9, value:loc10, iterable:loc6, next:loc8, iterator:loc12, stackOffset:18, nextResultValueProfile:6, doneValueProfile:7, valueValueProfile:8
[  53] jfalse             condition:loc9, targetLabel:6(->59)
Successors: [ #3 #2 ]

bb#2
Predecessors: [ #1 ]
[  56] mov                dst:loc10, src:Undefined(const0)
Successors: [ #3 ]

bb#3
Predecessors: [ #1 #2 ]
[  59] get_by_id          dst:loc13, base:loc10, property:1, valueProfile:9
[  65] mov                dst:loc14, src:loc10
[  68] iterator_open      iterator:loc11, next:loc12, symbolIterator:loc13, iterable:loc14, stackOffset:20, iterableValueProfile:10, iteratorValueProfile:11, nextValueProfile:12
[  78] mov                dst:loc16, src:loc11
[  81] iterator_next      done:loc13, value:loc14, iterable:loc10, next:loc12, iterator:loc16, stackOffset:22, nextResultValueProfile:13, doneValueProfile:14, valueValueProfile:15
[  92] jfalse             condition:loc13, targetLabel:6(->98)
Successors: [ #5 #4 ]

bb#4
Predecessors: [ #3 ]
[  95] mov                dst:loc14, src:Undefined(const0)
Successors: [ #5 ]

bb#5
Predecessors: [ #3 #4 ]
[  98] get_by_id          dst:loc17, base:loc14, property:1, valueProfile:16
[ 104] mov                dst:loc18, src:loc14
[ 107] iterator_open      iterator:loc15, next:loc16, symbolIterator:loc17, iterable:loc18, stackOffset:24, iterableValueProfile:17, iteratorValueProfile:18, nextValueProfile:19
[ 117] mov                dst:loc20, src:loc15
[ 120] iterator_next      done:loc17, value:loc18, iterable:loc14, next:loc16, iterator:loc20, stackOffset:26, nextResultValueProfile:20, doneValueProfile:21, valueValueProfile:22
[ 131] jfalse             condition:loc17, targetLabel:6(->137)
Successors: [ #7 #6 ]

bb#6
Predecessors: [ #5 ]
[ 134] mov                dst:loc18, src:Undefined(const0)
Successors: [ #7 ]

bb#7
Predecessors: [ #5 #6 ]
[ 137] resolve_scope      dst:loc19, scope:loc4, var:2, resolveType:GlobalProperty, localScopeDepth:0
[ 144] put_to_scope       scope:loc19, var:2, value:loc18, getPutInfo:1049600<DoNotThrowIfNotFound|GlobalProperty|ConstInitialization|NotStrictMode>, symbolTableOrScopeDepth:0, offset:0
[ 152] jtrue              condition:loc17, targetLabel:20(->172)
Successors: [ #9 #8 ]

bb#8
Predecessors: [ #7 ]
[ 155] mov                dst:loc20, src:loc15
[ 158] iterator_next      done:loc17, value:loc18, iterable:loc14, next:loc16, iterator:loc20, stackOffset:26, nextResultValueProfile:23, doneValueProfile:24, valueValueProfile:25
[ 169] jfalse             condition:loc17, targetLabel:6(->175)
Successors: [ #10 #9 ]

bb#9
Predecessors: [ #7 #8 ]
[ 172] mov                dst:loc18, src:Undefined(const0)
Successors: [ #10 ]

bb#10
Predecessors: [ #8 #9 ]
[ 175] resolve_scope      dst:loc19, scope:loc4, var:3, resolveType:GlobalProperty, localScopeDepth:0
[ 182] put_to_scope       scope:loc19, var:3, value:loc18, getPutInfo:1049600<DoNotThrowIfNotFound|GlobalProperty|ConstInitialization|NotStrictMode>, symbolTableOrScopeDepth:0, offset:0
[ 190] jtrue              condition:loc17, targetLabel:31(->221)
Successors: [ #14 #11 ]

bb#11
Predecessors: [ #10 ]
[ 193] get_by_id          dst:loc18, base:loc15, property:4, valueProfile:26
[ 199] jundefined_or_null value:loc18, targetLabel:22(->221)
Successors: [ #14 #12 ]

bb#12
Predecessors: [ #11 ]
[ 202] mov                dst:loc20, src:loc15
[ 205] call               dst:loc19, callee:loc18, argc:1, argv:26, valueProfile:27
[ 212] is_object          dst:loc21, operand:loc19
[ 215] jtrue              condition:loc21, targetLabel:6(->221)
Successors: [ #14 #13 ]

bb#13
Predecessors: [ #12 ]
[ 218] throw_static_error message:String (atomic),8Bit:(1),length:(43): Iterator result interface is not an object., StructureID: 16976(const1), errorType:TypeError
Successors: [ ]

bb#14
Predecessors: [ #10 #11 #12 ]
[ 221] jtrue              condition:loc13, targetLabel:31(->252)
Successors: [ #18 #15 ]

bb#15
Predecessors: [ #14 ]
[ 224] get_by_id          dst:loc14, base:loc11, property:4, valueProfile:28
[ 230] jundefined_or_null value:loc14, targetLabel:22(->252)
Successors: [ #18 #16 ]

bb#16
Predecessors: [ #15 ]
[ 233] mov                dst:loc16, src:loc11
[ 236] call               dst:loc15, callee:loc14, argc:1, argv:22, valueProfile:29
[ 243] is_object          dst:loc17, operand:loc15
[ 246] jtrue              condition:loc17, targetLabel:6(->252)
Successors: [ #18 #17 ]

bb#17
Predecessors: [ #16 ]
[ 249] throw_static_error message:String (atomic),8Bit:(1),length:(43): Iterator result interface is not an object., StructureID: 16976(const1), errorType:TypeError
Successors: [ ]

bb#18
Predecessors: [ #14 #15 #16 ]
[ 252] jtrue              condition:loc9, targetLabel:31(->283)
Successors: [ #22 #19 ]

bb#19
Predecessors: [ #18 ]
[ 255] get_by_id          dst:loc10, base:loc7, property:4, valueProfile:30
[ 261] jundefined_or_null value:loc10, targetLabel:22(->283)
Successors: [ #22 #20 ]

bb#20
Predecessors: [ #19 ]
[ 264] mov                dst:loc12, src:loc7
[ 267] call               dst:loc11, callee:loc10, argc:1, argv:18, valueProfile:31
[ 274] is_object          dst:loc13, operand:loc11
[ 277] jtrue              condition:loc13, targetLabel:6(->283)
Successors: [ #22 #21 ]

bb#21
Predecessors: [ #20 ]
[ 280] throw_static_error message:String (atomic),8Bit:(1),length:(43): Iterator result interface is not an object., StructureID: 16976(const1), errorType:TypeError
Successors: [ ]

bb#22
Predecessors: [ #18 #19 #20 ]
[ 283] end                value:loc5
Successors: [ ]


Identifiers:
  id0 = foo
  id1 = Symbol.iterator
  id2 = x
  id3 = y
  id4 = return

Constants:
   k0 = Undefined
   k1 = String (atomic),8Bit:(1),length:(43): Iterator result interface is not an object., StructureID: 16976


[21:37:23.0489] <keith_miller>
 *  const \[\[\[x, y\]\]\] = foo
\<global>#CzC5ob:\[0x130538220->0x10e071488, NoneGlobal, 285\]: 59 instructions (0 16-bit instructions, 0 32-bit instructions, 22 instructions with metadata); 381 bytes (96 metadata bytes); 1 parameter(s); 26 callee register(s); 5 variable(s); scope at loc4

bb#1
Predecessors: \[ \]
\[   0\] enter
\[   1\] mov                dst:loc5, src:Undefined(const0)
\[   4\] resolve\_scope      dst:loc6, scope:loc4, var:0, resolveType:GlobalProperty, localScopeDepth:0
\[  11\] get\_from\_scope     dst:loc6, scope:loc6, var:0, getPutInfo:2048\<ThrowIfNotFound|GlobalProperty|NotInitialization|NotStrictMode>, localScopeDepth:0, offset:0, valueProfile:1
\[  20\] get\_by\_id          dst:loc9, base:loc6, property:1, valueProfile:2
\[  26\] mov                dst:loc10, src:loc6
\[  29\] iterator\_open      iterator:loc7, next:loc8, symbolIterator:loc9, iterable:loc10, stackOffset:16, iterableValueProfile:3, iteratorValueProfile:4, nextValueProfile:5
\[  39\] mov                dst:loc12, src:loc7
\[  42\] iterator\_next      done:loc9, value:loc10, iterable:loc6, next:loc8, iterator:loc12, stackOffset:18, nextResultValueProfile:6, doneValueProfile:7, valueValueProfile:8
\[  53\] jfalse             condition:loc9, targetLabel:6(->59)
Successors: \[ #3 #2 \]

bb#2
Predecessors: \[ #1 \]
\[  56\] mov                dst:loc10, src:Undefined(const0)
Successors: \[ #3 \]

bb#3
Predecessors: \[ #1 #2 \]
\[  59\] get\_by\_id          dst:loc13, base:loc10, property:1, valueProfile:9
\[  65\] mov                dst:loc14, src:loc10
\[  68\] iterator\_open      iterator:loc11, next:loc12, symbolIterator:loc13, iterable:loc14, stackOffset:20, iterableValueProfile:10, iteratorValueProfile:11, nextValueProfile:12
\[  78\] mov                dst:loc16, src:loc11
\[  81\] iterator\_next      done:loc13, value:loc14, iterable:loc10, next:loc12, iterator:loc16, stackOffset:22, nextResultValueProfile:13, doneValueProfile:14, valueValueProfile:15
\[  92\] jfalse             condition:loc13, targetLabel:6(->98)
Successors: \[ #5 #4 \]

bb#4
Predecessors: \[ #3 \]
\[  95\] mov                dst:loc14, src:Undefined(const0)
Successors: \[ #5 \]

bb#5
Predecessors: \[ #3 #4 \]
\[  98\] get\_by\_id          dst:loc17, base:loc14, property:1, valueProfile:16
\[ 104\] mov                dst:loc18, src:loc14
\[ 107\] iterator\_open      iterator:loc15, next:loc16, symbolIterator:loc17, iterable:loc18, stackOffset:24, iterableValueProfile:17, iteratorValueProfile:18, nextValueProfile:19
\[ 117\] mov                dst:loc20, src:loc15
\[ 120\] iterator\_next      done:loc17, value:loc18, iterable:loc14, next:loc16, iterator:loc20, stackOffset:26, nextResultValueProfile:20, doneValueProfile:21, valueValueProfile:22
\[ 131\] jfalse             condition:loc17, targetLabel:6(->137)
Successors: \[ #7 #6 \]

bb#6
Predecessors: \[ #5 \]
\[ 134\] mov                dst:loc18, src:Undefined(const0)
Successors: \[ #7 \]

bb#7
Predecessors: \[ #5 #6 \]
\[ 137\] resolve\_scope      dst:loc19, scope:loc4, var:2, resolveType:GlobalProperty, localScopeDepth:0
\[ 144\] put\_to\_scope       scope:loc19, var:2, value:loc18, getPutInfo:1049600\<DoNotThrowIfNotFound|GlobalProperty|ConstInitialization|NotStrictMode>, symbolTableOrScopeDepth:0, offset:0
\[ 152\] jtrue              condition:loc17, targetLabel:20(->172)
Successors: \[ #9 #8 \]

bb#8
Predecessors: \[ #7 \]
\[ 155\] mov                dst:loc20, src:loc15
\[ 158\] iterator\_next      done:loc17, value:loc18, iterable:loc14, next:loc16, iterator:loc20, stackOffset:26, nextResultValueProfile:23, doneValueProfile:24, valueValueProfile:25
\[ 169\] jfalse             condition:loc17, targetLabel:6(->175)
Successors: \[ #10 #9 \]

bb#9
Predecessors: \[ #7 #8 \]
\[ 172\] mov                dst:loc18, src:Undefined(const0)
Successors: \[ #10 \]

bb#10
Predecessors: \[ #8 #9 \]
\[ 175\] resolve\_scope      dst:loc19, scope:loc4, var:3, resolveType:GlobalProperty, localScopeDepth:0
\[ 182\] put\_to\_scope       scope:loc19, var:3, value:loc18, getPutInfo:1049600\<DoNotThrowIfNotFound|GlobalProperty|ConstInitialization|NotStrictMode>, symbolTableOrScopeDepth:0, offset:0
\[ 190\] jtrue              condition:loc17, targetLabel:31(->221)
Successors: \[ #14 #11 \]

bb#11
Predecessors: \[ #10 \]
\[ 193\] get\_by\_id          dst:loc18, base:loc15, property:4, valueProfile:26
\[ 199\] jundefined\_or\_null value:loc18, targetLabel:22(->221)
Successors: \[ #14 #12 \]

bb#12
Predecessors: \[ #11 \]
\[ 202\] mov                dst:loc20, src:loc15
\[ 205\] call               dst:loc19, callee:loc18, argc:1, argv:26, valueProfile:27
\[ 212\] is\_object          dst:loc21, operand:loc19
\[ 215\] jtrue              condition:loc21, targetLabel:6(->221)
Successors: \[ #14 #13 \]

bb#13
Predecessors: \[ #12 \]
\[ 218\] throw\_static\_error message:String (atomic),8Bit:(1),length:(43): Iterator result interface is not an object., StructureID: 16976(const1), errorType:TypeError
Successors: \[ \]

bb#14
Predecessors: \[ #10 #11 #12 \]
\[ 221\] jtrue              condition:loc13, targetLabel:31(->252)
Successors: \[ #18 #15 \]

bb#15
Predecessors: \[ #14 \]
\[ 224\] get\_by\_id          dst:loc14, base:loc11, property:4, valueProfile:28
\[ 230\] jundefined\_or\_null value:loc14, targetLabel:22(->252)
Successors: \[ #18 #16 \]

bb#16
Predecessors: \[ #15 \]
\[ 233\] mov                dst:loc16, src:loc11
\[ 236\] call               dst:loc15, callee:loc14, argc:1, argv:22, valueProfile:29
\[ 243\] is\_object          dst:loc17, operand:loc15
\[ 246\] jtrue              condition:loc17, targetLabel:6(->252)
Successors: \[ #18 #17 \]

bb#17
Predecessors: \[ #16 \]
\[ 249\] throw\_static\_error message:String (atomic),8Bit:(1),length:(43): Iterator result interface is not an object., StructureID: 16976(const1), errorType:TypeError
Successors: \[ \]

bb#18
Predecessors: \[ #14 #15 #16 \]
\[ 252\] jtrue              condition:loc9, targetLabel:31(->283)
Successors: \[ #22 #19 \]

bb#19
Predecessors: \[ #18 \]
\[ 255\] get\_by\_id          dst:loc10, base:loc7, property:4, valueProfile:30
\[ 261\] jundefined\_or\_null value:loc10, targetLabel:22(->283)
Successors: \[ #22 #20 \]

bb#20
Predecessors: \[ #19 \]
\[ 264\] mov                dst:loc12, src:loc7
\[ 267\] call               dst:loc11, callee:loc10, argc:1, argv:18, valueProfile:31
\[ 274\] is\_object          dst:loc13, operand:loc11
\[ 277\] jtrue              condition:loc13, targetLabel:6(->283)
Successors: \[ #22 #21 \]

bb#21
Predecessors: \[ #20 \]
\[ 280\] throw\_static\_error message:String (atomic),8Bit:(1),length:(43): Iterator result interface is not an object., StructureID: 16976(const1), errorType:TypeError
Successors: \[ \]

bb#22
Predecessors: \[ #18 #19 #20 \]
\[ 283\] end                value:loc5
Successors: \[ \]

Identifiers:
id0 = foo
id1 = Symbol.iterator
id2 = x
id3 = y
id4 = return

Constants:
k0 = Undefined
k1 = String (atomic),8Bit:(1),length:(43): Iterator result interface is not an object., StructureID: 16976

[21:37:43.0672] <Michael Ficarra>
please don't dump walls of text into Matrix, make a gist or something

[21:38:44.0059] <keith_miller>
I put it in a thread for that reason?

[21:39:30.0308] <rbuckton>
Does the bytecode for the `Optional.some[Symbol.customMatcher]` include the cost of looking up `customMatcher` on Symbol? A native implementation would be able to avoid that because it would be using a known symbol.

[21:39:56.0742] <Michael Ficarra>
> <@keith_miller:matrix.org> I put it in a thread for that reason?

oh I think my client doesn't do threads

[21:40:33.0188] <keith_miller>
> <@michaelficarra:matrix.org> oh I think my client doesn't do threads

Ah fair, sorry. I assumed that was the standard.

[21:40:43.0342] <hax (HE Shi-Jun)>
> <@ljharb:matrix.org> and readable code correlates to that value, imo often more highly than the performance of that application

I agree with Jordan, extractor give u a simple abstraction and shorter code. such feature will improve the code quality generally (not only perf, but also many other aspects). 

[21:40:47.0967] <Jack Works>
> <@rbuckton:matrix.org> Does the bytecode for the `Optional.some[Symbol.customMatcher]` include the cost of looking up `customMatcher` on Symbol? A native implementation would be able to avoid that because it would be using a known symbol.

that's just 1~3 steps i guess

[21:40:51.0654] <keith_miller>
Sure, that would be avoided but that's not too much of the code generated

[21:46:01.0029] <keith_miller>
I think the browser vendors are pushing back on the idea that it gives you perf

[21:46:19.0908] <keith_miller>
It's not a magic box that things become faster because you want it to

[21:46:34.0223] <keith_miller>
 * It's not a magic box where things become faster because you want it to

[21:46:44.0536] <rbuckton>
At least extractors are not a hidden cost you stumble into, unlike getters/setters or let/const TDZ. You don't pay the cost if you don't use extractors, and so long as developers are aware of the cost (and that cost is not absurdly high), developers can balance the pros and cons and fall back to existing behaviors for high performance scenarios. I think the part of concern is that developers might blindly adopt extractors without considering the cost?

[21:46:45.0925] <Justin Ridgewell>
> <@michaelficarra:matrix.org> oh I think my client doesn't do threads

Cinny shows ‚Äúthreaded reply‚Äù under the username

[21:46:59.0493] <shu>
i think extractors are _totally_ a hidden cost

[21:47:01.0489] <rbuckton>
 * At least extractors are not a hidden cost you stumble into, unlike getters/setters or let/const TDZ. You don't pay the cost if you don't use extractors, and so long as developers are aware of the cost (and that cost is not absurdly high), developers can balance the pros and cons and fall back to existing behaviors for high performance scenarios. I think part of concern is that developers might blindly adopt extractors without considering the cost?

[21:47:24.0568] <yulia>
> <@rbuckton:matrix.org> At least extractors are not a hidden cost you stumble into, unlike getters/setters or let/const TDZ. You don't pay the cost if you don't use extractors, and so long as developers are aware of the cost (and that cost is not absurdly high), developers can balance the pros and cons and fall back to existing behaviors for high performance scenarios. I think part of concern is that developers might blindly adopt extractors without considering the cost?

extractors are quite similar to let/const, they hide the cost of the operation behind what looks like light weight syntax

[21:47:43.0435] <shu>
here's a really simple, clean looking code (multiple delegates have said as such, **i** also think it looks very clean and nice) that hides a pretty expensive operation that doesn't exist in other languages that inspired this feature!

[21:47:55.0513] <Michael Ficarra>
@yulia:mozilla.org no more so than positional destructuring

[21:47:56.0466] <keith_miller>
Yeah the syntax is üíØ hiding the cost! That's exactly what I was trying to show!

[21:47:59.0471] <rbuckton>
The syntax looks like a function call, part of the benefit of that is that the expectation is that it will have the cost of a function call.

[21:48:20.0915] <shu>
do you think a rust or haskell programmer look at pattern matching and think that's a function call?

[21:48:34.0464] <canadahonk>
couldn't the same be said with array destructuring?

[21:48:39.0553] <bakkot>
yes

[21:48:40.0926] <shu>
yeah?

[21:48:41.0702] <yulia>
yes, 

[21:48:43.0736] <shu>
array destructuring is terrible

[21:48:44.0592] <canadahonk>
welp

[21:48:50.0030] <keith_miller>
> <@michaelficarra:matrix.org> @yulia:mozilla.org no more so than positional destructuring

Sure and I think engines would consider that was a mistake

[21:48:51.0546] <hax (HE Shi-Jun)>
A function calling is also a very simple syntax (and can hide cost). I don't see there is any diff.

[21:49:39.0891] <keith_miller>
In every language a function call is a significant cost

[21:50:06.0200] <keith_miller>
Maybe if you're clever you can get the compiler to remove a lot of that but IMO devs know that's on them

[21:50:13.0488] <keith_miller>
 * Maybe if you're clever you can get the compiler to remove a lot of that but IMO devs know that's on them to verify

[21:50:21.0512] <Aki>
"other parts of the web platform" /me perks nup

[21:50:23.0574] <Aki>
 * "other parts of the web platform" /me perks up

[21:50:39.0483] <Chris de Almeida>
the good parts or... ?

[21:51:12.0590] <Marja H√∂ltt√§>
function calls and things like array destructing / extractors are also completely different levels of fundamental; can't really imagine a modern language without functions, but the other 2 are much more optional

[21:51:26.0275] <rkirsling>
amusing overload of "javascript core" lol

[21:51:34.0201] <rkirsling>
(yes it was clear in context hehe)

[21:51:38.0600] <keith_miller>
Yeah, I got really confused for a sec lol

[21:51:39.0498] <yulia>
sooorrryyyy my brain is so dead

[21:51:45.0453] <rbuckton>
> <@keith_miller:matrix.org> Maybe if you're clever you can get the compiler to remove a lot of that but IMO devs know that's on them to verify

If they're expected to know that `const p = Point(x, y)` has a cost, they won't be expected to know that `const Point(x, y) = p` does as well?

[21:51:48.0020] <Bradford Smith>
Also, there is no restriction in the Extractors proposal on just how expensive that function may be. It could do anything. The examples assume they will always "undo" a constructor call, but there's no reason to believe it would stay restricted to that in practice.

[21:52:14.0581] <rbuckton>
That's part of the reason for the duality of the syntax. Extraction mirrors applilcation

[21:52:35.0567] <rbuckton>
 * That's part of the reason for the duality of the syntax. Extraction mirrors application.

[21:52:44.0526] <Bradford Smith>
only by convention, though. It's not enforceable.

[21:52:57.0013] <rbuckton>
application can be arbitrarily expensive because its user code. Extraction can be arbitrarily expensive because its user code.

[21:53:21.0471] <keith_miller>
> <@rbuckton:matrix.org> If they're expected to know that `const p = Point(x, y)` has a cost, they won't be expected to know that `const Point(x, y) = p` does as well?

No because no other binding in the language has a cost. let/const is a great example of this in the sense that people didn't expect there would be a cost there.

[21:53:42.0101] <keith_miller>
> <@rbuckton:matrix.org> If they're expected to know that `const p = Point(x, y)` has a cost, they won't be expected to know that `const Point(x, y) = p` does as well?

 * No because other bindings in the language don't have a cost. let/const is a great example of this in the sense that people didn't expect there would be a cost there.

[21:53:45.0928] <hax (HE Shi-Jun)>
If a specific extracting logic is complex and cost , then it always there, people just write it in some other form, and generally speaking, average programmers normally write much slower code repeatly and every place. On the other side, extractor allow senior programmer factor the logic and do optimization in single place and provide other an easy to adoption syntax. 

[21:53:59.0074] <Bradford Smith>
My point is, part of the assumption of improved readability is assuming that the feature will be used in a particular way. I expect it would be abused to make code "magically" shorter.

[21:54:01.0044] <rkirsling>
ngl if I'm in JS author mode, my brain wants to view destructuring as zero-cost

[21:54:24.0486] <rbuckton>
> <@keith_miller:matrix.org> No because other bindings in the language don't have a cost. let/const is a great example of this in the sense that people didn't expect there would be a cost there.

Yes they do, `const [x, y]` has a cost. Extractors have an obvious cost because they are explicitly designed to run user code, that's the whole point.

[21:55:13.0581] <keith_miller>
I think it's non-obvious. Maybe this would be worth a developer study?

[21:55:50.0845] <rbuckton>
Most developers don't think about iteration cost when they use `const [x, y]` because the possibility of iteration being expensive is hidden on the RHS, not the LHS. Extractors put that cost in your face by being on the LHS./

[21:55:52.0196] <rbuckton>
 * Most developers don't think about iteration cost when they use `const [x, y]` because the possibility of iteration being expensive is hidden on the RHS, not the LHS. Extractors put that cost in your face by being on the LHS.

[21:55:57.0436] <hax (HE Shi-Jun)>
> <@rkirsling:matrix.org> ngl if I'm in JS author mode, my brain wants to view destructuring as zero-cost

I only expect builtin syntax like object destructuing and array destructing to be fast enough. But extractor means custom matcher and it just like function, and I don't expect it is zero cost.

[21:55:59.0221] <keith_miller>
IIRC, Mozilla (not asking them to do it again) did this in the past and it revealed a lot of reasonable insights.

[21:56:33.0034] <keith_miller>
 * IIRC, Mozilla (not asking them to do it again) did this in the past and it revealed a lot of interensting insights.

[21:56:41.0571] <keith_miller>
 * IIRC, Mozilla (not asking them to do it again) did this in the past and it revealed a lot of interesting insights.

[21:57:39.0536] <yulia>
(we did what now?)

[21:58:08.0690] <yulia>
... user study? yeah thats something we have a whole TG for please get in touch!

[21:58:17.0429] <shu>
user study for this hidden cost question

[21:58:20.0469] <yulia>
we can get students to do it

[21:58:34.0495] <yulia>
(im not doing it, no time these days, but there are eager folks)

[21:59:12.0018] <rbuckton>
That could be very helpful, though I'm not sure how to get that process started.

[21:59:45.0005] <yulia>
you can make an issue in https://github.com/tc39/tg5/issues or add it here: https://github.com/tc39/tg5/issues/29

[22:00:06.0144] <yulia>
then at our next meeting we will bring it up as a request for help from the committee, and we will see if one of the universities wants to take it up

[22:02:29.0500] <rbuckton>
Thanks, I'll look into this after plenary.

[22:07:22.0386] <Michael Ficarra>
hot take: I'm kinda okay with engine divergence on stupid stuff that nobody should ever be observing

[22:07:28.0820] <Michael Ficarra>
maybe that's a lukewarm take, I dunno

[22:08:28.0634] <Ashley Claymore>
it's like natural fuzz testing of apps

[22:14:25.0110] <shu>
i think this is a ArrayBuffer-specific thing

[22:14:36.0012] <shu>
like in general deviance is particularly bad for AB and TAs because of the whole Khronos thing

[22:15:58.0050] <rbuckton>
Only stage 4 candidate of the day, there were like 4 yesterday

[22:16:04.0337] <keith_miller>
Yeah AB is a pants on head crazy place

[22:16:27.0156] <rkirsling>
detach all the things

[22:16:28.0378] <shu>
in particular that bug from the presentation is because what used to be a ToInteger changed to a ToIndex sometime in 2016

[22:16:43.0467] <shu>
https://github.com/tc39/ecma262/pull/410

[22:16:52.0802] <Chris de Almeida>
> <@rbuckton:matrix.org> Only stage 4 candidate of the day, there were like 4 yesterday

it's the last one remaining for this meeting, is what I meant

[22:17:04.0435] <shu>
like, it looks like SM was intimately involved with that PR at the time, which is probably why they're compliant

[22:17:11.0428] <shu>
and this just never got implemented in JSC and V8 for whatever reason at the time

[22:17:56.0765] <shu>
> <@michaelficarra:matrix.org> hot take: I'm kinda okay with engine divergence on stupid stuff that nobody should ever be observing

yeah, experience with ABs and TAs show that this is surprisingly robust?

[22:22:45.0160] <nicolo-ribaudo>
I was talking with an MDN writer -- I think we should make MDN a stage 4 requirement. MDN is very happy to write docs by themselves, but we don't really have a process to coordinate themself. Their current process is "regularly check what Firefox" implements, which means that sometimes Stage 4 proposals (thus, meant to be used by developers) have no docs

[22:23:08.0517] <nicolo-ribaudo>
 * I was talking with an MDN writer -- I think we should make MDN a stage 4 requirement. MDN is very happy to write docs by themselves, but we don't really have a process to coordinate themself. Their current process is "regularly check what Firefox implements", which means that sometimes Stage 4 proposals (thus, meant to be used by developers) have no docs

[22:23:18.0057] <nicolo-ribaudo>
 * I was talking with an MDN writer -- I think we should make MDN a stage 4 requirement. MDN is very happy to write docs by themselves, but we don't really have a process to coordinate. Their current process is "regularly check what Firefox implements", which means that sometimes Stage 4 proposals (thus, meant to be used by developers) have no docs

[22:23:29.0493] <yulia>
we have a meta issue for all tc39 proposals

[22:23:44.0703] <yulia>
https://bugzilla.mozilla.org/show_bug.cgi?id=1435811

[22:23:58.0659] <yulia>
and each proposal (now) has a meta that documentation watches

[22:24:41.0419] <ryzokuken>
> <@nicolo-ribaudo:matrix.org> I was talking with an MDN writer -- I think we should make MDN a stage 4 requirement. MDN is very happy to write docs by themselves, but we don't really have a process to coordinate. Their current process is "regularly check what Firefox implements", which means that sometimes Stage 4 proposals (thus, meant to be used by developers) have no docs

it has come up a few times in the past before but TG2 already does this

[22:24:43.0935] <Michael Ficarra>
> <@nicolo-ribaudo:matrix.org> I was talking with an MDN writer -- I think we should make MDN a stage 4 requirement. MDN is very happy to write docs by themselves, but we don't really have a process to coordinate. Their current process is "regularly check what Firefox implements", which means that sometimes Stage 4 proposals (thus, meant to be used by developers) have no docs

we can't make something a requirement if it is entirely out of our control

[22:24:46.0581] <ryzokuken>
and not at Stage 4

[22:25:14.0017] <ryzokuken>
so yeah this is not unprecedented and we just need to bring it to agenda to get into the process doc I guess

[22:25:36.0118] <Andreu Botella (at TC39, üïê JST)>
> <@michaelficarra:matrix.org> we can't make something a requirement if it is entirely out of our control

MDN is a github repo

[22:25:38.0125] <nicolo-ribaudo>
> <@yulia:mozilla.org> and each proposal (now) has a meta that documentation watches

From what I understood, the problem is that it's still Firefox-centric. The ideal time to write docs is after that one implementation ships, and before stage 4. From Firefox's issue tracker, you can either get notified when a proposal reaches stage 3 (too early) or when Firerfox implements it (sometimes too late)

[22:26:05.0719] <yulia>
yep, thats true -- was giving some insight about how the process currently works

[22:26:17.0840] <yulia>
we don't actually tell MDN what to write about, and sometimes they write docs before we ship

[22:26:28.0467] <nicolo-ribaudo>
> <@michaelficarra:matrix.org> we can't make something a requirement if it is entirely out of our control

True, their recommendation was actually "require that MDN folks have been notified in advance so that they can make sure to prioritise docs"

[22:26:29.0879] <yulia>
they just watch that issue for upcoming topics

[22:26:44.0628] <yulia>
and we have a meta issue for every proposal at stage 3

[22:27:02.0390] <Michael Ficarra>
> <@nicolo-ribaudo:matrix.org> True, their recommendation was actually "require that MDN folks have been notified in advance so that they can make sure to prioritise docs"

that's fine by me

[22:27:34.0327] <Chris de Almeida>
while I very much want the docs, I am wary of asking more from proposal champions

[22:27:38.0892] <Michael Ficarra>
> <@abotella:igalia.com> MDN is a github repo

I am not an expert in the kinds of things that go into writing user-facing documentation

[22:28:03.0242] <nicolo-ribaudo>
> <@softwarechris:matrix.org> while I very much want the docs, I am wary of asking more from proposal champions

They are not asking us to write docs for them (they are technical writers, it's their job!), just to coordinate better

[22:28:35.0144] <Chris de Almeida>
then it doesn't seem like we can require it

[22:28:59.0861] <nicolo-ribaudo>
Well, HTML for example requires that an issue must have been opened before merging the change to the spec

[22:29:07.0857] <nicolo-ribaudo>
 * Well, HTML for example requires that a docs issue must have been opened before merging the change to the spec

[22:29:30.0232] <yulia>
nicolo-ribaudo: which proposals were missed?

[22:29:32.0018] <Michael Ficarra>
yeah I am fine with asking for an issue to be opened or something akin to that

[22:30:45.0182] <Chris de Almeida>
I am fine with the spirit of it, but I hesitate to codify something 3rd party.  but if everyone supports it, I won't get in the way

[22:30:46.0008] <nicolo-ribaudo>
> <@yulia:mozilla.org> nicolo-ribaudo: which proposals were missed?

Recent examples were symbols as weakmap keys and regexp v mode

[22:31:10.0139] <ptomato>
a coworker and I tried to get ahead of the game with Temporal docs for MDN, back when the proposal went to stage 3. it was a frustrating experience because it was blocked for months on getting a Temporal key into the browser compatibility data repo. I had to conclude that the process wasn't really navigable for outsiders. I don't think we can really require it from our side

[22:32:03.0936] <shu>
waldemar: it's not a full pre-parse phase, it's an eager, regular parse phase. pre-parse = parse for syntax errors, do not generate an AST, do not generate bytecode. regular parse = parse, generate an AST, and bytecode.

since pre-parse is default, it turns out slower for a function that's immediately executed to first pre-parse, then to do a full parse. so this is a hint to say "skip that initial pre-parse, because it's gonna be called immediately"

[22:33:39.0128] <shu>
ah, i completely anticipated the wrong question waldemar, apologies

[22:45:18.0394] <nicolo-ribaudo>
‚ö†Ô∏è Remember that this room is public 

[22:45:38.0091] <Chris de Almeida>
yes, do not discuss topic here, or anywhere in matrix for that matter

[22:46:05.0131] <Aki>
`/set mode +m`

[22:47:17.0745] <Rob Palmer>
Due to explicit lazy-loading, our system lends itself to loading code that is highly likely to be executed.  Prior to us rolling out client-side code-caching, we found maximal PIFEs sped up app load times.  The marginal cost of the unnecessary preparse was costing a lot (>100ms.). I believe the need for those legacy-style hints went away after we switch to bytecode caching with high hit rates (90%+ of modules hit the cache).  But for cache misses, I would expect the source hints to still be valuable.

[22:48:22.0672] <rkirsling>
what is the point of `void` there (this question should be separate from the topic, I assume)

[22:53:38.0867] <hax (HE Shi-Jun)>
> <@rkirsling:matrix.org> what is the point of `void` there (this question should be separate from the topic, I assume)

just ignore the value?

[22:54:00.0238] <rkirsling>
yeah, I guess so

[22:54:20.0472] <hax (HE Shi-Jun)>
what's the behavior of`seal` and `freeze` on resizeable typed array?

[22:54:34.0511] <hax (HE Shi-Jun)>
I remember `freeze` just throw?

[22:55:10.0032] <hax (HE Shi-Jun)>
so another option is just throw?

[22:57:51.0746] <Chris de Almeida>
ü§´

[23:29:29.0447] <Ashley Claymore>
> <@rkirsling:matrix.org> what is the point of `void` there (this question should be separate from the topic, I assume)

how topical!

[23:34:38.0400] <rkirsling>
hah!

[23:34:50.0993] <rkirsling>
I just couldn't wait ;)

[23:35:42.0635] <rkirsling>
that'd be an awfully large needs-consensus PR methinks

[23:36:37.0060] <Michael Ficarra>
yeah there's no way that could be done as a needs-consensus PR

[23:47:34.0589] <littledan>
it‚Äôs not just linters: if you use VS Code, then you will immediately get things marked if they are unused, kinda like a soft error, and with void, you wouldn‚Äôt get it marked. I guess tools could learn a convention like _a and do the same.

[23:49:22.0151] <ljharb>
TS also warns on it unless you follow their nonconfigurable convention

[23:50:42.0635] <nicolo-ribaudo>
All of this shows that we made a mistake in the design of using

[23:53:26.0197] <Jack Works>
this is what pattern matching explained why a `void` is better

[23:54:27.0079] <hax (HE Shi-Jun)>
Though I guess pattern matching could still make `_` special case, make it work like `Any` pattern.

[23:54:48.0553] <hax (HE Shi-Jun)>
> <@nicolo-ribaudo:matrix.org> All of this shows that we made a mistake in the design of using

What mistake?

[23:54:57.0035] <Jack Works>
for pattern mathcing currently the following works:

```js
when { x: let _ }: // unused _
when { let x }:  // unused x
when has 'x': // test 'x' in subject
```

[23:55:25.0567] <Jack Works>
* for pattern mathcing currently the following works:

```js
when { x: let _ }: // unused _
when { let x }:  // unused x
when has 'x': // test 'x' in subject (a possibly extension)
```

[23:56:38.0574] <hax (HE Shi-Jun)>
how `when has 'x'` work for multiple property?

[23:56:53.0808] <Jack Works>
> <@haxjs:matrix.org> how `when has 'x'` work for multiple property?

when has 'x' and has 'y'

[23:56:54.0288] <nicolo-ribaudo>
> <@haxjs:matrix.org> What mistake?

Using `using ID = ...` instead of something else (example: `using { expression }`)

[23:57:03.0479] <Jack Works>
* ```js
when has 'x' and has 'y'
```

[23:57:18.0539] <hax (HE Shi-Jun)>
> <@jackworks:matrix.org> ```js
> when has 'x' and has 'y'
> ```

Not bad üôÑ 

[23:57:34.0334] <Jack Works>
or

```js
when { let something } and has 'x': ...
```

[23:58:16.0258] <hax (HE Shi-Jun)>
> <@nicolo-ribaudo:matrix.org> Using `using ID = ...` instead of something else (example: `using { expression }`)

I remember ron mentioned some reasons why not do that , but I can't recall

[23:58:16.0777] <Jack Works>
note `{ let x }` and `has 'x'` are both additional feature and may not exist in the final version. see https://tc39.es/proposal-pattern-matching/ for details

[23:59:34.0289] <Jack Works>
```js
when [let _, let _2, let _3, let x]: ...
when [void, void, void, let x]: ...
when [,,, let x]: ...
```

[23:59:57.0191] <hax (HE Shi-Jun)>
Consider pattern match is new syntax, we always can make `when { x: _ }` work, (at least work if there is no `_` binding exist?)

[23:59:57.0461] <littledan>
This proposal is good. I hope we do it.

[00:00:12.0814] <littledan>
I wonder how browsers feel about this, if they want it to be a desugaring

[00:00:16.0232] <ljharb>
> <@haxjs:matrix.org> Consider pattern match is new syntax, we always can make `when { x: _ }` work, (at least work if there is no `_` binding exist?)

it would be very bad if it sometimes was a binding and sometimes was a discard

[00:00:23.0974] <Jack Works>
> <@haxjs:matrix.org> Consider pattern match is new syntax, we always can make `when { x: _ }` work, (at least work if there is no `_` binding exist?)

this is one of the possible solution what suggested in this discarding proposal

[00:01:10.0407] <hax (HE Shi-Jun)>
> <@ljharb:matrix.org> it would be very bad if it sometimes was a binding and sometimes was a discard

I agree, but `_` is special case. (it's already special in practice)

[00:01:33.0840] <ljharb>
the contention on the discard bindings proposal is that some think it is, and some think it's not. i think it's not.

[00:01:45.0870] <Justin Ridgewell>
Ron mentioned  that `when { x: y } => ‚Ä¶` means that it‚Äôs matching that the object has the structure `{x}` and `x`‚Äôs current value is equal to `y`. Rust doesn‚Äôt have that, it only matches structure and extracts values, you use an additional `when { x } if (x === y) => ‚Ä¶` to specify an exact value.

[00:01:50.0506] <ljharb>
 * the contention on the discard bindings proposal is that some think it is, and some think it's not. i think it's not. some people definitely _treat_ it as if it's special, is all.

[00:02:02.0534] <danielrosenwasser>
> <@jridgewell:matrix.org> Ron mentioned  that `when { x: y } => ‚Ä¶` means that it‚Äôs matching that the object has the structure `{x}` and `x`‚Äôs current value is equal to `y`. Rust doesn‚Äôt have that, it only matches structure and extracts values, you use an additional `when { x } if (x === y) => ‚Ä¶` to specify an exact value.

FWIW

https://x.com/pcwalton/status/1359970388839550976
https://x.com/UINT_MIN/status/1359977668460957696

[00:02:12.0118] <littledan>
I just haven‚Äôt seen the _otherString pattern in enough cases where it felt like something someone actually wanted to write 

[00:02:14.0040] <rbuckton>
If JS didn't have two popular libraries regularly aliases as `_`, I'd say sure let's special case it. but unfortunately, we do.

[00:02:24.0332] <rbuckton>
 * If JS didn't have two popular libraries regularly aliased as `_`, I'd say sure let's special case it. but unfortunately, we do.

[00:02:35.0697] <shu>
> <@littledan:matrix.org> I wonder how browsers feel about this, if they want it to be a desugaring

for me personally the complexity is pretty low unless i'm missing the parser work needed to resolve ambiguities

[00:02:51.0644] <shu>
personally i think it is not necessary at all but i won't fight too hard for it

[00:03:00.0227] <shu>
 * personally i think it is not necessary at all but i won't fight against it

[00:03:07.0540] <shu>
happy to take devs at their word here

[00:03:08.0197] <yulia>
yeah this looks pretty minor to me as well

[00:03:09.0179] <hax (HE Shi-Jun)>
> <@rbuckton:matrix.org> If JS didn't have two popular libraries regularly aliased as `_`, I'd say sure let's special case it. but unfortunately, we do.

but I think most people do not use `_` as the alias in recent years I guess?

[00:03:14.0105] <littledan>
> <@shuyuguo:matrix.org> for me personally the complexity is pretty low unless i'm missing the parser work needed to resolve ambiguities

This is really helpful to understand: it is a cost/benefit tradeoff, and here the cost is low

[00:03:30.0368] <ljharb>
> <@haxjs:matrix.org> but I think most people do not use `_` as the alias in recent years I guess?

tons of people still do for underscore/lodash, at least

[00:03:31.0153] <shu>
it's always a cost/benefit tradeoff

[00:03:43.0889] <shu>
like if there's no cost ot make devs happier, why wouldn't we?

[00:03:52.0756] <Justin Ridgewell>
> <@danielrosenwasser:matrix.org> FWIW
> 
> https://x.com/pcwalton/status/1359970388839550976
> https://x.com/UINT_MIN/status/1359977668460957696

I‚Äôm missing context, what are they trying to say?

[00:03:55.0951] <rbuckton>
Regarding Rust pattern matching. Rust knows statically whether a RHS in a pattern is an existing binding or a new binding, JS does not. Any code could introduce a new global that could change the meaning of something like `match (value) { { x: x, y: y }: ... }`

[00:04:01.0529] <littledan>
Why would it make devs happier if they are all using tools?

[00:04:18.0302] <keith_miller>
Well I hate devs personally :P

[00:04:47.0773] <shu>
well i do also respect the haters

[00:04:49.0019] <rbuckton>
Because JS cannot determine this statically, the pattern matching proposal says an identifier in a pattern is *always* reference. If you intend it to be a declaration, you must use `let`/`const`/`var` to declare it.

[00:04:58.0314] <rbuckton>
 * Because JS cannot determine this statically, the pattern matching proposal says an identifier in a pattern is _always_ a reference. If you intend it to be a declaration, you must use `let`/`const`/`var` to declare it.

[00:05:21.0028] <Justin Ridgewell>
> <@rbuckton:matrix.org> Regarding Rust pattern matching. Rust knows statically whether a RHS in a pattern is an existing binding or a new binding, JS does not. Any code could introduce a new global that could change the meaning of something like `match (value) { { x: x, y: y }: ... }`

Because your patten matching means something different than Rust's.

[00:05:30.0488] <rbuckton>
So you would write
```js
match (value) {
  { x: let x, y: let y }: doSomething(x, y),
}
```

[00:05:38.0587] <hax (HE Shi-Jun)>
> <@ljharb:matrix.org> tons of people still do for underscore/lodash, at least

Not sure about it. I think people use `_` or `$` in no module era (before commonjs), it seems become less and less after we adopt modules, especially esm.

[00:06:08.0496] <danielrosenwasser>
The context is that you have a choice in pattern matching on whether a bare identifier denotes a new binding, or an existing binding to be checked against

[00:06:27.0399] <nicolo-ribaudo>
> <@rbuckton:matrix.org> Regarding Rust pattern matching. Rust knows statically whether a RHS in a pattern is an existing binding or a new binding, JS does not. Any code could introduce a new global that could change the meaning of something like `match (value) { { x: x, y: y }: ... }`

In rust it's just syntax-based, right? i.e. in this case you are introducing a new binding `x`:

```rust
fn main() {
    let x = 42;
    let y = Some(3);
    match y {
        Some(x) => println!("Some"),
        _ => println!("Other")
    }
}
```

[00:06:29.0208] <rbuckton>
> <@jridgewell:matrix.org> Because your patten matching means something different than Rust's.

It only really differs in how bindings are declared, by necessity.

[00:06:59.0061] <ljharb>
> <@haxjs:matrix.org> Not sure about it. I think people use `_` or `$` in no module era (before commonjs), it seems become less and less after we adopt modules, especially esm.

123K results on github alone https://github.com/search?q=%22import+*+as+_+from+%27lodash%27%22&type=code

[00:07:32.0282] <Justin Ridgewell>
> <@nicolo-ribaudo:matrix.org> In rust it's just syntax-based, right? i.e. in this case you are introducing a new binding `x`:
> 
> ```rust
> fn main() {
>     let x = 42;
>     let y = Some(3);
>     match y {
>         Some(x) => println!("Some"),
>         _ => println!("Other")
>     }
> }
> ```

You are always introducing a new binding `x`, you are never matching a value `y === Some(x)`

[00:08:03.0771] <Justin Ridgewell>
To match a value, you use an `if` check on the case

[00:08:22.0791] <rbuckton>
> <@nicolo-ribaudo:matrix.org> In rust it's just syntax-based, right? i.e. in this case you are introducing a new binding `x`:
> 
> ```rust
> fn main() {
>     let x = 42;
>     let y = Some(3);
>     match y {
>         Some(x) => println!("Some"),
>         _ => println!("Other")
>     }
> }
> ```

`Some(x):` may seem obvious, but what about just `{ x: Number }`. Should I be declaring a new variable named `Number` or referencing the `Number` constructor?

[00:08:35.0807] <Ashley Claymore>
> <@yulia:mozilla.org> yeah this looks pretty minor to me as well

would there be any (tiny) advantage to engines, to immediately know the binding is a discard as opposed to discovering that only once the parse finished? Potentially keeping the set of names to track smaller

[00:08:41.0318] <hax (HE Shi-Jun)>
> <@ljharb:matrix.org> 123K results on github alone https://github.com/search?q=%22import+*+as+_+from+%27lodash%27%22&type=code

ok, let me write a bot to send PRs üòÇ

[00:08:55.0463] <ljharb>
lol, careful github doesn't autoban you :-p

[00:09:22.0107] <rbuckton>
> <@aclaymore:matrix.org> would there be any (tiny) advantage to engines, to immediately know the binding is a discard as opposed to discovering that only once the parse finished? Potentially keeping the set of names to track smaller

Do implementations need to declare the number of locals within a function? That increases the memory size of a function at runtime.

[00:09:28.0815] <yulia>
> <@aclaymore:matrix.org> would there be any (tiny) advantage to engines, to immediately know the binding is a discard as opposed to discovering that only once the parse finished? Potentially keeping the set of names to track smaller

erm. maybe i am sleep deprived, how would we do this before parse?

[00:09:37.0706] <yulia>
> <@rbuckton:matrix.org> Do implementations need to declare the number of locals within a function? That increases the memory size of a function at runtime.

yep

[00:09:59.0305] <yulia>
> <@rbuckton:matrix.org> Do implementations need to declare the number of locals within a function? That increases the memory size of a function at runtime.

 * yep (we do anyway)

[00:10:09.0258] <rbuckton>
So yes, there is probably a tiny benefit to implementations since they don't need to hold onto a local for those variables.

[00:10:29.0358] <rbuckton>
The spec text also skips adding a binding.

[00:10:38.0214] <Ashley Claymore>
I was thinking during the parse, rather than before the parse

[00:10:55.0120] <Ashley Claymore>
 * I was thinking 'during the parse', rather than 'before the parse'

[00:11:36.0828] <Justin Ridgewell>
Can anyone on the call hear the room?

[00:11:41.0348] <yulia>
_thinking_ 

[00:11:44.0034] <danielrosenwasser>
For a `using` you still need to basically keep the "discarded" value around until the end of the scope, so even if it's not identifiable by a variable name, some work needs to happen.

[00:12:27.0584] <danielrosenwasser>
(right?)

[00:12:37.0327] <nicolo-ribaudo>
shu It's what the user reads in the callback of the event listener

[00:12:46.0663] <rbuckton>
> <@danielrosenwasser:matrix.org> For a `using` you still need to basically keep the "discarded" value around until the end of the scope, so even if it's not identifiable by a variable name, some work needs to happen.

For a `using`, there are two memory locations that hold the value. One is in the environment record for later disposal, the other is in the variable binding itself.

[00:12:54.0948] <yulia>
you would still do the whole parse before constructing the necessary stuff for the script's representation. so this wouldn't be a benefit during parse i think... i don't recall the details of the proposal right now -- if a const binding is void is that name disallowed in the function? im not sure it would help, that might just be more stuff to track and then throw errors on

[00:13:04.0274] <shu>
> <@nicolo-ribaudo:matrix.org> shu It's what the user reads in the callback of the event listener

so "nullable" on that slide means "could be null in the case there was no JS code that triggered the dispatch"

[00:13:17.0566] <yulia>
you'd still have to do the full parse. but, we could discard it as part of our count of things that are local to the function, thats true

[00:13:24.0375] <yulia>
i don't think its a huge improvement 

[00:13:32.0559] <littledan>
Is there time for a timebox extension? This proposal deserves a bit of discussion 

[00:14:07.0505] <Chris de Almeida>
yes

[00:14:31.0533] <Michael Ficarra>
yeah it should've been given a bigger timebox to begin with

[00:14:35.0382] <nicolo-ribaudo>
```js

x.run("registration", () => {
  addEventListener("foo", () => { x.get() })
});

x.run("dispatch", () => {
dispatchEvent("foo")
})
```

[00:14:46.0035] <nicolo-ribaudo>
^ example of the two contexts

[00:15:02.0808] <nicolo-ribaudo>
If the dispatch happens from user interaction, than that's null

[00:15:10.0999] <nicolo-ribaudo>
If it's from JS code, there is something

[00:15:17.0853] <shu>
uh i forget the signature for run()

[00:16:11.0758] <Justin Ridgewell>
> <@shuyuguo:matrix.org> uh i forget the signature for run()

The first param is the new internal value of the async var, the second is a callback that is invoked immedaitely. When the callback returns, the internal value is reset to the previous value.

[00:18:44.0130] <yulia>
hello everyone, I am your erzats chair for the next 5 min

[00:19:36.0859] <yulia>
 * hello everyone, I am your ersatz chair for the next 5 min

[00:21:00.0561] <yulia>
chair relinquished

[00:21:03.0474] <jkup>
you had a good run 

[00:31:49.0009] <nicolo-ribaudo>
For whoever can speak to Mark: I can come to TG3 next week if we don't get to your TCQ topic

[00:32:29.0015] <Aki>
ljharb: ‚òùÔ∏è

[00:34:36.0012] <jkup>
Did the call drop remotely?

[00:35:01.0149] <nicolo-ribaudo>
It was you in the room having problems

[00:35:04.0533] <nicolo-ribaudo>
I could hear Mark well

[00:47:14.0495] <Aki>
while we're between agenda items: i'm looking for an example of a small proposal focussed on developer ergonomics that went through the stage process pretty smoothly in the past few years

[00:48:47.0557] <rkirsling>
I think Promise.try flew through pretty quick

[00:48:53.0508] <Rob Palmer>
Promise.withResolvers

[00:49:34.0939] <nicolo-ribaudo>
> <@rkirsling:matrix.org> I think Promise.try flew through pretty quick

8 years according to the champion

[00:49:43.0255] <rkirsling>
oops

[00:50:00.0829] <jkup>
> <@nicolo-ribaudo:matrix.org> 8 years according to the champion

8 smooth years though

[00:50:01.0197] <rkirsling>
totally missed that part somehow lol

[00:50:02.0733] <nicolo-ribaudo>
To be fair it has been at stage 1 for 7 of those 8 years

[00:51:29.0397] <ljharb>
stage 2 to 4 was indeed smooth

[00:51:33.0430] <ljharb>
1 to 2 was a beast tho

[00:55:10.0054] <rkirsling>
"gently unsure" is such a great phrasing

[01:00:29.0753] <shu>
in general, for API features that are purely motivated by convenience, i'd like us to take a bigger scope view and do some prioritization

[01:00:49.0037] <shu>
michael has followed a program of 'make iterators more helpful', which i personally agree is well motivated

[01:01:08.0919] <shu>
but i do regularly hear the deficiency of the JS stdlib

[01:02:09.0106] <shu>
to take a personal pet peeve: we don't have some pretty basic data structures, like Queue, and people are using arrays to poorly emulate. how does something like that weigh against 'make iterators even more helpful'

[01:02:49.0007] <yulia>
yeah, thats a good question

[01:03:43.0729] <rkirsling>
is that a true statement? I have always viewed the push/pop/shift/unshift methods to imply that arrays simply _are_ stacks or queues or whatever

[01:04:24.0741] <ljharb>
arrays are sadly queues, and stacks, and lists, all at once

[01:04:37.0462] <shu>
there are crimes being done in the engine to support the expected algorithmic complexity of queue vs stack vs random-access arrays

[01:04:42.0332] <shu>
that's what i meant by "poorly emulate" above

[01:04:59.0666] <Michael Ficarra>
also MultiMaps!

[01:05:00.0980] <shu>
yes, you can use them as such, but we'd also like have data structures fit for purpose

[01:05:18.0865] <Michael Ficarra>
please someone give us MultiMaps

[01:05:19.0419] <shu>
it might be a bit late

[01:05:36.0972] <rkirsling>
relative to which it would seem needlessly Java-like to demand a Queue or Stack class... but then that could _also_ have been an argument against Map (wrt Object), so

[01:05:37.0800] <nicolo-ribaudo>
> <@michaelficarra:matrix.org> please someone give us MultiMaps

Is it the compositeKey proposal Ashley is working on?

[01:05:58.0589] <rkirsling>
maybe the times have simply changed on me

[01:06:07.0864] <nicolo-ribaudo>
Oh no it's something else

[01:08:31.0832] <nicolo-ribaudo>
I was distracted

[01:08:39.0103] <nicolo-ribaudo>
What's happening now? Are done?

[01:08:52.0851] <Chengzhong Wu>
Restricting subclassing support in built-in methods: Telemetry Results (Firefox) Update

[01:08:55.0236] <shu>
no, we're doing yulia's update on killing species

[01:09:00.0899] <Justin Ridgewell>
Yulia is presenting subclassing

[01:09:02.0329] <shu>
i should've named the proposal Extinction

[01:09:02.0850] <nicolo-ribaudo>
Oh ok thanks to who spoke

[01:09:23.0334] <Chengzhong Wu>
20min

[01:13:53.0969] <rbuckton>
I use `Symbol.species` for Array subclasses when I don't want `.map`/`.filter` to produce an instance of the subclass because the constructor parameters differ.

[01:14:33.0032] <rbuckton>
Without it I have to override map, filter, slice, et al and provide my own implementation.

[01:14:47.0658] <shu>
that seems better

[01:14:58.0604] <rbuckton>
Not really.

[01:15:32.0110] <Ashley Claymore>
if we hadn't of done Symbol.species, wouldn't you have gotten your desired behaviour by default?

[01:16:06.0756] <rbuckton>
It's not that I need `Symbol.species`. It's that I need some way to tell the superclass to just produce `Array` and not my subclass.

[01:17:06.0880] <rbuckton>
Yes, if we didn't have symbol.species and the default behavior was not to try to produce an instance from the current constructor, that would have been acceptable.

[01:18:01.0678] <Ashley Claymore>
This is what we do in the new Array methods

[01:18:29.0420] <littledan>
XRegExp was a big source of type 4 stuff

[01:18:34.0882] <rbuckton>
But if you unship Symbol.species you need to choose whether to only return `Array` instances or to only return `this.constructor` instances. The question is who are you breaking by choosing one or the other.

[01:19:02.0499] <nicolo-ribaudo>
I feel that "Yeah" very hard

[01:19:14.0872] <Ashley Claymore>
```
class MyArray extends Array {}
new MyArray().toSorted() instanceof MyArray; // false
```

[01:21:15.0562] <littledan>
> <@rbuckton:matrix.org> But if you unship Symbol.species you need to choose whether to only return `Array` instances or to only return `this.constructor` instances. The question is who are you breaking by choosing one or the other.

Yeah I suspect that Array and maybe Promise are more real than RegExp‚Äîmore plausible to have not-just-polyfill usages

[01:21:15.0682] <rbuckton>
Essentially, I only use Symbol.species to work around the existence of Symbol.species.

[01:22:16.0616] <nicolo-ribaudo>
Can we use AI to filter those cases

[01:22:26.0037] <nicolo-ribaudo>
Google is already shipping it in the browser

[01:22:36.0676] <nicolo-ribaudo>
It can run in the background and check all the loaded pages :)

[01:22:41.0325] <rbuckton>
I have no intuition as to how many people are subclassing `Array` and it actually matters that `.map()` et al produce a subclass. These implementations wouldn't be overriding `Symbol.species`, just using the default behavior.

[01:27:04.0339] <Justin Ridgewell>
Yah, Type II Array uses are probably genuine

[01:27:19.0998] <Justin Ridgewell>
It‚Äôs just too simple for a web dev to have written

[01:29:38.0440] <rbuckton>
Historically we've had two opposing positions on subclassing and overriding methods:
1. Overriding methods is bad because anyone can call `superclass.prototype.method.call(subclassinstance)` and ignore any behavior imposed by the subclass. The suggested solution was to somehow bake this information into the instance. Using `Symbol.species` falls under this category
2. Don't use `Symbol.species` and instead override methods.


[01:30:27.0124] <rbuckton>
For example, (1) was the approach considered for things like customizing keying for `Map`/`Set`.

[01:31:31.0459] <rbuckton>
1 and 2 aren't polar opposites, but they do cross purposes wrt Symbol.species and how/when to handle subclass construction for results.

[01:33:12.0423] <rbuckton>
A third approach is wrapping, but you cant wrap an `Array` due to its exotic nature.

[01:34:43.0975] <rbuckton>
(at least, not without a `Proxy`, which is hard to get right and slow)

[01:50:31.0047] <hax (HE Shi-Jun)>
`Symbol.species` provide a hook which just like protected member in OOP. Compare to other protocol I don't think it's inevitable evil. My question is why it's a static property? If it's a instance property, would it be better for the engines?

[02:55:10.0934] <Anthony Bullard>
I think the thing missed in this discussion is that in languages that do a ton of this, and where it‚Äôs fast (zero cost-ish or better) the extraction requires no function call or hidden user code.  It‚Äôs literally the same lookups and comparisons you can see in the patterns and possibly some branch caching.

If we got rid of Extractors with custom user code, 90% of concerns over hidden perf costs go away

[04:56:56.0776] <Duncan MacGregor>
Did the "Next meeting host and logistics" agenda item get cut, or was it simply not minuted? I don't see it in the day 1 notes.

[16:12:25.0121] <Michael Ficarra>
> <@aardvark179:matrix.org> Did the "Next meeting host and logistics" agenda item get cut, or was it simply not minuted? I don't see it in the day 1 notes.

It was briefly mentioned.


2024-10-10
[18:00:53.0948] <jkup>
yulia: Ashley Claymore Rob Palmer this is what I was referring to https://firefox-source-docs.mozilla.org/devtools-user/custom_formatters/index.html

[18:03:09.0400] <yulia>
heck, added 2022. nice

[18:03:25.0970] <yulia>
 * heck, added 2023. nice

[18:04:00.0744] <yulia>
 * heck, added 2022. nice

[18:06:15.0387] <msaboff>
Add your name, etc to today's notes.

[18:10:52.0572] <littledan>
I really like Mark‚Äôs thing of recording and posting his presentations. It‚Äôd be great if we can make this an option for presenters all the time, and post the presentations to a TC39 YouTube channel, for presenters who want it.

[18:12:04.0746] <Andreu Botella (at TC39, üïê JST)>
would that make it harder to remove sections from the notes, since the video would also need to be edited?

[18:12:31.0479] <bakkot>
yes, but we only very rarely do that, and mostly for entire items rather than small parts of a presentation

[18:12:59.0780] <Justin Ridgewell>
Strings will deoptimize pretty quickly once you store non-utf8 bytes

[18:13:14.0706] <Justin Ridgewell>
And assembling them byte by byte is not very fast

[18:13:59.0875] <Andreu Botella (at TC39, üïê JST)>
> <@jridgewell:matrix.org> Strings will deoptimize pretty quickly once you store non-utf8 bytes

In typical implementations, I don't think that's true, since all engines have Latin-1 and UTF-16 representations

[18:14:01.0277] <canadahonk>
used strings personally before and it is not nice

[18:14:14.0284] <canadahonk>
 * used strings personally before and it is not nice. works but :/

[18:14:22.0124] <Andreu Botella (at TC39, üïê JST)>
> <@jridgewell:matrix.org> Strings will deoptimize pretty quickly once you store non-utf8 bytes

 * In typical implementations, I don't think that's true, since all engines have Latin-1 and UTF-16 representations, but not UTF-8

[18:15:44.0958] <Justin Ridgewell>
> <@abotella:igalia.com> In typical implementations, I don't think that's true, since all engines have Latin-1 and UTF-16 representations, but not UTF-8

Is V8‚Äôs one-byte string Latin1? When I wrote the UTF-8 parser, it would create 2 byte strings once you went over 0x80

[18:16:09.0627] <Chris de Almeida>
> <@littledan:matrix.org> I really like Mark‚Äôs thing of recording and posting his presentations. It‚Äôd be great if we can make this an option for presenters all the time, and post the presentations to a TC39 YouTube channel, for presenters who want it.

cc Aki 

[18:16:11.0603] <Mathieu Hofman>
Also you can't build a real TypedArray with a string backing, so might as well shim it with a mutable array buffer copy

[18:16:12.0251] <Andreu Botella (at TC39, üïê JST)>
> <@jridgewell:matrix.org> Is V8‚Äôs one-byte string Latin1? When I wrote the UTF-8 parser, it would create 2 byte strings once you went over 0x80

huh, that was not my understanding

[18:17:05.0331] <Andreu Botella (at TC39, üïê JST)>
a Latin-1 string representation is identical to a byte array, where the Unicode character values would just be the byte values

[18:19:34.0878] <Marja H√∂ltt√§>
v8 has two types of strings, one-byte (latin1) and two-byte (not quite utf-16 but ucs... something... maybe ucs-2)

[18:20:43.0089] <Marja H√∂ltt√§>
and interestingly, it also has an utf-8 parser which is used during streaming compilation, it can do stuff like pause between characters if we need to wait for more data from the network. so in that case we don't use chromium's utf-8 parser but our own

[18:20:57.0341] <Marja H√∂ltt√§>
 * and interestingly, it also has an utf-8 parser which is used during streaming parsing, it can do stuff like pause between characters if we need to wait for more data from the network. so in that case we don't use chromium's utf-8 parser but our own

[18:21:12.0166] <Marja H√∂ltt√§>
 * and interestingly, it also has an utf-8 decoder which is used during streaming parsing, it can do stuff like pause between characters if we need to wait for more data from the network. so in that case we don't use chromium's utf-8 decoder but our own

[18:22:11.0850] <Marja H√∂ltt√§>
 * and interestingly, it also has an utf-8 decoder which is used during streaming parsing, it can do stuff like pause mid-character if we need to wait for more data from the network. so in that case we don't use chromium's utf-8 decoder but our own

[18:22:39.0363] <Andreu Botella (at TC39, üïê JST)>
> <@marjakh:matrix.org> v8 has two types of strings, one-byte (latin1) and two-byte (not quite utf-16 but ucs... something... maybe ucs-2)

I don't know if WTF-16 is the right term for that (https://simonsapin.github.io/wtf-8/#ill-formed-utf-16)

[18:26:32.0031] <Chris de Almeida>
please add your name to the attendees list of today's notes doc

[18:26:37.0291] <Richard Gibson>
> <@abotella:igalia.com> I don't know if WTF-16 is the right term for that (https://simonsapin.github.io/wtf-8/#ill-formed-utf-16)

yeah, pretty much

[18:28:25.0185] <Justin Ridgewell>
> <@abotella:igalia.com> a Latin-1 string representation is identical to a byte array, where the Unicode character values would just be the byte values

Verified, you are correct. If you stay below 0xff, you‚Äôll keep `ONE_BYTE_STRING` representation.

[18:28:40.0878] <Justin Ridgewell>
> <@marjakh:matrix.org> and interestingly, it also has an utf-8 decoder which is used during streaming parsing, it can do stuff like pause mid-character if we need to wait for more data from the network. so in that case we don't use chromium's utf-8 decoder but our own

I wrote that!

[18:29:30.0758] <bakkot>
if you do it in the next 10 seconds i don't have to redact the logs

[18:29:39.0503] <bakkot>
yay

[18:29:39.0971] <Marja H√∂ltt√§>
Justin Ridgewell: no, not that one. maybe there is another one you wrote :)

[18:29:46.0706] <ryzokuken>
üôá‚Äç‚ôÇÔ∏è

[18:29:55.0075] <Marja H√∂ltt√§>
too many utf-8 decoders

[18:30:02.0534] <canadahonk>
sorry üôà

[18:30:08.0627] <Chris de Almeida>
/me shows `canadahonk` to the shamecube

[18:30:24.0998] <Michael Ficarra>
we need regular reminders that this is a public channel

[18:30:46.0287] <Justin Ridgewell>
> <@marjakh:matrix.org> Justin Ridgewell: no, not that one. maybe there is another one you wrote :)

https://source.chromium.org/chromium/chromium/src/+/main:v8/src/third_party/utf8-decoder/;l=1;bpv=1;bpt=0 ?

[18:32:12.0332] <bakkot>
2017-12-11, nice

[18:32:19.0166] <Marja H√∂ltt√§>
Justin Ridgewell: nope, this one: https://source.chromium.org/chromium/chromium/src/+/main:v8/src/parsing/scanner-character-streams.cc;l=507  .. and... i wrote it :D

[18:32:42.0849] <Marja H√∂ltt√§>
we can unify these if your version can also pause mid-character to wait for more data

[18:32:57.0493] <Chris de Almeida>
bakkot: the notes link made it to the archive üò≠üò≠üò≠

[18:33:31.0075] <bakkot>
sadness

[18:35:09.0302] <Justin Ridgewell>
> <@marjakh:matrix.org> we can unify these if your version can also pause mid-character to wait for more data

That‚Äôs just a small wrapper around my code: https://source.chromium.org/chromium/chromium/src/+/main:v8/src/parsing/scanner-character-streams.cc;l=622-623;drc=a9777d919551975bd1208221a8ba8c012c03bc56

[18:35:09.0665] <Marja H√∂ltt√§>
based on very quick googling it seems that the difference between UCS-2 and UTF-16 is more than treating the ill-formed strings but my knowledge level is getting very shaky here

[18:35:42.0534] <Marja H√∂ltt√§>
ahh it has been rewritten since, okay that's good, i think 2 utf-8 decoders are enough for chromium

[18:35:58.0097] <Justin Ridgewell>
UCS-2 allows lone surrogates, UTF-16 doesn't

[18:36:03.0921] <Justin Ridgewell>
They‚Äôre the same otherwise

[18:38:17.0588] <Marja H√∂ltt√§>
google says "UCS-2 is fixed width, UTF-16 is variable width with a minimum of two bytes and a maximum of four bytes." << what about this part? no idea what v8 does here

[18:38:24.0925] <littledan>
A related interesting API proposal https://gist.github.com/domenic/a9343fa787ba54b4ba3a60882c49cc32?permalink_comment_id=4394695#gistcomment-4394695

[18:38:55.0936] <Rob Palmer>
Can anyone dialled in share the TCQ on Teams?

[18:39:20.0233] <jkup>
It was up for a second

[18:39:41.0088] <littledan>
IMO it‚Äôs more parsimonious to have a separate method

[18:40:06.0955] <Justin Ridgewell>
> <@marjakh:matrix.org> google says "UCS-2 is fixed width, UTF-16 is variable width with a minimum of two bytes and a maximum of four bytes." << what about this part? no idea what v8 does here

That‚Äôs if you want to combine surrogates into a single UTF char (u32). The streams themselves are the same.

[18:41:13.0061] <littledan>
I think the meaning of ucs2 has changed over time. It was designed in the days when all code points fit in 16 bits. Since then, it has been redefined to mean, potentially ill-formed utf16

[18:41:59.0912] <Justin Ridgewell>
Yah, baseically that ^

[18:42:10.0356] <Justin Ridgewell>
* Yah, basically that ^

[18:42:12.0369] <littledan>
JS generally does not check for well-formed-ness so you could (informally) say it works in the ucs2 encoding rather than utf16

[18:46:11.0503] <Marja H√∂ltt√§>
oh, and wtf-16 says it's the name kinda corresponding to that evolved usage of ucs-2. yess, not confusing at all. okay.

[18:50:09.0967] <Marja H√∂ltt√§>
ok how did we end up here? what does "Strings will deoptimize pretty quickly once you store non-utf8 bytes" mean? one thing that's not great about onebyte vs twobyte is that if you have one non-onebyte character in your string, the whole string has to be stored as a twobyte and it's slightly unnecessary overhead.

[18:50:56.0863] <Marja H√∂ltt√§>
(but i don't see a way around it in the current world unless we add utf-8 strings and... i don't think anyone wants to... strings are incredibly complex as is)

[18:52:58.0744] <Michael Ficarra>
@marjakh:matrix.org ropes of mixed 1-byte and 2-byte sections

[18:53:41.0836] <Marja H√∂ltt√§>
true, could also do that!

[18:53:53.0338] <littledan>
No I wasn‚Äôt talking about volatile read-only views on an underlying changing ArrayBuffee

[18:53:55.0251] <Justin Ridgewell>
> <@marjakh:matrix.org> ok how did we end up here? what does "Strings will deoptimize pretty quickly once you store non-utf8 bytes" mean? one thing that's not great about onebyte vs twobyte is that if you have one non-onebyte character in your string, the whole string has to be stored as a twobyte and it's slightly unnecessary overhead.

I mistakenly though that `String.fromCharCode(0x80)` returned a 2-byte string representation

[18:53:59.0996] <littledan>
* No I wasn‚Äôt talking about volatile read-only views on an underlying changing ArrayBuffer

[18:54:19.0377] <Justin Ridgewell>
`0x80` being an illegal UTF-8 lead byte

[18:55:01.0194] <Justin Ridgewell>
You can construct strings in memory that holds any byte sequence, you just can‚Äôt transfer that string over the wire

[18:55:47.0574] <Justin Ridgewell>
A UTF-8 parser on the other end will replace bad byte sequences with the Replacement Char

[18:56:31.0453] <littledan>
I am also OK keeping the rw lock stuff outside of this proposal but I think it could make it more usable for certain cases, which could allow some more zero copy in practice. Not needed for the motivating embedded case though.

[18:57:15.0490] <Andreu Botella (at TC39, üïê JST)>
> <@marjakh:matrix.org> (but i don't see a way around it in the current world unless we add utf-8 strings and... i don't think anyone wants to... strings are incredibly complex as is)

Some hosts work with UTF-8 strings and would benefit from not having to convert when making them into JS string primitives. Whether that is offset by the cost of adding UTF-8 strings to the engine is a different question though

[18:59:02.0088] <littledan>
I am very happy that the wasm memory control stuff is getting attention 

[19:00:35.0850] <Mathieu Hofman>
I took a quick look, and it looks like it's basically trying to specify a full MMU ?

[19:01:02.0804] <shu>
it's a pretty open question but in the limit, yeah, systems people are gonna want full control

[19:01:10.0034] <shu>
i haven't heard anything _too_ concrete yet

[19:01:54.0669] <yulia>
yeah i think they are still exploring quite a bit.

[19:03:03.0558] <littledan>
I hope we get memory protection for the first page so I can get a segfault in Wasm for derefencing a null pointer

[19:03:34.0342] <littledan>
* I hope we get the capability to set up memory protection for the first page so I can get a segfault in Wasm for derefencing a null pointer

[19:04:45.0718] <shu>
As a... Unix user, I want my programs to SIGSEV, so th

bus error

[19:11:10.0446] <littledan>
It would be really interesting to hear a presentation about how various approaches to polyfills work, since it seems to drive a lot of our designs

[19:15:07.0446] <littledan>
In general it‚Äôs good to find reasons which could be motivating for others, but it also is interesting to learn what the proponents are motivated by.

[19:19:29.0453] <keith_miller>
Isn't the clamping just `value & 256`?

[19:19:35.0878] <shu>
yeah i am confused

[19:19:39.0273] <keith_miller>
Or is there some other part that's not quite that?

[19:20:27.0303] <Justin Ridgewell>
> <@keith_miller:matrix.org> Isn't the clamping just `value & 256`?

`value & 255`

[19:20:34.0044] <keith_miller>
Err sorry

[19:20:35.0788] <keith_miller>
Yeah

[19:20:57.0425] <Andreu Botella (at TC39, üïê JST)>
or `value % 256`

[19:21:14.0158] <littledan>
That‚Äôs how normal uint8arrays work; I thought clamped was different 

[19:21:41.0709] <littledan>
What if we added a Math.clamp method? I think that would be a broadly useful utility.

[19:21:56.0946] <Justin Ridgewell>
^CSS did, not us

[19:21:59.0800] <yulia>
right but what are we solving exactly rn?

[19:22:02.0698] <ljharb>
so the spec logic is https://tc39.es/ecma262/#sec-touint8clamp

[19:22:24.0465] <ljharb>
if all those steps are just `value & 255` then an editorial cleanup would certainly have helped :-)

[19:22:25.0986] <shu>
wait, why isn't that algorithm steps?

[19:22:32.0438] <shu>
you said it wans't described in algo steps

[19:22:40.0956] <rbuckton>
Is that clamping or does that allow overflow/underflow?

[19:22:41.0536] <Justin Ridgewell>
> <@ljharb:matrix.org> if all those steps are just `value & 255` then an editorial cleanup would certainly have helped :-)

No, it won‚Äôt round

[19:22:44.0705] <ljharb>
yes, my mistake, it is algorithm steps

[19:22:58.0204] <littledan>
> <@yulia:mozilla.org> right but what are we solving exactly rn?

Is this asking about Math.clamp? That is just saving a couple lines of code, making everyday things slightly nicer. Also fine by me to not do.

[19:23:44.0071] <Michael Ficarra>
FYI we also didn't get a summary for the previous topic

[19:24:03.0616] <yulia>
is math.clamp more general than the dataview methods? i'm not opposed to it, would be good to see which everyday things are being improved

[19:24:22.0673] <yulia>
i think the spec has a oneliner note using modulo

[19:24:24.0318] <keith_miller>
Wait sorry it's not `value & 255` lol I'm too tired it's ```if (number > 255) return 255; if (number < 0) return 0; return number;```

[19:24:27.0674] <shu>
wait taking a step back

[19:24:28.0139] <yulia>
https://tc39.es/ecma262/#clamping

[19:24:43.0860] <shu>
why did we add uint8clamp TAs to begin with?

[19:24:47.0783] <shu>
something textures?

[19:24:55.0727] <keith_miller>
I think for textures or something yeah

[19:25:05.0370] <keith_miller>
 * I think for textures/colors or something yeah

[19:25:34.0407] <Justin Ridgewell>
> <@keith_miller:matrix.org> Wait sorry it's not `value & 255` lol I'm too tired it's ```if (number > 255) return 255; if (number < 0) return 0; return number;```

Ahh, I forgot about negaties. But you‚Äôre missing the rounding, too.

[19:25:39.0496] <canadahonk>
> <@yulia:mozilla.org> is math.clamp more general than the dataview methods? i'm not opposed to it, would be good to see which everyday things are being improved

written it at least a few times for webapps in the past

[19:25:42.0559] <littledan>
> <@yulia:mozilla.org> is math.clamp more general than the dataview methods? i'm not opposed to it, would be good to see which everyday things are being improved

Yeah it doesn‚Äôt really have to do with data views, it‚Äôs just like you give a min and max and return one of those if you are out of bounds

[19:26:03.0588] <yulia>
sure, that sounds fine

[19:26:17.0527] <shu>
> <@canadahonk:matrix.org> written it at least a few times for webapps in the past

what was it for?

[19:26:40.0797] <rbuckton>
yulia: I have code that could make use of consistent names for data view methods for the purpose of dynamic dispatch, were it to be rewritten to use dynamic dispatch: https://github.com/esfx/esfx/blob/main/packages/struct-type/src/internal/numbers.ts#L122-L133 one data point may not necessarily be compelling, however.

[19:26:57.0663] <ljharb>
here's my summary:
> - In order to advance, champion needs to provide use cases that are actually solved by the proposal; polyfilling is not solved by it.
> - Current proposal is get + set; based on future presented use cases, other alternatives may include ‚Äújust set‚Äù, or ‚Äújust a clamp helper‚Äù

lmk if i'm missing anything

[19:27:13.0103] <canadahonk>
there is a ~new math.clamp proposal that lacks a champion btw

[19:27:27.0333] <ljharb>
> <@littledan:matrix.org> Yeah it doesn‚Äôt really have to do with data views, it‚Äôs just like you give a min and max and return one of those if you are out of bounds

Math.clamp is nice but wouldn't give me the rounding i need

[19:27:49.0535] <canadahonk>
> <@canadahonk:matrix.org> there is a ~new math.clamp proposal that lacks a champion btw

https://github.com/Richienb/proposal-math-clamp which I may if no one else wants :^)

[19:28:05.0311] <yulia>
if you had math.clamp you could use math.floor with it, no?

[19:28:58.0625] <Michael Ficarra>
> <@canadahonk:matrix.org> https://github.com/Richienb/proposal-math-clamp which I may if no one else wants :^)

discourse thread: https://es.discourse.group/t/math-clamp-strawman/1059

[19:29:04.0195] <ljharb>
and ceil if negative, sure. Math.clamp helps me compose the logic for sure.

[19:29:04.0253] <shu>
`Number.setFPUControlWord` so we can change the rounding mode to round half to even

[19:31:57.0926] <keith_miller>
Is `Math.clamp` sufficiently more powerful than `Math.min(Math.max(x, upper), lower)`?

[19:32:27.0508] <keith_miller>
 * Is `Math.clamp` sufficiently more powerful than `Math.min(Math.max(x, lower), upper)`?

[19:32:36.0691] <rbuckton>
It's sufficiently easier to get right the first time

[19:33:10.0796] <canadahonk>
also something something performance probably better?

[19:33:27.0198] <keith_miller>
Ehh, I think I'd screw up the argument order too though

[19:33:37.0365] <keith_miller>
On 8 hours of sleep over 3 days

[19:33:46.0738] <keith_miller>
Performance is probably the same

[19:33:56.0244] <canadahonk>
2 func calls vs 1?

[19:34:12.0326] <keith_miller>
It would be inlined and optimized in most JIT engines anyway

[19:35:21.0005] <rbuckton>
I imagine signature help in an IDE is more reliable for something that reads `Math.clamp(value: number, min: number, max: number)` then trying to figure out the correct order for `Math.min(x: number, y: number)` and `Math.max(x: number, y: number)`.

[19:35:27.0219] <littledan>
Yeah I don‚Äôt think this is a thing to decide on perf but rather developer mental model 

[19:35:50.0562] <canadahonk>
> <@littledan:matrix.org> Yeah I don‚Äôt think this is a thing to decide on perf but rather developer mental model

agree, but I mean it definitely wouldn't be a downside at least

[19:36:07.0814] <canadahonk>
> <@littledan:matrix.org> Yeah I don‚Äôt think this is a thing to decide on perf but rather developer mental model

 * agree, but I mean it definitely wouldn't be a downside at least, only possible benefit (afaik)

[19:37:59.0938] <jkup>
clamp seems nice, especially combining it with round/floor

[19:51:56.0985] <ljharb>
liquid volume remains solidly imperial for cooking

[19:52:02.0839] <ljharb>
 * liquid volume remains solidly imperial for cooking, in the US

[19:52:11.0235] <ljharb>
also gasoline

[19:52:12.0103] <rbuckton>
> <@ljharb:matrix.org> liquid volume remains solidly imperial for cooking, in the US

unless you are baking

[19:52:16.0378] <ljharb>
 * also gasoline and milk

[19:52:39.0096] <ljharb>
hm, maybe i don't bake with the newest recipes, but i still see them all in imperial

[19:52:40.0757] <rbuckton>
> <@ljharb:matrix.org> also gasoline and milk

Or buying soda

[19:52:51.0854] <shu>
wait what

[19:52:56.0301] <shu>
liter is an imperial unit?

[19:53:06.0682] <ljharb>
soda is non-imperial

[19:53:12.0376] <ljharb>
gas/milk is imperial

[19:53:13.0015] <rbuckton>
No, I'm saying soda is not imperial

[19:53:14.0366] <shu>
oh i got it reversed

[19:53:17.0425] <shu>
right

[19:53:19.0952] <rbuckton>
 * No, I'm saying soda is not generally measured in imperial units

[19:53:22.0076] <Chris de Almeida>
you don't use volume in baking

[19:53:38.0091] <rkirsling>
what a plot twist that soda is an unamerican drink

[19:53:46.0963] <ljharb>
like a teaspoon of oil or something?

[19:54:13.0768] <ljharb>
a cup of water, etc

[19:54:14.0274] <rbuckton>
> <@softwarechris:matrix.org> you don't use volume in baking

I suppose it's by weight if you're using a kitchen scale for measuring

[19:54:22.0701] <Michael Ficarra>
I think the british baking show has rubbed off on americans and now they all use metric units when baking

[19:54:39.0032] <Chris de Almeida>
it's always by weight if you're doing it right...  but it does help that 1ml === 1g

[19:54:48.0373] <ljharb>
maybe yall are doing fancier baking than me, but ive not yet heard americans using metric for baking

[19:54:48.0377] <ryzokuken>
for water

[19:54:52.0925] <Chris de Almeida>
yes

[19:55:47.0213] <rbuckton>
I'm finding myself using metric more and more as I venture deeper and deeper into the 3D printing world

[19:55:47.0692] <Chris de Almeida>
if you see a baking recipe and it's giving volume measurements, throw it in the trash

[19:57:12.0676] <ljharb>
/me nervously glances at literally every cake box in safeway

[19:57:20.0429] <ljharb>
/me  * nervously glances at literally every cake mix box in safeway

[19:57:49.0618] <Chris de Almeida>
cake mix?!  `/scoff`

[19:57:54.0563] <Michael Ficarra>
A BOX?!

[19:57:59.0725] <Michael Ficarra>
jesus

[19:58:09.0023] <shu>
what, you want your cake box in a paper bag?

[19:58:14.0707] <shu>
 * what, you want your cake mix in a paper bag?

[19:58:42.0270] <Chris de Almeida>
unserious cake mixers itc

[20:00:41.0047] <ljharb>
wait what else would cake mix come in but a bo

[20:00:42.0016] <ljharb>
 * wait what else would cake mix come in but a box

[20:01:08.0682] <kriskowal>
50# sacks

[20:01:09.0254] <ljharb>
i mean it's bagged inside the box ofc, like cereal

[20:01:23.0342] <canadahonk>
usage="cake-mix"

[20:01:25.0375] <ptomato>
> <@ljharb:matrix.org> wait what else would cake mix come in but a box

a cake mix tureen, what else

[20:01:27.0890] <canadahonk>
 * `usage="cake-mix"`

[20:01:28.0211] <Richard Gibson>
aluminum cans

[20:01:38.0552] <Michael Ficarra>
it wouldn't be cake mix and it wouldn't be in a box, it would be raw ingredients

[20:01:56.0316] <Chris de Almeida>
the rawest

[20:01:58.0439] <ljharb>
ok, calm down, you baking elitists

[20:02:09.0687] <Chris de Almeida>
if you're not milling your own flour are you really a baker?

[20:02:21.0981] <kriskowal>
that would be a miller

[20:03:05.0415] <ljharb>
https://abcnews.go.com/Lifestyle/man-spends-months-1500-make-sandwich-scratch/story?id=33802231

[20:03:10.0386] <kriskowal>
‚Ä¶molar, m√ºller, mollino, etc

[20:03:58.0905] <kriskowal>
> <@ljharb:matrix.org> https://abcnews.go.com/Lifestyle/man-spends-months-1500-make-sandwich-scratch/story?id=33802231

to bake a cake from scratch one must first create the universe

[20:39:16.0948] <Chris de Almeida>
looking for folks to help with the notes starting in 20 mins

[20:58:33.0391] <Chris de Almeida>
üëÄ

[20:59:10.0178] <Chengzhong Wu>
+1

[21:01:46.0246] <Chengzhong Wu>
do we need consensus for stage 0?

[21:01:55.0259] <Ashley Claymore>
could someone on the team's call copy the link to the slides? I'm assuming if I join I won't be able to see previous chat history

[21:02:40.0485] <Chris de Almeida>
https://docs.google.com/presentation/d/1yakKCsS3pR0T7eJcaJD2ZUzK6xG6FcoFnrmngkJUcEo/edit#slide=id.g2fa19dd416b_0_181

[21:04:00.0119] <Ashley Claymore>
ta

[21:04:51.0238] <Chris de Almeida>
We regret to inform that the `Observable` topic has been withdrawn due to availability issues.

[21:17:36.0297] <rkirsling>
"30m stage 0 update" is a pretty wild concept

[21:18:22.0905] <ljharb>
if we're getting an item more than once at committee then it's really not stage 0, it's stage 1

[21:18:29.0159] <ljharb>
because we're spending time exploring the problem

[21:19:06.0324] <Ross Kirsling>
that is also how I feel

[21:19:29.0638] <Chris de Almeida>
> delegates HATE it.. circumvent the process with this one neat trick!

[21:43:22.0472] <waldemar>
What if the module exports `then`?

[21:43:37.0020] <Ashley Claymore>
that's coming up

[21:44:54.0849] <hax (HE Shi-Jun)>
> <@waldemarh:matrix.org> What if the module exports `then`?

dynamic import will call `then` üò≠

[21:45:16.0968] <hax (HE Shi-Jun)>
I always think it's a mistake.

[21:45:25.0063] <waldemar>
Yeah. That seems a bit troublesome‚Ä¶

[21:47:01.0638] <hax (HE Shi-Jun)>
So I really hope we can fix it (not sure why Symbol.unthenable was rejected...)

[21:48:34.0001] <ljharb>
web compat, people were already relying on thenable modules in production

[21:49:03.0796] <Andreu Botella (at TC39, üïê JST)>
> <@ljharb:matrix.org> web compat, people were already relying on thenable modules in production

really? üò©

[21:49:41.0589] <hax (HE Shi-Jun)>
> <@ljharb:matrix.org> web compat, people were already relying on thenable modules in production

really weird... Is it just for fun?

[21:50:24.0499] <hax (HE Shi-Jun)>
Is it a real production or just toy project?

[21:50:48.0559] <ljharb>
i'm not sure we ever dug into it, we just heard claims that they were i think

[21:51:27.0764] <Andreu Botella (at TC39, üïê JST)>
would it be hard to feature detect that?

[21:51:46.0560] <Andreu Botella (at TC39, üïê JST)>
well, I meant, hard to know how much it's used

[21:52:19.0872] <hax (HE Shi-Jun)>
I really think relying on the such bad semantics (static import and dynamic import give u different things) in production is very very weird...

[21:54:48.0409] <canadahonk>
are there any known demands for import.defer?

[21:57:34.0069] <Justin Ridgewell>
@nicolo-ribaudo:matrix.org we can hear you typing

[22:00:20.0280] <Mathieu Hofman>
> <@haxjs:matrix.org> Is it a real production or just toy project?

Production. 

[22:01:06.0860] <Mathieu Hofman>
I'm not on the call now, what is the problem with lazy evaluating on export access?

[22:01:23.0326] <bakkot>
thenables

[22:03:06.0665] <Justin Ridgewell>
Specifically the promise resolution of the dynamic import triggers the evaluation

[22:04:24.0207] <Mathieu Hofman>
I understand that. But it just means that only thenable modules wouldn't be lazy evaluated. More precisely the promise logic doing get then would trigger evaluation

[22:04:44.0658] <Mathieu Hofman>
* I understand that. But it just means that only thenable modules wouldn't be lazy evaluated. More precisely the promise logic doing get then would trigger their evaluation

[22:05:08.0871] <Mathieu Hofman>
It wouldn't affect any other kind of modules

[22:05:33.0052] <bakkot>
any property access triggers evaluation

[22:05:37.0914] <bakkot>
and you have to access `.then`

[22:06:18.0065] <Mathieu Hofman>
Right so what's the problem to trigger evaluation of thenable modules

[22:06:33.0258] <Ashley Claymore>
it triggers all modules

[22:06:36.0603] <bakkot>
`Promise.resolve(foo)` accesses `foo.then`

[22:06:43.0888] <bakkot>
regardless of whether `foo` has a `.then`

[22:06:57.0756] <Mathieu Hofman>
I'm just saying if the module is non thenable, it wouldn't trigger evaluation. All good

[22:07:14.0578] <bakkot>
any property access triggers evaluation

[22:07:23.0334] <bakkot>
the property does not have to exist to trigger evaluation

[22:07:40.0099] <bakkot>
and sticking the module namespace object into a promise triggers access of `.then`

[22:07:52.0052] <bakkot>
and dynamic import sticks the module namespace object into a promise

[22:07:58.0968] <Mathieu Hofman>
But that's what I'm asking. Why can't we defer evaluation to access of a known export

[22:08:56.0794] <shu>
when would you trigger the evaluation

[22:09:02.0672] <Mathieu Hofman>
You don't need to evaluate to know what is exported 

[22:09:24.0444] <shu>
Promise.resolve accesses .then, it doesn't ask if it has a .then

[22:09:33.0876] <Mathieu Hofman>
When you do get then or any prop access for known exports 

[22:09:53.0260] <shu>
which Promise.resolve does, it gets .then

[22:10:00.0199] <shu>
what is happening

[22:10:58.0157] <ljharb>
i think what mathieu is suggesting is that we _change_ promise resolution so that _for a deferred namespace object_, it doesn't access `.then` unless that's an export of the module?

[22:11:20.0859] <Chris de Almeida>
I see stuff dropping off the queue, but we have time to continue discussion

[22:11:22.0568] <shu>
where do you put this, inside step 9 of https://tc39.es/ecma262/#sec-promise-resolve-functions?

[22:11:33.0773] <bakkot>
I assumed the idea was that you

[22:11:42.0688] <bakkot>
 * I assumed the idea was that you'd know the names before triggering evaluation

[22:11:48.0602] <bakkot>
I don't know if that's true

[22:12:03.0576] <ljharb>
> <@shuyuguo:matrix.org> where do you put this, inside step 9 of https://tc39.es/ecma262/#sec-promise-resolve-functions?

that seems like a reasonable place

[22:12:19.0057] <shu>
seems wacky

[22:12:44.0350] <ljharb>
anything that touches thenable modules is wacky

[22:12:48.0487] <ljharb>
 * anything that touches thenable modules is indeed wacky

[22:13:03.0512] <Ashley Claymore>
> <@bakkot:matrix.org> I don't know if that's true

the official spec knows. But userland bundlers may not know

[22:14:22.0713] <littledan>
> <@ljharb:matrix.org> web compat, people were already relying on thenable modules in production

Also expense/complexity of adding another property access to this hot path of promise resolution 

[22:16:24.0772] <littledan>
About the use cases for import.defer: we had an internal meeting in Bloomberg before TC39, and we couldn‚Äôt come up with a real use case. The case Ashley raised doesn‚Äôt occur in our infrastructure‚Äîit is very hypothetical. Personally I think removing the dynamic import.defer feature and not doing this namespace censorship is the right tradeoff for avoiding complexity

[22:17:06.0695] <yulia>
i feel like you can get what you want with dynamic import + static defer inside the dynamically imported graph

[22:17:22.0836] <yulia>
but let me check internally as well, we might have a use case. at the moment i can't think of anything

[22:17:43.0020] <ljharb>
i guess you could maybe get it with `import()` of a data URI that does a static deferred import and re-export?

[22:17:50.0970] <yulia>
yeah exactly

[22:18:14.0847] <Mathieu Hofman>
 Sorry afk, will formulate more clearly soon

[22:18:30.0730] <yulia>
because `import.defer` is fundamentally different from the static import defer: static import defer is always a module graph edge. In the case of import.defer we are deferring the module root

[22:21:35.0225] <sffc>
I want to see a future where WASM module instantiation is handled transparently in the ESM universe. WASM source imports are a step in the right direction, but I want to see instantiation handled via import defer at some point. And dynamic loading of WASM sources is definitely a use case.

[22:24:37.0320] <littledan>
> <@sffc:mozilla.org> I want to see a future where WASM module instantiation is handled transparently in the ESM universe. WASM source imports are a step in the right direction, but I want to see instantiation handled via import defer at some point. And dynamic loading of WASM sources is definitely a use case.

Import source + import() covers some of these cases though 

[22:24:52.0274] <littledan>
The problem is the function coloring‚Ä¶

[22:30:00.0509] <nicolo-ribaudo>
> <@bakkot:matrix.org> I assumed the idea was that you'd know the names before triggering evaluation

There are two possible implementations of this proposal:
- one (trivial) is that you follow the spec to the word, and eagerly pre-load and pre-parse the module and its dependencies. In this case, you always have access to the list of export names before evaluation.
- the other one is that you only collect some minimal metadata (does it have a dep with TLA? does it have syntax errors?) about modules before executing the app, and then skip loading/parsing entirely. You obviously cannot do this if you need to fetch files from the network, but that's often not the case (Node.js, the various edge runtimes, browser caches). This is the approach that gives the most benefits.

With the second approach you _can_ get the list of exports in this pre-execution phase, but it's more metadata you have to maintain.

Bundlers are very similar to to the second case, except that they currently need _no metadata_: the way to bundle deferred modules is to wrap them in a function, and thus:
- you already are protected against syntax errors
- there is no TLA, because that's handled by injecting the async module outside of the deferred function

[22:30:57.0875] <nicolo-ribaudo>
> <@littledan:matrix.org> Import source + import() covers some of these cases though

Well, also `const wasm = import.source(...)` + `WebAssembly.instantiate(wasm)` covers it in a sync way

[22:31:31.0060] <littledan>
> <@nicolo-ribaudo:matrix.org> Well, also `const wasm = import.source(...)` + `WebAssembly.instantiate(wasm)` covers it in a sync way

Kinda, but then you don‚Äôt get the native imports

[22:32:15.0453] <nicolo-ribaudo>
Oh true -- it only covers the many of the cases but not all of them

[22:35:16.0248] <Duncan MacGregor>
> <@michaelficarra:matrix.org> It was briefly mentioned.

Ah, found it in the automated transcript.

> Our next meeting coming up is a remote meeting on mountain time. So that's Albuquerque, our notional virtual venue. We are also working on the schedule for next year and hope to publish that very soon, as soon as we've got confirmations from the potential hosts.

[22:35:38.0227] <littledan>
> <@sffc:mozilla.org> I want to see a future where WASM module instantiation is handled transparently in the ESM universe. WASM source imports are a step in the right direction, but I want to see instantiation handled via import defer at some point. And dynamic loading of WASM sources is definitely a use case.

I agree with this goal about Wasm/ESM integration, and now understand the case better where this feature will be useful, but then I  wonder who will be sophisticated enough to do this import.defer() idiom in order to split up compilation vs instantiation cost (and what policy should even be used)

[22:42:08.0560] <Mathieu Hofman>
> <@bakkot:matrix.org> I assumed the idea was that you'd know the names before triggering evaluation

This exactly. My understanding is that all exported names of a module are known without evaluating the module. That means technically we could model this as an object with known props and the first access (get, gOPD) on one of these props would trigger the evaluation of the module. That way the import.defer of a non thenable module does not trigger the evaluation of the module. But if the module is thenable, then of course the regular promise logic will trigger evaluation when it does a get of then

[22:44:07.0263] <yulia>
> <@littledan:matrix.org> The problem is the function coloring‚Ä¶

can you elaborate? not familiar with the wasm usecase so well, so i don't know how import.defer solves this better than import source + import()

[22:44:25.0685] <ptomato>
are any slides intended to be shared right now?

[22:44:26.0740] <yulia>
because thats a good point, import.source and then import later is possibly another solution?

[22:45:28.0255] <shu>
i don't really see the priority on making evaluation-phase wasm ESM integration work well

[22:45:37.0821] <shu>
you gotta do something to pass in the imports

[22:45:49.0289] <shu>
it seems like it's just composed import.source then an instantiate

[22:46:04.0026] <shu>
the hard problems about actually making wasm modules participate in the module graph is solved by import.source

[22:46:47.0488] <Ashley Claymore>
> <@mhofman:matrix.org> This exactly. My understanding is that all exported names of a module are known without evaluating the module. That means technically we could model this as an object with known props and the first access (get, gOPD) on one of these props would trigger the evaluation of the module. That way the import.defer of a non thenable module does not trigger the evaluation of the module. But if the module is thenable, then of course the regular promise logic will trigger evaluation when it does a get of then

in a pure ESM  spec world yes. But ecosystem tooling has to deal with less concrete situations. Not relying on knowing the keys is a big help for tooling that emulates ESM

[22:48:06.0608] <Ashley Claymore>
dropping `import.defer` looks like it has more of a win

[22:48:18.0337] <Mathieu Hofman>
I thought that static analyzability of module exports was one of the main point of ESM? Are you saying you want to import.defer other module types where export names are not known ahead of time?

[22:49:35.0798] <Ashley Claymore>
Tools like Babel will transform ESM to CommonJS one module at a time, without that global info

[22:50:53.0727] <Ashley Claymore>
it's doable, but adds complexity to tooling. Dropping `import.defer` is a solution that reduces complexity instead of moving it.

[23:50:05.0349] <rbuckton>
`bigint` could never have been JSSugar due to operator overloading. Neither could decimal as a primitive.

[23:50:59.0253] <nicolo-ribaudo>
Unless we introduce escaped operators like "a \+ b" that desugars to a.add(b) :)

[23:51:52.0395] <Ashley Claymore>
not operator overloading, it's AO impacting. new primitives change the core AOs of the language

[23:52:02.0065] <Ashley Claymore>
 * beyond operator overloading, it's AO impacting. new primitives change the core AOs of the language

[23:52:35.0755] <shu>
absent type-driven stuff, you can be like ocaml and have +.

[23:54:10.0620] <Justin Ridgewell>
I was discussing with Yulia last night that you could `import + from ‚Äòjs:operators‚Äô`, and have that perform the `left + right` -> `left.add(right)` change

[23:54:51.0562] <yulia>
üëÄ what happened in shibuya should stay in shibuya (for now)

[23:54:58.0067] <yulia>
or in TDZ

[23:54:58.0787] <Justin Ridgewell>
Requires coordination from the ‚Äúcore‚Äù, but we could then add new number types pretty easily

[23:55:24.0592] <yulia>
until we have something more concrete at least. context: this needs a lot more thought before we consider it as a serious proposal

[23:55:52.0122] <Chengzhong Wu>
> <@jridgewell:matrix.org> I was discussing with Yulia last night that you could `import + from ‚Äòjs:operators‚Äô`, and have that perform the `left + right` -> `left.add(right)` change

how is this going to be different from https://github.com/tc39/proposal-operator-overloading

[23:55:55.0580] <yulia>
also i had. lot of drinks

[23:56:54.0725] <Justin Ridgewell>
> <@legendecas:matrix.org> how is this going to be different from https://github.com/tc39/proposal-operator-overloading

It wouldn‚Äôt be checked per operand types. Import `+`, and now all `+` are `left.add(right)`

[23:56:58.0073] <yulia>
but yea ast rewriting, ill talk about it when my thing comes up

[23:57:04.0741] <Justin Ridgewell>
* It wouldn‚Äôt be checked per operand types. Import `+`, and now all `+` in the file are `left.add(right)`

[23:58:09.0872] <nicolo-ribaudo>
> <@yulia:mozilla.org> but yea ast rewriting, ill talk about it when my thing comes up

A clear strategy to build hype

[23:58:43.0846] <yulia>
if you haven't read rewriting the technical interview you really should, but thats a digression

[23:58:54.0590] <Chris de Almeida>
what I am trying to say is I want to date JSSugar before marrying.  thank you Ashley for helping to clarify my intent there

[23:59:09.0927] <yulia>
Chris de Almeida: chris you've been dating for years

[23:59:15.0461] <yulia>
 * Chris de Almeida: you've been dating for years

[23:59:36.0514] <jkup>
> <@yulia:mozilla.org> if you haven't read rewriting the technical interview you really should, but thats a digression

all time favorite

[23:59:38.0944] <Chris de Almeida>
but surely there is _some_ delta from our current process that we could PoC

[00:00:51.0241] <Chris de Almeida>
for example maybe a proposal that would involve a split, or _could_ involve a split

[00:01:18.0865] <Chris de Almeida>
but if the response is that it's already so close to what we do, per what Shu was saying, then that's fine

[00:01:38.0559] <yulia>
concretely I could see the following: new syntax gets the following restrictions

1) it has to be expressible as a rewritten ast
2) it cannot present a simplified interface to what is a costly set of operations (with some rubrick determining where the line is)

[00:01:53.0526] <yulia>
 * concretely I could see the following: new syntax gets the following restrictions

1. it has to be expressible as a rewritten ast
2. it cannot present a simplified interface to what is a costly set of operations (with some rubrick determining where the line is, ie the expansion can not be greater than x)

[00:02:12.0767] <yulia>
 * concretely I could see the following: new syntax gets the following restrictions

1. it has to be expressible as a rewritten ast
2. it cannot present a simplified interface to what is a costly set of operations (with some rubrick determining where the line is, ie the expansion can not be greater than x)

And, with this, we say that new syntax has a wait time of at least 3 years before landing in browsers

[00:02:41.0417] <yulia>
 * concretely I could see the following: new syntax for JSSugar gets the following restrictions

1. it has to be expressible as a rewritten ast
2. it cannot present a simplified interface to what is a costly set of operations (with some rubrick determining where the line is, ie the expansion can not be greater than x)

And, with this, we say that new syntax has a wait time of at least 3 years before landing in browsers

[00:08:51.0415] <ljharb>
couldn't we say that right now, for syntax stage 2.7 features that they need 3 years (as usable transpilations) before being eligible for stage 3?

[00:09:06.0250] <ljharb>
 * couldn't we say that right now, for syntax stage 2.7 features that they need 3 years (as usable transpilations) before being eligible for stage 3? (ie, without any sugar/core/js0 stuff)

[00:09:32.0791] <shu>
no, because then people might not ever adopt it at scale and we never get a meaningful signal

[00:09:41.0979] <shu>
it's not baking time with committee that's needed

[00:09:44.0688] <shu>
it's baking time with the world

[00:09:46.0474] <yulia>
yeah it should be considered finished

