2021-09-01
[06:37:48.0472] <Ashley Claymore>
change-array-by-copy methods dropped from 10 to 4
https://github.com/tc39/proposal-change-array-by-copy/issues/27

[06:47:37.0167] <bakkot>
do we want to take notes for the "Response to ECMA / LF Proposed Partnership | Michael Saboff" item?

[06:47:54.0207] <bakkot>
I'm never sure for the administrative rather than technical items

[06:50:14.0762] <Rob Palmer>
yes, take notes, but we won't make them publish them publicly

[06:52:44.0375] <Rob Palmer>
the jitsi is open - same passcode as yesterday

[07:44:12.0054] <littledan>
I also strongly support the "safety value" of permissive copyright agreements/forkability

[07:49:47.0242] <shu>
just FYI here's the list of ecma members: https://www.ecma-international.org/about-ecma/members/

[08:08:51.0456] <Michael Ficarra>
ceil, floor, round, trunc, really?

[08:09:11.0847] <bakkot>
I'd actually say that stage 1 shouldn't be about extending Math specifically, just about adding more math operations for bigints

[08:09:31.0082] <ljharb>
"bigint math" indeed doesn't necessarily mean it has to be on `Math`

[08:09:44.0513] <rbuckton>
It could just be on `BigInt`

[08:09:56.0939] <ljharb>
the challenge there is, "why are these things on Number too?"

[08:10:01.0219] <ljharb>
 * the challenge there is, "why aren't these things on Number too?"

[08:10:15.0017] <ljharb>
iow, perhaps most of the Math methods belonged on Number, but here we are

[08:10:21.0410] <ryzokuken>
maybe we could later add aliases on `Number` ðŸ˜€ 

[08:10:52.0748] <rbuckton>
Also possible to introduce a separate global, i.e., `MathN` or `BigMath`, but I'd hate to have to do this over and over if we add more number types in the future.

[08:11:24.0229] <nicolo-ribaudo>
It could be namespaced, `Math.BigInt.*`

[08:11:37.0382] <ryzokuken>
what about `mixedArrayWithNumbersAndBigInts.map(Math.abs)`?

[08:11:49.0483] <ljharb>
 * would have to be `Math.bigint.*` then, thanks to `Temporal.Now`

[08:12:03.0900] <ryzokuken>
wait, isn't it a namespace too?

[08:12:10.0637] <ljharb>
lol nvm, i'm tired and confused myself

[08:12:10.0674] <ryzokuken>
so same capitalization

[08:14:41.0954] <ljharb>
re max/min, `1n < 3` works, so `Math.max(1n, 3)` should work.

[08:15:11.0194] <ljharb>
 * re max/min, `1n < 3` works, so `Math.max(1n, 3)` should work. i see zero concern with "mixing" in max/min

[08:15:24.0493] <ljharb>
 * re max/min, `1n < 3` works, so `Math.max(1n, 3)` should work. i see zero concern with "mixing" in max/min, because there's no accidental precision loss, which was the only motivation for mixing errors i recall

[08:16:02.0655] <ljharb>
 * re max/min, `1n < 3` works, so `Math.max(1n, 3)` should work. i see zero concern with "mixing" in max/min, because there's no accidental precision loss, which was the only motivation for mixing errors that i recall

[08:16:45.0828] <Michael Ficarra>
I fully support "maths operations for BigInts", not so sure about the choice of functions listed here

[08:17:03.0605] <bakkot>
yeah, +1 for excluding transcedentals

[08:18:22.0742] <Jack Works>
support for some kind of NS instead of `bigMax` and `bigMin`

[08:18:29.0027] <bakkot>
though also, +1 for hashing out the exact list in stage 1

[08:19:30.0105] <shu>
i don't know if it's bizarre that arbitrary precision math doesn't "just work"...

[08:19:55.0247] <ljharb>
max/min isn't "arbitrary precision", it's a form of `>` and `<`

[08:20:18.0626] <ljharb>
if i can do `999999999999999999999999999999999999999999999999999999999999999n > 1`, why can't i put those in max or min?

[08:20:40.0241] <danielrosenwasser>
> because there's no accidental precision loss

`10000000000000000000000n < 10000000000000000000000.1`

`> false`

ðŸ¤¨

[08:21:00.0873] <shu>
ljharb: yes, my comment is about unqualified "math"

[08:21:01.0063] <ljharb>
in that case the loss happens on the number creation, not part of the `<`

[08:21:01.0465] <nicolo-ribaudo>
You don't know the return type of `Math.min(x, y)` when `x` is a number and `y` is a bigint

[08:21:37.0181] <danielrosenwasser>
I don't really think it's a problem in practice, but it's not like most people know the behavior off-hand

[08:21:38.0934] <ljharb>
nicolo-ribaudo: the return type is T, the type of your inputs - number if all numbers or non-numbers, bigint if all bigints, number or bigint if both

[08:21:44.0118] <bakkot>
RangeError, surely?

[08:21:45.0488] <danielrosenwasser>
 * I don't really think it's a problem in practice, but it's not like most people know the behavior off-hand

[08:21:52.0464] <bakkot>
I guess TypeError makes sense from one perspective

[08:22:00.0250] <ljharb>
why would it be an error of any kind if `<` with them isn't

[08:22:05.0554] <ljharb>
 * why would it be an error of any kind if `<` with them isn't

[08:22:17.0505] <ljharb>
bigint/number mixing errors are about losing precision _by the mixing_. this is not a problem for max/min, just like it's not one for comparison.

[08:22:34.0789] <ljharb>
 * bigint/number mixing errors are about losing precision _by the mixing_. this is not a problem for max/min, just like it's not one for comparison.

[08:22:35.0780] <Michael Ficarra>
ljharb: you can't `<` with 0 operands

[08:23:13.0572] <ljharb>
sure?

[08:23:35.0998] <Michael Ficarra>
so min/max with 0 arguments should do what?

[08:23:42.0396] <ljharb>
`Math.max()` is `-Infinity`, `Math.max(x)` is `x`, and 2+ operands is where it's useful, and also where it matters

[08:24:12.0732] <ljharb>
i don't see any issue with `Math.max(...x)` possibly returning either type. if you cared about that, you'd already be ensuring `x` has 2+ items.

[08:24:43.0324] <ljharb>
 * i don't see any issue with `Math.max(...x)` possibly returning either type. if you cared about that, you'd already be ensuring `x` has 1+ items.

[08:24:46.0801] <ljharb>
since bigint lacks an ultimate max/min value (infinity) it's nonsensical to put in < 1 items and expect a bigint back, no?

[08:25:06.0047] <Michael Ficarra>
yes, so RangeError

[08:25:17.0627] <ljharb>
if it were a bigint-only method, sure

[08:25:26.0119] <ljharb>
but in this scenario it's a bigint and/or number method.

[08:25:32.0115] <ljharb>
and it already doesn't throw an error, so it can't start now

[08:26:08.0589] <ljharb>
and making a new method, that still mixes (because not allowing mixing here is ridiculous), only to throw an error on 0 items (or maybe to satisfy some type system-like mental model?), doesn't seem sufficiently motivated to me

[08:26:23.0556] <ljharb>
 * and making a new method, that still mixes (because not allowing mixing here is ridiculous), only to throw an error on 0 items (or maybe to satisfy some type system-like mental model?), doesn't seem sufficiently motivated to me

[08:26:31.0710] <Michael Ficarra>
I'm leaning toward new methods on BigInt here

[08:26:41.0393] <bakkot>
sqrt is easy I think, but it's the only obvious sometimes-irrational one which works

[08:26:45.0798] <bakkot>
and cbrt, of course

[08:27:00.0643] <ljharb>
for max and min specifically, i would be staunchly opposed to a bigint-only one. these methods only should allow mixing. and `BigInt.max` allowing both seems odd.

[08:27:11.0655] <ljharb>
 * for max and min specifically, i would be staunchly opposed to a bigint-only one. these methods only should allow mixing. and `BigInt.max` allowing both seems odd.

[08:27:48.0362] <sarahghp>
you can already sort a mixed array, right? 

[08:28:06.0760] <bakkot>
ljharb: the only reason to allow mixing is if you have a list which has both bigint and numbers, which you should not have and it is not clear to me that the language ought to have explicit support for

[08:28:11.0017] <sarahghp>
so then Max and Min is logical

[08:28:22.0434] <ljharb>
i don't understand "should not have"

[08:28:36.0276] <ryzokuken>
me neither, why should you not have mixed arrays?

[08:28:37.0323] <Michael Ficarra>
sarahghp: are you referring to the default sort comparator? you can sort anything

[08:28:55.0605] <Jack Works>
Oh but I have some question about BigInt or Decimals in general

[08:29:01.0897] <ljharb>
 * also the language already has explicit support for it - `mixedArray.reduce((a, b) => a + b)` works fine, eg.

[08:29:41.0020] <Jack Works>
what if I do `1m/3m`? Can I get a infinite precise decimal number to represent `1/3` in Math?

[08:30:04.0119] <ryzokuken>
Jack Works: that's an open question for the bigdecimal proposal

[08:30:15.0436] <ryzokuken>
but for decimal128 that's not as big as issue

[08:30:23.0344] <ryzokuken>
or for fractions

[08:30:31.0998] <sarahghp>
> <@michaelficarra:matrix.org> sarahghp: are you referring to the default sort comparator? you can sort anything

I mean the default sort on array works, and so, as a practitioner, I would expect max and min to work as well. 

[08:30:51.0527] <bakkot>
the default sort on array uses strings

[08:30:52.0796] <HE Shi-Jun>
sounds like we need Fractions? syntax like `1/3r` 

[08:31:03.0564] <bakkot>
that is, sorts by string order

[08:31:11.0600] <ryzokuken>
yeah, either fractions or decimal128 would avoid the 1/3 issue

[08:31:12.0291] <sarahghp>
yes I know why it works, but I am saying from DX not an internal reason why it would be expected to work

[08:31:25.0113] <ryzokuken>
but then there's other issues that bigdecimals solve... it's a complicated tradeoff

[08:31:25.0138] <sarahghp>
 * yes I know why it works, but I am saying from DX not an internal reason why it would be expected to work

[08:32:05.0101] <bakkot>
I do strongly think that a `bigSqrt` should truncate to a bigint rather than returning a number or decimal or anything

[08:33:08.0843] <ryzokuken>
+1 for stage 1.

[08:33:44.0801] <HE Shi-Jun>
not sure we really need `bigMin/bigMax`, it seems `Infinity` is ok for empty... because the worst case is just throw TypeError so no need to have `bigMin/bigMax` if it also throw TypeError ðŸ˜‚

[08:33:47.0794] <Tierney Cyren>
always love to see improved math

[08:34:09.0413] <Jack Works>
and for example, in 6.1.6.2.3 BigInt::exponentiate, it doesn't say what will happen if the result is too big to represent. Should the engine give a rounded/approximated result or should the engine throw a TypeError?

[08:34:56.0012] <HE Shi-Jun>
> <@jackworks:matrix.org> and for example, in 6.1.6.2.3 BigInt::exponentiate, it doesn't say what will happen if the result is too big to represent. Should the engine give a rounded/approximated result or should the engine throw a TypeError?

I suppose it should throw TypeError or OOM ??

