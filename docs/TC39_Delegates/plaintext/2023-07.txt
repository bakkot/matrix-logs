2023-07-05
[02:04:16.0414] <Rob Palmer>
[The September Tokyo plenary invite](https://github.com/tc39/Reflector/issues/499) is now posted on the Reflector.

If anyone needs support on visas (e.g. generating an invite letter from the host), please let me know.  It is just under 12 weeks away.

[04:56:12.0750] <littledan>
Note that we are working on a community event the evening before, on the 25th.

[07:20:55.0627] <peetk>
oops i didn't see this before, thanks for this! i actually didn't mean to include that slide, ha!

[12:13:57.0838] <Chris de Almeida>
https://github.com/tc39/agendas/pull/1423

‚òùÔ∏è this is a low-stakes change, but would be nice to get some more blessings on it


2023-07-06
[01:59:18.0773] <Jack Works>
https://docs.google.com/presentation/d/1m5R5J98W6adegghgkAlbSuFgAYJDT52yyFVdAqLjm00/edit#slide=id.geaea8d83af_0_4

[01:59:27.0695] <Jack Works>
https://github.com/tc39/proposal-iterator.range/issues/60
https://tc39.es/proposal-iterator.range/#sec-create-numeric-range-iterator

[01:59:35.0049] <Jack Works>
also in Iterator.range

[10:01:29.0622] <TabAtkins>
https://github.com/tc39/proposal-integer-and-modulus-math appears to have Issues turned off so I can't comment on it. littledan ?

[10:20:05.0849] <ljharb>
they're on afaict

[10:20:12.0632] <ljharb>
 * they're on afaict - https://github.com/tc39/proposal-integer-and-modulus-math/issues

[10:20:26.0139] <ljharb>
 * TabAtkins: they're on afaict - https://github.com/tc39/proposal-integer-and-modulus-math/issues

[10:21:04.0036] <TabAtkins>
Wth, nothing was there on my desktop


2023-07-09
[05:06:20.0083] <nicolo-ribaudo>
Do we already have a matrix room for the in-person participants to the meeting?

[05:09:04.0578] <Jack Works>
I don't think so

[05:15:50.0048] <Rob Palmer>
Please create one, Nicolo! 

[10:43:59.0133] <Michael Ficarra>
nicolo-ribaudo: can you link the room here or send me an invite?

[10:55:31.0958] <nicolo-ribaudo>
You already joined it some hours ago üòÖ

[11:09:18.0673] <Michael Ficarra>
I am so confused

[11:09:52.0993] <Michael Ficarra>
I have been in transit for far too long

[11:11:37.0939] <Michael Ficarra>
I literally thought I imagined that lmao


2023-07-10
[00:47:17.0133] <rkirsling>
wait 10am in Oslo is 5pm in Tokyo?

[00:47:19.0423] <rkirsling>
wild

[03:50:50.0254] <dminor>
Sorry if this is a basic element/matrix question, but how do I join the TC39 space, like the thing that organizes all of the TC39 rooms into one view?

[03:51:45.0811] <nicolo-ribaudo>
https://matrix.to/#/#tc39-space:matrix.org try this

[03:51:55.0289] <nicolo-ribaudo>
https://matrix.to/#/#tc39-space:matrix.org

[04:30:05.0188] <dminor>
Well, it looks like that should work, but my element client just spins on `loading` for 30 minutes :/ I'll try again later.

[05:51:59.0214] <Rob Palmer>
Is anyone available to dial into zoom to help confirm AV in 20 mins time? 

[06:00:12.0717] <Ashley Claymore>
I'll try the zoom from the hotel Wi-fi

[06:08:35.0032] <Rob Palmer>
Thanks, Ashley

[06:10:14.0035] <Ashley Claymore>
ping me a link when you're ready

[06:54:05.0941] <dminor>
Works now, thanks for the help :)

[15:42:13.0216] <rbuckton>
Chairs: Any concern if I extend the timebox for the Explicit Resource Management update by 15 minutes to cover a suggestion that came up last week? The schedule currently calls for a 15 minute underflow on the day/time I'm currently scheduled to present. If that's not feasible, I'll see what I can squeeze in in the time I have available and offer to discuss further with interested parties after the plenary.


2023-07-11
[18:25:52.0330] <Chris de Almeida>
rbuckton: you got it 

[00:31:33.0476] <Rob Palmer>
The sign-in form is now posted if you wish to dial into the Zoom for today's plenary:  https://github.com/tc39/Reflector/issues/473

[00:49:58.0332] <Rob Palmer>
Please could someone attempt dial in so we can confirm AV is working

[01:01:52.0052] <Jack Works>
it's working

[01:02:02.0596] <Jack Works>
 * it's working (zoom web)

[01:18:25.0714] <bakkot>
huh, "OramaSearch" is new to me; any delegates from them here today?

[01:18:36.0784] <littledan>
Michele Riva is the delegate, I think?

[01:18:45.0192] <ryzokuken (‚úàÔ∏è to üá≥üá¥)>
yeah

[01:18:52.0250] <ryzokuken (‚úàÔ∏è to üá≥üá¥)>
it's a new org

[01:20:03.0996] <Jack Works>
i found the voice quality is bad... i need more effort to heard what are the meetings talking about

[01:28:58.0433] <Rob Palmer>
Jack Works: is it one person's voice quality?

[01:31:46.0692] <Jack Works>
> <@robpalme:matrix.org> Jack Works: is it one person's voice quality?

it's the in-person one

[01:32:59.0612] <Rob Palmer>
The whole room is "hot".  Meaning all mics on the whole time.  So we need everyone to avoid noise unless they are speaking, e.g. placing cups down gently.

[01:34:37.0740] <Christian Ulbrich>
Rob Palmer: Although it would be possible to mute each mic directly, because they have a direct mute button.

[01:35:40.0179] <Rob Palmer>
That is a good point - lets try using that

[01:41:53.0253] <littledan>
Yeah, this does look nicer! Thanks editors

[01:44:57.0772] <bakkot>
tcq does indeed appear to be down

[01:45:04.0842] <bakkot>
chaos :(

[01:46:45.0808] <Michael Ficarra>
I don't even know what to do without TCQ anymore

[01:47:12.0593] <Michael Ficarra>
we are now 100% dependent

[01:47:13.0374] <nicolo-ribaudo>
A google doc with someone manually sorting the items by priority?

[01:47:54.0823] <Bradford Smith>
current discussion is not audible remotely

[01:48:30.0154] <Christian Ulbrich>
Sorry! We forgot to unmute; it was about missing conclusions.

[01:49:42.0120] <Christian Ulbrich>
Just give us a nod and we will signal, unmute.

[01:52:40.0196] <bakkot>
is TCQ still just running off of some Azure account Brian is expensing?

[01:54:16.0507] <Christian Ulbrich>
bakkot: Looks so -> https://github.com/bterlson/tcq/blob/b5be1287a6843f24dc570c1d951d1c26ac566d66/src/server/db.ts#L1C14-L1C18

[01:55:49.0783] <Michael Ficarra>
why is #783 being done as a needs-consensus PR and not a staged proposal?

[02:00:32.0459] <bakkot>
I don't think it's that useful to make things like this optional?

[02:00:41.0029] <bakkot>
at least not optional for web browsers

[02:00:50.0660] <bakkot>
as a programmer I am going to want to rely on their existence

[02:00:55.0438] <littledan>
+1

[02:01:11.0604] <bakkot>
and as a user I'm going to be annoyed if the page behaves differently in my browser than the one the developer was using

[02:01:57.0939] <ryzokuken üá≥üá¥>
but when it comes to internationalization, that's bound to happen, right?

[02:02:05.0159] <ryzokuken üá≥üá¥>
I mean, I totally agree with the general sentiment

[02:02:54.0023] <bakkot>
... is it?

[02:03:01.0769] <Michael Ficarra>
bakkot: ligatures and opentype features are optional; that doesn't make a font not useful

[02:03:25.0043] <littledan>
> <@usharma:igalia.com> but when it comes to internationalization, that's bound to happen, right?

well, we still try to limit the scope of this

[02:03:36.0561] <littledan>
> <@bakkot:matrix.org> ... is it?

it is because different browsers make different tailorings of the data

[02:05:32.0991] <littledan>
sffc: Can you link to that PR for number format for the notes?

[02:05:45.0188] <littledan>
oops it's in TCQ

[02:05:46.0250] <littledan>
https://github.com/tc39/proposal-intl-numberformat-v3/pull/130

[02:09:01.0571] <Rob Palmer>
> <@michaelficarra:matrix.org> I don't even know what to do without TCQ anymore

There is a defined backup plan involving a spreadsheet.

[02:09:27.0488] <Michael Ficarra>
good to hear!

[02:10:25.0322] <bakkot>
someone is typing surprisingly loudly?

[02:10:29.0927] <HE Shi-Jun>
does import attr support boolean values?

[02:10:55.0269] <Rob Palmer>
I think it may be ryzokuken üá≥üá¥ aggressively typing.

[02:11:16.0168] <Jack Works>
> <@haxjs:matrix.org> does import attr support boolean values?

no

[02:11:25.0796] <Michael Ficarra>
I think it is littledan just surprisingly close to the mic

[02:11:52.0528] <rbuckton>
Is someone typing on an open mic?

[02:12:20.0835] <littledan>
sorry that may be me. Is it fixed now?

[02:12:25.0935] <littledan>
(I moved off of the table)

[02:12:38.0389] <bakkot>
there are not currently typing noises

[02:13:34.0084] <HE Shi-Jun>
> <@jackworks:matrix.org> no

If support boolean I would like it also support `null` :)

[02:14:16.0015] <Michael Ficarra>
HE Shi-Jun: Jack Works: I would oppose that because I want to keep a future open where we do not ToString these value

[02:15:17.0439] <bakkot>
yeah I like keeping the restrictions tight until there are concrete things we want to loosen them for

[02:15:52.0249] <bakkot>
definitely I can imagine features where we'd want `true`, `false`, `null` etc but I think we can come back when that's relevant?

[02:15:55.0320] <HE Shi-Jun>
we do ToString for attribute values now?

[02:16:05.0743] <bakkot>
otoh I guess this is partially for bundlers to build out there own things so maybe that doesn't make sense

[02:34:23.0743] <Michael Ficarra>
I support auto deferral in this case, but I don't want this or iterators to be considered precedent to justify auto deferring in future proposals

[02:43:02.0107] <Bradford Smith>
could someone remind me what "hint" means in this context?

[02:43:15.0233] <Michael Ficarra>
it's an alias in the spec

[02:43:15.0834] <littledan>
it means "flag" in practice

[02:43:19.0440] <littledan>
it's a silly name

[02:43:35.0402] <Michael Ficarra>
it's used in places where we provide an AO with context about its use

[02:44:18.0802] <Bradford Smith>
so it's not something specific to the syntax for Explicit Resource Management, then. Thanks

[02:44:33.0013] <ryzokuken üá≥üá¥>
yeah, I always assumed that it was a contextual hints from the caller, as in toPrimitive

[02:44:34.0259] <Michael Ficarra>
correct, entirely spec internal

[02:44:45.0428] <ryzokuken üá≥üá¥>
 * yeah, I always assumed that it was a contextual hint from the caller, as in toPrimitive

[02:44:46.0996] <nicolo-ribaudo>
> <@bradfordcsmith:matrix.org> so it's not something specific to the syntax for Explicit Resource Management, then. Thanks

Well, in this specific case the hint is whether we are using `using` or `await using`

[02:45:18.0103] <ryzokuken üá≥üá¥>
hmm, I would've said the word "context" is better but at this point it's so overloaded that it's probably not

[02:45:50.0132] <Michael Ficarra>
same with "flag"

[02:48:39.0885] <nicolo-ribaudo>
ptomato (at TC39, limited availability): It is not possible unless we want all the `const` and `let` declaration to perform property access

[02:52:05.0891] <bakkot>
or if we change the semantics of `using`, like suggested here

[02:52:16.0159] <nicolo-ribaudo>
> <@nicolo-ribaudo:matrix.org> ptomato (at TC39, limited availability): It is not possible unless we want all the `const` and `let` declaration to perform property access

Oh well, the resource could throw if it's used before accessing its `[Symbol.dispose]` property

[02:52:49.0591] <bakkot>
that's kinda cute actually

[02:53:04.0025] <Luca Casonato>
And also, it is totally reasonable to move around disposables using `let` or `const`, before passing it to a `using`

[02:53:08.0261] <bakkot>
but probably confusing

[02:53:25.0187] <littledan>
if we want to seriously consider Symbol.enter, we should demote this proposal to Stage 2

[02:55:58.0663] <ryzokuken üá≥üá¥>
> <@lucacasonato:matrix.org> And also, it is totally reasonable to move around disposables using `let` or `const`, before passing it to a `using`

I don't quite understand how you envision this

[02:56:18.0885] <Michael Ficarra>
littledan: I think it works fine as a follow-on

[02:58:48.0537] <littledan>
this is not the kind of thing that will be good to have a compatibility matrix around. It's also not some complicated uncertain technology--we know the design space already.

[03:00:11.0620] <Bradford Smith>
littledan: Are you concerned about avoiding a future where some disposables are wrapper objects that pseudo-enforce use of `using` and some are not?

[03:00:45.0616] <littledan>
it will be annoying to have to reason about different possible ways that this protocol could be implemented, in general. Possible, but annoying

[03:01:33.0965] <littledan>
Queue:
Reply: Concern with disposers that throw exception in GC for embeddings
Philip Chimento
2
New Topic: I am not in favour of recommending GC based cleanup. Should -> may?
Luca Casonato (@denoland)
3
New Topic: Is it possible to enforce use of `using` in the language, rather than in tooling
Philip Chimento
4
New Topic: Test sanitizers can be used to help with this
Luca Casonato (@denoland)
5
New Topic: I support looking into the @@enter/@@asyncEnter, possibly part of this proposal.
Michael Saboff

[03:02:16.0960] <ryzokuken üá≥üá¥>
thanks, could we perhaps also put this in the notes so we have a copy stored?

[03:03:53.0942] <sffc>
is tcq.app down for anyone else? The console says
```
WebSocket connection to '<URL>' failed: WebSocket is closed before the connection is established.
wKFO:1 Unchecked runtime.lastError: The message port closed before a response was received.
```

[03:04:03.0581] <ryzokuken üá≥üá¥>
yeah, it's down again

[03:09:53.0928] <rbuckton>
To clarify, I am fine with not providing a recommendation to ensure cleanup if a disposable is dropped on the floor, regardless as to the practice in other languages. It was brought up in #159 as one of the concerns about dropping a disposable is that native handles that are usually just tracked by a `number` value can leak and are not visible in a heap dump.

[03:11:23.0275] <rbuckton>
That said, it is feasible to implement a "cleanup on GC" behavior using `FinalizationRegistry` in user code if needed, given that's one of `FinalizationRegistry`'s use cases, and such behavior already exists in NodeJS for many native handles.

[03:24:49.0138] <rbuckton>
Regarding the `Symbol.enter` suggestion, I have been considering the following as a follow-on proposal:

`Symbol.enter` (or `Symbol.enterContext`?) - indicates a method that, when invoked, enters a context and returns a value associated with that context. This method is optional, and if missing is implicitly handled as if the definition was:

```
[Symbol.enter]() {
  return this;
}
```

`Symbol.exit` (or `Symbol.exitContext`?) - indicates a method that is invoked when the context is exited at the end of the block. Receives two arguments, `hasError` and `error`, that indicate whether an exception occurred prior to context exit. The method may return `true` to inform the caller not to throw `error` (swallowing the exception). Any other return value is ignored, indicating the caller should throw `error`. The method may also choose to throw its own error, but should not throw `error` itself. This method is also optional, and if missing is implicitly handled as if the definition was:

```
[Symbol.exit](hasError, error) {
  try {
    this[Symbol.dispose]();
  } catch (e) {
    if (hasError) {
      throw new SuppressedError(e, error);
    } else {
      throw e;
    }
  }
  return undefined;
}
```

Thus, `[Symbol.dispose]()` on its own would constitute a lightweight context manager.

[03:28:48.0847] <rbuckton>
Things do become more complex for async context managers, however, given that they must `await` the result of `[Symbol.asyncEnter]()` if we were to adhere to the Python design. `await using x = y` would potentially Await twice: once at the declaration site in the presence of a `[Symbol.asyncEnter]()` method, and once at the end of the block for the `[Symbol.asyncExit]()` or `[Symbol.asyncDispose]()` call. 

[03:31:45.0193] <rbuckton>
Finally, `AsyncDisposableStack.prototype.use` becomes *slightly* more complicated as it may return a `Promise` if the resource that is passed to `use` is an async context manager. `use` itself doesn't necessarily need to become async, however, since all it needs to do is return the result of calling `[Symbol.asyncEnter]()`. If you were to pass in a sync context or a disposable, it would not need to return a `Promise`.

[03:32:56.0584] <rbuckton>
Context managers are extremely powerful, but also extremely complex, which is why I have been reticent to consider them for this proposal. 

[03:36:08.0463] <rbuckton>
I also didn't want the general purpose `[Symbol.dispose]` behavior to be complicated by the error handling and error suppression semantics of `__exit__`, as the majority of cases related to resource management have no need of that complexity.

[04:08:10.0949] <Luca Casonato>
you may come back ljharb Chris de Almeida 

[04:08:13.0713] <Rob Palmer>
Please return to the Zoom

[04:10:08.0221] <Luca Casonato>
> <@usharma:igalia.com> I don't quite understand how you envision this

```js
const resource = createResource()

promises.push(doSomethingWithResource(resource));

async function doSomethingWithResource(resource) {
  using r = resource;

  ...
}
``

[04:10:15.0808] <Luca Casonato>
> <@usharma:igalia.com> I don't quite understand how you envision this

 * ```js
const resource = createResource()

promises.push(doSomethingWithResource(resource));

async function doSomethingWithResource(resource) {
  using r = resource;

  ...
}
```

[04:19:44.0993] <eemeli>
littledan: My preferred source-maps scope change would be to expand the two "including ECMAScript code" mentions to be something like "including CSS and ECMAScript code".

[04:21:49.0741] <Christian Ulbrich>
-> https://notlaura.com/is-css-turing-complete/

[04:28:06.0197] <littledan>
Thank you for ensuring that the CoC Committee member list is accurate

[04:28:08.0901] <littledan>
with the pruning

[04:28:12.0080] <littledan>
and thanks to new volunteers

[04:34:55.0982] <Bradford Smith>
The delegate's organization is not listed in https://github.com/tc39/notes/blob/main/delegates.txt. Is that information available somewhere?

[04:35:37.0309] <nicolo-ribaudo>
We are divided in teams in the tc39 GH org based on our org

[04:35:41.0292] <nicolo-ribaudo>
 * We are divided in teams in the tc39 GH org based on our organization

[04:35:43.0747] <nicolo-ribaudo>
 * We are divided in teams in the tc39 GH org based on our organizations

[04:36:25.0754] <nicolo-ribaudo>
Example: https://github.com/orgs/tc39/teams/member-igalia

[04:36:49.0356] <Bradford Smith>
Thanks for that reminder. I still don't really know how to "look up" the information that way. I mean go from name/abbreviation -> organization

[04:37:01.0761] <littledan>
so, the public calendar email address to invite will be shared with the committee to make events public?

[04:37:37.0280] <Michael Ficarra>
Bradford Smith: type their name here: https://github.com/orgs/tc39/teams/eligible-meeting-participants?query=membership%3Achild-team

[04:44:09.0800] <Chris de Almeida>
yes

[04:45:02.0712] <Michael Ficarra>
I'm confused, don't only the chairs have edit access?

[04:45:22.0193] <Chris de Almeida>
the public calendar is managed by way of the private calendar

[04:45:43.0664] <Michael Ficarra>
yes, I mean edit access to the private calendar

[04:45:52.0817] <littledan>
no, we can all edit the private calendar

[04:46:01.0136] <Chris de Almeida>
not everyone can edit it

[04:46:07.0997] <Chris de Almeida>
several people have permission though

[04:46:18.0736] <Chris de Almeida>
https://github.com/tc39/how-we-work/issues/94#issuecomment-1518375862

[04:46:38.0625] <Chris de Almeida>
calendar id there is the address to invite the public calendar to a private calendar meeting

[04:47:01.0032] <Chris de Almeida>
as discussed, we will place this information in a more accessible place rather than buried in a GH issue

[04:48:22.0110] <Chris de Almeida>
we should document some points of contact who have edit access so it's not ambiguous who to contact when needing to make calendar updates

[04:48:55.0502] <Chris de Almeida>
at the very least the chairs, but other folks with edit access may be willing to make themselves available for this purpose

[04:49:06.0971] <ljharb>
i've been fielding calendar update requests for awhile

[04:49:31.0461] <ryzokuken üá≥üá¥>
I think the admin role is perfect for this tbh

[04:49:33.0674] <ljharb>
 * i've been fielding calendar update requests for awhile fwiw

[04:49:52.0354] <ryzokuken üá≥üá¥>
so it makes sense for you to be among the listed contacts ljharb 

[04:49:54.0835] <littledan>
maybe we should give edit access somewhat more broadly?

[04:50:16.0756] <littledan>
I don't really see why I should have more access than others

[04:50:32.0879] <ryzokuken üá≥üá¥>
I think we have a high enough degree of trust within the committee to share edit access to the calendar more broadly, yes

[04:50:48.0997] <ryzokuken üá≥üá¥>
like the calendar edit permission is not really that critical now that I think about it

[04:50:50.0081] <ljharb>
that said, calendar management can be tricky and it's really easy to accidentally fire off dozens of email notifications

[04:51:01.0635] <Chris de Almeida>
true

[04:51:02.0722] <ljharb>
 * that said, calendar management can be tricky and it's really easy to accidentally fire off dozens of email notifications, and there's no audit log to restore deleted events

[04:51:36.0474] <littledan>
> <@ljharb:matrix.org> that said, calendar management can be tricky and it's really easy to accidentally fire off dozens of email notifications, and there's no audit log to restore deleted events

In fact it looks like the source map meetings might've been randomly deleted or something

[04:52:07.0727] <ljharb>
oof, ping me with the deets you want and i'll be happy to set it back up

[04:52:32.0144] <ryzokuken üá≥üá¥>
> <@ljharb:matrix.org> that said, calendar management can be tricky and it's really easy to accidentally fire off dozens of email notifications, and there's no audit log to restore deleted events

I guess that makes sense given that those operations are not actually part of the calendar protocol

[04:52:49.0996] <Michael Ficarra>
yeah I'm fine with delegating the calendar management as long as the people are decently responsive

[04:52:52.0625] <ryzokuken üá≥üá¥>
the calendar protocol is weird actually, but maybe you have some degree of a backlog in your emails

[04:53:07.0891] <ryzokuken üá≥üá¥>
or CalDAV

[04:54:08.0837] <Chris de Almeida>
source maps still on my calendar, but not on the tc39 calendar

[04:54:33.0292] <Chris de Almeida>
it's 2023 and calendaring is still in the dark ages

[04:54:46.0907] <Chris de Almeida>
TG5: Calendar Spec

[04:55:29.0626] <ryzokuken üá≥üá¥>
Chris de Almeida: 100% seriously I've been thinking about it a lot lately

[04:55:34.0242] <ryzokuken üá≥üá¥>
and trying to fix that somewhat

[04:56:05.0939] <Chris de Almeida>
I'd support you

[04:57:42.0176] <shu>
littledan: so actually for the loop bound recomputation bugs there are already tests AFAICT

[04:58:09.0969] <shu>
(marja implemented and wrote the tests for them, but i didn't correctly fix the spec draft)

[04:58:14.0402] <Andreu Botella>
syg: I wonder if throwing if there was a concurrent too-large grow makes sense, since if the concurrent grow happens just after this thread's grow returns, you'd still have a too-large buffer when you try to use it

[04:58:18.0684] <shu>
the only one missing is the detach timing

[04:58:46.0734] <Andreu Botella>
 *  shu: I wonder if throwing if there was a concurrent too-large grow makes sense, since if the concurrent grow happens just after this thread's grow returns, you'd still have a too-large buffer when you try to use it

[04:58:47.0436] <shu>
Andreu Botella: you mean throwing if there is _any_ race?

[04:59:18.0103] <shu>
i don't think so, because racing for too-large cannot be reliably detected

[04:59:37.0176] <Andreu Botella>
no, I mean you'd still have a race in user code if the concurrent grow happens just a bit too late

[04:59:46.0784] <shu>
right, you can't detect that

[04:59:57.0035] <Andreu Botella>
so why try to detect it inside the loop?

[05:00:15.0695] <Andreu Botella>
well, I guess you'd have to detect it anyway, but why throw

[05:00:24.0443] <shu>
the race inside the loop is for the opposite case, where grow(10) races with grow(20)

[05:00:32.0321] <Rob Palmer>
https://github.com/tc39/proposal-array-grouping/issues/57

[05:00:35.0443] <shu>
and grow(20) happens first, and grow(10) is now a shrink

[05:00:38.0615] <shu>
and is disallowed

[05:00:49.0337] <shu>
it's throwing not because of a race per se, it's throwing because shrinks already throw

[05:01:07.0247] <shu>
you could have it silently do nothing, that's a possibility

[05:01:09.0094] <Andreu Botella>
After a grow, you know the SAB is *at least* the size you've grown it too

[05:01:15.0527] <Andreu Botella>
so I'm not thinking of the grow(10) as a shrink

[05:01:21.0051] <Andreu Botella>
maybe a user might

[05:01:32.0322] <Andreu Botella>
 * maybe a user might though

[05:02:05.0767] <shu>
that's fair, this could be relaxed, but it's shipped with these semantics already and i don't feel particularly compelled to change it

[05:02:13.0487] <Andreu Botella>
oh, right, a slightly-too-late grow(10) would indeed throw

[05:02:21.0297] <Andreu Botella>
that makes sense then

[05:02:22.0007] <shu>
the actual answer is just... don't race your grows

[05:02:23.0926] <shu>
synchronize another way

[05:03:16.0858] <ryzokuken üá≥üá¥>
I understand that but given the level of abstraction we work on, couldn't we do a bit of hand holding here?

[05:03:36.0345] <ryzokuken üá≥üá¥>
make it a bit harder to run into this issue to begin with to whatever extent we can

[05:04:07.0424] <ryzokuken üá≥üá¥>
> <@shuyuguo:matrix.org> that's fair, this could be relaxed, but it's shipped with these semantics already and i don't feel particularly compelled to change it

oh, this is quite compelling, nvm 

[05:04:27.0025] <littledan>
> <@usharma:igalia.com> I understand that but given the level of abstraction we work on, couldn't we do a bit of hand holding here?

yeah I think this is generally not the right kind of thing to do with low-level concurrency primitives

[05:05:11.0115] <littledan>
So, should we have a brief overflow topic to get through the conditionality?

[05:05:20.0725] <littledan>
if msaboff expects to review it tonight

[05:05:59.0809] <littledan>
it has not really been helpful to replace what we were calling "conclusion" with "summary". The idea was to be more detailed.

[05:06:17.0467] <shu>
agreed with littledan, i think hand-holding lock-free concurrency stuff is just not a good idea

[05:06:18.0216] <littledan>
we've had a conclusion for a long time

[05:07:01.0905] <Michael Ficarra>
the request from this morning is just that we don't forget to add a conclusion

[05:07:56.0271] <littledan>
this is false. The request from Ecma has been to add summaries. We had been adding conclusions previously.

[05:08:23.0330] <littledan>
I'm really confused by the resistance from the committee to summaries. I really think they would make the notes more accessible.

[05:08:42.0882] <littledan>
the idea is to cover the main points in the presentation and discussion, not only the things we got consensus on

[05:09:08.0246] <littledan>
if a delegate doesn't want to write a summary, that's OK, but I don't understand why they should oppose others writing summaries...

[05:10:49.0452] <ljharb>
i don't recall any opposition to someone just going in and adding a summary - i thought the opposition was just to pausing the meeting and/or asking champions to write a summary

[05:11:07.0858] <ljharb>
 * i don't recall any opposition to someone just going in and adding a summary - i thought the opposition was just to pausing the meeting and/or asking champions to write a summary, but maybe i'm not remembering right

[05:21:34.0330] <Chris de Almeida>
the summaries (with or without a conclusion) are very helpful.  it takes only a moment for the speaker to dictate a summary.  I don't think there's a lot of controversy with this, but in the past IIRC it was only because it was perceived to take up too much committee time.  but I think that was also when we were sitting there waiting for the speaker (or someone else) to type up the summary, whereas it should just be dictated, which should only take a moment, and can be cleaned up async as needed

[05:22:45.0343] <Chris de Almeida>
so yes, Jordan is right that it was in opposition to pausing the meeting. it's such a small sacrifice though and is a lot easier to do when it's timely

[05:24:23.0552] <Chris de Almeida>
but 100% almost every time in recent memory where I needed to refer to meeting notes, it was so helpful to have those summaries rather than having to scour the entire dialog

[05:24:31.0004] <Chris de Almeida>
 * 100% almost every time in recent memory where I needed to refer to meeting notes, it was so helpful to have those summaries rather than having to scour the entire dialog

[05:38:44.0161] <Luca Casonato>
syg: The profile ^^



[05:43:01.0547] <Michael Ficarra>
ljharb: if you don't use namespace imports, you will have effects triggered on reading a local

[05:43:11.0229] <Michael Ficarra>
reading a local shouldn't have an effect

[05:44:48.0092] <ljharb>
i agree with that

[05:45:08.0092] <ljharb>
that doesn't mean `import *` is any more palatable tho

[05:45:23.0883] <littledan>
> <@ljharb:matrix.org> that doesn't mean `import *` is any more palatable tho

Do you have any other suggestions?

[05:45:44.0068] <rbuckton>
> <@michaelficarra:matrix.org> reading a local shouldn't have an effect

`with` would like a word /s

[05:46:05.0684] <Michael Ficarra>
"why not `with` but *everywhere*?"

[05:46:47.0664] <HE Shi-Jun>
I don't understand current page...

[05:47:16.0716] <ljharb>
> <@littledan:matrix.org> Do you have any other suggestions?

no, the design goals of ESM didn't really leave many options here i can see :-/

[05:47:38.0436] <Jack Works>
> <@michaelficarra:matrix.org> reading a local shouldn't have an effect

but imported variable isn't a local.

[05:47:47.0719] <ljharb>
sure it is

[05:47:58.0622] <littledan>
like it could be `import with` instead of `import defer`?

[05:48:01.0096] <HE Shi-Jun>
personally i think some magic like `with` is acceptable in this specific case :)

[05:48:03.0070] <ljharb>
altho it's slightly different in that its value can change out from under you

[05:48:15.0287] <ljharb>
 * altho it's slightly different in that its value can change out from under you if the export is a `let` that's reassigned

[05:48:30.0539] <littledan>
> <@ljharb:matrix.org> no, the design goals of ESM didn't really leave many options here i can see :-/

I don't really understand why the namespace restriction is fatal, but I guess you'll explain in your queue item?

[05:48:46.0419] <ljharb>
i didn't say it was fatal. but yes, i will

[05:48:58.0855] <ljharb>
 * i didn't say it was fatal. but yes, i will elaborate on my queue item

[05:49:09.0148] <littledan>
 * like it could be `import with` instead of `import defer`? (joking)

[05:49:31.0238] <ljharb>
 * i didn't say it was fatal. but yes, i will elaborate on my queue item (i just combined my two into one)

[05:49:38.0708] <Jack Works>
I support allowing `import defer { ... }`, we have already using it by the webpack implementation and we found enforcing a namespace is somewhat a bad DX .

[05:50:25.0662] <littledan>
in our use at Bloomberg, we've found that the restriction to a namespace is a little annoying but not really that bad

[05:50:58.0852] <ljharb>
bakkot: adding TLA to a module is already a breaking change i think

[05:51:07.0360] <littledan>
the more significant thing is the decision about whether to include deferred * re-exports (coming later in the slides, proposed to discuss during stage 2)

[05:51:10.0177] <danielrosenwasser>
> <@lucacasonato:matrix.org> sent an image.

is the second column milliseconds?

[05:51:18.0316] <littledan>
> <@ljharb:matrix.org> bakkot: adding TLA to a module is already a breaking change i think

well. ot

[05:51:33.0009] <littledan>
> <@ljharb:matrix.org> bakkot: adding TLA to a module is already a breaking change i think

 * well. it's observable but it's intended to not be quite breaking

[05:52:02.0676] <Luca Casonato>
> <@danielrosenwasser:matrix.org> is the second column milliseconds?

i think either function call count or sample count - but I don't know for sure

[05:52:17.0953] <ljharb>
i believe there's nonzero use cases where if a module starts using TLA, things will break - i forget which off the top of my head tho

[05:52:31.0102] <rbuckton>
> <@littledan:matrix.org> in our use at Bloomberg, we've found that the restriction to a namespace is a little annoying but not really that bad

I wonder if we could employ a heuristic where named imports that are only used in functions are deferred until the first function call?

[05:53:55.0166] <nicolo-ribaudo>
> <@ljharb:matrix.org> i believe there's nonzero use cases where if a module starts using TLA, things will break - i forget which off the top of my head tho

If it has side effects and a module that does not list it as a dependency relies on its side effects

[05:55:02.0965] <ljharb>
hm, that's not what i was thinking of, but since i can't recall specifics rn, ¬Ø\_(„ÉÑ)_/¬Ø 

[05:55:05.0042] <rbuckton>
i.e.:
```js
// a.js
import defer * as ns from "foo";
// defer until `ns` property accessed.

// b.js
import defer { a, b } from "foo";
export function f() { console.log(a, b); } // defer until `f` is called

// c.js
import defer { a, b } from "foo";
console.log(a, b); // not actually deferred
```

[05:55:08.0139] <ljharb>
 * hm, that's not what i was thinking of, but since i can't recall specifics rn, ¬Ø\\\_(„ÉÑ)\_/¬Ø

[05:55:23.0649] <bakkot>
> <@ljharb:matrix.org> i believe there's nonzero use cases where if a module starts using TLA, things will break - i forget which off the top of my head tho

for well-behaved graphs I don't think it's ever breaking; it's only if there's weird side-effect ordering problems that it breaks

[05:56:27.0366] <bakkot>
> <@rbuckton:matrix.org> I wonder if we could employ a heuristic where named imports that are only used in functions are deferred until the first function call?

fwiw that seems like too much magic to me

[05:56:47.0885] <Jack Works>
> <@bakkot:matrix.org> for well-behaved graphs I don't think it's ever breaking; it's only if there's weird side-effect ordering problems that it breaks

we've hit that. we have code `onAppInstall.addListener(...)` which the callback is _only_ called if the callback is registered in 1st event loop.

[05:57:37.0460] <rbuckton>
> <@bakkot:matrix.org> fwiw that seems like too much magic to me

`defer` itself is too much like magic

[05:58:08.0841] <bakkot>
the thing where the namespace object implicitly has side-effecting accessors is, just barely, not too magic for me

[05:58:19.0640] <bakkot>
the previous suggestion of having local access be side-effecting was too magic

[05:58:24.0891] <bakkot>
but property access can already be side-effecting

[05:58:28.0838] <Luca Casonato>
bakkot: Most places I have seen TLA in is leaf modules (for example Wasm loading), or the top level entrypoint (for example data fetching in a CLI). In my experience TLA anywhere between entrypoint and leaf is very rare.

[05:58:30.0912] <bakkot>
you can explain this feature in terms of existing ones

[05:58:37.0248] <bakkot>
 * you can (mostly) explain this feature in terms of existing ones

[05:58:38.0417] <ljharb>
it still feels too magic to me tbh

[05:58:40.0307] <bakkot>
so it is, just barely, ok with me

[05:58:56.0073] <bakkot>
> <@lucacasonato:matrix.org> bakkot: Most places I have seen TLA in is leaf modules (for example Wasm loading), or the top level entrypoint (for example data fetching in a CLI). In my experience TLA anywhere between entrypoint and leaf is very rare.

why would wasm loading be a leaf?

[05:59:00.0824] <bakkot>
wasm is just like... code

[05:59:08.0479] <rbuckton>
> <@rbuckton:matrix.org> `defer` itself is too much like magic

but also, determining whether named imports are lexically scoped to functions is statically analyzable, with the exception of direct-`eval` (which could just block deferred evaluation anyways).

[05:59:24.0022] <Jack Works>
+1 I don't think it's magical for the `ns` case. Direct import binding is a little bit magic but also good to me.

[06:00:17.0505] <Michael Ficarra>
> <@bakkot:matrix.org> why would wasm loading be a leaf?

... because it needs to be passed an imports object? how can it not be a leaf?

[06:01:51.0372] <bakkot>
I guess I mean a difference sense of "loading"

[06:02:00.0740] <bakkot>
yes, loading the bytecode is a leaf, of cousre

[06:02:03.0623] <bakkot>
 * yes, loading the bytecode is a leaf, of course

[06:03:02.0537] <bakkot>
but if you have a library which has a wasm component, it seems like "TLA to async-compile the wasm" is a pretty normal use case

[06:03:56.0303] <bakkot>
which means your library's entry point would have a TLA, not just the leafs of the library

[06:05:57.0951] <shu>
i don't think i'm confused

[06:06:08.0207] <shu>
i'm saying in JS, compilation can be transparently deferred and folded into evaluation

[06:06:19.0838] <shu>
in wasm because timing is of a bigger concern, it cannot be generally transparently deferred

[06:06:54.0635] <Jack Works>
I also want to notice the deferred is not only the compilation happened in the engine, but also the _execution_ of the JS code

[06:06:55.0388] <shu>
and the motivating number of "half the time spent in evaluation" as shown by the profiler output suggests that that includes main-thread deferred compilation

[06:07:07.0677] <shu>
well yes, obviously the execution is the main thing to be deferred

[06:07:16.0402] <shu>
i'm questioning the "half the time" measure and what it includes

[06:07:18.0551] <sffc>
https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Instance/Instance#syntax says in a big red box, "Warning: Since instantiation for large modules can be expensive, developers should only use the Instance() constructor when synchronous instantiation is absolutely required; the asynchronous WebAssembly.instantiateStreaming() method should be used at all other times."

[06:07:58.0049] <sffc>
^ This is about the sync constructor after you already have an async compiled Module

[06:08:01.0853] <Jack Works>
for example https://github.com/alexcorvi/anchorme.js/pull/127 this library cost 30ms to init (this PR is reverted by the author). We now using `defer` to save this 30ms

[06:08:11.0708] <littledan>
> <@shuyuguo:matrix.org> i'm questioning the "half the time" measure and what it includes

right, the thing is, we have a whole bunch of data about the benefit of this, and the champions were conservative about what they included on slides. I think it's reasonable that you ask how much benefit this will get on the web.

[06:08:28.0228] <littledan>
I would point out, though, that when it's a cache hit, the fetching and compiling part might be pretty quick

[06:08:30.0139] <shu>
i'm convinced it's a win for JS for sure

[06:08:57.0427] <shu>
the wasm questions got me doubting about how well the performance story composes

[06:08:58.0946] <Rob Palmer>
Synchronous lazy loading in CommonJS is sometime known as "inline requires".  Jest managed to [half their startup time](https://jestjs.io/blog/2016/03/11/javascript-unit-testing-performance#inline-requires-and-lazy-mocking) by incorporating this technique.

[06:09:03.0020] <shu>
or are we also introducing performance footguns

[06:09:17.0379] <littledan>
I guess I don't understand the performance breakdown case

[06:10:35.0663] <littledan>
you're all right that we should investigate this better for Wasm. I think this should block Stage 3.

[06:10:52.0626] <littledan>
I should've realized that earlier, so thanks for raising it

[06:11:06.0324] <Michael Ficarra>
Chris de Almeida: have you considered just implementing https://github.com/bterlson/tcq/issues/14?

[06:11:26.0430] <Michael Ficarra>
there's so many good things on the TCQ issue tracker

[06:11:28.0100] <eemeli>
I wonder if a module could say e.g. `"defer load"` to communicate that if it's loaded via `import defer`, all of its imported dependencies could be completely deferred until its evaluation.

[06:11:50.0878] <shu>
well i think the wasm case is generalizable to a certain kind of module with a certain weight profile of time spent in which phases

[06:12:04.0521] <shu>
the high-order bit for me is "does the performance story compose"

[06:12:16.0381] <bakkot>
concretely, I have published exactly one wasm-based library (z3-solver). It's CJS-based so it has an async `init` function, but if it was ESM-based it would totally have a top-level `await` in its entrypoint, not at a leaf. and it's doing a nontrivial amount of computation on load, of exactly the sort I'd hope to be deferring by the use of `defer`.

[06:12:20.0177] <shu>
can someone who doesn't need sync evaluation can just always insert `defer` and get some loading wins

[06:12:37.0123] <Chris de Almeida>
Michael Ficarra: yeah.. I think we need a DX workflow presentation from BT first

[06:13:50.0703] <littledan>
> <@shuyuguo:matrix.org> the high-order bit for me is "does the performance story compose"

right, I think this comes down to some details of the algorithm for exactly what is made eager. It's a good action item for the champions to articulate some more cases to investigate this. My intuition is that it should work out as long as you do `import defer` for the imports from within the module that uses TLA--then you get the deferred-ness back

[06:13:56.0556] <Rob Palmer>
> <@shuyuguo:matrix.org> the high-order bit for me is "does the performance story compose"

Given our experience deploying an ESM system, we've found the ESM performance composition story is not viable without this feature.

[06:14:16.0435] <Jack Works>
let me rejoin

[06:14:22.0337] <littledan>
> <@robpalme:matrix.org> Given our experience deploying an ESM system, we've found the ESM performance composition story is not viable without this feature.

this matches what Yulia shared for Firefox DevTools at the outset of this project

[06:14:34.0731] <shu>
that's not what i mean by composition, i don't think

[06:14:40.0681] <Rob Palmer>
It also matches what I've said at every plenary where this item is brought up ;-)

[06:14:54.0305] <shu>
i understand Yulia's original claim to be "ESM performance story is not viable without this feature"

[06:15:01.0274] <Rob Palmer>
ok sorry if I misinterpreted the point

[06:15:01.0834] <shu>
maybe that's the overriding thing

[06:15:45.0646] <littledan>
> <@littledan:matrix.org> right, I think this comes down to some details of the algorithm for exactly what is made eager. It's a good action item for the champions to articulate some more cases to investigate this. My intuition is that it should work out as long as you do `import defer` for the imports from within the module that uses TLA--then you get the deferred-ness back

does this match what you're asking about, shu ?

[06:17:11.0507] <shu>
let me try to articulate what i'm asking for plenary littledan 

[06:18:12.0048] <ljharb>
webpack might be the TLA breaking change i was thinking of

[06:19:08.0400] <danielrosenwasser>
I know bakkot  mentioned something like this - but it does feel like `import defer` is going to ring the wrong bells for a lot of people who expect this won't even do script parsing.

Not that I am necessarily advocating for that behavior.

[06:19:13.0871] <Jack Works>
this proposal is good enough for sync usage. I have no idea about TLA and WASM and we  haven't try that yet.

[06:19:59.0506] <ljharb>
so it did get stage 2?

[06:20:07.0380] <ryzokuken üá≥üá¥>
yeah

[06:20:14.0369] <ljharb>
k

[06:20:14.0875] <Ashley Claymore>
fwiw, at Bloomberg we still encourge use of fully-async dynamic import when that is viable. This proposal has been great for the places where it has not been viable to go fully async

[06:20:32.0170] <shu>
Ashley Claymore: see that smells really off to me

[06:21:54.0675] <Ashley Claymore>
the current situation when it is not viable is that code is written to be fully eager.

[06:22:41.0030] <shu>
hm my internet is not down but zoom disappeared for me

[06:23:01.0080] <shu>
just me?

[06:23:07.0938] <Jack Works>
no, I can see zoom

[06:25:16.0660] <shu>
okay, took a while to come back

[06:25:25.0899] <shu>
Ashley Claymore: right, agreed on that premise

[06:26:02.0853] <littledan>
> <@shuyuguo:matrix.org> Ashley Claymore: see that smells really off to me

it's pretty common that you're writing code that's not in an async function... I don't think that's going to go away.

[06:26:03.0505] <shu>
Ashley Claymore: but it doesn't smell right to me (yet) that we've been saying "asyncify" and now saying "well, if you did asyncify if you wanna take advantage of this new deferral thing you might not be able to"

[06:27:14.0899] <Rob Palmer>
shu: Using dynamic import would only neuter the deferred import if the dynamic import were awaited at top-level.  The general advice is to never do that.  Instead, dynamic import is best used just-in-time inside async functions that require it.

[06:27:51.0339] <shu>
i mean top-level await is a thing?

[06:28:08.0535] <shu>
i don't know how to reconcile that we added it with "actually the general advice is to never do that"?

[06:28:10.0047] <littledan>
> <@shuyuguo:matrix.org> Ashley Claymore: but it doesn't smell right to me (yet) that we've been saying "asyncify" and now saying "well, if you did asyncify if you wanna take advantage of this new deferral thing you might not be able to"

In some way, this is a key part of providing a well-scoped amount of feature parity from CJS into, since CJS has always supported this pattern (differently, just by having sync require, which is more general than this feature)

[06:28:20.0975] <littledan>
> <@shuyuguo:matrix.org> Ashley Claymore: but it doesn't smell right to me (yet) that we've been saying "asyncify" and now saying "well, if you did asyncify if you wanna take advantage of this new deferral thing you might not be able to"

 * In some way, this is a key part of providing a well-scoped amount of feature parity from CJS into ESM, since CJS has always supported this pattern (differently, just by having sync require, which is more general than this feature)

[06:28:25.0857] <shu>
interesting framing

[06:28:29.0606] <shu>
i don't know enough about CJS to say

[06:28:35.0316] <Rob Palmer>
"never do that" -> "avoid if possible" (I was too strong)

[06:28:38.0618] <shu>
 * i don't know enough about CJS to say if i find that compelling

[06:28:53.0915] <Michael Ficarra>
üòÆ I had no idea they didn't have an FPU!

[06:29:21.0317] <littledan>
> <@shuyuguo:matrix.org> i don't know how to reconcile that we added it with "actually the general advice is to never do that"?

I think this isn't actually the advice--it's more like, if you want the deferral to happen, you also need to defer the imports within the TLA-containing module, and not put the only `defer` things higher up in the module graph

[06:31:46.0607] <Jesse (TC39)>
someone is spamming the notes with the  letter t

[06:32:04.0571] <Andreu Botella>
did someone fall asleep at their keyboard? /j

[06:32:44.0720] <Michael Ficarra>
why would we want `irandom` to take bounds if `random` doesn't? I don't like it

[06:32:53.0419] <Chris de Almeida>
üêàÔ∏è
‚å®Ô∏è

[06:37:02.0388] <HE Shi-Jun>
Because it's very common? `Math.random()` actually have bounds implicitly 

[06:37:15.0742] <littledan>
Note that our internal membership lists don't exactly match what Ecma has recorded. We should work to reconcile these. cc saminahusain 

[06:37:35.0058] <bakkot>
> <@michaelficarra:matrix.org> why would we want `irandom` to take bounds if `random` doesn't? I don't like it

don't think if it as "like random, but gives an int"

[06:37:49.0311] <bakkot>
think of it as "like randInt, the extremely useful function in every other standard library"

[06:38:12.0854] <bakkot>
(probably it should also not be spelled `irandom`)

[06:39:19.0127] <Michael Ficarra>
sffc: is divrem considered an alternative to divmod or is it still useful even when you have divmod?

[06:40:50.0226] <HE Shi-Jun>
why not operator `a /% b` instead of `divrem`? üòÅ

[06:40:52.0511] <Michael Ficarra>
littledan: doesn't Ecma only keep one point of contact per member?

[06:41:14.0822] <bakkot>
sffc: ... because we don't have 64-bit integers?

[06:42:04.0082] <shu>
yeah i think... that's just that

[06:42:10.0274] <shu>
also i don't want to allocate BigInts?

[06:43:43.0332] <littledan>
yeah I guess if we wanted to support 64-bit integers we'd need stuff for, like, adding two bigints and then rounding to the right 64-bit int (possible to define in multiple ways for signed vs unsigned). I'm not convinced we need that--my hope was that BigInt.asUintN would be a suitable replacement (to call after the bigint arithmetic op)

[06:44:29.0045] <littledan>
> <@shuyuguo:matrix.org> also i don't want to allocate BigInts?

I guess the hope is that the compiler would do representation analysis and avoid allocating BigInts

[06:44:39.0229] <shu>
lol, lmao

[06:45:06.0065] <littledan>
why lol?

[06:45:26.0341] <littledan>
I mean, it's fine that you don't do it now, but I don't know what the blocker would be if it were used commonly enough

[06:46:07.0858] <littledan>
like, this is a totally classical optimization in the Scheme world

[06:46:18.0426] <shu>
i don't think that will ever happen outside of the optimizing tier

[06:46:37.0947] <littledan>
oh yeah definitely

[06:46:50.0885] <shu>
and i don't consider optimizing tier hope to be very compelling for proposal motivations, or alleviating proposal performance concerns

[06:47:50.0884] <littledan>
I mean, this logic went into the decision to not add int64 and instead go for bigint, in the first place

[06:48:38.0121] <shu>
yes, and in retrospect i think it was wrong

[06:49:08.0722] <shu>
for Promise.withResolvers: i have another meeting at 7am (didn't realize this went until 7:15)

[06:49:35.0151] <littledan>
shu: Are you OK with the presentation going on? we can return to it later if you want to give more comments

[06:49:41.0503] <littledan>
but you might have time for yours

[06:49:52.0338] <shu>
yes of course

[06:59:43.0716] <sffc>
> <@michaelficarra:matrix.org> sffc: is divrem considered an alternative to divmod or is it still useful even when you have divmod?

I was referring to the Euclid divrem, which always returns positive numbers for the remainder and rounds the quotient toward negative Infinity instead of zero. At least this is what Rust calls the operation (added a link to the notes)

[07:02:20.0756] <littledan>
> <@sffc:mozilla.org> I was referring to the Euclid divrem, which always returns positive numbers for the remainder and rounds the quotient toward negative Infinity instead of zero. At least this is what Rust calls the operation (added a link to the notes)

thanks for clarifying in the notes

[07:03:11.0061] <bakkot>
I maintain that `defer` and `deferred` are awful names for anyone who doesn't know the history, which is 95%+ of users

[07:03:14.0771] <bakkot>
it doesn't defer anything

[07:03:22.0572] <bakkot>
and `deferred` is not a noun

[07:07:17.0236] <littledan>
> <@bakkot:matrix.org> I maintain that `defer` and `deferred` are awful names for anyone who doesn't know the history, which is 95%+ of users

Yeah, bikeshedding names is sort of the rare case where it is reasonable to make decisions based on the knowledge of percentages of JS developers

[07:07:41.0385] <Christian Ulbrich>
Rob Palmer: We'd gladly host you in Dresden :)

[07:08:18.0983] <Jack Works>
than we can name it `import duck` until stage 3 üòá

[07:09:45.0193] <bakkot>
ok I'm assuming nothing else important is happening so I am going to go sleep

[07:27:01.0679] <Luca Casonato>
```
// wasm.js
const mod = await WASM.instantiateStreaming(fetch(‚Ä¶));
export const foo = mod.exports.foo;
```

[07:27:15.0750] <Luca Casonato>
This is a leaf. No imports

[08:02:56.0556] <Mathieu Hofman>
bakkot: looks like we're missing the logs for today? https://matrixlogs.bakkot.com/TC39_Delegates/2023-07-11

[08:19:27.0865] <Chris de Almeida>
> <@mhofman:matrix.org> bakkot: looks like we're missing the logs for today? https://matrixlogs.bakkot.com/TC39_Delegates/2023-07-11

I think it's a cron job that runs, not realtime (?)

[08:32:40.0089] <Chris de Almeida>
I forgot who asked, but I added the TG3 slides to the agenda (`07.md`)

[08:37:28.0392] <Chris de Almeida>
https://www.ecma-international.org/news/ecma-tc39-ecmascript-has-formed-a-new-task-group-tg3-dedicated-to-the-security-of-the-ecmascript-javascript-language/

do we want/need to work with Ecma on drafting something like this for TG4?  littledan jkup 

[09:08:51.0792] <jkup>
> <@softwarechris:matrix.org> https://www.ecma-international.org/news/ecma-tc39-ecmascript-has-formed-a-new-task-group-tg3-dedicated-to-the-security-of-the-ecmascript-javascript-language/
> 
> do we want/need to work with Ecma on drafting something like this for TG4?  littledan jkup 

I think that would be great!

[09:14:00.0568] <ljharb>
Array Grouping has now met its stage 3 condition

[09:48:18.0682] <shu>
peetk: i am fine with Promise.withResolvers advancing to Stage 3 given the explanations

[09:48:30.0602] <shu>
sorry for having to drop out early

[09:48:56.0598] <shu>
(though for the future i'd still prefer to not have meetings end on :15 which is kinda weird)

[10:02:32.0506] <shu>
i think it's good and healthy to revisit, and overturn, previous design decisions based on new evidence

[10:03:52.0542] <shu>
but still in this particular case and future ones i don't want to conflate "good" defaults and developer signal

[10:07:10.0173] <shu>
the end goal for me is users, not developers, and good defaults for me should be chosen to nudge developers to the result (responsiveness, correctness, fast loading, whatever) we want on products they build for the user. if _all_ developers ignore a default constantly, then we obviously failed and nobody benefits. Google-internally, i did not get this sense when talking with practitioners

[10:08:48.0957] <shu>
this is all to say that it's a common argument in committee to say "look developers all do X and want Y", and it's not really that much signal to me most of the time

[10:09:17.0646] <shu>
 * the end goal for me is users, not developers, and good defaults for me should be chosen to nudge developers to the result (responsiveness, correctness, fast loading, whatever) we want on products they build for the user. if _all_ developers ignore a default constantly, then we obviously failed and nobody benefits. Google-internally, i did not get this sense when talking with practitioners about a lack of a defer-like thing

[10:10:13.0442] <Chris de Almeida>
how do you feel about DX as motivation for proposals in general?

[10:11:17.0446] <shu>
i think it is a weak motivation by itself

[10:13:07.0335] <shu>
as a general rule i do not think DX outweighs other concerns like security and performance

[10:13:28.0533] <shu>
if the other concerns are minimal, then DX is the right thing to optimize for

[10:14:59.0532] <shu>
but at the scale of JS and the web, until we figure out a way to do zero-cost DX improvements, it is explicitly a non-goal for me

[10:21:27.0525] <shu>
(it is not an anti-goal, i'm not saying i will actively oppose DX proposals, just that it is not a thing i will push for and find compelling standalone, but i certainly won't block absent other concerns)

[10:24:29.0662] <bakkot>
> <@mhofman:matrix.org> bakkot: looks like we're missing the logs for today? https://matrixlogs.bakkot.com/TC39_Delegates/2023-07-11

ugh, yes, something's up with my server

[10:25:43.0010] <bakkot>
it keeps making the boot disk read-only

[10:25:47.0847] <bakkot>
for reasons I have not been able to discern

[10:26:08.0481] <bakkot>
I will fix it later today and the logs will come back

[10:50:14.0227] <Chris de Almeida>
https://hackmd.io/BkORU_-kTKmR43Ipuohwog

schedule has been updated.  there is no difference in terms of constraints, but please review if you are presenting

[10:50:57.0578] <Chris de Almeida>
 * https://hackmd.io/BkORU\_-kTKmR43Ipuohwog

schedule has been updated.  there is no difference in terms of constraints, but please review if you are presenting.  edit: I think only Day 3 was affected, and changes are minor

[11:58:14.0652] <Mathieu Hofman>
I do not see Explicit resource management in the overflow section but from reading the notes I gather it did overflow its timebox?

[12:02:44.0087] <Chris de Almeida>
> Consensus on PRs: 180,178,175,171 and 167.

> Debates about the appropriate use of GC and Symbol.enter are ongoing and will take place in overflow time


[12:04:34.0115] <Chris de Almeida>
rbuckton: are we scheduling a continuation?  if so, how much time do you estimate?

[13:01:17.0639] <Ashley Claymore>
Thank you!

[13:17:33.0245] <rbuckton>
> <@softwarechris:matrix.org> rbuckton: are we scheduling a continuation?  if so, how much time do you estimate?

Yes, if we could. 15 minutes, maybe? 

[13:18:15.0496] <Chris de Almeida>
tomorrow morning work?

[13:18:45.0109] <Chris de Almeida>
if other topics run long or if 15 mins turns out to not be enough, there's still time available on Friday morning

[13:19:33.0680] <Chris de Almeida>
done

[13:20:24.0545] <Chris de Almeida>
 * if other topics run long or if 15 mins turns out to not be enough, there's still time available on Thursday morning


2023-07-12
[17:15:44.0630] <bakkot>
> <@mhofman:matrix.org> bakkot: looks like we're missing the logs for today? https://matrixlogs.bakkot.com/TC39_Delegates/2023-07-11

fixed. I suspect my boot disk is failing; will have it replaced tomorrow.

[19:17:00.0903] <Jack Works>
> <@shuyuguo:matrix.org> the end goal for me is users, not developers, and good defaults for me should be chosen to nudge developers to the result (responsiveness, correctness, fast loading, whatever) we want on products they build for the user. if _all_ developers ignore a default constantly, then we obviously failed and nobody benefits. Google-internally, i did not get this sense when talking with practitioners about a lack of a defer-like thing

the problem is we cannot everything by default because it's a breaking change

[20:03:24.0392] <shu>
not sure i follow

[20:03:36.0124] <shu>
the context of my previous comment was about the Promise constructor vs withResolvers

[20:04:14.0834] <Jack Works>
oh

[20:04:29.0446] <shu>
the "good default" was referring to the hope that the Promise constructor would, even though it's more inconvenient to use, would bring about better correctness results wrt uncaught exceptions -> rejections

[20:04:56.0737] <shu>
but since then we've learned that maybe that doesn't have quite the effect we hoped because people ignore it

[20:05:01.0237] <shu>
or because there are legitimate use cases

[20:05:15.0239] <shu>
and so, it's fine to add withResolvers, even though it's explicitly against what we thought was the good default

[20:05:51.0139] <shu>
but the broader point is that that's the kind of argument i'm looking to hearing, not simply "developers use pattern X"

[20:06:00.0275] <shu>
 * but the broader point is that that's the kind of argument i'm looking to hear, not simply "developers use pattern X"

[01:02:00.0423] <bakkot>
g'morning all

[01:10:12.0088] <jkup>
I have a question about calendars. The source map monthly call was on the TC39 calendar but I don't see it on there anymore. How can I go about adding it back? Do I make a personal event and then invite the calendar? Or do I need a special permission to do this?

[01:18:16.0682] <Michael Ficarra>
my understanding was that an event needs to be added to the private calendar first, and the public calendar is invited as an attendee of that event

[01:18:37.0120] <Michael Ficarra>
the public calendar has an email address to invite

[01:19:04.0106] <Michael Ficarra>
most of us regular-folk don't have permission to create such an event on the private calendar, though, so you should contact a chair or ljharb 

[01:19:11.0594] <jkup>
Thank you!

[01:24:16.0833] <littledan>
> <@shuyuguo:matrix.org> but since then we've learned that maybe that doesn't have quite the effect we hoped because people ignore it

I think this is the key point--despite many years passing, people are generally unaware both of the implied best practice and the fact that the promise constructor helps lead you to it, and on the other hand, the best practice is enforced by async/await. An illustration of the widespread lack of awareness is that no one even raised this concern in committee until you did, and without this awareness, people can't even really be expected to use the promise constructor in the way where it's helpful.

[01:33:29.0463] <rbuckton>
If `dayOfWeek` returns `2`, indicating this is the 2nd day of the week relative to the `firstDayOfWeek`, it could be confusing that both are numbers 1-7 but don't represent the same value.

[01:33:38.0594] <ryzokuken üá≥üá¥>
https://unicode.org/reports/tr35/#UnicodeFirstDayIdentifier

[01:33:46.0417] <ryzokuken üá≥üá¥>
(this is what Shane is talking about)

[01:34:47.0922] <rbuckton>
> <@rbuckton:matrix.org> If `dayOfWeek` returns `2`, indicating this is the 2nd day of the week relative to the `firstDayOfWeek`, it could be confusing that both are numbers 1-7 but don't represent the same value.

Assuming my interpretation is correct. 

[01:38:18.0510] <Bradford Smith>
This Unicode extension for locale identifiers seems nuts to me. You have to use the first part of the identifier "en" to know how to interpret the identification of the day of the week "tue".

[01:42:21.0338] <littledan>
It also maintains a list of all of the delegates to TC39; this is listed in the Ecma memento. When organizations add or remove delegates, someone is supposed to inform Ecma of this so they can update their lists (I think the chairs do this?). But anyway things have gone out of sync.

[01:50:51.0528] <littledan>
I think the summary can omit the back-and-forth that Frank and I had, and instead be in paragraph form. Will Frank be doing this rephrasing, or should I do so? (I don't see Frank here, maybe another Google could ask him?)

[01:51:07.0255] <littledan>
 * I think the summary can omit the back-and-forth that Frank and I had, and instead be in paragraph form. Will Frank be doing this rephrasing, or should I do so? (I don't see Frank here, maybe another Googler could ask him?)

[01:51:59.0685] <littledan>
(or bullet form)

[01:53:28.0183] <Rob Palmer>
Unless the presenter explicitly delegates, they remain responsible for the summary.  The secretary will chase presenters where summaries appear insufficient.  I'll make sure we say this on the Reflector.

[02:07:43.0222] <ryzokuken üá≥üá¥>
Ashley Claymore: should I put the link in the notes?

[02:08:54.0651] <Michael Ficarra>
ryzokuken üá≥üá¥: yes, there is a spot for you to do so already

[02:09:12.0182] <Michael Ficarra>
search for "slides presented but no link in agenda"

[02:14:59.0719] <HE Shi-Jun>
I slightly prefer `offset` solution because I guess developers use BYOB for perf, and would like to use `offset` to get perf benefit (even a little), and even without `offset`, it already complicated üòâ

[02:16:59.0014] <Michael Ficarra>
HE Shi-Jun: I wouldn't want to do that without compelling evidence that the perf is significantly better

[02:17:10.0586] <Michael Ficarra>
also, it would be safe to add later, right?

[02:21:09.0997] <ryzokuken üá≥üá¥>
> <@michaelficarra:matrix.org> ryzokuken üá≥üá¥: yes, there is a spot for you to do so already

done, thanks again for the reminder

[02:22:08.0423] <HE Shi-Jun>
> <@michaelficarra:matrix.org> also, it would be safe to add later, right?

agree it could be add later. I just think it very likely will have some perf benefit, especially on embed engines.

[02:27:15.0855] <Bradford Smith>
So, the alternative to having these "inputOffset" and "outputOffset" parameters is to have to create a separate view into the input & output base arrays on each iteration of the loop?

[02:29:43.0338] <Michael Ficarra>
Bradford Smith: yes, or a shifting view, and views should be very lightweight

[02:30:24.0287] <Michael Ficarra>
 * Bradford Smith: yes, and views should be very lightweight

[02:46:54.0982] <HE Shi-Jun>
After listening all queue discussion, I feel maybe we'd better leave the streaming api to future follow-on proposal ... 

[02:48:12.0314] <Christian Ulbrich>
I think we want the full cake, we want the un-disputed oneshot methods to fast-track, and have the streaming API versions that share consistency with them added later. Looks like a good challenge...

[02:48:48.0806] <Michael Ficarra>
I think the streaming design is as fleshed out as it's going to be, we just need to decide whether it's justified for inclusion or not

[02:49:08.0894] <Michael Ficarra>
I don't think splitting helps with that

[02:50:44.0468] <bakkot>
> <@michaelficarra:matrix.org> Bradford Smith: yes, and views should be very lightweight

views are apparently not that lightweight in JSC per https://github.com/tc39/proposal-arraybuffer-base64/pull/26#issuecomment-1617312928

[02:51:03.0791] <bakkot>
or at least not the first view

[02:51:40.0116] <Michael Ficarra>
*should*

[02:51:58.0011] <tkopp>
I dont think views are in general "lightweight" in comparison to actually know the place where you want to put yyour data

[02:52:28.0435] <tkopp>
> <@michaelficarra:matrix.org> I think the streaming design is as fleshed out as it's going to be, we just need to decide whether it's justified for inclusion or not

But, yes this might be true

[02:52:44.0996] <bakkot>
> <@michaelficarra:matrix.org> *should*

I think there's always going to tradeoffs in any representation, and a representation in which the second view of a buffer is expensive in exchange for the first view being faster is not obviously incorrect

[02:52:52.0890] <bakkot>
so I don't think "should" is at all obvious here

[02:54:24.0000] <bakkot>
Luca Casonato: https://github.com/tc39/proposal-arraybuffer-base64/issues/13 is the streaming issue, and https://github.com/tc39/proposal-arraybuffer-base64/issues/21 the one for encoding into an existing buffer

[02:55:56.0867] <bakkot>
the thing where you have a "prefix" argument to the one-shot API was my first suggestion, if I have understood correctly that this is what you were proposing; see response from justin in https://github.com/tc39/proposal-arraybuffer-base64/issues/13#issuecomment-911968641

[02:56:18.0460] <bakkot>
(and from peter, two comments down)

[03:00:40.0426] <littledan>
re: streaming: I think, in general, it's vaguely best practice that primitives that deals with data should have zero-copy and streaming APIs for doing stuff with them. To me, the main question is whether there are valid use cases for doing base64 on a fairly big thing that can't fit in memory/packets all together. I don't know of such use cases/environments.

[03:01:47.0809] <ryzokuken üá≥üá¥>
might be a bit cursed but I've seen people pass around entire images encoded in base64

[03:02:18.0555] <Michael Ficarra>
that's not even unusual

[03:02:18.0742] <ryzokuken üá≥üá¥>
 * might be a bit cursed but I've seen people pass around entire images encoded in encoded base64

[03:02:52.0075] <ryzokuken üá≥üá¥>
yeah, not sure how ideal it is, but it's certainly not uncommon

[03:03:13.0457] <littledan>
I know but there's a certain limit on how big they can get, right?

[03:04:06.0984] <littledan>
also I don't think HTML has a streaming API to set the src of an img tag...

[03:04:14.0076] <tkopp>
there are a lot of APIs that don't handle binary data at all. You can only send e.g. images via encoding

[03:04:22.0509] <Luca Casonato>
bakkot: My suggestion was this: https://gist.github.com/lucacasonato/06a74fe2658fbe5a2d9c24cc767006c0

No need for any `extra` option on the static API. This performs at most 3 byte copies for every remainder. The code can be optimized further.

[03:05:01.0526] <Michael Ficarra>
at Shape, we one-shot base64 decode something like 150kb of bytecode on the main thread every page load

[03:05:08.0499] <Michael Ficarra>
haven't run into any long task issues yet

[03:05:55.0014] <tkopp>
There is no "real" upper limit of the length of a string. Most of the limits are imposed by the server software that is used

[03:06:10.0467] <Ashley Claymore>
yes please

[03:06:15.0714] <Michael Ficarra>
let me introduce you to my good friend 2**53

[03:06:21.0608] <tkopp>
:D

[03:06:54.0155] <tkopp>
You might compress you string before you hit that ÀÜÀÜ

[03:07:01.0180] <tkopp>
*your

[03:07:14.0245] <bakkot>
ah, got it

[03:07:44.0484] <littledan>
> <@tkopp:matrix.org> there are a lot of APIs that don't handle binary data at all. You can only send e.g. images via encoding

it'd be good to understand use cases like this in some more detail

[03:07:49.0401] <Luca Casonato>
bakkot: do you have a link to your Web Streams impl ontop of the streaming API? I can't find it in your slides

[03:07:56.0024] <Luca Casonato>
 * bakkot: do you have a link to your Web Streams impl ontop of the proposed streaming API? I can't find it in your slides

[03:08:03.0376] <bakkot>
it's in the playground

[03:08:11.0266] <bakkot>
https://tc39.es/proposal-arraybuffer-base64/

[03:08:39.0667] <Luca Casonato>
Ah, thanks!

[03:10:50.0639] <ptomato (at TC39, limited availability)>
rbuckton: my personal opinion is that I'd like to investigate `Symbol.enter` but with what I know at this time, full context manager support seems excessive. I'd hesitate to speak for the committee, but that would be my recommendation

[03:10:50.0954] <tkopp>
soap APIs from transportation/shipping companies come to mind immediately.

[03:11:24.0800] <littledan>
great, I'd love to hear about your experience with these and how they relate to data size and streaming

[03:11:28.0671] <bakkot>
github rest API returns contents as base64-encoded strings

[03:11:54.0509] <bakkot>
for files up to 100MB in size

[03:14:52.0272] <bakkot>
actually I guess only up to 1MB; the API changes a bit for larger files

[03:14:56.0838] <Bradford Smith>
From my point of view Ron was just considering a related problem - how to make sure developers are nudged toward using the resource management features he's defining - and then coming up with a possible solution to this. He presented it as a possible follow-on proposal. DE seemed at first to be saying that this problem is important enough to force changes to the existing stage 3 proposal, but I think he's backed down from this. I think the conclusion is not to include such a feature in the current proposal.

[03:15:19.0969] <rbuckton>
I'll reiterate that I don't have an appetite for full context managers. They add a level of complexity that I'm not sure is suitable for ECMAScript, and they would have a negative impact on the ability for static type checkers like TypeScript to make reasonable assumptions about control flow due to ability for any context manager bound to a `using` to swallow an exception. 

[03:18:34.0245] <Bradford Smith>
Regarding the GC cleanup issue: I thought Ron was suggesting that engines could be encouraged to clean up any disposables that they themselves created (not every possible disposable) if they go out of scope without "leaking" anywhere else from the scope where they were created. 

[03:19:05.0387] <Bradford Smith>
just encouraged, not required

[03:19:37.0644] <rbuckton>
If we're not doing full context managers, then the goal of the proposed change would be to resolve a concern about "unused" disposables. That would be addressed by `Symbol.enter` without the need to introduce a `Symbol.asyncEnter`. `await using` would still verify/capture `[Symbol.asyncDispose]` as it does today, but would call `[Symbol.enter]()` synchronously without the need to introduce an extra `Await` at the declaration site. That would also avoid needing to rethink `AsyncDisposableStack.prototype.use` to handle the async case.

[03:20:18.0955] <Ashley Claymore>
for using `Symbol.enter` as a way for types to _enforce_ they are being assigned to `using`, could this also be done with `Symbol.dipose` setting a `userHasAcknoledgedLifetime` flag that either errors/warns if other methods are called without that flag set?

[03:20:24.0521] <bakkot>
> <@littledan:matrix.org> re: streaming: I think, in general, it's vaguely best practice that primitives that deals with data should have zero-copy and streaming APIs for doing stuff with them. To me, the main question is whether there are valid use cases for doing base64 on a fairly big thing that can't fit in memory/packets all together. I don't know of such use cases/environments.

it's not just about whether it all fits in memory; for example, one might reasonably stream base64'd wasm bytecode into WebAssembly.compileStreaming. the advantage of streaming in this case is that you can start doing work before waiting for the whole download to finish. which is nice!

[03:21:12.0270] <bakkot>
similarly, if you're uploading base64'd data to a server, you might do binary data -> compression stream -> base64 stream -> `fetch`; it's nice to be able to start the network request as early as possible

[03:21:43.0418] <Ashley Claymore>
my gut feeling is also that `DisposeStack.p.return` is a simpler API to explain that the enter/exit symbols.

[03:21:44.0173] <rbuckton>
> <@aclaymore:matrix.org> for using `Symbol.enter` as a way for types to _enforce_ they are being assigned to `using`, could this also be done with `Symbol.dipose` setting a `userHasAcknoledgedLifetime` flag that either errors/warns if other methods are called without that flag set?

Yes, a user-defined implementation could conceivably make `[Symbol.dispose]` a getter that indicates the method was at least read.

[03:21:58.0224] <rbuckton>
> <@aclaymore:matrix.org> my gut feeling is also that `DisposeStack.p.return` is a simpler API to explain that the enter/exit symbols.

what is `return`?

[03:22:03.0391] <Ashley Claymore>
sorry, move

[03:22:06.0860] <Ashley Claymore>
 * sorry, `move`

[03:22:13.0457] <Ashley Claymore>
 * my gut feeling is also that `DisposeStack.p.move` is a simpler API to explain that the enter/exit symbols.

[03:24:46.0181] <rbuckton>
> <@bradfordcsmith:matrix.org> Regarding the GC cleanup issue: I thought Ron was suggesting that engines could be encouraged to clean up any disposables that they themselves created (not every possible disposable) if they go out of scope without "leaking" anywhere else from the scope where they were created.

My intent was to state that as a remediation for an "unused" disposable, a host could leverage GC if necessary to ensure native handles don't leak, and that a user could use `FinalizationRegistry` to do the same. I worded it too strongly to expect that to always be the case, and that the outcome should be resource cleanup rather than a warning message like as what can happen for unhandled promise rejections. That wording was based on my prior experience with C#'s `IDisposable` and the C# team's recommendations to do likewise.

[03:25:24.0264] <Bradford Smith>
> <@rbuckton:matrix.org> Yes, a user-defined implementation could conceivably make `[Symbol.dispose]` a getter that indicates the method was at least read.

Personally, I think you're chasing an impossible goal here. The Explicit Resource Management proposal as-is provides a useful feature. There's no need to try so hard to force its correct use. Leave that problem for another day. Just my $0.02.

[03:26:04.0982] <rbuckton>
> <@aclaymore:matrix.org> sorry, `move`

`move` and `exit` are somewhat orthogonal to each other, so I'm not clear on the correlation you are making?

[03:28:55.0303] <rbuckton>
> <@bradfordcsmith:matrix.org> Personally, I think you're chasing an impossible goal here. The Explicit Resource Management proposal as-is provides a useful feature. There's no need to try so hard to force its correct use. Leave that problem for another day. Just my $0.02.

I concur. JavaScript itself can't reliably enforce lifetimes and ownership in the same way a language like Rust can, as that essentially requires a fully-baked runtime type system. Without that, we would be forced to take a major performance hit for every `var`/`let`/`const` declaration and every assignment to check or transfer ownership of an object's lifetime, which is a non-starter.

[03:29:21.0151] <Ashley Claymore>
for the examples where code is switching if the exit was a throw or return completion. Reaching DisposeStack.p.move also indicates that 

[03:29:28.0113] <Ashley Claymore>
* can also indicate that 

[03:29:36.0049] <rbuckton>
I'm not convinced we even need `[Symbol.enter]()`.

[03:29:59.0588] <rbuckton>
> <@aclaymore:matrix.org> for the examples where code is switching if the exit was a throw or return completion. Reaching DisposeStack.p.move also indicates that

Ah, thank you for the clarification.

[03:32:41.0219] <rbuckton>
> <@rbuckton:matrix.org> I concur. JavaScript itself can't reliably enforce lifetimes and ownership in the same way a language like Rust can, as that essentially requires a fully-baked runtime type system. Without that, we would be forced to take a major performance hit for every `var`/`let`/`const` declaration and every assignment to check or transfer ownership of an object's lifetime, which is a non-starter.

In a way, `DisposableStack.p.move` is a close approximation of Rust's `move` semantics as a way to "transfer ownership on assignment" similar to an affine type system, but in an imperative form:
```js
const stack1 = new DisposableStack();
...
const stack2 = stack1.move(); // stack1 can no longer be used, its contents have been moved to stack2.
...
const stack3 = stack2.move(); // stack2 can no longer be used, its contents have been moved to stack3.
```

[03:33:07.0184] <rbuckton>
(which is part of the reason for the choice of method name as well)

[03:34:09.0148] <rbuckton>
> <@rbuckton:matrix.org> I concur. JavaScript itself can't reliably enforce lifetimes and ownership in the same way a language like Rust can, as that essentially requires a fully-baked runtime type system. Without that, we would be forced to take a major performance hit for every `var`/`let`/`const` declaration and every assignment to check or transfer ownership of an object's lifetime, which is a non-starter.

 * In a way, `DisposableStack.p.move` is a close approximation of Rust's `move` semantics as a way to "transfer ownership on assignment" similar to an affine type system, but in an imperative form:

```js
using stack1 = new DisposableStack();
...
using stack2 = stack1.move(); // stack1 can no longer be used, its contents have been moved to stack2.
...
using stack3 = stack2.move(); // stack2 can no longer be used, its contents have been moved to stack3.
```

[04:01:49.0293] <littledan>
> <@rbuckton:matrix.org> I'm not convinced we even need `[Symbol.enter]()`.

I agree. But if we did want to go in that direction, I think we should retract this proposal to Stage 2, as it's a big change and we don't have a concrete form of this yet.

[04:02:02.0069] <littledan>
I think we should conclude that we're not going in this Symbol.enter direction

[04:02:56.0606] <littledan>
this is just a very big thing to be considered an open question for a Stage 3 proposal

[04:05:24.0149] <rbuckton>
> <@littledan:matrix.org> I think we should conclude that we're not going in this Symbol.enter direction

nicolo-ribaudo's suggestion to make `[Symbol.dispose]` a getter if you want to opt-in to requiring the use of `using` or a `DisposableStack` holds water and may be satisfactory, without the need to introduce a new symbol-named method to the Disposable protocol: https://github.com/tc39/proposal-explicit-resource-management/issues/159#issuecomment-1630532470

[04:25:02.0382] <Michael Ficarra>
it's so strange to me that IETF would explicitly *not* want to support sub-minute offsets

[04:25:21.0014] <Michael Ficarra>
it just feels like painting yourself into a corner for no good reason

[04:25:51.0665] <shu>
be the change you want to see in the world

[04:26:05.0419] <shu>
do you want sub-minute offset timezone in the world

[04:26:17.0593] <Michael Ficarra>
I am not a politician, I do not get to decide that

[04:26:22.0208] <ryzokuken üá≥üá¥>
they considered it vestigial and unnecessary

[04:26:29.0086] <ryzokuken üá≥üá¥>
 * they considered it vestigial and unnecessary moving forwards

[04:26:36.0713] <bakkot>
if all the computer people collectively refuse to implement support for it, what are the politicians gonna do?

[04:26:41.0899] <ryzokuken üá≥üá¥>
fwiw, the ISO format still accepts all sorts of input

[04:26:43.0352] <Michael Ficarra>
I would not be at all surprised if the DPRK changed their timezone (again) to a sub-minute offset

[04:26:46.0519] <bakkot>
the time is whatever my phone tells me it is, not what a politician announces

[04:26:48.0902] <ryzokuken üá≥üá¥>
but IETF prefers to maintain a leaner profile

[04:27:10.0009] <shu>
> <@michaelficarra:matrix.org> I am not a politician, I do not get to decide that

you sell yourself short dear mr ficarra

[04:27:18.0144] <Michael Ficarra>
bakkot: the DPRK makes their own OS

[04:27:31.0189] <shu>
i too skinned Linux when i was 10

[04:28:09.0018] <ryzokuken üá≥üá¥>
> <@michaelficarra:matrix.org> bakkot: the DPRK makes their own OS

I really wanted to respond but this isn't TDZ üòõ 

[04:28:55.0537] <shu>
yes, the limitation of being unhinged and deranged about time zones

[04:51:38.0020] <ptomato (at TC39, limited availability)>
FWIW, `Asia/Pyongyang` could still have a sub-minute offset. the limitation doesn't apply to named time zones

[04:54:17.0596] <ryzokuken üá≥üá¥>
Yes, this only applies to in-timestamp offsets

[04:59:40.0555] <littledan>
I think the details of whether engines ship the Intl-only part separately or just together with Intl is something that we can leave to engines to decide. If an engine expects to take a really long time to do Temporal, they might do the Intl-only part. But Temporal should only ship with this included, and it'd be valid to ship at the same time. Within this, I think 2a would be the simplest way to organize the explanations.

[05:02:47.0075] <littledan>
> <@littledan:matrix.org> I think the details of whether engines ship the Intl-only part separately or just together with Intl is something that we can leave to engines to decide. If an engine expects to take a really long time to do Temporal, they might do the Intl-only part. But Temporal should only ship with this included, and it'd be valid to ship at the same time. Within this, I think 2a would be the simplest way to organize the explanations.

err, never mind--I'm convinced by what Shu and Justin said, about how missing the .equals method is fatal for shipping separately

[05:05:04.0393] <shu>
sffc: no we can't implement the non-temporal parts sooner

[05:05:11.0432] <shu>
because of what dan just said

[05:09:10.0194] <sffc>
It still seems like we should stop returning Saigon and Kiev despite the lack of a Temporal.TimeZone.prototype.equals

[05:10:08.0107] <ptomato (at TC39, limited availability)>
that's what I was getting at, but I take Shu's point that that causes interoperability problems

[05:11:45.0978] <bakkot>
I do like this proposal but I still wish we had `import program from 'source.wasm' with { imports: whatever, memory: new ArrayBuffer(1000) }` etc

[05:12:38.0521] <bakkot>
instead of needing to import the source and then compile it yourself

[05:12:41.0274] <bakkot>
that's just kinda silly

[05:12:46.0366] <shu>
is that a static import with a `new ArrayBuffer`

[05:12:51.0341] <shu>
how does that work

[05:12:52.0202] <nicolo-ribaudo>
> <@bakkot:matrix.org> I do like this proposal but I still wish we had `import program from 'source.wasm' with { imports: whatever, memory: new ArrayBuffer(1000) }` etc

Evaluating expressions even before linking the modiule graph seems... hard

[05:13:12.0160] <nicolo-ribaudo>
> <@bakkot:matrix.org> I do like this proposal but I still wish we had `import program from 'source.wasm' with { imports: whatever, memory: new ArrayBuffer(1000) }` etc

 * Evaluating expressions even before linking the module graph seems... difficult

[05:13:35.0779] <bakkot>
you do the downloading and so on right away but don't do the actual instantiation until you hit the `import` declaration

[05:13:39.0066] <bakkot>
this does not seem hard to me?

[05:14:25.0720] <sffc>
> <@pchimento:igalia.com> that's what I was getting at, but I take Shu's point that that causes interoperability problems

ok, sorry for my misunderstanding

[05:14:46.0733] <nicolo-ribaudo>
And you cannot capture bindings from outside the import declaration? i.e.

```js
let buf = new ArrayBuffer()
import program from 'source.wasm' with { memory: buf } 
```

[05:15:27.0104] <bakkot>
no I am imagining that would work as written

[05:15:34.0819] <bakkot>
don't see why it shouldn't

[05:15:36.0398] <nicolo-ribaudo>
That could work with CJS where modules are evaluated before their dependencies, but with ESM `buf` does not exist until when all the imported modules are evaluated

[05:15:57.0130] <bakkot>
there are multiple notions of "evaluated" wrt wasm

[05:16:38.0994] <bakkot>
the obvious thing for it to do is to download the thing but not actually instantiate until you hit the import declaration, at which point `buf` is available

[05:16:57.0949] <shu>
what is "hit the import declaration"

[05:17:16.0348] <bakkot>
like, get to that line in the program

[05:17:17.0321] <Michael Ficarra>
evaluation semantics for an ImportDeclaration

[05:18:16.0737] <shu>
the import declaration is just parsed and collected and processed ahead of time right now, it's not even in the compiled AST

[05:18:20.0578] <shu>
i don't think import has evaluation does it

[05:18:31.0659] <shu>
like we could add it but that seems a radical departure from what it does right now

[05:18:48.0162] <shu>
 * the import declaration is just parsed and collected and processed ahead of time right now, it's not even in the AST sent to the compiler

[05:18:56.0784] <nicolo-ribaudo>
Also, import declarations are hoisted. Capturing from inside them has the same problems discussed for function declaration decorators

[05:19:06.0607] <bakkot>
to be clear I am not super-seriously proposing this

[05:19:17.0483] <bakkot>
I agree the hoisting is annoying technically

[05:19:28.0278] <bakkot>
however, no real program relies on hoisting import declarations, because that's batshit

[05:19:29.0807] <nicolo-ribaudo>
Also to be clear, I also hope we'll have direct imports for wasm one day

[05:19:47.0291] <bakkot>
so it still feels like the code sample above should just work as written

[05:20:03.0047] <ljharb>
hm, can you `class extends AbstractModuleSource { }` if it's not constructable or callable?

[05:20:13.0416] <shu>
i don't understand the spec draft as written

[05:20:14.0554] <littledan>
if you use direct Wasm imports, then that Wasm module can import a memory from a different ESM module that explicitly constructs it.

[05:20:16.0379] <bakkot>
> <@bakkot:matrix.org> however, no real program relies on hoisting import declarations, because that's batshit

(hoisting in the function declaration sense, that is)

[05:20:19.0578] <nicolo-ribaudo>
> <@ljharb:matrix.org> hm, can you `class extends AbstractModuleSource { }` if it's not constructable or callable?

Yes but you cannot then call `super()`

[05:20:39.0739] <shu>
> (hoisting in the function declaration sense, that is)
really? you don't write mutually recursive functions?

[05:20:47.0656] <shu>
 * > (hoisting in the function declaration sense, that is)

really? you don't write mutually recursive functions?

[05:21:00.0981] <ljharb>
> <@nicolo-ribaudo:matrix.org> Yes but you cannot then call `super()`

ok so there's no way for a subclass to get the internal slot in a self-hosted-in-JS implementation?

[05:21:10.0502] <nicolo-ribaudo>
> <@shuyuguo:matrix.org> > (hoisting in the function declaration sense, that is)
> 
> really? you don't write mutually recursive functions?

Well, you don't write mutually recursive imports

[05:21:21.0031] <shu>
oh i misunderstood the point

[05:21:34.0201] <shu>
not that nobody relies on the hoisting function semantics, but the hoisting import semantics that are like the hoisting function semantics

[05:21:36.0090] <littledan>
It's pretty common to use function hoisting in a sillier way, like

```js
foo.onbar = fn;
function fn() { }
```

In fact, fear of breaking this particular pattern is what's holding back function decorators

[05:21:51.0062] <bakkot>
> <@shuyuguo:matrix.org> not that nobody relies on the hoisting function semantics, but the hoisting import semantics that are like the hoisting function semantics

right exactly

[05:21:54.0218] <littledan>
> <@shuyuguo:matrix.org> not that nobody relies on the hoisting function semantics, but the hoisting import semantics that are like the hoisting function semantics

anyway yes this is how import statements work

[05:22:21.0767] <bakkot>
concretely, no one writes an `import` declaration at the bottom of a file and code which runs right away which uses a binding from the `import` at the top of the file

[05:22:22.0907] <Michael Ficarra>
nicolo-ribaudo: it shouldn't unconditionally throw, it should just throw if it's its own NewTarget

[05:22:54.0128] <shu>
i think the current spec draft is just wrong about the abstract constructor thing

[05:22:59.0819] <Michael Ficarra>
https://github.com/tc39/ecma262/pull/3094#discussion_r1230304753

[05:23:01.0666] <nicolo-ribaudo>
(I need to look at the proposal spec before answering to that)

[05:23:02.0403] <shu>
it's unconditionally throwing now but the comment suggests otherwise

[05:23:16.0136] <littledan>
> <@shuyuguo:matrix.org> it's unconditionally throwing now but the comment suggests otherwise

This is resolved by the Wasm subclass behavior

[05:23:28.0229] <shu>
how can you resolve that in the subclass behavior

[05:23:52.0796] <shu>
what installs the brand?

[05:23:58.0826] <littledan>
the cyclic module record superclass throws; the wasm module subclass does another thing

[05:24:11.0493] <littledan>
it's installed when parsing the Wasm module, by construction

[05:24:12.0201] <rbuckton>
> <@littledan:matrix.org> It's pretty common to use function hoisting in a sillier way, like
> 
> ```js
> foo.onbar = fn;
> function fn() { }
> ```
> 
> In fact, fear of breaking this particular pattern is what's holding back function decorators

sillier? This is a common practice in the TS codebase, i.e.:
```ts
function createFoo() {
  const quxx = ...;

  return {
    bar,
    baz,
  };

  function bar() { ... }
  function baz() { ... }
}
```

[05:24:23.0473] <littledan>
> <@rbuckton:matrix.org> sillier? This is a common practice in the TS codebase, i.e.:
> ```ts
> function createFoo() {
>   const quxx = ...;
> 
>   return {
>     bar,
>     baz,
>   };
> 
>   function bar() { ... }
>   function baz() { ... }
> }
> ```

sorry I shouldn't've included a value judgement

[05:24:25.0924] <shu>
littledan: i don't understand. happy to see spec text though

[05:24:54.0723] <littledan>
shu: https://webassembly.github.io/esm-integration/js-api/index.html#get-module-source

[05:25:09.0966] <shu>
how does that interface with %AbstractModuleSource%

[05:25:42.0504] <nicolo-ribaudo>
It sets the internal slot in step 4 of https://webassembly.github.io/esm-integration/js-api/index.html#construct-a-webassembly-module-object

[05:25:53.0020] <littledan>
(oops sorry I was answering the wrong question)

[05:26:05.0437] <bakkot>
someone is typing loudly again

[05:26:19.0464] <nicolo-ribaudo>
However yes, there is no way for JS code to create objects with that internal slot with the current spec (@ljharb)

[05:26:23.0324] <nicolo-ribaudo>
> <@bakkot:matrix.org> someone is typing loudly again

Sorry, me

[05:26:24.0134] <ljharb>
that seems like a problem

[05:26:49.0912] <littledan>
> <@bakkot:matrix.org> someone is typing loudly again

did it stop for you?

[05:26:53.0920] <nicolo-ribaudo>
Do y'all think that throwing only if constructed directly would be an acceptable solution?

[05:27:07.0450] <ljharb>
that works for me

[05:27:11.0211] <nicolo-ribaudo>
> <@nicolo-ribaudo:matrix.org> Do y'all think that throwing only if constructed directly would be an acceptable solution?

(I do not remember why we throw)

[05:27:13.0447] <ljharb>
 * that works for me, based on new.target or something

[05:27:15.0532] <bakkot>
> <@littledan:matrix.org> did it stop for you?

it has stopped now yes

[05:28:06.0095] <Michael Ficarra>
nicolo-ribaudo: yes, that is what we suggested here: https://github.com/tc39/ecma262/pull/3094#discussion_r1230304753

[05:28:48.0752] <nicolo-ribaudo>
I'm trying to find references as to why we introduced the throwing behavior in the first place

[05:29:27.0069] <littledan>
if there's no JS-exposed API for setting that internal brand slot (e.g., a super constructor parameter), then the constructor isn't very useful

[05:29:32.0848] <littledan>
whether or not it throws

[05:30:01.0191] <ljharb>
hm, that is true

[05:30:12.0103] <ljharb>
it seems important to be able to self-host in JS tho

[05:30:34.0546] <littledan>
to me this feels like something that's OK to unconditionally throw "for now" with a hope that we expand this out soon (maybe in the context of compartments)

[05:31:07.0558] <nicolo-ribaudo>
> <@ljharb:matrix.org> it seems important to be able to self-host in JS tho

Without custom module loading you cannot self-host modules anyway

[05:31:28.0024] <ljharb>
you could with on-the-fly source rewriting, no?

[05:31:40.0321] <littledan>
"instantiable" would be a name reflecting intuition? I think this sounds just vaguely computer-y.

[05:31:43.0042] <ljharb>
 * you could with on-the-fly source rewriting, no? i don't mean virtualization which indeed would require custom module loading

[05:32:21.0074] <Michael Ficarra>
I don't like any of these new name suggestions

[05:32:28.0165] <Michael Ficarra>
the exiting names are fine

[05:32:37.0037] <littledan>
> <@ljharb:matrix.org> you could with on-the-fly source rewriting, no? i don't mean virtualization which indeed would require custom module loading

If you're rewriting source, why do you care about using a real source object at all?

[05:32:41.0845] <Michael Ficarra>
 * the existing names are fine

[05:32:46.0999] <Ashley Claymore>
'source' is much easier to write and spell than 'instantiable'

[05:33:00.0024] <ljharb>
> <@littledan:matrix.org> If you're rewriting source, why do you care about using a real source object at all?

because user code would still need to interact with the resulting source phase object

[05:33:23.0352] <littledan>
sorry, which sorts of interactions are you picturing?

[05:33:37.0807] <danielrosenwasser>
> <@aclaymore:matrix.org> 'source' is much easier to write and spell than 'instantiable'

The good news is this is a power-user feature with a keyword that can get auto-completed

[05:34:21.0336] <Michael Ficarra>
importing and using wasm is power user now?

[05:34:23.0786] <ljharb>
> <@littledan:matrix.org> sorry, which sorts of interactions are you picturing?

anything that's observable. i don't have a use case except that a self-hosted implementation should be able to be made indistinguishable from a C++ one

[05:34:36.0575] <littledan>
> <@michaelficarra:matrix.org> importing and using wasm is power user now?

when linking it yourself? yes, I think so

[05:34:37.0237] <ljharb>
since when has it not been

[05:34:50.0142] <Ashley Claymore>
I wish writing code snippets in non-IDES have auto-complete

[05:35:00.0519] <Ashley Claymore>
 * I wish writing code snippets in non-IDEs had auto-complete

[05:36:09.0432] <Bradford Smith>
I find "instantiable" even less understandable than "source".

[05:36:39.0186] <danielrosenwasser>
What's your definition of an IDE? Even notepad++ has auto-complete for JavaScript :D

[05:36:48.0188] <danielrosenwasser>
 * What's your definition of a non-IDE? Even notepad++ has auto-complete for JavaScript :D

[05:36:51.0861] <Michael Ficarra>
apparently I don't understand the limits of the average developer nowadays

[05:36:55.0201] <Ashley Claymore>
Matrix

[05:36:58.0320] <Ashley Claymore>
github

[05:37:02.0495] <Ashley Claymore>
Slack

[05:37:07.0899] <Ashley Claymore>
Whatsapp

[05:37:12.0647] <bakkot>
not convinced you ever did

[05:37:15.0067] <Ashley Claymore>
 * Whatsapp ;)

[05:37:32.0966] <shu>
i'm surprised but point taken

[05:37:37.0345] <Michael Ficarra>
Twitter bio

[05:37:39.0915] <danielrosenwasser>
If someone judges you for a code typo in Whatsapp please let me yell at them

[05:37:43.0012] <Ashley Claymore>
Threads?

[05:37:44.0299] <bakkot>
that said it is getting less and less power-user-y as it becomes a more first-class target in languages like go and rust

[05:37:48.0014] <shu>
(like, what do you think you want to do with the thing you get from this phase, if not to instantiate it later?)

[05:37:48.0137] <ryzokuken üá≥üá¥>
no JS in Whatsapp please

[05:37:52.0358] <danielrosenwasser>
JavaScript doesn't have threads

[05:38:06.0188] <ryzokuken üá≥üá¥>
does Threads have JS tho?

[05:38:13.0760] <ryzokuken üá≥üá¥>
sorry, I'll show myself out

[05:38:24.0087] <nicolo-ribaudo>
> <@shuyuguo:matrix.org> (like, what do you think you want to do with the thing you get from this phase, if not to instantiate it later?)

Well, with WebAssembly.Module you might do reflection and nothing else

[05:38:25.0666] <danielrosenwasser>
Probably only in a bytecode format nowadays

[05:38:40.0907] <danielrosenwasser>
 * Probably only in Hermes' bytecode format nowadays

[05:38:43.0503] <nicolo-ribaudo>
But yes, you would almost always want to instantiate it

[05:38:50.0504] <shu>
i don't get what that means, you just want to hold on to it?

[05:38:51.0983] <Michael Ficarra>
I think ljharb is saying the opposite?

[05:38:55.0461] <ryzokuken üá≥üá¥>
HHVM for JS

[05:39:09.0679] <nicolo-ribaudo>
WebAssembly.Module.imports() or exports()

[05:39:14.0699] <Ashley Claymore>
https://nodejs.org/api/worker_threads.html#workerismainthread

[05:39:24.0059] <nicolo-ribaudo>
 * WebAssembly.Module.imports() or .exports()

[05:39:25.0714] <Michael Ficarra>
as it gets support in languages targeting wasm, using it manually becomes more niche

[05:39:27.0939] <Ashley Claymore>
how can their be a main thread if there are no threads......

[05:39:31.0195] <ryzokuken üá≥üá¥>
it's part of the host, not JS

[05:39:31.0665] <Ashley Claymore>
:D

[05:39:34.0770] <danielrosenwasser>
`import reflectable`

[05:39:39.0497] <ryzokuken üá≥üá¥>
üôà

[05:39:46.0913] <ryzokuken üá≥üá¥>
I'm bad at jokes

[05:40:05.0433] <Andreu Botella>
`import sourceable`

[05:40:23.0709] <danielrosenwasser>
No, you're doing good here by backing *my* joke  ryzokuken üá≥üá¥ ,

[05:40:34.0426] <danielrosenwasser>
`import saucable`

[05:40:39.0632] <danielrosenwasser>
oh no

[05:40:44.0143] <danielrosenwasser>
`import sauceable`?

[05:40:44.0445] <ryzokuken üá≥üá¥>
I think I'm old enough to start writing my own jokes eventually

[05:40:48.0014] <eemeli>
`import raw`

[05:41:01.0033] <Bradford Smith>
`import uninstantiated`?

[05:41:09.0488] <Michael Ficarra>
this is not TDZ

[05:41:12.0498] <Andreu Botella>
`import saukable`

[05:41:14.0670] <shu>
uninstantiated is fine but how is that worse than instantiable?

[05:41:22.0269] <ljharb>
i would argue that usage of "not JS" to interoperate directly with JS is still a power user thing

[05:41:34.0435] <ryzokuken üá≥üá¥>
> <@eemeli:mozilla.org> `import raw`

that could work actually

[05:41:36.0069] <bakkot>
"uninstantiated" is at least a word I have literally ever used before

[05:41:44.0122] <ljharb>
a word can be more precise and yet worse ergonomically

[05:41:47.0561] <bakkot>
"raw" sounds more like asset/blob/bytes to me

[05:41:59.0220] <danielrosenwasser>
But how often is this word getting typed out?

[05:41:59.0740] <Bradford Smith>
An "uninstantiated module" makes sense to me more than "instantiable module"

[05:42:15.0251] <ljharb>
 * i would argue that usage of "not JS" to interoperate directly with JS is still a power user thing, and will likely remain so for the foreseeable future

[05:42:52.0451] <ljharb>
> <@danielrosenwasser:matrix.org> But how often is this word getting typed out?

hopefully often enough to warrant this proposal advancing

[05:45:09.0747] <bakkot>
I think for JS developers, yes

[05:45:27.0048] <ljharb>
what are the "phases" identified for modules during this process? like what comes after "source"

[05:45:35.0152] <bakkot>
but if you are a Go programmer, you are going to want to write Go, and then a small JS wrapper to let the Go program interact with the webapp

[05:45:42.0015] <shu>
`raw` is worse than `source` for the same confusion, yeah

[05:45:51.0136] <bakkot>
and the way you do that is, you compile the Go to wasm, and then import the wasm from a JS module

[05:45:55.0690] <littledan>
honestly `import compiled` captures things well for Wasm (or `import parsed`??), but I'm not sure if it will be intuitive.

[05:45:59.0504] <bakkot>
this does not require being a poweruser of either language

[05:46:13.0906] <danielrosenwasser>
I was going to make a `String.raw` joke but Michael Ficarra  said this wasn't TDZ

[05:46:16.0680] <Andreu Botella>
I guess some people might think that it AOT-compiles the module code for JS?

[05:46:30.0096] <Andreu Botella>
 * I guess some people might think that `import compiled` AOT-compiles the module code for JS?

[05:47:11.0729] <bakkot>
do we imagine using this for things other than wasm

[05:47:17.0378] <Michael Ficarra>
no one is stopping you from making terrible jokes in TDZ

[05:47:18.0671] <bakkot>
if not, can we just make it `import.wasm`

[05:47:35.0141] <danielrosenwasser>
My impression is that the anticipated frequency of use is not the reason why this proposal exists - moreso, it's a small set of important use-cases that compose well

[05:47:39.0809] <nicolo-ribaudo>
> <@bakkot:matrix.org> do we imagine using this for things other than wasm

KKL has a proposal for JS sources

[05:47:57.0460] <nicolo-ribaudo>
To do reflection on them, as well as custom linking

[05:48:02.0875] <bakkot>
ah, right

[05:48:11.0560] <bakkot>
and to bypass CSP I guess

[05:48:21.0523] <bakkot>
 * and to avoid running afoul of CSP I guess

[05:48:35.0319] <danielrosenwasser>
> <@danielrosenwasser:matrix.org> My impression is that the anticipated frequency of use is not the reason why this proposal exists - moreso, it's a small set of important use-cases that compose well

Which is why "pick the most explicit name" seems like the right option for me

[05:48:35.0577] <nicolo-ribaudo>
Yep, to avoid eval-like

[05:48:55.0942] <danielrosenwasser>
> <@danielrosenwasser:matrix.org> My impression is that the anticipated frequency of use is not the reason why this proposal exists - moreso, it's a small set of important use-cases that compose well

 * Which is why "pick the most explicit name" seems like the right option for me, even if it's a little verbose

[05:49:12.0365] <danielrosenwasser>
But `import source` is still better than `import module`

[05:49:16.0069] <bakkot>
that suggests maybe `import.reflect`?

[05:49:42.0908] <Michael Ficarra>
please, source is fine üò©

[05:49:44.0113] <bakkot>
though I guess reflection might suggest also evaluation

[05:50:06.0792] <nicolo-ribaudo>
> <@bakkot:matrix.org> that suggests maybe `import.reflect`?

I think this was the original world in the proposal, but there are two use cases (custom instantiation and reflection) and it only covers one

[05:50:07.0925] <Rob Palmer>
`import fetched`

[05:50:31.0529] <bakkot>
`fetched` also suggests just raw bytes to me

[05:50:50.0992] <shu>
maybe the answer is there is just no intuition for half-processed things having names

[05:51:00.0002] <Rob Palmer>
`import parsed`

[05:51:05.0383] <nicolo-ribaudo>
> <@shuyuguo:matrix.org> maybe the answer is there is just no intuition for half-processed things having names

`import half mod from "x"`

[05:51:31.0425] <shu>
`parsed` i can live with but wasm isn't parsed but validated?

[05:51:47.0933] <bakkot>
validation is like parsing

[05:51:50.0596] <nicolo-ribaudo>
`analyzed`

[05:51:51.0074] <shu>
yeah

[05:51:57.0168] <shu>
`parsed` sgtm

[05:52:01.0612] <shu>
who hates `parsed`

[05:52:09.0274] <shu>
who hates the truth

[05:52:09.0736] <bakkot>
I could live with `parsed`

[05:52:32.0302] <nicolo-ribaudo>
What I dislike about it is that also a fully evaluated module has been parsed

[05:52:47.0788] <Michael Ficarra>
yeah but it's "only" parsed

[05:52:51.0048] <bakkot>
a fully evaluated module has also been source though

[05:52:56.0289] <shu>
yeah, pragmatics!!

[05:53:13.0034] <shu>
implicatures, specifically

[05:53:44.0146] <bakkot>
love me a gricean implicature


[05:54:05.0311] <Jesse (TC39)>
ooh grice fans

[05:54:54.0927] <Chris de Almeida>
we do have some time available tomorrow if folks would like to have further discussion regarding source phase imports naming

[05:55:09.0356] <Jesse (TC39)>
the Racket programming language uses "syntax" to refer to data that has been parsed -- ranging from simple expressions like `42` to entire modules -- but not yet evaluated

[05:56:02.0382] <shu>
that's in the context of macros

[05:56:22.0439] <shu>
in that there's a unified representation they manipulate

[05:56:29.0607] <shu>
whereas the thing we're getting is just kinda abstract

[05:56:56.0813] <Chris de Almeida>
> <@danielrosenwasser:matrix.org> `import sauceable`?

I would unironically support `sauce`

[05:57:13.0953] <Andreu Botella>
<del>`import abstract mod from "paper.js";`</del>

[05:57:19.0923] <bakkot>
> <@softwarechris:matrix.org> I would unironically support `sauce`

that would be so confusing as an english language learner

[05:57:33.0963] <Chris de Almeida>
fair

[05:57:39.0942] <bakkot>
> <@softwarechris:matrix.org> we do have some time available tomorrow if folks would like to have further discussion regarding source phase imports naming

maybe come back and see if `import parsed` is amenable to everyone?

[05:59:18.0974] <bakkot>
> <@shuyuguo:matrix.org> `parsed` i can live with but wasm isn't parsed but validated?

also since it gives you a different representation than the input I think it is in fact parsed rather than validated?

[05:59:30.0673] <shu>
bakkot: okay i'm convinced

[05:59:35.0450] <bakkot>
at least according to the taxonomy of https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/

[05:59:48.0634] <shu>
also just polled internally

[05:59:55.0488] <shu>
V8 can live with `parsed`

[06:00:31.0299] <bakkot>
how did you conduct a representative sample poll at 6am

[06:00:37.0372] <bakkot>
I guess v8 is mostly in munich, nvm

[06:01:55.0877] <Christian Ulbrich>
TCQ pretty rough... -> https://github.com/ChristianUlbrich/tcq/tree/contemporary-edition I split into three packages and decided that it is not worthwhile to get the old stuff to working, so I am just porting the client to contemporary Vue...

[06:02:29.0253] <Christian Ulbrich>
Hope I have the client ported by the end of the day, what I am seeing is "special" to say the least, bust one step at a time...

[06:05:49.0422] <Chris de Almeida>
sorcery!

[06:06:02.0140] <Chris de Almeida>
> <@bakkot:matrix.org> maybe come back and see if `import parsed` is amenable to everyone?

guybedford: Luca Casonato some folks here signaling it may be useful to spend some time tomorrow.  thoughts?

[06:06:26.0393] <eemeli>
If we change to something else from `import source`, should/will the "module source" references in the proposal also be updated?

[06:08:04.0832] <ljharb>
probably yes

[06:08:15.0512] <Jesse (TC39)>
ChatGPT ought to be able to suggest some terms

[06:14:13.0652] <shu>
eemeli: IMO that's not important at all

[06:14:22.0106] <shu>
it's not going to be an uttered name really

[06:15:16.0153] <ljharb>
when the proposal for JS ModuleSource objects arrives, that part will be

[06:15:48.0819] <eemeli>
shu: Not sure that I agree. We still need a generic name for the thing you get from this statement.

[06:16:25.0675] <shu>
sure, you need a name, but it's not a thing that developers are going to be typing, so i think any name is fine, really

[06:16:43.0041] <shu>
_once_ the JS module thing itself exists, that might be typed, and we should be more careful about that

[06:40:56.0091] <Luca Casonato>
https://github.com/tc39/proposal-source-phase-imports/issues/53

[06:41:05.0566] <yulia | Back in October>
> <@shuyuguo:matrix.org> i understand Yulia's original claim to be "ESM performance story is not viable without this feature"

<still on leave, may not be able to actually answer here later> I wouldn't say it isn't viable, a code base can be entirely rewritten just for performance gains, at the cost of developing new features etc. But what we have found is that the rewriting of applications is unrealistic, and this stops people from moving to modules all together. 

[06:42:01.0747] <littledan>
whoa Yulia is here! I just want to take this opportunity to thank you for organizing the meeting here in Bergen. It's a beautiful city and great to meet this very relevant and insightful academic research group.

[06:42:22.0962] <yulia | Back in October>
oh that is lovely to hear! i hope we can work more with the community there, they are very excited about tc39

[06:43:11.0923] <littledan>
> <@yulia:mozilla.org> oh that is lovely to hear! i hope we can work more with the community there, they are very excited about tc39

Yes, I hope so too. Talking to them, I think they didn't realize that they were actual TC39 members and can participate as delegates if they want, not just observe. I think there's a big opportunity for collaboration

[06:43:31.0668] <ryzokuken üá≥üá¥>
I talked about some folks from the uni about this earlier

[06:44:02.0837] <yulia | Back in October>
Mikhail Barash is really great to work with, I've really enjoyed collaborating with the students at Bergen. Would love to join myself next year if we can do a plenary there again. 

[06:44:15.0500] <yulia | Back in October>
my overlord is calling, i have to run.

[06:44:16.0985] <ryzokuken üá≥üá¥>
Hoping we can improve our relationships with all of our researcher colleagues and utilize academic techniques to analyze proposals in addition to everything we do now

[06:44:48.0986] <yulia | Back in October>
enjoy the plenary everyone!

[06:48:07.0455] <yulia | Back in October>
> <@shuyuguo:matrix.org> i understand Yulia's original claim to be "ESM performance story is not viable without this feature"

 * \<still on leave, may not be able to actually answer here later> I wouldn't say it isn't viable, thats maybe too broad. a web code base can be entirely rewritten just for performance gains, at the cost of developing new features etc. But what we have found is that the rewriting of applications is unrealistic, and this stops people from moving to modules all together. In addition, this doesn't work so well when we consider non-web js applications, such as a good portion of the FX codebase, where we cannot use loading techniques such as module-preload

[06:49:03.0157] <yulia | Back in October>
 * \<still on leave, may not be able to actually answer here later> I wouldn't say it isn't viable, thats maybe too broad. a web code base can be entirely rewritten just for performance gains, at the cost of developing new features etc. But what we have found is that the rewriting of applications is unrealistic, and this stops people from moving to modules all together. In addition, this doesn't work so well when we consider non-web js applications that share modules with web applications, such as a good portion of the FX codebase, where we cannot use loading techniques such as module-preload

[06:50:28.0689] <Michael Ficarra>
apparently NTSC framerate is defined as a ratio as well

[06:51:22.0523] <Andreu Botella>
We should push for a version of BigDecimal where 0.99999... != 1

[06:58:03.0501] <shu>
ugh the web zoom client like pauses the video if i background the tab i think

[06:58:05.0411] <shu>
and it can't recover

[06:58:36.0399] <ryzokuken üá≥üá¥>
the web zoom client is terrible 

[06:58:38.0038] <shu>
this wasn't happening as much yesterday

[06:58:45.0145] <ryzokuken üá≥üá¥>
but the app doesn't work on my computer üòÖ

[06:58:50.0448] <ryzokuken üá≥üá¥>
 * but the app doesn't work on my computer either üòÖ

[06:59:50.0889] <shu>
well i can't install it per corp policy...

[07:00:04.0408] <ljharb>
does corp policy let you use parallels?

[07:00:19.0992] <ljharb>
 * does corp policy let you use parallels? you could have a mac in your mac and install zoom on the guest mac

[07:00:23.0102] <shu>
do i want to install parallels

[07:01:40.0115] <ryzokuken üá≥üá¥>
(I know this is an unproductive discussion, sorry)

[07:06:57.0498] <Michael Ficarra>
dminor: they are talking about our proposed normalisation and omission if Infinity/NaN

[07:07:14.0265] <Michael Ficarra>
 * dminor: they are talking about our proposed normalisation and omission of Infinity/NaN

[07:07:21.0248] <littledan>
but it's Waldemar who wants normalization...

[07:07:26.0954] <littledan>
I think the coercion with numbers is just an error

[07:07:29.0790] <ryzokuken üá≥üá¥>
IEEE standards are paywalled?

[07:07:45.0708] <Michael Ficarra>
I am skeptical about the perf claims, there mostly isn't hardware acceleration for Decimal128 yet

[07:07:58.0391] <dminor>
Ok, so is this IEEE 754 decimal128 or not?

[07:07:58.0526] <Michael Ficarra>
so no matter what, you're implementing it using integer maths

[07:08:36.0216] <Michael Ficarra>
*mostly*

[07:09:25.0756] <ryzokuken üá≥üá¥>
but these implementations could improve perf over time as hardware acceleration crops up

[07:10:03.0881] <littledan>
dminor: Yes, the idea is that we'd use IEEE Decimal128

[07:10:57.0460] <Chris de Almeida>
> <@usharma:igalia.com> IEEE standards are paywalled?

yes...  are you looking for something?  `<laughs in hidden>`

[07:12:10.0509] <Michael Ficarra>
where did it say that decimals have object identity?

[07:13:22.0821] <shu>
it doesn't have operator overloading

[07:13:50.0892] <nicolo-ribaudo>
I thought the operator overloading discussion was about math operators

[07:14:01.0911] <shu>
=== is an operator

[07:14:34.0380] <nicolo-ribaudo>
Yeah for some reason I never realized it was part of that discussion

[07:14:36.0026] <ljharb>
oh oof, it wouldn't be a primitive?

[07:14:42.0939] <shu>
nope

[07:14:47.0596] <ljharb>
i don't see any point in doing a number system if it's not a primitive

[07:15:17.0518] <Michael Ficarra>
defining behaviour for `===` does not mean operator overloading

[07:15:33.0606] <Michael Ficarra>
operator overloading means deferring to some user code, no?

[07:15:45.0985] <chipmorningstar>
What about `+`?

[07:15:50.0120] <shu>
in this context it means overloading existing syntax operators

[07:15:55.0347] <Chris de Almeida>
It's dangerous to go alone!  Take this.

[07:15:57.0570] <shu>
not necessarily user code

[07:16:00.0196] <Michael Ficarra>
defining behaviour for maths operators does not mean operator overloading

[07:16:14.0515] <ljharb>
i also understand the term "operator overloading" to mean for user code

[07:16:19.0094] <shu>
the constraint from engines is we don't want to add new paths to operators

[07:16:27.0992] <shu>
what phrase should be used for that constraint?

[07:16:40.0439] <Rob Palmer>
"builtin operator overloading"

[07:16:42.0767] <ljharb>
that position effectively kills a bunch of useful proposals, including decimal, imo

[07:16:45.0921] <shu>
where operator includes all operators, `+` and `===` etc

[07:16:49.0485] <Michael Ficarra>
shu: no new primitives

[07:16:53.0347] <rbuckton>
there's a distinction between user-defined operator overloading and the fact that JS operators are overloaded. Currently they are overloaded based on type and coercion (i.e., string, number, bigint)

[07:17:08.0824] <ljharb>
if "no new primitives" is the stance from engines i'd love to see some kind of public statement to that effect

[07:17:24.0353] <ljharb>
because we need something to point the massive mob of angry JS devs to

[07:17:36.0263] <shu>
it's no new primitives unless vastly compelling

[07:17:50.0400] <Michael Ficarra>
then decimal is dead in the water

[07:17:52.0978] <shu>
if you publicize it it will be taken outside of context as a standalone fiat

[07:18:04.0840] <ljharb>
i don't understand how R&T and Decimal aren't both vastly compelling - if neither of those hit the bar then that's the same as "no new primitives"

[07:18:26.0219] <shu>
you and i disagree

[07:18:26.0646] <ljharb>
 * i don't understand how R&T and Decimal aren't both vastly compelling - if neither of those hit the bar then that's the same as "no new primitives" imo

[07:18:32.0055] <rbuckton>
My understanding is that the position of implementers regarding "no new primitives" is due to implementation complexity, not whether they would fit within the spec itself?

[07:19:00.0049] <shu>
it's complexity and performance in the engine itself, yes

[07:19:01.0435] <ljharb>
> <@shuyuguo:matrix.org> you and i disagree

that's fine, but i think it's important to get a sense from the wider JS community about this sort of thing

[07:19:06.0519] <Michael Ficarra>
we may as well pack up and go home, language is done folks

[07:19:12.0264] <ryzokuken üá≥üá¥>
"vastly compelling" always subjective. There's almost no public JS event I've been to where nobody was lamenting IEEE doubles.

[07:20:37.0326] <rbuckton>
> <@usharma:igalia.com> "vastly compelling" always subjective. There's almost no public JS event I've been to where nobody was lamenting IEEE doubles.

Hard to parse double negatives...do you mean to say "every public JS event I've been to there was always someone lamenting IEEE doubles"? or that no one is complaining about it?

[07:20:49.0525] <ryzokuken üá≥üá¥>
sorry, yes

[07:21:10.0189] <ryzokuken üá≥üá¥>
I meant that I'm almost bored of hearing people criticize how we do `Number`s

[07:21:20.0412] <Rob Palmer>
I'm assuming @ljharb is wondering how we can surface data for cases where significant developer demand exists, such that it would justify implementation burden that would otherwise be intolerable.  I don't think he is encouraging mass pile-ons and pitchforks.

[07:21:28.0463] <ljharb>
exactly that

[07:21:54.0254] <ljharb>
but also, there WILL be massive pileons and pitchforks if we hide the actual position of browsers behind TC39 notes

[07:21:54.0354] <shu>
we literally do not know how to get high-quality signal for web developers, the closest we come is scaled surveys

[07:22:07.0497] <ryzokuken üá≥üá¥>
I think the priority of constituencies is a reasonable solution

[07:22:09.0323] <Michael Ficarra>
well maybe a couple of pitchforks

[07:22:25.0702] <ljharb>
make a joint public statement from browsers saying decimals and R&T are effectively dead because "no new primitives" and why, and i suspect you will quickly get signal from web developers. whether it's high-quality is ofc another matter.

[07:22:49.0676] <Christian Ulbrich>
What amount of developer demand would convince an implementor, that an implementation is worth the burden?

[07:23:18.0247] <ljharb>
i would hope that's something an implementor feels obligated to answer

[07:23:43.0619] <Michael Ficarra>
even if we go by V8's statement yesterday about encouraging features that will make better user experiences, decimal is incredibly justified because web users will have better experiences when they get correct numeric results!

[07:27:13.0304] <shu>
> <@christianulbrich:matrix.org> What amount of developer demand would convince an implementor, that an implementation is worth the burden?

as i said yesterday, developer demand is not convincing in itself, but in a larger context it could add color. for example, if a proposal does not pose significant complexity (which is really about security) concerns, then developer demand tips the scale for me and V8 to support

[07:27:32.0164] <Bradford Smith>
"Do it in the backend" doesn't help if the backend is Node.js

[07:27:48.0349] <rbuckton>
This statement presupposes that "the backend" is not NodeJS and "the frontend" is not Electron

[07:29:33.0473] <Bradford Smith>
I may have missed this: Did the presentation include pointers to one or more known-good userland libraries for this?

[07:30:13.0807] <Michael Ficarra>
Bradford Smith: yes, the champion made one himself

[07:30:25.0668] <Michael Ficarra>
and linked to it from the slides

[07:30:44.0436] <dminor>
I don't question that this would be useful in node.js, but that doesn't convince me that this needs to baked into the language.

[07:30:47.0969] <Rob Palmer>
We have a huge amount of financial processing happening on the client-side.  Common untransformed data is multi-cast to many users with low-latency.  Lots of per-client per-window per-widget customized calculations happens on the client side.

[07:32:21.0133] <Bradford Smith>
> <@michaelficarra:matrix.org> Bradford Smith: yes, the champion made one himself

I'm not talking about a playground for the current proposal. I'

[07:32:33.0597] <Christian Ulbrich>
As I have stated before, we were using -> https://mikemcl.github.io/decimal.js/ - I do not care about IEEEEEE4673838 as a developer, I just want something that works‚Ñ¢, preferably from my good olde JS engine! :) 

[07:33:05.0064] <Bradford Smith>
> <@michaelficarra:matrix.org> Bradford Smith: yes, the champion made one himself

 * I'm not talking about a playground for the current proposal. I'm talking about a library used currently by applications to handle Decimal use-cases.

[07:33:09.0110] <littledan>
JS itself even has decimal processing on the client side (in Intl.NumberFormat, on strings when rounding options are used)

[07:33:18.0217] <ptomato (at TC39, limited availability)>
there's also http://mikemcl.github.io/big.js/ from the same author

[07:33:52.0814] <Bradford Smith>
OK, I see Christian's link

[07:34:01.0750] <ryzokuken üá≥üá¥>
> <@christianulbrich:matrix.org> As I have stated before, we were using -> https://mikemcl.github.io/decimal.js/ - I do not care about IEEEEEE4673838 as a developer, I just want something that works‚Ñ¢, preferably from my good olde JS engine! :)

while I empathize with the calls to stick to IEEE at all costs (and I believe we will), I'm afraid this view is representative of a majority of JS developers

[07:34:51.0723] <littledan>
I just don't understand the details of the claim that this proposal deviates from IEEE 754 decimal. I'd like to follow up on those in a more concrete way. The intention is to use IEEE 754.

[07:35:10.0317] <shu>
if we're going by developer anecdotes, i'd wager majority of js developers also just do not care about JS semantics either

[07:35:58.0256] <ryzokuken üá≥üá¥>
fair, but the point I'm trying to make is that there's a strong signal that this is really popular among users

[07:37:03.0054] <Michael Ficarra>
devs are going to think we're incompetent and out of touch if we tell them decimals are not sufficiently justified

[07:37:25.0955] <littledan>
https://github.com/whatwg/html/pull/9486

[07:37:45.0104] <shu>
Michael Ficarra: specifically do you mean "decimals as primitives"

[07:38:22.0645] <ljharb>
decimals you can use === and other basic operators with

[07:38:31.0981] <Michael Ficarra>
if we have decimals as non-primitives, they will just think they're clunky

[07:38:44.0362] <ljharb>
most JS devs won't care or necessarily know about primitives vs objects but they *will* care about all the things "being primitives" lets them do

[07:39:27.0097] <ljharb>
and without being primitives, what's the value over just using a library

[07:39:43.0766] <ljharb>
 * and without being primitives, what's the value over just using a library - "i don't have to install it" imo is far far weaker than "it's more ergonomic"

[07:39:47.0765] <shu>
so is that "yes" to my question?

[07:39:48.0040] <Michael Ficarra>
ljharb: literal syntax

[07:40:26.0745] <Michael Ficarra>
shu: no, I think they will have different, but still negative, feelings about us

[07:40:37.0720] <Christian Ulbrich>
@shu I think so, they need to be first-class citizen, i.e. Primitives, with everything that entails, I am afraid.

[07:41:12.0791] <shu>
our position stands, and i've articulated as our not being convinced against the complexity (security) and performance tradeoffs

[07:41:56.0719] <ljharb>
and what i asked was that that position be stated somewhere publicly, outside of tc39, so it can be cited when making proposal decisions

[07:42:09.0485] <ljharb>
 * and what i asked/suggested was that that position be stated somewhere publicly, outside of tc39, so it can be cited when making proposal decisions

[07:42:37.0876] <rbuckton>
I mean, how useful would it be to have actual integer primitives like `int8` , `int16`, `int32`, `uint32`, etc. with proper overflow checking? Current approaches to constrain values to a specific integer space are often complex, such that we end up needing to add static methods to `Math` for proper integer division because all we have is Number.

[07:42:41.0062] <ljharb>
 * and what i asked/suggested was that that position be stated somewhere publicly, outside of tc39, so it can be cited when making proposal decisions (for the benefit of the wider JS dev community)

[07:42:41.0163] <shu>
i am not a PR person, i am a standards person

[07:43:01.0157] <ljharb>
there is considerable overlap there, i suspect

[07:43:06.0778] <shu>
not for me

[07:43:28.0270] <ljharb>
i would hope for v8/chrome, though?

[07:43:39.0337] <shu>
to explain our standards positions to the general public? no

[07:43:44.0935] <ljharb>
wow, ok

[07:43:45.0454] <shu>
to explain our standards positions to stakeholders? yes

[07:43:46.0948] <ljharb>
that's surprising

[07:43:53.0331] <ljharb>
the general public are all stakeholders.

[07:43:53.0944] <ptomato (at TC39, limited availability)>
> <@ljharb:matrix.org> and without being primitives, what's the value over just using a library - "i don't have to install it" imo is far far weaker than "it's more ergonomic"

I agree with your position on Decimal pretty much, but I do think "I don't have to install it" is a huge motivation for serving the majority of the world's population that accesses websites on an unstable or metered internet connection

[07:45:33.0267] <Michael Ficarra>
true, it is justified for *many* reasons

[07:52:23.0754] <shu>
to be clear i don't mean that we wish to make standards positions _private_, i mean that i don't consider it my job to _publicize_

[07:52:37.0650] <shu>
like, twitter threads, blog posts, whatever

[07:53:27.0972] <shu>
dminor: are you contributing to irregexp?

[07:53:52.0119] <Chris de Almeida>
Jesse (TC39): do you want to have a continuation for Decimal tomorrow?  if so, how long?

[07:54:19.0821] <nicolo-ribaudo>
irregexp seems like something cool to eventually learn how to contribute to

[07:55:06.0054] <shu>
please do!

[07:57:09.0896] <Jesse (TC39)>
> <@softwarechris:matrix.org> Jesse (TC39): do you want to have a continuation for Decimal tomorrow?  if so, how long?

sure, how about 20 minutes?

[07:58:20.0429] <shu>
FYI if you schedule it in the morning, i will not be able to attend

[07:59:05.0083] <Chris de Almeida>
shu: we can add to afternoon

[08:04:18.0758] <Chris de Almeida>
decimal queue capture is now in the notes

[08:13:41.0126] <Andreu Botella>
There is precedent in that `/test/ === /test/` is false, but yeah, it is weird

[08:17:51.0148] <Christian Ulbrich>
There are other things, with `NaN === NaN` only being the most prominent one, but `[] === []`... are also not equal :) As are Dates...

[08:20:27.0392] <ljharb>
It‚Äôs not that syntax always means triple equals, but that the oddities are known and minimal and shouldn‚Äôt be increased.

[08:34:13.0160] <shu>
interesting point about regexps having creation syntax but have Object semantics

[08:35:03.0136] <shu>
but numeric literals having Object semantics feels it is unprecedented in all of PL. would be fascinating to see an exception

[08:42:22.0337] <Jesse (TC39)>
> <@eemeli:mozilla.org> Re: the Decimal proposal, do I understand right that as currently proposed `1.0m === 1.0m` would be `false`, yes? That's... weird.

indeed -- it's a bullet one would bite if you accept the "no overloading" approach. I'm happy to discuss whether we should make an exception for `===`

[08:43:34.0386] <Jesse (TC39)>
i.e., make `===` be numerical equality when both lhs and rhs are `Decimal`s

[08:44:09.0396] <nicolo-ribaudo>
> <@shuyuguo:matrix.org> but numeric literals having Object semantics feels it is unprecedented in all of PL. would be fascinating to see an exception

I would rather not use JS as the language for "nobody does this so let's try to see how weird it will be!"

[08:52:19.0065] <shu>
me neither?

[08:52:44.0645] <shu>
that was not a "would be fascinating for JS to do this as an exception", that was a "it would be fascinating to see prior art, i don't believe it exists"

[08:55:01.0196] <shu>
> <@jesse:igalia.com> i.e., make `===` be numerical equality when both lhs and rhs are `Decimal`s

i would not support this

[08:57:33.0853] <Jesse (TC39)>
> <@shuyuguo:matrix.org> i would not support this

understood -- the "no overloading" philosophy (which I still stand by) tries to respect that

[09:00:47.0695] <Jesse (TC39)>
in `C#` (a language that has decimals natively), you use a `cmp` function (returns -1, 0, or 1), which is also what I have in my current proposal. No `===`

[09:01:45.0656] <rbuckton>
> <@jesse:igalia.com> in `C#` (a language that has decimals natively), you use a `cmp` function (returns -1, 0, or 1), which is also what I have in my current proposal. No `===`

C# has operator overloading that covers `==` and other operators

[09:01:58.0561] <Jesse (TC39)>
ah ok, thanks, didn't know üëçÔ∏è

[09:05:03.0817] <rbuckton>
In C#, all primitives are "value types" that are essentially defined as `struct`s, and all operations on these types flows through operator overloading. Since C# is a typed language, it determines which static operator method to bind at compile time so that the runtime cost is negligible, though for a number of built in operations those can also generate native code that is faster than the overload method. 

[09:06:38.0322] <rbuckton>
 * In C#, almost all primitives (except `string`) are "value types" that are essentially defined as `struct`s, and all operations on these types flows through operator overloading. Since C# is a typed language, it determines which static operator method to bind at compile time so that the runtime cost is negligible, though for a number of built in operations those can also generate native code that is faster than the overload method.

[09:07:39.0117] <rbuckton>
for example: https://learn.microsoft.com/en-us/dotnet/api/system.decimal?view=net-7.0

[09:08:45.0489] <Jesse (TC39)>
heh love the `PiggyBank` class

[09:13:30.0725] <rbuckton>
We had a number of discussions about user-defined operator overloading a few years back. The thought at the time was that you would need to have some kind of syntactic opt-in to inform the runtime that it should consider operator overloads. The upside being that existing code wouldn't be effected by the cost associated with operator overloads, the downside being that it would be fairly easy to forget to include the syntax, especially if you are working with a value that is returned from a function defined in a different module.

It was something like `with operators from Foo` to opt into using operators defined on a constructor, IIRC. 

[09:13:55.0930] <rbuckton>
 * We had a number of discussions about user-defined operator overloading a few years back. The thought at the time was that you would need to have some kind of syntactic opt-in to inform the runtime that it should consider operator overloads. The upside being that existing code wouldn't be effected by the cost associated with operator overloads, the downside being that it would be fairly easy to forget to include the syntax, especially if you are working with a value that is returned from a function defined in a different module.

It was something like `with operators from Foo;` to opt into using operators defined on the constructor `Foo`, or something to that effect.

[09:14:05.0602] <rbuckton>
 * We had a number of discussions about user-defined operator overloading a few years back. The thought at the time was that you would need to have some kind of syntactic opt-in to inform the runtime that it should consider operator overloads. The upside being that existing code wouldn't be effected by the cost associated with operator overloads, the downside being that it would be fairly easy to forget to include the syntax, especially if you are working with a value that is returned from a function defined in a different module.

It was something like `with operators from Foo;` to opt into using operators defined on the constructor `Foo`.

[09:16:32.0220] <rbuckton>
I'd hoped that we could tie operator overloading to something like `struct`, such that an implementation might have an easy way to recognize whether to even consider an overloaded operator (so it doesn't need to consider operator overloads for all other types), but that doesn't look to be viable with the direction we're going.

[09:18:04.0027] <rbuckton>
Alternatively, something similar we could use to tag an instance as opting-in to operator overloads like a `value class C {}` or something to that effect.


2023-07-13
[17:39:01.0123] <littledan>
> <@shuyuguo:matrix.org> but numeric literals having Object semantics feels it is unprecedented in all of PL. would be fascinating to see an exception

Don‚Äôt C++ custom literals enable exactly this? For my JS custom literals proposal, I assumed it would be Ok to follow that and allow those to return objects or primitives.

[17:45:33.0719] <littledan>
> <@shuyuguo:matrix.org> to be clear i don't mean that we wish to make standards positions _private_, i mean that i don't consider it my job to _publicize_

It doesn‚Äôt quite have to be your job to publicize it as such, but if you could give us (proponents of features) direction on what to say to others when they ask us about this, so as to accurately represent your position, that would be helpful. The scope of what you would like JS proposals to avoid has been a little ambiguous even to many committee members leading up to this meeting.

[18:41:59.0180] <justingrant>
> <@michaelficarra:matrix.org> it's so strange to me that IETF would explicitly *not* want to support sub-minute offsets

(catching up) Here's more context around IETF's reasoning, and more generally why restricting offset time zones to minutes seems OK to me:

Existing RFC3339 timestamp strings (which the new IETF spec, aka "IXDTF", extends) only support HH:MM in the offset, e.g. `2023-07-12T14:06-07:00`. You can't use `07:00:01` or even `07:00:00` because parsers wouldn't recognize it. JS Date has the same same limit, BTW. 

In the new IETF spec, they didn't want to change anything about the RFC3339 portion of the IXDTF timestamp, only the stuff in brackets after the timestamp is what's new.  Otherwise, existing RFC3339 parsers would break for the before-brackets portion. Of course, that's not necessarily related to what's in brackets. We could have different precision for the in-brackets portion because there's no legacy.

But with IXDTF, the rule is that the RFC3339 offset must match the offset of the time zone in brackets.  So `2020-01-01T00:00-05:00[America /Los_Angeles]` is considered an error because the offset doesn't match the time zone.

For named time zones that have sub-minute precision, the new IETF spec handles it by being flexible about what "match" means: if the bracketed time zone's offset, when rounded to HH:MM, matches the offset in the RFC3339 portion of the string, then there's no error produced. 

So `1970-01-01T00:00-00:45[Africa/Monrovia]` is considered valid, even though Liberia's offset in 1970 was -00:44:30. The rounding hack simply tells the receiver not to throw an error in that case; it doesn't change the actual instant that the string represents. The instant described by "midnight on Jan 1 1970 in Liberia" is still 44:30 away from UNIX epoch: 
```js
Temporal.ZonedDateTime.from('1970-01-01T00:00-00:45[Africa/Monrovia]').toInstant();
// => 1970-01-01T00:44:30Z
```

Temporal does the same thing in reverse in `ZonedDateTime.p.toString()`: it formats the instant by rounding the offset to the nearest minute.

Anyway, that's how it works for named time zones. But what about offset time zones? 

Because the offset in the RFC3339 portion of the string is constrained to HH:MM, the IETF folks felt that it'd be better to also limit the bracketed time zone to HH:MM too. There's nothing preventing us from extending the format in the future if there's customer demand, using the same rounding hack used for named time zones, so that `1970-01-01T00:00-00:45[-00:44:30]` would also be allowed.

But it's not clear (to me at least) that this customer demand will ever materialize. Offset time zones were really only added to Temporal and IXDTF for backwards compatibility with Java. It's not clear how much usage of offset time zones there will be in Temporal. Partly this is because all IANA time zones today are on 15-minute boundaries. Sub-minute offsets haven't been official in any country since the 1970s, and even then it was rare. And offset time zones intentionally dispense with the main value of time zones in Temporal: the ability to automatically adjust timestamps for DST and other time zone weirdness.

Also, there's a storage advantage. If offset time zones are limited to minutes, then a Temporal.TimeZone can fit in a 16-bit union: 12 bits for offset time zones (¬±24h at minute-precision), 10 bits for the index into ~600 named time zones, and one bit to choose between them. Sub-minute offsets would require 50% more bytes to support a use case with questionable demand.

Finally, any user who really needs an offset time zone with sub-minute precision can create a custom time zone with granularity down to nanoseconds. Which they'd have to do anyways for time zones like TAI which don't have constant offsets (thanks leap seconds!) so you can't use an offset time zone anyways. AFAICT, there has never been a real-world time zone that has had a non-minute-aligned offset whose offset has never changed.  So I'm kinda skeptical that "offset time zones at sub-minute precision" are real things.

P.S. - one concern raised was how RFC 5545 (aka iCalendar) supports [second-precision offsets](https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.14). But AFAICT, those offsets are never actually used for time zone identifiers. Rather, they're used to define the offsets of named time zones. And Temporal is already permissive with timestamp offset inputs, so we'll accept strings like `1970-01-01T00:00-00:44:30` which AFAICT is what RFC5545 needs. 

Summary: restricting to minutes for built-in offset time zones seems like a safe initial bet that we can always extend later if needed. 

Thanks for coming to my obscure TED talk. 

[19:29:11.0228] <justingrant>
> <@sffc:mozilla.org> It still seems like we should stop returning Saigon and Kiev despite the lack of a Temporal.TimeZone.prototype.equals

There are two pieces required to fully solve this: 
1. Stop canonicalizing user-inputted IDs to canonical IDs that are sometimes outdated and/or varying across browsers.  By bringing proposal-canonical-tz to Stage 3 and merging it into Temporal, this problem gets solved as soon as Temporal.TimeZone ships in implementations. Yay!
2. Stop using outdated canonical IDs. Today this affects all IDs, but after (1) is done this will only affect IDs generated by ECMAScript itself, e.g. `new Intl.DateTimeFormat().resolvedOptions().timeZone` and `Intl.supportedValuesOf('timeZone')`.

These two pieces are independent!  Even though yesterday the committee agreed to hold (1) until Temporal.TimeZone ships, for (2) implementations are already free to return Europe/Kyiv, Asia/Kolkata, and Asia/Ho_Chi_Minh as canonical IDs. Firefox does this today, and Anba has argued (convincingly, IMO) that the FF behavior is more spec-compliant with current 402.

V8 and JSC don't do this today because they rely on CLDR and ICU which never update renamed IDs.  But nothing stops ICU-using implementations from doing what Firefox does and overriding the ~20 zones in CLDR that use out-of-date names. If an ICU solution will take 2 years, could V8 and JSC in the meantime just add a hard-coded mapping table of 20 IDs?  It's not like renames happen often: less than once per year is the average. If you, shu , and Frank wanted to do this badly enough, I suspect it could get done fast!

That said, it's a reasonable argument that doing (1) before (2), or at the same time, would reduce the negative impact to existing code because user-inputted zones wouldn't be affected.

My suggestion:
* Let's get implementations building & shipping Temporal!  After this plenary's normative changes are merged within a week or two, AFAIK there are no other large changes on the horizon.
* IMO, V8 and JSC should really consider the 20-item hard-coded mapping table to work around CLDR's slow schedule. Could this work be paired with Temporal implementation instead of waiting until later? Could this work start now, and ship in a limited test to gauge the web-compat impact?

Let me know how I can help!

[19:39:46.0529] <Richard Gibson>
> if the bracketed time zone's offset, when rounded to HH:MM, matches the offset in the RFC3339 portion of the string, then there's no error produced

justingrant I was wondering about how this rounding handled midpoint values like -00:44:30 or +00:44:30 (specifically "ties away from zero" vs. "ties toward positive infinity" vs. "ties toward even"), but I don't see _any_ mention of it at https://www.ietf.org/archive/id/draft-ietf-sedate-datetime-extended-08.html or https://github.com/ietf-wg-sedate/draft-ietf-sedate-datetime-extended/blob/main/draft-ietf-sedate-datetime-extended.md . Are you sure you're not thinking of [Temporal InterpretISODateTimeOffset](https://tc39.es/proposal-temporal/#sec-temporal-interpretisodatetimeoffset) step 8.c.i RoundNumberToIncrement(_candidateNanoseconds_, 60e9, "halfExpand")?

[19:45:18.0120] <shu>
> <@littledan:matrix.org> It doesn‚Äôt quite have to be your job to publicize it as such, but if you could give us (proponents of features) direction on what to say to others when they ask us about this, so as to accurately represent your position, that would be helpful. The scope of what you would like JS proposals to avoid has been a little ambiguous even to many committee members leading up to this meeting.

my suggestion there is you should redirect the people who ask about this back to V8 instead, instead of relaying it on behalf of V8

[20:20:13.0111] <shu>
> <@justingrant:matrix.org> There are two pieces required to fully solve this: 
> 1. Stop canonicalizing user-inputted IDs to canonical IDs that are sometimes outdated and/or varying across browsers.  By bringing proposal-canonical-tz to Stage 3 and merging it into Temporal, this problem gets solved as soon as Temporal.TimeZone ships in implementations. Yay!
> 2. Stop using outdated canonical IDs. Today this affects all IDs, but after (1) is done this will only affect IDs generated by ECMAScript itself, e.g. `new Intl.DateTimeFormat().resolvedOptions().timeZone` and `Intl.supportedValuesOf('timeZone')`.
> 
> These two pieces are independent!  Even though yesterday the committee agreed to hold (1) until Temporal.TimeZone ships, for (2) implementations are already free to return Europe/Kyiv, Asia/Kolkata, and Asia/Ho_Chi_Minh as canonical IDs. Firefox does this today, and Anba has argued (convincingly, IMO) that the FF behavior is more spec-compliant with current 402.
> 
> V8 and JSC don't do this today because they rely on CLDR and ICU which never update renamed IDs.  But nothing stops ICU-using implementations from doing what Firefox does and overriding the ~20 zones in CLDR that use out-of-date names. If an ICU solution will take 2 years, could V8 and JSC in the meantime just add a hard-coded mapping table of 20 IDs?  It's not like renames happen often: less than once per year is the average. If you, shu , and Frank wanted to do this badly enough, I suspect it could get done fast!
> 
> That said, it's a reasonable argument that doing (1) before (2), or at the same time, would reduce the negative impact to existing code because user-inputted zones wouldn't be affected.
> 
> My suggestion:
> * Let's get implementations building & shipping Temporal!  After this plenary's normative changes are merged within a week or two, AFAIK there are no other large changes on the horizon.
> * IMO, V8 and JSC should really consider the 20-item hard-coded mapping table to work around CLDR's slow schedule. Could this work be paired with Temporal implementation instead of waiting until later? Could this work start now, and ship in a limited test to gauge the web-compat impact?
> 
> Let me know how I can help!

thanks for the detailed plan, i'd hate for it to get lost in the matrix chat, an issue to capture it would be great.

for (2), good to know it's independent. i won't be the one to drive this work, so Frank, who's much closer to the i18n and ICU teams, would be the one for you to convince to do the heavy lifting. frankly i just don't have the domain expertise and don't have a nose for the impact here to make a decision

[20:59:41.0007] <bakkot>
do I read the schedule correctly that there's a 60 minute underflow before lunch?

[20:59:57.0531] <bakkot>
is there any thought of moving stuff up or is all the other stuff fixed in time?

[00:28:24.0462] <Rob Palmer>
We're open to ideas on filling the morning schedule. 

[00:52:34.0444] <bakkot>
I ask mainly because I would like to know if I will miss anything if I sleep during the time that is currently dead

[00:52:51.0232] <bakkot>
that being 2am-4am pacific time

[00:53:08.0282] <bakkot>
i.e. hours that I would very much like to sleep through if I am not going to be missing anything

[00:53:53.0010] <Rob Palmer>
We will begin by asking for agenda items to fill the time.

[01:03:14.0790] <sffc>
my slides: https://docs.google.com/presentation/d/1MKceo1Pn1PvuMz1WkzGwIpbT5qRNZVZRxY3rgcPJOKI/edit#slide=id.p

[01:07:55.0660] <littledan>
We are likely to do a review of Stage 2 proposals during the spare time in the morning, and a presentation of research by people here in UiB in the afternoon, but details tbd for each.

[01:12:29.0399] <Rob Palmer>
We have brought forward Nicolo's Optional Chaining into this morning.  Plus the two additions Dan mentioned.

[01:17:03.0919] <Michael Ficarra>
I have seen this exact complaint about not being able to shrink wasm memory before in one of the wasm issue trackers

[01:17:34.0060] <Michael Ficarra>
they're aware of a need here

[01:18:00.0746] <littledan>
Isn't this just an issue at the tooling level, when it comes to single-threaded Wasm?

[01:18:03.0736] <bakkot>
https://github.com/WebAssembly/design/issues/1397

[01:20:10.0184] <littledan>
 * <del>Isn't this just an issue at the tooling level, when it comes to single-threaded Wasm?</del>

[01:27:33.0165] <justingrant>
> @shu: thanks for the detailed plan, i'd hate for it to get lost in the matrix chat, an issue to capture it would be great.

Done! https://github.com/tc39/ecma402/issues/806. Feedback welcome! 

[01:28:58.0244] <justingrant>
 * > @shu: thanks for the detailed plan, i'd hate for it to get lost in the matrix chat, an issue to capture it would be great.

https://github.com/tc39/ecma402/issues/806. Feedback welcome!

[01:33:33.0682] <justingrant>
> <@gibson042:matrix.org> > if the bracketed time zone's offset, when rounded to HH:MM, matches the offset in the RFC3339 portion of the string, then there's no error produced
> 
> justingrant I was wondering about how this rounding handled midpoint values like -00:44:30 or +00:44:30 (specifically "ties away from zero" vs. "ties toward positive infinity" vs. "ties toward even"), but I don't see _any_ mention of it at https://www.ietf.org/archive/id/draft-ietf-sedate-datetime-extended-08.html or https://github.com/ietf-wg-sedate/draft-ietf-sedate-datetime-extended/blob/main/draft-ietf-sedate-datetime-extended.md . Are you sure you're not thinking of [Temporal InterpretISODateTimeOffset](https://tc39.es/proposal-temporal/#sec-temporal-interpretisodatetimeoffset) step 8.c.i RoundNumberToIncrement(_candidateNanoseconds_, 60e9, "halfExpand")?

Good catch. You're right, the rounding is a Temporal solution, not something in the IETF spec. Let's discuss among the Temporal champions whether it's wroth trying to get this into the IETF spec, or whether it's too niche for us to care about pushing it into that spec.

[01:46:39.0063] <rbuckton>
Python's `contextlib` has a very tight coupling between decorators and context managers, such as `contextlib.ContextDecorator`: https://docs.python.org/3/library/contextlib.html#contextlib.ContextDecorator

[01:50:14.0890] <Luca Casonato>
On the topic of source phase imports, please vote on the keyword (or suggest other keywords): https://github.com/tc39/proposal-source-phase-imports/issues/54

[01:53:02.0196] <Luca Casonato>
And you can discuss here: https://github.com/tc39/proposal-source-phase-imports/issues/53

[02:11:02.0661] <littledan>
the `new` example should be `new a?.()`

[02:11:45.0644] <littledan>
I thought the example `new a?.b()` should already be legal (but would not be so useful)

[02:12:45.0429] <eemeli>
Do we have any valid syntax yet that considers the LHS in any way before attempting evaluation of the RHS?

[02:14:55.0013] <bakkot>
`(a.b) = c` being legal is an accident of history

[02:15:05.0739] <rbuckton>
```js
a = { b: x };
a = ({ b: x });
( { b: x } = a );
( ({ b: x }) = a ); // does not work
```

[02:15:10.0106] <bakkot>
we made `([x]) = b` illegal

[02:15:14.0833] <rbuckton>
so we are not consistent in all assignment cases

[02:19:25.0616] <Andreu Botella>
You can also treat this as being precedence-related, right?

[02:19:35.0710] <Andreu Botella>
whether `?.` is prioritized over `=`

[02:19:35.0846] <bakkot>
not with the example on screen, no

[02:19:37.0088] <Michael Ficarra>
Andreu Botella: no?

[02:19:44.0260] <HE Shi-Jun>
> <@bakkot:matrix.org> `(a.b) = c` being legal is an accident of history

yeah, it's strange. Much strange that we support `(a.b)=c` but not `(test?a:b)=c` which was supported in some other languages.  

[02:19:47.0898] <Michael Ficarra>
Andreu Botella: definitely not

[02:20:31.0090] <rbuckton>
Its easy enough to say that `(a?.b)` is not a valid simple assignment target

[02:20:53.0616] <Michael Ficarra>
HE Shi-Jun: you're right, that is a strange inconsistency

[02:22:14.0357] <bakkot>
we could say `a?.b = c` is only legal in statement position

[02:22:17.0555] <rbuckton>
syntactically `a?.b = c` would likely be an _OptionalChainAssignment_, where the `?.b = c = d = 42` is part of the chain

[02:22:18.0361] <bakkot>
that would be kind of odd but like

[02:22:18.0800] <bakkot>
fine

[02:22:37.0499] <HE Shi-Jun>
`a = b.x = c?.y = d = e = 42;` this case is interesting, what's the behavior as current draft?

[02:23:18.0227] <rbuckton>
If you translate this example to the "setter-function" case, it is consistent:
```js
a = b.x = c?.setY(d = e = 42);
```
would produce `undefined`

[02:24:15.0332] <rbuckton>
 * If you translate this example to the "setter-function" case, it is consistent:

```js
a = b.x = c?.setY(d = e = 42);
```

would assign `undefined` to `a` and `b.x`

[02:24:16.0928] <HE Shi-Jun>
so `a` and `b.x` would be `undefined` instead of `42`? ü§î

[02:24:21.0690] <rbuckton>
yes

[02:24:54.0980] <rbuckton>
maybe weaker than Statement and only at `,`

[02:25:09.0985] <rbuckton>
 * maybe weaker than Statement and allow at `,`

[02:25:16.0255] <rbuckton>
 * maybe weaker than Statement and allow at `,`?

[02:25:22.0234] <bakkot>
yeah, that also works

[02:25:34.0224] <bakkot>
really anywhere except the RHS of an assignment expression

[02:26:07.0666] <bakkot>
though, if the goal is to avoid observing the value, you do want "only in statement position" probably

[02:26:28.0097] <nicolo-ribaudo>
The goal is to "accidentally" observe the value

[02:26:31.0974] <rbuckton>
It should be feasible to forbid `a = b?.x = c` in the grammar

[02:26:39.0808] <bakkot>
`x = (0, a?.b = c)` assigns what value to `x`? `undefined` or `c`?

[02:26:43.0750] <nicolo-ribaudo>
i.e. something like `a = (b?.c = d)` might still be ok

[02:26:55.0780] <nicolo-ribaudo>
 * i.e. something like `a = (b?.c = d)` might still be ok, assigning undefined

[02:29:38.0458] <rbuckton>
Not sure I want `a?.b = c` where `c` is evaluated if `a` is undefined. The point is to avoid the evaluation of `c` if it isn't going to be used, otherwise it is not a valid refactor from `if (a) a.b = c`

[02:30:14.0094] <rbuckton>
`a?.b ?= c`?

[02:30:48.0668] <littledan>
> <@rbuckton:matrix.org> `a?.b ?= c`?

Maybe? It feels like one ? should correspond to one instance of short-circuiting, but this has two ? to point to the same thing

[02:30:59.0193] <bakkot>
> <@rbuckton:matrix.org> Not sure I want `a?.b = c` where `c` is evaluated if `a` is undefined. The point is to avoid the evaluation of `c` if it isn't going to be used, otherwise it is not a valid refactor from `if (a) a.b = c`

I agree but I also agree with the concern about evaluating the RHS, which makes me not want this proposal (in the current form)

[02:31:09.0443] <littledan>
it feels like ne pas in French--agreement

[02:32:17.0914] <rbuckton>
ah, c'est vrai

[02:32:49.0230] <rbuckton>
(though I admit my french is limited and rusty)

[02:33:51.0372] <littledan>
same

[02:35:02.0741] <rbuckton>
`a?.b` is often intended to be read more like `a  ?  .b` or `if a then a.b`, thus `a?.b = c` would be intended to be read as `a  ?  .b = c` or `if a then a.b = c`.

[02:35:33.0293] <rbuckton>
 * `a?.b` is often intended to be read more like `a  ?  .b` or `if a (exists) then a.b`, thus `a?.b = c` would be intended to be read as `a  ?  .b = c` or `if a (exists) then a.b = c`.

[02:35:59.0860] <rbuckton>
 * `a?.b` is often intended to be read more like `a  ?  .b` or "*if a (exists) then a.b*", thus `a?.b = c` would be intended to be read as `a  ?  .b = c` or "*if a (exists) then a.b = c*".

[02:36:15.0128] <rbuckton>
 * `a?.b` is often intended to be read more like `a  ?  .b` or "_if a exists then a.b_", thus `a?.b = c` would be intended to be read as `a  ?  .b = c` or "_if a exists then a.b = c_".

[02:38:50.0343] <rbuckton>
> <@littledan:matrix.org> Maybe? It feels like one ? should correspond to one instance of short-circuiting, but this has two ? to point to the same thing

Yeah, I don't like it but it would be a way to clarify what happens to the RHS. It's questionable how this would work with compound assignment or prefix/postfix increment/decrement however.

[02:40:24.0862] <Michael Ficarra>
eemeli: I think you need to review what stage 1 means

[02:40:33.0684] <Michael Ficarra>
you are asking nonsensical questions

[02:40:55.0277] <Michael Ficarra>
a solution is not accepted to stage 1; a problem space is

[02:41:16.0575] <rbuckton>
I would like us to investigate this at Stage 1 to see if we can find a way to resolve concerns raised by some delegates. I think this would be very valuable to have in some form and is worth pursuing, even if we need to find unique syntax to accommodate concerns.

[02:41:24.0585] <nicolo-ribaudo>
> <@michaelficarra:matrix.org> a solution is not accepted to stage 1; a problem space is

I think Eemeli's point is that this is not something that needs a solution at all

[02:41:58.0368] <Michael Ficarra>
yes, often when a proposal is "overcooked", we end up in this kind of a situation

[02:42:17.0748] <Michael Ficarra>
people get too hung up on the specifics of a potential solution

[02:42:19.0071] <bakkot>
(fwiw I think that the MessageFormat proposal had the same problem)

[02:42:42.0829] <Michael Ficarra>
unfortunately, without them, it can be difficult to understand the problem space

[02:43:42.0379] <rbuckton>
I would say the problem space is "allowing assignment with similar ergonomics as optional chaining currently allows: avoiding repetition and conditional member references based on whether a part of the LHs is null/undefined"

[02:43:58.0258] <rbuckton>
 * I would say the problem space is "allowing assignment with similar ergonomics as optional chaining currently allows: avoiding repetition and handling conditional member references based on whether a part of the LHs is null/undefined"

[02:46:05.0277] <bakkot>
Bradford Smith: I do not think it will be hard to specify this

[02:46:10.0972] <rbuckton>
We can at least block `a = b?.c = d` via a static semantics rule, even if not in the grammar.

[02:46:12.0842] <bakkot>
or to write parsers for it

[02:46:31.0829] <rbuckton>
We block `const a` via static semantics, so this doesn't seem that bad

[02:47:18.0136] <bakkot>
like I expect this to be about an order of magnitude easier specify and implement than the hideous `async (x)` cover grammar

[02:47:31.0418] <bakkot>
which, granted, I wouldn't want any new features of that complexity

[02:47:36.0108] <bakkot>
but this one doesn't seem bad at all

[02:47:50.0564] <bakkot>
 * like I expect this to be about an order of magnitude easier to specify and implement than the hideous `async (x)` cover grammar

[02:48:20.0172] <littledan>
arrow functions should've been like `^x => y` or something

[02:48:20.0231] <nicolo-ribaudo>
I know that I should have not written a spec for a stage 0 proposal, but the way it can be specified is nicolo-ribaudo.github.io/proposal-optional-chaining-assignment/

[02:48:26.0805] <littledan>
everything would be way easier in that case

[02:48:57.0212] <Michael Ficarra>
`Œªx. y`

[02:49:09.0647] <bakkot>
sidebar: is someone breathing directly into one of the microphones?

[02:49:19.0247] <rbuckton>
> <@bakkot:matrix.org> like I expect this to be about an order of magnitude easier to specify and implement than the hideous `async (x)` cover grammar

We want to allow `a?.b = c` where its on the LHS, but disallow `a = b?.c = d` where its on the LHS and RHS, but not disallow `a = b?.c`. Possible with production parameters maybe, especially if the assignment is part of the _OptionalChain_ production

[02:49:44.0610] <Bradford Smith>
> <@bakkot:matrix.org> Bradford Smith: I do not think it will be hard to specify this

Well I expect you're more familiar with the details of the grammar than I.

[02:49:54.0560] <rbuckton>
> <@bakkot:matrix.org> like I expect this to be about an order of magnitude easier to specify and implement than the hideous `async (x)` cover grammar

 * We want to allow `a?.b = c` where its on the LHS, but disallow `a = b?.c = d` where its on the LHS and RHS, but not disallow `a = b?.c` where its on the RHS only. Possible with production parameters maybe, especially if the assignment is part of the _OptionalChain_ production

[02:50:18.0460] <eemeli>
> <@bakkot:matrix.org> (fwiw I think that the MessageFormat proposal had the same problem)

Agreed. We really should've explicitly gone for stage-1 for Intl.MessageFormat a couple of years earlier, when the work in its WG started under Unicode.

[02:51:01.0821] <ryzokuken üá≥üá¥>
> <@eemeli:mozilla.org> Agreed. We really should've explicitly gone for stage-1 for Intl.MessageFormat a couple of years earlier, when the work in its WG started under Unicode.

It's hard to see these things ahead of time tbf

[02:51:03.0436] <rbuckton>
> <@bradfordcsmith:matrix.org> Well I expect you're more familiar with the details of the grammar than I.

We do some similar grammar gymnastics with `??`

[02:51:16.0291] <ryzokuken üá≥üá¥>
> <@eemeli:mozilla.org> Agreed. We really should've explicitly gone for stage-1 for Intl.MessageFormat a couple of years earlier, when the work in its WG started under Unicode.

 * It's hard to foresee these issues ahead of time tbf

[02:51:23.0028] <bakkot>
> <@rbuckton:matrix.org> We want to allow `a?.b = c` where its on the LHS, but disallow `a = b?.c = d` where its on the LHS and RHS, but not disallow `a = b?.c` where its on the RHS only. Possible with production parameters maybe, especially if the assignment is part of the _OptionalChain_ production

production parameter works, yes - have a new [IsStatement] flag or whatever, present only on AssignmentExpression, and then Expression sets the flag and no other use of AssignmentExpression sets it

[02:51:36.0154] <bakkot>
alternatively you can just have an early error with prose

[02:52:18.0275] <rbuckton>
> <@bakkot:matrix.org> alternatively you can just have an early error with prose

Yeah, an EE is probably easiest.

[02:52:46.0670] <nicolo-ribaudo>
ryzokuken üá≥üá¥ Rob Palmer TCQ is at the previous agenda item

[02:52:57.0819] <ryzokuken üá≥üá¥>
oops

[02:53:04.0985] <ryzokuken üá≥üá¥>
ptomato (at TC39, limited availability): could you add your item again?

[02:53:22.0806] <nicolo-ribaudo>
> <@usharma:igalia.com> ptomato (at TC39, limited availability): could you add your item again?

It's still there

[02:53:31.0598] <nicolo-ribaudo>
Or at least, I see it there

[02:54:59.0630] <bakkot>
"how should the committee proceed wrt the pipeline operator" -> we should not proceed with the pipeline operator

[02:55:13.0103] <Michael Ficarra>
personally, I think the pipeline operator may need a full re-justification

[02:55:27.0374] <bakkot>
(sorry to be blunt; in my defense it's 3am)

[02:55:37.0039] <Michael Ficarra>
(reviewed in the context of the language as it is today, not how it was when originally justified)

[02:56:05.0999] <ryzokuken üá≥üá¥>
I think given all that transpired with pipeline, maybe it makes sense to deviate from both semantics and try to come up with something unique that would be a decent compromise?

[02:56:13.0494] <Andreu Botella>
it's odd that test262 seems to strongly rely on `cleanupSome` to test some GC things

[02:56:40.0941] <nicolo-ribaudo>
> <@michaelficarra:matrix.org> personally, I think the pipeline operator may need a full re-justification

I would like to hear how it fits with the protocols proposal, since they both solve 'I want "methods" without the bad^TM modifications to its prototype that I do now own'

[02:57:41.0227] <nicolo-ribaudo>
I like throw expressions

[02:58:21.0804] <Michael Ficarra>
same

[02:58:24.0097] <nicolo-ribaudo>
I like them even in a world with do expressions

[02:58:31.0744] <Michael Ficarra>
I really wish I could get some time to work on protocols again

[02:59:15.0749] <Michael Ficarra>
editor work unfortunately takes up most of my time allocated to TC39, and iterator helpers (and follow-ons) are definitely ore popular in the communit

[02:59:18.0483] <Michael Ficarra>
 * editor work unfortunately takes up most of my time allocated to TC39, and iterator helpers (and follow-ons) are definitely ore popular in the community

[02:59:23.0645] <Michael Ficarra>
 * editor work unfortunately takes up most of my time allocated to TC39, and iterator helpers (and follow-ons) are definitely more popular in the community

[03:03:02.0928] <Andreu Botella>
it seems like if `cleanupSome` is withdrawn, it would have to be added to the test262 infrastructure

[03:03:12.0330] <rbuckton>
The direction that the pipeline operator took has had significant pushback from the community. There's a tremendous amount of interest in the feature, but choice to use Hack-style pipes didn't sit well with some of the major libraries in the FP.

[03:03:20.0996] <Andreu Botella>
maybe in a simplified way, without taking a callback

[03:03:49.0447] <rbuckton>
 * The direction that the pipeline operator took has had significant pushback from the community. There's a tremendous amount of interest in the feature, but choice to use Hack-style pipes didn't sit well with some of the major libraries in the FP community.

[03:04:03.0171] <Rob Palmer>
Please could you write this (in an appropriate way) in the summary notes for this topic, Ron.

[03:04:04.0207] <rbuckton>
i accidentally a word. I've edited the comment

[03:04:32.0204] <rbuckton>
re: `do` expressions, I think some proposals like pattern matching are depending on it.

[03:04:49.0219] <rbuckton>
not to say that they can't work around that.

[03:04:50.0389] <bakkot>
yeah, though pattern matching is even more syntax than `do` is

[03:04:58.0671] <bakkot>
it is so much syntax

[03:05:20.0270] <rbuckton>
pattern matching is extremely valuable though, and I think is definitely worth its weight.

[03:05:39.0996] <bakkot>
yeah I'm not saying any of these things shouldn't be pursued, considered in isolation (except maybe pipeline)

[03:05:41.0428] <ptomato (at TC39, limited availability)>
which implementations have cleanupSome anyway? I don't think it works in most of them, at least not unflagged

[03:05:55.0730] <bakkot>
just that I think the community would be better served by us focusing on stdlib stuff over syntax, at the margin

[03:06:01.0181] <ptomato (at TC39, limited availability)>
it may well be that the test262 infrastructure that uses cleanupSome, was only added for testing cleanupSome

[03:06:36.0693] <Andreu Botella>
https://github.com/tc39/test262/blob/main/test/built-ins/FinalizationRegistry/gc-has-one-chance-to-call-cleanupCallback-for-object.js

[03:06:59.0247] <Michael Ficarra>
I believe HE Shi-Jun was interested in championing the `function.sent` proposal

[03:07:00.0329] <Andreu Botella>
that test doesn't seem to be specifically for `cleanupSome`

[03:07:16.0690] <Andreu Botella>
and it uses `asyncGC`, which uses `cleanupSome` internally

[03:07:30.0527] <bakkot>
it does kind of claim to be testing `cleanupSome`?

[03:07:36.0953] <bakkot>
at least, that's what the `info` section has

[03:07:55.0926] <Andreu Botella>
it includes `cleanupSome` in the features it uses, because otherwise test262 and maybe other engines will not pass the right flags

[03:08:06.0865] <Andreu Botella>
but I don't think it is testing `cleanupSome`

[03:08:22.0202] <Andreu Botella>
I might be wrong though

[03:08:33.0516] <ptomato (at TC39, limited availability)>
well that's what I meant by my original question - I suspect that most/all consumers of test262 might just never run this test

[03:08:42.0287] <ptomato (at TC39, limited availability)>
anyway, I'll add this to the agenda for the next test262 maintainers meeting. I'm not too familiar with these tests

[03:09:05.0935] <Andreu Botella>
I ran into this because of testing the interaction of `AsyncContext` with the `FinalizationRegistry` callback

[03:09:23.0952] <Andreu Botella>
 * I ran into this when testing the interaction of `AsyncContext` with the `FinalizationRegistry` callback, and seeing what other FR tests did

[03:10:44.0756] <Andreu Botella>
 * it includes `cleanupSome` in the features it uses, because otherwise engine262 and maybe other engines will not pass the right flags

[03:11:38.0681] <bakkot>
rbuckton: re: `throw`; it occurs to me that possibly

```
ThrowExpression: `throw` AssignmentExpression [lookahead ‚â† ,]
```
might also work?

[03:12:36.0203] <bakkot>
in combination with a `[lookahead ‚â† Throw]` restriction in `ExpressionStatement`, to avoid ambiguity

[03:13:15.0865] <bakkot>
it's a little bit weird, but I think it avoids the `throw a, b` problem

[03:14:22.0374] <bakkot>
and lookahead restrictions at the end of productions are precedented in `IfStatement`

[03:15:02.0238] <rbuckton>
That could work, and is far simpler than what I was thinking, though it does mean that _ThrowStatement_ and _ThrowExpression_ wouldn't be symmetrical.

[03:15:24.0189] <bakkot>
yeah, but you only notice the asymmetry as an author (or implementer), not as a reader

[03:15:54.0800] <bakkot>
since as a reader you would simply never encounter `throw a, b` in expression position, so it would not come up

[03:16:33.0777] <bakkot>
 * in combination with a `[lookahead ‚â† throw]` restriction in `ExpressionStatement`, to avoid ambiguity

[03:16:59.0066] <rbuckton>
The alternative I had was this:
```
Expression :
  ThrowExpression
  CommaExpression

CommaExpression : // the old Expression production
  AssignmentExpression
  CommaExpression `,` AssignmentExpression
```
And you could potentially even drop _ThrowStatement_ since it would be fully covered by _ExpressionStatement_ (rather than a lookahead restriction in _ExpressionStatement_.

[03:17:04.0073] <rbuckton>
 * The alternative I had was this:

```
Expression :
  ThrowExpression
  CommaExpression

CommaExpression : // the old Expression production
  AssignmentExpression
  CommaExpression `,` AssignmentExpression
```

And you could potentially even drop _ThrowStatement_ since it would be fully covered by _ExpressionStatement_ (rather than a lookahead restriction in _ExpressionStatement_).

[03:17:29.0847] <bakkot>
the main place I'd expect you to notice the asymmetry as an author would be like `function f(x = throw new Error('argument is not optional'), y) {]`

[03:18:06.0412] <bakkot>
but, that case is one which is hard for readers who are familiar with `ThrowStatement` to read, so I am ok with authors having to deal with asymmetry in that case

[03:18:12.0881] <bakkot>
 * the main place I'd expect you to notice the restriction as an author would be like `function f(x = throw new Error('argument is not optional'), y) {]`

[03:18:17.0491] <bakkot>
 * but, that case is one which is hard for readers who are familiar with `ThrowStatement` to read, so I am ok with authors having to deal with the restriction in that case

[03:19:56.0202] <rbuckton>
With the grammar I mention above, rather than the ambiguity of `throw` in an initializer, you would be forced to write it as `function f(x = (throw new Error(...)), y)` which helps with the ambiguity, with the downside that 99% of the places you'd want to use `throw` requiring parens.

[03:20:36.0546] <rbuckton>
I like your approach though, since I'd venture to guess that the number of `throw` statements that use `,` is vanishingly small.

[03:21:18.0623] <bakkot>
pretty small, though probably not vanishingly

[03:21:47.0598] <bakkot>
in particular, stuff like

```
let obj = {
  x: condition ? val : throw new Error('condition is not satisfied'),
  y,
};
```

[03:21:59.0399] <bakkot>
so it's still a little annoying

[03:22:06.0819] <bakkot>
but, no ambiguity.

[03:22:13.0604] <bakkot>
and you fix it with parens and go on with your life

[03:22:19.0283] <rbuckton>
> <@bakkot:matrix.org> pretty small, though probably not vanishingly

Yeah, minifiers probably do that with `throw` statements today.

[03:22:40.0320] <bakkot>
oh, sorry, yes, lots of `throw` statements with `,` because of minifiers

[03:22:52.0184] <rbuckton>
I'm happy with that though. If you *really* wanted to use `,` in your `throw` expression, you could parenthesize.

[03:22:53.0664] <bakkot>
minifiers love commas

[03:23:11.0642] <rbuckton>
> <@bakkot:matrix.org> oh, sorry, yes, lots of `throw` statements with `,` because of minifiers

But probably very few hand-written statements, I would venture to guess.

[03:23:20.0309] <bakkot>
agreed

[03:23:54.0268] <bakkot>
reading the old thread, I have a comment which reads

> Note the comma after the `throw`. How would you propose to forbid it? Would you even want to?

I don't know why it didn't occur to me that you could trivially forbid it with a lookahead...

[03:24:04.0833] <rbuckton>
I am happy with ``ThrowExpression : `throw`  AssignmentExpression [lookahead != `,`] ``

[03:24:25.0481] <rbuckton>
> <@bakkot:matrix.org> reading the old thread, I have a comment which reads
> 
> > Note the comma after the `throw`. How would you propose to forbid it? Would you even want to?
> 
> I don't know why it didn't occur to me that you could trivially forbid it with a lookahead...

or me. its only been what, 5 years?

[03:24:55.0584] <bakkot>
since that comment, almost exactly two years, but for the proposal in general yes

[03:26:18.0892] <bakkot>
> <@bakkot:matrix.org> in particular, stuff like
> 
> ```
> let obj = {
>   x: condition ? val : throw new Error('condition is not satisfied'),
>   y,
> };
> ```

I do hope implementations / parsers are able to give a good error message in this case ("try wrapping the throw expression in parentheses")

[03:26:54.0509] <bakkot>
annoying technical restrictions like this chafe a lot less when you are told immediately how to fix them

[03:27:01.0054] <bakkot>
seems like it ought to be possible

[03:27:12.0084] <rbuckton>
> <@bakkot:matrix.org> I do hope implementations / parsers are able to give a good error message in this case ("try wrapping the throw expression in parentheses")

TypeScript does this for quite a few grammar errors.

[03:28:05.0701] <bakkot>
good good

[03:28:39.0069] <rbuckton>
I posted your suggestion here: https://github.com/tc39/proposal-throw-expressions/issues/10#issuecomment-1633978974

[03:42:43.0273] <rbuckton>
> <@rbuckton:matrix.org> or me. its only been what, 5 years?

Do we care about other restrictions aside from `,`? any infix operator has the same kind of precedence issue, i.e., `throw a = b` as a statement vs. as an expression. Right now assignment isn't much of an issue in the proposal because the proposal does not allow _ThrowExpression_ to be a valid assignment target, but other operators like `&&`, `||`, `??`, etc. would have a different precedence. That said, you kind of do want to be able to do `a && throw b || c`, but `throw b || c;` has a different meaning.

[03:42:59.0019] <rbuckton>
> <@rbuckton:matrix.org> or me. its only been what, 5 years?

 * Do we care about other restrictions aside from `,`? any infix operator has the same kind of precedence issue, i.e., `throw a = b` as a statement vs. as an expression. Right now assignment isn't much of an issue in the proposal because the proposal does not allow _ThrowExpression_ to be a valid assignment target, but other operators like `&&`, `||`, `??`, etc. would have a different precedence. That said, you kind of may want to be able to write `a && throw b || c`, but `throw b || c;` has a different meaning.

[03:45:19.0226] <rbuckton>
Forcing parentheses (i.e., `(throw err)`) does solve all of those precedence concerns, though.

[03:47:33.0481] <bakkot>
does it have the same issue? wouldn't `a && throw b || c` parse as `a && (throw b || c)`, like `a && yield b || c` does?

[03:48:41.0769] <rbuckton>
`throw` is currently specified as a _UnaryExpression_, so it doesn't have the same precedence as `yield`. `a && yield b || c` isn't legal.

[03:49:07.0436] <rbuckton>
_YieldExpression_ is _AssignmentExpression_, so it can't be on the RHS of `&&`.

[03:49:28.0826] <bakkot>
ah, right

[03:49:32.0033] <bakkot>
I forget `yield` is weird

[03:50:34.0091] <rbuckton>
And one of the motivators for `throw` was to use it with `??`, i.e. `const a = b ?? throw new Error()`, so it wouldn't work as `yield` precedence without parens.

[03:52:13.0188] <rbuckton>
But that's also an alternative to my `CommaExpression` idea. Instead, just make _ThrowExpression_ an _AssignmentExpression_ with the same trailing ``[lookahead != `,`]`` restriction. That would mean you could write `a, throw b`, but not `throw a, b`, which is a bit weird, tbh.

[03:53:07.0958] <bakkot>
I am not super worried about humans writing comma expressions

[03:53:28.0901] <bakkot>
they almost exclusively come up when reading minified code, in my experience

[03:53:50.0591] <bakkot>
occasionally in loop heads but I don't anticipate much use of `throw` there either

[03:54:33.0487] <bakkot>
so while I agree that it would be weird that you could write `a, throw b` but not `throw a, b`, my actual concern is preventing you from writing the second thing, and since I don't think anyone would write the first thing the inconsistency doesn't bother me

[03:58:34.0003] <rbuckton>
Do you have a position on the precedence for other infix operators differing between the statement and expression forms, or was `,` your only concern?

[04:00:19.0067] <bakkot>
> <@rbuckton:matrix.org> Do we care about other restrictions aside from `,`? any infix operator has the same kind of precedence issue, i.e., `throw a = b` as a statement vs. as an expression. Right now assignment isn't much of an issue in the proposal because the proposal does not allow _ThrowExpression_ to be a valid assignment target, but other operators like `&&`, `||`, `??`, etc. would have a different precedence. That said, you kind of may want to be able to write `a && throw b || c`, but `throw b || c;` has a different meaning.

`a && throw b || c` does worry me. I'll have to think more about the tradeoff between that ambiguity and forcing more parens.

[04:01:05.0769] <bakkot>
it is a little less worrying that the `,` case because `throw b || c` isn't really a thing which comes up today, even in minified code, so I am less worried about people misreading it

[04:01:14.0411] <rbuckton>
Would you agree that forcing parens is a working solution, even if only as a fallback?

[04:01:30.0753] <bakkot>
yes, forcing parens solves the ambiguity

[04:01:35.0385] <rbuckton>
> <@bakkot:matrix.org> it is a little less worrying that the `,` case because `throw b || c` isn't really a thing which comes up today, even in minified code, so I am less worried about people misreading it

But minifiers, though..

[04:01:50.0183] <bakkot>
even minifiers don't output `throw b || c` in my experience

[04:02:12.0013] <littledan>
when you hear "dataflow", think "reactivity"

[04:02:36.0942] <rbuckton>
I expect that they do emit `throw a && b` though, since they often use `&&` as a substitute for `if` 

[04:02:42.0910] <Michael Ficarra>
littledan: FRP?

[04:04:36.0763] <bakkot>
> <@rbuckton:matrix.org> I expect that they do emit `throw a && b` though, since they often use `&&` as a substitute for `if`

not that I can recall seeing. that's equivalent to `if (!a) throw a; throw b;`, but I think that pattern is rare enough to not have been special-cased

[04:04:58.0451] <bakkot>
`&&` as a substitute for `if` is mainly useful when the rhs of the `if` is an expression

[04:06:41.0711] <bakkot>
looks like `esbuild` does in fact implement that, so it's just that I haven't run into it because it's rare enough

[04:09:44.0820] <bakkot>
another option, which I am... only kind of serious about, would be

```
`throw` AssignmentExpression [lookahead ‚àà {`)`, `}`, `;`, EOF} ]
```

[04:09:58.0893] <bakkot>
this would be fine if everyone used semis consistently

[04:10:29.0252] <rbuckton>
Why would you disallow `)`?

[04:10:38.0273] <bakkot>
that's an allowlist, not a denylist

[04:10:40.0068] <Michael Ficarra>
the grammar sees source post-ASI

[04:10:44.0713] <rbuckton>
Ah, sorry. I see.

[04:11:07.0047] <bakkot>
> <@michaelficarra:matrix.org> the grammar sees source post-ASI

oh, hm. that's a fair point.

[04:11:25.0474] <rbuckton>
> <@michaelficarra:matrix.org> the grammar sees source post-ASI

ish. true for most parsers, but the spec says "parse it. if parse fails, see if it parses after inserting `;`)"

[04:11:34.0225] <rbuckton>
> <@michaelficarra:matrix.org> the grammar sees source post-ASI

 * ish. true for most parsers, but the spec says "parse it. if parse fails, see if it parses after inserting `;`"

[04:11:53.0067] <Michael Ficarra>
yes, it would have to be otherwise invalid

[04:12:05.0468] <bakkot>
in this case it would be though

[04:12:06.0505] <rbuckton>
the grammar has to see source pre-ASI for ASI to work.

[04:12:20.0457] <Michael Ficarra>
yeah

[04:12:51.0675] <rbuckton>
`EOF` isn't defined in the spec though.

[04:13:32.0891] <Michael Ficarra>
I thought we had a way to assert on end of input

[04:16:09.0710] <rbuckton>
"end of input" is mentioned only once in terms of White Space. We also have something like "parsed...with no tokens left over" for cover grammars

[04:17:07.0791] <rbuckton>
and "with no tokens left over" is mentioned in The Syntactic Grammar as well when discussing the Script and Module goals.

[04:18:07.0297] <rbuckton>
"end of the input stream" is mentioned in the rules for ASI

[04:18:25.0488] <bakkot>
the EOF isn't necessary because of the ASI thing

[04:18:34.0948] <bakkot>
strike it from my suggestion

[04:18:53.0541] <rbuckton>
Also, `]` should be allowed as well.

[04:18:56.0415] <bakkot>
if you had `a ?? throw b` at the end of the program, ASI would add a `;` so it would parse

[04:19:03.0750] <bakkot>
yup, agreed on `]`

[04:19:20.0757] <rbuckton>
And maybe `{` for something like `class extends a || throw b {`?

[04:19:22.0539] <bakkot>
also should add `:`

[04:19:28.0600] <rbuckton>
for `case`?

[04:19:34.0146] <bakkot>
for `a ? throw b : c`

[04:19:49.0170] <bakkot>
might be easier to enumerate operators which should be disallowed instead, really

[04:20:05.0893] <rbuckton>
Ah, yes. but also `case`. There are a lot of tokens to consider and its possible that list would need to change if/when new syntax is added.

[04:20:11.0350] <bakkot>
yeah

[04:22:01.0107] <rbuckton>
Yeah, I think its easier to restrict to all of the infix operators, or maybe pull out part of _OtherPunctuators_ in the lexical grammar.

[04:32:12.0766] <rbuckton>
It helped to write the `using` implementation in engine262 when writing tests as a way to verify both the implementation and the test itself.

[04:32:50.0519] <Bradford Smith>
Does the current process call for reviewers specifically to review the test262 tests? And if so, are there published guidelines for how to review them?

[04:33:04.0920] <ryzokuken üá≥üá¥>
no, reviewers review the spec

[04:33:19.0402] <ryzokuken üá≥üá¥>
test262 tests are reviewed by test262 maintainers

[04:35:02.0265] <ptomato (at TC39, limited availability)>
stage 3 reviewers are hereby enthusiastically invited to review the tests, though!

[04:35:16.0016] <ptomato (at TC39, limited availability)>
it really helps the maintainers if the real experts on a proposal weigh in

[04:35:29.0656] <rbuckton>
Though I'd contributed to test262 in the past, I found it very difficult to get started on the tests for `using` as I found the documentation was somewhat lacking in terms of how to set up the environment, and I had trouble running the tests on Windows and had to use WSL. 

[04:36:16.0501] <ptomato (at TC39, limited availability)>
would you like to bring that up in #test262-maintainers:matrix.org and maybe contribute better documentation for that use case?

[04:36:51.0089] <rbuckton>
Plus there is a lot of hunting around to figure out what files you need to add to `includes: []` for some assertions. The experience of working with test262 in an editor like VSCode wasn't great. 

[04:37:34.0171] <rbuckton>
> <@pchimento:igalia.com> would you like to bring that up in #test262-maintainers:matrix.org and maybe contribute better documentation for that use case?

I can bring it up, but it would be hard to document myself if I don't actually have a strong grasp of what needs to be documented.

[04:37:45.0425] <ptomato (at TC39, limited availability)>
this is valuable feedback and I'd love to have a follow up on it

[04:39:02.0599] <rbuckton>
I forwarded the messages to the maintainers chat

[04:39:49.0994] <rbuckton>
What msaboff is saying is exactly why I wrote an implementation for engine262 to verify the tests themselves were accurate.

[04:40:28.0356] <bakkot>
I know michael used polyfills to exercise the iterator helpers tests

[04:46:40.0264] <littledan>
I think it's kinda inconsequential whether the reviews happen before or after tests are written, and it'd be fine to shift this later. I'd be uneasy about potentially weakening "Stage 3" which is why I like the numbering Michael used.

[04:48:46.0314] <Willian Martins>
Maybe stage 3 üî¥ and 3 üü¢?

[04:49:16.0752] <Andreu Botella>
Stage 3‚Å∫ and Stage 3‚Çã

[04:52:37.0431] <Jesse (TC39)>
3.-0 and 3.+0

[04:56:03.0757] <shu>
littledan: i don't think it is actually, it should happen before tests are written

[04:56:43.0622] <shu>
reviews can trigger non-implementation-motivated normative changes, no?

[05:00:27.0665] <littledan>
please advance the queue

[05:01:37.0346] <nicolo-ribaudo>
> <@littledan:matrix.org> I think it's kinda inconsequential whether the reviews happen before or after tests are written, and it'd be fine to shift this later. I'd be uneasy about potentially weakening "Stage 3" which is why I like the numbering Michael used.

Adding a stage before stage 3 makes stage 3 stronger, but not doing so doesn't make it weaker

[05:02:06.0016] <bakkot>
in my ideal world, implementations would start at stage 2.75, and would write tests, and then champions would do the work of getting those tests into test262 proper, and then get stage 3

[05:03:40.0997] <littledan>
not sure why my topic was converted to a reply and pushed up

[05:03:54.0834] <littledan>
I'd prefer to wait to raise this separate topic

[05:12:35.0806] <Rob Palmer>
We will take the photo on the mezzanine floor at 14:20

[05:20:46.0566] <Chris de Almeida>
Jesse (TC39): Michael Ficarra please let me know if you would indeed like to sacrifice the Decimal continuation for a continuation of the stage/process discussion

[05:24:18.0263] <Jesse (TC39)>
yes, sacrifice is OK

[05:27:51.0319] <Michael Ficarra>
I would accept additional time for the process topic

[05:29:57.0554] <HE Shi-Jun>
what diff between getUint8Clamped and getUint8 ?

[05:31:06.0625] <bakkot>
there is no difference

[05:33:41.0979] <Michael Ficarra>
they could literally be the same function object

[05:36:37.0425] <bakkot>
this proposal feels like a good reason for us to have introduced the "someone must explicitly second for it to advance"

[05:39:43.0713] <nicolo-ribaudo>
> <@michaelficarra:matrix.org> they could literally be the same function object

+1, like for `[][Symbol.iterator] === [].values`

[05:40:05.0888] <shu>
what is the .name

[05:40:14.0026] <nicolo-ribaudo>
I _think_ "value"

[05:40:16.0691] <nicolo-ribaudo>
 * I _think_ "values"

[05:40:26.0032] <shu>
`"getUint8(Clamped)"

[05:40:29.0596] <shu>
 * \`"getUint8(Clamped)"`

[05:40:38.0888] <Michael Ficarra>
we only have 1 choice there

[05:40:40.0013] <shu>
oh no i meant for the DataView methods

[05:40:57.0593] <Michael Ficarra>
since the non-clamped one already has a name

[05:41:04.0933] <shu>
boo

[05:46:11.0682] <HE Shi-Jun>
let's add a directive: "no coercing" üòÇ

[05:46:20.0139] <Michael Ficarra>
no need

[05:47:06.0036] <HE Shi-Jun>
 * let's add a directive: "no coercing" üòÇ for the old APIs

[05:52:06.0177] <Michael Ficarra>
omg that padStart one was disgusting

[05:53:10.0682] <Christian Ulbrich>
I'd prefer `'ky'.padStart(5, Number)`!

[05:59:30.0649] <Michael Ficarra>
I can see people relying on primitive-to-string conversion

[05:59:34.0684] <Michael Ficarra>
I know Java devs love it

[06:03:04.0525] <Christian Ulbrich>
I never used coercion for params and I would not let someone pass in a review, if there were to use it...

[06:09:20.0338] <Christian Ulbrich>
TypeScript types for WebAPIs are usually stricter, than the APIs is, i.e. they won't allow using types, that are actually "supported" by coercion.

[06:09:41.0729] <ryzokuken üá≥üá¥>
> <@michaelficarra:matrix.org> I can see people relying on primitive-to-string conversion

if I got a dime for every dependency that _required_ it

[06:11:39.0223] <Christian Ulbrich>
Although I have to say, that TypeScript is often too ambitious, dis-allowing `undefined` in some many places...

[06:12:39.0982] <Christian Ulbrich>
 * Although I have to say, that TypeScript is often too ambitious, dis-allowing `undefined` in many (WebAPI) places...

[06:13:57.0129] <rbuckton>
> <@christianulbrich:matrix.org> Although I have to say, that TypeScript is often too ambitious, dis-allowing `undefined` in many (WebAPI) places...

Do you have examples? IIRC, most of our DOM-specific libs are generated from WebIDL.

[06:14:31.0605] <Luca Casonato>
Anecdote here: a fun TypeScript case (WHATWG not TC39) on deciding when coercion is ok vs not ok. https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/1568

[06:14:40.0927] <Luca Casonato>
 * Anecdote here: a fun TypeScript case (WHATWG not TC39 api) on deciding when coercion is ok vs not ok. https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/1568

[06:20:43.0701] <Michael Ficarra>
so what do TypeScript developers use to convert String->Number?

[06:21:01.0551] <Michael Ficarra>
do they actually use the full variety of options as appropriate?

[06:21:06.0388] <Christian Ulbrich>
Hm. I kind have to retract my argument, having looked at my own code and blaming TypeScript, indeed I am using sth. like `parseFloat(value) < 5` and I do rely on `parseFloat(undefined)` returning `NaN` ... and `NaN < 5` being `false`...

[06:21:38.0694] <ljharb>
having parseFloat return NaN for a non-string input seems ok to me too tho

[06:22:12.0114] <Christian Ulbrich>
I think it returns `NaN` because `undefined` is _coerced_ into `'undefined'`:)

[06:23:04.0028] <ljharb>
right - but i think it would be reasonable to return `NaN` because it's not a string, as well, instead of throwing

[06:23:57.0726] <Christian Ulbrich>
this is somewhat related to stuff, that TS does not like comparing with `undefined`, which to me totally makes sense... and seemingly [not only me](https://github.com/microsoft/TypeScript/issues/45543)

[06:33:05.0816] <Jesse (TC39)>
do we document these kinds of things? Does this go, e.g., in the how-we-work document?

[06:33:54.0189] <Michael Ficarra>
yes, we've recently started documenting these sorts of things

[06:34:12.0346] <Michael Ficarra>
I'm sure Kevin will PR it after we're done

[06:34:14.0829] <ryzokuken üá≥üá¥>
would this be an invariant then?

[06:34:26.0273] <Michael Ficarra>
no

[06:34:41.0614] <ryzokuken üá≥üá¥>
I see, just a recommendation?

[06:34:49.0333] <Michael Ficarra>
https://github.com/tc39/how-we-work/pull/119

[06:34:52.0794] <Michael Ficarra>
a convention

[06:34:57.0192] <ryzokuken üá≥üá¥>
I see

[06:38:31.0952] <Christian Ulbrich>
rbuckton: I only skimmed through my code, at first glance I only found `HTMLInputElement['value']`, this is typed as `string`, where in reality‚Ñ¢ it also accepts `null` to reset the value... 

[06:41:00.0619] <littledan>
> <@michaelficarra:matrix.org> littledan: FRP?

I mean like generically, React and signals and all that stuff. I think FRP is in that space too but I haven't really looked into it.

[06:41:35.0829] <nicolo-ribaudo>
> <@christianulbrich:matrix.org> rbuckton: I only skimmed through my code, at first glance I only found `HTMLInputElement['value']`, this is typed as `string`, where in reality‚Ñ¢ it also accepts `null` to reset the value...

It also accepts `""` to reset the value, right?

[06:43:06.0362] <Christian Ulbrich>
> <@nicolo-ribaudo:matrix.org> It also accepts `""` to reset the value, right?

It certainly does not accept `undefined`, because this gets coerced to `'undefined'` and sets the value to `'undefined'`...

[06:43:46.0694] <shu>
bakkot: we got consensus for not rounding non-integral, right?

[06:45:27.0915] <shu>
bakkot: btw i would like to discuss the thing i put on the queue, which is while i'm happy with requiring explicit coercions, the coercions people will reach for is like, `String()` and `Number()` which create wrapper objects, and not incantations like `+""`. this is a performance footgun imo but maybe is not a big deal

[06:45:32.0985] <bakkot>
we did not

[06:45:43.0560] <shu>
oh i missed that, i thought we got consensus for rounding... huh

[06:45:48.0530] <shu>
there was opposition to that?

[06:45:54.0728] <bakkot>
sffc said he'd want more time to review implications for intl

[06:45:58.0294] <shu>
ah okay

[06:46:05.0346] <nicolo-ribaudo>
> <@shuyuguo:matrix.org> bakkot: btw i would like to discuss the thing i put on the queue, which is while i'm happy with requiring explicit coercions, the coercions people will reach for is like, `String()` and `Number()` which create wrapper objects, and not incantations like `+""`. this is a performance footgun imo but maybe is not a big deal

`String(a number)` does not create a wrapper object

[06:46:09.0455] <nicolo-ribaudo>
> <@shuyuguo:matrix.org> bakkot: btw i would like to discuss the thing i put on the queue, which is while i'm happy with requiring explicit coercions, the coercions people will reach for is like, `String()` and `Number()` which create wrapper objects, and not incantations like `+""`. this is a performance footgun imo but maybe is not a big deal

 * `String(a number)` does not create a wrapper object, right?

[06:46:13.0588] <bakkot>
`String()` and `Number()` don't create wrapper objects though

[06:46:18.0086] <bakkot>
only `new String`

[06:48:32.0053] <shu>
oh the [[Call]] behavior is different!

[06:48:32.0972] <shu>
awesome

[06:48:42.0250] <shu>
i mean not awesome for me, embarrassing for me to have forgotten that

[06:48:44.0996] <shu>
but great, no concern then

[06:51:23.0796] <Ashley Claymore>
all that C++ you're writing pushing out the JS again

[06:53:38.0782] <Michael Ficarra>
honestly, changing from stage numbers to stage names seems like a good idea

[06:53:50.0041] <Michael Ficarra>
where the names are the things that each stage is meant to signal

[06:54:09.0384] <shu>
i don't disagree

[06:54:19.0924] <shu>
but you're opening yourself up to like, an order of magnitude more hours of bikeshedding

[06:54:25.0845] <Chris de Almeida>
if we're bikeshedding the stage name, 2 splitting into to 2.a, 2.b seems better to me than 2, 2.75

[06:54:36.0807] <littledan>
I think Rust went through this detailed bikeshedding exercise at some point

[06:54:47.0060] <ryzokuken üá≥üá¥>
well, we technically have names

[06:54:49.0221] <littledan>
2.b doesn't sound enough like "almost 3" to me

[06:54:57.0238] <Chris de Almeida>
why does it need to?

[06:55:04.0176] <shu>
because it is supposed to be almost 3

[06:55:10.0893] <ryzokuken üá≥üá¥>
strawperson/proposal/draft/...

[06:55:21.0125] <Chris de Almeida>
2.z

[06:55:23.0962] <Michael Ficarra>
Chris de Almeida: we've had a request for that

[06:55:26.0774] <bakkot>
so that we don't argue about design decisions

[06:55:33.0543] <eemeli>
I've been mostly posting this on TDZ, but I seriously think we should go with stages 1, 2, e, œÄ, 4.

[06:55:45.0103] <bakkot>
the reason to signal "almost stage 3" is because we want to explicitly signal "do not keep arguing about design"

[06:55:55.0189] <eemeli>
Then we'd have two three-ish stages.

[06:56:00.0580] <ryzokuken üá≥üá¥>
I think renaming stage 3 is going to be hard

[06:56:08.0092] <Michael Ficarra>
eemeli: no

[06:56:10.0365] <ryzokuken üá≥üá¥>
a lot of things out there use that 

[06:56:20.0227] <ryzokuken üá≥üá¥>
they might not depend as much on lower stages

[06:56:36.0430] <ryzokuken üá≥üá¥>
 * they might not depend as much on lower stages (like babel bundles IIRC?)

[06:59:56.0477] <sffc>
> <@bakkot:matrix.org> sffc said he'd want more time to review implications for intl

I'm a bit concerned about integral numbers because it is more likely to cause data-driven exceptions. Actually the realm of data-driven exceptions is something we should discuss in plenary.

[07:01:39.0009] <bakkot>
data-driven exceptions seem better than data-driven not-the-right-answer

[07:02:41.0288] <sffc>
There's a big difference between "not the right answer" and "best effort answer". In Intl and i18n we're very much driven by doing a best effort acknowledging that we can never be always exactly "right".

[07:04:19.0967] <bakkot>
I think for APIs which accept integers, passing a non-integral value is generally a programmer error, rather than being a case where there is only a best-effort answer

[07:05:05.0775] <bakkot>
and I generally think programmer errors should be program exceptions, rather than trying to get a best-effort result

[07:05:08.0713] <Michael Ficarra>
RE the "spiraling", the thing we need to keep in mind is that it's fine if we have *an* implementation during stage 2.75 (Dan suggested polyfills/transpilers, but it can also be an engine), it's just the idea is to avoid recommending for general implementation, which is where that aggregate work is extremely high

[07:05:10.0286] <ljharb>
a best-effort answer doesn't necessarily mean you can't restrict inputs

[07:05:19.0819] <ljharb>
it just means the output doesn't have to be perfect

[07:08:29.0090] <rbuckton>
> <@christianulbrich:matrix.org> rbuckton: I only skimmed through my code, at first glance I only found `HTMLInputElement['value']`, this is typed as `string`, where in reality‚Ñ¢ it also accepts `null` to reset the value...

It appears that, while we handle `[LegacyNullToEmptyString]` on method parameters, we don't seem to handle it for properties.

[07:10:29.0724] <shu>
> <@sffc:mozilla.org> There's a big difference between "not the right answer" and "best effort answer". In Intl and i18n we're very much driven by doing a best effort acknowledging that we can never be always exactly "right".

if "correctness" is generally not a design principle in Intl and that domain, and it's instead "approximation", then i can see where you're coming from

[07:10:47.0831] <shu>
for 262 at least "approximation" is most definitely not the design principles for new APIs

[07:12:53.0438] <rbuckton>
> <@christianulbrich:matrix.org> rbuckton: I only skimmed through my code, at first glance I only found `HTMLInputElement['value']`, this is typed as `string`, where in reality‚Ñ¢ it also accepts `null` to reset the value...

Filed as https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/1596. If you have other cases, I encourage you to report them at https://github.com/microsoft/TypeScript-DOM-lib-generator or http://github.com/microsoft/TypeScript.

[07:15:06.0914] <bakkot>
shu: I do think that, given that the committee is receptive to breaking with precedent for coercing stuff in at least some cases, it is maybe worth asking to break with precedent for any new TA things

[07:15:17.0521] <bakkot>
to avoid the awful user code coercions

[07:15:30.0778] <shu>
yeah, the TA problem is narrowly solvable

[07:15:44.0170] <shu>
it'd be _nice_ to solve it generally but i'll take any improvement obv

[07:16:01.0239] <bakkot>
on the "coercing objects to strings is useful" point, one of the things I will ask about next time I bring this up is, just don't coerce objects _to number_, and continue coercing to string

[07:16:24.0316] <bakkot>
since, granted, there is some utility to coercing things like URL to string

[07:16:40.0081] <bakkot>
(even if I personally would prefer people do it explicitly)

[07:16:58.0563] <shu>
i'd also take "built-in toString methods only" but that's not that nice and hurts polyfills

[07:17:44.0520] <Christian Ulbrich>
rbuckton: Quite the service! Thanks for creating the bug. From my mind, there were other issues, I'll report them once I have some more time, currently only ~30 `//@ts-ignore` in our code base, not too bad. The other thing, was with `NodeListOf` being _iteratable_ (sic!)  but I have to give this a more thorough look on _modern_ TypeScript (we are currently at `4.6.2`. 

[07:18:47.0824] <shu>
actually let's generalize that, it'd be cool to have the dynamic extent of argument + receiver coercion to throw on user code, even if they continue to coerce

[07:21:10.0927] <sffc>
> <@shuyuguo:matrix.org> for 262 at least "approximation" is most definitely not the design principles for new APIs

I think this is an appropriate line to draw

[07:23:10.0281] <bakkot>
> <@ljharb:matrix.org> a best-effort answer doesn't necessarily mean you can't restrict inputs

as a concrete example: "give me the best 2 candidate locales" is a well-posed question with only an approximately correct answer. "give me the best 2.5 candidate locales" is an ill-posed question, just as much as "give me the best NaN candidate locales" is. throwing is the right response to ill-posed questions.

[07:25:03.0712] <sffc>
I'm happy to iterate on the language surrounding when ToIntegerIfIntegral should be used versus truncation

[07:56:50.0744] <Richard Gibson>
I'm having difficulty in coming up with any scenario where we would prefer truncation other than for consistency with existing APIs. It's just such a mess that e.g. `-0.2` is accepted as a non-negative integer or `max + 0.1` is rejected where `max - 1 + 0.1` is accepted as equivalent to `max - 1`.

[08:07:34.0324] <sffc>
> <@gibson042:matrix.org> I'm having difficulty in coming up with any scenario where we would prefer truncation other than for consistency with existing APIs. It's just such a mess that e.g. `-0.2` is accepted as a non-negative integer or `max + 0.1` is rejected where `max - 1 + 0.1` is accepted as equivalent to `max - 1`.

So you have every right to disagree with this example, but something like truncating "123.4 minutes" to "123 minutes" in Intl.DurationFormat is not necessarily bad, especially if (and again, people are welcome to disagree) we have a path toward making the fractional digits work in the future.

[08:34:55.0752] <Richard Gibson>
I definitely do disagree; that's a clear case where the truncation is **bad** because "123.4 minutes" has a valid interpretation that is silently discarded in favor of equivalence with "123 minutes", making future support for respecting the fractional part more difficult. This is an analogue of the motivating use case in Temporal Durations, which couldn't lean on the fuzziness inherent to ECMA-402 formatting (that _might_ leave a sufficient gap for future extension, but then again might not) as justification.

[08:43:03.0413] <Richard Gibson>
 * I definitely do disagree; that's a clear case where the truncation would be bad because "123.4 minutes" has a valid interpretation that should not be silently discarded in favor of equivalence with "123 minutes", making future support for respecting the fractional part more difficult. This is an analogue of the motivating use case in Temporal Durations, which couldn't lean on the fuzziness inherent to ECMA-402 formatting (that _might_ leave a sufficient gap for future extension, but then again might not) as justification.

[08:53:28.0875] <sffc>
The counter-point is that if we were to enable that type of extension in the future, it's not inherently bad that older engines operate with the approximate behavior. Many programmers will not think about catching the exception in older engines, causing those browsers to needlessly break when they would otherwise get close-but-not-quite-right output.

[08:54:18.0374] <sffc>
As an example, we executed on this successfully when we deployed the "interpret strings as decimals" change in Intl.NumberFormat.prototype.format.

[09:51:53.0649] <TabAtkins>
I'm with sffc here that this is a very debatable case that has a reasonable argument for truncation. (But I'm generally for the "stop coercing/truncating everywhere" proposal.)

[09:58:29.0058] <TabAtkins>
> <@bakkot:matrix.org> just that I think the community would be better served by us focusing on stdlib stuff over syntax, at the margin

I don't think we need to set these against each other, but I do agree we need *way* more stdlib investment in this group. (And I need to finish my own contribution to that, the seeded-random proposal.)

[10:11:42.0020] <TabAtkins>
The justification of "make everything method-chainable" is still valid. It would be good to do another review of everything trying to do similar things. But I don't think protocols clash in any meaningful way.

[10:12:35.0319] <TabAtkins>
Like if you *squint* they're both doing similar things (playing in the method space, without messing with prototypes) but protocols use-case, justifications, and abilities are quite distinct.


2023-07-14
[02:54:50.0361] <HE Shi-Jun>
A question about `import defer`. Currently, a module include top level-await will not be deferred. Could we allow implementations do some static analysis and optimization to defer the sync part (code after the last `await` expression) ?

[03:45:15.0747] <Ashley Claymore>
Wouldn't that break run until completion semantics?

[03:45:48.0760] <Ashley Claymore>
Maybe not if it, as you say,  doesn't start to run 

[03:46:30.0487] <Ashley Claymore>
I'm not sure how big a saving g that would add, just the last part of one module 

[03:47:20.0037] <Ashley Claymore>
* I'm not sure how big a saving that would add, just the last part of one module

[03:49:57.0507] <Ashley Claymore>
Interesting idea though, I'd love to try it out on our version of `import defer` at Bloomberg but our equivalent of TLA isn't as statically analysable so not really possible 

[04:11:07.0057] <Ashley Claymore>
* I'm not sure how big a saving that would add, just the last part of the N preloaded async modules 

[08:00:43.0789] <rbuckton>
The tricky part of "defer the sync part" is that TLA can be conditional, with the final `await` sitting behind a branch that might not be evaluated. You cannot know whether it will be until the condition is evaluated. Which part, then, is the sync part?

[09:50:14.0604] <saminahusain>
Great meeting and dinner!


2023-07-16
[23:08:53.0087] <snek>
cool to see engine262 getting more mind share. i guess that project for evaluating the spec text didn't catch on?

[00:15:22.0153] <Ashley Claymore>
esmeta? It's run as part of the 262 spec CI https://github.com/tc39/ecma262/blob/main/.github/workflows/esmeta-typecheck.yml

[00:16:21.0124] <Ashley Claymore>
also ‚ù§Ô∏è engine262

[01:04:27.0412] <bakkot>
strictly speaking we only run the typechecker part of esmeta, not the actual evaluator

[04:23:47.0701] <littledan>
Same goes for call syntax, I think(which I previously made the same overlap comment about)

[09:09:32.0667] <Richard Gibson>
relevant: https://jschoi.org/22/es-dataflow/#five-proposals

[09:33:00.0537] <Mathieu Hofman>
I have been meaning to fix this for a while. I actually started rewriting the asyncGC helper and the tests, but I really don't have much time to dedicate to this.

[09:34:07.0656] <Mathieu Hofman>
If someone is interested in taking over I can try to cleanup my old local experiment. Some tests do need to be rewritten to accommodate 

[12:54:11.0205] <jschoi>
Would any delegate be able to sponsor me as an invited expert (https://github.com/tc39/how-we-work/blob/main/invited-expert.md#joining-process) so I can continue championing my proposals? I‚Äôm leaving Indiana University, a TC39 member.

[12:54:40.0238] <jschoi>
 * Would any delegate be able to sponsor me as an invited expert (https://github.com/tc39/how-we-work/blob/main/invited-expert.md#joining-process) so I can continue championing/co-championing proposals? I‚Äôm leaving Indiana University, a TC39 member.

[14:44:32.0655] <littledan>
Where are you going to, jschoi?

[14:57:09.0612] <jschoi>
littledan: University of Utah! :¬†)


2023-07-17
[19:22:09.0294] <snek>
> <@jschoi:matrix.org> Would any delegate be able to sponsor me as an invited expert (https://github.com/tc39/how-we-work/blob/main/invited-expert.md#joining-process) so I can continue championing/co-championing proposals? I‚Äôm leaving Indiana University, a TC39 member.

maybe see if openjs foundation will take you as a delegate? https://github.com/openjs-foundation/standards cc ljharb 

[19:40:35.0859] <jschoi>
snek: Thanks for that pointer; I‚Äôll reach out to them and see if I can join as a delegate.

(In the meantime, if anyone would be willing to sponsor me as an invited delegate, let me know in parallel. Thanks!)

[05:30:31.0985] <ptomato (limited availability)>
I can't commit yet to taking over, but I'd be interested in seeing the state of your branch Mathieu Hofman 

[05:31:36.0311] <ptomato (limited availability)>
it looks like the majority of tests using the `async-gc` helper are indeed tests of `cleanupSome`. there is one for `FinalizationRegistry()`, one for `FinalizationRegistry.p.unregister()`, and one for `WeakRef.p.deref()`.

[05:32:10.0123] <ptomato (limited availability)>
so, if `cleanupSome` were withdrawn, we'd need to fix those three tests

[06:22:56.0506] <littledan>
Maybe the University of Utah could join, also? It doesn't cost anything. In general, I do think the Invited Expert system would be a good fit for you, given your past contributions.

[07:58:37.0366] <Chris de Almeida>
University of Utah joining would be ideal, but could take some time for that process.  IE is a reasonable stopgap to ensure continuity of access to GH resources, etc

[10:32:03.0880] <Chris de Almeida>
are any of the three `enum` proposals being substantively pursued at this point?

[10:32:47.0155] <Jack Works>
afaik no

[10:33:23.0668] <Jack Works>
I don't have time to do all the things üò≠üò≠üò≠

[10:33:39.0242] <Chris de Almeida>
there seems to be a theme üôÇ

[10:34:02.0297] <Kris Kowal>
> <@jackworks:matrix.org> I don't have time to do all the things üò≠üò≠üò≠

big feel‚Ñ¢

[10:35:48.0221] <Chris de Almeida>
- situation: there are two enum proposals
- two?  ridiculous?  we need to develop one universal enum proposal that covers everyone's use cases.
- yeah!
- situation: there are three enum proposals

[10:36:24.0301] <Chris de Almeida>
 * - situation: there are two enum proposals
- two?  ridiculous!  we need to develop one universal enum proposal that covers everyone's use cases.
- yeah!
- situation: there are three enum proposals

[11:47:27.0958] <bakkot>
Michael Ficarra: btw in the meeting you were asking about my claim that the modal JS developer uses typescript; here's some cites:

- https://2022.stateofjs.com/en-US/other-tools/#javascript_flavors (click "percent of respondants")
- https://stackoverflow.blog/2023/06/13/developer-survey-results-are-in/ - 64% of respondents say they use JS, 39% say they use TS. it's pick-all-you-use, so probably most of the people who clicked TS also clicked JS.

[11:48:20.0216] <bakkot>
though the actual claim I wanted to make was "many people have adopted typescript, which will have forced them to learn to do explicit coercions, and that does not seem to have resulting in confusion", and this doesn't rely on TS being a majority, just a large fraction

[11:48:33.0070] <bakkot>
 * though the actual claim I wanted to make was "many people have adopted typescript, which will have forced them to learn to do explicit coercions, and that does not seem to have resulted in confusion", and this doesn't rely on TS being a majority, just a large fraction

[12:12:48.0825] <Michael Ficarra>
yeah, I got that from the conversation

[12:12:59.0251] <Michael Ficarra>
apparently TS users are already commonly doing these casts

[12:13:26.0256] <Michael Ficarra>
I'd love to see data on the string-to-number conversions

[12:13:59.0379] <Michael Ficarra>
like what are they doing most commonly and are these actually leading to undesired behaviour for some inputs

[12:34:50.0318] <Chris de Almeida>
some further thoughts on the coercion of primitives:

- I do not _like_ the conversion of 1,0 to boolean (and similar coercions), but we should not break with long-standing precedent for truthiness/falsiness evaluation.  (presuming the `Stop coercing between primitive types` was meant to include boolean coercion, e.g. in params for new methods and conditions)
- I think `"true"` and `"false"` should be fair game for implicit conversion to boolean, in the same vein as I was suggesting `"2"` and `"3"` should be ok for expected integral values

[12:56:18.0208] <TabAtkins>
`"true"` and `"false"` both convert to `true` today, we absolutely cannot change that.

[13:03:18.0578] <bakkot>
I am mostly OK with coercing strings and numbers to booleans. I am less OK with coercing booleans to strings and numbers. Thoughts on that direction?

[13:04:06.0235] <bakkot>
> <@tabatkins:matrix.org> `"true"` and `"false"` both convert to `true` today, we absolutely cannot change that.

the proposal wouldn't be to change that for existing code, just to say that in _future_ boolean-taking APIs, passing any string where a boolean is expected would be a TypeError, rather than implicitly coercing `"false"` to `true`.

[13:04:38.0160] <TabAtkins>
right

[13:32:49.0412] <Chris de Almeida>
> <@bakkot:matrix.org> I am mostly OK with coercing strings and numbers to booleans. I am less OK with coercing booleans to strings and numbers. Thoughts on that direction?

that seems reasonable to me, but I'm struggling to think of actual examples of where that would be desirable or expected 

[13:33:06.0335] <Chris de Almeida>
> <@bakkot:matrix.org> I am mostly OK with coercing strings and numbers to booleans. I am less OK with coercing booleans to strings and numbers. Thoughts on that direction?

 * that seems reasonable to me, but I'm struggling to think of actual examples of where that would be desirable or expected (boolean to string or number)

[16:08:07.0181] <TabAtkins>
The only use-case that's remotely reasonable is treating bools as 0 and 1 for bitflag purposes.

[16:08:41.0149] <TabAtkins>
For strings tho, no, never.


2023-07-18
[08:04:37.0991] <littledan>
well, cleanupSome is at Stage 2, so those need to be fixed anyway

[08:04:54.0800] <littledan>
it was taken out of the WeakRef/FinalizationRegistry proposal a while ago

[09:55:06.0477] <bakkot>
> <@tabatkins:matrix.org> The only use-case that's remotely reasonable is treating bools as 0 and 1 for bitflag purposes.

and that's something you'd want to do with syntax (`(prop << 2) | prop2`, etc), not with boolean-taking APIs, so even that use case doesn't imply boolean-taking APIs ought to accept numbers

[10:55:50.0916] <TabAtkins>
yes, i was replying to "boolean to string or number"

[10:56:24.0499] <TabAtkins>
(twice now you've replied to me about the opposite direction of what i was talking about when responding to chris - you might want to read the convo a little more closely ^_^)

[10:59:39.0036] <bakkot>
> <@tabatkins:matrix.org> The only use-case that's remotely reasonable is treating bools as 0 and 1 for bitflag purposes.

 * and that's something you'd want to do with syntax (`(prop << 2) | prop2`, etc), not with number-taking APIs, so even that use case doesn't imply number-taking APIs ought to accept booleans

[10:59:39.0984] <bakkot>
sorry, I got my nouns switched in previous comment; fixed now

[10:59:50.0964] <bakkot>
didn't misread you, just misspoke

[11:00:32.0341] <TabAtkins>
ah yes, then, still agree that outside of that operator-mangling case there's really no argument for a bool to coerce to a number

[11:00:40.0296] <bakkot>
though the earlier comment, I don't see how it's the opposite direction of what you said?

[11:01:33.0767] <TabAtkins>
maybe i'd misread what Chris said in "I think "true" and "false" should be fair game for implicit conversion to boolean"

[11:01:51.0572] <TabAtkins>
i thought they were implying that converting "true" and "false" to true and false was fair game?

[11:02:07.0477] <TabAtkins>
(which i oppose)

[11:05:25.0919] <bakkot>
ok, so you meant "we can't make `"false"` coerce to `false` in future boolean-taking APIs", rather than "we can't change how `"false"` is handled in existing APIs", which is how I read you

[11:06:05.0303] <bakkot>
anyway yes agreed that `"false"` should not coerce to `false` in any new or future API

[11:08:33.0204] <bakkot>
incidentally, that reminds me of this excellent example of why coercing strings to booleans is a bad idea: https://github.com/tc39/proposal-intl-numberformat-v3/pull/107

[11:09:08.0249] <bakkot>
API was being expanded to take more than two values, but people were already passing strings, and some people were passing the string `"false"` and (apparently) relying on that being `true`

[11:09:29.0321] <bakkot>
leading to this lovely bit of spec:
```
1. NOTE: For historical reasons, the strings *"true"* and *"false"* are treated the same as the boolean value *true*.
```

[11:09:35.0856] <bakkot>
 * leading to this lovely bit of spec:

> 1. NOTE: For historical reasons, the strings *"true"* and *"false"* are treated the same as the boolean value *true*.


[11:09:46.0404] <Chris de Almeida>
yeah that's annoying

[11:12:19.0129] <Chris de Almeida>
I walk back what I said about boolean strings being implicitly converted

[11:13:06.0292] <Chris de Almeida>
especially as it would fly in the face of my first point about existing behavior for conditions re: truthy/falsey

[12:21:36.0724] <rbuckton>
Given how long its been since I last presented `throw` expressions, one of my current stage 2 reviewers is no longer a delegate and is unable to review, while the other has minimal involvement in TC39 at this time. I plan to bring back `throw` expressions at the next plenary meeting given the discussion at the last meeting, and will ask for new reviewers at that time. If anyone is willing to review the changes that bakkot and I discussed last week, I'd appreciate it. I'd be especially grateful if you would be willing to volunteer as a reviewer at the next plenary as well.

The PR for the relevant changes to the `throw` expressions proposal can be found here: https://github.com/tc39/proposal-throw-expressions/pull/17

The relevant change since this was last proposed for advancement from Stage 2 to Stage 3 is the addition of a new lookahead restriction at the end of the expression that would disallow any trailing binary operator or `?` so that `throw` expressions would not require parentheses in most places, but would disallow syntax that would have different semantics compared to `throw` as a statement.

My hope is that I can propose advancement to Stage 3 at the next plenary assuming I can find willing volunteers for reviewers in advance of the meeting.

[16:00:10.0918] <davethegr8>
Did anyone happen to make a summary of what advanced from last plenary?

[16:24:02.0399] <Chris de Almeida>
> <@davethegr8:matrix.org> Did anyone happen to make a summary of what advanced from last plenary?

Rob Palmer's twitter and Hemanth's blog

[16:24:27.0591] <davethegr8>
> <@softwarechris:matrix.org> Rob Palmer's twitter and Hemanth's blog

nice thanks!

[16:24:38.0497] <Chris de Almeida>
https://dev.to/hemanth/updates-from-the-97th-tc39-meeting-1cnj

[16:25:02.0788] <Chris de Almeida>
https://twitter.com/robpalmer2


2023-07-28
[14:51:20.0150] <bakkot>
proposal to add observables: https://twitter.com/domfarolino/status/1684921351004430336

[14:51:29.0958] <bakkot>
specifically to add them to HTML, instead of JS

[14:51:33.0062] <bakkot>
for... reasons

[14:52:03.0360] <ljharb>
reasons that are unclear; i've recommended it be brought back to tc39 on the repo

[14:52:33.0226] <bakkot>
well, I mean

[14:53:03.0015] <bakkot>
the reason is almost certainly that he thinks it is not going to get through tc39 in any reasonable timeframe, and wants it in the platform, so he is routing around tc39

[15:09:45.0748] <snek>
is there anything in the js spec that would use observables

[15:10:00.0783] <snek>
we really need a more robust standard library

[15:10:21.0267] <snek>
i guess Atomics.waitAsync is the only thing that is ilke an "event"

[15:34:46.0393] <bakkot>
we really really need a more robust standard library yes

[16:04:01.0261] <TabAtkins>
Yeah, the "just do it in DOM" is almost certainly an "avoid the tc39 logjam which is extremely likely to result" thing. Plus as @snek said, DOM has a use-case immediately (event listeners), while JS itself doesn't.

[16:08:46.0666] <Kris Kowal>
My 2¬¢ is that ES already implies the shape of an Observable in the form of sync generator functions (dual to their use as iterators) and that we may as well make it official.
```
Observable {
  next(value: T) => void;
  return(value: T) => void;
  throw(error: unknown) => void;
}
```

[16:10:32.0252] <Kris Kowal>
Once @bakkot‚Äôs iterator helpers settle, there‚Äôll be plenty of precedents on which to triangulate.

[16:18:33.0392] <bakkot>
(Michael Ficarra's and Yulia's iterator helpers, strictly speaking; I just helped out)

[16:18:47.0394] <bakkot>
also iterator helpers have settled and are shipping in Chrome

[16:18:52.0905] <bakkot>
though we'll want to add some more stuff

[16:18:58.0327] <Rob Palmer>
Bradley suggests there may be a performance advantage of implementing this at a higher level.

https://twitter.com/bradleymeck/status/1685008883385839616

[16:19:00.0363] <bakkot>
or at least I will

[16:19:12.0289] <bakkot>
(the observable proposal linked above does indeed draw on iterator helpers for its combinators)

[16:20:31.0816] <bakkot>
 * also iterator helpers have settled and are shipping in Chrome (unstable - stable on Sep 12)

[16:34:49.0614] <snek>
> <@kriskowal:matrix.org> My 2¬¢ is that ES already implies the shape of an Observable in the form of sync generator functions (dual to their use as iterators) and that we may as well make it official.
> ```
> Observable {
>   next(value: T) => void;
>   return(value: T) => void;
>   throw(error: unknown) => void;
> }
> ```

isn't the point of observables that they're push instead of pull? so no next/return/throw methods

[16:35:22.0702] <Kris Kowal>
Those are in fact push methods if you look closely.

[16:35:47.0821] <snek>
oh i see

[16:35:48.0360] <snek>
lol

[16:37:11.0714] <Kris Kowal>
I wrote a thing about this about nine years ago. https://github.com/kriskowal/gtor

[16:37:30.0363] <snek>
oh you wrote that

[16:37:35.0171] <snek>
small world as always

[16:40:07.0003] <Kris Kowal>
I do intend to dust it off some day since async iterators actually exist now.


2023-07-29
[18:15:24.0355] <ljharb>
i love gtor

[20:02:20.0416] <shu>
what a delightful graphic

[20:02:41.0742] <shu>
i feel like those red joins can be made to work if you press both sides hard enough

[20:03:14.0215] <shu>
the groverhaus of data flow composition, if you will

[00:07:16.0114] <snek>
this graphic is cool but makes absolutely no intuitive sense to me


2023-07-31
[10:12:14.0050] <Kris Kowal>
(It‚Äôs to be the final slide of a long deck, which is to say: yes.)

[10:15:31.0415] <Kris Kowal>
But, in short, green plugs fitting in sockets means that the left can be lifted to above, e.g,, by X.from(y).

