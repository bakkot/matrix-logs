2023-07-05
[02:04:16.0414] <Rob Palmer>
[The September Tokyo plenary invite](https://github.com/tc39/Reflector/issues/499) is now posted on the Reflector.

If anyone needs support on visas (e.g. generating an invite letter from the host), please let me know.  It is just under 12 weeks away.

[04:56:12.0750] <littledan>
Note that we are working on a community event the evening before, on the 25th.

[07:20:55.0627] <peetk>
oops i didn't see this before, thanks for this! i actually didn't mean to include that slide, ha!

[12:13:57.0838] <Chris de Almeida>
https://github.com/tc39/agendas/pull/1423

‚òùÔ∏è this is a low-stakes change, but would be nice to get some more blessings on it


2023-07-06
[01:59:18.0773] <Jack Works>
https://docs.google.com/presentation/d/1m5R5J98W6adegghgkAlbSuFgAYJDT52yyFVdAqLjm00/edit#slide=id.geaea8d83af_0_4

[01:59:27.0695] <Jack Works>
https://github.com/tc39/proposal-iterator.range/issues/60
https://tc39.es/proposal-iterator.range/#sec-create-numeric-range-iterator

[01:59:35.0049] <Jack Works>
also in Iterator.range

[10:01:29.0622] <TabAtkins>
https://github.com/tc39/proposal-integer-and-modulus-math appears to have Issues turned off so I can't comment on it. littledan ?

[10:20:05.0849] <ljharb>
they're on afaict

[10:20:12.0632] <ljharb>
 * they're on afaict - https://github.com/tc39/proposal-integer-and-modulus-math/issues

[10:20:26.0139] <ljharb>
 * TabAtkins: they're on afaict - https://github.com/tc39/proposal-integer-and-modulus-math/issues

[10:21:04.0036] <TabAtkins>
Wth, nothing was there on my desktop


2023-07-09
[05:06:20.0083] <nicolo-ribaudo>
Do we already have a matrix room for the in-person participants to the meeting?

[05:09:04.0578] <Jack Works>
I don't think so

[05:15:50.0048] <Rob Palmer>
Please create one, Nicolo! 

[10:43:59.0133] <Michael Ficarra>
nicolo-ribaudo: can you link the room here or send me an invite?

[10:55:31.0958] <nicolo-ribaudo>
You already joined it some hours ago üòÖ

[11:09:18.0673] <Michael Ficarra>
I am so confused

[11:09:52.0993] <Michael Ficarra>
I have been in transit for far too long

[11:11:37.0939] <Michael Ficarra>
I literally thought I imagined that lmao


2023-07-10
[00:47:17.0133] <rkirsling>
wait 10am in Oslo is 5pm in Tokyo?

[00:47:19.0423] <rkirsling>
wild

[03:50:50.0254] <dminor>
Sorry if this is a basic element/matrix question, but how do I join the TC39 space, like the thing that organizes all of the TC39 rooms into one view?

[03:51:45.0811] <nicolo-ribaudo>
https://matrix.to/#/#tc39-space:matrix.org try this

[03:51:55.0289] <nicolo-ribaudo>
https://matrix.to/#/#tc39-space:matrix.org

[04:30:05.0188] <dminor>
Well, it looks like that should work, but my element client just spins on `loading` for 30 minutes :/ I'll try again later.

[05:51:59.0214] <Rob Palmer>
Is anyone available to dial into zoom to help confirm AV in 20 mins time? 

[06:00:12.0717] <Ashley Claymore>
I'll try the zoom from the hotel Wi-fi

[06:08:35.0032] <Rob Palmer>
Thanks, Ashley

[06:10:14.0035] <Ashley Claymore>
ping me a link when you're ready

[06:54:05.0941] <dminor>
Works now, thanks for the help :)

[15:42:13.0216] <rbuckton>
Chairs: Any concern if I extend the timebox for the Explicit Resource Management update by 15 minutes to cover a suggestion that came up last week? The schedule currently calls for a 15 minute underflow on the day/time I'm currently scheduled to present. If that's not feasible, I'll see what I can squeeze in in the time I have available and offer to discuss further with interested parties after the plenary.


2023-07-11
[18:25:52.0330] <Chris de Almeida>
rbuckton: you got it 

[00:31:33.0476] <Rob Palmer>
The sign-in form is now posted if you wish to dial into the Zoom for today's plenary:  https://github.com/tc39/Reflector/issues/473

[00:49:58.0332] <Rob Palmer>
Please could someone attempt dial in so we can confirm AV is working

[01:01:52.0052] <Jack Works>
it's working

[01:02:02.0596] <Jack Works>
 * it's working (zoom web)

[01:18:25.0714] <bakkot>
huh, "OramaSearch" is new to me; any delegates from them here today?

[01:18:36.0784] <littledan>
Michele Riva is the delegate, I think?

[01:18:45.0192] <ryzokuken (‚úàÔ∏è to üá≥üá¥)>
yeah

[01:18:52.0250] <ryzokuken (‚úàÔ∏è to üá≥üá¥)>
it's a new org

[01:20:03.0996] <Jack Works>
i found the voice quality is bad... i need more effort to heard what are the meetings talking about

[01:28:58.0433] <Rob Palmer>
Jack Works: is it one person's voice quality?

[01:31:46.0692] <Jack Works>
> <@robpalme:matrix.org> Jack Works: is it one person's voice quality?

it's the in-person one

[01:32:59.0612] <Rob Palmer>
The whole room is "hot".  Meaning all mics on the whole time.  So we need everyone to avoid noise unless they are speaking, e.g. placing cups down gently.

[01:34:37.0740] <Christian Ulbrich>
Rob Palmer: Although it would be possible to mute each mic directly, because they have a direct mute button.

[01:35:40.0179] <Rob Palmer>
That is a good point - lets try using that

[01:41:53.0253] <littledan>
Yeah, this does look nicer! Thanks editors

[01:44:57.0772] <bakkot>
tcq does indeed appear to be down

[01:45:04.0842] <bakkot>
chaos :(

[01:46:45.0808] <Michael Ficarra>
I don't even know what to do without TCQ anymore

[01:47:12.0593] <Michael Ficarra>
we are now 100% dependent

[01:47:13.0374] <nicolo-ribaudo>
A google doc with someone manually sorting the items by priority?

[01:47:54.0823] <Bradford Smith>
current discussion is not audible remotely

[01:48:30.0154] <Christian Ulbrich>
Sorry! We forgot to unmute; it was about missing conclusions.

[01:49:42.0120] <Christian Ulbrich>
Just give us a nod and we will signal, unmute.

[01:52:40.0196] <bakkot>
is TCQ still just running off of some Azure account Brian is expensing?

[01:54:16.0507] <Christian Ulbrich>
bakkot: Looks so -> https://github.com/bterlson/tcq/blob/b5be1287a6843f24dc570c1d951d1c26ac566d66/src/server/db.ts#L1C14-L1C18

[01:55:49.0783] <Michael Ficarra>
why is #783 being done as a needs-consensus PR and not a staged proposal?

[02:00:32.0459] <bakkot>
I don't think it's that useful to make things like this optional?

[02:00:41.0029] <bakkot>
at least not optional for web browsers

[02:00:50.0660] <bakkot>
as a programmer I am going to want to rely on their existence

[02:00:55.0438] <littledan>
+1

[02:01:11.0604] <bakkot>
and as a user I'm going to be annoyed if the page behaves differently in my browser than the one the developer was using

[02:01:57.0939] <ryzokuken üá≥üá¥>
but when it comes to internationalization, that's bound to happen, right?

[02:02:05.0159] <ryzokuken üá≥üá¥>
I mean, I totally agree with the general sentiment

[02:02:54.0023] <bakkot>
... is it?

[02:03:01.0769] <Michael Ficarra>
bakkot: ligatures and opentype features are optional; that doesn't make a font not useful

[02:03:25.0043] <littledan>
> <@usharma:igalia.com> but when it comes to internationalization, that's bound to happen, right?

well, we still try to limit the scope of this

[02:03:36.0561] <littledan>
> <@bakkot:matrix.org> ... is it?

it is because different browsers make different tailorings of the data

[02:05:32.0991] <littledan>
sffc: Can you link to that PR for number format for the notes?

[02:05:45.0188] <littledan>
oops it's in TCQ

[02:05:46.0250] <littledan>
https://github.com/tc39/proposal-intl-numberformat-v3/pull/130

[02:09:01.0571] <Rob Palmer>
> <@michaelficarra:matrix.org> I don't even know what to do without TCQ anymore

There is a defined backup plan involving a spreadsheet.

[02:09:27.0488] <Michael Ficarra>
good to hear!

[02:10:25.0322] <bakkot>
someone is typing surprisingly loudly?

[02:10:29.0927] <HE Shi-Jun>
does import attr support boolean values?

[02:10:55.0269] <Rob Palmer>
I think it may be ryzokuken üá≥üá¥ aggressively typing.

[02:11:16.0168] <Jack Works>
> <@haxjs:matrix.org> does import attr support boolean values?

no

[02:11:25.0796] <Michael Ficarra>
I think it is littledan just surprisingly close to the mic

[02:11:52.0528] <rbuckton>
Is someone typing on an open mic?

[02:12:20.0835] <littledan>
sorry that may be me. Is it fixed now?

[02:12:25.0935] <littledan>
(I moved off of the table)

[02:12:38.0389] <bakkot>
there are not currently typing noises

[02:13:34.0084] <HE Shi-Jun>
> <@jackworks:matrix.org> no

If support boolean I would like it also support `null` :)

[02:14:16.0015] <Michael Ficarra>
HE Shi-Jun: Jack Works: I would oppose that because I want to keep a future open where we do not ToString these value

[02:15:17.0439] <bakkot>
yeah I like keeping the restrictions tight until there are concrete things we want to loosen them for

[02:15:52.0249] <bakkot>
definitely I can imagine features where we'd want `true`, `false`, `null` etc but I think we can come back when that's relevant?

[02:15:55.0320] <HE Shi-Jun>
we do ToString for attribute values now?

[02:16:05.0743] <bakkot>
otoh I guess this is partially for bundlers to build out there own things so maybe that doesn't make sense

[02:34:23.0743] <Michael Ficarra>
I support auto deferral in this case, but I don't want this or iterators to be considered precedent to justify auto deferring in future proposals

[02:43:02.0107] <Bradford Smith>
could someone remind me what "hint" means in this context?

[02:43:15.0233] <Michael Ficarra>
it's an alias in the spec

[02:43:15.0834] <littledan>
it means "flag" in practice

[02:43:19.0440] <littledan>
it's a silly name

[02:43:35.0402] <Michael Ficarra>
it's used in places where we provide an AO with context about its use

[02:44:18.0802] <Bradford Smith>
so it's not something specific to the syntax for Explicit Resource Management, then. Thanks

[02:44:33.0013] <ryzokuken üá≥üá¥>
yeah, I always assumed that it was a contextual hints from the caller, as in toPrimitive

[02:44:34.0259] <Michael Ficarra>
correct, entirely spec internal

[02:44:45.0428] <ryzokuken üá≥üá¥>
 * yeah, I always assumed that it was a contextual hint from the caller, as in toPrimitive

[02:44:46.0996] <nicolo-ribaudo>
> <@bradfordcsmith:matrix.org> so it's not something specific to the syntax for Explicit Resource Management, then. Thanks

Well, in this specific case the hint is whether we are using `using` or `await using`

[02:45:18.0103] <ryzokuken üá≥üá¥>
hmm, I would've said the word "context" is better but at this point it's so overloaded that it's probably not

[02:45:50.0132] <Michael Ficarra>
same with "flag"

[02:48:39.0885] <nicolo-ribaudo>
ptomato (at TC39, limited availability): It is not possible unless we want all the `const` and `let` declaration to perform property access

[02:52:05.0891] <bakkot>
or if we change the semantics of `using`, like suggested here

[02:52:16.0159] <nicolo-ribaudo>
> <@nicolo-ribaudo:matrix.org> ptomato (at TC39, limited availability): It is not possible unless we want all the `const` and `let` declaration to perform property access

Oh well, the resource could throw if it's used before accessing its `[Symbol.dispose]` property

[02:52:49.0591] <bakkot>
that's kinda cute actually

[02:53:04.0025] <Luca Casonato>
And also, it is totally reasonable to move around disposables using `let` or `const`, before passing it to a `using`

[02:53:08.0261] <bakkot>
but probably confusing

[02:53:25.0187] <littledan>
if we want to seriously consider Symbol.enter, we should demote this proposal to Stage 2

[02:55:58.0663] <ryzokuken üá≥üá¥>
> <@lucacasonato:matrix.org> And also, it is totally reasonable to move around disposables using `let` or `const`, before passing it to a `using`

I don't quite understand how you envision this

[02:56:18.0885] <Michael Ficarra>
littledan: I think it works fine as a follow-on

[02:58:48.0537] <littledan>
this is not the kind of thing that will be good to have a compatibility matrix around. It's also not some complicated uncertain technology--we know the design space already.

[03:00:11.0620] <Bradford Smith>
littledan: Are you concerned about avoiding a future where some disposables are wrapper objects that pseudo-enforce use of `using` and some are not?

[03:00:45.0616] <littledan>
it will be annoying to have to reason about different possible ways that this protocol could be implemented, in general. Possible, but annoying

[03:01:33.0965] <littledan>
Queue:
Reply: Concern with disposers that throw exception in GC for embeddings
Philip Chimento
2
New Topic: I am not in favour of recommending GC based cleanup. Should -> may?
Luca Casonato (@denoland)
3
New Topic: Is it possible to enforce use of `using` in the language, rather than in tooling
Philip Chimento
4
New Topic: Test sanitizers can be used to help with this
Luca Casonato (@denoland)
5
New Topic: I support looking into the @@enter/@@asyncEnter, possibly part of this proposal.
Michael Saboff

[03:02:16.0960] <ryzokuken üá≥üá¥>
thanks, could we perhaps also put this in the notes so we have a copy stored?

[03:03:53.0942] <sffc>
is tcq.app down for anyone else? The console says
```
WebSocket connection to '<URL>' failed: WebSocket is closed before the connection is established.
wKFO:1 Unchecked runtime.lastError: The message port closed before a response was received.
```

[03:04:03.0581] <ryzokuken üá≥üá¥>
yeah, it's down again

[03:09:53.0928] <rbuckton>
To clarify, I am fine with not providing a recommendation to ensure cleanup if a disposable is dropped on the floor, regardless as to the practice in other languages. It was brought up in #159 as one of the concerns about dropping a disposable is that native handles that are usually just tracked by a `number` value can leak and are not visible in a heap dump.

[03:11:23.0275] <rbuckton>
That said, it is feasible to implement a "cleanup on GC" behavior using `FinalizationRegistry` in user code if needed, given that's one of `FinalizationRegistry`'s use cases, and such behavior already exists in NodeJS for many native handles.

[03:24:49.0138] <rbuckton>
Regarding the `Symbol.enter` suggestion, I have been considering the following as a follow-on proposal:

`Symbol.enter` (or `Symbol.enterContext`?) - indicates a method that, when invoked, enters a context and returns a value associated with that context. This method is optional, and if missing is implicitly handled as if the definition was:

```
[Symbol.enter]() {
  return this;
}
```

`Symbol.exit` (or `Symbol.exitContext`?) - indicates a method that is invoked when the context is exited at the end of the block. Receives two arguments, `hasError` and `error`, that indicate whether an exception occurred prior to context exit. The method may return `true` to inform the caller not to throw `error` (swallowing the exception). Any other return value is ignored, indicating the caller should throw `error`. The method may also choose to throw its own error, but should not throw `error` itself. This method is also optional, and if missing is implicitly handled as if the definition was:

```
[Symbol.exit](hasError, error) {
  try {
    this[Symbol.dispose]();
  } catch (e) {
    if (hasError) {
      throw new SuppressedError(e, error);
    } else {
      throw e;
    }
  }
  return undefined;
}
```

Thus, `[Symbol.dispose]()` on its own would constitute a lightweight context manager.

[03:28:48.0847] <rbuckton>
Things do become more complex for async context managers, however, given that they must `await` the result of `[Symbol.asyncEnter]()` if we were to adhere to the Python design. `await using x = y` would potentially Await twice: once at the declaration site in the presence of a `[Symbol.asyncEnter]()` method, and once at the end of the block for the `[Symbol.asyncExit]()` or `[Symbol.asyncDispose]()` call. 

[03:31:45.0193] <rbuckton>
Finally, `AsyncDisposableStack.prototype.use` becomes *slightly* more complicated as it may return a `Promise` if the resource that is passed to `use` is an async context manager. `use` itself doesn't necessarily need to become async, however, since all it needs to do is return the result of calling `[Symbol.asyncEnter]()`. If you were to pass in a sync context or a disposable, it would not need to return a `Promise`.

[03:32:56.0584] <rbuckton>
Context managers are extremely powerful, but also extremely complex, which is why I have been reticent to consider them for this proposal. 

[03:36:08.0463] <rbuckton>
I also didn't want the general purpose `[Symbol.dispose]` behavior to be complicated by the error handling and error suppression semantics of `__exit__`, as the majority of cases related to resource management have no need of that complexity.

[04:08:10.0949] <Luca Casonato>
you may come back ljharb Chris de Almeida 

[04:08:13.0713] <Rob Palmer>
Please return to the Zoom

[04:10:08.0221] <Luca Casonato>
> <@usharma:igalia.com> I don't quite understand how you envision this

```js
const resource = createResource()

promises.push(doSomethingWithResource(resource));

async function doSomethingWithResource(resource) {
  using r = resource;

  ...
}
``

[04:10:15.0808] <Luca Casonato>
> <@usharma:igalia.com> I don't quite understand how you envision this

 * ```js
const resource = createResource()

promises.push(doSomethingWithResource(resource));

async function doSomethingWithResource(resource) {
  using r = resource;

  ...
}
```

[04:19:44.0993] <eemeli>
littledan: My preferred source-maps scope change would be to expand the two "including ECMAScript code" mentions to be something like "including CSS and ECMAScript code".

[04:21:49.0741] <Christian Ulbrich>
-> https://notlaura.com/is-css-turing-complete/

[04:28:06.0197] <littledan>
Thank you for ensuring that the CoC Committee member list is accurate

[04:28:08.0901] <littledan>
with the pruning

[04:28:12.0080] <littledan>
and thanks to new volunteers

[04:34:55.0982] <Bradford Smith>
The delegate's organization is not listed in https://github.com/tc39/notes/blob/main/delegates.txt. Is that information available somewhere?

[04:35:37.0309] <nicolo-ribaudo>
We are divided in teams in the tc39 GH org based on our org

[04:35:41.0292] <nicolo-ribaudo>
 * We are divided in teams in the tc39 GH org based on our organization

[04:35:43.0747] <nicolo-ribaudo>
 * We are divided in teams in the tc39 GH org based on our organizations

[04:36:25.0754] <nicolo-ribaudo>
Example: https://github.com/orgs/tc39/teams/member-igalia

[04:36:49.0356] <Bradford Smith>
Thanks for that reminder. I still don't really know how to "look up" the information that way. I mean go from name/abbreviation -> organization

[04:37:01.0761] <littledan>
so, the public calendar email address to invite will be shared with the committee to make events public?

[04:37:37.0280] <Michael Ficarra>
Bradford Smith: type their name here: https://github.com/orgs/tc39/teams/eligible-meeting-participants?query=membership%3Achild-team

[04:44:09.0800] <Chris de Almeida>
yes

[04:45:02.0712] <Michael Ficarra>
I'm confused, don't only the chairs have edit access?

[04:45:22.0193] <Chris de Almeida>
the public calendar is managed by way of the private calendar

[04:45:43.0664] <Michael Ficarra>
yes, I mean edit access to the private calendar

[04:45:52.0817] <littledan>
no, we can all edit the private calendar

[04:46:01.0136] <Chris de Almeida>
not everyone can edit it

[04:46:07.0997] <Chris de Almeida>
several people have permission though

[04:46:18.0736] <Chris de Almeida>
https://github.com/tc39/how-we-work/issues/94#issuecomment-1518375862

[04:46:38.0625] <Chris de Almeida>
calendar id there is the address to invite the public calendar to a private calendar meeting

[04:47:01.0032] <Chris de Almeida>
as discussed, we will place this information in a more accessible place rather than buried in a GH issue

[04:48:22.0110] <Chris de Almeida>
we should document some points of contact who have edit access so it's not ambiguous who to contact when needing to make calendar updates

[04:48:55.0502] <Chris de Almeida>
at the very least the chairs, but other folks with edit access may be willing to make themselves available for this purpose

[04:49:06.0971] <ljharb>
i've been fielding calendar update requests for awhile

[04:49:31.0461] <ryzokuken üá≥üá¥>
I think the admin role is perfect for this tbh

[04:49:33.0674] <ljharb>
 * i've been fielding calendar update requests for awhile fwiw

[04:49:52.0354] <ryzokuken üá≥üá¥>
so it makes sense for you to be among the listed contacts ljharb 

[04:49:54.0835] <littledan>
maybe we should give edit access somewhat more broadly?

[04:50:16.0756] <littledan>
I don't really see why I should have more access than others

[04:50:32.0879] <ryzokuken üá≥üá¥>
I think we have a high enough degree of trust within the committee to share edit access to the calendar more broadly, yes

[04:50:48.0997] <ryzokuken üá≥üá¥>
like the calendar edit permission is not really that critical now that I think about it

[04:50:50.0081] <ljharb>
that said, calendar management can be tricky and it's really easy to accidentally fire off dozens of email notifications

[04:51:01.0635] <Chris de Almeida>
true

[04:51:02.0722] <ljharb>
 * that said, calendar management can be tricky and it's really easy to accidentally fire off dozens of email notifications, and there's no audit log to restore deleted events

[04:51:36.0474] <littledan>
> <@ljharb:matrix.org> that said, calendar management can be tricky and it's really easy to accidentally fire off dozens of email notifications, and there's no audit log to restore deleted events

In fact it looks like the source map meetings might've been randomly deleted or something

[04:52:07.0727] <ljharb>
oof, ping me with the deets you want and i'll be happy to set it back up

[04:52:32.0144] <ryzokuken üá≥üá¥>
> <@ljharb:matrix.org> that said, calendar management can be tricky and it's really easy to accidentally fire off dozens of email notifications, and there's no audit log to restore deleted events

I guess that makes sense given that those operations are not actually part of the calendar protocol

[04:52:49.0996] <Michael Ficarra>
yeah I'm fine with delegating the calendar management as long as the people are decently responsive

[04:52:52.0625] <ryzokuken üá≥üá¥>
the calendar protocol is weird actually, but maybe you have some degree of a backlog in your emails

[04:53:07.0891] <ryzokuken üá≥üá¥>
or CalDAV

[04:54:08.0837] <Chris de Almeida>
source maps still on my calendar, but not on the tc39 calendar

[04:54:33.0292] <Chris de Almeida>
it's 2023 and calendaring is still in the dark ages

[04:54:46.0907] <Chris de Almeida>
TG5: Calendar Spec

[04:55:29.0626] <ryzokuken üá≥üá¥>
Chris de Almeida: 100% seriously I've been thinking about it a lot lately

[04:55:34.0242] <ryzokuken üá≥üá¥>
and trying to fix that somewhat

[04:56:05.0939] <Chris de Almeida>
I'd support you

[04:57:42.0176] <shu>
littledan: so actually for the loop bound recomputation bugs there are already tests AFAICT

[04:58:09.0969] <shu>
(marja implemented and wrote the tests for them, but i didn't correctly fix the spec draft)

[04:58:14.0402] <Andreu Botella>
syg: I wonder if throwing if there was a concurrent too-large grow makes sense, since if the concurrent grow happens just after this thread's grow returns, you'd still have a too-large buffer when you try to use it

[04:58:18.0684] <shu>
the only one missing is the detach timing

[04:58:46.0734] <Andreu Botella>
 *  shu: I wonder if throwing if there was a concurrent too-large grow makes sense, since if the concurrent grow happens just after this thread's grow returns, you'd still have a too-large buffer when you try to use it

[04:58:47.0436] <shu>
Andreu Botella: you mean throwing if there is _any_ race?

[04:59:18.0103] <shu>
i don't think so, because racing for too-large cannot be reliably detected

[04:59:37.0176] <Andreu Botella>
no, I mean you'd still have a race in user code if the concurrent grow happens just a bit too late

[04:59:46.0784] <shu>
right, you can't detect that

[04:59:57.0035] <Andreu Botella>
so why try to detect it inside the loop?

[05:00:15.0695] <Andreu Botella>
well, I guess you'd have to detect it anyway, but why throw

[05:00:24.0443] <shu>
the race inside the loop is for the opposite case, where grow(10) races with grow(20)

[05:00:32.0321] <Rob Palmer>
https://github.com/tc39/proposal-array-grouping/issues/57

[05:00:35.0443] <shu>
and grow(20) happens first, and grow(10) is now a shrink

[05:00:38.0615] <shu>
and is disallowed

[05:00:49.0337] <shu>
it's throwing not because of a race per se, it's throwing because shrinks already throw

[05:01:07.0247] <shu>
you could have it silently do nothing, that's a possibility

[05:01:09.0094] <Andreu Botella>
After a grow, you know the SAB is *at least* the size you've grown it too

[05:01:15.0527] <Andreu Botella>
so I'm not thinking of the grow(10) as a shrink

[05:01:21.0051] <Andreu Botella>
maybe a user might

[05:01:32.0322] <Andreu Botella>
 * maybe a user might though

[05:02:05.0767] <shu>
that's fair, this could be relaxed, but it's shipped with these semantics already and i don't feel particularly compelled to change it

[05:02:13.0487] <Andreu Botella>
oh, right, a slightly-too-late grow(10) would indeed throw

[05:02:21.0297] <Andreu Botella>
that makes sense then

[05:02:22.0007] <shu>
the actual answer is just... don't race your grows

[05:02:23.0926] <shu>
synchronize another way

[05:03:16.0858] <ryzokuken üá≥üá¥>
I understand that but given the level of abstraction we work on, couldn't we do a bit of hand holding here?

[05:03:36.0345] <ryzokuken üá≥üá¥>
make it a bit harder to run into this issue to begin with to whatever extent we can

[05:04:07.0424] <ryzokuken üá≥üá¥>
> <@shuyuguo:matrix.org> that's fair, this could be relaxed, but it's shipped with these semantics already and i don't feel particularly compelled to change it

oh, this is quite compelling, nvm 

[05:04:27.0025] <littledan>
> <@usharma:igalia.com> I understand that but given the level of abstraction we work on, couldn't we do a bit of hand holding here?

yeah I think this is generally not the right kind of thing to do with low-level concurrency primitives

[05:05:11.0115] <littledan>
So, should we have a brief overflow topic to get through the conditionality?

[05:05:20.0725] <littledan>
if msaboff expects to review it tonight

[05:05:59.0809] <littledan>
it has not really been helpful to replace what we were calling "conclusion" with "summary". The idea was to be more detailed.

[05:06:17.0467] <shu>
agreed with littledan, i think hand-holding lock-free concurrency stuff is just not a good idea

[05:06:18.0216] <littledan>
we've had a conclusion for a long time

[05:07:01.0905] <Michael Ficarra>
the request from this morning is just that we don't forget to add a conclusion

[05:07:56.0271] <littledan>
this is false. The request from Ecma has been to add summaries. We had been adding conclusions previously.

[05:08:23.0330] <littledan>
I'm really confused by the resistance from the committee to summaries. I really think they would make the notes more accessible.

[05:08:42.0882] <littledan>
the idea is to cover the main points in the presentation and discussion, not only the things we got consensus on

[05:09:08.0246] <littledan>
if a delegate doesn't want to write a summary, that's OK, but I don't understand why they should oppose others writing summaries...

[05:10:49.0452] <ljharb>
i don't recall any opposition to someone just going in and adding a summary - i thought the opposition was just to pausing the meeting and/or asking champions to write a summary

[05:11:07.0858] <ljharb>
 * i don't recall any opposition to someone just going in and adding a summary - i thought the opposition was just to pausing the meeting and/or asking champions to write a summary, but maybe i'm not remembering right

[05:21:34.0330] <Chris de Almeida>
the summaries (with or without a conclusion) are very helpful.  it takes only a moment for the speaker to dictate a summary.  I don't think there's a lot of controversy with this, but in the past IIRC it was only because it was perceived to take up too much committee time.  but I think that was also when we were sitting there waiting for the speaker (or someone else) to type up the summary, whereas it should just be dictated, which should only take a moment, and can be cleaned up async as needed

[05:22:45.0343] <Chris de Almeida>
so yes, Jordan is right that it was in opposition to pausing the meeting. it's such a small sacrifice though and is a lot easier to do when it's timely

[05:24:23.0552] <Chris de Almeida>
but 100% almost every time in recent memory where I needed to refer to meeting notes, it was so helpful to have those summaries rather than having to scour the entire dialog

[05:24:31.0004] <Chris de Almeida>
 * 100% almost every time in recent memory where I needed to refer to meeting notes, it was so helpful to have those summaries rather than having to scour the entire dialog

[05:38:44.0161] <Luca Casonato>
syg: The profile ^^



[05:43:01.0547] <Michael Ficarra>
ljharb: if you don't use namespace imports, you will have effects triggered on reading a local

[05:43:11.0229] <Michael Ficarra>
reading a local shouldn't have an effect

[05:44:48.0092] <ljharb>
i agree with that

[05:45:08.0092] <ljharb>
that doesn't mean `import *` is any more palatable tho

[05:45:23.0883] <littledan>
> <@ljharb:matrix.org> that doesn't mean `import *` is any more palatable tho

Do you have any other suggestions?

[05:45:44.0068] <rbuckton>
> <@michaelficarra:matrix.org> reading a local shouldn't have an effect

`with` would like a word /s

[05:46:05.0684] <Michael Ficarra>
"why not `with` but *everywhere*?"

[05:46:47.0664] <HE Shi-Jun>
I don't understand current page...

[05:47:16.0716] <ljharb>
> <@littledan:matrix.org> Do you have any other suggestions?

no, the design goals of ESM didn't really leave many options here i can see :-/

[05:47:38.0436] <Jack Works>
> <@michaelficarra:matrix.org> reading a local shouldn't have an effect

but imported variable isn't a local.

[05:47:47.0719] <ljharb>
sure it is

[05:47:58.0622] <littledan>
like it could be `import with` instead of `import defer`?

[05:48:01.0096] <HE Shi-Jun>
personally i think some magic like `with` is acceptable in this specific case :)

[05:48:03.0070] <ljharb>
altho it's slightly different in that its value can change out from under you

[05:48:15.0287] <ljharb>
 * altho it's slightly different in that its value can change out from under you if the export is a `let` that's reassigned

[05:48:30.0539] <littledan>
> <@ljharb:matrix.org> no, the design goals of ESM didn't really leave many options here i can see :-/

I don't really understand why the namespace restriction is fatal, but I guess you'll explain in your queue item?

[05:48:46.0419] <ljharb>
i didn't say it was fatal. but yes, i will

[05:48:58.0855] <ljharb>
 * i didn't say it was fatal. but yes, i will elaborate on my queue item

[05:49:09.0148] <littledan>
 * like it could be `import with` instead of `import defer`? (joking)

[05:49:31.0238] <ljharb>
 * i didn't say it was fatal. but yes, i will elaborate on my queue item (i just combined my two into one)

[05:49:38.0708] <Jack Works>
I support allowing `import defer { ... }`, we have already using it by the webpack implementation and we found enforcing a namespace is somewhat a bad DX .

[05:50:25.0662] <littledan>
in our use at Bloomberg, we've found that the restriction to a namespace is a little annoying but not really that bad

[05:50:58.0852] <ljharb>
bakkot: adding TLA to a module is already a breaking change i think

[05:51:07.0360] <littledan>
the more significant thing is the decision about whether to include deferred * re-exports (coming later in the slides, proposed to discuss during stage 2)

[05:51:10.0177] <danielrosenwasser>
> <@lucacasonato:matrix.org> sent an image.

is the second column milliseconds?

[05:51:18.0316] <littledan>
> <@ljharb:matrix.org> bakkot: adding TLA to a module is already a breaking change i think

well. ot

[05:51:33.0009] <littledan>
> <@ljharb:matrix.org> bakkot: adding TLA to a module is already a breaking change i think

 * well. it's observable but it's intended to not be quite breaking

[05:52:02.0676] <Luca Casonato>
> <@danielrosenwasser:matrix.org> is the second column milliseconds?

i think either function call count or sample count - but I don't know for sure

[05:52:17.0953] <ljharb>
i believe there's nonzero use cases where if a module starts using TLA, things will break - i forget which off the top of my head tho

[05:52:31.0102] <rbuckton>
> <@littledan:matrix.org> in our use at Bloomberg, we've found that the restriction to a namespace is a little annoying but not really that bad

I wonder if we could employ a heuristic where named imports that are only used in functions are deferred until the first function call?

[05:53:55.0166] <nicolo-ribaudo>
> <@ljharb:matrix.org> i believe there's nonzero use cases where if a module starts using TLA, things will break - i forget which off the top of my head tho

If it has side effects and a module that does not list it as a dependency relies on its side effects

[05:55:02.0965] <ljharb>
hm, that's not what i was thinking of, but since i can't recall specifics rn, ¬Ø\_(„ÉÑ)_/¬Ø 

[05:55:05.0042] <rbuckton>
i.e.:
```js
// a.js
import defer * as ns from "foo";
// defer until `ns` property accessed.

// b.js
import defer { a, b } from "foo";
export function f() { console.log(a, b); } // defer until `f` is called

// c.js
import defer { a, b } from "foo";
console.log(a, b); // not actually deferred
```

[05:55:08.0139] <ljharb>
 * hm, that's not what i was thinking of, but since i can't recall specifics rn, ¬Ø\\\_(„ÉÑ)\_/¬Ø

[05:55:23.0649] <bakkot>
> <@ljharb:matrix.org> i believe there's nonzero use cases where if a module starts using TLA, things will break - i forget which off the top of my head tho

for well-behaved graphs I don't think it's ever breaking; it's only if there's weird side-effect ordering problems that it breaks

[05:56:27.0366] <bakkot>
> <@rbuckton:matrix.org> I wonder if we could employ a heuristic where named imports that are only used in functions are deferred until the first function call?

fwiw that seems like too much magic to me

[05:56:47.0885] <Jack Works>
> <@bakkot:matrix.org> for well-behaved graphs I don't think it's ever breaking; it's only if there's weird side-effect ordering problems that it breaks

we've hit that. we have code `onAppInstall.addListener(...)` which the callback is _only_ called if the callback is registered in 1st event loop.

[05:57:37.0460] <rbuckton>
> <@bakkot:matrix.org> fwiw that seems like too much magic to me

`defer` itself is too much like magic

[05:58:08.0841] <bakkot>
the thing where the namespace object implicitly has side-effecting accessors is, just barely, not too magic for me

[05:58:19.0640] <bakkot>
the previous suggestion of having local access be side-effecting was too magic

[05:58:24.0891] <bakkot>
but property access can already be side-effecting

[05:58:28.0838] <Luca Casonato>
bakkot: Most places I have seen TLA in is leaf modules (for example Wasm loading), or the top level entrypoint (for example data fetching in a CLI). In my experience TLA anywhere between entrypoint and leaf is very rare.

[05:58:30.0912] <bakkot>
you can explain this feature in terms of existing ones

[05:58:37.0248] <bakkot>
 * you can (mostly) explain this feature in terms of existing ones

[05:58:38.0417] <ljharb>
it still feels too magic to me tbh

[05:58:40.0307] <bakkot>
so it is, just barely, ok with me

[05:58:56.0073] <bakkot>
> <@lucacasonato:matrix.org> bakkot: Most places I have seen TLA in is leaf modules (for example Wasm loading), or the top level entrypoint (for example data fetching in a CLI). In my experience TLA anywhere between entrypoint and leaf is very rare.

why would wasm loading be a leaf?

[05:59:00.0824] <bakkot>
wasm is just like... code

[05:59:08.0479] <rbuckton>
> <@rbuckton:matrix.org> `defer` itself is too much like magic

but also, determining whether named imports are lexically scoped to functions is statically analyzable, with the exception of direct-`eval` (which could just block deferred evaluation anyways).

[05:59:24.0022] <Jack Works>
+1 I don't think it's magical for the `ns` case. Direct import binding is a little bit magic but also good to me.

[06:00:17.0505] <Michael Ficarra>
> <@bakkot:matrix.org> why would wasm loading be a leaf?

... because it needs to be passed an imports object? how can it not be a leaf?

[06:01:51.0372] <bakkot>
I guess I mean a difference sense of "loading"

[06:02:00.0740] <bakkot>
yes, loading the bytecode is a leaf, of cousre

[06:02:03.0623] <bakkot>
 * yes, loading the bytecode is a leaf, of course

[06:03:02.0537] <bakkot>
but if you have a library which has a wasm component, it seems like "TLA to async-compile the wasm" is a pretty normal use case

[06:03:56.0303] <bakkot>
which means your library's entry point would have a TLA, not just the leafs of the library

[06:05:57.0951] <shu>
i don't think i'm confused

[06:06:08.0207] <shu>
i'm saying in JS, compilation can be transparently deferred and folded into evaluation

[06:06:19.0838] <shu>
in wasm because timing is of a bigger concern, it cannot be generally transparently deferred

[06:06:54.0635] <Jack Works>
I also want to notice the deferred is not only the compilation happened in the engine, but also the _execution_ of the JS code

[06:06:55.0388] <shu>
and the motivating number of "half the time spent in evaluation" as shown by the profiler output suggests that that includes main-thread deferred compilation

[06:07:07.0677] <shu>
well yes, obviously the execution is the main thing to be deferred

[06:07:16.0402] <shu>
i'm questioning the "half the time" measure and what it includes

[06:07:18.0551] <sffc>
https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Instance/Instance#syntax says in a big red box, "Warning: Since instantiation for large modules can be expensive, developers should only use the Instance() constructor when synchronous instantiation is absolutely required; the asynchronous WebAssembly.instantiateStreaming() method should be used at all other times."

[06:07:58.0049] <sffc>
^ This is about the sync constructor after you already have an async compiled Module

[06:08:01.0853] <Jack Works>
for example https://github.com/alexcorvi/anchorme.js/pull/127 this library cost 30ms to init (this PR is reverted by the author). We now using `defer` to save this 30ms

[06:08:11.0708] <littledan>
> <@shuyuguo:matrix.org> i'm questioning the "half the time" measure and what it includes

right, the thing is, we have a whole bunch of data about the benefit of this, and the champions were conservative about what they included on slides. I think it's reasonable that you ask how much benefit this will get on the web.

[06:08:28.0228] <littledan>
I would point out, though, that when it's a cache hit, the fetching and compiling part might be pretty quick

[06:08:30.0139] <shu>
i'm convinced it's a win for JS for sure

[06:08:57.0427] <shu>
the wasm questions got me doubting about how well the performance story composes

[06:08:58.0946] <Rob Palmer>
Synchronous lazy loading in CommonJS is sometime known as "inline requires".  Jest managed to [half their startup time](https://jestjs.io/blog/2016/03/11/javascript-unit-testing-performance#inline-requires-and-lazy-mocking) by incorporating this technique.

[06:09:03.0020] <shu>
or are we also introducing performance footguns

[06:09:17.0379] <littledan>
I guess I don't understand the performance breakdown case

[06:10:35.0663] <littledan>
you're all right that we should investigate this better for Wasm. I think this should block Stage 3.

[06:10:52.0626] <littledan>
I should've realized that earlier, so thanks for raising it

[06:11:06.0324] <Michael Ficarra>
Chris de Almeida: have you considered just implementing https://github.com/bterlson/tcq/issues/14?

[06:11:26.0430] <Michael Ficarra>
there's so many good things on the TCQ issue tracker

[06:11:28.0100] <eemeli>
I wonder if a module could say e.g. `"defer load"` to communicate that if it's loaded via `import defer`, all of its imported dependencies could be completely deferred until its evaluation.

[06:11:50.0878] <shu>
well i think the wasm case is generalizable to a certain kind of module with a certain weight profile of time spent in which phases

[06:12:04.0521] <shu>
the high-order bit for me is "does the performance story compose"

[06:12:16.0381] <bakkot>
concretely, I have published exactly one wasm-based library (z3-solver). It's CJS-based so it has an async `init` function, but if it was ESM-based it would totally have a top-level `await` in its entrypoint, not at a leaf. and it's doing a nontrivial amount of computation on load, of exactly the sort I'd hope to be deferring by the use of `defer`.

[06:12:20.0177] <shu>
can someone who doesn't need sync evaluation can just always insert `defer` and get some loading wins

[06:12:37.0123] <Chris de Almeida>
Michael Ficarra: yeah.. I think we need a DX workflow presentation from BT first

[06:13:50.0703] <littledan>
> <@shuyuguo:matrix.org> the high-order bit for me is "does the performance story compose"

right, I think this comes down to some details of the algorithm for exactly what is made eager. It's a good action item for the champions to articulate some more cases to investigate this. My intuition is that it should work out as long as you do `import defer` for the imports from within the module that uses TLA--then you get the deferred-ness back

[06:13:56.0556] <Rob Palmer>
> <@shuyuguo:matrix.org> the high-order bit for me is "does the performance story compose"

Given our experience deploying an ESM system, we've found the ESM performance composition story is not viable without this feature.

[06:14:16.0435] <Jack Works>
let me rejoin

[06:14:22.0337] <littledan>
> <@robpalme:matrix.org> Given our experience deploying an ESM system, we've found the ESM performance composition story is not viable without this feature.

this matches what Yulia shared for Firefox DevTools at the outset of this project

[06:14:34.0731] <shu>
that's not what i mean by composition, i don't think

[06:14:40.0681] <Rob Palmer>
It also matches what I've said at every plenary where this item is brought up ;-)

[06:14:54.0305] <shu>
i understand Yulia's original claim to be "ESM performance story is not viable without this feature"

[06:15:01.0274] <Rob Palmer>
ok sorry if I misinterpreted the point

[06:15:01.0834] <shu>
maybe that's the overriding thing

[06:15:45.0646] <littledan>
> <@littledan:matrix.org> right, I think this comes down to some details of the algorithm for exactly what is made eager. It's a good action item for the champions to articulate some more cases to investigate this. My intuition is that it should work out as long as you do `import defer` for the imports from within the module that uses TLA--then you get the deferred-ness back

does this match what you're asking about, shu ?

[06:17:11.0507] <shu>
let me try to articulate what i'm asking for plenary littledan 

[06:18:12.0048] <ljharb>
webpack might be the TLA breaking change i was thinking of

[06:19:08.0400] <danielrosenwasser>
I know bakkot  mentioned something like this - but it does feel like `import defer` is going to ring the wrong bells for a lot of people who expect this won't even do script parsing.

Not that I am necessarily advocating for that behavior.

[06:19:13.0871] <Jack Works>
this proposal is good enough for sync usage. I have no idea about TLA and WASM and we  haven't try that yet.

[06:19:59.0506] <ljharb>
so it did get stage 2?

[06:20:07.0380] <ryzokuken üá≥üá¥>
yeah

[06:20:14.0369] <ljharb>
k

[06:20:14.0875] <Ashley Claymore>
fwiw, at Bloomberg we still encourge use of fully-async dynamic import when that is viable. This proposal has been great for the places where it has not been viable to go fully async

[06:20:32.0170] <shu>
Ashley Claymore: see that smells really off to me

[06:21:54.0675] <Ashley Claymore>
the current situation when it is not viable is that code is written to be fully eager.

[06:22:41.0030] <shu>
hm my internet is not down but zoom disappeared for me

[06:23:01.0080] <shu>
just me?

[06:23:07.0938] <Jack Works>
no, I can see zoom

[06:25:16.0660] <shu>
okay, took a while to come back

[06:25:25.0899] <shu>
Ashley Claymore: right, agreed on that premise

[06:26:02.0853] <littledan>
> <@shuyuguo:matrix.org> Ashley Claymore: see that smells really off to me

it's pretty common that you're writing code that's not in an async function... I don't think that's going to go away.

[06:26:03.0505] <shu>
Ashley Claymore: but it doesn't smell right to me (yet) that we've been saying "asyncify" and now saying "well, if you did asyncify if you wanna take advantage of this new deferral thing you might not be able to"

[06:27:14.0899] <Rob Palmer>
shu: Using dynamic import would only neuter the deferred import if the dynamic import were awaited at top-level.  The general advice is to never do that.  Instead, dynamic import is best used just-in-time inside async functions that require it.

[06:27:51.0339] <shu>
i mean top-level await is a thing?

[06:28:08.0535] <shu>
i don't know how to reconcile that we added it with "actually the general advice is to never do that"?

[06:28:10.0047] <littledan>
> <@shuyuguo:matrix.org> Ashley Claymore: but it doesn't smell right to me (yet) that we've been saying "asyncify" and now saying "well, if you did asyncify if you wanna take advantage of this new deferral thing you might not be able to"

In some way, this is a key part of providing a well-scoped amount of feature parity from CJS into, since CJS has always supported this pattern (differently, just by having sync require, which is more general than this feature)

[06:28:20.0975] <littledan>
> <@shuyuguo:matrix.org> Ashley Claymore: but it doesn't smell right to me (yet) that we've been saying "asyncify" and now saying "well, if you did asyncify if you wanna take advantage of this new deferral thing you might not be able to"

 * In some way, this is a key part of providing a well-scoped amount of feature parity from CJS into ESM, since CJS has always supported this pattern (differently, just by having sync require, which is more general than this feature)

[06:28:25.0857] <shu>
interesting framing

[06:28:29.0606] <shu>
i don't know enough about CJS to say

[06:28:35.0316] <Rob Palmer>
"never do that" -> "avoid if possible" (I was too strong)

[06:28:38.0618] <shu>
 * i don't know enough about CJS to say if i find that compelling

[06:28:53.0915] <Michael Ficarra>
üòÆ I had no idea they didn't have an FPU!

[06:29:21.0317] <littledan>
> <@shuyuguo:matrix.org> i don't know how to reconcile that we added it with "actually the general advice is to never do that"?

I think this isn't actually the advice--it's more like, if you want the deferral to happen, you also need to defer the imports within the TLA-containing module, and not put the only `defer` things higher up in the module graph

[06:31:46.0607] <Jesse (TC39)>
someone is spamming the notes with the  letter t

[06:32:04.0571] <Andreu Botella>
did someone fall asleep at their keyboard? /j

[06:32:44.0720] <Michael Ficarra>
why would we want `irandom` to take bounds if `random` doesn't? I don't like it

[06:32:53.0419] <Chris de Almeida>
üêàÔ∏è
‚å®Ô∏è

[06:37:02.0388] <HE Shi-Jun>
Because it's very common? `Math.random()` actually have bounds implicitly 

[06:37:15.0742] <littledan>
Note that our internal membership lists don't exactly match what Ecma has recorded. We should work to reconcile these. cc saminahusain 

[06:37:35.0058] <bakkot>
> <@michaelficarra:matrix.org> why would we want `irandom` to take bounds if `random` doesn't? I don't like it

don't think if it as "like random, but gives an int"

[06:37:49.0311] <bakkot>
think of it as "like randInt, the extremely useful function in every other standard library"

[06:38:12.0854] <bakkot>
(probably it should also not be spelled `irandom`)

[06:39:19.0127] <Michael Ficarra>
sffc: is divrem considered an alternative to divmod or is it still useful even when you have divmod?

[06:40:50.0226] <HE Shi-Jun>
why not operator `a /% b` instead of `divrem`? üòÅ

[06:40:52.0511] <Michael Ficarra>
littledan: doesn't Ecma only keep one point of contact per member?

[06:41:14.0822] <bakkot>
sffc: ... because we don't have 64-bit integers?

[06:42:04.0082] <shu>
yeah i think... that's just that

[06:42:10.0274] <shu>
also i don't want to allocate BigInts?

[06:43:43.0332] <littledan>
yeah I guess if we wanted to support 64-bit integers we'd need stuff for, like, adding two bigints and then rounding to the right 64-bit int (possible to define in multiple ways for signed vs unsigned). I'm not convinced we need that--my hope was that BigInt.asUintN would be a suitable replacement (to call after the bigint arithmetic op)

[06:44:29.0045] <littledan>
> <@shuyuguo:matrix.org> also i don't want to allocate BigInts?

I guess the hope is that the compiler would do representation analysis and avoid allocating BigInts

[06:44:39.0229] <shu>
lol, lmao

[06:45:06.0065] <littledan>
why lol?

[06:45:26.0341] <littledan>
I mean, it's fine that you don't do it now, but I don't know what the blocker would be if it were used commonly enough

[06:46:07.0858] <littledan>
like, this is a totally classical optimization in the Scheme world

[06:46:18.0426] <shu>
i don't think that will ever happen outside of the optimizing tier

[06:46:37.0947] <littledan>
oh yeah definitely

[06:46:50.0885] <shu>
and i don't consider optimizing tier hope to be very compelling for proposal motivations, or alleviating proposal performance concerns

[06:47:50.0884] <littledan>
I mean, this logic went into the decision to not add int64 and instead go for bigint, in the first place

[06:48:38.0121] <shu>
yes, and in retrospect i think it was wrong

[06:49:08.0722] <shu>
for Promise.withResolvers: i have another meeting at 7am (didn't realize this went until 7:15)

[06:49:35.0151] <littledan>
shu: Are you OK with the presentation going on? we can return to it later if you want to give more comments

[06:49:41.0503] <littledan>
but you might have time for yours

[06:49:52.0338] <shu>
yes of course

[06:59:43.0716] <sffc>
> <@michaelficarra:matrix.org> sffc: is divrem considered an alternative to divmod or is it still useful even when you have divmod?

I was referring to the Euclid divrem, which always returns positive numbers for the remainder and rounds the quotient toward negative Infinity instead of zero. At least this is what Rust calls the operation (added a link to the notes)

[07:02:20.0756] <littledan>
> <@sffc:mozilla.org> I was referring to the Euclid divrem, which always returns positive numbers for the remainder and rounds the quotient toward negative Infinity instead of zero. At least this is what Rust calls the operation (added a link to the notes)

thanks for clarifying in the notes

[07:03:11.0061] <bakkot>
I maintain that `defer` and `deferred` are awful names for anyone who doesn't know the history, which is 95%+ of users

[07:03:14.0771] <bakkot>
it doesn't defer anything

[07:03:22.0572] <bakkot>
and `deferred` is not a noun

[07:07:17.0236] <littledan>
> <@bakkot:matrix.org> I maintain that `defer` and `deferred` are awful names for anyone who doesn't know the history, which is 95%+ of users

Yeah, bikeshedding names is sort of the rare case where it is reasonable to make decisions based on the knowledge of percentages of JS developers

[07:07:41.0385] <Christian Ulbrich>
Rob Palmer: We'd gladly host you in Dresden :)

[07:08:18.0983] <Jack Works>
than we can name it `import duck` until stage 3 üòá

[07:09:45.0193] <bakkot>
ok I'm assuming nothing else important is happening so I am going to go sleep

[07:27:01.0679] <Luca Casonato>
```
// wasm.js
const mod = await WASM.instantiateStreaming(fetch(‚Ä¶));
export const foo = mod.exports.foo;
```

[07:27:15.0750] <Luca Casonato>
This is a leaf. No imports

[08:02:56.0556] <Mathieu Hofman>
bakkot: looks like we're missing the logs for today? https://matrixlogs.bakkot.com/TC39_Delegates/2023-07-11

[08:19:27.0865] <Chris de Almeida>
> <@mhofman:matrix.org> bakkot: looks like we're missing the logs for today? https://matrixlogs.bakkot.com/TC39_Delegates/2023-07-11

I think it's a cron job that runs, not realtime (?)

[08:32:40.0089] <Chris de Almeida>
I forgot who asked, but I added the TG3 slides to the agenda (`07.md`)

[08:37:28.0392] <Chris de Almeida>
https://www.ecma-international.org/news/ecma-tc39-ecmascript-has-formed-a-new-task-group-tg3-dedicated-to-the-security-of-the-ecmascript-javascript-language/

do we want/need to work with Ecma on drafting something like this for TG4?  littledan jkup 

[09:08:51.0792] <jkup>
> <@softwarechris:matrix.org> https://www.ecma-international.org/news/ecma-tc39-ecmascript-has-formed-a-new-task-group-tg3-dedicated-to-the-security-of-the-ecmascript-javascript-language/
> 
> do we want/need to work with Ecma on drafting something like this for TG4?  littledan jkup 

I think that would be great!

[09:14:00.0568] <ljharb>
Array Grouping has now met its stage 3 condition

[09:48:18.0682] <shu>
peetk: i am fine with Promise.withResolvers advancing to Stage 3 given the explanations

[09:48:30.0602] <shu>
sorry for having to drop out early

[09:48:56.0598] <shu>
(though for the future i'd still prefer to not have meetings end on :15 which is kinda weird)

[10:02:32.0506] <shu>
i think it's good and healthy to revisit, and overturn, previous design decisions based on new evidence

[10:03:52.0542] <shu>
but still in this particular case and future ones i don't want to conflate "good" defaults and developer signal

[10:07:10.0173] <shu>
the end goal for me is users, not developers, and good defaults for me should be chosen to nudge developers to the result (responsiveness, correctness, fast loading, whatever) we want on products they build for the user. if _all_ developers ignore a default constantly, then we obviously failed and nobody benefits. Google-internally, i did not get this sense when talking with practitioners

[10:08:48.0957] <shu>
this is all to say that it's a common argument in committee to say "look developers all do X and want Y", and it's not really that much signal to me most of the time

[10:09:17.0646] <shu>
 * the end goal for me is users, not developers, and good defaults for me should be chosen to nudge developers to the result (responsiveness, correctness, fast loading, whatever) we want on products they build for the user. if _all_ developers ignore a default constantly, then we obviously failed and nobody benefits. Google-internally, i did not get this sense when talking with practitioners about a lack of a defer-like thing

[10:10:13.0442] <Chris de Almeida>
how do you feel about DX as motivation for proposals in general?

[10:11:17.0446] <shu>
i think it is a weak motivation by itself

[10:13:07.0335] <shu>
as a general rule i do not think DX outweighs other concerns like security and performance

[10:13:28.0533] <shu>
if the other concerns are minimal, then DX is the right thing to optimize for

[10:14:59.0532] <shu>
but at the scale of JS and the web, until we figure out a way to do zero-cost DX improvements, it is explicitly a non-goal for me

[10:21:27.0525] <shu>
(it is not an anti-goal, i'm not saying i will actively oppose DX proposals, just that it is not a thing i will push for and find compelling standalone, but i certainly won't block absent other concerns)

[10:24:29.0662] <bakkot>
> <@mhofman:matrix.org> bakkot: looks like we're missing the logs for today? https://matrixlogs.bakkot.com/TC39_Delegates/2023-07-11

ugh, yes, something's up with my server

[10:25:43.0010] <bakkot>
it keeps making the boot disk read-only

[10:25:47.0847] <bakkot>
for reasons I have not been able to discern

[10:26:08.0481] <bakkot>
I will fix it later today and the logs will come back

[10:50:14.0227] <Chris de Almeida>
https://hackmd.io/BkORU_-kTKmR43Ipuohwog

schedule has been updated.  there is no difference in terms of constraints, but please review if you are presenting

[10:50:57.0578] <Chris de Almeida>
 * https://hackmd.io/BkORU\_-kTKmR43Ipuohwog

schedule has been updated.  there is no difference in terms of constraints, but please review if you are presenting.  edit: I think only Day 3 was affected, and changes are minor

[11:58:14.0652] <Mathieu Hofman>
I do not see Explicit resource management in the overflow section but from reading the notes I gather it did overflow its timebox?

[12:02:44.0087] <Chris de Almeida>
> Consensus on PRs: 180,178,175,171 and 167.

> Debates about the appropriate use of GC and Symbol.enter are ongoing and will take place in overflow time


[12:04:34.0115] <Chris de Almeida>
rbuckton: are we scheduling a continuation?  if so, how much time do you estimate?

[13:01:17.0639] <Ashley Claymore>
Thank you!

[13:17:33.0245] <rbuckton>
> <@softwarechris:matrix.org> rbuckton: are we scheduling a continuation?  if so, how much time do you estimate?

Yes, if we could. 15 minutes, maybe? 

[13:18:15.0496] <Chris de Almeida>
tomorrow morning work?

[13:18:45.0109] <Chris de Almeida>
if other topics run long or if 15 mins turns out to not be enough, there's still time available on Friday morning

[13:19:33.0680] <Chris de Almeida>
done

[13:20:24.0545] <Chris de Almeida>
 * if other topics run long or if 15 mins turns out to not be enough, there's still time available on Thursday morning


2023-07-12
[17:15:44.0630] <bakkot>
> <@mhofman:matrix.org> bakkot: looks like we're missing the logs for today? https://matrixlogs.bakkot.com/TC39_Delegates/2023-07-11

fixed. I suspect my boot disk is failing; will have it replaced tomorrow.

[19:17:00.0903] <Jack Works>
> <@shuyuguo:matrix.org> the end goal for me is users, not developers, and good defaults for me should be chosen to nudge developers to the result (responsiveness, correctness, fast loading, whatever) we want on products they build for the user. if _all_ developers ignore a default constantly, then we obviously failed and nobody benefits. Google-internally, i did not get this sense when talking with practitioners about a lack of a defer-like thing

the problem is we cannot everything by default because it's a breaking change

[20:03:24.0392] <shu>
not sure i follow

[20:03:36.0124] <shu>
the context of my previous comment was about the Promise constructor vs withResolvers

[20:04:14.0834] <Jack Works>
oh

[20:04:29.0446] <shu>
the "good default" was referring to the hope that the Promise constructor would, even though it's more inconvenient to use, would bring about better correctness results wrt uncaught exceptions -> rejections

[20:04:56.0737] <shu>
but since then we've learned that maybe that doesn't have quite the effect we hoped because people ignore it

[20:05:01.0237] <shu>
or because there are legitimate use cases

[20:05:15.0239] <shu>
and so, it's fine to add withResolvers, even though it's explicitly against what we thought was the good default

[20:05:51.0139] <shu>
but the broader point is that that's the kind of argument i'm looking to hearing, not simply "developers use pattern X"

[20:06:00.0275] <shu>
 * but the broader point is that that's the kind of argument i'm looking to hear, not simply "developers use pattern X"

[01:02:00.0423] <bakkot>
g'morning all

[01:10:12.0088] <jkup>
I have a question about calendars. The source map monthly call was on the TC39 calendar but I don't see it on there anymore. How can I go about adding it back? Do I make a personal event and then invite the calendar? Or do I need a special permission to do this?

[01:18:16.0682] <Michael Ficarra>
my understanding was that an event needs to be added to the private calendar first, and the public calendar is invited as an attendee of that event

[01:18:37.0120] <Michael Ficarra>
the public calendar has an email address to invite

[01:19:04.0106] <Michael Ficarra>
most of us regular-folk don't have permission to create such an event on the private calendar, though, so you should contact a chair or ljharb 

[01:19:11.0594] <jkup>
Thank you!

[01:24:16.0833] <littledan>
> <@shuyuguo:matrix.org> but since then we've learned that maybe that doesn't have quite the effect we hoped because people ignore it

I think this is the key point--despite many years passing, people are generally unaware both of the implied best practice and the fact that the promise constructor helps lead you to it, and on the other hand, the best practice is enforced by async/await. An illustration of the widespread lack of awareness is that no one even raised this concern in committee until you did, and without this awareness, people can't even really be expected to use the promise constructor in the way where it's helpful.

[01:33:29.0463] <rbuckton>
If `dayOfWeek` returns `2`, indicating this is the 2nd day of the week relative to the `firstDayOfWeek`, it could be confusing that both are numbers 1-7 but don't represent the same value.

[01:33:38.0594] <ryzokuken üá≥üá¥>
https://unicode.org/reports/tr35/#UnicodeFirstDayIdentifier

[01:33:46.0417] <ryzokuken üá≥üá¥>
(this is what Shane is talking about)

[01:34:47.0922] <rbuckton>
> <@rbuckton:matrix.org> If `dayOfWeek` returns `2`, indicating this is the 2nd day of the week relative to the `firstDayOfWeek`, it could be confusing that both are numbers 1-7 but don't represent the same value.

Assuming my interpretation is correct. 

[01:38:18.0510] <Bradford Smith>
This Unicode extension for locale identifiers seems nuts to me. You have to use the first part of the identifier "en" to know how to interpret the identification of the day of the week "tue".

[01:42:21.0338] <littledan>
It also maintains a list of all of the delegates to TC39; this is listed in the Ecma memento. When organizations add or remove delegates, someone is supposed to inform Ecma of this so they can update their lists (I think the chairs do this?). But anyway things have gone out of sync.

[01:50:51.0528] <littledan>
I think the summary can omit the back-and-forth that Frank and I had, and instead be in paragraph form. Will Frank be doing this rephrasing, or should I do so? (I don't see Frank here, maybe another Google could ask him?)

[01:51:07.0255] <littledan>
 * I think the summary can omit the back-and-forth that Frank and I had, and instead be in paragraph form. Will Frank be doing this rephrasing, or should I do so? (I don't see Frank here, maybe another Googler could ask him?)

[01:51:59.0685] <littledan>
(or bullet form)

[01:53:28.0183] <Rob Palmer>
Unless the presenter explicitly delegates, they remain responsible for the summary.  The secretary will chase presenters where summaries appear insufficient.  I'll make sure we say this on the Reflector.

[02:07:43.0222] <ryzokuken üá≥üá¥>
Ashley Claymore: should I put the link in the notes?

[02:08:54.0651] <Michael Ficarra>
ryzokuken üá≥üá¥: yes, there is a spot for you to do so already

[02:09:12.0182] <Michael Ficarra>
search for "slides presented but no link in agenda"

[02:14:59.0719] <HE Shi-Jun>
I slightly prefer `offset` solution because I guess developers use BYOB for perf, and would like to use `offset` to get perf benefit (even a little), and even without `offset`, it already complicated üòâ

[02:16:59.0014] <Michael Ficarra>
HE Shi-Jun: I wouldn't want to do that without compelling evidence that the perf is significantly better

[02:17:10.0586] <Michael Ficarra>
also, it would be safe to add later, right?

[02:21:09.0997] <ryzokuken üá≥üá¥>
> <@michaelficarra:matrix.org> ryzokuken üá≥üá¥: yes, there is a spot for you to do so already

done, thanks again for the reminder

[02:22:08.0423] <HE Shi-Jun>
> <@michaelficarra:matrix.org> also, it would be safe to add later, right?

agree it could be add later. I just think it very likely will have some perf benefit, especially on embed engines.

[02:27:15.0855] <Bradford Smith>
So, the alternative to having these "inputOffset" and "outputOffset" parameters is to have to create a separate view into the input & output base arrays on each iteration of the loop?

[02:29:43.0338] <Michael Ficarra>
Bradford Smith: yes, or a shifting view, and views should be very lightweight

[02:30:24.0287] <Michael Ficarra>
 * Bradford Smith: yes, and views should be very lightweight

[02:46:54.0982] <HE Shi-Jun>
After listening all queue discussion, I feel maybe we'd better leave the streaming api to future follow-on proposal ... 

[02:48:12.0314] <Christian Ulbrich>
I think we want the full cake, we want the un-disputed oneshot methods to fast-track, and have the streaming API versions that share consistency with them added later. Looks like a good challenge...

[02:48:48.0806] <Michael Ficarra>
I think the streaming design is as fleshed out as it's going to be, we just need to decide whether it's justified for inclusion or not

[02:49:08.0894] <Michael Ficarra>
I don't think splitting helps with that

[02:50:44.0468] <bakkot>
> <@michaelficarra:matrix.org> Bradford Smith: yes, and views should be very lightweight

views are apparently not that lightweight in JSC per https://github.com/tc39/proposal-arraybuffer-base64/pull/26#issuecomment-1617312928

[02:51:03.0791] <bakkot>
or at least not the first view

[02:51:40.0116] <Michael Ficarra>
*should*

[02:51:58.0011] <tkopp>
I dont think views are in general "lightweight" in comparison to actually know the place where you want to put yyour data

[02:52:28.0435] <tkopp>
> <@michaelficarra:matrix.org> I think the streaming design is as fleshed out as it's going to be, we just need to decide whether it's justified for inclusion or not

But, yes this might be true

[02:52:44.0996] <bakkot>
> <@michaelficarra:matrix.org> *should*

I think there's always going to tradeoffs in any representation, and a representation in which the second view of a buffer is expensive in exchange for the first view being faster is not obviously incorrect

[02:52:52.0890] <bakkot>
so I don't think "should" is at all obvious here

[02:54:24.0000] <bakkot>
Luca Casonato: https://github.com/tc39/proposal-arraybuffer-base64/issues/13 is the streaming issue, and https://github.com/tc39/proposal-arraybuffer-base64/issues/21 the one for encoding into an existing buffer

[02:55:56.0867] <bakkot>
the thing where you have a "prefix" argument to the one-shot API was my first suggestion, if I have understood correctly that this is what you were proposing; see response from justin in https://github.com/tc39/proposal-arraybuffer-base64/issues/13#issuecomment-911968641

[02:56:18.0460] <bakkot>
(and from peter, two comments down)

[03:00:40.0426] <littledan>
re: streaming: I think, in general, it's vaguely best practice that primitives that deals with data should have zero-copy and streaming APIs for doing stuff with them. To me, the main question is whether there are valid use cases for doing base64 on a fairly big thing that can't fit in memory/packets all together. I don't know of such use cases/environments.

[03:01:47.0809] <ryzokuken üá≥üá¥>
might be a bit cursed but I've seen people pass around entire images encoded in base64

[03:02:18.0555] <Michael Ficarra>
that's not even unusual

[03:02:18.0742] <ryzokuken üá≥üá¥>
 * might be a bit cursed but I've seen people pass around entire images encoded in encoded base64

[03:02:52.0075] <ryzokuken üá≥üá¥>
yeah, not sure how ideal it is, but it's certainly not uncommon

[03:03:13.0457] <littledan>
I know but there's a certain limit on how big they can get, right?

[03:04:06.0984] <littledan>
also I don't think HTML has a streaming API to set the src of an img tag...

[03:04:14.0076] <tkopp>
there are a lot of APIs that don't handle binary data at all. You can only send e.g. images via encoding

[03:04:22.0509] <Luca Casonato>
bakkot: My suggestion was this: https://gist.github.com/lucacasonato/06a74fe2658fbe5a2d9c24cc767006c0

No need for any `extra` option on the static API. This performs at most 3 byte copies for every remainder. The code can be optimized further.

[03:05:01.0526] <Michael Ficarra>
at Shape, we one-shot base64 decode something like 150kb of bytecode on the main thread every page load

[03:05:08.0499] <Michael Ficarra>
haven't run into any long task issues yet

[03:05:55.0014] <tkopp>
There is no "real" upper limit of the length of a string. Most of the limits are imposed by the server software that is used

[03:06:10.0467] <Ashley Claymore>
yes please

[03:06:15.0714] <Michael Ficarra>
let me introduce you to my good friend 2**53

[03:06:21.0608] <tkopp>
:D

[03:06:54.0155] <tkopp>
You might compress you string before you hit that ÀÜÀÜ

[03:07:01.0180] <tkopp>
*your

[03:07:14.0245] <bakkot>
ah, got it

[03:07:44.0484] <littledan>
> <@tkopp:matrix.org> there are a lot of APIs that don't handle binary data at all. You can only send e.g. images via encoding

it'd be good to understand use cases like this in some more detail

[03:07:49.0401] <Luca Casonato>
bakkot: do you have a link to your Web Streams impl ontop of the streaming API? I can't find it in your slides

[03:07:56.0024] <Luca Casonato>
 * bakkot: do you have a link to your Web Streams impl ontop of the proposed streaming API? I can't find it in your slides

[03:08:03.0376] <bakkot>
it's in the playground

[03:08:11.0266] <bakkot>
https://tc39.es/proposal-arraybuffer-base64/

[03:08:39.0667] <Luca Casonato>
Ah, thanks!

[03:10:50.0639] <ptomato (at TC39, limited availability)>
rbuckton: my personal opinion is that I'd like to investigate `Symbol.enter` but with what I know at this time, full context manager support seems excessive. I'd hesitate to speak for the committee, but that would be my recommendation

[03:10:50.0954] <tkopp>
soap APIs from transportation/shipping companies come to mind immediately.

[03:11:24.0800] <littledan>
great, I'd love to hear about your experience with these and how they relate to data size and streaming

[03:11:28.0671] <bakkot>
github rest API returns contents as base64-encoded strings

[03:11:54.0509] <bakkot>
for files up to 100MB in size

[03:14:52.0272] <bakkot>
actually I guess only up to 1MB; the API changes a bit for larger files

[03:14:56.0838] <Bradford Smith>
From my point of view Ron was just considering a related problem - how to make sure developers are nudged toward using the resource management features he's defining - and then coming up with a possible solution to this. He presented it as a possible follow-on proposal. DE seemed at first to be saying that this problem is important enough to force changes to the existing stage 3 proposal, but I think he's backed down from this. I think the conclusion is not to include such a feature in the current proposal.

[03:15:19.0969] <rbuckton>
I'll reiterate that I don't have an appetite for full context managers. They add a level of complexity that I'm not sure is suitable for ECMAScript, and they would have a negative impact on the ability for static type checkers like TypeScript to make reasonable assumptions about control flow due to ability for any context manager bound to a `using` to swallow an exception. 

[03:18:34.0245] <Bradford Smith>
Regarding the GC cleanup issue: I thought Ron was suggesting that engines could be encouraged to clean up any disposables that they themselves created (not every possible disposable) if they go out of scope without "leaking" anywhere else from the scope where they were created. 

[03:19:05.0387] <Bradford Smith>
just encouraged, not required

[03:19:37.0644] <rbuckton>
If we're not doing full context managers, then the goal of the proposed change would be to resolve a concern about "unused" disposables. That would be addressed by `Symbol.enter` without the need to introduce a `Symbol.asyncEnter`. `await using` would still verify/capture `[Symbol.asyncDispose]` as it does today, but would call `[Symbol.enter]()` synchronously without the need to introduce an extra `Await` at the declaration site. That would also avoid needing to rethink `AsyncDisposableStack.prototype.use` to handle the async case.

[03:20:18.0955] <Ashley Claymore>
for using `Symbol.enter` as a way for types to _enforce_ they are being assigned to `using`, could this also be done with `Symbol.dipose` setting a `userHasAcknoledgedLifetime` flag that either errors/warns if other methods are called without that flag set?

[03:20:24.0521] <bakkot>
> <@littledan:matrix.org> re: streaming: I think, in general, it's vaguely best practice that primitives that deals with data should have zero-copy and streaming APIs for doing stuff with them. To me, the main question is whether there are valid use cases for doing base64 on a fairly big thing that can't fit in memory/packets all together. I don't know of such use cases/environments.

it's not just about whether it all fits in memory; for example, one might reasonably stream base64'd wasm bytecode into WebAssembly.compileStreaming. the advantage of streaming in this case is that you can start doing work before waiting for the whole download to finish. which is nice!

[03:21:12.0270] <bakkot>
similarly, if you're uploading base64'd data to a server, you might do binary data -> compression stream -> base64 stream -> `fetch`; it's nice to be able to start the network request as early as possible

[03:21:43.0418] <Ashley Claymore>
my gut feeling is also that `DisposeStack.p.return` is a simpler API to explain that the enter/exit symbols.

[03:21:44.0173] <rbuckton>
> <@aclaymore:matrix.org> for using `Symbol.enter` as a way for types to _enforce_ they are being assigned to `using`, could this also be done with `Symbol.dipose` setting a `userHasAcknoledgedLifetime` flag that either errors/warns if other methods are called without that flag set?

Yes, a user-defined implementation could conceivably make `[Symbol.dispose]` a getter that indicates the method was at least read.

[03:21:58.0224] <rbuckton>
> <@aclaymore:matrix.org> my gut feeling is also that `DisposeStack.p.return` is a simpler API to explain that the enter/exit symbols.

what is `return`?

[03:22:03.0391] <Ashley Claymore>
sorry, move

[03:22:06.0860] <Ashley Claymore>
 * sorry, `move`

[03:22:13.0457] <Ashley Claymore>
 * my gut feeling is also that `DisposeStack.p.move` is a simpler API to explain that the enter/exit symbols.

[03:24:46.0181] <rbuckton>
> <@bradfordcsmith:matrix.org> Regarding the GC cleanup issue: I thought Ron was suggesting that engines could be encouraged to clean up any disposables that they themselves created (not every possible disposable) if they go out of scope without "leaking" anywhere else from the scope where they were created.

My intent was to state that as a remediation for an "unused" disposable, a host could leverage GC if necessary to ensure native handles don't leak, and that a user could use `FinalizationRegistry` to do the same. I worded it too strongly to expect that to always be the case, and that the outcome should be resource cleanup rather than a warning message like as what can happen for unhandled promise rejections. That wording was based on my prior experience with C#'s `IDisposable` and the C# team's recommendations to do likewise.

[03:25:24.0264] <Bradford Smith>
> <@rbuckton:matrix.org> Yes, a user-defined implementation could conceivably make `[Symbol.dispose]` a getter that indicates the method was at least read.

Personally, I think you're chasing an impossible goal here. The Explicit Resource Management proposal as-is provides a useful feature. There's no need to try so hard to force its correct use. Leave that problem for another day. Just my $0.02.

[03:26:04.0982] <rbuckton>
> <@aclaymore:matrix.org> sorry, `move`

`move` and `exit` are somewhat orthogonal to each other, so I'm not clear on the correlation you are making?

[03:28:55.0303] <rbuckton>
> <@bradfordcsmith:matrix.org> Personally, I think you're chasing an impossible goal here. The Explicit Resource Management proposal as-is provides a useful feature. There's no need to try so hard to force its correct use. Leave that problem for another day. Just my $0.02.

I concur. JavaScript itself can't reliably enforce lifetimes and ownership in the same way a language like Rust can, as that essentially requires a fully-baked runtime type system. Without that, we would be forced to take a major performance hit for every `var`/`let`/`const` declaration and every assignment to check or transfer ownership of an object's lifetime, which is a non-starter.

[03:29:21.0151] <Ashley Claymore>
for the examples where code is switching if the exit was a throw or return completion. Reaching DisposeStack.p.move also indicates that 

[03:29:28.0113] <Ashley Claymore>
* can also indicate that 

[03:29:36.0049] <rbuckton>
I'm not convinced we even need `[Symbol.enter]()`.

[03:29:59.0588] <rbuckton>
> <@aclaymore:matrix.org> for the examples where code is switching if the exit was a throw or return completion. Reaching DisposeStack.p.move also indicates that

Ah, thank you for the clarification.

[03:32:41.0219] <rbuckton>
> <@rbuckton:matrix.org> I concur. JavaScript itself can't reliably enforce lifetimes and ownership in the same way a language like Rust can, as that essentially requires a fully-baked runtime type system. Without that, we would be forced to take a major performance hit for every `var`/`let`/`const` declaration and every assignment to check or transfer ownership of an object's lifetime, which is a non-starter.

In a way, `DisposableStack.p.move` is a close approximation of Rust's `move` semantics as a way to "transfer ownership on assignment" similar to an affine type system, but in an imperative form:
```js
const stack1 = new DisposableStack();
...
const stack2 = stack1.move(); // stack1 can no longer be used, its contents have been moved to stack2.
...
const stack3 = stack2.move(); // stack2 can no longer be used, its contents have been moved to stack3.
```

[03:33:07.0184] <rbuckton>
(which is part of the reason for the choice of method name as well)

[03:34:09.0148] <rbuckton>
> <@rbuckton:matrix.org> I concur. JavaScript itself can't reliably enforce lifetimes and ownership in the same way a language like Rust can, as that essentially requires a fully-baked runtime type system. Without that, we would be forced to take a major performance hit for every `var`/`let`/`const` declaration and every assignment to check or transfer ownership of an object's lifetime, which is a non-starter.

 * In a way, `DisposableStack.p.move` is a close approximation of Rust's `move` semantics as a way to "transfer ownership on assignment" similar to an affine type system, but in an imperative form:

```js
using stack1 = new DisposableStack();
...
using stack2 = stack1.move(); // stack1 can no longer be used, its contents have been moved to stack2.
...
using stack3 = stack2.move(); // stack2 can no longer be used, its contents have been moved to stack3.
```

[04:01:49.0293] <littledan>
> <@rbuckton:matrix.org> I'm not convinced we even need `[Symbol.enter]()`.

I agree. But if we did want to go in that direction, I think we should retract this proposal to Stage 2, as it's a big change and we don't have a concrete form of this yet.

[04:02:02.0069] <littledan>
I think we should conclude that we're not going in this Symbol.enter direction

[04:02:56.0606] <littledan>
this is just a very big thing to be considered an open question for a Stage 3 proposal

[04:05:24.0149] <rbuckton>
> <@littledan:matrix.org> I think we should conclude that we're not going in this Symbol.enter direction

nicolo-ribaudo's suggestion to make `[Symbol.dispose]` a getter if you want to opt-in to requiring the use of `using` or a `DisposableStack` holds water and may be satisfactory, without the need to introduce a new symbol-named method to the Disposable protocol: https://github.com/tc39/proposal-explicit-resource-management/issues/159#issuecomment-1630532470

[04:25:02.0382] <Michael Ficarra>
it's so strange to me that IETF would explicitly *not* want to support sub-minute offsets

[04:25:21.0014] <Michael Ficarra>
it just feels like painting yourself into a corner for no good reason

[04:25:51.0665] <shu>
be the change you want to see in the world

[04:26:05.0419] <shu>
do you want sub-minute offset timezone in the world

[04:26:17.0593] <Michael Ficarra>
I am not a politician, I do not get to decide that

[04:26:22.0208] <ryzokuken üá≥üá¥>
they considered it vestigial and unnecessary

[04:26:29.0086] <ryzokuken üá≥üá¥>
 * they considered it vestigial and unnecessary moving forwards

[04:26:36.0713] <bakkot>
if all the computer people collectively refuse to implement support for it, what are the politicians gonna do?

[04:26:41.0899] <ryzokuken üá≥üá¥>
fwiw, the ISO format still accepts all sorts of input

[04:26:43.0352] <Michael Ficarra>
I would not be at all surprised if the DPRK changed their timezone (again) to a sub-minute offset

[04:26:46.0519] <bakkot>
the time is whatever my phone tells me it is, not what a politician announces

[04:26:48.0902] <ryzokuken üá≥üá¥>
but IETF prefers to maintain a leaner profile

[04:27:10.0009] <shu>
> <@michaelficarra:matrix.org> I am not a politician, I do not get to decide that

you sell yourself short dear mr ficarra

[04:27:18.0144] <Michael Ficarra>
bakkot: the DPRK makes their own OS

[04:27:31.0189] <shu>
i too skinned Linux when i was 10

[04:28:09.0018] <ryzokuken üá≥üá¥>
> <@michaelficarra:matrix.org> bakkot: the DPRK makes their own OS

I really wanted to respond but this isn't TDZ üòõ 

[04:28:55.0537] <shu>
yes, the limitation of being unhinged and deranged about time zones

[04:51:38.0020] <ptomato (at TC39, limited availability)>
FWIW, `Asia/Pyongyang` could still have a sub-minute offset. the limitation doesn't apply to named time zones

[04:54:17.0596] <ryzokuken üá≥üá¥>
Yes, this only applies to in-timestamp offsets

[04:59:40.0555] <littledan>
I think the details of whether engines ship the Intl-only part separately or just together with Intl is something that we can leave to engines to decide. If an engine expects to take a really long time to do Temporal, they might do the Intl-only part. But Temporal should only ship with this included, and it'd be valid to ship at the same time. Within this, I think 2a would be the simplest way to organize the explanations.

[05:02:47.0075] <littledan>
> <@littledan:matrix.org> I think the details of whether engines ship the Intl-only part separately or just together with Intl is something that we can leave to engines to decide. If an engine expects to take a really long time to do Temporal, they might do the Intl-only part. But Temporal should only ship with this included, and it'd be valid to ship at the same time. Within this, I think 2a would be the simplest way to organize the explanations.

err, never mind--I'm convinced by what Shu and Justin said, about how missing the .equals method is fatal for shipping separately

[05:05:04.0393] <shu>
sffc: no we can't implement the non-temporal parts sooner

[05:05:11.0432] <shu>
because of what dan just said

[05:09:10.0194] <sffc>
It still seems like we should stop returning Saigon and Kiev despite the lack of a Temporal.TimeZone.prototype.equals

[05:10:08.0107] <ptomato (at TC39, limited availability)>
that's what I was getting at, but I take Shu's point that that causes interoperability problems

[05:11:45.0978] <bakkot>
I do like this proposal but I still wish we had `import program from 'source.wasm' with { imports: whatever, memory: new ArrayBuffer(1000) }` etc

[05:12:38.0521] <bakkot>
instead of needing to import the source and then compile it yourself

[05:12:41.0274] <bakkot>
that's just kinda silly

[05:12:46.0366] <shu>
is that a static import with a `new ArrayBuffer`

[05:12:51.0341] <shu>
how does that work

[05:12:52.0202] <nicolo-ribaudo>
> <@bakkot:matrix.org> I do like this proposal but I still wish we had `import program from 'source.wasm' with { imports: whatever, memory: new ArrayBuffer(1000) }` etc

Evaluating expressions even before linking the modiule graph seems... hard

[05:13:12.0160] <nicolo-ribaudo>
> <@bakkot:matrix.org> I do like this proposal but I still wish we had `import program from 'source.wasm' with { imports: whatever, memory: new ArrayBuffer(1000) }` etc

 * Evaluating expressions even before linking the module graph seems... difficult

[05:13:35.0779] <bakkot>
you do the downloading and so on right away but don't do the actual instantiation until you hit the `import` declaration

[05:13:39.0066] <bakkot>
this does not seem hard to me?

[05:14:25.0720] <sffc>
> <@pchimento:igalia.com> that's what I was getting at, but I take Shu's point that that causes interoperability problems

ok, sorry for my misunderstanding

[05:14:46.0733] <nicolo-ribaudo>
And you cannot capture bindings from outside the import declaration? i.e.

```js
let buf = new ArrayBuffer()
import program from 'source.wasm' with { memory: buf } 
```

[05:15:27.0104] <bakkot>
no I am imagining that would work as written

[05:15:34.0819] <bakkot>
don't see why it shouldn't

[05:15:36.0398] <nicolo-ribaudo>
That could work with CJS where modules are evaluated before their dependencies, but with ESM `buf` does not exist until when all the imported modules are evaluated

[05:15:57.0130] <bakkot>
there are multiple notions of "evaluated" wrt wasm

[05:16:38.0994] <bakkot>
the obvious thing for it to do is to download the thing but not actually instantiate until you hit the import declaration, at which point `buf` is available

[05:16:57.0949] <shu>
what is "hit the import declaration"

[05:17:16.0348] <bakkot>
like, get to that line in the program

[05:17:17.0321] <Michael Ficarra>
evaluation semantics for an ImportDeclaration

[05:18:16.0737] <shu>
the import declaration is just parsed and collected and processed ahead of time right now, it's not even in the compiled AST

[05:18:20.0578] <shu>
i don't think import has evaluation does it

[05:18:31.0659] <shu>
like we could add it but that seems a radical departure from what it does right now

[05:18:48.0162] <shu>
 * the import declaration is just parsed and collected and processed ahead of time right now, it's not even in the AST sent to the compiler

[05:18:56.0784] <nicolo-ribaudo>
Also, import declarations are hoisted. Capturing from inside them has the same problems discussed for function declaration decorators

[05:19:06.0607] <bakkot>
to be clear I am not super-seriously proposing this

[05:19:17.0483] <bakkot>
I agree the hoisting is annoying technically

[05:19:28.0278] <bakkot>
however, no real program relies on hoisting import declarations, because that's batshit

[05:19:29.0807] <nicolo-ribaudo>
Also to be clear, I also hope we'll have direct imports for wasm one day

[05:19:47.0291] <bakkot>
so it still feels like the code sample above should just work as written

[05:20:03.0047] <ljharb>
hm, can you `class extends AbstractModuleSource { }` if it's not constructable or callable?

[05:20:13.0416] <shu>
i don't understand the spec draft as written

[05:20:14.0554] <littledan>
if you use direct Wasm imports, then that Wasm module can import a memory from a different ESM module that explicitly constructs it.

[05:20:16.0379] <bakkot>
> <@bakkot:matrix.org> however, no real program relies on hoisting import declarations, because that's batshit

(hoisting in the function declaration sense, that is)

[05:20:19.0578] <nicolo-ribaudo>
> <@ljharb:matrix.org> hm, can you `class extends AbstractModuleSource { }` if it's not constructable or callable?

Yes but you cannot then call `super()`

[05:20:39.0739] <shu>
> (hoisting in the function declaration sense, that is)
really? you don't write mutually recursive functions?

[05:20:47.0656] <shu>
 * > (hoisting in the function declaration sense, that is)

really? you don't write mutually recursive functions?

[05:21:00.0981] <ljharb>
> <@nicolo-ribaudo:matrix.org> Yes but you cannot then call `super()`

ok so there's no way for a subclass to get the internal slot in a self-hosted-in-JS implementation?

[05:21:10.0502] <nicolo-ribaudo>
> <@shuyuguo:matrix.org> > (hoisting in the function declaration sense, that is)
> 
> really? you don't write mutually recursive functions?

Well, you don't write mutually recursive imports

[05:21:21.0031] <shu>
oh i misunderstood the point

[05:21:34.0201] <shu>
not that nobody relies on the hoisting function semantics, but the hoisting import semantics that are like the hoisting function semantics

[05:21:36.0090] <littledan>
It's pretty common to use function hoisting in a sillier way, like

```js
foo.onbar = fn;
function fn() { }
```

In fact, fear of breaking this particular pattern is what's holding back function decorators

[05:21:51.0062] <bakkot>
> <@shuyuguo:matrix.org> not that nobody relies on the hoisting function semantics, but the hoisting import semantics that are like the hoisting function semantics

right exactly

[05:21:54.0218] <littledan>
> <@shuyuguo:matrix.org> not that nobody relies on the hoisting function semantics, but the hoisting import semantics that are like the hoisting function semantics

anyway yes this is how import statements work

[05:22:21.0767] <bakkot>
concretely, no one writes an `import` declaration at the bottom of a file and code which runs right away which uses a binding from the `import` at the top of the file

[05:22:22.0907] <Michael Ficarra>
nicolo-ribaudo: it shouldn't unconditionally throw, it should just throw if it's its own NewTarget

[05:22:54.0128] <shu>
i think the current spec draft is just wrong about the abstract constructor thing

[05:22:59.0819] <Michael Ficarra>
https://github.com/tc39/ecma262/pull/3094#discussion_r1230304753

[05:23:01.0666] <nicolo-ribaudo>
(I need to look at the proposal spec before answering to that)

[05:23:02.0403] <shu>
it's unconditionally throwing now but the comment suggests otherwise

[05:23:16.0136] <littledan>
> <@shuyuguo:matrix.org> it's unconditionally throwing now but the comment suggests otherwise

This is resolved by the Wasm subclass behavior

[05:23:28.0229] <shu>
how can you resolve that in the subclass behavior

[05:23:52.0796] <shu>
what installs the brand?

[05:23:58.0826] <littledan>
the cyclic module record superclass throws; the wasm module subclass does another thing

[05:24:11.0493] <littledan>
it's installed when parsing the Wasm module, by construction

[05:24:12.0201] <rbuckton>
> <@littledan:matrix.org> It's pretty common to use function hoisting in a sillier way, like
> 
> ```js
> foo.onbar = fn;
> function fn() { }
> ```
> 
> In fact, fear of breaking this particular pattern is what's holding back function decorators

sillier? This is a common practice in the TS codebase, i.e.:
```ts
function createFoo() {
  const quxx = ...;

  return {
    bar,
    baz,
  };

  function bar() { ... }
  function baz() { ... }
}
```

[05:24:23.0473] <littledan>
> <@rbuckton:matrix.org> sillier? This is a common practice in the TS codebase, i.e.:
> ```ts
> function createFoo() {
>   const quxx = ...;
> 
>   return {
>     bar,
>     baz,
>   };
> 
>   function bar() { ... }
>   function baz() { ... }
> }
> ```

sorry I shouldn't've included a value judgement

[05:24:25.0924] <shu>
littledan: i don't understand. happy to see spec text though

[05:24:54.0723] <littledan>
shu: https://webassembly.github.io/esm-integration/js-api/index.html#get-module-source

[05:25:09.0966] <shu>
how does that interface with %AbstractModuleSource%

[05:25:42.0504] <nicolo-ribaudo>
It sets the internal slot in step 4 of https://webassembly.github.io/esm-integration/js-api/index.html#construct-a-webassembly-module-object

[05:25:53.0020] <littledan>
(oops sorry I was answering the wrong question)

[05:26:05.0437] <bakkot>
someone is typing loudly again

[05:26:19.0464] <nicolo-ribaudo>
However yes, there is no way for JS code to create objects with that internal slot with the current spec (@ljharb)

[05:26:23.0324] <nicolo-ribaudo>
> <@bakkot:matrix.org> someone is typing loudly again

Sorry, me

[05:26:24.0134] <ljharb>
that seems like a problem

[05:26:49.0912] <littledan>
> <@bakkot:matrix.org> someone is typing loudly again

did it stop for you?

[05:26:53.0920] <nicolo-ribaudo>
Do y'all think that throwing only if constructed directly would be an acceptable solution?

[05:27:07.0450] <ljharb>
that works for me

[05:27:11.0211] <nicolo-ribaudo>
> <@nicolo-ribaudo:matrix.org> Do y'all think that throwing only if constructed directly would be an acceptable solution?

(I do not remember why we throw)

[05:27:13.0447] <ljharb>
 * that works for me, based on new.target or something

[05:27:15.0532] <bakkot>
> <@littledan:matrix.org> did it stop for you?

it has stopped now yes

[05:28:06.0095] <Michael Ficarra>
nicolo-ribaudo: yes, that is what we suggested here: https://github.com/tc39/ecma262/pull/3094#discussion_r1230304753

[05:28:48.0752] <nicolo-ribaudo>
I'm trying to find references as to why we introduced the throwing behavior in the first place

[05:29:27.0069] <littledan>
if there's no JS-exposed API for setting that internal brand slot (e.g., a super constructor parameter), then the constructor isn't very useful

[05:29:32.0848] <littledan>
whether or not it throws

[05:30:01.0191] <ljharb>
hm, that is true

[05:30:12.0103] <ljharb>
it seems important to be able to self-host in JS tho

[05:30:34.0546] <littledan>
to me this feels like something that's OK to unconditionally throw "for now" with a hope that we expand this out soon (maybe in the context of compartments)

[05:31:07.0558] <nicolo-ribaudo>
> <@ljharb:matrix.org> it seems important to be able to self-host in JS tho

Without custom module loading you cannot self-host modules anyway

[05:31:28.0024] <ljharb>
you could with on-the-fly source rewriting, no?

[05:31:40.0321] <littledan>
"instantiable" would be a name reflecting intuition? I think this sounds just vaguely computer-y.

[05:31:43.0042] <ljharb>
 * you could with on-the-fly source rewriting, no? i don't mean virtualization which indeed would require custom module loading

[05:32:21.0074] <Michael Ficarra>
I don't like any of these new name suggestions

[05:32:28.0165] <Michael Ficarra>
the exiting names are fine

[05:32:37.0037] <littledan>
> <@ljharb:matrix.org> you could with on-the-fly source rewriting, no? i don't mean virtualization which indeed would require custom module loading

If you're rewriting source, why do you care about using a real source object at all?

[05:32:41.0845] <Michael Ficarra>
 * the existing names are fine

[05:32:46.0999] <Ashley Claymore>
'source' is much easier to write and spell than 'instantiable'

[05:33:00.0024] <ljharb>
> <@littledan:matrix.org> If you're rewriting source, why do you care about using a real source object at all?

because user code would still need to interact with the resulting source phase object

[05:33:23.0352] <littledan>
sorry, which sorts of interactions are you picturing?

[05:33:37.0807] <danielrosenwasser>
> <@aclaymore:matrix.org> 'source' is much easier to write and spell than 'instantiable'

The good news is this is a power-user feature with a keyword that can get auto-completed

[05:34:21.0336] <Michael Ficarra>
importing and using wasm is power user now?

[05:34:23.0786] <ljharb>
> <@littledan:matrix.org> sorry, which sorts of interactions are you picturing?

anything that's observable. i don't have a use case except that a self-hosted implementation should be able to be made indistinguishable from a C++ one

[05:34:36.0575] <littledan>
> <@michaelficarra:matrix.org> importing and using wasm is power user now?

when linking it yourself? yes, I think so

[05:34:37.0237] <ljharb>
since when has it not been

[05:34:50.0142] <Ashley Claymore>
I wish writing code snippets in non-IDES have auto-complete

[05:35:00.0519] <Ashley Claymore>
 * I wish writing code snippets in non-IDEs had auto-complete

[05:36:09.0432] <Bradford Smith>
I find "instantiable" even less understandable than "source".

[05:36:39.0186] <danielrosenwasser>
What's your definition of an IDE? Even notepad++ has auto-complete for JavaScript :D

[05:36:48.0188] <danielrosenwasser>
 * What's your definition of a non-IDE? Even notepad++ has auto-complete for JavaScript :D

[05:36:51.0861] <Michael Ficarra>
apparently I don't understand the limits of the average developer nowadays

[05:36:55.0201] <Ashley Claymore>
Matrix

[05:36:58.0320] <Ashley Claymore>
github

[05:37:02.0495] <Ashley Claymore>
Slack

[05:37:07.0899] <Ashley Claymore>
Whatsapp

[05:37:12.0647] <bakkot>
not convinced you ever did

[05:37:15.0067] <Ashley Claymore>
 * Whatsapp ;)

[05:37:32.0966] <shu>
i'm surprised but point taken

[05:37:37.0345] <Michael Ficarra>
Twitter bio

[05:37:39.0915] <danielrosenwasser>
If someone judges you for a code typo in Whatsapp please let me yell at them

[05:37:43.0012] <Ashley Claymore>
Threads?

[05:37:44.0299] <bakkot>
that said it is getting less and less power-user-y as it becomes a more first-class target in languages like go and rust

[05:37:48.0014] <shu>
(like, what do you think you want to do with the thing you get from this phase, if not to instantiate it later?)

[05:37:48.0137] <ryzokuken üá≥üá¥>
no JS in Whatsapp please

[05:37:52.0358] <danielrosenwasser>
JavaScript doesn't have threads

[05:38:06.0188] <ryzokuken üá≥üá¥>
does Threads have JS tho?

[05:38:13.0760] <ryzokuken üá≥üá¥>
sorry, I'll show myself out

[05:38:24.0087] <nicolo-ribaudo>
> <@shuyuguo:matrix.org> (like, what do you think you want to do with the thing you get from this phase, if not to instantiate it later?)

Well, with WebAssembly.Module you might do reflection and nothing else

[05:38:25.0666] <danielrosenwasser>
Probably only in a bytecode format nowadays

[05:38:40.0907] <danielrosenwasser>
 * Probably only in Hermes' bytecode format nowadays

[05:38:43.0503] <nicolo-ribaudo>
But yes, you would almost always want to instantiate it

[05:38:50.0504] <shu>
i don't get what that means, you just want to hold on to it?

[05:38:51.0983] <Michael Ficarra>
I think ljharb is saying the opposite?

[05:38:55.0461] <ryzokuken üá≥üá¥>
HHVM for JS

[05:39:09.0679] <nicolo-ribaudo>
WebAssembly.Module.imports() or exports()

[05:39:14.0699] <Ashley Claymore>
https://nodejs.org/api/worker_threads.html#workerismainthread

[05:39:24.0059] <nicolo-ribaudo>
 * WebAssembly.Module.imports() or .exports()

[05:39:25.0714] <Michael Ficarra>
as it gets support in languages targeting wasm, using it manually becomes more niche

[05:39:27.0939] <Ashley Claymore>
how can their be a main thread if there are no threads......

[05:39:31.0195] <ryzokuken üá≥üá¥>
it's part of the host, not JS

[05:39:31.0665] <Ashley Claymore>
:D

[05:39:34.0770] <danielrosenwasser>
`import reflectable`

[05:39:39.0497] <ryzokuken üá≥üá¥>
üôà

[05:39:46.0913] <ryzokuken üá≥üá¥>
I'm bad at jokes

[05:40:05.0433] <Andreu Botella>
`import sourceable`

[05:40:23.0709] <danielrosenwasser>
No, you're doing good here by backing *my* joke  ryzokuken üá≥üá¥ ,

[05:40:34.0426] <danielrosenwasser>
`import saucable`

[05:40:39.0632] <danielrosenwasser>
oh no

[05:40:44.0143] <danielrosenwasser>
`import sauceable`?

[05:40:44.0445] <ryzokuken üá≥üá¥>
I think I'm old enough to start writing my own jokes eventually

[05:40:48.0014] <eemeli>
`import raw`

[05:41:01.0033] <Bradford Smith>
`import uninstantiated`?

[05:41:09.0488] <Michael Ficarra>
this is not TDZ

[05:41:12.0498] <Andreu Botella>
`import saukable`

[05:41:14.0670] <shu>
uninstantiated is fine but how is that worse than instantiable?

[05:41:22.0269] <ljharb>
i would argue that usage of "not JS" to interoperate directly with JS is still a power user thing

[05:41:34.0435] <ryzokuken üá≥üá¥>
> <@eemeli:mozilla.org> `import raw`

that could work actually

[05:41:36.0069] <bakkot>
"uninstantiated" is at least a word I have literally ever used before

[05:41:44.0122] <ljharb>
a word can be more precise and yet worse ergonomically

[05:41:47.0561] <bakkot>
"raw" sounds more like asset/blob/bytes to me

[05:41:59.0220] <danielrosenwasser>
But how often is this word getting typed out?

[05:41:59.0740] <Bradford Smith>
An "uninstantiated module" makes sense to me more than "instantiable module"

[05:42:15.0251] <ljharb>
 * i would argue that usage of "not JS" to interoperate directly with JS is still a power user thing, and will likely remain so for the foreseeable future

[05:42:52.0451] <ljharb>
> <@danielrosenwasser:matrix.org> But how often is this word getting typed out?

hopefully often enough to warrant this proposal advancing

[05:45:09.0747] <bakkot>
I think for JS developers, yes

[05:45:27.0048] <ljharb>
what are the "phases" identified for modules during this process? like what comes after "source"

[05:45:35.0152] <bakkot>
but if you are a Go programmer, you are going to want to write Go, and then a small JS wrapper to let the Go program interact with the webapp

[05:45:42.0015] <shu>
`raw` is worse than `source` for the same confusion, yeah

[05:45:51.0136] <bakkot>
and the way you do that is, you compile the Go to wasm, and then import the wasm from a JS module

[05:45:55.0690] <littledan>
honestly `import compiled` captures things well for Wasm (or `import parsed`??), but I'm not sure if it will be intuitive.

[05:45:59.0504] <bakkot>
this does not require being a poweruser of either language

[05:46:13.0906] <danielrosenwasser>
I was going to make a `String.raw` joke but Michael Ficarra  said this wasn't TDZ

[05:46:16.0680] <Andreu Botella>
I guess some people might think that it AOT-compiles the module code for JS?

[05:46:30.0096] <Andreu Botella>
 * I guess some people might think that `import compiled` AOT-compiles the module code for JS?

[05:47:11.0729] <bakkot>
do we imagine using this for things other than wasm

[05:47:17.0378] <Michael Ficarra>
no one is stopping you from making terrible jokes in TDZ

[05:47:18.0671] <bakkot>
if not, can we just make it `import.wasm`

[05:47:35.0141] <danielrosenwasser>
My impression is that the anticipated frequency of use is not the reason why this proposal exists - moreso, it's a small set of important use-cases that compose well

[05:47:39.0809] <nicolo-ribaudo>
> <@bakkot:matrix.org> do we imagine using this for things other than wasm

KKL has a proposal for JS sources

[05:47:57.0460] <nicolo-ribaudo>
To do reflection on them, as well as custom linking

[05:48:02.0875] <bakkot>
ah, right

[05:48:11.0560] <bakkot>
and to bypass CSP I guess

[05:48:21.0523] <bakkot>
 * and to avoid running afoul of CSP I guess

[05:48:35.0319] <danielrosenwasser>
> <@danielrosenwasser:matrix.org> My impression is that the anticipated frequency of use is not the reason why this proposal exists - moreso, it's a small set of important use-cases that compose well

Which is why "pick the most explicit name" seems like the right option for me

[05:48:35.0577] <nicolo-ribaudo>
Yep, to avoid eval-like

[05:48:55.0942] <danielrosenwasser>
> <@danielrosenwasser:matrix.org> My impression is that the anticipated frequency of use is not the reason why this proposal exists - moreso, it's a small set of important use-cases that compose well

 * Which is why "pick the most explicit name" seems like the right option for me, even if it's a little verbose

[05:49:12.0365] <danielrosenwasser>
But `import source` is still better than `import module`

[05:49:16.0069] <bakkot>
that suggests maybe `import.reflect`?

[05:49:42.0908] <Michael Ficarra>
please, source is fine üò©

[05:49:44.0113] <bakkot>
though I guess reflection might suggest also evaluation

[05:50:06.0792] <nicolo-ribaudo>
> <@bakkot:matrix.org> that suggests maybe `import.reflect`?

I think this was the original world in the proposal, but there are two use cases (custom instantiation and reflection) and it only covers one

[05:50:07.0925] <Rob Palmer>
`import fetched`

[05:50:31.0529] <bakkot>
`fetched` also suggests just raw bytes to me

[05:50:50.0992] <shu>
maybe the answer is there is just no intuition for half-processed things having names

[05:51:00.0002] <Rob Palmer>
`import parsed`

[05:51:05.0383] <nicolo-ribaudo>
> <@shuyuguo:matrix.org> maybe the answer is there is just no intuition for half-processed things having names

`import half mod from "x"`

[05:51:31.0425] <shu>
`parsed` i can live with but wasm isn't parsed but validated?

[05:51:47.0933] <bakkot>
validation is like parsing

[05:51:50.0596] <nicolo-ribaudo>
`analyzed`

[05:51:51.0074] <shu>
yeah

[05:51:57.0168] <shu>
`parsed` sgtm

[05:52:01.0612] <shu>
who hates `parsed`

[05:52:09.0274] <shu>
who hates the truth

[05:52:09.0736] <bakkot>
I could live with `parsed`

[05:52:32.0302] <nicolo-ribaudo>
What I dislike about it is that also a fully evaluated module has been parsed

[05:52:47.0788] <Michael Ficarra>
yeah but it's "only" parsed

[05:52:51.0048] <bakkot>
a fully evaluated module has also been source though

[05:52:56.0289] <shu>
yeah, pragmatics!!

[05:53:13.0034] <shu>
implicatures, specifically

[05:53:44.0146] <bakkot>
love me a gricean implicature


[05:54:05.0311] <Jesse (TC39)>
ooh grice fans

[05:54:54.0927] <Chris de Almeida>
we do have some time available tomorrow if folks would like to have further discussion regarding source phase imports naming

[05:55:09.0356] <Jesse (TC39)>
the Racket programming language uses "syntax" to refer to data that has been parsed -- ranging from simple expressions like `42` to entire modules -- but not yet evaluated

[05:56:02.0382] <shu>
that's in the context of macros

[05:56:22.0439] <shu>
in that there's a unified representation they manipulate

[05:56:29.0607] <shu>
whereas the thing we're getting is just kinda abstract

[05:56:56.0813] <Chris de Almeida>
> <@danielrosenwasser:matrix.org> `import sauceable`?

I would unironically support `sauce`

[05:57:13.0953] <Andreu Botella>
<del>`import abstract mod from "paper.js";`</del>

[05:57:19.0923] <bakkot>
> <@softwarechris:matrix.org> I would unironically support `sauce`

that would be so confusing as an english language learner

[05:57:33.0963] <Chris de Almeida>
fair

[05:57:39.0942] <bakkot>
> <@softwarechris:matrix.org> we do have some time available tomorrow if folks would like to have further discussion regarding source phase imports naming

maybe come back and see if `import parsed` is amenable to everyone?

[05:59:18.0974] <bakkot>
> <@shuyuguo:matrix.org> `parsed` i can live with but wasm isn't parsed but validated?

also since it gives you a different representation than the input I think it is in fact parsed rather than validated?

[05:59:30.0673] <shu>
bakkot: okay i'm convinced

[05:59:35.0450] <bakkot>
at least according to the taxonomy of https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/

[05:59:48.0634] <shu>
also just polled internally

[05:59:55.0488] <shu>
V8 can live with `parsed`

[06:00:31.0299] <bakkot>
how did you conduct a representative sample poll at 6am

[06:00:37.0372] <bakkot>
I guess v8 is mostly in munich, nvm

[06:01:55.0877] <Christian Ulbrich>
TCQ pretty rough... -> https://github.com/ChristianUlbrich/tcq/tree/contemporary-edition I split into three packages and decided that it is not worthwhile to get the old stuff to working, so I am just porting the client to contemporary Vue...

[06:02:29.0253] <Christian Ulbrich>
Hope I have the client ported by the end of the day, what I am seeing is "special" to say the least, bust one step at a time...

[06:05:49.0422] <Chris de Almeida>
sorcery!

[06:06:02.0140] <Chris de Almeida>
> <@bakkot:matrix.org> maybe come back and see if `import parsed` is amenable to everyone?

guybedford: Luca Casonato some folks here signaling it may be useful to spend some time tomorrow.  thoughts?

[06:06:26.0393] <eemeli>
If we change to something else from `import source`, should/will the "module source" references in the proposal also be updated?

[06:08:04.0832] <ljharb>
probably yes

[06:08:15.0512] <Jesse (TC39)>
ChatGPT ought to be able to suggest some terms

[06:14:13.0652] <shu>
eemeli: IMO that's not important at all

[06:14:22.0106] <shu>
it's not going to be an uttered name really

[06:15:16.0153] <ljharb>
when the proposal for JS ModuleSource objects arrives, that part will be

[06:15:48.0819] <eemeli>
shu: Not sure that I agree. We still need a generic name for the thing you get from this statement.

[06:16:25.0675] <shu>
sure, you need a name, but it's not a thing that developers are going to be typing, so i think any name is fine, really

[06:16:43.0041] <shu>
_once_ the JS module thing itself exists, that might be typed, and we should be more careful about that

[06:40:56.0091] <Luca Casonato>
https://github.com/tc39/proposal-source-phase-imports/issues/53

[06:41:05.0566] <yulia | Back in October>
> <@shuyuguo:matrix.org> i understand Yulia's original claim to be "ESM performance story is not viable without this feature"

<still on leave, may not be able to actually answer here later> I wouldn't say it isn't viable, a code base can be entirely rewritten just for performance gains, at the cost of developing new features etc. But what we have found is that the rewriting of applications is unrealistic, and this stops people from moving to modules all together. 

[06:42:01.0747] <littledan>
whoa Yulia is here! I just want to take this opportunity to thank you for organizing the meeting here in Bergen. It's a beautiful city and great to meet this very relevant and insightful academic research group.

[06:42:22.0962] <yulia | Back in October>
oh that is lovely to hear! i hope we can work more with the community there, they are very excited about tc39

[06:43:11.0923] <littledan>
> <@yulia:mozilla.org> oh that is lovely to hear! i hope we can work more with the community there, they are very excited about tc39

Yes, I hope so too. Talking to them, I think they didn't realize that they were actual TC39 members and can participate as delegates if they want, not just observe. I think there's a big opportunity for collaboration

[06:43:31.0668] <ryzokuken üá≥üá¥>
I talked about some folks from the uni about this earlier

[06:44:02.0837] <yulia | Back in October>
Mikhail Barash is really great to work with, I've really enjoyed collaborating with the students at Bergen. Would love to join myself next year if we can do a plenary there again. 

[06:44:15.0500] <yulia | Back in October>
my overlord is calling, i have to run.

[06:44:16.0985] <ryzokuken üá≥üá¥>
Hoping we can improve our relationships with all of our researcher colleagues and utilize academic techniques to analyze proposals in addition to everything we do now

[06:44:48.0986] <yulia | Back in October>
enjoy the plenary everyone!

[06:48:07.0455] <yulia | Back in October>
> <@shuyuguo:matrix.org> i understand Yulia's original claim to be "ESM performance story is not viable without this feature"

 * \<still on leave, may not be able to actually answer here later> I wouldn't say it isn't viable, thats maybe too broad. a web code base can be entirely rewritten just for performance gains, at the cost of developing new features etc. But what we have found is that the rewriting of applications is unrealistic, and this stops people from moving to modules all together. In addition, this doesn't work so well when we consider non-web js applications, such as a good portion of the FX codebase, where we cannot use loading techniques such as module-preload

[06:49:03.0157] <yulia | Back in October>
 * \<still on leave, may not be able to actually answer here later> I wouldn't say it isn't viable, thats maybe too broad. a web code base can be entirely rewritten just for performance gains, at the cost of developing new features etc. But what we have found is that the rewriting of applications is unrealistic, and this stops people from moving to modules all together. In addition, this doesn't work so well when we consider non-web js applications that share modules with web applications, such as a good portion of the FX codebase, where we cannot use loading techniques such as module-preload

[06:50:28.0689] <Michael Ficarra>
apparently NTSC framerate is defined as a ratio as well

[06:51:22.0523] <Andreu Botella>
We should push for a version of BigDecimal where 0.99999... != 1

[06:58:03.0501] <shu>
ugh the web zoom client like pauses the video if i background the tab i think

[06:58:05.0411] <shu>
and it can't recover

[06:58:36.0399] <ryzokuken üá≥üá¥>
the web zoom client is terrible 

[06:58:38.0038] <shu>
this wasn't happening as much yesterday

[06:58:45.0145] <ryzokuken üá≥üá¥>
but the app doesn't work on my computer üòÖ

[06:58:50.0448] <ryzokuken üá≥üá¥>
 * but the app doesn't work on my computer either üòÖ

[06:59:50.0889] <shu>
well i can't install it per corp policy...

[07:00:04.0408] <ljharb>
does corp policy let you use parallels?

[07:00:19.0992] <ljharb>
 * does corp policy let you use parallels? you could have a mac in your mac and install zoom on the guest mac

[07:00:23.0102] <shu>
do i want to install parallels

[07:01:40.0115] <ryzokuken üá≥üá¥>
(I know this is an unproductive discussion, sorry)

[07:06:57.0498] <Michael Ficarra>
dminor: they are talking about our proposed normalisation and omission if Infinity/NaN

[07:07:14.0265] <Michael Ficarra>
 * dminor: they are talking about our proposed normalisation and omission of Infinity/NaN

[07:07:21.0248] <littledan>
but it's Waldemar who wants normalization...

[07:07:26.0954] <littledan>
I think the coercion with numbers is just an error

[07:07:29.0790] <ryzokuken üá≥üá¥>
IEEE standards are paywalled?

[07:07:45.0708] <Michael Ficarra>
I am skeptical about the perf claims, there mostly isn't hardware acceleration for Decimal128 yet

[07:07:58.0391] <dminor>
Ok, so is this IEEE 754 decimal128 or not?

[07:07:58.0526] <Michael Ficarra>
so no matter what, you're implementing it using integer maths

[07:08:36.0216] <Michael Ficarra>
*mostly*

[07:09:25.0756] <ryzokuken üá≥üá¥>
but these implementations could improve perf over time as hardware acceleration crops up

[07:10:03.0881] <littledan>
dminor: Yes, the idea is that we'd use IEEE Decimal128

[07:10:57.0460] <Chris de Almeida>
> <@usharma:igalia.com> IEEE standards are paywalled?

yes...  are you looking for something?  `<laughs in hidden>`

[07:12:10.0509] <Michael Ficarra>
where did it say that decimals have object identity?

[07:13:22.0821] <shu>
it doesn't have operator overloading

[07:13:50.0892] <nicolo-ribaudo>
I thought the operator overloading discussion was about math operators

[07:14:01.0911] <shu>
=== is an operator

[07:14:34.0380] <nicolo-ribaudo>
Yeah for some reason I never realized it was part of that discussion

[07:14:36.0026] <ljharb>
oh oof, it wouldn't be a primitive?

[07:14:42.0939] <shu>
nope

[07:14:47.0596] <ljharb>
i don't see any point in doing a number system if it's not a primitive

[07:15:17.0518] <Michael Ficarra>
defining behaviour for `===` does not mean operator overloading

[07:15:33.0606] <Michael Ficarra>
operator overloading means deferring to some user code, no?

[07:15:45.0985] <chipmorningstar>
What about `+`?

[07:15:50.0120] <shu>
in this context it means overloading existing syntax operators

[07:15:55.0347] <Chris de Almeida>
It's dangerous to go alone!  Take this.

[07:15:57.0570] <shu>
not necessarily user code

[07:16:00.0196] <Michael Ficarra>
defining behaviour for maths operators does not mean operator overloading

[07:16:14.0515] <ljharb>
i also understand the term "operator overloading" to mean for user code

[07:16:19.0094] <shu>
the constraint from engines is we don't want to add new paths to operators

[07:16:27.0992] <shu>
what phrase should be used for that constraint?

[07:16:40.0439] <Rob Palmer>
"builtin operator overloading"

[07:16:42.0767] <ljharb>
that position effectively kills a bunch of useful proposals, including decimal, imo

[07:16:45.0921] <shu>
where operator includes all operators, `+` and `===` etc

[07:16:49.0485] <Michael Ficarra>
shu: no new primitives

[07:16:53.0347] <rbuckton>
there's a distinction between user-defined operator overloading and the fact that JS operators are overloaded. Currently they are overloaded based on type and coercion (i.e., string, number, bigint)

[07:17:08.0824] <ljharb>
if "no new primitives" is the stance from engines i'd love to see some kind of public statement to that effect

[07:17:24.0353] <ljharb>
because we need something to point the massive mob of angry JS devs to

[07:17:36.0263] <shu>
it's no new primitives unless vastly compelling

[07:17:50.0400] <Michael Ficarra>
then decimal is dead in the water

[07:17:52.0978] <shu>
if you publicize it it will be taken outside of context as a standalone fiat

[07:18:04.0840] <ljharb>
i don't understand how R&T and Decimal aren't both vastly compelling - if neither of those hit the bar then that's the same as "no new primitives"

[07:18:26.0219] <shu>
you and i disagree

[07:18:26.0646] <ljharb>
 * i don't understand how R&T and Decimal aren't both vastly compelling - if neither of those hit the bar then that's the same as "no new primitives" imo

[07:18:32.0055] <rbuckton>
My understanding is that the position of implementers regarding "no new primitives" is due to implementation complexity, not whether they would fit within the spec itself?

[07:19:00.0049] <shu>
it's complexity and performance in the engine itself, yes

[07:19:01.0435] <ljharb>
> <@shuyuguo:matrix.org> you and i disagree

that's fine, but i think it's important to get a sense from the wider JS community about this sort of thing

[07:19:06.0519] <Michael Ficarra>
we may as well pack up and go home, language is done folks

[07:19:12.0264] <ryzokuken üá≥üá¥>
"vastly compelling" always subjective. There's almost no public JS event I've been to where nobody was lamenting IEEE doubles.

[07:20:37.0326] <rbuckton>
> <@usharma:igalia.com> "vastly compelling" always subjective. There's almost no public JS event I've been to where nobody was lamenting IEEE doubles.

Hard to parse double negatives...do you mean to say "every public JS event I've been to there was always someone lamenting IEEE doubles"? or that no one is complaining about it?

[07:20:49.0525] <ryzokuken üá≥üá¥>
sorry, yes

[07:21:10.0189] <ryzokuken üá≥üá¥>
I meant that I'm almost bored of hearing people criticize how we do `Number`s

[07:21:20.0412] <Rob Palmer>
I'm assuming @ljharb is wondering how we can surface data for cases where significant developer demand exists, such that it would justify implementation burden that would otherwise be intolerable.  I don't think he is encouraging mass pile-ons and pitchforks.

[07:21:28.0463] <ljharb>
exactly that

[07:21:54.0254] <ljharb>
but also, there WILL be massive pileons and pitchforks if we hide the actual position of browsers behind TC39 notes

[07:21:54.0354] <shu>
we literally do not know how to get high-quality signal for web developers, the closest we come is scaled surveys

[07:22:07.0497] <ryzokuken üá≥üá¥>
I think the priority of constituencies is a reasonable solution

[07:22:09.0323] <Michael Ficarra>
well maybe a couple of pitchforks

[07:22:25.0702] <ljharb>
make a joint public statement from browsers saying decimals and R&T are effectively dead because "no new primitives" and why, and i suspect you will quickly get signal from web developers. whether it's high-quality is ofc another matter.

[07:22:49.0676] <Christian Ulbrich>
What amount of developer demand would convince an implementor, that an implementation is worth the burden?

[07:23:18.0247] <ljharb>
i would hope that's something an implementor feels obligated to answer

[07:23:43.0619] <Michael Ficarra>
even if we go by V8's statement yesterday about encouraging features that will make better user experiences, decimal is incredibly justified because web users will have better experiences when they get correct numeric results!

[07:27:13.0304] <shu>
> <@christianulbrich:matrix.org> What amount of developer demand would convince an implementor, that an implementation is worth the burden?

as i said yesterday, developer demand is not convincing in itself, but in a larger context it could add color. for example, if a proposal does not pose significant complexity (which is really about security) concerns, then developer demand tips the scale for me and V8 to support

[07:27:32.0164] <Bradford Smith>
"Do it in the backend" doesn't help if the backend is Node.js

[07:27:48.0349] <rbuckton>
This statement presupposes that "the backend" is not NodeJS and "the frontend" is not Electron

[07:29:33.0473] <Bradford Smith>
I may have missed this: Did the presentation include pointers to one or more known-good userland libraries for this?

[07:30:13.0807] <Michael Ficarra>
Bradford Smith: yes, the champion made one himself

[07:30:25.0668] <Michael Ficarra>
and linked to it from the slides

[07:30:44.0436] <dminor>
I don't question that this would be useful in node.js, but that doesn't convince me that this needs to baked into the language.

[07:30:47.0969] <Rob Palmer>
We have a huge amount of financial processing happening on the client-side.  Common untransformed data is multi-cast to many users with low-latency.  Lots of per-client per-window per-widget customized calculations happens on the client side.

[07:32:21.0133] <Bradford Smith>
> <@michaelficarra:matrix.org> Bradford Smith: yes, the champion made one himself

I'm not talking about a playground for the current proposal. I'

[07:32:33.0597] <Christian Ulbrich>
As I have stated before, we were using -> https://mikemcl.github.io/decimal.js/ - I do not care about IEEEEEE4673838 as a developer, I just want something that works‚Ñ¢, preferably from my good olde JS engine! :) 

[07:33:05.0064] <Bradford Smith>
> <@michaelficarra:matrix.org> Bradford Smith: yes, the champion made one himself

 * I'm not talking about a playground for the current proposal. I'm talking about a library used currently by applications to handle Decimal use-cases.

[07:33:09.0110] <littledan>
JS itself even has decimal processing on the client side (in Intl.NumberFormat, on strings when rounding options are used)

[07:33:18.0217] <ptomato (at TC39, limited availability)>
there's also http://mikemcl.github.io/big.js/ from the same author

[07:33:52.0814] <Bradford Smith>
OK, I see Christian's link

[07:34:01.0750] <ryzokuken üá≥üá¥>
> <@christianulbrich:matrix.org> As I have stated before, we were using -> https://mikemcl.github.io/decimal.js/ - I do not care about IEEEEEE4673838 as a developer, I just want something that works‚Ñ¢, preferably from my good olde JS engine! :)

while I empathize with the calls to stick to IEEE at all costs (and I believe we will), I'm afraid this view is representative of a majority of JS developers

[07:34:51.0723] <littledan>
I just don't understand the details of the claim that this proposal deviates from IEEE 754 decimal. I'd like to follow up on those in a more concrete way. The intention is to use IEEE 754.

[07:35:10.0317] <shu>
if we're going by developer anecdotes, i'd wager majority of js developers also just do not care about JS semantics either

[07:35:58.0256] <ryzokuken üá≥üá¥>
fair, but the point I'm trying to make is that there's a strong signal that this is really popular among users

[07:37:03.0054] <Michael Ficarra>
devs are going to think we're incompetent and out of touch if we tell them decimals are not sufficiently justified

[07:37:25.0955] <littledan>
https://github.com/whatwg/html/pull/9486

[07:37:45.0104] <shu>
Michael Ficarra: specifically do you mean "decimals as primitives"

[07:38:22.0645] <ljharb>
decimals you can use === and other basic operators with

[07:38:31.0981] <Michael Ficarra>
if we have decimals as non-primitives, they will just think they're clunky

[07:38:44.0362] <ljharb>
most JS devs won't care or necessarily know about primitives vs objects but they *will* care about all the things "being primitives" lets them do

[07:39:27.0097] <ljharb>
and without being primitives, what's the value over just using a library

[07:39:43.0766] <ljharb>
 * and without being primitives, what's the value over just using a library - "i don't have to install it" imo is far far weaker than "it's more ergonomic"

[07:39:47.0765] <shu>
so is that "yes" to my question?

[07:39:48.0040] <Michael Ficarra>
ljharb: literal syntax

[07:40:26.0745] <Michael Ficarra>
shu: no, I think they will have different, but still negative, feelings about us

[07:40:37.0720] <Christian Ulbrich>
@shu I think so, they need to be first-class citizen, i.e. Primitives, with everything that entails, I am afraid.

[07:41:12.0791] <shu>
our position stands, and i've articulated as our not being convinced against the complexity (security) and performance tradeoffs

[07:41:56.0719] <ljharb>
and what i asked was that that position be stated somewhere publicly, outside of tc39, so it can be cited when making proposal decisions

[07:42:09.0485] <ljharb>
 * and what i asked/suggested was that that position be stated somewhere publicly, outside of tc39, so it can be cited when making proposal decisions

[07:42:37.0876] <rbuckton>
I mean, how useful would it be to have actual integer primitives like `int8` , `int16`, `int32`, `uint32`, etc. with proper overflow checking? Current approaches to constrain values to a specific integer space are often complex, such that we end up needing to add static methods to `Math` for proper integer division because all we have is Number.

[07:42:41.0062] <ljharb>
 * and what i asked/suggested was that that position be stated somewhere publicly, outside of tc39, so it can be cited when making proposal decisions (for the benefit of the wider JS dev community)

[07:42:41.0163] <shu>
i am not a PR person, i am a standards person

[07:43:01.0157] <ljharb>
there is considerable overlap there, i suspect

[07:43:06.0778] <shu>
not for me

[07:43:28.0270] <ljharb>
i would hope for v8/chrome, though?

[07:43:39.0337] <shu>
to explain our standards positions to the general public? no

[07:43:44.0935] <ljharb>
wow, ok

[07:43:45.0454] <shu>
to explain our standards positions to stakeholders? yes

[07:43:46.0948] <ljharb>
that's surprising

[07:43:53.0331] <ljharb>
the general public are all stakeholders.

[07:43:53.0944] <ptomato (at TC39, limited availability)>
> <@ljharb:matrix.org> and without being primitives, what's the value over just using a library - "i don't have to install it" imo is far far weaker than "it's more ergonomic"

I agree with your position on Decimal pretty much, but I do think "I don't have to install it" is a huge motivation for serving the majority of the world's population that accesses websites on an unstable or metered internet connection

[07:45:33.0267] <Michael Ficarra>
true, it is justified for *many* reasons

[07:52:23.0754] <shu>
to be clear i don't mean that we wish to make standards positions _private_, i mean that i don't consider it my job to _publicize_

[07:52:37.0650] <shu>
like, twitter threads, blog posts, whatever

[07:53:27.0972] <shu>
dminor: are you contributing to irregexp?

[07:53:52.0119] <Chris de Almeida>
Jesse (TC39): do you want to have a continuation for Decimal tomorrow?  if so, how long?

[07:54:19.0821] <nicolo-ribaudo>
irregexp seems like something cool to eventually learn how to contribute to

[07:55:06.0054] <shu>
please do!

[07:57:09.0896] <Jesse (TC39)>
> <@softwarechris:matrix.org> Jesse (TC39): do you want to have a continuation for Decimal tomorrow?  if so, how long?

sure, how about 20 minutes?

[07:58:20.0429] <shu>
FYI if you schedule it in the morning, i will not be able to attend

[07:59:05.0083] <Chris de Almeida>
shu: we can add to afternoon

[08:04:18.0758] <Chris de Almeida>
decimal queue capture is now in the notes

[08:13:41.0126] <Andreu Botella>
There is precedent in that `/test/ === /test/` is false, but yeah, it is weird

[08:17:51.0148] <Christian Ulbrich>
There are other things, with `NaN === NaN` only being the most prominent one, but `[] === []`... are also not equal :) As are Dates...

[08:20:27.0392] <ljharb>
It‚Äôs not that syntax always means triple equals, but that the oddities are known and minimal and shouldn‚Äôt be increased.

[08:34:13.0160] <shu>
interesting point about regexps having creation syntax but have Object semantics

[08:35:03.0136] <shu>
but numeric literals having Object semantics feels it is unprecedented in all of PL. would be fascinating to see an exception

[08:42:22.0337] <Jesse (TC39)>
> <@eemeli:mozilla.org> Re: the Decimal proposal, do I understand right that as currently proposed `1.0m === 1.0m` would be `false`, yes? That's... weird.

indeed -- it's a bullet one would bite if you accept the "no overloading" approach. I'm happy to discuss whether we should make an exception for `===`

[08:43:34.0386] <Jesse (TC39)>
i.e., make `===` be numerical equality when both lhs and rhs are `Decimal`s

[08:44:09.0396] <nicolo-ribaudo>
> <@shuyuguo:matrix.org> but numeric literals having Object semantics feels it is unprecedented in all of PL. would be fascinating to see an exception

I would rather not use JS as the language for "nobody does this so let's try to see how weird it will be!"

[08:52:19.0065] <shu>
me neither?

[08:52:44.0645] <shu>
that was not a "would be fascinating for JS to do this as an exception", that was a "it would be fascinating to see prior art, i don't believe it exists"

[08:55:01.0196] <shu>
> <@jesse:igalia.com> i.e., make `===` be numerical equality when both lhs and rhs are `Decimal`s

i would not support this

[08:57:33.0853] <Jesse (TC39)>
> <@shuyuguo:matrix.org> i would not support this

understood -- the "no overloading" philosophy (which I still stand by) tries to respect that

[09:00:47.0695] <Jesse (TC39)>
in `C#` (a language that has decimals natively), you use a `cmp` function (returns -1, 0, or 1), which is also what I have in my current proposal. No `===`

[09:01:45.0656] <rbuckton>
> <@jesse:igalia.com> in `C#` (a language that has decimals natively), you use a `cmp` function (returns -1, 0, or 1), which is also what I have in my current proposal. No `===`

C# has operator overloading that covers `==` and other operators

[09:01:58.0561] <Jesse (TC39)>
ah ok, thanks, didn't know üëçÔ∏è

[09:05:03.0817] <rbuckton>
In C#, all primitives are "value types" that are essentially defined as `struct`s, and all operations on these types flows through operator overloading. Since C# is a typed language, it determines which static operator method to bind at compile time so that the runtime cost is negligible, though for a number of built in operations those can also generate native code that is faster than the overload method. 

[09:06:38.0322] <rbuckton>
 * In C#, almost all primitives (except `string`) are "value types" that are essentially defined as `struct`s, and all operations on these types flows through operator overloading. Since C# is a typed language, it determines which static operator method to bind at compile time so that the runtime cost is negligible, though for a number of built in operations those can also generate native code that is faster than the overload method.

[09:07:39.0117] <rbuckton>
for example: https://learn.microsoft.com/en-us/dotnet/api/system.decimal?view=net-7.0

[09:08:45.0489] <Jesse (TC39)>
heh love the `PiggyBank` class

[09:13:30.0725] <rbuckton>
We had a number of discussions about user-defined operator overloading a few years back. The thought at the time was that you would need to have some kind of syntactic opt-in to inform the runtime that it should consider operator overloads. The upside being that existing code wouldn't be effected by the cost associated with operator overloads, the downside being that it would be fairly easy to forget to include the syntax, especially if you are working with a value that is returned from a function defined in a different module.

It was something like `with operators from Foo` to opt into using operators defined on a constructor, IIRC. 

[09:13:55.0930] <rbuckton>
 * We had a number of discussions about user-defined operator overloading a few years back. The thought at the time was that you would need to have some kind of syntactic opt-in to inform the runtime that it should consider operator overloads. The upside being that existing code wouldn't be effected by the cost associated with operator overloads, the downside being that it would be fairly easy to forget to include the syntax, especially if you are working with a value that is returned from a function defined in a different module.

It was something like `with operators from Foo;` to opt into using operators defined on the constructor `Foo`, or something to that effect.

[09:14:05.0602] <rbuckton>
 * We had a number of discussions about user-defined operator overloading a few years back. The thought at the time was that you would need to have some kind of syntactic opt-in to inform the runtime that it should consider operator overloads. The upside being that existing code wouldn't be effected by the cost associated with operator overloads, the downside being that it would be fairly easy to forget to include the syntax, especially if you are working with a value that is returned from a function defined in a different module.

It was something like `with operators from Foo;` to opt into using operators defined on the constructor `Foo`.

[09:16:32.0220] <rbuckton>
I'd hoped that we could tie operator overloading to something like `struct`, such that an implementation might have an easy way to recognize whether to even consider an overloaded operator (so it doesn't need to consider operator overloads for all other types), but that doesn't look to be viable with the direction we're going.

[09:18:04.0027] <rbuckton>
Alternatively, something similar we could use to tag an instance as opting-in to operator overloads like a `value class C {}` or something to that effect.


2023-07-13
[17:39:01.0123] <littledan>
> <@shuyuguo:matrix.org> but numeric literals having Object semantics feels it is unprecedented in all of PL. would be fascinating to see an exception

Don‚Äôt C++ custom literals enable exactly this? For my JS custom literals proposal, I assumed it would be Ok to follow that and allow those to return objects or primitives.

[17:45:33.0719] <littledan>
> <@shuyuguo:matrix.org> to be clear i don't mean that we wish to make standards positions _private_, i mean that i don't consider it my job to _publicize_

It doesn‚Äôt quite have to be your job to publicize it as such, but if you could give us (proponents of features) direction on what to say to others when they ask us about this, so as to accurately represent your position, that would be helpful. The scope of what you would like JS proposals to avoid has been a little ambiguous even to many committee members leading up to this meeting.

[18:41:59.0180] <justingrant>
> <@michaelficarra:matrix.org> it's so strange to me that IETF would explicitly *not* want to support sub-minute offsets

(catching up) Here's more context around IETF's reasoning, and more generally why restricting offset time zones to minutes seems OK to me:

Existing RFC3339 timestamp strings (which the new IETF spec, aka "IXDTF", extends) only support HH:MM in the offset, e.g. `2023-07-12T14:06-07:00`. You can't use `07:00:01` or even `07:00:00` because parsers wouldn't recognize it. JS Date has the same same limit, BTW. 

In the new IETF spec, they didn't want to change anything about the RFC3339 portion of the IXDTF timestamp, only the stuff in brackets after the timestamp is what's new.  Otherwise, existing RFC3339 parsers would break for the before-brackets portion. Of course, that's not necessarily related to what's in brackets. We could have different precision for the in-brackets portion because there's no legacy.

But with IXDTF, the rule is that the RFC3339 offset must match the offset of the time zone in brackets.  So `2020-01-01T00:00-05:00[America /Los_Angeles]` is considered an error because the offset doesn't match the time zone.

For named time zones that have sub-minute precision, the new IETF spec handles it by being flexible about what "match" means: if the bracketed time zone's offset, when rounded to HH:MM, matches the offset in the RFC3339 portion of the string, then there's no error produced. 

So `1970-01-01T00:00-00:45[Africa/Monrovia]` is considered valid, even though Liberia's offset in 1970 was -00:44:30. The rounding hack simply tells the receiver not to throw an error in that case; it doesn't change the actual instant that the string represents. The instant described by "midnight on Jan 1 1970 in Liberia" is still 44:30 away from UNIX epoch: 
```js
Temporal.ZonedDateTime.from('1970-01-01T00:00-00:45[Africa/Monrovia]').toInstant();
// => 1970-01-01T00:44:30Z
```

Temporal does the same thing in reverse in `ZonedDateTime.p.toString()`: it formats the instant by rounding the offset to the nearest minute.

Anyway, that's how it works for named time zones. But what about offset time zones? 

Because the offset in the RFC3339 portion of the string is constrained to HH:MM, the IETF folks felt that it'd be better to also limit the bracketed time zone to HH:MM too. There's nothing preventing us from extending the format in the future if there's customer demand, using the same rounding hack used for named time zones, so that `1970-01-01T00:00-00:45[-00:44:30]` would also be allowed.

But it's not clear (to me at least) that this customer demand will ever materialize. Offset time zones were really only added to Temporal and IXDTF for backwards compatibility with Java. It's not clear how much usage of offset time zones there will be in Temporal. Partly this is because all IANA time zones today are on 15-minute boundaries. Sub-minute offsets haven't been official in any country since the 1970s, and even then it was rare. And offset time zones intentionally dispense with the main value of time zones in Temporal: the ability to automatically adjust timestamps for DST and other time zone weirdness.

Also, there's a storage advantage. If offset time zones are limited to minutes, then a Temporal.TimeZone can fit in a 16-bit union: 12 bits for offset time zones (¬±24h at minute-precision), 10 bits for the index into ~600 named time zones, and one bit to choose between them. Sub-minute offsets would require 50% more bytes to support a use case with questionable demand.

Finally, any user who really needs an offset time zone with sub-minute precision can create a custom time zone with granularity down to nanoseconds. Which they'd have to do anyways for time zones like TAI which don't have constant offsets (thanks leap seconds!) so you can't use an offset time zone anyways. AFAICT, there has never been a real-world time zone that has had a non-minute-aligned offset whose offset has never changed.  So I'm kinda skeptical that "offset time zones at sub-minute precision" are real things.

P.S. - one concern raised was how RFC 5545 (aka iCalendar) supports [second-precision offsets](https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.14). But AFAICT, those offsets are never actually used for time zone identifiers. Rather, they're used to define the offsets of named time zones. And Temporal is already permissive with timestamp offset inputs, so we'll accept strings like `1970-01-01T00:00-00:44:30` which AFAICT is what RFC5545 needs. 

Summary: restricting to minutes for built-in offset time zones seems like a safe initial bet that we can always extend later if needed. 

Thanks for coming to my obscure TED talk. 

[19:29:11.0228] <justingrant>
> <@sffc:mozilla.org> It still seems like we should stop returning Saigon and Kiev despite the lack of a Temporal.TimeZone.prototype.equals

There are two pieces required to fully solve this: 
1. Stop canonicalizing user-inputted IDs to canonical IDs that are sometimes outdated and/or varying across browsers.  By bringing proposal-canonical-tz to Stage 3 and merging it into Temporal, this problem gets solved as soon as Temporal.TimeZone ships in implementations. Yay!
2. Stop using outdated canonical IDs. Today this affects all IDs, but after (1) is done this will only affect IDs generated by ECMAScript itself, e.g. `new Intl.DateTimeFormat().resolvedOptions().timeZone` and `Intl.supportedValuesOf('timeZone')`.

These two pieces are independent!  Even though yesterday the committee agreed to hold (1) until Temporal.TimeZone ships, for (2) implementations are already free to return Europe/Kyiv, Asia/Kolkata, and Asia/Ho_Chi_Minh as canonical IDs. Firefox does this today, and Anba has argued (convincingly, IMO) that the FF behavior is more spec-compliant with current 402.

V8 and JSC don't do this today because they rely on CLDR and ICU which never update renamed IDs.  But nothing stops ICU-using implementations from doing what Firefox does and overriding the ~20 zones in CLDR that use out-of-date names. If an ICU solution will take 2 years, could V8 and JSC in the meantime just add a hard-coded mapping table of 20 IDs?  It's not like renames happen often: less than once per year is the average. If you, shu , and Frank wanted to do this badly enough, I suspect it could get done fast!

That said, it's a reasonable argument that doing (1) before (2), or at the same time, would reduce the negative impact to existing code because user-inputted zones wouldn't be affected.

My suggestion:
* Let's get implementations building & shipping Temporal!  After this plenary's normative changes are merged within a week or two, AFAIK there are no other large changes on the horizon.
* IMO, V8 and JSC should really consider the 20-item hard-coded mapping table to work around CLDR's slow schedule. Could this work be paired with Temporal implementation instead of waiting until later? Could this work start now, and ship in a limited test to gauge the web-compat impact?

Let me know how I can help!

[19:39:46.0529] <Richard Gibson>
> if the bracketed time zone's offset, when rounded to HH:MM, matches the offset in the RFC3339 portion of the string, then there's no error produced

justingrant I was wondering about how this rounding handled midpoint values like -00:44:30 or +00:44:30 (specifically "ties away from zero" vs. "ties toward positive infinity" vs. "ties toward even"), but I don't see _any_ mention of it at https://www.ietf.org/archive/id/draft-ietf-sedate-datetime-extended-08.html or https://github.com/ietf-wg-sedate/draft-ietf-sedate-datetime-extended/blob/main/draft-ietf-sedate-datetime-extended.md . Are you sure you're not thinking of [Temporal InterpretISODateTimeOffset](https://tc39.es/proposal-temporal/#sec-temporal-interpretisodatetimeoffset) step 8.c.i RoundNumberToIncrement(_candidateNanoseconds_, 60e9, "halfExpand")?

[19:45:18.0120] <shu>
> <@littledan:matrix.org> It doesn‚Äôt quite have to be your job to publicize it as such, but if you could give us (proponents of features) direction on what to say to others when they ask us about this, so as to accurately represent your position, that would be helpful. The scope of what you would like JS proposals to avoid has been a little ambiguous even to many committee members leading up to this meeting.

my suggestion there is you should redirect the people who ask about this back to V8 instead, instead of relaying it on behalf of V8

[20:20:13.0111] <shu>
> <@justingrant:matrix.org> There are two pieces required to fully solve this: 
> 1. Stop canonicalizing user-inputted IDs to canonical IDs that are sometimes outdated and/or varying across browsers.  By bringing proposal-canonical-tz to Stage 3 and merging it into Temporal, this problem gets solved as soon as Temporal.TimeZone ships in implementations. Yay!
> 2. Stop using outdated canonical IDs. Today this affects all IDs, but after (1) is done this will only affect IDs generated by ECMAScript itself, e.g. `new Intl.DateTimeFormat().resolvedOptions().timeZone` and `Intl.supportedValuesOf('timeZone')`.
> 
> These two pieces are independent!  Even though yesterday the committee agreed to hold (1) until Temporal.TimeZone ships, for (2) implementations are already free to return Europe/Kyiv, Asia/Kolkata, and Asia/Ho_Chi_Minh as canonical IDs. Firefox does this today, and Anba has argued (convincingly, IMO) that the FF behavior is more spec-compliant with current 402.
> 
> V8 and JSC don't do this today because they rely on CLDR and ICU which never update renamed IDs.  But nothing stops ICU-using implementations from doing what Firefox does and overriding the ~20 zones in CLDR that use out-of-date names. If an ICU solution will take 2 years, could V8 and JSC in the meantime just add a hard-coded mapping table of 20 IDs?  It's not like renames happen often: less than once per year is the average. If you, shu , and Frank wanted to do this badly enough, I suspect it could get done fast!
> 
> That said, it's a reasonable argument that doing (1) before (2), or at the same time, would reduce the negative impact to existing code because user-inputted zones wouldn't be affected.
> 
> My suggestion:
> * Let's get implementations building & shipping Temporal!  After this plenary's normative changes are merged within a week or two, AFAIK there are no other large changes on the horizon.
> * IMO, V8 and JSC should really consider the 20-item hard-coded mapping table to work around CLDR's slow schedule. Could this work be paired with Temporal implementation instead of waiting until later? Could this work start now, and ship in a limited test to gauge the web-compat impact?
> 
> Let me know how I can help!

thanks for the detailed plan, i'd hate for it to get lost in the matrix chat, an issue to capture it would be great.

for (2), good to know it's independent. i won't be the one to drive this work, so Frank, who's much closer to the i18n and ICU teams, would be the one for you to convince to do the heavy lifting. frankly i just don't have the domain expertise and don't have a nose for the impact here to make a decision

[20:59:41.0007] <bakkot>
do I read the schedule correctly that there's a 60 minute underflow before lunch?

[20:59:57.0531] <bakkot>
is there any thought of moving stuff up or is all the other stuff fixed in time?

[00:28:24.0462] <Rob Palmer>
We're open to ideas on filling the morning schedule. 

[00:52:34.0444] <bakkot>
I ask mainly because I would like to know if I will miss anything if I sleep during the time that is currently dead

[00:52:51.0232] <bakkot>
that being 2am-4am pacific time

[00:53:08.0282] <bakkot>
i.e. hours that I would very much like to sleep through if I am not going to be missing anything

[00:53:53.0010] <Rob Palmer>
We will begin by asking for agenda items to fill the time.

[01:03:14.0790] <sffc>
my slides: https://docs.google.com/presentation/d/1MKceo1Pn1PvuMz1WkzGwIpbT5qRNZVZRxY3rgcPJOKI/edit#slide=id.p

[01:07:55.0660] <littledan>
We are likely to do a review of Stage 2 proposals during the spare time in the morning, and a presentation of research by people here in UiB in the afternoon, but details tbd for each.

[01:12:29.0399] <Rob Palmer>
We have brought forward Nicolo's Optional Chaining into this morning.  Plus the two additions Dan mentioned.

[01:17:03.0919] <Michael Ficarra>
I have seen this exact complaint about not being able to shrink wasm memory before in one of the wasm issue trackers

[01:17:34.0060] <Michael Ficarra>
they're aware of a need here

[01:18:00.0746] <littledan>
Isn't this just an issue at the tooling level, when it comes to single-threaded Wasm?

[01:18:03.0736] <bakkot>
https://github.com/WebAssembly/design/issues/1397

[01:20:10.0184] <littledan>
 * <del>Isn't this just an issue at the tooling level, when it comes to single-threaded Wasm?</del>

[01:27:33.0165] <justingrant>
> @shu: thanks for the detailed plan, i'd hate for it to get lost in the matrix chat, an issue to capture it would be great.

Done! https://github.com/tc39/ecma402/issues/806. Feedback welcome! 

[01:28:58.0244] <justingrant>
 * > @shu: thanks for the detailed plan, i'd hate for it to get lost in the matrix chat, an issue to capture it would be great.

https://github.com/tc39/ecma402/issues/806. Feedback welcome!

[01:33:33.0682] <justingrant>
> <@gibson042:matrix.org> > if the bracketed time zone's offset, when rounded to HH:MM, matches the offset in the RFC3339 portion of the string, then there's no error produced
> 
> justingrant I was wondering about how this rounding handled midpoint values like -00:44:30 or +00:44:30 (specifically "ties away from zero" vs. "ties toward positive infinity" vs. "ties toward even"), but I don't see _any_ mention of it at https://www.ietf.org/archive/id/draft-ietf-sedate-datetime-extended-08.html or https://github.com/ietf-wg-sedate/draft-ietf-sedate-datetime-extended/blob/main/draft-ietf-sedate-datetime-extended.md . Are you sure you're not thinking of [Temporal InterpretISODateTimeOffset](https://tc39.es/proposal-temporal/#sec-temporal-interpretisodatetimeoffset) step 8.c.i RoundNumberToIncrement(_candidateNanoseconds_, 60e9, "halfExpand")?

Good catch. You're right, the rounding is a Temporal solution, not something in the IETF spec. Let's discuss among the Temporal champions whether it's wroth trying to get this into the IETF spec, or whether it's too niche for us to care about pushing it into that spec.

[01:46:39.0063] <rbuckton>
Python's `contextlib` has a very tight coupling between decorators and context managers, such as `contextlib.ContextDecorator`: https://docs.python.org/3/library/contextlib.html#contextlib.ContextDecorator

[01:50:14.0890] <Luca Casonato>
On the topic of source phase imports, please vote on the keyword (or suggest other keywords): https://github.com/tc39/proposal-source-phase-imports/issues/54

[01:53:02.0196] <Luca Casonato>
And you can discuss here: https://github.com/tc39/proposal-source-phase-imports/issues/53

