2024-05-03
[01:36:35.0790] <Rob Palmer>
Hongbo is suggesting the iterator protocol has a high performance overhead (25x perf loss).  Do we know if this is cost is effectively mandated in the spec, or is this just a unfulfilled optimization opportunity in engines?

https://www.moonbitlang.com/blog/js-support#benchmark-code-execution-speed-exceeds-javascript-by-25-times

[02:35:57.0697] <rbuckton>
My hope is that engines could optimize Array iteration, but I'm not sure about other cases

[02:45:57.0326] <rbuckton>
With something like iterator helpers, engines could theoretically optimize some parts of iteration knowing the shapes of the inputs and the whole of the graph of iteration operations. It's no small task, though, as it requires verifying that no intermediate steps are observable (proxies, user-defined iterators, patched methods, etc.). 

[07:59:25.0036] <littledan>
Engines brought up the overhead of the iteration protocol at the most recent TC39 meeting, as a source of hesitation for the pattern matching proposal's semantics

[08:00:16.0499] <littledan>
engines *sometimes* can reduce or eliminate the overhead in particular cases (e.g., for-of loops over Arrays, as long as you didn't mess with Array.prototype too much) but these optimizations are fragile and difficult to generalize

[08:00:47.0160] <littledan>
I think if we were to do the iteration protocol today, we'd do it differently. But at this point, it'd be expensive to have multiple iteration protocols...

[08:01:10.0893] <bakkot>
see some discussion earlier: https://matrixlogs.bakkot.com/TC39_Delegates/2024-04-25#L21

[08:02:18.0535] <bakkot>
that said there is a lot of room for optimizing iterators, in many cases without much in the way of performance cliffs

[08:02:36.0702] <bakkot>
it's just a lot of work

[08:09:20.0345] <bakkot>
(also it is extremely unlikely to ever be as fast as a bare loop, even with a huge amount of work)

[08:16:24.0663] <bakkot>
if we are interested in making iterator helpers faster, something we _could_ do is make all the `{ next, done }` pairs yielded by a given call to an iterator helper be the same object

[08:16:54.0739] <bakkot>
 * if we are interested in making iterator helpers faster, something we _could_ do is make all the `{ value, done }` pairs yielded by a given call to an iterator helper be the same object

[08:18:50.0345] <bakkot>
so like

```js
function map(fn) {
  let result = { value, done }; // probably with those properties being non-configurable
  let underlying = this;
  return {
    next() {
      let { value, done } = underlying.next();
      if (!done) value = fn(value);
      result.value = value;
      result.done = done;
      return result;
    }
  }
}
```

[08:19:06.0588] <bakkot>
this would avoid most of the overhead and no one would ever notice

[08:19:14.0911] <bakkot>
but it is, as littledan indicates, conceptually quite gross

[08:46:42.0117] <mgaudet>
> <@robpalme:matrix.org> Hongbo is suggesting the iterator protocol has a high performance overhead (25x perf loss).  Do we know if this is cost is effectively mandated in the spec, or is this just a unfulfilled optimization opportunity in engines?
> 
> https://www.moonbitlang.com/blog/js-support#benchmark-code-execution-speed-exceeds-javascript-by-25-times

Both? The iterator protocol imposes a lot of complexity; some of that complexity can be optimized through heroic work in JS engines (and has been!)... but the heroics mean that it's costly to do, particularly in any generalizable fashion. 

I haven't looked at Iterator Helpers in a long while, but I'll bet they could certainly have more optimization applied over time, but I suspect a similar story applies: Could we make them faster? Sure, but that work displaces other work, and so we need to see it as important enough. 

[08:56:27.0036] <bakkot>
by coincidence I just read an article which  touches on performance of array destructuring, which is the same problem https://www.figma.com/blog/figmas-journey-to-typescript-compiling-away-our-custom-programming-language/#performance-issues-with-array-destructuring

[10:07:20.0884] <shu>
down with iteration protocol

[10:16:10.0365] <littledan>
if only we said "iterables can't contain undefined", then we would have .next() simply return undefined when it's done. Problem solved!

[10:16:33.0963] <shu>
> <@bakkot:matrix.org> if we are interested in making iterator helpers faster, something we _could_ do is make all the `{ value, done }` pairs yielded by a given call to an iterator helper be the same object

i feel like how you react to this is like "inside you are two wolves"

