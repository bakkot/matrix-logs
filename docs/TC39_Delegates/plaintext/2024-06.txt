2024-06-01
[20:29:37.0615] <justingrant>
What's the right process to get consensus on it from TG1 in Helsinki for normative PRs to ECMA-402? Do I add it as a standalone agenda item?  As part of a standing agenda item for 402 changes?  Something else? PR is https://github.com/tc39/ecma402/pull/877

This is mostly a "web reality" change that aligns the spec with how V8 and JSC already behave by tightening under-specified parts of the spec. It also adds forward-looking guidance to handle future issues that may crop up with time zone identifiers.

Ideally I would have asked this question yesterday before the deadline, but I mistakenly believed that all TG2-approved PRs would magically make it into the agenda. Oops. Anyway, I'll add this as a late submission. 

[21:33:25.0929] <bakkot>
I believe you still have two hours before the deadline

[21:34:24.0705] <bakkot>
this is a three-day meeting so the deadline is Saturday rather than Friday (but Saturday in Helsinki, so earlier than it would for meetings in PT)

[01:33:37.0254] <sffc>
Yeah, it should be added under "Needs Consensus PRs". ECMA-402 PRs previously got added automatically, but that practice stopped about a year ago. Now we just make an announcement in the monthly TG2 call to remind champions to add their stuff to the TG1 agenda if it needs TG1 consensus.

[16:11:03.0610] <Rob Palmer>
We still have around 3 hours of spare capacity. So please don't let the agenda deadline stop you from adding more items. 


2024-06-02
[17:12:02.0955] <rbuckton>
I'd hoped to bring back extractors and void bindings for Stage 2 this plenary, but only recently had the time to address feedback from last meeting and I want to give Waldemar time to review the changes intended to address his concerns. I may try to add them as late agenda items since they both seemed fairly close to reaching stage 2 at the last meeting (or, at least that was my impression). 

[15:37:32.0946] <justingrant>
> Yeah, it should be added under "Needs Consensus PRs". ECMA-402 PRs previously got added automatically, but that practice stopped about a year ago. Now we just make an announcement in the monthly TG2 call to remind champions to add their stuff to the TG1 agenda if it needs TG1 consensus.

Serves me right for not listening carefully!  üëÇÔ∏è  I just [submitted](https://github.com/tc39/agendas/pull/1611) a needs-consensus agenda item for that PR.


2024-06-03
[03:19:44.0481] <littledan>
If we seriously have extra time on the agenda, there are a couple wild open discussion topics which might be fun. Emoji-react something if you're interested in them. (Apologies for not raising this before the agenda deadline.)

[03:19:48.0061] <littledan>
Cancellable promises

[03:20:02.0708] <littledan>
Private name declarations outside of classes

[03:34:55.0090] <rbuckton>
> <@littledan:matrix.org> Cancellable promises

Would it make sense to discuss this on https://github.com/tc39/proposal-cancellation? 

[03:37:07.0446] <littledan>
> <@rbuckton:matrix.org> Would it make sense to discuss this on https://github.com/tc39/proposal-cancellation?

oh thanks that gives a lot of helpful references to review. I have been thinking about this area again in the context of AsyncContext, which gives us more options for propagating the cancel token.

[03:37:44.0109] <littledan>
also AbortSignal.any is a very helpful, core capability in this area, which I don't think was there last time we discussed this

[03:40:19.0801] <littledan>
(I guess it basically enables what your previous proposal's `new CancellationTokenSource(linkedTokens?)` does, roughly)

[03:46:36.0415] <rbuckton>
Unfortunately, since `AbortSignal` is outside the purview of TC39 the best forum for that may be WHATWG. 

[03:47:27.0488] <rbuckton>
Though I've long held that cancellation graphs like that are very valuable

[03:47:50.0220] <littledan>
We'll definitely have to collaborate between standards groups to make this happen, but I think you were right to bring this to TC39, and believe we can make some progress together.

[03:49:56.0372] <littledan>
also if we want integration with async/await (e.g., all awaits are implicitly racing with the cancel token), something would need to happen in TC39

[03:50:01.0638] <rbuckton>
I also agree that AsyncContext would have been the way to traffic a cancellation token in the way Yehuda wanted, so long as there was a way to suppress async context flow when needed

[03:50:30.0594] <littledan>
> <@rbuckton:matrix.org> I also agree that AsyncContext would have been the way to traffic a cancellation token in the way Yehuda wanted, so long as there was a way to suppress async context flow when needed

could you say more about this suppression use case?

[03:50:41.0467] <littledan>
I mean, requirements for it

[03:50:47.0027] <rbuckton>
The only avenue given to us at this point is a host hook. 

[03:51:16.0521] <littledan>
IIRC wanting the cancel token to be implicitly propagated was a goal of Domenic's as well

[03:51:41.0981] <rbuckton>
> <@littledan:matrix.org> could you say more about this suppression use case?

Sometimes you *don't* want to propagate the token.

[03:51:55.0355] <rbuckton>
I have to step away, I'll discuss more shortly.

[03:52:03.0559] <littledan>
> <@rbuckton:matrix.org> The only avenue given to us at this point is a host hook.

I hope we can first think about the problem space and what's needed for developers (as you were trying to do) and then we can go from there to "how do we lay this out across the various specs"

[04:02:15.0431] <rbuckton>
With the token as a parameter, it is up to the caller to determine whether to pass the token to a function. If you had a function that invoked a REST API, you might want to allow it to be cancellable in some cases, but not others. If there is no suppression mechanism, then there is no way for the caller to make this determination. The structure of the Cancellation API (so far as that proposal was concerned) ensured an appropriate separation of concerns so that the correct level of control was available with respect to the caller and the call site. 

[04:10:21.0273] <rbuckton>
> <@littledan:matrix.org> (I guess it basically enables what your previous proposal's `new CancellationTokenSource(linkedTokens?)` does, roughly)

One of the major reasons I wanted a linked cancellation graph was to address memory overhead. If cancellation sources could be intrinsically linked, and could be disposed when cancellation was no longer needed, then all of the token subscriptions could be GC'd (incl. the callbacks and closed-over variables that they held).

[04:11:02.0669] <littledan>
> <@rbuckton:matrix.org> With the token as a parameter, it is up to the caller to determine whether to pass the token to a function. If you had a function that invoked a REST API, you might want to allow it to be cancellable in some cases, but not others. If there is no suppression mechanism, then there is no way for the caller to make this determination. The structure of the Cancellation API (so far as that proposal was concerned) ensured an appropriate separation of concerns so that the correct level of control was available with respect to the caller and the call site.

yes, so if we had an AsyncContext variable for the current cancel token, and then a function you could call to set that variable to a fresh token while running a callback, that would achieve suppression, right?

[04:11:20.0600] <littledan>
> <@rbuckton:matrix.org> One of the major reasons I wanted a linked cancellation graph was to address memory overhead. If cancellation sources could be intrinsically linked, and could be disposed when cancellation was no longer needed, then all of the token subscriptions could be GC'd (incl. the callbacks and closed-over variables that they held).

yes, I agree this is important. Do you see AbortSignal.any as solving that issue too?

[04:11:23.0772] <rbuckton>
A fresh token, or no token.

[04:11:51.0719] <rbuckton>
I would have to think about that. IIRC, the issue with `any` is how ownership is controlled for a subgraph.

[04:12:17.0977] <littledan>
> <@rbuckton:matrix.org> I would have to think about that. IIRC, the issue with `any` is how ownership is controlled for a subgraph.

I think `any` has to be used in a sort of opinionated way to make things work

[04:12:48.0595] <littledan>
and your proposed signature sort of already encapsulates that pattern

[04:13:37.0431] <rbuckton>
Let's say I receive a token and want to call another function with both that and my own token. With `any`, I can close *my* source, but since I have no control over the incoming token, the graph can't be GC'd

[04:14:41.0288] <littledan>
which graph do you mean?

[04:16:43.0747] <rbuckton>
```js
function outer(signal) {
  const myController = new AbortController();
  const combined = AbortController.any([signal, myController.signal]);
  const promise = inner(combined.signal);
  ...
  // we've progressed to a point where cancellation shouldn't occur, 
  // but we can't signal that to `inner`
  myController.dispose(); 
}
```

[04:17:03.0949] <rbuckton>
 * ```js
function outer(signal) {
  const myController = new AbortController();
  const combinedSignal = AbortController.any([signal, myController.signal]);
  const promise = inner(combinedSignal);
  ...
  // we've progressed to a point where cancellation shouldn't occur, 
  // but we can't signal that to `inner`
  myController.dispose(); 
}
```

[04:17:22.0439] <rbuckton>
 * ```js
function outer(signal) {
  const myController = new AbortController();
  const combinedSignal = AbortSignal.any([signal, myController.signal]);
  const promise = inner(combinedSignal);
  ...
  // we've progressed to a point where cancellation shouldn't occur, 
  // but we can't signal that to `inner`
  myController.dispose(); 
}
```

[04:17:58.0738] <rbuckton>
Here, even if we think `inner` should keep going, if `signal` is canceled then `combinedSignal` is cancelled.

[04:18:18.0929] <rbuckton>
If `any` returns a signal, then I can't model this relationship using it.

[04:19:34.0859] <rbuckton>
But if `any` returns a controller, then I can exert this level of control:
```js
function outer(signal) {
  const combinedController = AbortController.any([signal]);
  const promise = inner(combinedController.signal);
  ...
  // we've progressed to a point where cancellation shouldn't occur
  combinedController.dispose(); 
}
```

[04:21:02.0607] <rbuckton>
The `new CancellationTokenSource(linkedTokens?)` API allowed you to express this relationship. If you need control over the subgraph, you hold a reference to the source. If you don't need control over the subgraph, you don't hold a reference to the source and just pass along it's `token`.

[04:21:42.0030] <littledan>
Btw did you point this out in any issue on the AbortSignal.any repo?

[04:22:29.0213] <rbuckton>
I wasn't aware of an `AbortSignal.any` repo, but I've definitely discussed it many years ago in TC39 as part of the cancellation proposal.

[04:23:46.0088] <littledan>
This was the repo, but it's already shipping across browsers https://github.com/shaseley/abort-signal-any

[04:24:18.0854] <littledan>
I had trouble following all the aspects of your previous presentation, and was watching this proposal later, and thought it was good and solved the problems you were raising.

[04:26:05.0403] <rbuckton>
Ah, that's unfortunate.

[04:26:19.0641] <littledan>
I have trouble tracing the leak in the above code. It's that it's less apparent that the controller is dead?

[04:26:44.0432] <rbuckton>
No, the problem is that the controller isn't dead in the first example.

[04:27:01.0057] <littledan>
sure, that it isn't dead, so how big of a leak is that?

[04:27:20.0488] <littledan>
it's only referred to by that local variable, and that can be collected once you leave the scope. or is there anything else?

[04:28:06.0034] <littledan>
(I thought solving this particular GC issue was like 80% of the point of AbortSignal.any in the first place)

[04:28:36.0231] <rbuckton>
It's not a leak, it's bigger than that. If I wanted to be able to control whether `inner` could even be cancelled anymore after a certain point, I would not be able to do so in that approach, so it actually affects capabilities, not just memory.

[04:29:00.0966] <rbuckton>
Also, if there is no `dispose()`/`close()` then you're not addressing the GC concern at all.

[04:29:15.0895] <littledan>
how can you do that with the API you're proposing?

[04:29:43.0061] <rbuckton>
It's quite hard to explain in text without drawing a graph :/

[04:57:44.0560] <rbuckton>
Lets assume for a moment that an `AbortController` has a `dispose()` method. In example one, you have an outer abort controller `A` (and signal `a`) and create an inner abort controller `B` (and signal `b`). Calling `AbortSignal.any([a, b])` produces a signal `ab` with the following semantics:
- Aborting `A` aborts `a` and `ab`
- Aborting `B` aborts `b` and `ab` 
- Disposing `A` disposes `a` but not `ab`, because `ab` could still be aborted by `B`.
- Disposing `B` disposes `b` but not `ab`, because `ab` could still be aborted by `A`.

My algorithm reaches a point of no return where I no longer want `inner` to be cancelable, at which point any subscriptions added by `inner` can be collected. Unfortunately, `AbortSignal.any` does not give me this capability since neither `A` nor `B` dominates the token `ab`.

[05:03:15.0189] <rbuckton>
In the `new CancellationTokenSource(linkedTokens?)` approach, you produce a new source/controller that dominates the cancellation interaction with `inner`. You have the same outer controller `A` (and signal `a`), and you wrap it with an inner controller `B(a)` with signal `b(a)`. Signal `b(a)` has the following semantics:

- Aborting `A` aborts `a` and `b(a)`.
- Aborting `B(a)` aborts `b(a)`.
- Disposing `A` disposes `a` but not `b(a)`, because `b(a)` could still be aborted by `B(a)`. However, the link between `B(a)` and a` can be removed and the subscription can be GC'd
- Disposing `B(a)` disposes `b(a)`, but not `a`. Any subscriptions to `b(a)` can be GC'd

[05:03:37.0928] <rbuckton>
 * In the `new CancellationTokenSource(linkedTokens?)` approach, you produce a new source/controller that dominates the cancellation interaction with `inner`. You have the same outer controller `A` (and signal `a`), and you wrap it with an inner controller `B(a)` (with signal `b(a)`). Signal `b(a)` has the following semantics:

- Aborting `A` aborts `a` and `b(a)`.
- Aborting `B(a)` aborts `b(a)`.
- Disposing `A` disposes `a` but not `b(a)`, because `b(a)` could still be aborted by `B(a)`. However, the link between `B(a)` and a\` can be removed and the subscription can be GC'd
- Disposing `B(a)` disposes `b(a)`, but not `a`. Any subscriptions to `b(a)` can be GC'd

[05:04:32.0980] <rbuckton>
 * In the `new CancellationTokenSource(linkedTokens?)` approach, you produce a new source/controller that dominates the cancellation interaction with `inner`. You have the same outer controller `A` (and signal `a`), and you wrap it with an inner controller `B(a)` (with signal `b(a)`). Signal `b(a)` has the following semantics:

- Aborting `A` aborts `a` and `b(a)`.
- Aborting `B(a)` aborts `b(a)`.
- Disposing `A` disposes `a` but not `b(a)`, because `b(a)` could still be aborted by `B(a)`. However, the link between `B(a)` and `a` can be removed and the subscription can be GC'd
- Disposing `B(a)` disposes `b(a)`, but not `a`. Any subscriptions to `b(a)` can be GC'd

[05:08:11.0585] <rbuckton>
So the difference between the two designs is not just one of memory efficiency, but capability. `b(a)` has a capability that `ab` does not.

[05:09:52.0035] <rbuckton>
 * In the `new CancellationTokenSource(linkedTokens?)` approach, you produce a new source/controller that dominates the cancellation interaction with `inner`. You have the same outer controller `A` (and signal `a`), and you wrap it with an inner controller `B(a)` (with signal `b(a)`). Signal `b(a)` has the following semantics:

- Aborting `A` aborts `a` and `b(a)` so long as a link still remains between `a` and `B(a)`.
- Aborting `B(a)` aborts `b(a)`.
- Disposing `A` disposes `a` but not `b(a)`, because `b(a)` could still be aborted by `B(a)`. However, the link between `B(a)` and `a` can be removed and the subscription can be GC'd
- Disposing `B(a)` disposes `b(a)`, but not `a`. Any subscriptions to `b(a)` can be GC'd

[05:10:16.0142] <rbuckton>
 * In the `new CancellationTokenSource(linkedTokens?)` approach, you produce a new source/controller that dominates the cancellation interaction with `inner`. You have the same outer controller `A` (and signal `a`), and you wrap it with an inner controller `B(a)` (with signal `b(a)`). Signal `b(a)` has the following semantics:

- Aborting `A` aborts `a` and `b(a)` so long as a link still remains between `a` and `B(a)`.
- Aborting `B(a)` aborts `b(a)`.
- Disposing `A` disposes `a` but not `b(a)`, because `b(a)` could still be aborted by `B(a)`. However, the link between `B(a)` and `a` can be removed and the subscription can be GC'd.
- Disposing `B(a)` disposes `b(a)`, but not `a`. Any subscriptions to `b(a)` can be GC'd.

[05:27:58.0561] <rbuckton>
I also discuss a lot of this in https://github.com/tc39/proposal-cancellation/blob/master/stage0/README.md, which was pulled out of the explainer when it advanced to stage 1.

[07:52:43.0090] <littledan>
I don't see anything in these docs about disposal. Is disposal really a necessary feature?

[07:57:00.0132] <littledan>
There's some related discussion about being on AbortController vs AbortSignal in https://github.com/shaseley/abort-signal-any/#exposure-through-abortsignal-vs-abortcontroller

[10:03:50.0407] <rbuckton>
> <@littledan:matrix.org> I don't see anything in these docs about disposal. Is disposal really a necessary feature?

See `source.close()` in that stage 0 explainer. I believe it is important, and the lack of it today is wasteful. 

[10:09:56.0125] <rbuckton (traveling)>
https://github.com/tc39/proposal-cancellation/blob/master/stage0%2FREADME.md#sourceclose

[10:17:21.0266] <rbuckton (traveling)>
If you can close/dispose a source, functions that receive the closed token can use more efficency code paths, and registrations that would have introduced closures can be skipped. A source that is left open instead of canceling/closing results in closures holding references to closed over values far longer than necessary. IIRC, AbortSignal doesn't even clean up user code registrations when aborted since user code registrations are event based

[10:18:55.0548] <rbuckton (traveling)>
* If you can close/dispose a source, functions that receive the closed token can use more efficenct code paths, and registrations that would have introduced closures can be skipped. A source that is left open instead of canceling/closing results in closures holding references to closed over values far longer than necessary. IIRC, AbortSignal doesn't even clean up user code registrations when aborted since user code registrations are event based

[10:28:11.0707] <rbuckton (traveling)>
FYI, the most recent iteration of this API is here: https://esfx.js.org/esfx/api/canceltoken.html?tabs=ts

[10:31:45.0010] <rbuckton (traveling)>
Where `CancelToken.race(cancelables)` is the same as `AbortSignal.any`, but `CancelToken.source(cancelables)` is preferred.

[15:00:22.0661] <littledan>
> <@rbuckton:matrix.org> See `source.close()` in that stage 0 explainer. I believe it is important, and the lack of it today is wasteful. 

Oh, I see. This is new for me; I need to think more to understand the implications.


2024-06-04
[03:51:26.0252] <nicolo-ribaudo>
WHATWG adopted a process inspired by our stage-based one:
https://whatwg.org/stages

[07:08:56.0818] <Chris de Almeida>
neat!  I wonder when they'll add 2.7  üßê


2024-06-05
[18:09:06.0532] <Michael Ficarra>
it actually appears it was mostly copied from us before the recent refactoring of the process document and the addition of 2.7

[18:09:09.0905] <Michael Ficarra>
that's a shame

[22:54:19.0718] <littledan>
Actually it matches our new state: tests are required for WHATWG stage 3, which we caught up with when defining Stage 2.7

[03:25:52.0819] <Michael Ficarra>
No, this much more closely matches our process before the 2.7 split. There's no point at which they commit to the specifics of the solution but have not yet created tests and permitted implementation. That was the primary goal of the split. Requiring tests for our stage 3 was only part of it.

[06:21:45.0746] <littledan>
I agree, there‚Äôs no specific intermediate point in their process; people are expected to write tests without that support. Though requiring tests for Stage 3 was a big part for me!


2024-06-07
[11:23:55.0652] <Jack Works>
> <@rbuckton:matrix.org> If you can close/dispose a source, functions that receive the closed token can use more efficency code paths, and registrations that would have introduced closures can be skipped. A source that is left open instead of canceling/closing results in closures holding references to closed over values far longer than necessary. IIRC, AbortSignal doesn't even clean up user code registrations when aborted since user code registrations are event based

yeah, I always write `signal.addEventListener('abort', f, { signal, once: true })`


2024-06-09
[16:21:31.0958] <rbuckton (traveling)>
I tested positive for covid on Saturday and it's hitting me hard. Depending on how my symptoms are tomorrow, I may need to limit my remote attendance to rest. I'll post a late breaking schedule constraint to the agenda tomorrow, if necessary. 

[16:30:51.0360] <Chris de Almeida>
draft schedule is available: https://github.com/tc39/Reflector/issues/527


2024-06-10
[23:37:30.0231] <Chris de Almeida>
please note some items on the schedule have shifted

[23:46:18.0074] <Ashley Claymore>
Oh no! Hope it passes quickly and you're able to some rest Ron

[00:17:23.0438] <nicolo-ribaudo>
> <@softwarechris:matrix.org> draft schedule is available: https://github.com/tc39/Reflector/issues/527

jkup "TG4: Source Maps (5m, Jon Kuperman)" can be removed given that we have the long presentation, right?

[00:17:46.0894] <jkup>
Yes that‚Äôs good with me! I meant to PR removing it 

[13:07:01.0950] <shu>
why is WWDC highlighting RegExp.escape

[13:07:06.0875] <shu>
it's stage 2!

[13:27:56.0110] <Chris de Almeida>
savaged again by the regex hypecycle!

[13:28:07.0263] <kriskowal>
This is funny, but also imagine waiting to jump the gun since https://simonwillison.net/2006/Jan/20/escape/

[13:43:05.0328] <ljharb>
O.o how is wwdc highlighting it?

[13:48:43.0037] <shu>
[https://www.youtube.com/watch?v=RXeOiIDNNek 57:46](https://youtu.be/RXeOiIDNNek?t=3466)

[13:49:09.0883] <shu>
Promise.try too

[13:49:16.0863] <shu>
is this like a list of WIP issues or something

[13:50:04.0282] <Michael Ficarra>
lmao `br_on_cast_fail` what is going on

[13:50:13.0573] <shu>
yeah there are so many questions for that graphic

[13:50:16.0159] <Michael Ficarra>
literally not even developers care about it, that is just for compiler authors

[13:50:27.0442] <shu>
gotta give it to them for keeping it real with showing how the sausage is made

[13:54:07.0185] <jkup>
Oh wow I thought you were joking with the RegExp.escape comment!

[13:54:18.0978] <shu>
me, a joker?


2024-06-11
[18:05:15.0806] <rkirsling>
> <@shuyuguo:matrix.org> Promise.try too

I guess I won't complain that they featured my work like this üòÜ

[23:27:46.0501] <Rob Palmer>
The Zoom is up and the Sign-in form is posted on the Reflector.

https://github.com/tc39/Reflector/issues/527

[00:11:32.0175] <Duncan MacGregor>
Is it the same sign in form for remote and in person?

[00:16:44.0826] <eemeli>
Yes.

[00:18:20.0277] <ryzokuken (TC39 üá´üáÆ)>
have a smooth recovery saminahusain 

[00:20:17.0890] <Aki>
recommendation to presenters: write your summary for notes ahead of time. edit on the fly as needed.

[00:23:33.0946] <littledan>
top quality transcriptionist today

[00:23:44.0791] <littledan>
 * top quality transcription today

[00:28:55.0545] <littledan>
FYI: Google Docs works badly when many people are in the doc. Please close the doc if you just have it in the background, if you're not reading or editing the notes.

[00:32:43.0056] <Michael Ficarra>
@littledan:matrix.org the recurring work was only due to Paged.js failing to break (or not break) according to the breaking rules that we wrote

[00:32:55.0405] <Michael Ficarra>
if a tool supports those rules, we don't need to do that work by hand

[00:33:38.0643] <Michael Ficarra>
for any browser vendors in the room, that tool *could* be your browser if you implement CSS Paged Media btw

[00:34:03.0009] <ryzokuken (TC39 üá´üáÆ)>
cc nicolo-ribaudo üëÄ

[00:34:17.0625] <ryzokuken (TC39 üá´üáÆ)>
 * ^ nicolo-ribaudo üëÄ

[00:37:38.0609] <littledan>
Is ryzokuken audible from remote?

[00:37:49.0999] <Aki>
yes

[00:41:09.0063] <Michael Ficarra>
@littledan:matrix.org in-room audio appears to be modulated separately from zoom audio

[00:41:22.0208] <Michael Ficarra>
if something sounds off to you, ask @eemeli:mozilla.org to adjust it

[00:42:11.0720] <Michael Ficarra>
FYI 402 editors: here is the in-progress editorial conventions document that @bakkot:matrix.org mentioned in the 262 update: https://github.com/tc39/ecma262/wiki/Editorial-Conventions

[00:42:51.0133] <eemeli>
Yeah, in-room and remote audio are routed separately. The speakers on the wall are delivering sound from Zoom, while in-room is from the screen at the other end.

[00:42:56.0744] <littledan>
great bullets bakkot, thanks

[00:50:55.0259] <littledan>
sffc: I would prefer that we not add Gemini-produced summaries in the notes. Let's use our human intelligence to understand what the important points are.

[00:51:24.0585] <littledan>
everyone who wants AI-produced summaries can make them themselves

[00:51:51.0466] <nicolo-ribaudo>
Is the _<< Software identified by reference to the Ecma Standard* ("Software)">>_ in https://github.com/tc39/test262/blob/main/LICENSE#L1 a placeholder, or is it expected to be written like that?

[00:54:24.0594] <Michael Ficarra>
> <@littledan:matrix.org> everyone who wants AI-produced summaries can make them themselves

you're *so close*

[00:54:58.0072] <littledan>
(I don't want to read an AI summary of anything)

[00:55:15.0214] <littledan>
(and it is confusing if they're included in our docs because it looks authoritative)

[00:55:25.0357] <Michael Ficarra>
I agree with both of those statement

[00:55:30.0073] <Michael Ficarra>
* I agree with both of those statements

[00:55:59.0738] <Aki>
holy shit toronto and montreal were merged?

[00:56:13.0908] <Aki>
politically not insignificant

[00:56:19.0300] <Chris de Almeida>
it's Torontreal now

[00:56:34.0128] <Chris de Almeida>
whoops, this isn't TDZ

[00:56:34.0459] <Rob Palmer>
Montronto surely

[00:57:06.0266] <Michael Ficarra>
üëÆ ‚û°Ô∏è #temporaldeadzone:matrix.org

[00:59:20.0345] <hax (HE Shi-Jun)>
typoÔºö chongquing should be chongqing

[00:59:42.0673] <littledan>
> <@haxjs:matrix.org> typoÔºö chongquing should be chongqing

This is a historical entry in TZDB; there are a lot of outdated latinizations there

[01:00:26.0879] <littledan>
(several of the other forwardings discussed were examples of the same)

[01:02:02.0083] <hax (HE Shi-Jun)>
I never see "asia/chongquing" spelling, google shows nothing...

[01:02:37.0411] <rkirsling>
yeah that's an interesting typo that only an English speaker could make

[01:02:46.0464] <littledan>
oh I stand corrected

[01:03:18.0213] <Michael Ficarra>
I thought the whole point of the slide was that some of the timezones were being renamed due to historical misspellings

[01:03:26.0023] <hax (HE Shi-Jun)>
Anyway, "asia/chongqing" -> "asia/shanghai" is a mistake IMO, always cause confusion and accidentaly cause bug üòÇ

[01:03:26.0339] <rkirsling>
(the outdated romanization would be chungking, fwiw)

[01:04:23.0495] <hax (HE Shi-Jun)>
Though it's not the bug of JS, but the bug of TZDB.

[01:06:24.0804] <littledan>
> <@haxjs:matrix.org> Anyway, "asia/chongqing" -> "asia/shanghai" is a mistake IMO, always cause confusion and accidentaly cause bug üòÇ

why is that? is there a chance that China will split into multiple timezones?

[01:08:22.0550] <Richard Gibson>
https://github.com/eggert/tz/blob/d56ae6ee85d496ef67f0428e81060341ec70cec2/backward#L311

[01:08:36.0944] <Chris de Almeida>
> <@littledan:matrix.org> why is that? is there a chance that China will split into multiple timezones?

bit of a misconception there is only one

[01:08:40.0041] <Chris de Almeida>
`Asia/Urumqi`

[01:08:41.0249] <Richard Gibson>
 * https://github.com/eggert/tz/blob/d56ae6ee85d496ef67f0428e81060341ec70cec2/backward#L311
> `Link	Asia/Shanghai		Asia/Chungking	#= Asia/Chongqing`

[01:09:26.0262] <Chris de Almeida>
also different TZ for HK and Macau

[01:09:58.0654] <Chris de Almeida>
although those are UTC+8 same as CST

[01:11:28.0184] <hax (HE Shi-Jun)>
> <@littledan:matrix.org> why is that? is there a chance that China will split into multiple timezones?

It's irrelevant to possible multiple timezones. Asia/Chongqing is a BUG due to misunderstanding of historical timezones in World War II. It never be used broadly in practice in the history. Or if it was been used, it already have no usage from 1950. So keep Asia/chongqing in the TZDB always cause confusion to Chinese programmers and users, especially some users might change the timezone to it and in edge cases it cause weird bugs in the historical dates.

[01:12:59.0643] <littledan>
> <@haxjs:matrix.org> It's irrelevant to possible multiple timezones. Asia/Chongqing is a BUG due to misunderstanding of historical timezones in World War II. It never be used broadly in practice in the history. Or if it was been used, it already have no usage from 1950. So keep Asia/chongqing in the TZDB always cause confusion to Chinese programmers and users, especially some users might change the timezone to it and in edge cases it cause weird bugs in the historical dates.

Great, so sounds like the merge is what should happen

[01:13:51.0887] <JaseW>
TCQ Revolutions

[01:13:53.0531] <hax (HE Shi-Jun)>
> <@littledan:matrix.org> Great, so sounds like the merge is what should happen

Well I think it should be deleted, not merged.. but It might be the deep design philosophy of TZDB which I don't fully agree with.

[01:13:56.0647] <littledan>
Meta: Please link your slides from the agenda so it's easier for folks to follow along (and link the slides from the notes)

[01:14:24.0502] <littledan>
> <@haxjs:matrix.org> Well I think it should be deleted, not merged.. but It might be the deep design philosophy of TZDB which I don't fully agree with.

so if someone uses it, an exception should be thrown, rather than redirecting them to CST?

[01:14:48.0847] <littledan>
Christian Ulbrich: After the presentation, please paste your slide link in the notes

[01:16:08.0854] <ryzokuken (TC39 üá´üáÆ)>
> <@haxjs:matrix.org> Well I think it should be deleted, not merged.. but It might be the deep design philosophy of TZDB which I don't fully agree with.

unfortunately that's not how TZDB is managed, yeah üòï 

[01:16:30.0986] <ryzokuken (TC39 üá´üáÆ)>
so all historic or just incorrect timezones need to stay forever although they could be linked to a more relevant zone

[01:16:46.0098] <hax (HE Shi-Jun)>
> <@littledan:matrix.org> so if someone uses it, an exception should be thrown, rather than redirecting them to CST?

If it's really "merged", I think it's ok. But in fact it will report differently in old dates in 194x ~ 195x. As I understand, TZDB never ensure correctness before 1970, but most OS still use TZDB history part, which IMO is bad, and cause problems.

[01:21:31.0129] <hax (HE Shi-Jun)>
> <@haxjs:matrix.org> If it's really "merged", I think it's ok. But in fact it will report differently in old dates in 194x ~ 195x. As I understand, TZDB never ensure correctness before 1970, but most OS still use TZDB history part, which IMO is bad, and cause problems.

Note "Asia/chongqing" is especially bad case , because in some old version TZDB it even report different time to CST in 198x dates.

[01:27:59.0277] <hax (HE Shi-Jun)>
> <@usharma:igalia.com> so all historic or just incorrect timezones need to stay forever although they could be linked to a more relevant zone

But there were another three China historical timezones in old TZDB and have been deleted, only Asia/Chongqing is merged, not sure why they keep it, IMO they are just from same misunderstand.

[01:28:38.0882] <ryzokuken (TC39 üá´üáÆ)>
> <@haxjs:matrix.org> But there were another three China historical timezones in old TZDB and have been deleted, only Asia/Chongqing is merged, not sure why they keep it, IMO they are just from same misunderstand.

interesting! yeah I have no clue but I'm curious so I'd try to dig around to see why

[01:29:05.0147] <littledan>
> <@haxjs:matrix.org> If it's really "merged", I think it's ok. But in fact it will report differently in old dates in 194x ~ 195x. As I understand, TZDB never ensure correctness before 1970, but most OS still use TZDB history part, which IMO is bad, and cause problems.

Yes, ICU and JS implementations tend to implement this historical part

[01:39:31.0787] <nicolo-ribaudo>
bakkot A few weeks ago I was writing my own source maps decoder, which use base64 but in a weird way: 6-bit-bytes should not be rearranged in 8-bit-bytes, but left as they are (or padded with a leading `00`): `ABCD` is not `[0, 16, 131]` but `[0, 1, 2, 3]`.
The proposals does _not_ support doing anything like this, right? (it's a quite niche use case so I'm not expecting it to, but I'm wondering if I missed something)

[01:39:49.0704] <bakkot>
correct

[01:40:17.0997] <bakkot>
but Michael Ficarra's iterator chunking proposal + flatMap would get you there!

[01:40:44.0549] <bakkot>
actually no it wouldn't, reading closer

[01:41:51.0103] <bakkot>
I guess that's just `[...string].map(x => Uint8Array.fromBase64(x + 'AAA')[0])`

[01:42:37.0696] <bakkot>
or... something like that anyway

[01:42:47.0931] <nicolo-ribaudo>
Oh yes that would work

[01:44:42.0159] <hax (HE Shi-Jun)>
> <@littledan:matrix.org> Yes, ICU and JS implementations tend to implement this historical part

Yeah, even Asia/Shanghai have some weird historical part. So in current js/web application, there is no easy way to represent CST (China standard time) for old dates (just like proleptic Gregorian calendar). It seems the design flaw of TZDB?

[01:45:21.0661] <littledan>
has this feedback been raised to the tzdb mailing list? (we're not really in a position to manage a better tzdb here in TC39)

[01:46:00.0660] <bakkot>
 * I guess that's just `[...string].map(x => Uint8Array.fromBase64(x + 'AAA')[0] >> 2)`

[01:49:25.0098] <sffc>
On the topic of time zones: TZDB and CLDR have both fairly explicitly decided to not prioritize pre-1970 transitions (and especially not pre-WWII transitions) because they were kind of a mess and documentation is kind-of lacking.

[01:50:43.0445] <sffc>
My understanding is that some of the merges are from time zones that had historic differences but have been the same since 1970

[01:52:23.0719] <bakkot>
re: `Symbol.isConcatSpreadable`, not only does no one use it, but also if you do use it then all uses of `Array.p.concat` anywhere on your page get slower in V8: https://www.tines.com/blog/understanding-why-our-build-got-15x-slower-with-webpack-5

[01:57:39.0089] <hax (HE Shi-Jun)>
Is it also get slower in FF/Webkit? Isn't that the bug of v8?

[01:58:02.0666] <bakkot>
it's not a bug, it's an intentional design decision

[01:58:52.0084] <bakkot>
FF and Webkit have similar things though I don't know if they have this specific thing

[02:01:17.0295] <Duncan MacGregor>
There is always going to be a trade off when deoptimising for things likes `isConcatSpreadable`. Just deopting at the particular sites you'll likely use more resources than just noting that the possibility exists everywhere.

[03:20:18.0931] <Luca Casonato>
The `AsyncIterator.propotype.split` thing looks nice

[03:24:20.0116] <Luca Casonato>
I wonder if we can combine the ideas from `split`, but still not require combining  a `split` and `merge`. For example:

```
const parallel = iter.parallelMap(5, (iter) => {
  return iter.map(mapFn).filter(filterFn)
});
```

Would be the same as

```
const parallel = AsyncIterator.merge(
  iter.split(5).map((iter) => {
    return iter.map(mapFn).filter(filterFn);
  })
);
```

[03:24:34.0646] <Luca Casonato>
 * I wonder if we can combine the ideas from `split`, but still not require combining  a `split`, `map` and `merge`. For example:

```
const parallel = iter.parallelMap(5, (iter) => {
  return iter.map(mapFn).filter(filterFn)
});
```

Would be the same as

```
const parallel = AsyncIterator.merge(
  iter.split(5).map((iter) => {
    return iter.map(mapFn).filter(filterFn);
  })
);
```

[03:35:02.0751] <Michael Ficarra>
@aclaymore:matrix.org that's what semaphores are for

[03:44:48.0805] <bakkot>
very pleased to have used 44minutes 30 seconds of a 45 minute timebox

[03:45:01.0756] <bakkot>
> <@michaelficarra:matrix.org> @aclaymore:matrix.org that's what semaphores are for

which we also don't have

[03:45:02.0168] <ryzokuken (TC39 üá´üáÆ)>
like a pro

[03:46:23.0594] <Michael Ficarra>
@bakkot:matrix.org yes but I would prefer the concurrency-limiting function helper anyway

[03:56:25.0040] <bakkot>
> <@lucacasonato:matrix.org> I wonder if we can combine the ideas from `split`, but still not require combining  a `split`, `map` and `merge`. For example:
> 
> ```
> const parallel = iter.parallelMap(5, (iter) => {
>   return iter.map(mapFn).filter(filterFn)
> });
> ```
> 
> Would be the same as
> 
> ```
> const parallel = AsyncIterator.merge(
>   iter.split(5).map((iter) => {
>     return iter.map(mapFn).filter(filterFn);
>   })
> );
> ```

yeah I was thinking about something like this. it's a very weird signature but once you learn to use it I think it does exactly what you want in many cases. a cute thing is that you can pass an async generator as the second argument:

```
iter.parallelMap(5,  async function*(vals) { for await (let item of vals) { yield item + 2 } })
```
or whatever

[03:56:40.0843] <bakkot>
 * yeah I was thinking about something like this. it's a very weird signature but once you learn to use it I think it does exactly what you want in many cases. a cute thing is that you can pass an async generator as the second argument:

```
iter.parallelMap(5, async function* (vals) { for await (let item of vals) { yield item + 2 } })
```

or whatever

[03:58:04.0164] <bakkot>
it does not immediately resolve the question of consuming, but I think that could just be a second function; `iter.concurrentForEach` or something

[03:58:20.0562] <bakkot>
 * it does not immediately resolve the question of consuming without producing a new iterator, but I think that could just be a second function; `iter.concurrentForEach` or something

[03:59:00.0318] <Michael Ficarra>
the note-taker is double-spacing sentences again, are we just gonna fix that up in post?

[03:59:14.0950] <bakkot>
```
let vals = iter.concurrentMap(5, async_generator);

for await (let item of vals) ...
```
and
```
let promise = iter.concurrentForEach(5, async_function);

await promise;
```

[03:59:44.0754] <bakkot>
 * ```
let vals = iter.concurrentMap(5, async_generator_taking_iterator);

for await (let item of vals) ...
```

and

```
let promise = iter.concurrentForEach(5, async_function_taking_iterator);

await promise;
```

[04:00:16.0507] <bakkot>
though maybe `concurrentForEach` would take a `T => void` rather than an `Iterator<T> => void`? unclear

[04:00:53.0393] <bakkot>
(which would make that a bad choice of names)

[04:01:21.0319] <Aki>
> <@michaelficarra:matrix.org> the note-taker is double-spacing sentences again, are we just gonna fix that up in post?

absolutely

[04:01:26.0896] <Aki>
i have a regex for it

[04:03:36.0239] <Michael Ficarra>
k good then we don't need to bug them about it

[04:17:34.0061] <Ashley Claymore>
Option 6 (a-la acorn):

```
const errors = [];
...format(..., { onError: errors });
if (errors.length) { ...}
```

to avoid inline callbacks

[04:23:32.0581] <bakkot>
i can no longer stay awake, but my bot will continue being in the meeting. please don't be misled by its presence, it is just a computer and cannot (yet?) represent my opinions for me

[04:25:08.0596] <bakkot>
for Error.isError, I'm not objecting to stage 2, but I still have reservations about whether it is motivated. i would like it to have strong from other delegates, and the reasons they want it to be captured, before it advances. also I do want to say that it absolutely must consider dom exceptions to be errors; users should not be exposed to that distinction.

[04:34:36.0109] <Luca Casonato>
> <@michaelficarra:matrix.org> @aclaymore:matrix.org that's what semaphores are for

straw man proposal: https://github.com/lucacasonato/proposal-semaphore

[04:34:46.0179] <Luca Casonato>
> <@michaelficarra:matrix.org> @aclaymore:matrix.org that's what semaphores are for

 * straw person proposal: https://github.com/lucacasonato/proposal-semaphore

[04:35:09.0928] <Michael Ficarra>
@lucacasonato:matrix.org lol noooo why?

[04:35:23.0626] <Michael Ficarra>
> @bakkot yes but I would prefer the concurrency-limiting function helper anyway

[04:35:47.0228] <Luca Casonato>
Michael Ficarra: It actually does that too - `semaphore.wait()` is this

[04:36:12.0610] <Luca Casonato>
 * Michael Ficarra: It actually does that too - `semaphore.wait()` is this (minus the wrapping itself)

[04:36:25.0127] <Michael Ficarra>
@lucacasonato:matrix.org that's backwards though

[04:36:44.0052] <mgaudet>
(Do we have a test262 dashboard that has v8 and sm on it? I have https://test262.fyi/ in my history, but this seems incomplete at the moment) 

[04:37:10.0399] <Luca Casonato>
> <@mgaudet:mozilla.org> (Do we have a test262 dashboard that has v8 and sm on it? I have https://test262.fyi/ in my history, but this seems incomplete at the moment)

It's just bugged at the moment - it has V8 and SM usually

[04:37:11.0890] <Michael Ficarra>
`let limitedFunction = fn.limitConcurrency(5)` and then pass `limitedFunction` around in place of `fn`

[04:37:50.0313] <Michael Ficarra>
> <@mgaudet:mozilla.org> (Do we have a test262 dashboard that has v8 and sm on it? I have https://test262.fyi/ in my history, but this seems incomplete at the moment) 

https://github.com/CanadaHonk/test262.fyi/issues/56

[04:38:00.0477] <ptomato>
> <@mgaudet:mozilla.org> (Do we have a test262 dashboard that has v8 and sm on it? I have https://test262.fyi/ in my history, but this seems incomplete at the moment) 

Was just wondering that as well, since I based my remark about implementation status on it üòÖ

[04:38:30.0388] <Luca Casonato>
> <@michaelficarra:matrix.org> @lucacasonato:matrix.org that's backwards though

```js
const semaphore = new Semaphore(12)
function wrap(cb) {
  return (...args) => semaphore.wait(cb);
}
```

I'll add this helper as an open question to the doc :)

[04:39:07.0262] <Michael Ficarra>
yeah but that allows you to wait on the semaphore with multiple functions, right?

[04:39:48.0711] <Luca Casonato>
Yes - I mean isn't that what you want?

[04:40:02.0913] <Luca Casonato>
> <@michaelficarra:matrix.org> `let limitedFunction = fn.limitConcurrency(5)` and then pass `limitedFunction` around in place of `fn`

This lacks flex

[04:40:07.0632] <Michael Ficarra>
no, it's inverted

[04:40:27.0107] <Michael Ficarra>
I want consumers to not have to even know that there's limiting going on

[04:40:57.0802] <Michael Ficarra>
think about it this way: if I am currently passing a function to someone, I want to swap it out with a concurrency-limited one without them changing their implementation

[04:41:14.0857] <Michael Ficarra>
yes I could do that with your wrap helper, and in fact that's how I will always do it

[04:41:30.0561] <Michael Ficarra>
so if I always do it that way, there's no reason to expose the semaphore directly

[04:46:33.0077] <Luca Casonato>
Sure - that makes sense. But there are use cases where this doesn't work - for example if you have `execute` and `query` functions that both operate on the same database, and you want to limit both together.

Another common case for this is when you want to limit the number of FS ops, but there are many different ops. For example you want to limit the number of `stat()`, `realpath()` etc all with the same limiter

Another use case that wrapping is not expressive enough for is if you want to limit the number of open files. Because you "acquire" at every `open` call, but only release once a file handle is explicitly closed.

Also one could propose that we make `Semaphore` sharable across agents :)

[04:49:30.0204] <Luca Casonato>
added a `wrap` method:

```
const semaphore = new Semaphore(5);

const wrappedFunction = semaphore.wrap(async () => {
  // Do some work
});

async function doWork() {
  await wrappedFunction();
}
```

[04:49:34.0938] <Luca Casonato>
 * added a `wrap` method:

```js
const semaphore = new Semaphore(5);

const wrappedFunction = semaphore.wrap(async () => {
  // Do some work
});

async function doWork() {
  await wrappedFunction();
}
```

[04:51:52.0179] <Michael Ficarra>
> <@lucacasonato:matrix.org> Sure - that makes sense. But there are use cases where this doesn't work - for example if you have `execute` and `query` functions that both operate on the same database, and you want to limit both together.
> 
> Another common case for this is when you want to limit the number of FS ops, but there are many different ops. For example you want to limit the number of `stat()`, `realpath()` etc all with the same limiter
> 
> Another use case that wrapping is not expressive enough for is if you want to limit the number of open files. Because you "acquire" at every `open` call, but only release once a file handle is explicitly closed.
> 
> Also one could propose that we make `Semaphore` sharable across agents :)

it does if you virtualise the database through these

[04:52:26.0280] <Luca Casonato>
yeah, but that seems rather unergonomic?

[04:55:28.0516] <Luca Casonato>
You can always do it by creating a function like `(function call(cb, ...args) => cb(args)).limitConcurrency(5)` - but i mean that is very messy and it also does not layer well with `using` - also it's very unergonomic when you are limiting a resource, not a single call

[04:55:48.0955] <Luca Casonato>
 * You can always do it by creating a function like `const call = ((cb, ...args) => cb(args)).limitConcurrency(5)` - but i mean that is very messy and it also does not layer well with `using` - also it's very unergonomic when you are limiting a resource, not a single call

[04:55:50.0317] <Michael Ficarra>
not really, it moves the limiting further inward into like a "kernel"

[04:55:56.0509] <Michael Ficarra>
we should talk over snack break

[04:55:58.0464] <Michael Ficarra>
I want a snack

[04:56:03.0050] <Luca Casonato>
sure :)

[05:02:30.0160] <hax (HE Shi-Jun)>
littledan: 

Regarding `function.sent`, we have discussed use cases and possible solutions in several past meetings. However, there is no consensus on whether the use cases are strong enough to support introducing a syntactic solution. Although I generally still believe this is a problem worth addressing, perhaps solving it through a more general feature like function decorators in the form of an API is more promising than introducing entirely new syntax. Therefore, I hope to revisit this proposal after the function decorator proposal advances to the next stage.

[05:07:34.0223] <ljharb>
good morning. to be clear about Iterator.concat, the behavior I think users will expect has nothing to do with Symbol.concatSpreadable, it's that array concat takes an array or a scalar, and anything with the name concat should do the same (take a container or a thing contained).

[05:07:48.0669] <ljharb>
 * good morning. to be clear about Iterator.concat, the behavior I think users will expect has nothing to do with Symbol.concatSpreadable (which is regrettable and nobody should expect it), it's that array concat takes an array or a scalar, and anything with the name concat should do the same (take a container or a thing contained).

[05:07:54.0966] <ljharb>
 * good morning. to be clear about Iterator.concat, the behavior I think users will expect has nothing to do with Symbol.isConcatSpreadable (which is regrettable and nobody should expect it), it's that array concat takes an array or a scalar, and anything with the name concat should do the same (take a container or a thing contained).

[05:09:36.0714] <ljharb>
 * good morning. to be clear about Iterator.concat, the behavior I think users will expect has nothing to do with Symbol.isConcatSpreadable (which is regrettable and nobody should expect it), it's that array concat takes both arrays or scalars, and anything with the name concat should do the same (take both containers or things contained).

[05:15:29.0761] <ljharb>
link to present for Promise.try: https://github.com/tc39/proposal-promise-try/issues/15

[05:17:46.0151] <littledan>
> <@ljharb:matrix.org> good morning. to be clear about Iterator.concat, the behavior I think users will expect has nothing to do with Symbol.isConcatSpreadable (which is regrettable and nobody should expect it), it's that array concat takes both arrays or scalars, and anything with the name concat should do the same (take both containers or things contained).

ah, sorry for any confusion caused by my misinterpretation

[05:19:04.0925] <Luca Casonato>
test262.fyi is sorta back ^^

[05:19:12.0103] <Michael Ficarra>
it's gradually filling

[05:19:30.0622] <ljharb>


links to present for RegExp.escape:
 - https://github.com/tc39/proposal-regex-escaping/issues/58
 - https://tc39.es/proposal-regex-escaping/


[05:20:01.0312] <littledan>
Congrats ljharb 

[05:20:07.0278] <littledan>
they wouldn't let me clap...

[05:21:51.0619] <littledan>
BTW volunteers welcome for doing the next proposal scrub

[05:32:01.0443] <Michael Ficarra>
I think we should retro the proposal scrub because I value it but it felt unproductive for some parts

[05:32:48.0362] <Ashley Claymore>
> <@haxjs:matrix.org> littledan: 
> 
> Regarding `function.sent`, we have discussed use cases and possible solutions in several past meetings. However, there is no consensus on whether the use cases are strong enough to support introducing a syntactic solution. Although I generally still believe this is a problem worth addressing, perhaps solving it through a more general feature like function decorators in the form of an API is more promising than introducing entirely new syntax. Therefore, I hope to revisit this proposal after the function decorator proposal advances to the next stage.

thanks! I've copied this into the notes in the appropriate section.

[05:34:22.0874] <hax (HE Shi-Jun)>
If do temp check, could we have a simple example to show the difference of two escape solutions ?

[05:34:35.0567] <Rob Palmer>
https://docs.google.com/document/d/19PqeLeKjdy9zTn4OAQEhQVI2zmAxUvZ7eCmnNrKQHeI/edit

[05:34:44.0264] <Rob Palmer>
Nicolo, can you share this on-screen

[05:35:56.0048] <Michael Ficarra>
> <@haxjs:matrix.org> If do temp check, could we have a simple example to show the difference of two escape solutions ?

`\x40` vs `\@`

[05:36:15.0024] <Michael Ficarra>
`for RegExp.escape('@')`

[05:36:23.0659] <Michael Ficarra>
* for `RegExp.escape('@')`

[05:36:48.0167] <Richard Gibson>
> <@haxjs:matrix.org> If do temp check, could we have a simple example to show the difference of two escape solutions ?

if we don't change, `RegExp.escape("$") === "\\$"`. If we do change, `RegExp.escape("$") === "\\x24"`

[05:39:39.0116] <ljharb>


links to present for Error.isError:
 - https://github.com/tc39/proposal-is-error?tab=readme-ov-file#use-cases
 - https://tc39.es/proposal-is-error/

[05:43:43.0014] <Rob Palmer>
I made a mistake of not stating Shu's comments on `RegExp.escape` so will read it out at the next break:

>V8 has no concerns for Stage 2.7.

>As for character vs hex code escapes, V8 can live with either outcome but weakly prefers character escapes. The future stability argument AFAIU is that choosing character escapes makes changing the behavior of character escapes in the future even harder. But it is already very hard to change non-throwing behavior to new non-throwing behavior. We don't understand why this would make it meaningfully harder.

[05:49:47.0894] <Michael Ficarra>
> <@robpalme:matrix.org> I made a mistake of not stating Shu's comments on `RegExp.escape` so will read it out at the next break:
> 
> >V8 has no concerns for Stage 2.7.
> 
> >As for character vs hex code escapes, V8 can live with either outcome but weakly prefers character escapes. The future stability argument AFAIU is that choosing character escapes makes changing the behavior of character escapes in the future even harder. But it is already very hard to change non-throwing behavior to new non-throwing behavior. We don't understand why this would make it meaningfully harder.

that was exactly my opinion

[05:50:58.0145] <littledan>
doesn't it throw an exception if you forget to call super(), unless you take the extreme step of returning something other than this?

[05:51:04.0652] <littledan>
 * doesn't it throw an exception if you forget to call super(), unless you take the extreme step of returning something other than this/undefined?

[05:51:20.0570] <Richard Gibson>
> <@michaelficarra:matrix.org> that was exactly my opinion

I think that's a misunderstanding; the changes would not be from non-throwing to throwing but rather the other way around (such that e.g. `/\@/u` becomes valid)

[05:52:04.0465] <ryzokuken (TC39 üá´üáÆ)>
(possible) hot take: brand checking is orders of magnitude more important (and less icky) than type checking

[05:52:31.0073] <littledan>
> <@usharma:igalia.com> (possible) hot take: brand checking is orders of magnitude more important (and less icky) than type checking

why contrast them? they are both important and just do different things.

[05:52:38.0532] <ryzokuken (TC39 üá´üáÆ)>
oh

[05:52:39.0509] <ryzokuken (TC39 üá´üáÆ)>
true

[05:53:08.0080] <ryzokuken (TC39 üá´üáÆ)>
I guess more accurately: runtime brand checks are important to complement type checks

[05:54:59.0552] <nicolo-ribaudo>
Chris de Almeida (TCQ) Because it's a revoked proxy, so you should not be able to inspect its state

[05:55:02.0866] <nicolo-ribaudo>
Array.isArray does the same

[05:56:17.0012] <Michael Ficarra>
@usharma:igalia.com give me one reason for brand checks

[05:56:58.0896] <ryzokuken (TC39 üá´üáÆ)>
well, you might want to check the "type" of something on runtime? I use code that uses `Array.isArray` all the time?

[05:57:11.0537] <ryzokuken (TC39 üá´üáÆ)>
as do many others I believe

[05:57:13.0758] <littledan>
we're in quite violent agreement about Error.isError returning true for DOMException.

[05:58:56.0950] <Michael Ficarra>
@usharma:igalia.com you should be duck typing, though maybe you need to know whether the object has a magic length property for some reason?

[05:59:13.0448] <ryzokuken (TC39 üá´üáÆ)>
I can give a more specific example from a recent function I wrote but in general when dealing with heterogeneous objects and collections like we do in JS, it's quite useful

[05:59:23.0072] <Michael Ficarra>
like I can see testing for Arrays due to the magic length property and mapped arguments objects because of their magic assignment behaviour

[05:59:44.0014] <Michael Ficarra>
in *general*, you definitely shouldn't be brand checking

[05:59:52.0730] <Michael Ficarra>
those two cases are accounting for language magic

[06:00:17.0081] <ryzokuken (TC39 üá´üáÆ)>
idk what to say... I disagree?

[06:00:35.0696] <ryzokuken (TC39 üá´üáÆ)>
I don't think the stuff I'm writing would be better handled _without_ brand checks

[06:04:32.0613] <Richard Gibson>
> <@michaelficarra:matrix.org> like I can see testing for Arrays due to the magic length property and mapped arguments objects because of their magic assignment behaviour

is there a way to identify a mapped arguments object?

[06:05:01.0824] <ljharb>
> <@gibson042:matrix.org> is there a way to identify a mapped arguments object?

no, this is indeed another missing brand check i seem to always forget about

[06:05:14.0435] <Michael Ficarra>
@ljharb:matrix.org don't you dare

[06:05:15.0775] <ljharb>
> <@gibson042:matrix.org> is there a way to identify a mapped arguments object?

 * no, this is indeed another missing brand check i seem to always forget about. see https://npmjs.com/is-arguments

[06:05:17.0324] <nicolo-ribaudo>
> <@gibson042:matrix.org> is there a way to identify a mapped arguments object?

He said "all _instances_ except for error have a brand check", I found the wording to be carefully chosen :)

[06:05:38.0106] <nicolo-ribaudo>
Can I stop screen sharing?

[06:05:44.0294] <ljharb>
sure, thanks

[06:08:54.0820] <ryzokuken (TC39 üá´üáÆ)>
Michael Ficarra can you expand a bit on "icky"? What's specifically wrong with explicit brand checks apart from just the added cost of an additional static method?

[06:12:28.0950] <Michael Ficarra>
@littledan:matrix.org I think you hit on the key point there: the opposition is to brand checks that are not otherwise justified. Like *all features* we consider, we should require them to have a good reason to exist.

[06:14:47.0592] <Michael Ficarra>
@usharma:igalia.com this is basically "nominal typing > structural typing" but at the term level

[06:24:33.0087] <littledan>
> <@michaelficarra:matrix.org> @littledan:matrix.org I think you hit on the key point there: the opposition is to brand checks that are not otherwise justified. Like *all features* we consider, we should require them to have a good reason to exist.

so the action item is for supporters and opponents to come together and make a shared set of guidelines. I'd prefer an answer which is not, "make sure you sneak in an operation that does a brand check without being just a brand check operation."

[06:25:30.0459] <littledan>
because this is what proposal champions currently have to do! it just papers over the disagreement about whether the brand check is justified.

[06:25:38.0932] <Michael Ficarra>
@littledan:matrix.org how is that a bad situation if that operation has been independently sufficiently justified

[06:25:43.0751] <Michael Ficarra>
* @littledan:matrix.org how is that a bad situation if that operation has been independently sufficiently justified?

[06:26:19.0259] <Michael Ficarra>
wanting the same thing for different reasons is how dispute resolution happens all the time, and it's fine

[06:26:54.0590] <littledan>
it is super confusing; if the objection from person A is "this can't move forward unless it adds a brand check" and person B is simultaneously saying "a brand check is not justified" then the champion ends up finding an *excuse* for a brand check by shaping the API such that it's "natural" to include one, such that independent motivation can be argued for. It's super confusing!

[06:27:22.0739] <littledan>
this is a particularly weird set of disagreements, among the various ones we have. It doesn't amount to a coherent design principle.

[06:27:51.0324] <littledan>
it seems like you have a different set of things you're looking for in "what makes a brand check justified" than ljharb does. Maybe you can work together on a common set of criteria.

[06:28:39.0366] <littledan>
the answer does not need to be that everything has a brand check; we should just find a common answer one way or another

[06:28:51.0702] <Michael Ficarra>
I think the majority of the committee agrees that brand checks are harmful for "normal" code

[06:29:14.0772] <Michael Ficarra>
this Error check was justified for like dev tooling

[06:29:28.0486] <ljharb>
i don't think that's actually true anymore

[06:29:29.0394] <Michael Ficarra>
it would be ideal if it was *less* ergonomic to discourage its use

[06:29:56.0246] <ljharb>
it was certainly true when the committee was 20 people, but we're much larger and have a much more "anchored in userland" set of experience represented than in the past

[06:30:09.0475] <littledan>
so, yes, if we can get consensus among the committee that brand checks are *not* required when making a new type of object with internal slots, then yeah that's a way through

[06:30:27.0372] <littledan>
*if*

[06:31:45.0887] <Michael Ficarra>
@nicolo-ribaudo:matrix.org to be clear, I didn't actually have time to complete my review, but from the review I did do, it was fine

[06:32:14.0636] <littledan>
(not sure why Shu's question was directed specifically at implementers)

[06:40:42.0588] <hax (HE Shi-Jun)>
question: are defer namespace and normal namespace object always distinct? or only distinct when error?

[06:43:21.0097] <Richard Gibson>
> <@haxjs:matrix.org> question: are defer namespace and normal namespace object always distinct? or only distinct when error?

hax (HE Shi-Jun): can you get that on the queue?

[06:44:47.0526] <nicolo-ribaudo>
> <@michaelficarra:matrix.org> @nicolo-ribaudo:matrix.org to be clear, I didn't actually have time to complete my review, but from the review I did do, it was fine

2.7 would be conditinal on editorial reviews

[06:45:03.0669] <nicolo-ribaudo>
> <@haxjs:matrix.org> question: are defer namespace and normal namespace object always distinct? or only distinct when error?

Always distinct because when you create them you don't know yet if the module will error or not

[06:45:50.0260] <hax (HE Shi-Jun)>
> <@gibson042:matrix.org> hax (HE Shi-Jun): can you get that on the queue?

Added.

[06:46:13.0542] <hax (HE Shi-Jun)>
> <@nicolo-ribaudo:matrix.org> Always distinct because when you create them you don't know yet if the module will error or not

Seems reasonable. Thank u!

[06:46:37.0387] <JaseW>
> <@mgaudet:mozilla.org> (Do we have a test262 dashboard that has v8 and sm on it? I have https://test262.fyi/ in my history, but this seems incomplete at the moment)

It's back up fully now https://test262.fyi

[06:47:45.0407] <mgaudet>
:) Still waiting for legacy regexp results tho

[06:50:56.0982] <ptomato>
> <@mgaudet:mozilla.org> :) Still waiting for legacy regexp results tho

a bit weird. this is what it looked like when I loaded it a couple of hours ago:

[06:51:05.0215] <ptomato>
now it's not showing v8 anymore

[06:51:36.0715] <mgaudet>
... huh. (kudos to Canadahonk for building this tho -- its a bit weird it's become load bearing?) 

[06:58:42.0333] <Jack Works>
if the fake module namespace object is created, it will be created each import

[06:59:13.0610] <Jack Works>
this usually happens in getting the ES namespace object of a  CommonJS module

[07:01:37.0495] <Jack Works>
for real ES Modules, webpack just returns the internal module namespace object. for non-strict semantics, (that `import * as ns` is equal to `ns = require()`), it's the same

[07:08:45.0442] <nicolo-ribaudo>
Thanks for investigating!

[07:08:52.0672] <nicolo-ribaudo>
Babel does indeed the same for CJS imports

[07:57:19.0762] <shu>
littledan: sorry wasn't there for the proposal scrub thing. you can always check chromestatus when in doubt

[07:57:29.0433] <shu>
that's usually kept up to date

[08:07:33.0447] <bakkot>
> <@lucacasonato:matrix.org> Sure - that makes sense. But there are use cases where this doesn't work - for example if you have `execute` and `query` functions that both operate on the same database, and you want to limit both together.
> 
> Another common case for this is when you want to limit the number of FS ops, but there are many different ops. For example you want to limit the number of `stat()`, `realpath()` etc all with the same limiter
> 
> Another use case that wrapping is not expressive enough for is if you want to limit the number of open files. Because you "acquire" at every `open` call, but only release once a file handle is explicitly closed.
> 
> Also one could propose that we make `Semaphore` sharable across agents :)

you can have a "wrap" which takes a set of functions and limits concurrency across all of them. prior art: https://www.npmjs.com/package/throat

[08:12:37.0848] <Luca Casonato>
> <@bakkot:matrix.org> you can have a "wrap" which takes a set of functions and limits concurrency across all of them. prior art: https://www.npmjs.com/package/throat

https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$jBz5BAYiJ6u9yymLBwDZTutvHhDE7LZooG0Q36NMxxo?via=mozilla.org&via=matrix.org

[08:13:44.0943] <bakkot>
I don't know what your snippet is supposed to be doing

[08:15:49.0618] <bakkot>
the `wrap` thing I'm suggesting would be like

```
let [limitedExecute, limitedQuery] = AsyncFunction.limitConcurrency(5, [execute, query])
```
or something like that

[08:17:16.0049] <bakkot>
or the api in `throat` gives you a `limiter` you can call repeatedly to draw on the same lock, as in

```
let limiter = limitConcurrency(2);
let limitedExecute = limiter(execute);
let limitedQuery = limiter(query);
```
which also works and is more flexible

[08:34:42.0008] <shu>
> <@gibson042:matrix.org> I think that's a misunderstanding; the changes would not be from non-throwing to throwing but rather the other way around (such that e.g. `/\@/u` becomes valid)

i meant non-throwing to non-throwing, because `\@` already is a literal escape that doesn't throw

[08:35:12.0982] <shu>
or was the scenario you were thinking of in u and v modes only?

[08:42:16.0816] <bakkot>
ljharb: re: `isError`, another thing I forgot to mention is that I am not OK having any more places that replicate `Array.isArray`'s proxy-piercing behavior

[08:42:41.0946] <bakkot>
that may mean that having a static method for this is incompatible with the SES folks' goal of practical membrane transparency

[08:48:25.0347] <shu>
bakkot: say more? is the rationale in the notes?

[08:48:39.0636] <bakkot>
from the last time this was discussed, I think, yes

[08:49:22.0184] <bakkot>
the SES goal is that a membrane for a thing "works like" that thing, as long as you're using the normal interface and not bypassing the object by doing e.g. `Map.prototype.call(membrane)`

[08:50:02.0452] <bakkot>
the way a membrane for a Map works is, its methods are themselves proxied so that they are able to reach into the underlying data structure of the proxy

[08:50:13.0350] <bakkot>
but that doesn't work for static methods, since those come from outside of the membrane

[08:50:21.0320] <shu>
but why aren't you okay with having more places that pierce Proxies?

[08:50:26.0931] <bakkot>
oh

[08:50:35.0250] <bakkot>
couple of things

[08:50:44.0807] <bakkot>
first is just that it's conceptually gross

[08:50:51.0675] <bakkot>
second is that it makes any use of proxies harder

[08:51:12.0898] <bakkot>
for most of the proxy invariants, you can uphold them as you go by imposing them on your target object when they come up

[08:51:29.0387] <bakkot>
but for specifically "is it a function, an object, or an array", you have to decide that up-front

[08:51:37.0214] <bakkot>
the reason "array" is on that list is because `isArray` pierces proxies

[08:51:40.0236] <bakkot>
I don't want to expand that list

[08:52:33.0382] <bakkot>
from the point of view of proxies, there are three kinds of thing in the world; we shouldn't add a forth, especially a fourth which is just some random thing and not as fundamental as the existing three

[08:52:38.0525] <shu>
right, it is just true that it makes use of proxies harder. i'm trying to understand if that's now a general goal you have, or a concrete use case, or that since we have Proxies, we shouldn't go out of our way to make them harder to use

[08:53:07.0473] <shu>
but also this seems like a pretty fundamental disagreement that should've blocked stage 2?

[08:53:34.0709] <bakkot>
I am reluctantly OK with this going forward _without_ the proxy-piercing behavior

[08:53:39.0854] <bakkot>
so I don't think it needs to block stage 2

[08:54:00.0963] <bakkot>
unless someone else says that they are OK with it going forward _only_ with the proxy-piercing behavior, in which case that's unreconcilable

[08:54:04.0831] <shu>
ah, i missed that last part

[08:54:24.0705] <shu>
okay, sg

[08:55:01.0106] <bakkot>
re: goals, I am OK with making proxies harder to use for the benefit of other more frequent features, since I think proxies are a power-user feature already. but the "should it pierce proxies" question is _about_ proxies, so it makes sense to evaluate that question from the perspective of how it affects users of proxies

[08:55:07.0155] <bakkot>
 * re: goals, I am OK with making proxies harder to use for the benefit of other more frequently used features, since I think proxies are a power-user feature already. but the "should it pierce proxies" question is _about_ proxies, so it makes sense to evaluate that question from the perspective of how it affects users of proxies

[08:55:19.0900] <shu>
yes, that sounds reasonable

[08:56:49.0484] <bakkot>
> <@bakkot:matrix.org> unless someone else says that they are OK with it going forward _only_ with the proxy-piercing behavior, in which case that's unreconcilable

my understanding is that the SES people might not be ok with this going forward as a static method without the proxy-piercing behavior but this has not yet been hashed out. also they might not be OK with it going forward as a static method with either proxy-piercing or not-proxy-piercing for different reasons. but I can't speak for them.

[09:06:35.0264] <ljharb>
right - proxy piercing is def something to resolve in stage 2. Your constraint is noted, thanks :-)

[09:45:49.0587] <littledan>
> <@shuyuguo:matrix.org> littledan: sorry wasn't there for the proposal scrub thing. you can always check chromestatus when in doubt

Sorry I should have skipped asking about implementation status anyway‚Äîthose proposals were already too current. Next scrub we will focus on Stage 2 and, if time allows, Stage 1 proposals which haven‚Äôt been discussed in a while.

[10:30:56.0265] <ljharb>
seems like it'd be more effective to start at oldest and move to newer?

[12:58:47.0376] <littledan>
This is what we did within the stage. Probably I should have skipped the more recent ones. But I do think we have more of a responsibility to keep things up to date for higher stage things 

[12:59:19.0181] <littledan>
Also I don‚Äôt want to own scrubs; if someone else wants to run this topic next time, that would be great

[13:01:00.0717] <littledan>
And then other facilitators could try their own prioritization schemes

[13:01:15.0893] <ljharb>
i should be fully at the next two plenaries so i could do one

[13:33:51.0935] <Chris de Almeida>
> <@littledan:matrix.org> Also I don‚Äôt want to own scrubs; if someone else wants to run this topic next time, that would be great

is this a topic that we should just include by default at every plenary?


2024-06-12
[23:50:02.0151] <ptomato>
I'd be happy to do a scrub session as well

[00:09:46.0321] <Richard Gibson>
> <@shuyuguo:matrix.org> or was the scenario you were thinking of in u and v modes only?

right, because of `IdentityEscape[UnicodeMode] :: [~UnicodeMode] |SourceCharacter| but not |UnicodeIDContinue|` (almost all character escapes are valid in legacy mode)

[01:04:39.0809] <nicolo-ribaudo>
I just realised we'll have to figure out the PDF generation story also for the source maps spec üò≠

[01:07:35.0073] <nicolo-ribaudo>
Oh actually just printing to PDF from Firefox is good enough

[01:11:34.0797] <Michael Ficarra>
yeah tell that to Ecma

[01:19:36.0320] <littledan>
we'll all have until December to figure this out; it won't be until next meeting (at the absolute earliest) that we have something that we want to propose to TC39 to propose to the Ecma GA

[01:33:05.0490] <hax (HE Shi-Jun)>
Is the link of slides of current topic available?

[01:33:51.0106] <ryzokuken (TC39 üá´üáÆ)>
hax (HE Shi-Jun) will ask the speaker to post them

[02:00:21.0369] <littledan>
For the ShadowRealms topic, I've inserted the comment that I wanted to make in the notes, which was:

I recommend applying the criterion, ‚ÄúShadowRealms should contain the intersection of what‚Äôs in all conceivable environments‚Äù, which implies that they are missing everything to do with I/O [excluding import()], timers, DOM, etc. https://github.com/tc39/proposal-shadowrealm/issues/398#issuecomment-1939418911


[02:01:23.0061] <waldemar>
Bit-packing breaks down badly once concurrent threads are introduced. C++ found out about this the hard way.

[02:01:47.0322] <littledan>
I agree with the set of things that are spec'd as Exposed=* that Igalia has put together--they seem to be following this principle already.

[02:01:53.0696] <waldemar>
A key requirement is that writes to different variables must be independent.

[02:55:22.0811] <Aki>
> <@nicolo-ribaudo:matrix.org> I just realised we'll have to figure out the PDF generation story also for the source maps spec üò≠

i got u bb üòò

[02:57:00.0618] <Aki>
Does anyone want to volunteer to audit the PDF when it's ready? If a handful of volunteers took a few clauses each (just scrolling through and making sure there's no unfortunate page breaks mostly) then I'd feel a lot more confident with the final product

[02:57:19.0882] <Aki>
it's like 900 pages, my eyes keep glazing over

[03:00:54.0064] <Michael Ficarra>
@akirose:matrix.org I can take a look at it

[03:01:31.0102] <Aki>
Michael Ficarra: cool, i'll let you know when it's ready

[03:01:37.0227] <ryzokuken (TC39 üá´üáÆ)>
I volunteer especially if you also want someone to look through 402

[03:02:02.0603] <Aki>
I'm pretty confident there isn't gonna be stuff randomly missing or cut off. readability is my priority now.

[03:02:19.0195] <Aki>
ryzokuken (TC39 üá´üáÆ): yessss

[03:02:19.0431] <littledan>
could someone who's been in the zoom copy the slide link for the notes?

[03:02:22.0850] <Michael Ficarra>
yeah it's the finding random bits that *aren't* there that's the real hard part

[03:03:35.0479] <sffc>
Can someone share Ben's slides? I have an older link but it's not these latest slides

[03:03:51.0701] <Ashley Claymore>
The link was posted in zoom, but I wasn't in the call when it was posted

[03:03:56.0134] <Ashley Claymore>
so joining now can't see it

[03:04:04.0811] <Ashley Claymore>
if someone who was already in zoom could share that would be great

[03:05:08.0875] <eemeli>
https://docs.google.com/presentation/d/1WCdpcX4IpObi0CD1ftXA9QbZL5RSEGlYGXdqw3EfIdg/

[03:05:13.0875] <Ashley Claymore>
thanks!

[03:17:56.0049] <Duncan MacGregor>
I was going to ask about the [US survey foot](https://www.nist.gov/pml/us-surveyfoot), but apparently that's being retired.

[03:18:28.0368] <Duncan MacGregor>
It's definitely not in the units.xml, nor are any of the other historical survey feet that various countries have specified.

[03:34:55.0857] <Michael Ficarra>
@littledan:matrix.org I disagree that MDN is a good solution for discoverability of these values

[03:35:13.0552] <littledan>
> <@michaelficarra:matrix.org> @littledan:matrix.org I disagree that MDN is a good solution for discoverability of these values

Can you elaborate on that?

[03:38:46.0053] <Michael Ficarra>
an l10n expert may have enough familiarity with cultural differences to know to describe a speed unit as a road travel speed or a volume unit as volume of gasoline, but your average developer might just see something more generic (which has no special handling in their locale) and use that

[03:39:43.0170] <Michael Ficarra>
that's why I think this is great for l10n experts but I just don't see your average dev who has no interest in l10n being all that effective with it

[03:40:09.0597] <Michael Ficarra>
not without having read through 100s of possible special cases from all around the world

[03:40:23.0868] <littledan>
it's hard for me to understand what sort of documentation or API shape might support them better.

[03:40:53.0564] <Michael Ficarra>
for example, I may not think to describe a volume of milk differently than a volume of water because in the US they are measured the same, but in other locales that makes a difference

[03:41:11.0645] <Michael Ficarra>
exactly, I don't know the solution to make this more discoverable either

[03:46:32.0801] <Duncan MacGregor>
In my experience people will use the wrong units or usage contexts, I don't think you can stop that. Luckily the units defined in `units.xml` are fairly limited, and most of them are different enough that people should spot problems fairly quickly. Things like piints and gallons are the exception here because the various types are close enough to be problematic in real world use.

[03:47:55.0173] <ryzokuken (TC39 üá´üáÆ)>
> <@michaelficarra:matrix.org> for example, I may not think to describe a volume of milk differently than a volume of water because in the US they are measured the same, but in other locales that makes a difference

idk about that, I think people tend to do it when designing interfaces...

[03:48:18.0792] <ryzokuken (TC39 üá´üáÆ)>
like if you're writing an app that sells milk across different locales, you might care about it

[03:48:42.0828] <Michael Ficarra>
if you're writing a news article, you may not

[03:50:08.0089] <Duncan MacGregor>
> <@michaelficarra:matrix.org> if you're writing a news article, you may not

Yeah, but if you're writing a news article you'll measure things in Olympic swimming pools, whales, Wales, and other silliness. :-)

[03:50:52.0743] <Michael Ficarra>
"libraries of Congress" is a frequent one in the US...

[03:50:54.0795] <ryzokuken (TC39 üá´üáÆ)>
> <@michaelficarra:matrix.org> if you're writing a news article, you may not

sure but you'd most likely write a static article in a single language

[03:58:42.0874] <Michael Ficarra>
@usharma:igalia.com I don't think that's the direction new articles are moving. NYT very frequently has interactive visualisations to help tell the story. I would not be surprised if they are localising units in their articles.

[04:17:03.0484] <hax (HE Shi-Jun)>
Yeah, I really want ambient AbortSignal!

[04:18:10.0957] <rbuckton>
For the record, I'm very much opposed to it. It looks good on the surface, but has a terrible developer experience for anything more than the simplest base case

[04:18:49.0034] <Rob Palmer>
*** New agenda item ***

Please be aware a new item has been added to the end of the Agenda - last thing tomorrow.

**Discard Bindings update or Stage 2** - by rbuckton 

https://github.com/tc39/agendas/pull/1634

[04:20:10.0439] <hax (HE Shi-Jun)>
> <@rbuckton:matrix.org> For the record, I'm very much opposed to it. It looks good on the surface, but has a terrible developer experience for anything more than the simplest base case

Ok. But I really need some easy way to solve such simplest case ... It's really frustrating that debugging several hours and find that someone just forgotten to pass signal in some inner functions...

[04:21:32.0311] <rbuckton>
> <@haxjs:matrix.org> Ok. But I really need some easy way to solve such simplest case ... It's really frustrating that debugging several hours and find that someone just forgotten to pass signal in some inner functions...

Debugging is even harder when transparent things you can't even trace cause issues in the other direction. Finding a forgotten parameter is easy in comparison.

[04:30:25.0090] <rbuckton>
Adding magical capabilities that do an end run around existing code is a great way to cause headaches for package authors who now start getting issues filed against them because they break unexpectedly where they worked fine before.

[04:31:29.0961] <rbuckton>
Filing issues or sending upstream PRs to packages to add support for cancellation is annoying, yes, but it allows those package authors to consider the ramifications of such a change.

[04:33:25.0168] <hax (HE Shi-Jun)>
I understand the risk, maybe we can find some way to allow package authors opt in such magic, for example, add special symbol to the objects/functions/classes to denote it.

[04:36:33.0196] <rbuckton>
I think it's reasonable for someone to use an `AsyncContext` variable to establish their own magical transparent cancellation token, as it's on a case by case basis. I would still strongly discourage that practice, though. 

[04:40:07.0655] <Ashley Claymore>
> <@rbuckton:matrix.org> Debugging is even harder when transparent things you can't even trace cause issues in the other direction. Finding a forgotten parameter is easy in comparison.

> Debugging is even harder when transparent things you can't even trace

Maybe devtools could help show when Tasks get cancelled, and show the stack of what triggered the cancellation?

[04:40:13.0450] <rbuckton>
I spoke out against transparent cancellation mechanisms when Yehuda suggested them back in ~2017. They overcomplicate everything but 1-1 cancellation interactions. 

[04:40:24.0304] <hax (HE Shi-Jun)>
> <@rbuckton:matrix.org> I think it's reasonable for someone to use an `AsyncContext` variable to establish their own magical transparent cancellation token, as it's on a case by case basis. I would still strongly discourage that practice, though.

We need some balance here, it's too annoying to pass params everywhere for the simple cases.

[04:41:03.0992] <rbuckton>
I don't want cancellation to be the new `this`.

[04:41:35.0298] <rbuckton>
Everyone complains or is confused about `this` in JS.

[04:42:03.0000] <hax (HE Shi-Jun)>
What about other langauges? I remember swift have some implicit cancelation behavior?

[04:42:38.0110] <rbuckton>
I'm not terribly familiar with swift, so I couldn't say.

[04:43:54.0609] <hax (HE Shi-Jun)>
> <@rbuckton:matrix.org> Everyone complains or is confused about `this` in JS.

I don't think it's comparable. Actually `this` will not be passed to function implicitly ?

[04:46:24.0544] <rbuckton>
It's comparable in that you have to do unique things to preserve or drop the `this` context in many cases.

[04:46:27.0286] <Anthony Bullard>
Any sort of implicit or ambient control flow sounds like a debugging nightmare

[04:46:31.0601] <hax (HE Shi-Jun)>
Only global functions will get `this` implicitly ?... oh, non-strict functions...

[04:47:11.0617] <rbuckton>
hax (HE Shi-Jun): you're proving my point. `this` is actually very complex.

[04:47:17.0710] <Anthony Bullard>
But I just woke up, so maybe I should get caught up first

[04:47:25.0712] <rbuckton>
Passing an argument is not complex.

[04:48:34.0995] <rbuckton>
Transparent cancellation is overoptimizing for the simplest case at the cost of the more complex cases that often have more need for an accurate and reliable cancellation mechanism.

[04:48:40.0782] <hax (HE Shi-Jun)>
> <@rbuckton:matrix.org> hax (HE Shi-Jun): you're proving my point. `this` is actually very complex.

I think the complexity is coming from inconsitant , not implicity itself. For example, in many languages, `fn()` equal to `this.fn()` in classes, and it seems ok to developers. 

[04:48:54.0010] <Duncan MacGregor>
Let's just introduce common lisp style "special variables" if we want to thread things through in an ambient fashion. /s

[04:51:10.0939] <rbuckton>
> <@haxjs:matrix.org> I think the complexity is coming from inconsitant , not implicity itself. For example, in many languages, `fn()` equal to `this.fn()` in classes, and it seems ok to developers.

I'm not saying its a 1:1 parallel. I'm saying `this` confusion is a well known issue where simple cases seem fine, but the complex cases you run into are perilously close to the simple case.

[04:52:34.0478] <hax (HE Shi-Jun)>
> <@rbuckton:matrix.org> hax (HE Shi-Jun): you're proving my point. `this` is actually very complex.

Actually, when I research old JS, it seems as the JS 1.0 logic,  JS could choose `fn()` always use `fn.call(this)` semantic everywhere, and I find it could be consistent and no confusion. üòÖ

[04:52:40.0955] <rbuckton>
```js
const counter = { value: 0, increment() { return this.value++; } };
counter.increment(); // simple case
setTimeout(counter.increment, 250); // complex case
```

[04:56:19.0475] <rbuckton>
But back to cancellation. An opt-in mechanism is "fine", i.e. `fetch(url, { signal: "inherit" })`. But that means documenting that native API's should always require user opt-in. A native API designer might choose to ignore that and require opt-out, thus it's a slippery slope.

[05:07:34.0738] <Luca Casonato>
Duncan MacGregor: we do have that already: `String.prototype[Symbol.asyncIterator]`

[05:09:41.0471] <Luca Casonato>
 * Duncan MacGregor: we do have that already: `String.prototype[Symbol.iterator]`

[05:10:39.0286] <littledan>
> <@rbuckton:matrix.org> But back to cancellation. An opt-in mechanism is "fine", i.e. `fetch(url, { signal: "inherit" })`. But that means documenting that native API's should always require user opt-in. A native API designer might choose to ignore that and require opt-out, thus it's a slippery slope.

If we have a simple and regular rule, I'm pretty optimistic that we can document it in https://w3ctag.github.io/design-principles/ and it will be generally followed. There's a lot of effort going into checking for this kind of API consistency these days (as we're seeing through pushback in proposals which don't lend themselves to that)

[05:13:35.0240] <littledan>
> <@rbuckton:matrix.org> Passing an argument is not complex.

it's not about being complex or simple, it's more like "will this actually be adopted". This is the motivation for AsyncContext in general--it sometimes becomes a layering violation to pass things around and through. For example, UI frameworks tend to track the current component/"owner" implicitly in a similar way. It'd be too weird to ask pieces of the component to pass the enclosing component into various APIs as an argument, rather than doing it as a global.

[05:14:18.0599] <littledan>
(I actually think having an ambient AbortSignal will be helpful for web components generally, alongside Signals)

[05:15:32.0210] <Duncan MacGregor>
> <@lucacasonato:matrix.org> Duncan MacGregor: we do have that already: `String.prototype[Symbol.iterator]`

I must be asleep, I had forgotten that existed. :-) I'm not convinced it's really the thing you want because strings like `"üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø"[Symbol.iterator]()` returns more elements than you may have wanted.

[05:16:03.0864] <Luca Casonato>
yeah - probably we also want string iteration on graphemes? :D

[05:17:39.0400] <Duncan MacGregor>
I think so yes.

[05:17:45.0720] <ljharb>
yup - we'd want string `.graphemes()` or something, and that's an intl API (Intl.Segmenter)

[05:18:08.0286] <ljharb>
 * yup - we'd want string `.graphemes()` or something, and that's an intl API (Intl.Segmenter) which makes it tricky to put on String.prototype

[05:19:54.0374] <Duncan MacGregor>
Is that an intl API for historical reasons? Do graphemes alter with locale in some way I haven't considered?

[05:20:13.0395] <ljharb>
they do

[05:20:20.0826] <ljharb>
 * they do (i'm told)

[05:20:47.0007] <Duncan MacGregor>
üò±

[05:21:48.0015] <ljharb>
otherwise we'd have probably had a string .graphemes proposal many years ago :-)

[05:21:55.0129] <littledan>
the definition of grapheme is complicated and changing a bit over time

[05:22:18.0255] <littledan>
I think it wasn't quite that graphemes were already defined in a locale-dependent way but rather that they might be in the future

[05:22:58.0547] <littledan>
something something Indic scripts something

[05:23:25.0576] <rbuckton>
> <@littledan:matrix.org> it's not about being complex or simple, it's more like "will this actually be adopted". This is the motivation for AsyncContext in general--it sometimes becomes a layering violation to pass things around and through. For example, UI frameworks tend to track the current component/"owner" implicitly in a similar way. It'd be too weird to ask pieces of the component to pass the enclosing component into various APIs as an argument, rather than doing it as a global.

.NET does not have transparent cancellation, but developers still use `CancellationToken`. I don't think it's as big of an adoption blocker as you're making it out to be? I don't use `AbortSignal` partly because it's to awkward to use due to its `EventTarget` usage. I _do_ use cancellation though (and `@esfx/async-canceltoken` can theoretically be used in place of an `AbortSignal` in DOM APIs)

[05:23:38.0245] <rbuckton>
> <@littledan:matrix.org> it's not about being complex or simple, it's more like "will this actually be adopted". This is the motivation for AsyncContext in general--it sometimes becomes a layering violation to pass things around and through. For example, UI frameworks tend to track the current component/"owner" implicitly in a similar way. It'd be too weird to ask pieces of the component to pass the enclosing component into various APIs as an argument, rather than doing it as a global.

 * .NET does not have transparent cancellation, but developers still use `CancellationToken`. I don't think it's as big of an adoption blocker as you're making it out to be? I don't use `AbortSignal` partly because it's too awkward to use due to its `EventTarget` usage. I _do_ use cancellation though (and `@esfx/async-canceltoken` can theoretically be used in place of an `AbortSignal` in DOM APIs)

[05:23:40.0753] <ljharb>
hmm, if it doesn't vary by locale *now* then it seems like there still might be value in shipping an invariant one in the language, and if that changes in the future, we could let Intl replace that in situ like it does for toLocaleString?

[05:23:47.0242] <bakkot>
zip üéâ

[05:24:12.0479] <ryzokuken (TC39 üá´üáÆ)>
localized strings cannot be iterated on in a locale-independent way

[05:25:56.0520] <littledan>
FYI "it should be fine to pass the cancel token explicitly" was the argument that Domenic and I had in 2016 (where I was arguing that explicit passing is OK) which led him to withdraw cancel tokens from TC39.

[05:26:43.0243] <littledan>
moving venues was a strange reaction to that argument, as it clearly didn't lead to implicit threading of cancel tokens... I think some misunderstandings happened around that issue.

[05:26:58.0322] <ryzokuken (TC39 üá´üáÆ)>
well, segmenter allows you to iterate on strings/segment them in many different ways beyond just graphemes

[05:27:20.0497] <ljharb>
> <@usharma:igalia.com> well, segmenter allows you to iterate on strings/segment them in many different ways beyond just graphemes

right, but if the only use case i have is to iterate on graphemes, can it be done in a locale-independent way?

[05:27:34.0762] <ryzokuken (TC39 üá´üáÆ)>
I believe there are edge cases 

[05:27:54.0760] <ryzokuken (TC39 üá´üáÆ)>
but let me confirm that 

[05:27:58.0242] <littledan>
> <@ljharb:matrix.org> right, but if the only use case i have is to iterate on graphemes, can it be done in a locale-independent way?

in general, we very much do not expose the "root locale". But with graphemes probably any locale will do for now.

[05:28:24.0677] <littledan>
the "root locale" is a synthetic construct in CLDR that doesn't correspond to anyplace, but other locales are expressed as a diff against it

[05:28:31.0913] <ryzokuken (TC39 üá´üáÆ)>
> <@littledan:matrix.org> in general, we very much do not expose the "root locale". But with graphemes probably any locale will do for now.

`und`

[05:28:54.0747] <ryzokuken (TC39 üá´üáÆ)>
I think it _could_ work? Let me see what implementations think.

[05:29:48.0446] <ryzokuken (TC39 üá´üáÆ)>
both `un` and `und` work here on FF

[05:30:04.0499] <ljharb>
if it can work and not be in intl, i'd be happy to co-champion something like `.codePoints()`, `.codeUnits()`, and `.graphemes()` methods on String.prototype

[05:30:28.0409] <ryzokuken (TC39 üá´üáÆ)>
why not champion an Intl proposal if needed? 

[05:30:30.0292] <ljharb>
 * if it can work and not be in intl, i'd be happy to co-champion something like `.codePoints()`, `.codeUnits()`, and `.graphemes()` methods on String.prototype. only reason i haven't years ago is that i thought it can't work

[05:30:44.0784] <ryzokuken (TC39 üá´üáÆ)>
we'd love to help out if we can üòÑ 

[05:30:47.0827] <Michael Ficarra>
I don't like `.graphemes` living outside Intl but the other two would be great and I would co-champion

[05:30:49.0541] <ljharb>
i have Intl.Segmenter for that already. I need something that's in every environment, and ideally on String.prototype.

[05:30:58.0365] <ryzokuken (TC39 üá´üáÆ)>
ah, sure

[05:31:02.0131] <ljharb>
> <@michaelficarra:matrix.org> I don't like `.graphemes` living outside Intl but the other two would be great and I would co-champion

if it's not locale-dependent, why would it need to be inside intl?

[05:31:12.0224] <Michael Ficarra>
@ljharb:matrix.org it is though

[05:31:21.0716] <littledan>
> <@usharma:igalia.com> both `un` and `und` work here on FF

Are you sure? What is their .resolvedOptions().locale ?

[05:31:28.0732] <ljharb>
i thought that's what ujjwal was just saying it's not.

[05:32:30.0472] <Michael Ficarra>
... where?

[05:32:36.0525] <ryzokuken (TC39 üá´üáÆ)>
ah interesting, it's treating `"und"` as the JS value `undefined`

[05:32:50.0691] <ryzokuken (TC39 üá´üáÆ)>
by which I mean it's falling back to my system locale

[05:32:58.0920] <ryzokuken (TC39 üá´üáÆ)>
 * by which I mean it's falling back to my system locale (en-DK)

[05:33:43.0065] <ljharb>
here: https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$dEtEYuEpnCUpLhfMmu7TbPKuc_4CEDr3LXHI_MkV4Y4?via=matrix.org&via=mozilla.org&via=igalia.com

but that's still unconfirmed, and maybe isn't the case

[05:34:14.0496] <ryzokuken (TC39 üá´üáÆ)>
yeah I'll recheck after today's session and let you know Michael 

[05:35:33.0766] <Michael Ficarra>
uhhh üáπüáº

[05:37:01.0599] <ljharb>
http://unicode.org/L2/L2001/01322r-grapheme_cluster.htm

[05:37:22.0197] <ljharb>
that's super old, did the proposal ever land?

[05:38:38.0160] <Michael Ficarra>
yeah if that exists, then I'd be fine putting it on `String.prototype`

[05:39:02.0399] <Duncan MacGregor>
There's a follow up here https://www.unicode.org/L2/L2023/23140-graphemes-expectations.pdf

[05:39:09.0670] <rbuckton>
Does Intl/CLDR/etc. have something like an "invariant" locale (i.e., for machine readable formatting, not UI formatting)?

[05:39:20.0306] <ryzokuken (TC39 üá´üáÆ)>
> <@rbuckton:matrix.org> Does Intl/CLDR/etc. have something like an "invariant" locale (i.e., for machine readable formatting, not UI formatting)?

yeah `und`

[05:39:32.0260] <ryzokuken (TC39 üá´üáÆ)>
but apparently we handle it quite weirdly?

[05:40:06.0480] <bakkot>
> <@michaelficarra:matrix.org> uhhh üáπüáº

flags are always a single grapheme regardless of whether they render

[05:41:02.0265] <ryzokuken (TC39 üá´üáÆ)>
all nordic flags should be a ligature with a base flag

[05:41:51.0384] <bakkot>
e.g. there is no `ww` flag but it's still one grapheme:
```
[...new Intl.Segmenter('en', {granularity:'grapheme'}).segment('\u{1f1fc}\u{1f1fc}')]
```

[05:41:51.0897] <Michael Ficarra>
even regional flags like üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø?

[05:42:31.0971] <bakkot>
```
[...new Intl.Segmenter('en', {granularity:'grapheme'}).segment('üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø')].length
```
1

[05:42:57.0041] <bakkot>
https://unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table says
> Do not break within emoji flag sequences. That is, do not break between regional indicator (RI) symbols if there is an odd number of RI characters before the break point.


[05:44:28.0355] <bakkot>
and also
> Do not break within emoji modifier sequences or emoji zwj sequences.

which applies to regional flags, probably

[05:45:03.0465] <bakkot>
though I don't know offhand whether something counts as a "emoji zwj sequence" if the sequence is not a recognized emoji

[05:45:31.0000] <Michael Ficarra>
it's only a ZWJ if there's intercalated ZWJs

[05:46:46.0950] <bakkot>
I guess üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø is a emoji modifier sequence not a zwj sequence yes

[05:47:39.0610] <littledan>
> <@usharma:igalia.com> by which I mean it's falling back to my system locale (en-DK)

right, this is generally what Intl does if you ask for a nonexistent locale

[05:47:59.0273] <ryzokuken (TC39 üá´üáÆ)>
no, I tried another and it complained 

[05:48:05.0609] <littledan>
try `(new Intl.NumberFormat("xyz")).resolvedOptions().locale`, same thing

[05:48:21.0106] <ryzokuken (TC39 üá´üáÆ)>
ah wait yes

[05:48:48.0656] <ryzokuken (TC39 üá´üáÆ)>
nvm it was failing for non 2-3 character long locales

[05:49:16.0189] <littledan>
üéâ

[05:49:21.0766] <eemeli>
With `"und"` you're observing fallback to the system locale.

[05:49:29.0352] <Duncan MacGregor>
Amusingly Safari's dev console doesn't handle deletion correctly with flags. "üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø" -> "üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥" -> "üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£" -> "üè¥Û†ÅßÛ†Å¢Û†Å≥" ‚Ä¶

[05:51:26.0266] <nicolo-ribaudo>
(deleted because my code was wrong)

[05:51:33.0035] <jkup>
wait nic i want that link 

[05:51:33.0651] <jkup>
oh ok

[05:52:26.0366] <nicolo-ribaudo>
https://developer.mozilla.org/en-US/docs/Web/API

[05:52:35.0257] <bakkot>
as far as I can tell:
- unicode has a locale-independent grapheme clustering algorithm
- it recommends the use of CLDR's language-specific rules when available
- CLDR does not appear to have implemented any such rules yet, from what I see https://cldr.unicode.org/development/development-process/design-proposals/grapheme-usage

[05:53:04.0368] <ljharb>
ok so then we should definitely have a 402-enhanceable String.prototype method?

[05:53:10.0809] <ljharb>
 * ok so then we should definitely have a future-402-enhanceable String.prototype method?

[05:53:25.0314] <bakkot>
I am not an Intl knower though, so that could be wrong

[05:53:31.0893] <Richard Gibson>
> <@aardvark179:matrix.org> Is that an intl API for historical reasons? Do graphemes alter with locale in some way I haven't considered?

"ch" is logically a single grapheme in the Latin transcription of many Slavic languages, and it seems likely to me that such tailorings will be added to CLDR at some point

[05:53:43.0446] <littledan>
> <@bakkot:matrix.org> as far as I can tell:
> - unicode has a locale-independent grapheme clustering algorithm
> - it recommends the use of CLDR's language-specific rules when available
> - CLDR does not appear to have implemented any such rules yet, from what I see https://cldr.unicode.org/development/development-process/design-proposals/grapheme-usage

lol that matches my understanding as of 2017

[05:54:45.0017] <Duncan MacGregor>
I think a 402 enhanceable method would be a good thing.

[05:55:10.0014] <Chris de Almeida>
folks on the queue, please include a topic description beyond just the letter. üôè

[05:55:16.0856] <ljharb>
(technically all methods are 402-enhanceable, but ofc i meant one explicitly designed for that future purpose)

[05:56:01.0397] <ljharb>
> <@softwarechris:matrix.org> folks on the queue, please include a topic description beyond just the letter. üôè

still can't edit :-(

[05:56:03.0829] <rbuckton>
> <@usharma:igalia.com> yeah `und`

Is `"und"` supposed to be the same regardless of system locale, or is the issue that `Intl` doesn't support that and treats it as an unknown locale?

[05:57:28.0124] <Chris de Almeida>
> <@ljharb:matrix.org> still can't edit :-(

you can add new, and I will rearrange

[05:58:11.0757] <Chris de Almeida>
thank you!

[05:59:04.0846] <bakkot>
we already have a built-in ThrowTypeError function

[05:59:29.0496] <bakkot>
(for `arguments.caller`)

[05:59:49.0753] <ljharb>
asked about that on the queue

[06:00:22.0520] <rbuckton>
I'd really like to be able to use a locale-invariant `Intl.Collator` for sorting inputs reliably in, say, a compiler that runs on different systems all over the world...

[06:00:37.0788] <bakkot>
 * (for `Function.prototype.caller`)

[06:01:21.0585] <bakkot>
though, engines probably want a different error message for `Function.prototype.caller` vs these things

[06:02:31.0308] <hax (HE Shi-Jun)>
Is there any precedent of sharing methods among several classes?

[06:03:06.0341] <rbuckton>
Wouldn't `b.until(a)` be a better replacement for `a.since(b)`?

[06:03:23.0605] <rbuckton>
(no intermediate allocation)

[06:04:59.0275] <bakkot>
> <@rbuckton:matrix.org> Is `"und"` supposed to be the same regardless of system locale, or is the issue that `Intl` doesn't support that and treats it as an unknown locale?

unicode reserves `"und"`

[06:05:12.0846] <bakkot>
> <@rbuckton:matrix.org> Is `"und"` supposed to be the same regardless of system locale, or is the issue that `Intl` doesn't support that and treats it as an unknown locale?

 * unicode reserves `"und"` for unknown

[06:05:13.0134] <rbuckton>
or is `until` clamped?

[06:05:22.0798] <bakkot>
so yes it is the system locale I think

[06:05:34.0897] <rbuckton>
> <@bakkot:matrix.org> so yes it is the system locale I think

Then that's definitely not what I want.

[06:05:38.0471] <nicolo-ribaudo>
> <@rbuckton:matrix.org> Wouldn't `b.until(a)` be a better replacement for `a.since(b)`?

I think they are not equivalent, but I don't know exactly how. I suggest asking in the queue so that Philip can respond 

[06:05:48.0097] <nicolo-ribaudo>
Or maybe ryzokuken (TC39 üá´üáÆ): knows

[06:06:02.0278] <rbuckton>
> <@nicolo-ribaudo:matrix.org> I think they are not equivalent, but I don't know exactly how. I suggest asking in the queue so that Philip can respond

It's more of a curiosity than a concern.

[06:06:14.0071] <bakkot>
ah, though apparently that isn't threaded through to browsers: https://github.com/tc39/ecma402/issues/885

[06:06:39.0032] <littledan>
> <@bakkot:matrix.org> ah, though apparently that isn't threaded through to browsers: https://github.com/tc39/ecma402/issues/885

yes this was a deliberate decision. Unicode recommends against exposing the root locale, and und isn't supposed to be interpreted as the root locale either.

[06:06:41.0097] <Richard Gibson>
> <@haxjs:matrix.org> Is there any precedent of sharing methods among several classes?

arguably those on %TypedArray.prototype%, %GeneratorPrototype%, etc.

[06:06:51.0642] <nicolo-ribaudo>
> <@rbuckton:matrix.org> It's more of a curiosity than a concern.

I'd be concerned if "the intuitive workaround that people are likely to use is wrong" :P

[06:11:07.0121] <rbuckton>
From the temporal docs for `since()`

[06:11:19.0318] <rbuckton>
Per this, they should be equivalent?

[06:12:24.0803] <rbuckton>
 * Per this, they should be equivalent? If not, I'm curious what the outliers are.

[06:12:41.0787] <Richard Gibson>
`a.since(b)` and `a.until(b).negated()` are equivalent, but `a.since(b)` and `b.until(a)` are not

[06:13:01.0041] <ljharb>
ftr H - K have nothing on the queue

[06:13:14.0337] <ljharb>
 * ftr C, and H - K, have nothing on the queue

[06:13:56.0776] <Richard Gibson>
 * `a.since(b, opts)` and `a.until(b, opts).negated()` are equivalent, but `a.since(b, opts)` and `b.until(a, opts)` are not

[06:14:23.0246] <rbuckton>
Ah, the difference is in how the `opts` might be applied?

[06:18:44.0535] <Richard Gibson>
right, starting point is always the receiver so e.g. with largestUnit: "month", March 31 to April 30 is P1M while April 30 to March 31 is -P30D

[06:19:50.0124] <Duncan MacGregor>
Thank you, that really helps clarify things.

[06:21:24.0360] <rbuckton>
> <@gibson042:matrix.org> right, starting point is always the receiver so e.g. with largestUnit: "month", March 31 to April 30 is P1M while April 30 to March 31 is -P30D

That makes sense, but feels odd. It makes me want some kind of normalization to occur, but I'm not sure I feel that strongly about it.

[06:22:36.0729] <Duncan MacGregor>
I think as soon as you allow addition or subtraction of variable sized things like months you'll hit those odd corner cases.

[06:23:36.0222] <rbuckton>
Mostly because this is essentially "date math" but isn't as reliable as actual math.

[06:24:57.0644] <Duncan MacGregor>
Yeah, abandon all hope, there are no monoids here.

[06:25:03.0195] <rbuckton>
I mean, normalization would make it consistent, i.e., swap left and right to ensure they are ordered, perform the necessary math, and then negate the results as needed for the given API and whether a swap occurred.

[06:27:16.0516] <rbuckton>
 * I mean, normalization would make it consistent, i.e., swap left and right as necessary to ensure they are ordered, perform the necessary math, and then negate the results as needed for the given API and whether a swap occurred.

[06:34:25.0490] <nicolo-ribaudo>
Could somebody re-explain me this comment? üòÖ Do database use timezones that are not the timezones we are using in temporal?

[06:34:29.0581] <nicolo-ribaudo>
 * Could somebody re-explain to me this comment? üòÖ Do database use timezones that are not the timezones we are using in temporal?

[06:34:33.0473] <nicolo-ribaudo>
 * Could somebody re-explain to me this comment? üòÖ Do databases use timezones that are not the timezones we are using in temporal?

[06:35:07.0363] <Richard Gibson>
> <@rbuckton:matrix.org> I mean, normalization would make it consistent, i.e., swap left and right as necessary to ensure they are ordered, perform the necessary math, and then negate the results as needed for the given API and whether a swap occurred.

such normalization would not give desired results. actual example (runnable against the polyfill at https://tc39.es/proposal-temporal/ ):

```
Temporal.PlainDate.from("2024-06-30").until("2024-08-31", {largestUnit:"months"}); // => P2M1D
Temporal.PlainDate.from("2024-08-31").until("2024-06-30", {largestUnit:"months"}); // => -P2M
```

[06:35:26.0624] <Richard Gibson>
> <@rbuckton:matrix.org> I mean, normalization would make it consistent, i.e., swap left and right as necessary to ensure they are ordered, perform the necessary math, and then negate the results as needed for the given API and whether a swap occurred.

 * such normalization would not give desired results. actual example (runnable against the polyfill at https://tc39.es/proposal-temporal/ ):

```
Temporal.PlainDate.from("2024-06-30").until("2024-08-31", {largestUnit:"months"});
// => P2M1D
Temporal.PlainDate.from("2024-08-31").until("2024-06-30", {largestUnit:"months"});
// => -P2M
```

[06:37:37.0379] <rbuckton>
That discrepancy is desired?

[06:37:43.0949] <Richard Gibson>
yes

[06:39:11.0278] <rbuckton>
Why is it desirable?

[06:41:07.0427] <nicolo-ribaudo>
Re subtract, even Shu said that it's confusing to remove subtract

[06:41:32.0705] <nicolo-ribaudo>
And this "size reduction" request is coming from him

[06:41:42.0532] <nicolo-ribaudo>
 * Re subtract, even Shu said that it's confusing to remove subtract in his pre-written message to rob

[06:41:45.0545] <nicolo-ribaudo>
 * Re subtract, even Shu said that it's confusing to remove subtract in his pre-written message to Rob

[06:42:20.0709] <jkup>
I sort of read into it as "I understand if you want subtract" but with an undertone of "If you add it back, remove something else" - maybe that's wrong?

[06:42:37.0854] <littledan>
> <@jkup:matrix.org> I sort of read into it as "I understand if you want subtract" but with an undertone of "If you add it back, remove something else" - maybe that's wrong?

I don't think that was necessarily the case

[06:42:47.0849] <nicolo-ribaudo>
We should look at O(n) reductions and not O(1)

[06:44:55.0532] <nicolo-ribaudo>
Would a .symmetricDifference instead of .subtract work, if the concern is hiding negative durations? (even though this should have been discussed in stage 2)

[06:46:58.0479] <nicolo-ribaudo>
Oh, I guess `a.subtract(b).abs()`

[06:46:59.0652] <littledan>
I'm not convinced that making people use negative durations for their subtract replacement more frequently is the best educational device... I don't think that should be a goal

[06:48:52.0872] <Richard Gibson>
> <@rbuckton:matrix.org> Why is it desirable?

because it maps to what people expect when doing calendar operations based on how constraining logic is asymmetric w.r.t to start-of-month vs. end-of-month (going forward, end-of-month to end-of-month has a zero "days" part, but going backward, doing the same thing would impose lossiness by producing the same result for adjacent inputs)

[06:50:52.0962] <nicolo-ribaudo>
Is the way humans think to use "since" for things in the past and "until" for things in the future?

[06:51:16.0490] <ljharb>
yes

[06:51:19.0029] <ljharb>
 * yes, i'd say so

[06:51:27.0762] <ljharb>
 * yes, i'd say so (in english at least)

[06:52:38.0478] <rbuckton>
I'd almost rather have `since` as I'm sure many users would be tripped up by `until` not being symmetric.

[06:52:43.0465] <nicolo-ribaudo>
Somehow it's much harder for me to think about until than since but this is like... not a data point

[06:53:34.0702] <Richard Gibson>
 * such normalization would not give desired results. actual example (runnable against the polyfill at https://tc39.es/proposal-temporal/ ):

```
Temporal.PlainDate.from("2024-06-30").until("2024-08-31", { largestUnit: "months" });
// => P2M1D
Temporal.PlainDate.from("2024-08-31").until("2024-06-30", { largestUnit: "months" });
// => -P2M
```

[06:54:00.0209] <nicolo-ribaudo>
Also, we said we don't want people to have to think about negative durations and now we are saying "get a negative duration and then re-negate it"?

[06:54:08.0482] <Michael Ficarra>
@nicolo-ribaudo:matrix.org many JS programmers are non-native speakers, so it kinda *is* a data point

[06:54:10.0204] <nicolo-ribaudo>
 * Also, we said it's difficult for people to have to think about negative durations and now we are saying "get a negative duration and then re-negate it"?

[06:54:30.0869] <nicolo-ribaudo>
Oh yeah I clearly remember a song we studied in middle school in my english classes that used "since" a lot üòÇ

[06:59:35.0158] <bakkot>
ljharb: I am confused; stage 2.7->3 is pro-forma on the basis of tests being present

[06:59:39.0617] <bakkot>
it is not about anything other than that

[06:59:49.0651] <bakkot>
 * ljharb: I am confused; stage 2.7->3 is pro-forma on the basis of sufficient tests being present

[06:59:55.0251] <bakkot>
Temporal has lots of tests

[07:00:25.0449] <ljharb>
p sure it's not _just_ about tests

[07:00:47.0645] <ljharb>
and either way this agenda item means its tests are no longer correct

[07:02:00.0057] <bakkot>
all changes at stage 3 invalidate some tests and we don't normally bump things down, and in fact the champions have already done the work to make the changes to the tests for these proposed changes

[07:02:17.0290] <bakkot>
and certainly when 2.7 was introduced I understood it to be about tests

[07:02:47.0179] <bakkot>
the purpose is

> Testing and validation. Validate the design of the feature through the development of a rigorous and comprehensive test suite Develop spec-compliant prototypes to validate implementability, as necessary, or aid in test development

and the entrance criteria for 3 is

> The feature has sufficient testing and appropriate pre-implementation experience


[07:03:03.0968] <bakkot>
perhaps Michael Ficarra can speak more to this?

[07:03:06.0018] <ljharb>
and clearly it wasn't sufficient given the vast quantity of normative changes over almost every meeting in the last 4 years.

[07:03:28.0260] <leftmostcat (UTC-7)>
justingrant ptomato I'd definitely be interested in discussing declarative custom time zone behavior further.

[07:03:46.0102] <littledan>
> <@bakkot:matrix.org> and certainly when 2.7 was introduced I understood it to be about tests

I agree. If we bump something down, it would be to Stage 2. There's no extra consensus-seeking step--that was very much a part of the process reform in the first place.

[07:04:04.0855] <ljharb>
ok, then maybe stage 2 is the right call

[07:04:30.0813] <ljharb>
i mainly feel that stage 3 isn't appropriate for Temporal (and really hasn't been in a long time)

[07:04:57.0411] <ljharb>
a big part of the discussion around 2.7 was admittedly my own stated opinion (but i wasn't alone) that "3 means shippable"

[07:05:04.0360] <ljharb>
temporal is not shippable yet.

[07:05:33.0899] <littledan>
I think Temporal is in a similar state to Decorators: right now it deserves to be at Stage 3, though at some point in the past it might've met the criteria for a demotion and re-promotion.

[07:05:39.0236] <bakkot>
3 means appropriate to implement

[07:05:42.0704] <nicolo-ribaudo>
Can we merge the since() and subtract() methods? And they check their receiver

[07:06:22.0011] <ljharb>
implement !== ship unflagged and use in production

[07:06:29.0157] <littledan>
> <@nicolo-ribaudo:matrix.org> Can we merge the since() and subtract() methods? And they check their receiver

if Shu wanted us to merge random things, he would've said so

[07:06:29.0286] <ljharb>
the intention was for 3 to mean the latter

[07:06:48.0086] <nicolo-ribaudo>
> <@littledan:matrix.org> if Shu wanted us to merge random things, he would've said so

I mean since with the sinces and subtract with the subtracts

[07:06:51.0420] <nicolo-ribaudo>
To have ony one .since and one .subtract

[07:06:54.0001] <nicolo-ribaudo>
Like for .valueOf

[07:07:57.0559] <ljharb>
 * the intention was for 3 to mean the latter; perhaps the 2.7 PR should have tweaked the stage 3 wording better, but i didn't realize it said "implement".

[07:11:06.0647] <bakkot>
> <@ljharb:matrix.org> implement !== ship unflagged and use in production

I don't think engines want us to be in charge of deciding whether they can ship an implementation they're happy with, once we've given the signal that it is ready to implement, so I don't think that's really a thing we can dictate

[07:11:18.0887] <ljharb>
it's not about "in charge", it's about the public signal

[07:11:46.0646] <ljharb>
a lot of the 2.7 discussion was about precisely that - that stage 3 sends the signal that it's ok to use it in production and that it's ok for it to be shipped unflagged. they can do whatever they want regardless, but the signal matters

[07:11:53.0781] <ljharb>
and temporal has had an inaccurate signal for 4 years

[07:12:25.0733] <bakkot>
the only signal relevant to whether you can use something in production is whether it is in the engines that you support

[07:13:06.0608] <ljharb>
that's wildly incorrect, given the existence and usage of polyfills

[07:13:33.0584] <ljharb>
and, not every engine/implementation is always in this room. the stage is a signal to them, too.

[07:13:56.0606] <bakkot>
you can use a polyfill for a feature which has never even been proposed if you want to? I don't know what the relevance of "polyfills exist" is to this

[07:35:51.0870] <shu>
> <@jkup:matrix.org> I sort of read into it as "I understand if you want subtract" but with an undertone of "If you add it back, remove something else" - maybe that's wrong?

no, didn't intend that subtext

[07:36:39.0220] <shu>
the undertone was more like "i understandable, on a case by case basis, if some should be added back. but if too many are added back then we have a problem again"

[07:36:46.0624] <shu>
 * the undertone was more like "it is understandable, on a case by case basis, if some should be added back. but if too many are added back then we have a problem again"

[07:45:11.0271] <Christian Ulbrich>
https://www.youtube.com/watch?v=hnpILIIo9ek

[07:45:30.0392] <Christian Ulbrich>
Or: head over to: https://tcq.staging.tcq-reloaded.tcq.ninja to see tcq-reloaded in action.

[07:47:33.0289] <Christian Ulbrich>
For those, that are interested, the PR is https://github.com/zalari/tcq/pull/7 , it is not persistent, i.e. whenever I redeploy, everything is gone, because I need to write additional adapters. Feedback on above PR is highly appreciated. I have no clue, what the perf requirements for TCQ are, it is a very small VM running on AWS Fargate.

[07:51:29.0249] <Christian Ulbrich>
I have created a meeting -> https://tcq.staging.tcq-reloaded.tcq.ninja/meeting/gMqy for which, Rob Palmer davidenke and Chris de Almeida are chairs, so feel free to play around.

[07:55:46.0240] <Michael Ficarra>
for those of us walking to the FF speaker dinner from kamppi metro, meet at the South building entrance in like 10 minutes?

[07:56:56.0342] <Michael Ficarra>
it's a 26min walk

[07:57:18.0126] <ljharb>
> <@bakkot:matrix.org> you can use a polyfill for a feature which has never even been proposed if you want to? I don't know what the relevance of "polyfills exist" is to this

web compat makes them entirely relevant.

[08:02:08.0385] <littledan>
> <@shuyuguo:matrix.org> the undertone was more like "i understandable, on a case by case basis, if some should be added back. but if too many are added back then we have a problem again"

With the results today, are we in that ‚Äúproblem‚Äù state (not yet removing minus or since; not merging toJSON or valueOf yet)?

[08:03:42.0704] <shu>
> <@littledan:matrix.org> With the results today, are we in that ‚Äúproblem‚Äù state (not yet removing minus or since; not merging toJSON or valueOf yet)?

i'm working through the notes still, but by state you mean items A-L excluding D, E, and F?

[08:04:50.0220] <shu>
i imagine the only way to tell is to implement the removals and see, but on paper it looks like a big improvement

[08:05:50.0560] <littledan>
> <@shuyuguo:matrix.org> i'm working through the notes still, but by state you mean items A-L excluding D, E, and F?

Yes

[08:07:48.0610] <ryzokuken (TC39 üá´üáÆ)>
> <@michaelficarra:matrix.org> for those of us walking to the FF speaker dinner from kamppi metro, meet at the South building entrance in like 10 minutes?

We already went past that

[08:07:58.0886] <ryzokuken (TC39 üá´üáÆ)>
At the Fazer cafe now

[08:08:05.0051] <ryzokuken (TC39 üá´üáÆ)>
It's on the walk there 

[08:08:41.0063] <shu>
have a good dinner everyone

[08:40:46.0194] <ptomato>
> <@rbuckton:matrix.org> I'd almost rather have `since` as I'm sure many users would be tripped up by `until` not being symmetric.

rbuckton: I'm not sure if this was later answered by anyone because there's a long scrollback that I wasn't keeping up with during the presentation; but `since` is equally asymmetric as `until` is

[08:42:26.0700] <ptomato>
also, I'd have to double-check to make sure I'm 100% right about this, but `a.since(b)` is equal to `b.until(a)`; it's only if you pass `a.since(b, opts)` and `b.until(a, opts)` where `opts` is not the default, that they are asymmetric. the default options don't let you run into calendar math, and calendar math is where the asymmetry occurs

[08:58:47.0512] <rbuckton>
> <@pchimento:igalia.com> rbuckton: I'm not sure if this was later answered by anyone because there's a long scrollback that I wasn't keeping up with during the presentation; but `since` is equally asymmetric as `until` is

Yes, that's the reason I feel both should exist. They're individually asymmetric, but since and until are symmetric with each other. 

[10:39:55.0840] <bakkot>
> <@ljharb:matrix.org> web compat makes them entirely relevant.

I don't think users can ever rely on a feature being stable before it is both implemented _and shipped_ in browsers. to give a concrete example, groupBy was stage 3, and we were all happy with the design, but we discovered after shipping that it needed to change. I don't see how the existence of polyfills has any relevance to that.

[10:40:21.0668] <bakkot>
so I don't think it makes sense to have a specific stage to indicate "you can rely on this in prod". the only signal of that is "is it shipped in browsers".

[10:40:45.0621] <bakkot>
> <@ljharb:matrix.org> web compat makes them entirely relevant.

 * I don't think users can ever rely on a feature being stable before it is both implemented _and shipped_ in browsers. to give a concrete example, groupBy was stage 3, and we were all happy with the design, but we discovered after shipping that it needed to change. we could not have reasonably learned that before shipping. I don't see how the existence of polyfills has any relevance to that.

[10:41:07.0162] <bakkot>
users should expect that any proposal might change prior to it being shipped

[10:41:10.0791] <ljharb>
i think the qualitative difference is the window. groupBy was only shipped for a very brief time

[10:41:30.0361] <ljharb>
i agree users should expect that. i'm saying that "stage 3" is what they DO expect indicates it.

[10:41:46.0311] <ljharb>
we can't just stick our heads in the sand and pretend users only think about things the way they "should"

[10:45:38.0402] <bakkot>
I don't think we can actually do anything about that though? we can't make them have different standards for relying on things

[10:45:51.0304] <bakkot>
redefining terms won't change what their thresholds actually are

[12:15:47.0272] <ljharb>
what we can do is adapt our meanings/signals to match their expectations. and their expectation is that "stage 3 means i can use it"

[12:16:11.0122] <ljharb>
iow just like the spec caves to web reality, the process should do the same to ecosystem reality.

[12:21:50.0805] <bakkot>
people don't interpret stage 3 as "i can use it" because they like the number 3, they interpret it that way because of what it actually signifies

[12:22:08.0794] <bakkot>
redefining terms will not cause them to start caring about different things

[12:25:21.0760] <Chris de Almeida>
I can't help but feeling there's some degree of hindsight bias involved

[12:37:29.0493] <ljharb>
i agree, i'm not saying we redefine terms. i'm saying that what stage 3 actually signifies in practice is "i can use it", not "browsers can implement it", which is why i think temporal probably doesn't belong in stage 3. because nobody's close to being able to use it yet.

[13:46:56.0185] <littledan>
We have been purposely refining the meaning of Stage 3 over time, eg recently adding the test requirement, in order to reinforce its rigor. It would be reasonable to consider further changes, eg ‚Äúif a proposal has recently changed it shouldn‚Äôt be Stage 3 for a bit‚Äù, but that would be a new, different process idea that we could consider for consensus in general; it is kinda ad hoc to advocate that we should enforce that requirement just for a particular proposal. 

[14:29:24.0190] <ljharb>
that was the precise suggestion you made for `global`, if you recall.


2024-06-13
[22:58:52.0176] <ljharb>
 * this was the precise suggestion you made for `global`, if you recall.

[00:00:42.0938] <littledan>
global was in a known web-incompatible state with no changes publicly proposed over the course of a year, so I think that's different. We don't have particular known issues for Temporal, and definitely not with respect to web compatibility.

[00:02:07.0261] <littledan>
(or did I say something about what should happen after the new name was proposed? I don't remember making that suggestion at that time.)

[00:02:16.0427] <ljharb>
very true that there's no web compat concern; it's not exactly the same

[00:02:49.0057] <ljharb>
but what i remember is that you argued (a position i disagreed with at the time, but have come around on and now agree with) that it should have dropped to stage 2 since the name was going to chnage

[00:02:51.0214] <ljharb>
 * but what i remember is that you argued (a position i disagreed with at the time, but have come around on and now agree with) that it should have dropped to stage 2 since the name was going to change

[00:03:30.0814] <littledan>
right, so that's a case of a change that needs to happen for something to be shippable, whereas we're not aware of changes that need to happen for Temporal for it to be shippable

[00:03:50.0631] <ljharb>
wasn't that the entire agenda item? it was too big to be shippable.

[00:04:31.0002] <littledan>
and we addressed it, we hope (modulo implementer feedback, which makes sense to seek during Stage 3)

[00:05:20.0826] <ljharb>
right. it's the "we hope" part that's been proven false in nearly every plenary for the last 4 years, and i'd think that over 10 times bitten should at least produce once shy

[00:06:14.0856] <ljharb>
 * right. it's the "we hope" part that's been proven false in nearly every plenary for the last 4 years, and i'd think that (likely well) over 10 times bitten should at least produce once shy

[00:06:55.0454] <littledan>
"once shy"? 

[00:07:24.0741] <ljharb>
lol i was trying to paraphrase "once bitten twice shy", i've been up for nearly 20 hours so it might not make sense

[00:07:30.0694] <Chris de Almeida>
once bitten, twice shy
idiom
‚Äîused to mean that a person who has failed or been hurt when trying to do something is careful or fearful about doing it again

[00:08:50.0414] <Chris de Almeida>
if the corrective action suggested here is to more liberally request consensus to regress proposals when it seems they should be regressed, that seems reasonable to me

[00:09:18.0245] <ljharb>
exactly that. which is something we've discussed multiple times in recent years, like with import attributes for example

[00:09:35.0791] <ljharb>
(to pretty consistently positive response, iirc)

[00:10:00.0841] <littledan>
so, for import attributes, it was retracted because a change was in progress, which is more similar to the globalThis case.

[00:10:04.0201] <ljharb>
the concept of a "scoped demotion" helped make that palatable, i think

[00:10:07.0683] <nicolo-ribaudo>
I wonder if the proposed action would have been "lets split the proposal in two and bring this part back to stage 2", rather than "lets remove this part", the stability impression would have been different

[00:11:02.0233] <littledan>
it was unfortunate that we didn't permit ourselves a scoped demotion. I think the committee agreed to the demotion partly because the strongly opinionated people agreed to scoping, even if the committee as a whole wasn't going to commit to scoping.

[00:11:02.0481] <ljharb>
or alternatively, at this point we could move it back to ~2 with a scope of "no design changes, only implementation-driven ones" - which sounds like stage 3, but, because of the scale of Temporal might be worthy of some flexibility

[00:11:22.0532] <littledan>
but there's no design changes proposed here, so I'm not sure what the criteria would be later for re-promotion

[00:11:35.0660] <ljharb>
dropping calendar and timezone were pretty massive design changes

[00:11:47.0310] <littledan>
right, but we don't have any *further* changes proposed

[00:11:58.0998] <ljharb>
oh sure. that's been the case after every plenary tho, until the next one

[00:12:23.0873] <littledan>
when import attributes were re-promoted, there was the idea raised, "even though we agree on these changes, should we wait longer to let things settle?" we decided no wait was needed, and that turned out just fine.

[00:12:57.0858] <ljharb>
since we won't have time to discuss temporal's stage this meeting, i guess we'll see either way :-)

[00:13:17.0118] <ljharb>
but if more changes come back in july, i think we should seriously consider demoting it until changes stop coming

[00:13:26.0073] <littledan>
> <@ljharb:matrix.org> since we won't have time to discuss temporal's stage this meeting, i guess we'll see either way :-)

we could have time--I agreed to the chair's request to cut down the signals topic to 30 minutes to permit an overflow topic on this subject.

[00:13:48.0308] <ljharb>
perhaps yall can indeed discuss it; i'm going to bed in an hour or so and won't be present after that

[00:13:55.0245] <littledan>
ah OK good to know

[00:14:07.0289] <ljharb>
 * perhaps yall can indeed discuss it; i'm going to bed in an hour or so and won't be present after that. i sleepy.

[00:14:47.0651] <ljharb>
my opinion is clear tho so i don't necessarily need to be there

[00:15:49.0453] <ljharb>
 * (presumably) my opinion is clear tho so i don't necessarily need to be there

[00:16:32.0690] <littledan>
I think we've made the points back and forth here; I'm not sure what more we should discuss

[00:17:25.0873] <ljharb>
it'd only be worth discussing if there's a decent chance of a demotion, otherwise it's probably more efficient to just wait til july and revisit if there's more changes

[00:17:32.0176] <ljharb>
 * it'd only be worth discussing imo if there's a decent chance of a demotion, otherwise it's probably more efficient to just wait til july and revisit if there's more changes

[00:36:51.0934] <Michael Ficarra>
maybe I wasn't clear?

[00:37:31.0018] <Michael Ficarra>
the question is NOT about whether there are only editorial changes remaining, it is about whether the remaining changes are considered "major", which is subjective

[00:37:55.0727] <rbuckton>
I understood "High level APIs and Syntax" to mean the rough design we want to proceed with. We've never been so strict for stage 2.

[00:38:08.0224] <rbuckton>
"Placeholders and TODOs are acceptable"

[00:38:58.0249] <rbuckton>
The description in the Purpose column describes the kinds of things Waldemar is discussing

[00:39:10.0586] <ptomato>
there have been proposals entering stage 2 with entire methods stubbed out

[00:39:50.0957] <littledan>
re Shane's topic: I think we *do* approve slideshows: we advance things based on conceptual agreements, which I think we have here. Stage 2.7 is where we look for the spec to be basically perfect.

[00:40:47.0295] <Michael Ficarra>
@littledan:matrix.org even stage 4 is advanced on conceptual agreements

[00:41:25.0501] <Chris de Almeida>
> <@michaelficarra:matrix.org> the question is NOT about whether there are only editorial changes remaining, it is about whether the remaining changes are considered "major", which is subjective

agree, and I disagree with the characterization that we are having a meta discussion on process.  we are talking about this proposal and what appear to be blocking possibly based on stage 2.7 or 3 entrance criteria rather than stage 2

[00:41:28.0869] <Michael Ficarra>
the editor group often finds things *in the 262 spec document* that don't align to what we conceptually agreed to and we just fix them and notify committee at the next plenary

[00:42:43.0484] <Michael Ficarra>
part of the editor's job responsibilities is going back through consensus (written and in our memory) to confirm that the document aligns with it

[00:43:04.0866] <Rob Palmer>
Purpose of Stage 2:

- Refining the solution.
- Work out minor details such as ordering of observable effects, handling of invalid inputs, API names, etc.
- Receive and address spec text reviews from the assigned reviewers and the appropriate editor group
- Produce experimental implementations such as loosely-correct (not for production use) polyfills to aid in validating the design and exploring the details
- Investigate integration with relevant host APIs, if necessary

[00:45:54.0534] <rbuckton>
If we agree this is the right direction to go for Decimal, then Stage 2 seems perfectly reasonable. It means we've committed to that direction and now we want to flesh out the details. 

[00:49:40.0321] <Chris de Almeida>
more greatest hits from the process doc, re: stage 2 status

> The committee has chosen a preferred solution or solution space, but the design is a draft and may still change significantly.

[00:50:30.0324] <littledan>
If we overflow, please feel free to take time away from Signals (even if it means we don't get to it at all this meeting)

[00:50:46.0338] <littledan>
 * If Decimals overflow, please feel free to take time away from Signals (even if it means we don't get to it at all this meeting)

[00:50:58.0400] <Ben>
The DurationForrmat update is not going to even come close to filling its timebox, so that clears up time this afternoon

[00:51:11.0718] <Ben>
(I've reached out to Ujjwal about this)

[00:51:22.0163] <nicolo-ribaudo>
Duncan MacGregor When comparing floats there is the same beahvior: `1 < NaN` is false, `1 > NaN` is false, and `1 == NaN` is false, so `compare` cannot return neither -1, nor 0, nor 1.

[00:53:39.0895] <mgaudet>
I'd like us to not over-rotate on API design based on the temporal experience

[00:54:37.0853] <nicolo-ribaudo>
Chrome is working on shipping the web neural network API, that has all the comparisons :)

[00:55:19.0636] <nicolo-ribaudo>
(just to put feedback on Chrome's code size into perspective)

[00:55:50.0568] <waldemar>
If we don't provide an equals method, users will test for = and ‚â† via compare(‚Ä¶) == 0 and compare(‚Ä¶) != 0 respectively. This produces incorrect results.

[00:56:01.0825] <rbuckton>
Stage 1 is scouting the terrain and coming up with a battle plan.
Stage 2 is starting the long march to battle and preparing fortifications.
Stage 2.7 is checking your gear before the battle starts.
Stage 3 is when you see how much of your plan survives contact with the enemy.
Stage 4 is the parade.

[00:56:01.0878] <Duncan MacGregor>
> <@nicolo-ribaudo:matrix.org> Duncan MacGregor When comparing floats there is the same beahvior: `1 < NaN` is false, `1 > NaN` is false, and `1 == NaN` is false, so `compare` cannot return neither -1, nor 0, nor 1.

Ah right. Too used to comparison methods which return an int and so *cannot* return NaN. It is also worth noting that things like `Array.prototype..sort()` turn a Nan value as +0.

[00:56:57.0827] <nicolo-ribaudo>
> <@aardvark179:matrix.org> Ah right. Too used to comparison methods which return an int and so *cannot* return NaN. It is also worth noting that things like `Array.prototype..sort()` turn a Nan value as +0.

The .sort behavior seems good with the .compare behavior: "I don't know how to compare these two things, so I don't shuffle them around"

[00:58:49.0952] <Chris de Almeida>
Eemeli's comment makes it sound like it's a foregone conclusion that a new primitive is not possible

[00:59:00.0321] <Chris de Almeida>
facts?

[00:59:17.0058] <ljharb>
that is browsers' position as i understand it, yes

[00:59:36.0293] <ljharb>
(which impacts both R&T and Decimal)

[01:00:11.0509] <nicolo-ribaudo>
I understand browsers position as "a primitive only makes sense if we see proof that it's actually going to be widely used", and I hope that decimal objects getting adoption will fulfill that

[01:00:19.0888] <Duncan MacGregor>
> <@nicolo-ribaudo:matrix.org> The .sort behavior seems good with the .compare behavior: "I don't know how to compare these two things, so I don't shuffle them around"

Yeah seems consistent, and maps reasonably to IEEE spec.

[01:01:08.0371] <Rob Palmer>
I do not see any route to convincing browsers that the juice is worth the squeeze on Decimal, other than the incremental route of proving it out first in API form.

[01:01:30.0394] <ljharb>
it can be proved out, though, without being in the spec - that's what npm is for

[01:01:32.0103] <Michael Ficarra>
> <@nicolo-ribaudo:matrix.org> The .sort behavior seems good with the .compare behavior: "I don't know how to compare these two things, so I don't shuffle them around"

this would be an inconsistent comparator though: https://tc39.es/ecma262/#consistent-comparator

[01:01:53.0283] <Chris de Almeida>
> <@robpalme:matrix.org> I do not see any route to convincing browsers that the juice is worth the squeeze on Decimal, other than the incremental route of proving it out first in API form.

precedent?

[01:02:10.0542] <ljharb>
this constraint on primitives is pretty new so i'm not sure there is any precedent

[01:03:13.0461] <nicolo-ribaudo>
Ugh, that's annoying. In wonder wether we could extend the definition of consistent comparators to include "some values can consistently not be compared with any other value"

[01:03:44.0863] <Chris de Almeida>
it would be nice to hear from vendors if that sort of signal would be sufficient to convince

[01:03:53.0303] <nicolo-ribaudo>
Because, NaN returned from .compare happens if and only if one of the arguments is a NaN

[01:04:13.0943] <nicolo-ribaudo>
I would have to check if implementations in practice are already doing it

[01:04:26.0280] <Richard Gibson>
very much related: https://matrix.to/#/!wbACpffbfxANskIFZq:matrix.org/$oOM8aZZATkGRuYJ1QzLp2veLMwV3yXlD1275Z1d6nBs?via=matrix.org&via=mozilla.org&via=igalia.com
> you can get consistent sorting like `newPages.sort( ( a, b ) => (isNaN(a.index) ? Infinity : a.index) - (isNaN(b.index) ? Infinity : b.index) )`, but I don't think there's any way to avoid some kind of surrogate value

[01:04:44.0322] <nicolo-ribaudo>
Infiniti - Infinity is NaN, right?

[01:04:49.0147] <nicolo-ribaudo>
 * Infinity - Infinity is NaN, right?

[01:04:56.0256] <Richard Gibson>
right

[01:05:03.0815] <Chris de Almeida>
 * it would be nice to hear from vendors if that sort of signal <del>would</del> might be sufficient to convince

[01:05:13.0245] <Duncan MacGregor>
Yes

[01:05:57.0539] <Richard Gibson>
which is treated as zero, i.e. same-sign infinities are not differentiated by that kind of sorting

[01:06:31.0319] <waldemar>
> <@softwarechris:matrix.org> agree, and I disagree with the characterization that we are having a meta discussion on process.  we are talking about this proposal and what appear to be blocking possibly based on stage 2.7 or 3 entrance criteria rather than stage 2

That's an unfair characterization. A lot of folks making this claim are making assumptions about what's currently working and what isn't working in the spec.

[01:06:35.0731] <eemeli>
> <@softwarechris:matrix.org> Eemeli's comment makes it sound like it's a foregone conclusion that a new primitive is not possible

I meant that only in the current specific context of Decimal as a class being proposed to Stage 2.

[01:07:45.0433] <Duncan MacGregor>
So the JVM's position on this is
> Compares two Double objects numerically. This method imposes a total order on Double objects with two differences compared to the incomplete order defined by the Java language numerical comparison operators (<, <=, ==, >=, >) on double values.
A NaN is unordered with respect to other values and unequal to itself under the comparison operators. This method chooses to define Double.NaN to be equal to itself and greater than all other double values (including Double.POSITIVE_INFINITY).
Positive zero and negative zero compare equal numerically, but are distinct and distinguishable values. This method chooses to define positive zero (+0.0d), to be greater than negative zero (-0.0d).
This ensures that the natural ordering of Double objects imposed by this method is consistent with equals; see this discussion for details of floating-point comparison and ordering.

[01:09:27.0837] <Duncan MacGregor>
It ends up putting all the doubles at the end of a sorted array, which also seems to be what I see in `Array.prototype.sort()` implementations.

[01:09:57.0950] <Chris de Almeida>
> <@waldemarh:matrix.org> That's an unfair characterization. A lot of folks making this claim are making assumptions about what's currently working and what isn't working in the spec.

you're right -- and the purpose of the discussion was to clarify

[01:10:34.0362] <waldemar>
The spec is not even in a good enough state for Shane to be able to read and understand it.

[01:10:47.0536] <rbuckton>
Could we add Decimal as a class and later add a primitive version for it if we block off relevant functionality to allow for it in the future? i.e., you have to write `new Decimal()` for now while `Decimal()` and `Decimal.prototype.valueOf()` throw, and later we add decimal primitives treating `new Decimal` as the boxed primitive version? That would give us the opportunity to ship it and prove out its utility in the ecosystem. IIRC, shu's concern was that BigInt added too much complexity for something whose only significant use ended up being for unscrupulous cryptocurrency mining.

[01:11:38.0461] <littledan>
waldemar: What do you think about "conditional Stage 2" on fixing those spec issues?

[01:11:53.0038] <waldemar>
> <@littledan:matrix.org> waldemar: What do you think about "conditional Stage 2" on fixing those spec issues?

That's fine by me.

[01:12:45.0150] <waldemar>
I *want* this to go to stage 2. It's just not ready at the moment, but it's getting there quickly.

[01:12:51.0092] <littledan>
> <@waldemarh:matrix.org> That's fine by me.

sffc: ?

[01:13:29.0545] <Duncan MacGregor>
I'm not convinced by the argument that Decimal is the answer to solving rounding issues seen by inexperienced developers, but I do understand that Decimal is a good answer to a particular set of problems.

[01:13:42.0280] <Duncan MacGregor>
 * I'm not convinced by the argument that Decimal is a *good* answer to solving rounding issues seen by inexperienced developers, but I do understand that Decimal is a good answer to a particular set of problems.

[01:14:45.0491] <littledan>
I think the existing libraries have tons of downloads, but maybe that is partly because of people depending on them when they don't really need them

[01:15:08.0559] <hax (HE Shi-Jun)>
About the diff with Decimal128 and Temporal, I think it's how people expect. For Decimal128 in non-primitive form, people will say: WTF! For Temporal, people will say: ok, it at least much much better than Date!

[01:15:26.0336] <Chris de Almeida>
`13,603,794` weekly downloads is tons or no?

[01:15:39.0403] <ljharb>
looking around on npm, i do see https://www.npmjs.com/package/bignumber.js which has 11m downloads, which is a pretty decent number

[01:15:42.0994] <jkup>
https://www.npmjs.com/package/decimal.js, https://www.npmjs.com/package/big.js, https://www.npmjs.com/package/bignumber.js

[01:15:46.0636] <sffc>
The spec intelligibility issues are not egregious enough to get in the way of Stage 2 for me; I think the committee sending a positive signal by promoting to Stage 2 is more important at this point in time

[01:15:46.0735] <jkup>
50mil

[01:16:00.0499] <ljharb>
and indeed decimal.js has 17 million

[01:16:26.0026] <ljharb>
so that's a great indicator, thank you. (i'd still want the proposal readme to have a list ofc)

[01:16:40.0452] <littledan>
the polyfill is not being developed in a way where it intends to compete with other decimal libraries

[01:17:25.0771] <ljharb>
oh sure, i don't care that a specific package has low usage, to be clear, i just was not aware that any were significantly used; those 3 high-usage examples certainly addresses the "demand" point for me

[01:17:26.0543] <Luca Casonato>
> <@littledan:matrix.org> the polyfill is not being developed in a way where it intends to compete with other decimal libraries

can you elaborate this? this seems like a statement that needs more explanation

[01:17:42.0083] <ljharb>
 * oh sure, i don't care that a specific package has low usage, to be clear, i just was not aware that any were significantly used; those 3 high-usage examples certainly addresses the "demand" point for me (but still not the "carries its weight" part)

[01:17:46.0261] <Chris de Almeida>
might need to invite `MikeMcl` to the chat at some point

[01:17:59.0598] <nicolo-ribaudo>
The goal of the polyfill is to have spec-compliant semantics, not to be an optimized production-ready implementation

[01:18:05.0306] <nicolo-ribaudo>
Same for temporal for example

[01:18:20.0847] <nicolo-ribaudo>
 * The goal of the polyfill is to have spec-compliant semantics, not to be an optimized production-ready implementation Luca Casonato 

[01:18:23.0084] <rbuckton>
Lets just add a single new primitive type that covers flexible user-defined data types and operator overloading and just base all other new primitives on that. 

[01:18:42.0909] <nicolo-ribaudo>
Let's call this primitive "object" :)

[01:18:46.0210] <Luca Casonato>
oh i misread polyfill as spec ü§¶‚Äç‚ôÇÔ∏è

[01:19:25.0099] <Luca Casonato>
i read "this spec is not being developed in a way where it intends to compete with other decimal libraries"

[01:19:33.0730] <rbuckton>
Honestly, this was one of the things I wanted to do with my version of the `struct` proposal prior to Shu's version.

[01:19:37.0441] <Duncan MacGregor>
So I can say that operator overloading is a significant implementation overhead in Ruby, and we try very hard to boil it away as much as we can. It's tempting, but it has real downsides.

[01:19:47.0588] <rbuckton>
I would have just called the primitive `"value"` 

[01:20:07.0929] <ljharb>
"tempting but has real downsides" is an understatement in my experience on both parts

[01:20:19.0762] <Duncan MacGregor>
:-)

[01:20:27.0414] <Duncan MacGregor>
 * ü§£

[01:20:35.0757] <nicolo-ribaudo>
> <@aardvark179:matrix.org> So I can say that operator overloading is a significant implementation overhead in Ruby, and we try very hard to boil it away as much as we can. It's tempting, but it has real downsides.

It would probably have to be lexically scoped to restrict the overhead to where you need it

[01:20:37.0199] <ljharb>
 * "tempting but has real downsides" is an understatement in my experience on both parts in any language i've used with the feature

[01:20:53.0309] <ljharb>
i suspect that would remove a lot of the downsides

[01:22:19.0965] <Duncan MacGregor>
> <@nicolo-ribaudo:matrix.org> It would probably have to be lexically scoped to restrict the overhead to where you need it

But then you can end up with weird corner cases because you're code does one thing while a library does another.

[01:23:44.0255] <rbuckton>
Question to implementers, when `bigint` was added along with its necessary operator overloads, how much of an impact on performance did that have for other javascript code that didn't make use of `bigint`?

[01:23:46.0448] <keith_miller>
Scoped overloads seems like a footgun how does a library support overloading in that case?

[01:24:12.0569] <ljharb>
i suppose it'd provide exports that can be "activated" inside a scope with syntax

[01:24:17.0660] <keith_miller>
> <@rbuckton:matrix.org> Question to implementers, when `bigint` was added along with its necessary operator overloads, how much of an impact on performance did that have for other javascript code that didn't make use of `bigint`?

AFAIK, none

[01:24:23.0075] <ljharb>
like a special decorator or something

[01:24:24.0230] <keith_miller>
Or it wouldn't have shipped

[01:25:14.0974] <keith_miller>
On the === front you could say that if object identity is equal then it doesn't call your overload. I don't think that's a crazy rule.

[01:25:37.0944] <keith_miller>
littledan: CC^

[01:25:58.0946] <Duncan MacGregor>
> <@keith_miller:matrix.org> AFAIK, none

Generally none, but some sites could end up having more types flowing through them than previously. Rarely significant though.

[01:25:59.0484] <littledan>
I think browsers want to be able to return "false" fast

[01:26:06.0231] <nicolo-ribaudo>
When we talk about performance, do we also include "time from when the user clicks on a link to when the page is available"? (i.e. loading time)

[01:26:13.0654] <nicolo-ribaudo>
Or just runtime performance?

[01:26:30.0899] <keith_miller>
You already have to look into your object to figure out if it's a string or BigInt though

[01:26:33.0483] <Duncan MacGregor>
I think we mean both.

[01:26:51.0588] <keith_miller>
At that point you can check for overloading, which too much cost in an IC

[01:27:01.0015] <rbuckton>
If we did provide a user-defined primitive capability with operator overloading in a similar vein, would it then be reasonable to assume that all performance overhead would be in interactions with those primitives, and not all other JS?

[01:27:07.0579] <keith_miller>
 * At that point you can check for overloading, without too much cost in an IC

[01:28:23.0816] <keith_miller>
I don't understand what you mean by "user-defined primitive capability"?

[01:28:52.0890] <hax (HE Shi-Jun)>
something close to Tuple/Record

[01:29:37.0211] <Ashley Claymore>
Record & Tuple was also blocked from being a primitive

[01:29:38.0838] <keith_miller>
It would still be an object though so it's not really a primitive. It just looks kinda like a primitive unless you squint

[01:29:48.0048] <rbuckton>
> <@keith_miller:matrix.org> I don't understand what you mean by "user-defined primitive capability"?

For the purpose of this discussion, I mean some bespoke syntax to declare a user-defined "primitive" type, much like a class, except it isn't Object.

[01:29:49.0750] <Duncan MacGregor>
Oh, the area where we would likely see a performance degradation is if people can define new cases involving the existing primitives.

[01:30:23.0800] <mgaudet>
(Personal Hat on): User defined primitives are a fascinating design space that I think would provide a lot of value, and potentially could be done -- a path I would propose would be abstracting BigInt such that you could re-host BigInt atop the abstraction, then provide user access to the abstraction. But there's many, many dragons here 

[01:30:30.0116] <rbuckton>
> <@keith_miller:matrix.org> It would still be an object though so it's not really a primitive. It just looks kinda like a primitive unless you squint

Sure, that's fine to me. I'm talking about "looks like a primitive".

[01:30:34.0969] <mgaudet>
(c.f. Project Valhalla etc) 

[01:31:08.0066] <hax (HE Shi-Jun)>
> <@rbuckton:matrix.org> For the purpose of this discussion, I mean some bespoke syntax to declare a user-defined "primitive" type, much like a class, except it isn't Object.

like Java primitive class ...

[01:31:11.0959] <Duncan MacGregor>
> <@mgaudet:mozilla.org> (c.f. Project Valhalla etc)

Trigger warning, please. üòÄ

[01:31:13.0772] <rbuckton>
With the caveat that operator overloads on a user-defined "primitive" will likely be far slower than native primitives.

[01:31:20.0122] <Michael Ficarra>
I see where Jodran's coming from. I believe this proposal is much less motivated without the primitive. But I still think it is motivated enough by its other merits, and there is a path to a primitive in the future, so I support it.

[01:31:28.0029] <mgaudet>
> <@aardvark179:matrix.org> Trigger warning, please. üòÄ

Apologies

[01:32:55.0645] <Michael Ficarra>
* I see where Jordan's coming from. I believe this proposal is much less motivated without the primitive. But I still think it is motivated enough by its other merits, and there is a path to a primitive in the future, so I support it.

[01:33:05.0132] <keith_miller>
> <@aardvark179:matrix.org> Oh, the area where we would likely see a performance degradation is if people can define new cases involving the existing primitives.

Yeah, I DEFINITELY don't think we can let users change e.g. `number + number`

[01:33:18.0520] <keith_miller>
For both performance and sanity reasons

[01:33:30.0783] <rbuckton>
You don't pay the cost of operator overloading for all Objects, only this different thing. If you want to define a "primitive"-like type with operator overloading, you use this and not Object. Implementations only have to plumb this through once and it is a catch-all for any "primitive"-like type we might want to include in the standard library as well.

[01:34:14.0255] <Duncan MacGregor>
> <@keith_miller:matrix.org> Yeah, I DEFINITELY don't think we can let users change e.g. `number + number`

But if I have a matrix type I'd definitely want to be able to define number * matrix‚Ä¶ This is where the dragons are.

[01:34:18.0019] <rbuckton>
> <@keith_miller:matrix.org> Yeah, I DEFINITELY don't think we can let users change e.g. `number + number`

Agreed. You'd only get custom overloading when one of the operands is the user-defined primitive.

[01:34:34.0597] <ljharb>
what if both operands have a different overload?

[01:34:55.0403] <Duncan MacGregor>
That's another dragon.

[01:35:02.0246] <keith_miller>
You could say both have to have the same function?

[01:35:04.0564] <Duncan MacGregor>
Ruby does it by operators really being methods

[01:35:08.0805] <keith_miller>
Or an exception

[01:35:10.0710] <keith_miller>
idk

[01:35:20.0970] <Duncan MacGregor>
Other langauges do multi-argument dispatch

[01:35:23.0320] <rbuckton>
> <@aardvark179:matrix.org> But if I have a matrix type I'd definitely want to be able to define number * matrix‚Ä¶ This is where the dragons are.

Yes, but the expectation is that using a user-defined "primitive" as an operand is about convenience and not performance.

[01:36:41.0597] <rbuckton>
We've investigated various mechanisms for operator overloading in the past. 

[01:39:05.0769] <keith_miller>
> <@aardvark179:matrix.org> But if I have a matrix type I'd definitely want to be able to define number * matrix‚Ä¶ This is where the dragons are.

Yeah, I could see `object <op> primitive` calling some overload too

[01:39:27.0103] <keith_miller>
But maybe there's dragons there I haven't thought through

[01:39:41.0371] <Luca Casonato>
Can someone advance the queue?

[01:40:20.0495] <littledan>
> <@rbuckton:matrix.org> You don't pay the cost of operator overloading for all Objects, only this different thing. If you want to define a "primitive"-like type with operator overloading, you use this and not Object. Implementations only have to plumb this through once and it is a catch-all for any "primitive"-like type we might want to include in the standard library as well.

yes, this corresponds to my previous operator overloading proposal, where you had to make it clear when allocating the object that it had overloading

[01:40:29.0836] <rbuckton>
I had a very early draft for operator overloading syntax in my original `struct` proposal, something like:
```
struct Decimal {
  ...
  static (Decimal + Decimal) (a, b) { return ...; }
  static (Decimal - Decimal) (a, b) { return ...; }
  static (Decimal * Decimal) (a, b) { return ...; }
  ...
}
```
NOTE that this is *not* being considered for the current `struct` proposal.

[01:41:08.0684] <littledan>
sure if there's an easy to check tag on the object that says whether it has overloading

[01:42:36.0880] <mgaudet>
(There's another dimension here to operators, which is also identity; primitives bring *both* operators *and* a lack of identity, and there's no ability as a user to create a user-defined-thing that has no identity too -- c.f. earlier R&T) 

[01:43:07.0786] <rbuckton>
Though I did spend some time fleshing out what a user-defined "primitive" might look like in my _old_ struct proposal: https://github.com/rbuckton/proposal-struct

[01:43:18.0162] <keith_miller>
> <@rbuckton:matrix.org> You don't pay the cost of operator overloading for all Objects, only this different thing. If you want to define a "primitive"-like type with operator overloading, you use this and not Object. Implementations only have to plumb this through once and it is a catch-all for any "primitive"-like type we might want to include in the standard library as well.

I don't think from the engine side there's a difference

[01:43:22.0360] <mgaudet>
(a lack of identity also ties in immutability too) 

[01:43:32.0093] <keith_miller>
But maybe that's different for other engines

[01:44:13.0001] <Duncan MacGregor>
Lack of guaranteed identity seems like a relatively small problem.

[01:44:33.0259] <mgaudet>
> <@aardvark179:matrix.org> Lack of guaranteed identity seems like a relatively small problem.

was arguably the core of R&T

[01:44:38.0695] <Richard Gibson>
> <@keith_miller:matrix.org> Yeah, I could see `object <op> primitive` calling some overload too

obligatory suggestion for infix function calls

[01:44:57.0016] <rbuckton>
> <@keith_miller:matrix.org> But maybe that's different for other engines

My understand was that the `with operators from ...` syntax that littledan had proposed was primarily to address performance concerns raised by some implementations

[01:45:12.0639] <littledan>
> <@rbuckton:matrix.org> My understand was that the `with operators from ...` syntax that littledan had proposed was primarily to address performance concerns raised by some implementations

sure but it creates other ones

[01:45:25.0059] <littledan>
it's also to address the behavior injection concerns from a design/correctness perspective

[01:45:56.0420] <Duncan MacGregor>
Right, records, tuples, value decorators (hard for JS as there aren't good immutability guarantees without R&T‚Ä¶ lots of ways to do it in VM implementations.

[01:46:34.0449] <Duncan MacGregor>
 * Right, records, tuples, value decorators (hard for JS as there aren't good immutability guarantees without R&T‚Ä¶) lots of ways to do it in VM implementations.

[01:48:35.0449] <keith_miller>
> <@rbuckton:matrix.org> My understand was that the `with operators from ...` syntax that littledan had proposed was primarily to address performance concerns raised by some implementations

That sounds... just worse than even a `Symbol.add` but I'd have to hear the exact performance objections. I would imagine `Symbol.add` would behave the same as a getter in the IC. Most engines already have the infrastructure for getters so I'm a bit surprised such code couldn't be generalized for operators.

[01:49:18.0936] <rbuckton>
When I put together my old struct proposal I was looking for a way to unify the mechanics for R&T, a Decimal primitive, maybe Temporal as a "primitive", and other user-defined "primitive" types.

[01:49:35.0212] <littledan>
`with operators from` means a lot of requirements for bookkeeping. But it's easy to see when you're *not* inside of those things and you can use the ICs which *don't* have support for the new operator overloaded things

[01:51:26.0083] <rbuckton>
If we did have operator overloading, I'd much rather restrict it to a specific domain of values than support `with operators from`. `with operators from` would be a mess for TypeScript.

[01:52:29.0331] <keith_miller>
> <@littledan:matrix.org> `with operators from` means a lot of requirements for bookkeeping. But it's easy to see when you're *not* inside of those things and you can use the ICs which *don't* have support for the new operator overloaded things

The whole point of ICs is that you only generate the cases you've seen though. So, I'm a bit surprised that would help anything.

[01:52:54.0703] <rbuckton>
And that's just type checking, we wouldn't downlevel operator overloading it would be to expensive based on our "no type-based emit" policy.

[01:52:56.0601] <keith_miller>
But, that said, I'm only intimately familiar with JSC's ICs

[01:53:12.0605] <littledan>
> <@keith_miller:matrix.org> The whole point of ICs is that you only generate the cases you've seen though. So, I'm a bit surprised that would help anything.

oh sorry I don't mean ICs, I guess I mean paths in the interpreter or something

[01:53:50.0348] <Duncan MacGregor>
I think the thing I wouldn't like about trying to add operator overloading to JS as currently defined is that we do various coercions  on the two arguments *and then* perform the operation. Ruby and Python both tree all this stuff as a simple method call, so it is simply up to the left operand what is done to the right operand.

[01:54:16.0208] <keith_miller>
> <@littledan:matrix.org> oh sorry I don't mean ICs, I guess I mean paths in the interpreter or something

Ah ok. Assuming we don't allow primitive operator overloading I don't think that would be an issue. At least for JSC.

[01:55:34.0275] <keith_miller>
Once you're in the non-primitive not-equal pointer case you're already doing slow stuff

[01:56:04.0364] <keith_miller>
Again, that's just JSC not necessarily other engines

[01:56:18.0855] <rbuckton>
Oh, also, my old struct proposal required "typed" field definitions to handle cases like size, alignment, packing, etc. You could, in theory, support `===` using the memory contents of the value.

[01:57:21.0796] <keith_miller>
> <@aardvark179:matrix.org> I think the thing I wouldn't like about trying to add operator overloading to JS as currently defined is that we do various coercions  on the two arguments *and then* perform the operation. Ruby and Python both tree all this stuff as a simple method call, so it is simply up to the left operand what is done to the right operand.

Why is it necessary to do coercions?

[01:58:35.0118] <Duncan MacGregor>
> <@keith_miller:matrix.org> Why is it necessary to do coercions?

So at the moment we do `GetValue` and then `ToPrimitive` (which of course we don't actually need to do most of the time).

[01:59:24.0798] <nicolo-ribaudo>
Michael Ficarra

I was going to answer that this is more of a question for the existing stage 3 proposal, that adds the concept of "sources" and wasm is already using it. This new proposal is only for defining what a JS source is.

However, Guy can probably still answer that (I know well how this proposal works for JS, but my Wasm knowledge is more limited üòõ)

[02:00:01.0243] <Michael Ficarra>
yeah but this is the first to introduce an import syntax, right?

[02:00:07.0166] <Duncan MacGregor>
> <@aardvark179:matrix.org> So at the moment we do `GetValue` and then `ToPrimitive` (which of course we don't actually need to do most of the time).

The fact those are just used in operator coercion means we'd need to come up with a new way to spec that, and work out whether we look for overloads before or after doing those conversion.

[02:00:16.0894] <nicolo-ribaudo>
> <@michaelficarra:matrix.org> yeah but this is the first to introduce an import syntax, right?

No, that's already in stage 3 and being implemented

[02:00:28.0047] <nicolo-ribaudo>
This only defines what using that syntax for importing JS files does

[02:00:40.0323] <Michael Ficarra>
oh maybe I'm confused

[02:00:43.0160] <Michael Ficarra>
can you send me a link?

[02:00:51.0800] <keith_miller>
> <@aardvark179:matrix.org> The fact those are just used in operator coercion means we'd need to come up with a new way to spec that, and work out whether we look for overloads before or after doing those conversion.

Ah, yeah, I see. I would expect we would do the coercion after but maybe that causes problems?

[02:00:54.0411] <Michael Ficarra>
there's so many of these module proposals

[02:01:01.0439] <nicolo-ribaudo>
Stage 3: https://github.com/tc39/proposal-source-phase-imports
this: https://github.com/tc39/proposal-esm-phase-imports/

[02:01:41.0528] <nicolo-ribaudo>
> <@michaelficarra:matrix.org> there's so many of these module proposals

Sorry about that, the space is huge and we ended up trying to split it in "independently motivated incremental changes", but maybe it ended up not being the best way üòÖ

[02:04:49.0206] <Michael Ficarra>
> <@nicolo-ribaudo:matrix.org> Sorry about that, the space is huge and we ended up trying to split it in "independently motivated incremental changes", but maybe it ended up not being the best way üòÖ

I'm legitimately still confused üò≠

[02:05:17.0327] <nicolo-ribaudo>
> <@michaelficarra:matrix.org> I'm legitimately still confused üò≠

Let's talk about that during lunch? :)

[02:05:35.0801] <Michael Ficarra>
> <@nicolo-ribaudo:matrix.org> Let's talk about that during lunch? :)

yes, please help me

[02:08:11.0432] <jkup>
> <@michaelficarra:matrix.org> yes, please help me

would love to join this session!

[03:01:10.0052] <Christian Ulbrich>
Could someone from Zoom plz. post the slide deck link, here?

[03:08:56.0273] <Ashley Claymore>
cc Ben 

[03:09:14.0498] <Ben>
https://notes.igalia.com/p/pj5uX_5nC#/

[03:17:02.0521] <Duncan MacGregor>
Going back through meeting notes I have found the first reference to operator overloading and decimal [here](https://github.com/tc39/notes/blob/main/meetings/2017-11/nov-29.md) in section 9.iv.b "Decimal for stage 0". keith_miller . 

[03:26:40.0347] <nicolo-ribaudo>
> <@aardvark179:matrix.org> Going back through meeting notes I have found the first reference to operator overloading and decimal [here](https://github.com/tc39/notes/blob/main/meetings/2017-11/nov-29.md) in section 9.iv.b "Decimal for stage 0". keith_miller .

It's much older (2002-04): https://web.archive.org/web/20161227042517/http://www.mozilla.org/js/language/js20-2002-04/core/operators.html

[03:27:32.0601] <nicolo-ribaudo>
And then https://web.archive.org/web/20161227042517/http://wiki.ecmascript.org/doku.php?id=proposals:operators some years later

[03:33:30.0164] <Michael Ficarra>
the problem with underscore is that you can't avoid shadowing an outer underscore variable

[03:33:50.0340] <Michael Ficarra>
void doesn't have this problem

[03:34:13.0459] <Michael Ficarra>
like I get the people who want underscore for aesthetics, but it's *technically* strictly worse

[03:34:52.0928] <shu>
get a custom ligature font that convers `void` to `_`

[03:35:01.0009] <shu>
 * get a custom ligature font that converts `void` to `_`

[03:35:52.0404] <Duncan MacGregor>
> <@nicolo-ribaudo:matrix.org> It's much older (2002-04): https://web.archive.org/web/20161227042517/http://www.mozilla.org/js/language/js20-2002-04/core/operators.html

Oh yeah, that was just the first ref I could find to operator overloading with reference to the decimal proposal, with a very FLT like comment
> I was going to propose operator overloading this meeting but didnt have time to finish it.

[03:39:48.0328] <shu>
Michael Ficarra: i really do not think `void` operator is a thing JS developers know about?

[03:40:01.0089] <shu>
like the extent to people will know about is using (void 0) as an incantation for undefined

[03:40:29.0477] <nicolo-ribaudo>
Sometimes we get questions in Babel about what's that `void 0` think that we generate so much in our output

[03:40:35.0792] <nicolo-ribaudo>
 * Sometimes we get questions in Babel about what's that `void 0` thing that we generate so much in our output

[03:40:35.0796] <jkup>
feeling a lot less imposter syndrome having just googled "mdn void operator"

[03:40:40.0496] <shu>
 * like the extent to which people will know about it is using (void 0) as an incantation for undefined

[03:41:15.0505] <Richard Gibson>
https://github.com/search?q=%2F%5Cbvoid+%5Ba-z_%5D%2F+language%3AJavaScript+&type=code

[03:42:19.0101] <Richard Gibson>
looks like mostly minified code, but there is definitely intentional use

[03:42:20.0591] <Michael Ficarra>
other than void 0, void is often used in front of IIFEs or in arrow concise bodies

[03:43:17.0821] <nicolo-ribaudo>
Those results are mind blowing

[03:43:29.0784] <nicolo-ribaudo>
There are so many usages of `void e` in the catch block in a statement position

[03:43:42.0699] <nicolo-ribaudo>
I assume it's to workaround bad linters before that the catch binding was optional

[03:43:59.0674] <nicolo-ribaudo>
Than, many of the results "for JS" are actually C code üòõ

[03:44:31.0885] <Michael Ficarra>
this is a really good example from those search results

[03:44:32.0493] <shu>
yeah those results are quite surprising to me as well, fascinating

[03:46:06.0409] <Richard Gibson>
`void undefined` at https://github.com/inspect-js/is-equal/blob/1b8f8f4ffe6e652b0bce57b4563237c90898b150/why.js#L244 üôÉ

[03:46:41.0946] <Michael Ficarra>
okay lol not *all* of them are good

[03:47:10.0791] <Michael Ficarra>
who knows, maybe there's a `var undefined` in there somewhere

[03:47:20.0446] <nicolo-ribaudo>
> <@michaelficarra:matrix.org> sent an image.

If you look at this file it's clearly code that has been minified and then re-formatted

[03:47:26.0242] <nicolo-ribaudo>
https://github.com/everthis/tpp_script/blob/1e4b0f02adea066ccdb21df4a857ec9e2fe2fcd0/um.js#L857

[03:48:13.0598] <shu>
lol `um.js` is a great name

[03:48:22.0778] <nicolo-ribaudo>
 * https://github.com/everthis/tpp_script/blob/1e4b0f02adea066ccdb21df4a857ec9e2fe2fcd0/um.js#L1219

[03:48:52.0254] <jkup>
I like that the two most interesting examples are a `why.js` file and an `um.js` file

[03:51:44.0171] <sffc>
I searched over some large JS codebases I've worked on and I didn't find any references to `void`, except where it is used in TypeScript to mean "this function does not return a value"

[03:51:53.0524] <Ashley Claymore>
To explicitly not want to handle a promise https://typescript-eslint.io/rules/no-floating-promises/ `void somePromiseChain`

[03:56:21.0567] <Richard Gibson>
`void undefined` at https://github.com/inspect-js/is-equal/blob/1b8f8f4ffe6e652b0bce57b4563237c90898b150/why.js#L244 üôÉ

[03:56:34.0536] <Ashley Claymore>
> You already have to look into your object to figure out if it's a string or BigInt though
I don't think that is true for SpiderMonkey, their tagging includes that info AFAIK

[03:56:39.0544] <Ashley Claymore>
 * > You already have to look into your object to figure out if it's a string or BigInt though

I don't think that is true for SpiderMonkey, their tagging includes that info AFAIK

[03:57:21.0970] <Ashley Claymore>
belt and braces

[03:58:39.0345] <Duncan MacGregor>
I think I've seen Java code with annotations to suppress unnecessary type casts, which feels similar.

[04:10:18.0985] <Ashley Claymore>
note: we'll need to merge https://github.com/tc39/notes/pull/326/files for the meeting notes to pass CI when that time comes

[04:11:00.0416] <Michael Ficarra>
is that who was just speaking?

[04:11:07.0285] <nicolo-ribaudo>
Yes

[04:11:42.0765] <ryzokuken (TC39 üá´üáÆ)>
is there any reason not to just merge it right away?

[04:12:19.0931] <nicolo-ribaudo>
> <@usharma:igalia.com> is there any reason not to just merge it right away?

https://github.com/tc39/Admin-and-Business/issues/442 is still pending

[04:12:43.0545] <ryzokuken (TC39 üá´üáÆ)>
this issue means they were accepted as IE

[04:12:48.0373] <ryzokuken (TC39 üá´üáÆ)>
and are being onboarded

[04:13:15.0137] <ryzokuken (TC39 üá´üáÆ)>
done

[04:24:49.0933] <Ashley Claymore>
resume at hh:40

[04:46:02.0022] <Michael Ficarra>
@usharma:igalia.com please advance the queue so I can reply

[04:46:34.0979] <ryzokuken (TC39 üá´üáÆ)>
Michael Ficarra to waldemar's?

[04:46:40.0982] <ryzokuken (TC39 üá´üáÆ)>
ah yes nvm

[04:46:43.0099] <Michael Ficarra>
yes that's the topic we're on

[04:56:19.0971] <Chris de Almeida>
sounds like a good rule for the nascent guide to writing good spec text üßê

[04:59:39.0455] <nicolo-ribaudo>
I think the spec should not change meaning if you remove all green notes -- they should just clarify what you can otherwise infer

[05:07:26.0426] <Michael Ficarra>
@littledan:matrix.org please try not to jump queue topics like that

[05:07:39.0927] <littledan>
what? I was on the queue

[05:07:47.0488] <Michael Ficarra>
I really don't like when people read a TCQ topic and try to pre-reply to it, assuming what the person was going to say

[05:07:49.0107] <littledan>
sorry

[05:08:00.0565] <Michael Ficarra>
it's also speaking out of turn IMO

[05:08:12.0390] <littledan>
you mean how I used replies?

[05:09:09.0225] <littledan>
OK I'll be more careful about that, thanks

[05:09:14.0045] <Michael Ficarra>
if we have two topics, A and B, in TCQ in that order, a reply to A (or the submitter of topic A if different from B) shouldn't try to also address B before B has been introduced

[05:09:50.0514] <littledan>
oh, about testing? right, sorry I didn't want to presume what you were going to say, but yes my comment was off-topic for what I had put on the queue

[05:10:05.0595] <Michael Ficarra>
yes, thank you

[05:10:43.0489] <littledan>
(I had wanted to make that point independently from whether I was responding to you, just with respect to what Shu and Keith seemed to be assuming about the implications of normative text)

[05:11:39.0643] <keith_miller>
I guess I don't understand the point of having normative text that has no requirement?

[05:11:40.0890] <Michael Ficarra>
I have no hard feelings, it's just every time it happens, it makes me feel more pressure to fully express myself in the topic so nobody pre-replies to me with a misinterpretation of what I want to say

[05:12:32.0189] <littledan>
> <@keith_miller:matrix.org> I guess I don't understand the point of having normative text that has no requirement?

The notes should be for context; reading the normative text should be enough to build an implementation, even if we can't have tests for it

[05:13:15.0349] <nicolo-ribaudo>
And Atomics.pause _does_ have behavior, you just cannot test it within JS. Otherwise we wouldn't have this proposal at all

[05:13:48.0741] <keith_miller>
> <@littledan:matrix.org> The notes should be for context; reading the normative text should be enough to build an implementation, even if we can't have tests for it

I guess but how do you ever say if something meets the specification or not if it's subjective?

[05:14:36.0811] <littledan>
specs are allowed to say "should", it's not must or nothing. There's more that the spec can say than "does this conform, yes or no"

[05:14:56.0043] <littledan>
these are just communication devices for humans

[05:15:59.0971] <nicolo-ribaudo>
Example: step 7 of https://tc39.es/ecma262/#sec-suspendthisagent

[05:16:03.0254] <nicolo-ribaudo>
It waits for some time

[05:16:50.0160] <nicolo-ribaudo>
> <@nicolo-ribaudo:matrix.org> Example: step 7 of https://tc39.es/ecma262/#sec-suspendthisagent

Doing something like this would address what I asked for, and it would do it exactly in the form that Richard Gibson proposed

[05:17:47.0794] <nicolo-ribaudo>
And the time in that case is implementation-defined (see step 24 of https://tc39.es/ecma262/#sec-dowait)

[05:18:07.0287] <keith_miller>
> <@nicolo-ribaudo:matrix.org> Example: step 7 of https://tc39.es/ecma262/#sec-suspendthisagent

That's definitively observable though. So it has actual requirements and is testable.

[05:18:10.0718] <hax (HE Shi-Jun)>
what is p1/p2 in the slide?

[05:18:23.0219] <littledan>
> <@haxjs:matrix.org> what is p1/p2 in the slide?

probably thinking of this and p

[05:18:23.0996] <keith_miller>
I think it's a typo

[05:18:45.0368] <rbuckton>
> <@haxjs:matrix.org> what is p1/p2 in the slide?

copy paste typo. `p1` is `this` and `p2` is `p`

[05:23:09.0379] <justingrant>
Yeah, this change was made by the IANA TZDB maintainers in 2015. 

Of all the intra-country merges, I do wish we could find some principled excuse to make this exception for my Quebcois friends (my current startup is based in Montreal) while not opening the door for 100+ other intra-country merges that are justified.



[05:23:14.0664] <keith_miller>
> <@keith_miller:matrix.org> That's definitively observable though. So it has actual requirements and is testable.

The text in `Atomics.pause` is outside the engine's or even OS's control in the third box. So would be impossible to do. Unless you want it to say is "For integral numbers N, Atomics.pause(N) should *attempt to* wait at most as long as Atomics.pause(N+1)."? Then I would agree that has some meaning.

[05:23:56.0083] <littledan>
yes, I agree that this "should" needs to be super non-binding. "should attempt to" SGTM.

[05:25:04.0091] <nicolo-ribaudo>
Yes I would be ok with that text

[05:25:08.0149] <keith_miller>
The first box would have to be something like: "Implementations are expected to implement a pause or yield instruction if *some version* of the best practices of the underlying architecture recommends such instructions in spin loops."

[05:25:45.0642] <justingrant>
The context is that adding Zones in TZDB was originally done pretty much arbitrarily. And the volunteer maintainer (Paul Eggert) who has maintained for the last 15 years has been trying to prune it ever since, using a basic rule that if rules have been the same since 1/1/1970 then they get merged. 

[05:26:06.0116] <nicolo-ribaudo>
The question is: if you were to delete the green notes, would your implementation still behave the same as if you are implementing it by also taking the green notes into account?

[05:26:09.0624] <nicolo-ribaudo>
The answer should be "yes"

[05:26:15.0090] <keith_miller>
Since the best practices can change over time and the engine may not know the best practices for the particular CPU it's targeting

[05:26:27.0374] <hax (HE Shi-Jun)>
If we have such auto correlation incantation, could it also apply to normal class?? üòÉ

[05:27:04.0645] <rbuckton>
> <@haxjs:matrix.org> If we have such auto correlation incantation, could it also apply to normal class?? üòÉ

No, how could it? Classes aren't shareable.

[05:28:07.0102] <keith_miller>
> <@nicolo-ribaudo:matrix.org> The question is: if you were to delete the green notes, would your implementation still behave the same as if you are implementing it by also taking the green notes into account?

What if some implementation finds people get better performance if they differ from those notes?

[05:28:26.0174] <keith_miller>
Should they be considered non-spec compliant?

[05:29:42.0410] <nicolo-ribaudo>
Assume that the person doing the implementation is infinitely smart and they can find all the possible optimizations

[05:29:56.0220] <nicolo-ribaudo>
The current spec text does not have enough info to hint what `N` is for

[05:30:15.0681] <nicolo-ribaudo>
Oh I misread

[05:30:19.0588] <nicolo-ribaudo>
 * ~~Assume that the person doing the implementation is infinitely smart and they can find all the possible optimizations~~

[05:30:24.0397] <nicolo-ribaudo>
 * <del>The current spec text does not have enough info to hint what `N` is for</del>

[05:30:30.0182] <nicolo-ribaudo>
 * <del>Assume that the person doing the implementation is infinitely smart and they can find all the possible optimizations</del>

[05:30:39.0407] <nicolo-ribaudo>
> <@keith_miller:matrix.org> Should they be considered non-spec compliant?

No, violating a should is not non-compliant

[05:30:52.0443] <nicolo-ribaudo>
But that doesn't mean that the spec text shouldn't describe the intention

[05:30:59.0116] <nicolo-ribaudo>
 * But that doesn't mean that the spec text shouldn't clearly communicate the intention

[05:31:52.0234] <nicolo-ribaudo>
 * But that doesn't mean that the spec text shouldn't clearly communicate the intention / recommended behavior

[05:32:16.0079] <Luca Casonato>
rbuckton: is the manual correlation token the same as Mechanism 1? or was Mechanism 1 "manually add the prototype to all incoming shared structs"? I couldn't quite tell

[05:32:33.0591] <rbuckton>
Not quite the same, no

[05:33:24.0120] <Luca Casonato>
ok, so then i don't understand Mechanism 1 I think

[05:33:24.0548] <littledan>
> <@keith_miller:matrix.org> The first box would have to be something like: "Implementations are expected to implement a pause or yield instruction if *some version* of the best practices of the underlying architecture recommends such instructions in spin loops."

sure this sounds fine. Honestly I think the current text has enough caveats but no harm adding more.

[05:34:03.0513] <keith_miller>
If that's the consensus then I don't have a problem with normative should. Although, I would prefer a recommends but maybe should is well defined enough in TC39?

[05:34:05.0151] <littledan>
> <@lucacasonato:matrix.org> ok, so then i don't understand Mechanism 1 I think

no, it's like, at startup, thread A sends a message to thread B containing some magical reference to the Point class, and thread B hooks up that reference to its Point class

[05:34:10.0526] <hax (HE Shi-Jun)>
> <@rbuckton:matrix.org> No, how could it? Classes aren't shareable.

I mean, u postMessage a normal class instance, and u got structured clone object which lose methods, so maybe it could be used to also auto correlation methods of them? üòÉ

[05:34:27.0442] <littledan>
> <@keith_miller:matrix.org> If that's the consensus then I don't have a problem with normative should. Although, I would prefer a recommends but maybe should is well defined enough in TC39?

either seems fine to me, I don't know what the difference is tbh

[05:34:30.0304] <Luca Casonato>
> <@littledan:matrix.org> no, it's like, at startup, thread A sends a message to thread B containing some magical reference to the Point class, and thread B hooks up that reference to its Point class

ok, i don't understand how this "magical reference" could work

[05:34:45.0357] <Luca Casonato>
we'd still need some "key" for each shared struct?

[05:34:46.0248] <Ashley Claymore>
Something something module declarations

[05:35:10.0090] <littledan>
> <@lucacasonato:matrix.org> we'd still need some "key" for each shared struct?

yes, this actually physically has to exist as the thing that's in memory as the prototype

[05:35:25.0516] <littledan>
but yes this is breaking new ground for postMessage

[05:35:39.0067] <mgaudet>
To clarify for myself.. if you don't have auto correlation, but you *have* imported the module on main and worker... it's just that points which are post-messaged will have no prototype;  right?

[05:35:45.0026] <Luca Casonato>
ok - i still don't quite see how this isn't exactly the same as the auto correlation key

[05:36:16.0281] <littledan>
> <@lucacasonato:matrix.org> ok - i still don't quite see how this isn't exactly the same as the auto correlation key

autocorrelation means, you don't have to send that reference explicitly; the system just already is using the same key

[05:36:17.0818] <Luca Casonato>
oh i guess that each realm does not need to automatically resolve to the same key

[05:36:33.0531] <keith_miller>
> <@littledan:matrix.org> either seems fine to me, I don't know what the difference is tbh

To me, should implies not doing it could be seen as non-compliance. Recommends is well a recommendation lol

[05:36:51.0932] <Luca Casonato>
the shared structs on either side do not have to have the same "identity" - you manually have to tie the identities together?

[05:36:54.0611] <mgaudet>
(and, I have forgotten a bit) and if you don't import on a worker, and you recieve a shared struct... you can read them like they're just POJOs with a null proto? 

[05:37:02.0871] <littledan>
> <@lucacasonato:matrix.org> ok - i still don't quite see how this isn't exactly the same as the auto correlation key

so we skip adding a weird API that's "Correlate this magic key to this prototype", and reifying that magic key

[05:37:19.0910] <littledan>
> <@mgaudet:mozilla.org> (and, I have forgotten a bit) and if you don't import on a worker, and you recieve a shared struct... you can read them like they're just POJOs with a null proto?

yes

[05:37:34.0850] <littledan>
or maybe a "[[Prototype]] which throws"

[05:37:34.0931] <rbuckton>
> <@mgaudet:mozilla.org> To clarify for myself.. if you don't have auto correlation, but you *have* imported the module on main and worker... it's just that points which are post-messaged will have no prototype;  right?

Not just postmessage. You can just set a shared struct value into a field on an existing shared struct

[05:37:57.0821] <littledan>
> <@rbuckton:matrix.org> Not just postmessage. You can just set a shared struct value into a field on an existing shared struct

right, this is why the only thing needed with postMessage is this one-time setup

[05:38:13.0014] <mgaudet>
rbuckton: Ah that's a helpful reminder too

[05:39:49.0539] <rbuckton>
> <@littledan:matrix.org> right, this is why the only thing needed with postMessage is this one-time setup

My biggest concern with manual correlation is that it weakens privacy, so we could probably never have private state in a shared struct. Auto correlation means you're loading the same code with the same privacy guarantees.

[05:40:26.0540] <Mathieu Hofman>
manual correlation does not have to weaken privacy

[05:41:29.0968] <rbuckton>
And I think having private state is an important capability for encapsulation, such as ensuring a field is only read/written atomically or under a lock via a method on the struct.

[05:41:37.0533] <Duncan MacGregor>
> <@mhofman:matrix.org> manual correlation does not have to weaken privacy

Yeah, do we know how it was thought it would?

[05:42:29.0382] <littledan>
yeah I can see how autocorrelation could help us with private field sharing, but I don't see how we'd do it with manual sharing

[05:42:29.0979] <Mathieu Hofman>
You have to reify a sharable object for the type that describes the capability to attach behavior and access private data (that is not reachable simply from having an instance, or even the constructor)

[05:42:33.0840] <nicolo-ribaudo>
I would consider the identity of a ModuleSource to be specifier+(id of the realm where it was originally created), and not just the specifier

[05:42:49.0247] <nicolo-ribaudo>
Which means that what I and Dan said is not the same behavior

[05:43:19.0022] <littledan>
right so in particular it's much more convenient if you *don't* have to pass along the handle, and can just independently import the same specifier and have it autocorrelate

[05:43:30.0762] <nicolo-ribaudo>
Yes I agree it's more convenient

[05:43:36.0202] <nicolo-ribaudo>
It's also more magival

[05:43:39.0164] <nicolo-ribaudo>
 * It's also more magical

[05:43:59.0860] <littledan>
yes, so, the mechanism you're describing is a way to do a handshake without exposing "too powerful" APIs

[05:44:08.0643] <nicolo-ribaudo>
Yes right

[05:44:12.0306] <littledan>
somehow in between the two mechanisms

[05:44:27.0237] <littledan>
(and corresponds to what I proposed a while ago)

[05:44:35.0096] <Mathieu Hofman>
right, I would like that to the basis of the implementation, and then we can consider sugar on top

[05:45:04.0460] <Mathieu Hofman>
 * right, I would like "a type admin capability" to the basis of the implementation, and then we can consider sugar on top

[05:45:05.0198] <littledan>
what nicolo-ribaudo is proposing would give us plenty of rope to implement sharing private field names

[05:45:30.0016] <littledan>
but a more imperative mechanism would not

[05:46:17.0521] <Mathieu Hofman>
Not really if you start to consider wasm, and how some wasm code would correlate the type

[05:46:59.0263] <Mathieu Hofman>
a more imperative mechanism can conceptually give you access to private fields

[05:47:19.0435] <Mathieu Hofman>
 * a more imperative mechanism can conceptually give you access to private data (maybe not fields per se)

[05:47:41.0505] <littledan>
well, currently Wasm doesn't need to correlate types because it's all structural. But if it gets some nominal capacity, why not transmit it by postMessaging WebAssembly.Module instances? I guess the thing is, they don't contain any reference to their Realm/Agent right now.

[05:48:00.0660] <littledan>
(I really want Wasm to get this nominal capacity)

[05:48:38.0039] <rbuckton>
> <@aardvark179:matrix.org> Yeah, do we know how it was thought it would?

I can explain my concerns after plenary. Feel free to ask in #shared-structs:matrix.org and I'll follow up. Unfortunately I'm still fighting off COVID so it would be easier to explain my position once I've had time to recover and have a clear head.

[05:48:57.0670] <Mathieu Hofman>
> <@littledan:matrix.org> well, currently Wasm doesn't need to correlate types because it's all structural. But if it gets some nominal capacity, why not transmit it by postMessaging WebAssembly.Module instances? I guess the thing is, they don't contain any reference to their Realm/Agent right now.

What restricts a module to contain only a single shared struct definition? 

[05:49:19.0264] <littledan>
> <@mhofman:matrix.org> What restricts a module to contain only a single shared struct definition?

nothing, but in Wasm it'd also correlate by index (a sufficient replacement for source position)

[05:49:28.0741] <littledan>
similar to us correlating by Parse Node

[05:50:06.0481] <littledan>
so it would be by specifier + allocating agent/realm + index

[05:52:30.0912] <Mathieu Hofman>
That really seems like forcing JS specific concepts onto wasm.  Does that mean wasm needs a JS module if it wants to correlate types between its own threads ?

[05:53:20.0722] <littledan>
Wasm as agents and specifiers; not sure what you mean

[05:54:13.0679] <littledan>
Wasm on the web (theoretically, with ESM integration) has a module map per Realm, so it'd be natural to use that rather than agent

[05:55:02.0384] <Duncan MacGregor>
I'm glad it's not just me who didn't understand that thread safety argument.

[06:03:23.0660] <rbuckton>
littledan: I think auto-correlation could handle privacy just fine.

[06:03:39.0703] <littledan>
> <@rbuckton:matrix.org> littledan: I think auto-correlation could handle privacy just fine.

yep agreed

[06:04:27.0741] <littledan>
I think nicolo-ribaudo 's handshake mechanism would also handle it fine. It's "even more lexical".

[06:04:51.0589] <nicolo-ribaudo>
> <@littledan:matrix.org> I think nicolo-ribaudo 's handshake mechanism would also handle it fine. It's "even more lexical".

Yes I think so too

[06:05:38.0366] <Mathieu Hofman>
How would auto correlation work across languages in a way that doesn't require either language to hold objects specific to the other language (as each language may run without the other existing)

[06:06:19.0441] <rbuckton>
My concern with manual correlation (i.e., based on postMessage/exemplars) is that realm B could wire up a struct from realm A into a struct definition that exposes private state, so you have to guard against malicious code being able to spawn a Worker (CSP helps on the web, but not in NodeJS) that can be used to hijack a struct.

[06:06:51.0455] <Mathieu Hofman>
Aka how would 2 wasm threads correlate shared structs (to get access private data) without requiring it to know what a JS module is

[06:07:03.0369] <littledan>
> <@rbuckton:matrix.org> My concern with manual correlation (i.e., based on postMessage/exemplars) is that realm B could wire up a struct from realm A into a struct definition that exposes private state, so you have to guard against malicious code being able to spawn a Worker (CSP helps on the web, but not in NodeJS) that can be used to hijack a struct.

Yes, I share these kinds of soundness concerns with a very expressive imperative API, but I think nicolo-ribaudo 's suggestion is not subject to this risk.

[06:07:35.0746] <rbuckton>
> <@mhofman:matrix.org> How would auto correlation work across languages in a way that doesn't require either language to hold objects specific to the other language (as each language may run without the other existing)

Does it need to work across languages? If JS private state is a uniquely JS mechanism, then WASM could interact with the struct via FFI calls into JS.

[06:08:06.0467] <shu>
> <@rbuckton:matrix.org> Does it need to work across languages? If JS private state is a uniquely JS mechanism, then WASM could interact with the struct via FFI calls into JS.

yeah exactly

[06:08:16.0894] <littledan>
> <@rbuckton:matrix.org> Does it need to work across languages? If JS private state is a uniquely JS mechanism, then WASM could interact with the struct via FFI calls into JS.

some form of nominal correlation would be useful for Wasm, especially if Wasm wants to interact with JS in various threads and give prototypes to its objects

[06:08:21.0446] <shu>
you do some tearoffs that can exfiltrate private data and import them from the wasm side

[06:08:38.0652] <Mathieu Hofman>
> <@rbuckton:matrix.org> My concern with manual correlation (i.e., based on postMessage/exemplars) is that realm B could wire up a struct from realm A into a struct definition that exposes private state, so you have to guard against malicious code being able to spawn a Worker (CSP helps on the web, but not in NodeJS) that can be used to hijack a struct.

if you use forgeable type description, of course. Manual correlation has to be based on non forgeable type descriptors that need to be explicitly shared with the realm in the first place

[06:09:54.0973] <shu>
Mathieu Hofman: you're engaged in the nuts & bolts of how correlation could work. great! but i'm more interested in working through the very high level, "i feel this is unsafe" objection

[06:10:07.0206] <Mathieu Hofman>
> <@rbuckton:matrix.org> Does it need to work across languages? If JS private state is a uniquely JS mechanism, then WASM could interact with the struct via FFI calls into JS.

Does wasm really have no notion of private data for objects?

[06:10:08.0230] <rbuckton>
> <@littledan:matrix.org> some form of nominal correlation would be useful for Wasm, especially if Wasm wants to interact with JS in various threads and give prototypes to its objects

Is there any concern that malicious code could craft a WASM assembly on the fly to unpack private state from a class?

[06:10:14.0691] <shu>
> <@mhofman:matrix.org> Does wasm really have no notion of private data for objects?

why would it?

[06:10:22.0977] <shu>
it's a target for compilers of higher level languages

[06:10:24.0564] <littledan>
> <@mhofman:matrix.org> Does wasm really have no notion of private data for objects?

wasm structs are simply typed tuples

[06:10:38.0220] <shu>
it doesn't have methods because you're supposed to just compile a vtable yourself

[06:10:44.0652] <shu>
not that it literally doesn't have methods

[06:12:03.0072] <Christian Ulbrich>
How is soon is now, I deployed dockerized _TCQ reloaded_ to https://tcq.staging.tcq-reloaded.tcq.ninja/ , **now** with _persistent_ storage, actual PR is at: https://github.com/zalari/tcq/pull/7 ; I will explain individual decisions. So I think, we can use TCQ reloaded next plenary!

[06:12:16.0627] <shu>
i feel like there's a lot of wishful thinking from opponents of the proposal

[06:12:31.0595] <shu>
yes, this is a difficult-to-program-correctly space

[06:12:57.0700] <rbuckton>
> <@littledan:matrix.org> some form of nominal correlation would be useful for Wasm, especially if Wasm wants to interact with JS in various threads and give prototypes to its objects

Ignoring private state JS could expose an API to acquire a "correlation token" it could pass to WASM to set up prototypes? 

[06:13:02.0363] <shu>
but adding on little guardrails doesn't really advance the goal of writing correct programs

[06:13:17.0540] <shu>
well, not even guardrails, just pointless friction imo

[06:13:35.0541] <rbuckton>
> <@mhofman:matrix.org> if you use forgeable type description, of course. Manual correlation has to be based on non forgeable type descriptors that need to be explicitly shared with the realm in the first place

What do you consider to be a "non forgeable type descriptor"? 

[06:14:07.0237] <Mathieu Hofman>
> <@shuyuguo:matrix.org> Mathieu Hofman: you're engaged in the nuts & bolts of how correlation could work. great! but i'm more interested in working through the very high level, "i feel this is unsafe" objection

That is mostly a question for Mark. My personal opinion right now is that shared fields should be private by default, and that correlated behavior would be providing the necessary encapsulation to access that shared data in a thread safe way

[06:14:27.0240] <shu>
mark literally just said that didn't work for java

[06:14:39.0376] <shu>
why do you think that'll move the safety needle here?

[06:15:15.0170] <shu>
i'd also request you ask yourself the question, what happens if you get thread unsafe code in JS/Wasm

[06:15:19.0090] <Mathieu Hofman>
> <@shuyuguo:matrix.org> you do some tearoffs that can exfiltrate private data and import them from the wasm side

jumping to JS land for this seems inefficient. I am really surprised that wasm wouldn't want a private field concept on its own wasm gc objects (shared or non shared)

[06:15:32.0439] <shu>
it's the wrong abstraction level

[06:18:22.0997] <Aki>
so who wants to volunteer to take a look at the print PDFs? they're in a state approaching publishable

[06:18:42.0145] <Mathieu Hofman>
> <@rbuckton:matrix.org> What do you consider to be a "non forgeable type descriptor"?

An object you get when defining the struct that is itself shareable. Not something you can obtain simply by having a reference to the constructor or any instance.

[06:20:39.0120] <rbuckton>
Do we, as a committee, think JS privacy is a security feature? Would it be unforgivable if private state isn't really private at the realm boundary? If we could have `struct S { #x; ... }` in realm A mapped to `struct S { x; ... }` in realm B, would we consider that a security vulnerability? 

[06:21:17.0700] <shu>
good question

[06:21:49.0848] <shu>
this is all echoes of hard constraints held by SES folks that are not clearly communicated as such, and so they feel like stop energy

[06:22:43.0335] <shu>
also like look, i'm *fine* with removing methods

[06:23:06.0005] <shu>
but i think that's actually *worse* for correctness! and i really don't get the arguments that it's better for correctness

[06:23:12.0780] <shu>
and it sounded like others share my confusion

[06:23:40.0791] <rbuckton>
In a shared struct, `struct S { #x; ... }` means that in the realm where it is defined, the private name `#x` refers to the first fixed storage field in the struct. in another realm you could have `struct S { x; ... }` that just says the field "x" refers to the first fixed storage field in the struct. If you manually correlate S in each realm, does the privacy need to be preserved?

[06:23:55.0094] <shu>
the _only_ thing i can make sense of is, "if we don't have methods, i can mentally compartmentalize everything over in wasm land, so i can not think about it"

[06:24:03.0443] <shu>
but end-to-end that argument doesn't make sense

[06:24:26.0532] <Mathieu Hofman>
The equivalence of private fields has always been WeakMap, and the guiding principle is "how do you give access to the WeakMap instance to access private data". In JS, the WeakMap instance is an object capability like everything else. No-one should be able to get object references without explicitely receiving them.

[06:24:56.0412] <shu>
you can use shared structs as a WeakMap key in a per-thread WeakMap?

[06:25:01.0185] <shu>
 * you can use shared structs as a WeakMap key in a per-thread WeakMap

[06:25:02.0277] <shu>
that's fine

[06:26:01.0420] <rbuckton>
Methods are just functions with lexical access to private state. The correlation mechanism is to make sure you're using the *right* functions (methods) in a given realm. Free functions provide no benefits.

[06:26:11.0188] <shu>
yeah exactly!

[06:26:31.0835] <Mathieu Hofman>
IMO the only interest to private data is to have it shared, so that it can be used for encapsulation

[06:27:42.0116] <shu>
i am going to become le joker

[06:27:48.0526] <rbuckton>
And if you want to guard your shared memory multithreading data structures and logic with a wrapper facade, as Mark suggested, you can do the same thing with methods. Methods vs functions has no impact on that.

[06:29:43.0990] <rbuckton>
> <@mhofman:matrix.org> IMO the only interest to private data is to have it shared, so that it can be used for encapsulation

That's precisely why I want private state to be an option for shared structs in the future.

[06:31:09.0315] <shu>
i want to be very clear on my thinking on footguns

[06:33:04.0824] <shu>
where something _is already expressible_, we should be thinking hard about not introducing alternative forms that are easy to get wrong, or easy to be slow, etc. because the incentive for a developer to do a thing is because it has the semantics the developer wants to do. so if choosing between form A and B that have more or less the same core behavior but differ in performance or some aspect of correctness, we shouldn't add forms that have higher likelihood of being slow or incorrect

[06:34:15.0298] <shu>
but if one's claim is that the likelihood of incorrectness comes from _expressing the thing at all_ (like shared memory), banning alternate forms adds friction for zero gain!

[06:41:38.0467] <rbuckton>
In terms of TypeScript's "incremental adoption" story, most of our AST nodes are essentially "immutable" after they are created (though that's only enforced through type checking). Being able to produce AST nodes in parallel parsers and collect them in the main thread for checking, and then spin them out to parallel emitters would be essential for incremental adoption in TS. Public fields aren't really a concern since we could annotate them with a design-time only `readonly` modifier, though it would be interesting to add an actual concept of an init-only field, e.g., `shared struct S { const x; ... }`

[06:42:58.0627] <shu>
ah right, that reminds me i didn't respond to the narrow point that mark made about the Point example being incorrect

[06:43:04.0707] <shu>
i also didn't show any code mutating .x and .y :)

[06:43:13.0008] <shu>
 * ah right, that reminds me i didn't respond to the narrow point that mark made about the Point example being not thread safe

[06:44:38.0030] <rbuckton>
But for incremental adoption to work those nodes would need to have methods, otherwise we would need to rewrite the entire compiler to even get started.

[06:58:17.0974] <Chris de Almeida>
> <@rbuckton:matrix.org> Do we, as a committee, think JS privacy is a security feature? Would it be unforgivable if private state isn't really private at the realm boundary? If we could have `struct S { #x; ... }` in realm A mapped to `struct S { x; ... }` in realm B, would we consider that a security vulnerability?

yes, yes, and yes.  if I understand your example correctly, the private field on A being accessible from B, I would consider that a security vulnerability


[07:00:30.0491] <rbuckton>
> <@softwarechris:matrix.org> yes, yes, and yes.  if I understand your example correctly, the private field on A being accessible from B, I would consider that a security vulnerability

Then I would expect that WASM can't read JS private state directly as it constitutes a vulnerability. 

[07:01:59.0992] <rbuckton>
But I also do not hold that private state is a security feature. 

[07:07:28.0802] <Chris de Almeida>
> <@rbuckton:matrix.org> But I also do not hold that private state is a security feature.

would you agree that encapsulation is a security feature?

[07:08:13.0957] <Chris de Almeida>
to be clear I don't suggest that privacy is _exclusively_ a security feature

[07:08:33.0280] <Chris de Almeida>
 * to be clear I don't suggest that privacy (or encapsulation in general) is _exclusively_ a security feature

[07:09:49.0750] <rbuckton>
I see it as a developer experience/convenience mechanism. It's not that I think it should be less "secure", per se, but that I don't consider private state to be trustworthy as there are limitations to its "security" in some situations. 

