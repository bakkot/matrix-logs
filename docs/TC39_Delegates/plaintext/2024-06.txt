2024-06-01
[20:29:37.0615] <justingrant>
What's the right process to get consensus on it from TG1 in Helsinki for normative PRs to ECMA-402? Do I add it as a standalone agenda item?  As part of a standing agenda item for 402 changes?  Something else? PR is https://github.com/tc39/ecma402/pull/877

This is mostly a "web reality" change that aligns the spec with how V8 and JSC already behave by tightening under-specified parts of the spec. It also adds forward-looking guidance to handle future issues that may crop up with time zone identifiers.

Ideally I would have asked this question yesterday before the deadline, but I mistakenly believed that all TG2-approved PRs would magically make it into the agenda. Oops. Anyway, I'll add this as a late submission. 

[21:33:25.0929] <bakkot>
I believe you still have two hours before the deadline

[21:34:24.0705] <bakkot>
this is a three-day meeting so the deadline is Saturday rather than Friday (but Saturday in Helsinki, so earlier than it would for meetings in PT)

[01:33:37.0254] <sffc>
Yeah, it should be added under "Needs Consensus PRs". ECMA-402 PRs previously got added automatically, but that practice stopped about a year ago. Now we just make an announcement in the monthly TG2 call to remind champions to add their stuff to the TG1 agenda if it needs TG1 consensus.

[16:11:03.0610] <Rob Palmer>
We still have around 3 hours of spare capacity. So please don't let the agenda deadline stop you from adding more items. 


2024-06-02
[17:12:02.0955] <rbuckton>
I'd hoped to bring back extractors and void bindings for Stage 2 this plenary, but only recently had the time to address feedback from last meeting and I want to give Waldemar time to review the changes intended to address his concerns. I may try to add them as late agenda items since they both seemed fairly close to reaching stage 2 at the last meeting (or, at least that was my impression). 

[15:37:32.0946] <justingrant>
> Yeah, it should be added under "Needs Consensus PRs". ECMA-402 PRs previously got added automatically, but that practice stopped about a year ago. Now we just make an announcement in the monthly TG2 call to remind champions to add their stuff to the TG1 agenda if it needs TG1 consensus.

Serves me right for not listening carefully!  üëÇÔ∏è  I just [submitted](https://github.com/tc39/agendas/pull/1611) a needs-consensus agenda item for that PR.


2024-06-03
[03:19:44.0481] <littledan>
If we seriously have extra time on the agenda, there are a couple wild open discussion topics which might be fun. Emoji-react something if you're interested in them. (Apologies for not raising this before the agenda deadline.)

[03:19:48.0061] <littledan>
Cancellable promises

[03:20:02.0708] <littledan>
Private name declarations outside of classes

[03:34:55.0090] <rbuckton>
> <@littledan:matrix.org> Cancellable promises

Would it make sense to discuss this on https://github.com/tc39/proposal-cancellation? 

[03:37:07.0446] <littledan>
> <@rbuckton:matrix.org> Would it make sense to discuss this on https://github.com/tc39/proposal-cancellation?

oh thanks that gives a lot of helpful references to review. I have been thinking about this area again in the context of AsyncContext, which gives us more options for propagating the cancel token.

[03:37:44.0109] <littledan>
also AbortSignal.any is a very helpful, core capability in this area, which I don't think was there last time we discussed this

[03:40:19.0801] <littledan>
(I guess it basically enables what your previous proposal's `new CancellationTokenSource(linkedTokens?)` does, roughly)

[03:46:36.0415] <rbuckton>
Unfortunately, since `AbortSignal` is outside the purview of TC39 the best forum for that may be WHATWG. 

[03:47:27.0488] <rbuckton>
Though I've long held that cancellation graphs like that are very valuable

[03:47:50.0220] <littledan>
We'll definitely have to collaborate between standards groups to make this happen, but I think you were right to bring this to TC39, and believe we can make some progress together.

[03:49:56.0372] <littledan>
also if we want integration with async/await (e.g., all awaits are implicitly racing with the cancel token), something would need to happen in TC39

[03:50:01.0638] <rbuckton>
I also agree that AsyncContext would have been the way to traffic a cancellation token in the way Yehuda wanted, so long as there was a way to suppress async context flow when needed

[03:50:30.0594] <littledan>
> <@rbuckton:matrix.org> I also agree that AsyncContext would have been the way to traffic a cancellation token in the way Yehuda wanted, so long as there was a way to suppress async context flow when needed

could you say more about this suppression use case?

[03:50:41.0467] <littledan>
I mean, requirements for it

[03:50:47.0027] <rbuckton>
The only avenue given to us at this point is a host hook. 

[03:51:16.0521] <littledan>
IIRC wanting the cancel token to be implicitly propagated was a goal of Domenic's as well

[03:51:41.0981] <rbuckton>
> <@littledan:matrix.org> could you say more about this suppression use case?

Sometimes you *don't* want to propagate the token.

[03:51:55.0355] <rbuckton>
I have to step away, I'll discuss more shortly.

[03:52:03.0559] <littledan>
> <@rbuckton:matrix.org> The only avenue given to us at this point is a host hook.

I hope we can first think about the problem space and what's needed for developers (as you were trying to do) and then we can go from there to "how do we lay this out across the various specs"

[04:02:15.0431] <rbuckton>
With the token as a parameter, it is up to the caller to determine whether to pass the token to a function. If you had a function that invoked a REST API, you might want to allow it to be cancellable in some cases, but not others. If there is no suppression mechanism, then there is no way for the caller to make this determination. The structure of the Cancellation API (so far as that proposal was concerned) ensured an appropriate separation of concerns so that the correct level of control was available with respect to the caller and the call site. 

[04:10:21.0273] <rbuckton>
> <@littledan:matrix.org> (I guess it basically enables what your previous proposal's `new CancellationTokenSource(linkedTokens?)` does, roughly)

One of the major reasons I wanted a linked cancellation graph was to address memory overhead. If cancellation sources could be intrinsically linked, and could be disposed when cancellation was no longer needed, then all of the token subscriptions could be GC'd (incl. the callbacks and closed-over variables that they held).

[04:11:02.0669] <littledan>
> <@rbuckton:matrix.org> With the token as a parameter, it is up to the caller to determine whether to pass the token to a function. If you had a function that invoked a REST API, you might want to allow it to be cancellable in some cases, but not others. If there is no suppression mechanism, then there is no way for the caller to make this determination. The structure of the Cancellation API (so far as that proposal was concerned) ensured an appropriate separation of concerns so that the correct level of control was available with respect to the caller and the call site.

yes, so if we had an AsyncContext variable for the current cancel token, and then a function you could call to set that variable to a fresh token while running a callback, that would achieve suppression, right?

[04:11:20.0600] <littledan>
> <@rbuckton:matrix.org> One of the major reasons I wanted a linked cancellation graph was to address memory overhead. If cancellation sources could be intrinsically linked, and could be disposed when cancellation was no longer needed, then all of the token subscriptions could be GC'd (incl. the callbacks and closed-over variables that they held).

yes, I agree this is important. Do you see AbortSignal.any as solving that issue too?

[04:11:23.0772] <rbuckton>
A fresh token, or no token.

[04:11:51.0719] <rbuckton>
I would have to think about that. IIRC, the issue with `any` is how ownership is controlled for a subgraph.

[04:12:17.0977] <littledan>
> <@rbuckton:matrix.org> I would have to think about that. IIRC, the issue with `any` is how ownership is controlled for a subgraph.

I think `any` has to be used in a sort of opinionated way to make things work

[04:12:48.0595] <littledan>
and your proposed signature sort of already encapsulates that pattern

[04:13:37.0431] <rbuckton>
Let's say I receive a token and want to call another function with both that and my own token. With `any`, I can close *my* source, but since I have no control over the incoming token, the graph can't be GC'd

[04:14:41.0288] <littledan>
which graph do you mean?

[04:16:43.0747] <rbuckton>
```js
function outer(signal) {
  const myController = new AbortController();
  const combined = AbortController.any([signal, myController.signal]);
  const promise = inner(combined.signal);
  ...
  // we've progressed to a point where cancellation shouldn't occur, 
  // but we can't signal that to `inner`
  myController.dispose(); 
}
```

[04:17:03.0949] <rbuckton>
 * ```js
function outer(signal) {
  const myController = new AbortController();
  const combinedSignal = AbortController.any([signal, myController.signal]);
  const promise = inner(combinedSignal);
  ...
  // we've progressed to a point where cancellation shouldn't occur, 
  // but we can't signal that to `inner`
  myController.dispose(); 
}
```

[04:17:22.0439] <rbuckton>
 * ```js
function outer(signal) {
  const myController = new AbortController();
  const combinedSignal = AbortSignal.any([signal, myController.signal]);
  const promise = inner(combinedSignal);
  ...
  // we've progressed to a point where cancellation shouldn't occur, 
  // but we can't signal that to `inner`
  myController.dispose(); 
}
```

[04:17:58.0738] <rbuckton>
Here, even if we think `inner` should keep going, if `signal` is canceled then `combinedSignal` is cancelled.

[04:18:18.0929] <rbuckton>
If `any` returns a signal, then I can't model this relationship using it.

[04:19:34.0859] <rbuckton>
But if `any` returns a controller, then I can exert this level of control:
```js
function outer(signal) {
  const combinedController = AbortController.any([signal]);
  const promise = inner(combinedController.signal);
  ...
  // we've progressed to a point where cancellation shouldn't occur
  combinedController.dispose(); 
}
```

[04:21:02.0607] <rbuckton>
The `new CancellationTokenSource(linkedTokens?)` API allowed you to express this relationship. If you need control over the subgraph, you hold a reference to the source. If you don't need control over the subgraph, you don't hold a reference to the source and just pass along it's `token`.

[04:21:42.0030] <littledan>
Btw did you point this out in any issue on the AbortSignal.any repo?

[04:22:29.0213] <rbuckton>
I wasn't aware of an `AbortSignal.any` repo, but I've definitely discussed it many years ago in TC39 as part of the cancellation proposal.

[04:23:46.0088] <littledan>
This was the repo, but it's already shipping across browsers https://github.com/shaseley/abort-signal-any

[04:24:18.0854] <littledan>
I had trouble following all the aspects of your previous presentation, and was watching this proposal later, and thought it was good and solved the problems you were raising.

[04:26:05.0403] <rbuckton>
Ah, that's unfortunate.

[04:26:19.0641] <littledan>
I have trouble tracing the leak in the above code. It's that it's less apparent that the controller is dead?

[04:26:44.0432] <rbuckton>
No, the problem is that the controller isn't dead in the first example.

[04:27:01.0057] <littledan>
sure, that it isn't dead, so how big of a leak is that?

[04:27:20.0488] <littledan>
it's only referred to by that local variable, and that can be collected once you leave the scope. or is there anything else?

[04:28:06.0034] <littledan>
(I thought solving this particular GC issue was like 80% of the point of AbortSignal.any in the first place)

[04:28:36.0231] <rbuckton>
It's not a leak, it's bigger than that. If I wanted to be able to control whether `inner` could even be cancelled anymore after a certain point, I would not be able to do so in that approach, so it actually affects capabilities, not just memory.

[04:29:00.0966] <rbuckton>
Also, if there is no `dispose()`/`close()` then you're not addressing the GC concern at all.

[04:29:15.0895] <littledan>
how can you do that with the API you're proposing?

[04:29:43.0061] <rbuckton>
It's quite hard to explain in text without drawing a graph :/

[04:57:44.0560] <rbuckton>
Lets assume for a moment that an `AbortController` has a `dispose()` method. In example one, you have an outer abort controller `A` (and signal `a`) and create an inner abort controller `B` (and signal `b`). Calling `AbortSignal.any([a, b])` produces a signal `ab` with the following semantics:
- Aborting `A` aborts `a` and `ab`
- Aborting `B` aborts `b` and `ab` 
- Disposing `A` disposes `a` but not `ab`, because `ab` could still be aborted by `B`.
- Disposing `B` disposes `b` but not `ab`, because `ab` could still be aborted by `A`.

My algorithm reaches a point of no return where I no longer want `inner` to be cancelable, at which point any subscriptions added by `inner` can be collected. Unfortunately, `AbortSignal.any` does not give me this capability since neither `A` nor `B` dominates the token `ab`.

[05:03:15.0189] <rbuckton>
In the `new CancellationTokenSource(linkedTokens?)` approach, you produce a new source/controller that dominates the cancellation interaction with `inner`. You have the same outer controller `A` (and signal `a`), and you wrap it with an inner controller `B(a)` with signal `b(a)`. Signal `b(a)` has the following semantics:

- Aborting `A` aborts `a` and `b(a)`.
- Aborting `B(a)` aborts `b(a)`.
- Disposing `A` disposes `a` but not `b(a)`, because `b(a)` could still be aborted by `B(a)`. However, the link between `B(a)` and a` can be removed and the subscription can be GC'd
- Disposing `B(a)` disposes `b(a)`, but not `a`. Any subscriptions to `b(a)` can be GC'd

[05:03:37.0928] <rbuckton>
 * In the `new CancellationTokenSource(linkedTokens?)` approach, you produce a new source/controller that dominates the cancellation interaction with `inner`. You have the same outer controller `A` (and signal `a`), and you wrap it with an inner controller `B(a)` (with signal `b(a)`). Signal `b(a)` has the following semantics:

- Aborting `A` aborts `a` and `b(a)`.
- Aborting `B(a)` aborts `b(a)`.
- Disposing `A` disposes `a` but not `b(a)`, because `b(a)` could still be aborted by `B(a)`. However, the link between `B(a)` and a\` can be removed and the subscription can be GC'd
- Disposing `B(a)` disposes `b(a)`, but not `a`. Any subscriptions to `b(a)` can be GC'd

[05:04:32.0980] <rbuckton>
 * In the `new CancellationTokenSource(linkedTokens?)` approach, you produce a new source/controller that dominates the cancellation interaction with `inner`. You have the same outer controller `A` (and signal `a`), and you wrap it with an inner controller `B(a)` (with signal `b(a)`). Signal `b(a)` has the following semantics:

- Aborting `A` aborts `a` and `b(a)`.
- Aborting `B(a)` aborts `b(a)`.
- Disposing `A` disposes `a` but not `b(a)`, because `b(a)` could still be aborted by `B(a)`. However, the link between `B(a)` and `a` can be removed and the subscription can be GC'd
- Disposing `B(a)` disposes `b(a)`, but not `a`. Any subscriptions to `b(a)` can be GC'd

[05:08:11.0585] <rbuckton>
So the difference between the two designs is not just one of memory efficiency, but capability. `b(a)` has a capability that `ab` does not.

[05:09:52.0035] <rbuckton>
 * In the `new CancellationTokenSource(linkedTokens?)` approach, you produce a new source/controller that dominates the cancellation interaction with `inner`. You have the same outer controller `A` (and signal `a`), and you wrap it with an inner controller `B(a)` (with signal `b(a)`). Signal `b(a)` has the following semantics:

- Aborting `A` aborts `a` and `b(a)` so long as a link still remains between `a` and `B(a)`.
- Aborting `B(a)` aborts `b(a)`.
- Disposing `A` disposes `a` but not `b(a)`, because `b(a)` could still be aborted by `B(a)`. However, the link between `B(a)` and `a` can be removed and the subscription can be GC'd
- Disposing `B(a)` disposes `b(a)`, but not `a`. Any subscriptions to `b(a)` can be GC'd

[05:10:16.0142] <rbuckton>
 * In the `new CancellationTokenSource(linkedTokens?)` approach, you produce a new source/controller that dominates the cancellation interaction with `inner`. You have the same outer controller `A` (and signal `a`), and you wrap it with an inner controller `B(a)` (with signal `b(a)`). Signal `b(a)` has the following semantics:

- Aborting `A` aborts `a` and `b(a)` so long as a link still remains between `a` and `B(a)`.
- Aborting `B(a)` aborts `b(a)`.
- Disposing `A` disposes `a` but not `b(a)`, because `b(a)` could still be aborted by `B(a)`. However, the link between `B(a)` and `a` can be removed and the subscription can be GC'd.
- Disposing `B(a)` disposes `b(a)`, but not `a`. Any subscriptions to `b(a)` can be GC'd.

[05:27:58.0561] <rbuckton>
I also discuss a lot of this in https://github.com/tc39/proposal-cancellation/blob/master/stage0/README.md, which was pulled out of the explainer when it advanced to stage 1.

[07:52:43.0090] <littledan>
I don't see anything in these docs about disposal. Is disposal really a necessary feature?

[07:57:00.0132] <littledan>
There's some related discussion about being on AbortController vs AbortSignal in https://github.com/shaseley/abort-signal-any/#exposure-through-abortsignal-vs-abortcontroller

[10:03:50.0407] <rbuckton>
> <@littledan:matrix.org> I don't see anything in these docs about disposal. Is disposal really a necessary feature?

See `source.close()` in that stage 0 explainer. I believe it is important, and the lack of it today is wasteful. 

[10:09:56.0125] <rbuckton (traveling)>
https://github.com/tc39/proposal-cancellation/blob/master/stage0%2FREADME.md#sourceclose

[10:17:21.0266] <rbuckton (traveling)>
If you can close/dispose a source, functions that receive the closed token can use more efficency code paths, and registrations that would have introduced closures can be skipped. A source that is left open instead of canceling/closing results in closures holding references to closed over values far longer than necessary. IIRC, AbortSignal doesn't even clean up user code registrations when aborted since user code registrations are event based

[10:18:55.0548] <rbuckton (traveling)>
* If you can close/dispose a source, functions that receive the closed token can use more efficenct code paths, and registrations that would have introduced closures can be skipped. A source that is left open instead of canceling/closing results in closures holding references to closed over values far longer than necessary. IIRC, AbortSignal doesn't even clean up user code registrations when aborted since user code registrations are event based

[10:28:11.0707] <rbuckton (traveling)>
FYI, the most recent iteration of this API is here: https://esfx.js.org/esfx/api/canceltoken.html?tabs=ts

[10:31:45.0010] <rbuckton (traveling)>
Where `CancelToken.race(cancelables)` is the same as `AbortSignal.any`, but `CancelToken.source(cancelables)` is preferred.

[15:00:22.0661] <littledan>
> <@rbuckton:matrix.org> See `source.close()` in that stage 0 explainer. I believe it is important, and the lack of it today is wasteful. 

Oh, I see. This is new for me; I need to think more to understand the implications.


2024-06-04
[03:51:26.0252] <nicolo-ribaudo>
WHATWG adopted a process inspired by our stage-based one:
https://whatwg.org/stages

[07:08:56.0818] <Chris de Almeida>
neat!  I wonder when they'll add 2.7  üßê


2024-06-05
[18:09:06.0532] <Michael Ficarra>
it actually appears it was mostly copied from us before the recent refactoring of the process document and the addition of 2.7

[18:09:09.0905] <Michael Ficarra>
that's a shame

[22:54:19.0718] <littledan>
Actually it matches our new state: tests are required for WHATWG stage 3, which we caught up with when defining Stage 2.7

[03:25:52.0819] <Michael Ficarra>
No, this much more closely matches our process before the 2.7 split. There's no point at which they commit to the specifics of the solution but have not yet created tests and permitted implementation. That was the primary goal of the split. Requiring tests for our stage 3 was only part of it.

[06:21:45.0746] <littledan>
I agree, there‚Äôs no specific intermediate point in their process; people are expected to write tests without that support. Though requiring tests for Stage 3 was a big part for me!


2024-06-07
[11:23:55.0652] <Jack Works>
> <@rbuckton:matrix.org> If you can close/dispose a source, functions that receive the closed token can use more efficency code paths, and registrations that would have introduced closures can be skipped. A source that is left open instead of canceling/closing results in closures holding references to closed over values far longer than necessary. IIRC, AbortSignal doesn't even clean up user code registrations when aborted since user code registrations are event based

yeah, I always write `signal.addEventListener('abort', f, { signal, once: true })`


2024-06-09
[16:21:31.0958] <rbuckton (traveling)>
I tested positive for covid on Saturday and it's hitting me hard. Depending on how my symptoms are tomorrow, I may need to limit my remote attendance to rest. I'll post a late breaking schedule constraint to the agenda tomorrow, if necessary. 

[16:30:51.0360] <Chris de Almeida>
draft schedule is available: https://github.com/tc39/Reflector/issues/527


2024-06-10
[23:37:30.0231] <Chris de Almeida>
please note some items on the schedule have shifted

[23:46:18.0074] <Ashley Claymore>
Oh no! Hope it passes quickly and you're able to some rest Ron

[00:17:23.0438] <nicolo-ribaudo>
> <@softwarechris:matrix.org> draft schedule is available: https://github.com/tc39/Reflector/issues/527

jkup "TG4: Source Maps (5m, Jon Kuperman)" can be removed given that we have the long presentation, right?

[00:17:46.0894] <jkup>
Yes that‚Äôs good with me! I meant to PR removing it 

[13:07:01.0950] <shu>
why is WWDC highlighting RegExp.escape

[13:07:06.0875] <shu>
it's stage 2!

[13:27:56.0110] <Chris de Almeida>
savaged again by the regex hypecycle!

[13:28:07.0263] <kriskowal>
This is funny, but also imagine waiting to jump the gun since https://simonwillison.net/2006/Jan/20/escape/

[13:43:05.0328] <ljharb>
O.o how is wwdc highlighting it?

[13:48:43.0037] <shu>
[https://www.youtube.com/watch?v=RXeOiIDNNek 57:46](https://youtu.be/RXeOiIDNNek?t=3466)

[13:49:09.0883] <shu>
Promise.try too

[13:49:16.0863] <shu>
is this like a list of WIP issues or something

[13:50:04.0282] <Michael Ficarra>
lmao `br_on_cast_fail` what is going on

[13:50:13.0573] <shu>
yeah there are so many questions for that graphic

[13:50:16.0159] <Michael Ficarra>
literally not even developers care about it, that is just for compiler authors

[13:50:27.0442] <shu>
gotta give it to them for keeping it real with showing how the sausage is made

[13:54:07.0185] <jkup>
Oh wow I thought you were joking with the RegExp.escape comment!

[13:54:18.0978] <shu>
me, a joker?


2024-06-11
[18:05:15.0806] <rkirsling>
> <@shuyuguo:matrix.org> Promise.try too

I guess I won't complain that they featured my work like this üòÜ

[23:27:46.0501] <Rob Palmer>
The Zoom is up and the Sign-in form is posted on the Reflector.

https://github.com/tc39/Reflector/issues/527

[00:11:32.0175] <Duncan MacGregor>
Is it the same sign in form for remote and in person?

[00:16:44.0826] <eemeli>
Yes.

[00:18:20.0277] <ryzokuken (TC39 üá´üáÆ)>
have a smooth recovery saminahusain 

[00:20:17.0890] <Aki>
recommendation to presenters: write your summary for notes ahead of time. edit on the fly as needed.

[00:23:33.0946] <littledan>
top quality transcriptionist today

[00:23:44.0791] <littledan>
 * top quality transcription today

[00:28:55.0545] <littledan>
FYI: Google Docs works badly when many people are in the doc. Please close the doc if you just have it in the background, if you're not reading or editing the notes.

[00:32:43.0056] <Michael Ficarra>
@littledan:matrix.org the recurring work was only due to Paged.js failing to break (or not break) according to the breaking rules that we wrote

[00:32:55.0405] <Michael Ficarra>
if a tool supports those rules, we don't need to do that work by hand

[00:33:38.0643] <Michael Ficarra>
for any browser vendors in the room, that tool *could* be your browser if you implement CSS Paged Media btw

[00:34:03.0009] <ryzokuken (TC39 üá´üáÆ)>
cc nicolo-ribaudo üëÄ

[00:34:17.0625] <ryzokuken (TC39 üá´üáÆ)>
 * ^ nicolo-ribaudo üëÄ

[00:37:38.0609] <littledan>
Is ryzokuken audible from remote?

[00:37:49.0999] <Aki>
yes

[00:41:09.0063] <Michael Ficarra>
@littledan:matrix.org in-room audio appears to be modulated separately from zoom audio

[00:41:22.0208] <Michael Ficarra>
if something sounds off to you, ask @eemeli:mozilla.org to adjust it

[00:42:11.0720] <Michael Ficarra>
FYI 402 editors: here is the in-progress editorial conventions document that @bakkot:matrix.org mentioned in the 262 update: https://github.com/tc39/ecma262/wiki/Editorial-Conventions

[00:42:51.0133] <eemeli>
Yeah, in-room and remote audio are routed separately. The speakers on the wall are delivering sound from Zoom, while in-room is from the screen at the other end.

[00:42:56.0744] <littledan>
great bullets bakkot, thanks

[00:50:55.0259] <littledan>
sffc: I would prefer that we not add Gemini-produced summaries in the notes. Let's use our human intelligence to understand what the important points are.

[00:51:24.0585] <littledan>
everyone who wants AI-produced summaries can make them themselves

[00:51:51.0466] <nicolo-ribaudo>
Is the _<< Software identified by reference to the Ecma Standard* ("Software)">>_ in https://github.com/tc39/test262/blob/main/LICENSE#L1 a placeholder, or is it expected to be written like that?

[00:54:24.0594] <Michael Ficarra>
> <@littledan:matrix.org> everyone who wants AI-produced summaries can make them themselves

you're *so close*

[00:54:58.0072] <littledan>
(I don't want to read an AI summary of anything)

[00:55:15.0214] <littledan>
(and it is confusing if they're included in our docs because it looks authoritative)

[00:55:25.0357] <Michael Ficarra>
I agree with both of those statement

[00:55:30.0073] <Michael Ficarra>
* I agree with both of those statements

[00:55:59.0738] <Aki>
holy shit toronto and montreal were merged?

[00:56:13.0908] <Aki>
politically not insignificant

[00:56:19.0300] <Chris de Almeida>
it's Torontreal now

[00:56:34.0128] <Chris de Almeida>
whoops, this isn't TDZ

[00:56:34.0459] <Rob Palmer>
Montronto surely

[00:57:06.0266] <Michael Ficarra>
üëÆ ‚û°Ô∏è #temporaldeadzone:matrix.org

[00:59:20.0345] <hax (HE Shi-Jun)>
typoÔºö chongquing should be chongqing

[00:59:42.0673] <littledan>
> <@haxjs:matrix.org> typoÔºö chongquing should be chongqing

This is a historical entry in TZDB; there are a lot of outdated latinizations there

[01:00:26.0879] <littledan>
(several of the other forwardings discussed were examples of the same)

[01:02:02.0083] <hax (HE Shi-Jun)>
I never see "asia/chongquing" spelling, google shows nothing...

[01:02:37.0411] <rkirsling>
yeah that's an interesting typo that only an English speaker could make

[01:02:46.0464] <littledan>
oh I stand corrected

[01:03:18.0213] <Michael Ficarra>
I thought the whole point of the slide was that some of the timezones were being renamed due to historical misspellings

[01:03:26.0023] <hax (HE Shi-Jun)>
Anyway, "asia/chongqing" -> "asia/shanghai" is a mistake IMO, always cause confusion and accidentaly cause bug üòÇ

[01:03:26.0339] <rkirsling>
(the outdated romanization would be chungking, fwiw)

[01:04:23.0495] <hax (HE Shi-Jun)>
Though it's not the bug of JS, but the bug of TZDB.

[01:06:24.0804] <littledan>
> <@haxjs:matrix.org> Anyway, "asia/chongqing" -> "asia/shanghai" is a mistake IMO, always cause confusion and accidentaly cause bug üòÇ

why is that? is there a chance that China will split into multiple timezones?

[01:08:22.0550] <Richard Gibson>
https://github.com/eggert/tz/blob/d56ae6ee85d496ef67f0428e81060341ec70cec2/backward#L311

[01:08:36.0944] <Chris de Almeida>
> <@littledan:matrix.org> why is that? is there a chance that China will split into multiple timezones?

bit of a misconception there is only one

[01:08:40.0041] <Chris de Almeida>
`Asia/Urumqi`

[01:08:41.0249] <Richard Gibson>
 * https://github.com/eggert/tz/blob/d56ae6ee85d496ef67f0428e81060341ec70cec2/backward#L311
> `Link	Asia/Shanghai		Asia/Chungking	#= Asia/Chongqing`

[01:09:26.0262] <Chris de Almeida>
also different TZ for HK and Macau

[01:09:58.0654] <Chris de Almeida>
although those are UTC+8 same as CST

[01:11:28.0184] <hax (HE Shi-Jun)>
> <@littledan:matrix.org> why is that? is there a chance that China will split into multiple timezones?

It's irrelevant to possible multiple timezones. Asia/Chongqing is a BUG due to misunderstanding of historical timezones in World War II. It never be used broadly in practice in the history. Or if it was been used, it already have no usage from 1950. So keep Asia/chongqing in the TZDB always cause confusion to Chinese programmers and users, especially some users might change the timezone to it and in edge cases it cause weird bugs in the historical dates.

[01:12:59.0643] <littledan>
> <@haxjs:matrix.org> It's irrelevant to possible multiple timezones. Asia/Chongqing is a BUG due to misunderstanding of historical timezones in World War II. It never be used broadly in practice in the history. Or if it was been used, it already have no usage from 1950. So keep Asia/chongqing in the TZDB always cause confusion to Chinese programmers and users, especially some users might change the timezone to it and in edge cases it cause weird bugs in the historical dates.

Great, so sounds like the merge is what should happen

[01:13:51.0887] <JaseW>
TCQ Revolutions

[01:13:53.0531] <hax (HE Shi-Jun)>
> <@littledan:matrix.org> Great, so sounds like the merge is what should happen

Well I think it should be deleted, not merged.. but It might be the deep design philosophy of TZDB which I don't fully agree with.

[01:13:56.0647] <littledan>
Meta: Please link your slides from the agenda so it's easier for folks to follow along (and link the slides from the notes)

[01:14:24.0502] <littledan>
> <@haxjs:matrix.org> Well I think it should be deleted, not merged.. but It might be the deep design philosophy of TZDB which I don't fully agree with.

so if someone uses it, an exception should be thrown, rather than redirecting them to CST?

[01:14:48.0847] <littledan>
Christian Ulbrich: After the presentation, please paste your slide link in the notes

[01:16:08.0854] <ryzokuken (TC39 üá´üáÆ)>
> <@haxjs:matrix.org> Well I think it should be deleted, not merged.. but It might be the deep design philosophy of TZDB which I don't fully agree with.

unfortunately that's not how TZDB is managed, yeah üòï 

[01:16:30.0986] <ryzokuken (TC39 üá´üáÆ)>
so all historic or just incorrect timezones need to stay forever although they could be linked to a more relevant zone

[01:16:46.0098] <hax (HE Shi-Jun)>
> <@littledan:matrix.org> so if someone uses it, an exception should be thrown, rather than redirecting them to CST?

If it's really "merged", I think it's ok. But in fact it will report differently in old dates in 194x ~ 195x. As I understand, TZDB never ensure correctness before 1970, but most OS still use TZDB history part, which IMO is bad, and cause problems.

[01:21:31.0129] <hax (HE Shi-Jun)>
> <@haxjs:matrix.org> If it's really "merged", I think it's ok. But in fact it will report differently in old dates in 194x ~ 195x. As I understand, TZDB never ensure correctness before 1970, but most OS still use TZDB history part, which IMO is bad, and cause problems.

Note "Asia/chongqing" is especially bad case , because in some old version TZDB it even report different time to CST in 198x dates.

[01:27:59.0277] <hax (HE Shi-Jun)>
> <@usharma:igalia.com> so all historic or just incorrect timezones need to stay forever although they could be linked to a more relevant zone

But there were another three China historical timezones in old TZDB and have been deleted, only Asia/Chongqing is merged, not sure why they keep it, IMO they are just from same misunderstand.

[01:28:38.0882] <ryzokuken (TC39 üá´üáÆ)>
> <@haxjs:matrix.org> But there were another three China historical timezones in old TZDB and have been deleted, only Asia/Chongqing is merged, not sure why they keep it, IMO they are just from same misunderstand.

interesting! yeah I have no clue but I'm curious so I'd try to dig around to see why

[01:29:05.0147] <littledan>
> <@haxjs:matrix.org> If it's really "merged", I think it's ok. But in fact it will report differently in old dates in 194x ~ 195x. As I understand, TZDB never ensure correctness before 1970, but most OS still use TZDB history part, which IMO is bad, and cause problems.

Yes, ICU and JS implementations tend to implement this historical part

[01:39:31.0787] <nicolo-ribaudo>
bakkot A few weeks ago I was writing my own source maps decoder, which use base64 but in a weird way: 6-bit-bytes should not be rearranged in 8-bit-bytes, but left as they are (or padded with a leading `00`): `ABCD` is not `[0, 16, 131]` but `[0, 1, 2, 3]`.
The proposals does _not_ support doing anything like this, right? (it's a quite niche use case so I'm not expecting it to, but I'm wondering if I missed something)

[01:39:49.0704] <bakkot>
correct

[01:40:17.0997] <bakkot>
but Michael Ficarra's iterator chunking proposal + flatMap would get you there!

[01:40:44.0549] <bakkot>
actually no it wouldn't, reading closer

[01:41:51.0103] <bakkot>
I guess that's just `[...string].map(x => Uint8Array.fromBase64(x + 'AAA')[0])`

[01:42:37.0696] <bakkot>
or... something like that anyway

[01:42:47.0931] <nicolo-ribaudo>
Oh yes that would work

[01:44:42.0159] <hax (HE Shi-Jun)>
> <@littledan:matrix.org> Yes, ICU and JS implementations tend to implement this historical part

Yeah, even Asia/Shanghai have some weird historical part. So in current js/web application, there is no easy way to represent CST (China standard time) for old dates (just like proleptic Gregorian calendar). It seems the design flaw of TZDB?

[01:45:21.0661] <littledan>
has this feedback been raised to the tzdb mailing list? (we're not really in a position to manage a better tzdb here in TC39)

[01:46:00.0660] <bakkot>
 * I guess that's just `[...string].map(x => Uint8Array.fromBase64(x + 'AAA')[0] >> 2)`

[01:49:25.0098] <sffc>
On the topic of time zones: TZDB and CLDR have both fairly explicitly decided to not prioritize pre-1970 transitions (and especially not pre-WWII transitions) because they were kind of a mess and documentation is kind-of lacking.

[01:50:43.0445] <sffc>
My understanding is that some of the merges are from time zones that had historic differences but have been the same since 1970

[01:52:23.0719] <bakkot>
re: `Symbol.isConcatSpreadable`, not only does no one use it, but also if you do use it then all uses of `Array.p.concat` anywhere on your page get slower in V8: https://www.tines.com/blog/understanding-why-our-build-got-15x-slower-with-webpack-5

[01:57:39.0089] <hax (HE Shi-Jun)>
Is it also get slower in FF/Webkit? Isn't that the bug of v8?

[01:58:02.0666] <bakkot>
it's not a bug, it's an intentional design decision

[01:58:52.0084] <bakkot>
FF and Webkit have similar things though I don't know if they have this specific thing

[02:01:17.0295] <Duncan MacGregor>
There is always going to be a trade off when deoptimising for things likes `isConcatSpreadable`. Just deopting at the particular sites you'll likely use more resources than just noting that the possibility exists everywhere.

[03:20:18.0931] <Luca Casonato>
The `AsyncIterator.propotype.split` thing looks nice

[03:24:20.0116] <Luca Casonato>
I wonder if we can combine the ideas from `split`, but still not require combining  a `split` and `merge`. For example:

```
const parallel = iter.parallelMap(5, (iter) => {
  return iter.map(mapFn).filter(filterFn)
});
```

Would be the same as

```
const parallel = AsyncIterator.merge(
  iter.split(5).map((iter) => {
    return iter.map(mapFn).filter(filterFn);
  })
);
```

[03:24:34.0646] <Luca Casonato>
 * I wonder if we can combine the ideas from `split`, but still not require combining  a `split`, `map` and `merge`. For example:

```
const parallel = iter.parallelMap(5, (iter) => {
  return iter.map(mapFn).filter(filterFn)
});
```

Would be the same as

```
const parallel = AsyncIterator.merge(
  iter.split(5).map((iter) => {
    return iter.map(mapFn).filter(filterFn);
  })
);
```

[03:35:02.0751] <Michael Ficarra>
@aclaymore:matrix.org that's what semaphores are for

[03:44:48.0805] <bakkot>
very pleased to have used 44minutes 30 seconds of a 45 minute timebox

[03:45:01.0756] <bakkot>
> <@michaelficarra:matrix.org> @aclaymore:matrix.org that's what semaphores are for

which we also don't have

[03:45:02.0168] <ryzokuken (TC39 üá´üáÆ)>
like a pro

[03:46:23.0594] <Michael Ficarra>
@bakkot:matrix.org yes but I would prefer the concurrency-limiting function helper anyway

[03:56:25.0040] <bakkot>
> <@lucacasonato:matrix.org> I wonder if we can combine the ideas from `split`, but still not require combining  a `split`, `map` and `merge`. For example:
> 
> ```
> const parallel = iter.parallelMap(5, (iter) => {
>   return iter.map(mapFn).filter(filterFn)
> });
> ```
> 
> Would be the same as
> 
> ```
> const parallel = AsyncIterator.merge(
>   iter.split(5).map((iter) => {
>     return iter.map(mapFn).filter(filterFn);
>   })
> );
> ```

yeah I was thinking about something like this. it's a very weird signature but once you learn to use it I think it does exactly what you want in many cases. a cute thing is that you can pass an async generator as the second argument:

```
iter.parallelMap(5,  async function*(vals) { for await (let item of vals) { yield item + 2 } })
```
or whatever

[03:56:40.0843] <bakkot>
 * yeah I was thinking about something like this. it's a very weird signature but once you learn to use it I think it does exactly what you want in many cases. a cute thing is that you can pass an async generator as the second argument:

```
iter.parallelMap(5, async function* (vals) { for await (let item of vals) { yield item + 2 } })
```

or whatever

[03:58:04.0164] <bakkot>
it does not immediately resolve the question of consuming, but I think that could just be a second function; `iter.concurrentForEach` or something

[03:58:20.0562] <bakkot>
 * it does not immediately resolve the question of consuming without producing a new iterator, but I think that could just be a second function; `iter.concurrentForEach` or something

[03:59:00.0318] <Michael Ficarra>
the note-taker is double-spacing sentences again, are we just gonna fix that up in post?

[03:59:14.0950] <bakkot>
```
let vals = iter.concurrentMap(5, async_generator);

for await (let item of vals) ...
```
and
```
let promise = iter.concurrentForEach(5, async_function);

await promise;
```

[03:59:44.0754] <bakkot>
 * ```
let vals = iter.concurrentMap(5, async_generator_taking_iterator);

for await (let item of vals) ...
```

and

```
let promise = iter.concurrentForEach(5, async_function_taking_iterator);

await promise;
```

[04:00:16.0507] <bakkot>
though maybe `concurrentForEach` would take a `T => void` rather than an `Iterator<T> => void`? unclear

[04:00:53.0393] <bakkot>
(which would make that a bad choice of names)

[04:01:21.0319] <Aki>
> <@michaelficarra:matrix.org> the note-taker is double-spacing sentences again, are we just gonna fix that up in post?

absolutely

[04:01:26.0896] <Aki>
i have a regex for it

[04:03:36.0239] <Michael Ficarra>
k good then we don't need to bug them about it

[04:17:34.0061] <Ashley Claymore>
Option 6 (a-la acorn):

```
const errors = [];
...format(..., { onError: errors });
if (errors.length) { ...}
```

to avoid inline callbacks

[04:23:32.0581] <bakkot>
i can no longer stay awake, but my bot will continue being in the meeting. please don't be misled by its presence, it is just a computer and cannot (yet?) represent my opinions for me

[04:25:08.0596] <bakkot>
for Error.isError, I'm not objecting to stage 2, but I still have reservations about whether it is motivated. i would like it to have strong from other delegates, and the reasons they want it to be captured, before it advances. also I do want to say that it absolutely must consider dom exceptions to be errors; users should not be exposed to that distinction.

[04:34:36.0109] <Luca Casonato>
> <@michaelficarra:matrix.org> @aclaymore:matrix.org that's what semaphores are for

straw man proposal: https://github.com/lucacasonato/proposal-semaphore

[04:34:46.0179] <Luca Casonato>
> <@michaelficarra:matrix.org> @aclaymore:matrix.org that's what semaphores are for

 * straw person proposal: https://github.com/lucacasonato/proposal-semaphore

[04:35:09.0928] <Michael Ficarra>
@lucacasonato:matrix.org lol noooo why?

[04:35:23.0626] <Michael Ficarra>
> @bakkot yes but I would prefer the concurrency-limiting function helper anyway

[04:35:47.0228] <Luca Casonato>
Michael Ficarra: It actually does that too - `semaphore.wait()` is this

[04:36:12.0610] <Luca Casonato>
 * Michael Ficarra: It actually does that too - `semaphore.wait()` is this (minus the wrapping itself)

[04:36:25.0127] <Michael Ficarra>
@lucacasonato:matrix.org that's backwards though

[04:36:44.0052] <mgaudet>
(Do we have a test262 dashboard that has v8 and sm on it? I have https://test262.fyi/ in my history, but this seems incomplete at the moment) 

[04:37:10.0399] <Luca Casonato>
> <@mgaudet:mozilla.org> (Do we have a test262 dashboard that has v8 and sm on it? I have https://test262.fyi/ in my history, but this seems incomplete at the moment)

It's just bugged at the moment - it has V8 and SM usually

[04:37:11.0890] <Michael Ficarra>
`let limitedFunction = fn.limitConcurrency(5)` and then pass `limitedFunction` around in place of `fn`

[04:37:50.0313] <Michael Ficarra>
> <@mgaudet:mozilla.org> (Do we have a test262 dashboard that has v8 and sm on it? I have https://test262.fyi/ in my history, but this seems incomplete at the moment) 

https://github.com/CanadaHonk/test262.fyi/issues/56

[04:38:00.0477] <ptomato>
> <@mgaudet:mozilla.org> (Do we have a test262 dashboard that has v8 and sm on it? I have https://test262.fyi/ in my history, but this seems incomplete at the moment) 

Was just wondering that as well, since I based my remark about implementation status on it üòÖ

[04:38:30.0388] <Luca Casonato>
> <@michaelficarra:matrix.org> @lucacasonato:matrix.org that's backwards though

```js
const semaphore = new Semaphore(12)
function wrap(cb) {
  return (...args) => semaphore.wait(cb);
}
```

I'll add this helper as an open question to the doc :)

[04:39:07.0262] <Michael Ficarra>
yeah but that allows you to wait on the semaphore with multiple functions, right?

[04:39:48.0711] <Luca Casonato>
Yes - I mean isn't that what you want?

[04:40:02.0913] <Luca Casonato>
> <@michaelficarra:matrix.org> `let limitedFunction = fn.limitConcurrency(5)` and then pass `limitedFunction` around in place of `fn`

This lacks flex

[04:40:07.0632] <Michael Ficarra>
no, it's inverted

[04:40:27.0107] <Michael Ficarra>
I want consumers to not have to even know that there's limiting going on

[04:40:57.0802] <Michael Ficarra>
think about it this way: if I am currently passing a function to someone, I want to swap it out with a concurrency-limited one without them changing their implementation

[04:41:14.0857] <Michael Ficarra>
yes I could do that with your wrap helper, and in fact that's how I will always do it

[04:41:30.0561] <Michael Ficarra>
so if I always do it that way, there's no reason to expose the semaphore directly

[04:46:33.0077] <Luca Casonato>
Sure - that makes sense. But there are use cases where this doesn't work - for example if you have `execute` and `query` functions that both operate on the same database, and you want to limit both together.

Another common case for this is when you want to limit the number of FS ops, but there are many different ops. For example you want to limit the number of `stat()`, `realpath()` etc all with the same limiter

Another use case that wrapping is not expressive enough for is if you want to limit the number of open files. Because you "acquire" at every `open` call, but only release once a file handle is explicitly closed.

Also one could propose that we make `Semaphore` sharable across agents :)

[04:49:30.0204] <Luca Casonato>
added a `wrap` method:

```
const semaphore = new Semaphore(5);

const wrappedFunction = semaphore.wrap(async () => {
  // Do some work
});

async function doWork() {
  await wrappedFunction();
}
```

[04:49:34.0938] <Luca Casonato>
 * added a `wrap` method:

```js
const semaphore = new Semaphore(5);

const wrappedFunction = semaphore.wrap(async () => {
  // Do some work
});

async function doWork() {
  await wrappedFunction();
}
```

[04:51:52.0179] <Michael Ficarra>
> <@lucacasonato:matrix.org> Sure - that makes sense. But there are use cases where this doesn't work - for example if you have `execute` and `query` functions that both operate on the same database, and you want to limit both together.
> 
> Another common case for this is when you want to limit the number of FS ops, but there are many different ops. For example you want to limit the number of `stat()`, `realpath()` etc all with the same limiter
> 
> Another use case that wrapping is not expressive enough for is if you want to limit the number of open files. Because you "acquire" at every `open` call, but only release once a file handle is explicitly closed.
> 
> Also one could propose that we make `Semaphore` sharable across agents :)

it does if you virtualise the database through these

[04:52:26.0280] <Luca Casonato>
yeah, but that seems rather unergonomic?

[04:55:28.0516] <Luca Casonato>
You can always do it by creating a function like `(function call(cb, ...args) => cb(args)).limitConcurrency(5)` - but i mean that is very messy and it also does not layer well with `using` - also it's very unergonomic when you are limiting a resource, not a single call

[04:55:48.0955] <Luca Casonato>
 * You can always do it by creating a function like `const call = ((cb, ...args) => cb(args)).limitConcurrency(5)` - but i mean that is very messy and it also does not layer well with `using` - also it's very unergonomic when you are limiting a resource, not a single call

[04:55:50.0317] <Michael Ficarra>
not really, it moves the limiting further inward into like a "kernel"

[04:55:56.0509] <Michael Ficarra>
we should talk over snack break

[04:55:58.0464] <Michael Ficarra>
I want a snack

[04:56:03.0050] <Luca Casonato>
sure :)

[05:02:30.0160] <hax (HE Shi-Jun)>
littledan: 

Regarding `function.sent`, we have discussed use cases and possible solutions in several past meetings. However, there is no consensus on whether the use cases are strong enough to support introducing a syntactic solution. Although I generally still believe this is a problem worth addressing, perhaps solving it through a more general feature like function decorators in the form of an API is more promising than introducing entirely new syntax. Therefore, I hope to revisit this proposal after the function decorator proposal advances to the next stage.

[05:07:34.0223] <ljharb>
good morning. to be clear about Iterator.concat, the behavior I think users will expect has nothing to do with Symbol.concatSpreadable, it's that array concat takes an array or a scalar, and anything with the name concat should do the same (take a container or a thing contained).

[05:07:48.0669] <ljharb>
 * good morning. to be clear about Iterator.concat, the behavior I think users will expect has nothing to do with Symbol.concatSpreadable (which is regrettable and nobody should expect it), it's that array concat takes an array or a scalar, and anything with the name concat should do the same (take a container or a thing contained).

[05:07:54.0966] <ljharb>
 * good morning. to be clear about Iterator.concat, the behavior I think users will expect has nothing to do with Symbol.isConcatSpreadable (which is regrettable and nobody should expect it), it's that array concat takes an array or a scalar, and anything with the name concat should do the same (take a container or a thing contained).

[05:09:36.0714] <ljharb>
 * good morning. to be clear about Iterator.concat, the behavior I think users will expect has nothing to do with Symbol.isConcatSpreadable (which is regrettable and nobody should expect it), it's that array concat takes both arrays or scalars, and anything with the name concat should do the same (take both containers or things contained).

[05:15:29.0761] <ljharb>
link to present for Promise.try: https://github.com/tc39/proposal-promise-try/issues/15

[05:17:46.0151] <littledan>
> <@ljharb:matrix.org> good morning. to be clear about Iterator.concat, the behavior I think users will expect has nothing to do with Symbol.isConcatSpreadable (which is regrettable and nobody should expect it), it's that array concat takes both arrays or scalars, and anything with the name concat should do the same (take both containers or things contained).

ah, sorry for any confusion caused by my misinterpretation

[05:19:04.0925] <Luca Casonato>
test262.fyi is sorta back ^^

[05:19:12.0103] <Michael Ficarra>
it's gradually filling

[05:19:30.0622] <ljharb>


links to present for RegExp.escape:
 - https://github.com/tc39/proposal-regex-escaping/issues/58
 - https://tc39.es/proposal-regex-escaping/


[05:20:01.0312] <littledan>
Congrats ljharb 

[05:20:07.0278] <littledan>
they wouldn't let me clap...

[05:21:51.0619] <littledan>
BTW volunteers welcome for doing the next proposal scrub

[05:32:01.0443] <Michael Ficarra>
I think we should retro the proposal scrub because I value it but it felt unproductive for some parts

[05:32:48.0362] <Ashley Claymore>
> <@haxjs:matrix.org> littledan: 
> 
> Regarding `function.sent`, we have discussed use cases and possible solutions in several past meetings. However, there is no consensus on whether the use cases are strong enough to support introducing a syntactic solution. Although I generally still believe this is a problem worth addressing, perhaps solving it through a more general feature like function decorators in the form of an API is more promising than introducing entirely new syntax. Therefore, I hope to revisit this proposal after the function decorator proposal advances to the next stage.

thanks! I've copied this into the notes in the appropriate section.

[05:34:22.0874] <hax (HE Shi-Jun)>
If do temp check, could we have a simple example to show the difference of two escape solutions ?

[05:34:35.0567] <Rob Palmer>
https://docs.google.com/document/d/19PqeLeKjdy9zTn4OAQEhQVI2zmAxUvZ7eCmnNrKQHeI/edit

[05:34:44.0264] <Rob Palmer>
Nicolo, can you share this on-screen

[05:35:56.0048] <Michael Ficarra>
> <@haxjs:matrix.org> If do temp check, could we have a simple example to show the difference of two escape solutions ?

`\x40` vs `\@`

[05:36:15.0024] <Michael Ficarra>
`for RegExp.escape('@')`

[05:36:23.0659] <Michael Ficarra>
* for `RegExp.escape('@')`

[05:36:48.0167] <Richard Gibson>
> <@haxjs:matrix.org> If do temp check, could we have a simple example to show the difference of two escape solutions ?

if we don't change, `RegExp.escape("$") === "\\$"`. If we do change, `RegExp.escape("$") === "\\x24"`

[05:39:39.0116] <ljharb>


links to present for Error.isError:
 - https://github.com/tc39/proposal-is-error?tab=readme-ov-file#use-cases
 - https://tc39.es/proposal-is-error/

[05:43:43.0014] <Rob Palmer>
I made a mistake of not stating Shu's comments on `RegExp.escape` so will read it out at the next break:

>V8 has no concerns for Stage 2.7.

>As for character vs hex code escapes, V8 can live with either outcome but weakly prefers character escapes. The future stability argument AFAIU is that choosing character escapes makes changing the behavior of character escapes in the future even harder. But it is already very hard to change non-throwing behavior to new non-throwing behavior. We don't understand why this would make it meaningfully harder.

[05:49:47.0894] <Michael Ficarra>
> <@robpalme:matrix.org> I made a mistake of not stating Shu's comments on `RegExp.escape` so will read it out at the next break:
> 
> >V8 has no concerns for Stage 2.7.
> 
> >As for character vs hex code escapes, V8 can live with either outcome but weakly prefers character escapes. The future stability argument AFAIU is that choosing character escapes makes changing the behavior of character escapes in the future even harder. But it is already very hard to change non-throwing behavior to new non-throwing behavior. We don't understand why this would make it meaningfully harder.

that was exactly my opinion

[05:50:58.0145] <littledan>
doesn't it throw an exception if you forget to call super(), unless you take the extreme step of returning something other than this?

[05:51:04.0652] <littledan>
 * doesn't it throw an exception if you forget to call super(), unless you take the extreme step of returning something other than this/undefined?

[05:51:20.0570] <Richard Gibson>
> <@michaelficarra:matrix.org> that was exactly my opinion

I think that's a misunderstanding; the changes would not be from non-throwing to throwing but rather the other way around (such that e.g. `/\@/u` becomes valid)

[05:52:04.0465] <ryzokuken (TC39 üá´üáÆ)>
(possible) hot take: brand checking is orders of magnitude more important (and less icky) than type checking

[05:52:31.0073] <littledan>
> <@usharma:igalia.com> (possible) hot take: brand checking is orders of magnitude more important (and less icky) than type checking

why contrast them? they are both important and just do different things.

[05:52:38.0532] <ryzokuken (TC39 üá´üáÆ)>
oh

[05:52:39.0509] <ryzokuken (TC39 üá´üáÆ)>
true

[05:53:08.0080] <ryzokuken (TC39 üá´üáÆ)>
I guess more accurately: runtime brand checks are important to complement type checks

[05:54:59.0552] <nicolo-ribaudo>
Chris de Almeida (TCQ) Because it's a revoked proxy, so you should not be able to inspect its state

[05:55:02.0866] <nicolo-ribaudo>
Array.isArray does the same

[05:56:17.0012] <Michael Ficarra>
@usharma:igalia.com give me one reason for brand checks

[05:56:58.0896] <ryzokuken (TC39 üá´üáÆ)>
well, you might want to check the "type" of something on runtime? I use code that uses `Array.isArray` all the time?

[05:57:11.0537] <ryzokuken (TC39 üá´üáÆ)>
as do many others I believe

[05:57:13.0758] <littledan>
we're in quite violent agreement about Error.isError returning true for DOMException.

[05:58:56.0950] <Michael Ficarra>
@usharma:igalia.com you should be duck typing, though maybe you need to know whether the object has a magic length property for some reason?

[05:59:13.0448] <ryzokuken (TC39 üá´üáÆ)>
I can give a more specific example from a recent function I wrote but in general when dealing with heterogeneous objects and collections like we do in JS, it's quite useful

[05:59:23.0072] <Michael Ficarra>
like I can see testing for Arrays due to the magic length property and mapped arguments objects because of their magic assignment behaviour

[05:59:44.0014] <Michael Ficarra>
in *general*, you definitely shouldn't be brand checking

[05:59:52.0730] <Michael Ficarra>
those two cases are accounting for language magic

[06:00:17.0081] <ryzokuken (TC39 üá´üáÆ)>
idk what to say... I disagree?

[06:00:35.0696] <ryzokuken (TC39 üá´üáÆ)>
I don't think the stuff I'm writing would be better handled _without_ brand checks

[06:04:32.0613] <Richard Gibson>
> <@michaelficarra:matrix.org> like I can see testing for Arrays due to the magic length property and mapped arguments objects because of their magic assignment behaviour

is there a way to identify a mapped arguments object?

[06:05:01.0824] <ljharb>
> <@gibson042:matrix.org> is there a way to identify a mapped arguments object?

no, this is indeed another missing brand check i seem to always forget about

[06:05:14.0435] <Michael Ficarra>
@ljharb:matrix.org don't you dare

[06:05:15.0775] <ljharb>
> <@gibson042:matrix.org> is there a way to identify a mapped arguments object?

 * no, this is indeed another missing brand check i seem to always forget about. see https://npmjs.com/is-arguments

[06:05:17.0324] <nicolo-ribaudo>
> <@gibson042:matrix.org> is there a way to identify a mapped arguments object?

He said "all _instances_ except for error have a brand check", I found the wording to be carefully chosen :)

[06:05:38.0106] <nicolo-ribaudo>
Can I stop screen sharing?

[06:05:44.0294] <ljharb>
sure, thanks

[06:08:54.0820] <ryzokuken (TC39 üá´üáÆ)>
Michael Ficarra can you expand a bit on "icky"? What's specifically wrong with explicit brand checks apart from just the added cost of an additional static method?

[06:12:28.0950] <Michael Ficarra>
@littledan:matrix.org I think you hit on the key point there: the opposition is to brand checks that are not otherwise justified. Like *all features* we consider, we should require them to have a good reason to exist.

[06:14:47.0592] <Michael Ficarra>
@usharma:igalia.com this is basically "nominal typing > structural typing" but at the term level

[06:24:33.0087] <littledan>
> <@michaelficarra:matrix.org> @littledan:matrix.org I think you hit on the key point there: the opposition is to brand checks that are not otherwise justified. Like *all features* we consider, we should require them to have a good reason to exist.

so the action item is for supporters and opponents to come together and make a shared set of guidelines. I'd prefer an answer which is not, "make sure you sneak in an operation that does a brand check without being just a brand check operation."

[06:25:30.0459] <littledan>
because this is what proposal champions currently have to do! it just papers over the disagreement about whether the brand check is justified.

[06:25:38.0932] <Michael Ficarra>
@littledan:matrix.org how is that a bad situation if that operation has been independently sufficiently justified

[06:25:43.0751] <Michael Ficarra>
* @littledan:matrix.org how is that a bad situation if that operation has been independently sufficiently justified?

[06:26:19.0259] <Michael Ficarra>
wanting the same thing for different reasons is how dispute resolution happens all the time, and it's fine

[06:26:54.0590] <littledan>
it is super confusing; if the objection from person A is "this can't move forward unless it adds a brand check" and person B is simultaneously saying "a brand check is not justified" then the champion ends up finding an *excuse* for a brand check by shaping the API such that it's "natural" to include one, such that independent motivation can be argued for. It's super confusing!

[06:27:22.0739] <littledan>
this is a particularly weird set of disagreements, among the various ones we have. It doesn't amount to a coherent design principle.

[06:27:51.0324] <littledan>
it seems like you have a different set of things you're looking for in "what makes a brand check justified" than ljharb does. Maybe you can work together on a common set of criteria.

[06:28:39.0366] <littledan>
the answer does not need to be that everything has a brand check; we should just find a common answer one way or another

[06:28:51.0702] <Michael Ficarra>
I think the majority of the committee agrees that brand checks are harmful for "normal" code

[06:29:14.0772] <Michael Ficarra>
this Error check was justified for like dev tooling

[06:29:28.0486] <ljharb>
i don't think that's actually true anymore

[06:29:29.0394] <Michael Ficarra>
it would be ideal if it was *less* ergonomic to discourage its use

[06:29:56.0246] <ljharb>
it was certainly true when the committee was 20 people, but we're much larger and have a much more "anchored in userland" set of experience represented than in the past

[06:30:09.0475] <littledan>
so, yes, if we can get consensus among the committee that brand checks are *not* required when making a new type of object with internal slots, then yeah that's a way through

[06:30:27.0372] <littledan>
*if*

[06:31:45.0887] <Michael Ficarra>
@nicolo-ribaudo:matrix.org to be clear, I didn't actually have time to complete my review, but from the review I did do, it was fine

[06:32:14.0636] <littledan>
(not sure why Shu's question was directed specifically at implementers)

[06:40:42.0588] <hax (HE Shi-Jun)>
question: are defer namespace and normal namespace object always distinct? or only distinct when error?

[06:43:21.0097] <Richard Gibson>
> <@haxjs:matrix.org> question: are defer namespace and normal namespace object always distinct? or only distinct when error?

hax (HE Shi-Jun): can you get that on the queue?

[06:44:47.0526] <nicolo-ribaudo>
> <@michaelficarra:matrix.org> @nicolo-ribaudo:matrix.org to be clear, I didn't actually have time to complete my review, but from the review I did do, it was fine

2.7 would be conditinal on editorial reviews

[06:45:03.0669] <nicolo-ribaudo>
> <@haxjs:matrix.org> question: are defer namespace and normal namespace object always distinct? or only distinct when error?

Always distinct because when you create them you don't know yet if the module will error or not

[06:45:50.0260] <hax (HE Shi-Jun)>
> <@gibson042:matrix.org> hax (HE Shi-Jun): can you get that on the queue?

Added.

[06:46:13.0542] <hax (HE Shi-Jun)>
> <@nicolo-ribaudo:matrix.org> Always distinct because when you create them you don't know yet if the module will error or not

Seems reasonable. Thank u!

[06:46:37.0387] <JaseW>
> <@mgaudet:mozilla.org> (Do we have a test262 dashboard that has v8 and sm on it? I have https://test262.fyi/ in my history, but this seems incomplete at the moment)

It's back up fully now https://test262.fyi

[06:47:45.0407] <mgaudet>
:) Still waiting for legacy regexp results tho

[06:50:56.0982] <ptomato>
> <@mgaudet:mozilla.org> :) Still waiting for legacy regexp results tho

a bit weird. this is what it looked like when I loaded it a couple of hours ago:

[06:51:05.0215] <ptomato>
now it's not showing v8 anymore

[06:51:36.0715] <mgaudet>
... huh. (kudos to Canadahonk for building this tho -- its a bit weird it's become load bearing?) 

[06:58:42.0333] <Jack Works>
if the fake module namespace object is created, it will be created each import

[06:59:13.0610] <Jack Works>
this usually happens in getting the ES namespace object of a  CommonJS module

[07:01:37.0495] <Jack Works>
for real ES Modules, webpack just returns the internal module namespace object. for non-strict semantics, (that `import * as ns` is equal to `ns = require()`), it's the same

[07:08:45.0442] <nicolo-ribaudo>
Thanks for investigating!

[07:08:52.0672] <nicolo-ribaudo>
Babel does indeed the same for CJS imports

[07:57:19.0762] <shu>
littledan: sorry wasn't there for the proposal scrub thing. you can always check chromestatus when in doubt

[07:57:29.0433] <shu>
that's usually kept up to date

[08:07:33.0447] <bakkot>
> <@lucacasonato:matrix.org> Sure - that makes sense. But there are use cases where this doesn't work - for example if you have `execute` and `query` functions that both operate on the same database, and you want to limit both together.
> 
> Another common case for this is when you want to limit the number of FS ops, but there are many different ops. For example you want to limit the number of `stat()`, `realpath()` etc all with the same limiter
> 
> Another use case that wrapping is not expressive enough for is if you want to limit the number of open files. Because you "acquire" at every `open` call, but only release once a file handle is explicitly closed.
> 
> Also one could propose that we make `Semaphore` sharable across agents :)

you can have a "wrap" which takes a set of functions and limits concurrency across all of them. prior art: https://www.npmjs.com/package/throat

[08:12:37.0848] <Luca Casonato>
> <@bakkot:matrix.org> you can have a "wrap" which takes a set of functions and limits concurrency across all of them. prior art: https://www.npmjs.com/package/throat

https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$jBz5BAYiJ6u9yymLBwDZTutvHhDE7LZooG0Q36NMxxo?via=mozilla.org&via=matrix.org

[08:13:44.0943] <bakkot>
I don't know what your snippet is supposed to be doing

[08:15:49.0618] <bakkot>
the `wrap` thing I'm suggesting would be like

```
let [limitedExecute, limitedQuery] = AsyncFunction.limitConcurrency(5, [execute, query])
```
or something like that

[08:17:16.0049] <bakkot>
or the api in `throat` gives you a `limiter` you can call repeatedly to draw on the same lock, as in

```
let limiter = limitConcurrency(2);
let limitedExecute = limiter(execute);
let limitedQuery = limiter(query);
```
which also works and is more flexible

[08:34:42.0008] <shu>
> <@gibson042:matrix.org> I think that's a misunderstanding; the changes would not be from non-throwing to throwing but rather the other way around (such that e.g. `/\@/u` becomes valid)

i meant non-throwing to non-throwing, because `\@` already is a literal escape that doesn't throw

[08:35:12.0982] <shu>
or was the scenario you were thinking of in u and v modes only?

[08:42:16.0816] <bakkot>
ljharb: re: `isError`, another thing I forgot to mention is that I am not OK having any more places that replicate `Array.isArray`'s proxy-piercing behavior

[08:42:41.0946] <bakkot>
that may mean that having a static method for this is incompatible with the SES folks' goal of practical membrane transparency

[08:48:25.0347] <shu>
bakkot: say more? is the rationale in the notes?

[08:48:39.0636] <bakkot>
from the last time this was discussed, I think, yes

[08:49:22.0184] <bakkot>
the SES goal is that a membrane for a thing "works like" that thing, as long as you're using the normal interface and not bypassing the object by doing e.g. `Map.prototype.call(membrane)`

[08:50:02.0452] <bakkot>
the way a membrane for a Map works is, its methods are themselves proxied so that they are able to reach into the underlying data structure of the proxy

[08:50:13.0350] <bakkot>
but that doesn't work for static methods, since those come from outside of the membrane

[08:50:21.0320] <shu>
but why aren't you okay with having more places that pierce Proxies?

[08:50:26.0931] <bakkot>
oh

[08:50:35.0250] <bakkot>
couple of things

[08:50:44.0807] <bakkot>
first is just that it's conceptually gross

[08:50:51.0675] <bakkot>
second is that it makes any use of proxies harder

[08:51:12.0898] <bakkot>
for most of the proxy invariants, you can uphold them as you go by imposing them on your target object when they come up

[08:51:29.0387] <bakkot>
but for specifically "is it a function, an object, or an array", you have to decide that up-front

[08:51:37.0214] <bakkot>
the reason "array" is on that list is because `isArray` pierces proxies

[08:51:40.0236] <bakkot>
I don't want to expand that list

[08:52:33.0382] <bakkot>
from the point of view of proxies, there are three kinds of thing in the world; we shouldn't add a forth, especially a fourth which is just some random thing and not as fundamental as the existing three

[08:52:38.0525] <shu>
right, it is just true that it makes use of proxies harder. i'm trying to understand if that's now a general goal you have, or a concrete use case, or that since we have Proxies, we shouldn't go out of our way to make them harder to use

[08:53:07.0473] <shu>
but also this seems like a pretty fundamental disagreement that should've blocked stage 2?

[08:53:34.0709] <bakkot>
I am reluctantly OK with this going forward _without_ the proxy-piercing behavior

[08:53:39.0854] <bakkot>
so I don't think it needs to block stage 2

[08:54:00.0963] <bakkot>
unless someone else says that they are OK with it going forward _only_ with the proxy-piercing behavior, in which case that's unreconcilable

[08:54:04.0831] <shu>
ah, i missed that last part

[08:54:24.0705] <shu>
okay, sg

[08:55:01.0106] <bakkot>
re: goals, I am OK with making proxies harder to use for the benefit of other more frequent features, since I think proxies are a power-user feature already. but the "should it pierce proxies" question is _about_ proxies, so it makes sense to evaluate that question from the perspective of how it affects users of proxies

[08:55:07.0155] <bakkot>
 * re: goals, I am OK with making proxies harder to use for the benefit of other more frequently used features, since I think proxies are a power-user feature already. but the "should it pierce proxies" question is _about_ proxies, so it makes sense to evaluate that question from the perspective of how it affects users of proxies

[08:55:19.0900] <shu>
yes, that sounds reasonable

[08:56:49.0484] <bakkot>
> <@bakkot:matrix.org> unless someone else says that they are OK with it going forward _only_ with the proxy-piercing behavior, in which case that's unreconcilable

my understanding is that the SES people might not be ok with this going forward as a static method without the proxy-piercing behavior but this has not yet been hashed out. also they might not be OK with it going forward as a static method with either proxy-piercing or not-proxy-piercing for different reasons. but I can't speak for them.

[09:06:35.0264] <ljharb>
right - proxy piercing is def something to resolve in stage 2. Your constraint is noted, thanks :-)

[09:45:49.0587] <littledan>
> <@shuyuguo:matrix.org> littledan: sorry wasn't there for the proposal scrub thing. you can always check chromestatus when in doubt

Sorry I should have skipped asking about implementation status anyway‚Äîthose proposals were already too current. Next scrub we will focus on Stage 2 and, if time allows, Stage 1 proposals which haven‚Äôt been discussed in a while.

[10:30:56.0265] <ljharb>
seems like it'd be more effective to start at oldest and move to newer?

[12:58:47.0376] <littledan>
This is what we did within the stage. Probably I should have skipped the more recent ones. But I do think we have more of a responsibility to keep things up to date for higher stage things 

[12:59:19.0181] <littledan>
Also I don‚Äôt want to own scrubs; if someone else wants to run this topic next time, that would be great

[13:01:00.0717] <littledan>
And then other facilitators could try their own prioritization schemes

[13:01:15.0893] <ljharb>
i should be fully at the next two plenaries so i could do one

[13:33:51.0935] <Chris de Almeida>
> <@littledan:matrix.org> Also I don‚Äôt want to own scrubs; if someone else wants to run this topic next time, that would be great

is this a topic that we should just include by default at every plenary?


2024-06-12
[23:50:02.0151] <ptomato>
I'd be happy to do a scrub session as well

[00:09:46.0321] <Richard Gibson>
> <@shuyuguo:matrix.org> or was the scenario you were thinking of in u and v modes only?

right, because of `IdentityEscape[UnicodeMode] :: [~UnicodeMode] |SourceCharacter| but not |UnicodeIDContinue|` (almost all character escapes are valid in legacy mode)

[01:04:39.0809] <nicolo-ribaudo>
I just realised we'll have to figure out the PDF generation story also for the source maps spec üò≠

[01:07:35.0073] <nicolo-ribaudo>
Oh actually just printing to PDF from Firefox is good enough

[01:11:34.0797] <Michael Ficarra>
yeah tell that to Ecma

[01:19:36.0320] <littledan>
we'll all have until December to figure this out; it won't be until next meeting (at the absolute earliest) that we have something that we want to propose to TC39 to propose to the Ecma GA

[01:33:05.0490] <hax (HE Shi-Jun)>
Is the link of slides of current topic available?

[01:33:51.0106] <ryzokuken (TC39 üá´üáÆ)>
hax (HE Shi-Jun) will ask the speaker to post them

[02:00:21.0369] <littledan>
For the ShadowRealms topic, I've inserted the comment that I wanted to make in the notes, which was:

I recommend applying the criterion, ‚ÄúShadowRealms should contain the intersection of what‚Äôs in all conceivable environments‚Äù, which implies that they are missing everything to do with I/O [excluding import()], timers, DOM, etc. https://github.com/tc39/proposal-shadowrealm/issues/398#issuecomment-1939418911


[02:01:23.0061] <waldemar>
Bit-packing breaks down badly once concurrent threads are introduced. C++ found out about this the hard way.

[02:01:47.0322] <littledan>
I agree with the set of things that are spec'd as Exposed=* that Igalia has put together--they seem to be following this principle already.

[02:01:53.0696] <waldemar>
A key requirement is that writes to different variables must be independent.

[02:55:22.0811] <Aki>
> <@nicolo-ribaudo:matrix.org> I just realised we'll have to figure out the PDF generation story also for the source maps spec üò≠

i got u bb üòò

[02:57:00.0618] <Aki>
Does anyone want to volunteer to audit the PDF when it's ready? If a handful of volunteers took a few clauses each (just scrolling through and making sure there's no unfortunate page breaks mostly) then I'd feel a lot more confident with the final product

[02:57:19.0882] <Aki>
it's like 900 pages, my eyes keep glazing over

[03:00:54.0064] <Michael Ficarra>
@akirose:matrix.org I can take a look at it

[03:01:31.0102] <Aki>
Michael Ficarra: cool, i'll let you know when it's ready

[03:01:37.0227] <ryzokuken (TC39 üá´üáÆ)>
I volunteer especially if you also want someone to look through 402

[03:02:02.0603] <Aki>
I'm pretty confident there isn't gonna be stuff randomly missing or cut off. readability is my priority now.

[03:02:19.0195] <Aki>
ryzokuken (TC39 üá´üáÆ): yessss

[03:02:19.0431] <littledan>
could someone who's been in the zoom copy the slide link for the notes?

[03:02:22.0850] <Michael Ficarra>
yeah it's the finding random bits that *aren't* there that's the real hard part

[03:03:35.0479] <sffc>
Can someone share Ben's slides? I have an older link but it's not these latest slides

[03:03:51.0701] <Ashley Claymore>
The link was posted in zoom, but I wasn't in the call when it was posted

[03:03:56.0134] <Ashley Claymore>
so joining now can't see it

[03:04:04.0811] <Ashley Claymore>
if someone who was already in zoom could share that would be great

[03:05:08.0875] <eemeli>
https://docs.google.com/presentation/d/1WCdpcX4IpObi0CD1ftXA9QbZL5RSEGlYGXdqw3EfIdg/

[03:05:13.0875] <Ashley Claymore>
thanks!

[03:17:56.0049] <Duncan MacGregor>
I was going to ask about the [US survey foot](https://www.nist.gov/pml/us-surveyfoot), but apparently that's being retired.

[03:18:28.0368] <Duncan MacGregor>
It's definitely not in the units.xml, nor are any of the other historical survey feet that various countries have specified.

[03:34:55.0857] <Michael Ficarra>
@littledan:matrix.org I disagree that MDN is a good solution for discoverability of these values

[03:35:13.0552] <littledan>
> <@michaelficarra:matrix.org> @littledan:matrix.org I disagree that MDN is a good solution for discoverability of these values

Can you elaborate on that?

[03:38:46.0053] <Michael Ficarra>
an l10n expert may have enough familiarity with cultural differences to know to describe a speed unit as a road travel speed or a volume unit as volume of gasoline, but your average developer might just see something more generic (which has no special handling in their locale) and use that

[03:39:43.0170] <Michael Ficarra>
that's why I think this is great for l10n experts but I just don't see your average dev who has no interest in l10n being all that effective with it

[03:40:09.0597] <Michael Ficarra>
not without having read through 100s of possible special cases from all around the world

[03:40:23.0868] <littledan>
it's hard for me to understand what sort of documentation or API shape might support them better.

[03:40:53.0564] <Michael Ficarra>
for example, I may not think to describe a volume of milk differently than a volume of water because in the US they are measured the same, but in other locales that makes a difference

[03:41:11.0645] <Michael Ficarra>
exactly, I don't know the solution to make this more discoverable either

[03:46:32.0801] <Duncan MacGregor>
In my experience people will use the wrong units or usage contexts, I don't think you can stop that. Luckily the units defined in `units.xml` are fairly limited, and most of them are different enough that people should spot problems fairly quickly. Things like piints and gallons are the exception here because the various types are close enough to be problematic in real world use.

[03:47:55.0173] <ryzokuken (TC39 üá´üáÆ)>
> <@michaelficarra:matrix.org> for example, I may not think to describe a volume of milk differently than a volume of water because in the US they are measured the same, but in other locales that makes a difference

idk about that, I think people tend to do it when designing interfaces...

[03:48:18.0792] <ryzokuken (TC39 üá´üáÆ)>
like if you're writing an app that sells milk across different locales, you might care about it

[03:48:42.0828] <Michael Ficarra>
if you're writing a news article, you may not

[03:50:08.0089] <Duncan MacGregor>
> <@michaelficarra:matrix.org> if you're writing a news article, you may not

Yeah, but if you're writing a news article you'll measure things in Olympic swimming pools, whales, Wales, and other silliness. :-)

[03:50:52.0743] <Michael Ficarra>
"libraries of Congress" is a frequent one in the US...

[03:50:54.0795] <ryzokuken (TC39 üá´üáÆ)>
> <@michaelficarra:matrix.org> if you're writing a news article, you may not

sure but you'd most likely write a static article in a single language

[03:58:42.0874] <Michael Ficarra>
@usharma:igalia.com I don't think that's the direction new articles are moving. NYT very frequently has interactive visualisations to help tell the story. I would not be surprised if they are localising units in their articles.

[04:17:03.0484] <hax (HE Shi-Jun)>
Yeah, I really want ambient AbortSignal!

[04:18:10.0957] <rbuckton>
For the record, I'm very much opposed to it. It looks good on the surface, but has a terrible developer experience for anything more than the simplest base case

[04:18:49.0034] <Rob Palmer>
*** New agenda item ***

Please be aware a new item has been added to the end of the Agenda - last thing tomorrow.

**Discard Bindings update or Stage 2** - by rbuckton 

https://github.com/tc39/agendas/pull/1634

[04:20:10.0439] <hax (HE Shi-Jun)>
> <@rbuckton:matrix.org> For the record, I'm very much opposed to it. It looks good on the surface, but has a terrible developer experience for anything more than the simplest base case

Ok. But I really need some easy way to solve such simplest case ... It's really frustrating that debugging several hours and find that someone just forgotten to pass signal in some inner functions...

[04:21:32.0311] <rbuckton>
> <@haxjs:matrix.org> Ok. But I really need some easy way to solve such simplest case ... It's really frustrating that debugging several hours and find that someone just forgotten to pass signal in some inner functions...

Debugging is even harder when transparent things you can't even trace cause issues in the other direction. Finding a forgotten parameter is easy in comparison.

[04:30:25.0090] <rbuckton>
Adding magical capabilities that do an end run around existing code is a great way to cause headaches for package authors who now start getting issues filed against them because they break unexpectedly where they worked fine before.

[04:31:29.0961] <rbuckton>
Filing issues or sending upstream PRs to packages to add support for cancellation is annoying, yes, but it allows those package authors to consider the ramifications of such a change.

[04:33:25.0168] <hax (HE Shi-Jun)>
I understand the risk, maybe we can find some way to allow package authors opt in such magic, for example, add special symbol to the objects/functions/classes to denote it.

[04:36:33.0196] <rbuckton>
I think it's reasonable for someone to use an `AsyncContext` variable to establish their own magical transparent cancellation token, as it's on a case by case basis. I would still strongly discourage that practice, though. 

[04:40:07.0655] <Ashley Claymore>
> <@rbuckton:matrix.org> Debugging is even harder when transparent things you can't even trace cause issues in the other direction. Finding a forgotten parameter is easy in comparison.

> Debugging is even harder when transparent things you can't even trace

Maybe devtools could help show when Tasks get cancelled, and show the stack of what triggered the cancellation?

[04:40:13.0450] <rbuckton>
I spoke out against transparent cancellation mechanisms when Yehuda suggested them back in ~2017. They overcomplicate everything but 1-1 cancellation interactions. 

[04:40:24.0304] <hax (HE Shi-Jun)>
> <@rbuckton:matrix.org> I think it's reasonable for someone to use an `AsyncContext` variable to establish their own magical transparent cancellation token, as it's on a case by case basis. I would still strongly discourage that practice, though.

We need some balance here, it's too annoying to pass params everywhere for the simple cases.

[04:41:03.0992] <rbuckton>
I don't want cancellation to be the new `this`.

[04:41:35.0298] <rbuckton>
Everyone complains or is confused about `this` in JS.

[04:42:03.0000] <hax (HE Shi-Jun)>
What about other langauges? I remember swift have some implicit cancelation behavior?

[04:42:38.0110] <rbuckton>
I'm not terribly familiar with swift, so I couldn't say.

[04:43:54.0609] <hax (HE Shi-Jun)>
> <@rbuckton:matrix.org> Everyone complains or is confused about `this` in JS.

I don't think it's comparable. Actually `this` will not be passed to function implicitly ?

[04:46:24.0544] <rbuckton>
It's comparable in that you have to do unique things to preserve or drop the `this` context in many cases.

[04:46:27.0286] <Anthony Bullard>
Any sort of implicit or ambient control flow sounds like a debugging nightmare

[04:46:31.0601] <hax (HE Shi-Jun)>
Only global functions will get `this` implicitly ?... oh, non-strict functions...

[04:47:11.0617] <rbuckton>
hax (HE Shi-Jun): you're proving my point. `this` is actually very complex.

[04:47:17.0710] <Anthony Bullard>
But I just woke up, so maybe I should get caught up first

[04:47:25.0712] <rbuckton>
Passing an argument is not complex.

[04:48:34.0995] <rbuckton>
Transparent cancellation is overoptimizing for the simplest case at the cost of the more complex cases that often have more need for an accurate and reliable cancellation mechanism.

[04:48:40.0782] <hax (HE Shi-Jun)>
> <@rbuckton:matrix.org> hax (HE Shi-Jun): you're proving my point. `this` is actually very complex.

I think the complexity is coming from inconsitant , not implicity itself. For example, in many languages, `fn()` equal to `this.fn()` in classes, and it seems ok to developers. 

[04:48:54.0010] <Duncan MacGregor>
Let's just introduce common lisp style "special variables" if we want to thread things through in an ambient fashion. /s

[04:51:10.0939] <rbuckton>
> <@haxjs:matrix.org> I think the complexity is coming from inconsitant , not implicity itself. For example, in many languages, `fn()` equal to `this.fn()` in classes, and it seems ok to developers.

I'm not saying its a 1:1 parallel. I'm saying `this` confusion is a well known issue where simple cases seem fine, but the complex cases you run into are perilously close to the simple case.

[04:52:34.0478] <hax (HE Shi-Jun)>
> <@rbuckton:matrix.org> hax (HE Shi-Jun): you're proving my point. `this` is actually very complex.

Actually, when I research old JS, it seems as the JS 1.0 logic,  JS could choose `fn()` always use `fn.call(this)` semantic everywhere, and I find it could be consistent and no confusion. üòÖ

[04:52:40.0955] <rbuckton>
```js
const counter = { value: 0, increment() { return this.value++; } };
counter.increment(); // simple case
setTimeout(counter.increment, 250); // complex case
```

[04:56:19.0475] <rbuckton>
But back to cancellation. An opt-in mechanism is "fine", i.e. `fetch(url, { signal: "inherit" })`. But that means documenting that native API's should always require user opt-in. A native API designer might choose to ignore that and require opt-out, thus it's a slippery slope.

[05:07:34.0738] <Luca Casonato>
Duncan MacGregor: we do have that already: `String.prototype[Symbol.asyncIterator]`

[05:09:41.0471] <Luca Casonato>
 * Duncan MacGregor: we do have that already: `String.prototype[Symbol.iterator]`

[05:10:39.0286] <littledan>
> <@rbuckton:matrix.org> But back to cancellation. An opt-in mechanism is "fine", i.e. `fetch(url, { signal: "inherit" })`. But that means documenting that native API's should always require user opt-in. A native API designer might choose to ignore that and require opt-out, thus it's a slippery slope.

If we have a simple and regular rule, I'm pretty optimistic that we can document it in https://w3ctag.github.io/design-principles/ and it will be generally followed. There's a lot of effort going into checking for this kind of API consistency these days (as we're seeing through pushback in proposals which don't lend themselves to that)

[05:13:35.0240] <littledan>
> <@rbuckton:matrix.org> Passing an argument is not complex.

it's not about being complex or simple, it's more like "will this actually be adopted". This is the motivation for AsyncContext in general--it sometimes becomes a layering violation to pass things around and through. For example, UI frameworks tend to track the current component/"owner" implicitly in a similar way. It'd be too weird to ask pieces of the component to pass the enclosing component into various APIs as an argument, rather than doing it as a global.

[05:14:18.0599] <littledan>
(I actually think having an ambient AbortSignal will be helpful for web components generally, alongside Signals)

[05:15:32.0210] <Duncan MacGregor>
> <@lucacasonato:matrix.org> Duncan MacGregor: we do have that already: `String.prototype[Symbol.iterator]`

I must be asleep, I had forgotten that existed. :-) I'm not convinced it's really the thing you want because strings like `"üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø"[Symbol.iterator]()` returns more elements than you may have wanted.

[05:16:03.0864] <Luca Casonato>
yeah - probably we also want string iteration on graphemes? :D

[05:17:39.0400] <Duncan MacGregor>
I think so yes.

[05:17:45.0720] <ljharb>
yup - we'd want string `.graphemes()` or something, and that's an intl API (Intl.Segmenter)

[05:18:08.0286] <ljharb>
 * yup - we'd want string `.graphemes()` or something, and that's an intl API (Intl.Segmenter) which makes it tricky to put on String.prototype

[05:19:54.0374] <Duncan MacGregor>
Is that an intl API for historical reasons? Do graphemes alter with locale in some way I haven't considered?

[05:20:13.0395] <ljharb>
they do

[05:20:20.0826] <ljharb>
 * they do (i'm told)

[05:20:47.0007] <Duncan MacGregor>
üò±

[05:21:48.0015] <ljharb>
otherwise we'd have probably had a string .graphemes proposal many years ago :-)

[05:21:55.0129] <littledan>
the definition of grapheme is complicated and changing a bit over time

[05:22:18.0255] <littledan>
I think it wasn't quite that graphemes were already defined in a locale-dependent way but rather that they might be in the future

[05:22:58.0547] <littledan>
something something Indic scripts something

[05:23:25.0576] <rbuckton>
> <@littledan:matrix.org> it's not about being complex or simple, it's more like "will this actually be adopted". This is the motivation for AsyncContext in general--it sometimes becomes a layering violation to pass things around and through. For example, UI frameworks tend to track the current component/"owner" implicitly in a similar way. It'd be too weird to ask pieces of the component to pass the enclosing component into various APIs as an argument, rather than doing it as a global.

.NET does not have transparent cancellation, but developers still use `CancellationToken`. I don't think it's as big of an adoption blocker as you're making it out to be? I don't use `AbortSignal` partly because it's to awkward to use due to its `EventTarget` usage. I _do_ use cancellation though (and `@esfx/async-canceltoken` can theoretically be used in place of an `AbortSignal` in DOM APIs)

[05:23:38.0245] <rbuckton>
> <@littledan:matrix.org> it's not about being complex or simple, it's more like "will this actually be adopted". This is the motivation for AsyncContext in general--it sometimes becomes a layering violation to pass things around and through. For example, UI frameworks tend to track the current component/"owner" implicitly in a similar way. It'd be too weird to ask pieces of the component to pass the enclosing component into various APIs as an argument, rather than doing it as a global.

 * .NET does not have transparent cancellation, but developers still use `CancellationToken`. I don't think it's as big of an adoption blocker as you're making it out to be? I don't use `AbortSignal` partly because it's too awkward to use due to its `EventTarget` usage. I _do_ use cancellation though (and `@esfx/async-canceltoken` can theoretically be used in place of an `AbortSignal` in DOM APIs)

[05:23:40.0753] <ljharb>
hmm, if it doesn't vary by locale *now* then it seems like there still might be value in shipping an invariant one in the language, and if that changes in the future, we could let Intl replace that in situ like it does for toLocaleString?

[05:23:47.0242] <bakkot>
zip üéâ

[05:24:12.0479] <ryzokuken (TC39 üá´üáÆ)>
localized strings cannot be iterated on in a locale-independent way

[05:25:56.0520] <littledan>
FYI "it should be fine to pass the cancel token explicitly" was the argument that Domenic and I had in 2016 (where I was arguing that explicit passing is OK) which led him to withdraw cancel tokens from TC39.

[05:26:43.0243] <littledan>
moving venues was a strange reaction to that argument, as it clearly didn't lead to implicit threading of cancel tokens... I think some misunderstandings happened around that issue.

[05:26:58.0322] <ryzokuken (TC39 üá´üáÆ)>
well, segmenter allows you to iterate on strings/segment them in many different ways beyond just graphemes

[05:27:20.0497] <ljharb>
> <@usharma:igalia.com> well, segmenter allows you to iterate on strings/segment them in many different ways beyond just graphemes

right, but if the only use case i have is to iterate on graphemes, can it be done in a locale-independent way?

[05:27:34.0762] <ryzokuken (TC39 üá´üáÆ)>
I believe there are edge cases 

[05:27:54.0760] <ryzokuken (TC39 üá´üáÆ)>
but let me confirm that 

[05:27:58.0242] <littledan>
> <@ljharb:matrix.org> right, but if the only use case i have is to iterate on graphemes, can it be done in a locale-independent way?

in general, we very much do not expose the "root locale". But with graphemes probably any locale will do for now.

[05:28:24.0677] <littledan>
the "root locale" is a synthetic construct in CLDR that doesn't correspond to anyplace, but other locales are expressed as a diff against it

[05:28:31.0913] <ryzokuken (TC39 üá´üáÆ)>
> <@littledan:matrix.org> in general, we very much do not expose the "root locale". But with graphemes probably any locale will do for now.

`und`

[05:28:54.0747] <ryzokuken (TC39 üá´üáÆ)>
I think it _could_ work? Let me see what implementations think.

[05:29:48.0446] <ryzokuken (TC39 üá´üáÆ)>
both `un` and `und` work here on FF

[05:30:04.0499] <ljharb>
if it can work and not be in intl, i'd be happy to co-champion something like `.codePoints()`, `.codeUnits()`, and `.graphemes()` methods on String.prototype

[05:30:28.0409] <ryzokuken (TC39 üá´üáÆ)>
why not champion an Intl proposal if needed? 

[05:30:30.0292] <ljharb>
 * if it can work and not be in intl, i'd be happy to co-champion something like `.codePoints()`, `.codeUnits()`, and `.graphemes()` methods on String.prototype. only reason i haven't years ago is that i thought it can't work

[05:30:44.0784] <ryzokuken (TC39 üá´üáÆ)>
we'd love to help out if we can üòÑ 

[05:30:47.0827] <Michael Ficarra>
I don't like `.graphemes` living outside Intl but the other two would be great and I would co-champion

[05:30:49.0541] <ljharb>
i have Intl.Segmenter for that already. I need something that's in every environment, and ideally on String.prototype.

[05:30:58.0365] <ryzokuken (TC39 üá´üáÆ)>
ah, sure

[05:31:02.0131] <ljharb>
> <@michaelficarra:matrix.org> I don't like `.graphemes` living outside Intl but the other two would be great and I would co-champion

if it's not locale-dependent, why would it need to be inside intl?

[05:31:12.0224] <Michael Ficarra>
@ljharb:matrix.org it is though

[05:31:21.0716] <littledan>
> <@usharma:igalia.com> both `un` and `und` work here on FF

Are you sure? What is their .resolvedOptions().locale ?

[05:31:28.0732] <ljharb>
i thought that's what ujjwal was just saying it's not.

[05:32:30.0472] <Michael Ficarra>
... where?

[05:32:36.0525] <ryzokuken (TC39 üá´üáÆ)>
ah interesting, it's treating `"und"` as the JS value `undefined`

[05:32:50.0691] <ryzokuken (TC39 üá´üáÆ)>
by which I mean it's falling back to my system locale

[05:32:58.0920] <ryzokuken (TC39 üá´üáÆ)>
 * by which I mean it's falling back to my system locale (en-DK)

[05:33:43.0065] <ljharb>
here: https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$dEtEYuEpnCUpLhfMmu7TbPKuc_4CEDr3LXHI_MkV4Y4?via=matrix.org&via=mozilla.org&via=igalia.com

but that's still unconfirmed, and maybe isn't the case

[05:34:14.0496] <ryzokuken (TC39 üá´üáÆ)>
yeah I'll recheck after today's session and let you know Michael 

[05:35:33.0766] <Michael Ficarra>
uhhh üáπüáº

[05:37:01.0599] <ljharb>
http://unicode.org/L2/L2001/01322r-grapheme_cluster.htm

[05:37:22.0197] <ljharb>
that's super old, did the proposal ever land?

[05:38:38.0160] <Michael Ficarra>
yeah if that exists, then I'd be fine putting it on `String.prototype`

[05:39:02.0399] <Duncan MacGregor>
There's a follow up here https://www.unicode.org/L2/L2023/23140-graphemes-expectations.pdf

[05:39:09.0670] <rbuckton>
Does Intl/CLDR/etc. have something like an "invariant" locale (i.e., for machine readable formatting, not UI formatting)?

[05:39:20.0306] <ryzokuken (TC39 üá´üáÆ)>
> <@rbuckton:matrix.org> Does Intl/CLDR/etc. have something like an "invariant" locale (i.e., for machine readable formatting, not UI formatting)?

yeah `und`

[05:39:32.0260] <ryzokuken (TC39 üá´üáÆ)>
but apparently we handle it quite weirdly?

[05:40:06.0480] <bakkot>
> <@michaelficarra:matrix.org> uhhh üáπüáº

flags are always a single grapheme regardless of whether they render

[05:41:02.0265] <ryzokuken (TC39 üá´üáÆ)>
all nordic flags should be a ligature with a base flag

[05:41:51.0384] <bakkot>
e.g. there is no `ww` flag but it's still one grapheme:
```
[...new Intl.Segmenter('en', {granularity:'grapheme'}).segment('\u{1f1fc}\u{1f1fc}')]
```

[05:41:51.0897] <Michael Ficarra>
even regional flags like üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø?

[05:42:31.0971] <bakkot>
```
[...new Intl.Segmenter('en', {granularity:'grapheme'}).segment('üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø')].length
```
1

[05:42:57.0041] <bakkot>
https://unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table says
> Do not break within emoji flag sequences. That is, do not break between regional indicator (RI) symbols if there is an odd number of RI characters before the break point.


[05:44:28.0355] <bakkot>
and also
> Do not break within emoji modifier sequences or emoji zwj sequences.

which applies to regional flags, probably

[05:45:03.0465] <bakkot>
though I don't know offhand whether something counts as a "emoji zwj sequence" if the sequence is not a recognized emoji

[05:45:31.0000] <Michael Ficarra>
it's only a ZWJ if there's intercalated ZWJs

[05:46:46.0950] <bakkot>
I guess üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø is a emoji modifier sequence not a zwj sequence yes

[05:47:39.0610] <littledan>
> <@usharma:igalia.com> by which I mean it's falling back to my system locale (en-DK)

right, this is generally what Intl does if you ask for a nonexistent locale

[05:47:59.0273] <ryzokuken (TC39 üá´üáÆ)>
no, I tried another and it complained 

[05:48:05.0609] <littledan>
try `(new Intl.NumberFormat("xyz")).resolvedOptions().locale`, same thing

[05:48:21.0106] <ryzokuken (TC39 üá´üáÆ)>
ah wait yes

[05:48:48.0656] <ryzokuken (TC39 üá´üáÆ)>
nvm it was failing for non 2-3 character long locales

[05:49:16.0189] <littledan>
üéâ

[05:49:21.0766] <eemeli>
With `"und"` you're observing fallback to the system locale.

[05:49:29.0352] <Duncan MacGregor>
Amusingly Safari's dev console doesn't handle deletion correctly with flags. "üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø" -> "üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥" -> "üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£" -> "üè¥Û†ÅßÛ†Å¢Û†Å≥" ‚Ä¶

[05:51:26.0266] <nicolo-ribaudo>
(deleted because my code was wrong)

[05:51:33.0035] <jkup>
wait nic i want that link 

[05:51:33.0651] <jkup>
oh ok

[05:52:26.0366] <nicolo-ribaudo>
https://developer.mozilla.org/en-US/docs/Web/API

[05:52:35.0257] <bakkot>
as far as I can tell:
- unicode has a locale-independent grapheme clustering algorithm
- it recommends the use of CLDR's language-specific rules when available
- CLDR does not appear to have implemented any such rules yet, from what I see https://cldr.unicode.org/development/development-process/design-proposals/grapheme-usage

[05:53:04.0368] <ljharb>
ok so then we should definitely have a 402-enhanceable String.prototype method?

[05:53:10.0809] <ljharb>
 * ok so then we should definitely have a future-402-enhanceable String.prototype method?

[05:53:25.0314] <bakkot>
I am not an Intl knower though, so that could be wrong

[05:53:31.0893] <Richard Gibson>
> <@aardvark179:matrix.org> Is that an intl API for historical reasons? Do graphemes alter with locale in some way I haven't considered?

"ch" is logically a single grapheme in the Latin transcription of many Slavic languages, and it seems likely to me that such tailorings will be added to CLDR at some point

[05:53:43.0446] <littledan>
> <@bakkot:matrix.org> as far as I can tell:
> - unicode has a locale-independent grapheme clustering algorithm
> - it recommends the use of CLDR's language-specific rules when available
> - CLDR does not appear to have implemented any such rules yet, from what I see https://cldr.unicode.org/development/development-process/design-proposals/grapheme-usage

lol that matches my understanding as of 2017

[05:54:45.0017] <Duncan MacGregor>
I think a 402 enhanceable method would be a good thing.

[05:55:10.0014] <Chris de Almeida>
folks on the queue, please include a topic description beyond just the letter. üôè

[05:55:16.0856] <ljharb>
(technically all methods are 402-enhanceable, but ofc i meant one explicitly designed for that future purpose)

[05:56:01.0397] <ljharb>
> <@softwarechris:matrix.org> folks on the queue, please include a topic description beyond just the letter. üôè

still can't edit :-(

[05:56:03.0829] <rbuckton>
> <@usharma:igalia.com> yeah `und`

Is `"und"` supposed to be the same regardless of system locale, or is the issue that `Intl` doesn't support that and treats it as an unknown locale?

[05:57:28.0124] <Chris de Almeida>
> <@ljharb:matrix.org> still can't edit :-(

you can add new, and I will rearrange

[05:58:11.0757] <Chris de Almeida>
thank you!

[05:59:04.0846] <bakkot>
we already have a built-in ThrowTypeError function

[05:59:29.0496] <bakkot>
(for `arguments.caller`)

[05:59:49.0753] <ljharb>
asked about that on the queue

[06:00:22.0520] <rbuckton>
I'd really like to be able to use a locale-invariant `Intl.Collator` for sorting inputs reliably in, say, a compiler that runs on different systems all over the world...

[06:00:37.0788] <bakkot>
 * (for `Function.prototype.caller`)

[06:01:21.0585] <bakkot>
though, engines probably want a different error message for `Function.prototype.caller` vs these things

[06:02:31.0308] <hax (HE Shi-Jun)>
Is there any precedent of sharing methods among several classes?

[06:03:06.0341] <rbuckton>
Wouldn't `b.until(a)` be a better replacement for `a.since(b)`?

[06:03:23.0605] <rbuckton>
(no intermediate allocation)

[06:04:59.0275] <bakkot>
> <@rbuckton:matrix.org> Is `"und"` supposed to be the same regardless of system locale, or is the issue that `Intl` doesn't support that and treats it as an unknown locale?

unicode reserves `"und"`

[06:05:12.0846] <bakkot>
> <@rbuckton:matrix.org> Is `"und"` supposed to be the same regardless of system locale, or is the issue that `Intl` doesn't support that and treats it as an unknown locale?

 * unicode reserves `"und"` for unknown

[06:05:13.0134] <rbuckton>
or is `until` clamped?

[06:05:22.0798] <bakkot>
so yes it is the system locale I think

[06:05:34.0897] <rbuckton>
> <@bakkot:matrix.org> so yes it is the system locale I think

Then that's definitely not what I want.

[06:05:38.0471] <nicolo-ribaudo>
> <@rbuckton:matrix.org> Wouldn't `b.until(a)` be a better replacement for `a.since(b)`?

I think they are not equivalent, but I don't know exactly how. I suggest asking in the queue so that Philip can respond 

[06:05:48.0097] <nicolo-ribaudo>
Or maybe ryzokuken (TC39 üá´üáÆ): knows

[06:06:02.0278] <rbuckton>
> <@nicolo-ribaudo:matrix.org> I think they are not equivalent, but I don't know exactly how. I suggest asking in the queue so that Philip can respond

It's more of a curiosity than a concern.

[06:06:14.0071] <bakkot>
ah, though apparently that isn't threaded through to browsers: https://github.com/tc39/ecma402/issues/885

[06:06:39.0032] <littledan>
> <@bakkot:matrix.org> ah, though apparently that isn't threaded through to browsers: https://github.com/tc39/ecma402/issues/885

yes this was a deliberate decision. Unicode recommends against exposing the root locale, and und isn't supposed to be interpreted as the root locale either.

[06:06:41.0097] <Richard Gibson>
> <@haxjs:matrix.org> Is there any precedent of sharing methods among several classes?

arguably those on %TypedArray.prototype%, %GeneratorPrototype%, etc.

[06:06:51.0642] <nicolo-ribaudo>
> <@rbuckton:matrix.org> It's more of a curiosity than a concern.

I'd be concerned if "the intuitive workaround that people are likely to use is wrong" :P

[06:11:07.0121] <rbuckton>
From the temporal docs for `since()`

[06:11:19.0318] <rbuckton>
Per this, they should be equivalent?

[06:12:24.0803] <rbuckton>
 * Per this, they should be equivalent? If not, I'm curious what the outliers are.

[06:12:41.0787] <Richard Gibson>
`a.since(b)` and `a.until(b).negated()` are equivalent, but `a.since(b)` and `b.until(a)` are not

[06:13:01.0041] <ljharb>
ftr H - K have nothing on the queue

[06:13:14.0337] <ljharb>
 * ftr C, and H - K, have nothing on the queue

[06:13:56.0776] <Richard Gibson>
 * `a.since(b, opts)` and `a.until(b, opts).negated()` are equivalent, but `a.since(b, opts)` and `b.until(a, opts)` are not

[06:14:23.0246] <rbuckton>
Ah, the difference is in how the `opts` might be applied?

[06:18:44.0535] <Richard Gibson>
right, starting point is always the receiver so e.g. with largestUnit: "month", March 31 to April 30 is P1M while April 30 to March 31 is -P30D

[06:19:50.0124] <Duncan MacGregor>
Thank you, that really helps clarify things.

[06:21:24.0360] <rbuckton>
> <@gibson042:matrix.org> right, starting point is always the receiver so e.g. with largestUnit: "month", March 31 to April 30 is P1M while April 30 to March 31 is -P30D

That makes sense, but feels odd. It makes me want some kind of normalization to occur, but I'm not sure I feel that strongly about it.

[06:22:36.0729] <Duncan MacGregor>
I think as soon as you allow addition or subtraction of variable sized things like months you'll hit those odd corner cases.

[06:23:36.0222] <rbuckton>
Mostly because this is essentially "date math" but isn't as reliable as actual math.

[06:24:57.0644] <Duncan MacGregor>
Yeah, abandon all hope, there are no monoids here.

[06:25:03.0195] <rbuckton>
I mean, normalization would make it consistent, i.e., swap left and right to ensure they are ordered, perform the necessary math, and then negate the results as needed for the given API and whether a swap occurred.

[06:27:16.0516] <rbuckton>
 * I mean, normalization would make it consistent, i.e., swap left and right as necessary to ensure they are ordered, perform the necessary math, and then negate the results as needed for the given API and whether a swap occurred.

[06:34:25.0490] <nicolo-ribaudo>
Could somebody re-explain me this comment? üòÖ Do database use timezones that are not the timezones we are using in temporal?

[06:34:29.0581] <nicolo-ribaudo>
 * Could somebody re-explain to me this comment? üòÖ Do database use timezones that are not the timezones we are using in temporal?

[06:34:33.0473] <nicolo-ribaudo>
 * Could somebody re-explain to me this comment? üòÖ Do databases use timezones that are not the timezones we are using in temporal?

[06:35:07.0363] <Richard Gibson>
> <@rbuckton:matrix.org> I mean, normalization would make it consistent, i.e., swap left and right as necessary to ensure they are ordered, perform the necessary math, and then negate the results as needed for the given API and whether a swap occurred.

such normalization would not give desired results. actual example (runnable against the polyfill at https://tc39.es/proposal-temporal/ ):

```
Temporal.PlainDate.from("2024-06-30").until("2024-08-31", {largestUnit:"months"}); // => P2M1D
Temporal.PlainDate.from("2024-08-31").until("2024-06-30", {largestUnit:"months"}); // => -P2M
```

[06:35:26.0624] <Richard Gibson>
> <@rbuckton:matrix.org> I mean, normalization would make it consistent, i.e., swap left and right as necessary to ensure they are ordered, perform the necessary math, and then negate the results as needed for the given API and whether a swap occurred.

 * such normalization would not give desired results. actual example (runnable against the polyfill at https://tc39.es/proposal-temporal/ ):

```
Temporal.PlainDate.from("2024-06-30").until("2024-08-31", {largestUnit:"months"});
// => P2M1D
Temporal.PlainDate.from("2024-08-31").until("2024-06-30", {largestUnit:"months"});
// => -P2M
```

[06:37:37.0379] <rbuckton>
That discrepancy is desired?

[06:37:43.0949] <Richard Gibson>
yes

[06:39:11.0278] <rbuckton>
Why is it desirable?

[06:41:07.0427] <nicolo-ribaudo>
Re subtract, even Shu said that it's confusing to remove subtract

[06:41:32.0705] <nicolo-ribaudo>
And this "size reduction" request is coming from him

[06:41:42.0532] <nicolo-ribaudo>
 * Re subtract, even Shu said that it's confusing to remove subtract in his pre-written message to rob

[06:41:45.0545] <nicolo-ribaudo>
 * Re subtract, even Shu said that it's confusing to remove subtract in his pre-written message to Rob

[06:42:20.0709] <jkup>
I sort of read into it as "I understand if you want subtract" but with an undertone of "If you add it back, remove something else" - maybe that's wrong?

[06:42:37.0854] <littledan>
> <@jkup:matrix.org> I sort of read into it as "I understand if you want subtract" but with an undertone of "If you add it back, remove something else" - maybe that's wrong?

I don't think that was necessarily the case

[06:42:47.0849] <nicolo-ribaudo>
We should look at O(n) reductions and not O(1)

[06:44:55.0532] <nicolo-ribaudo>
Would a .symmetricDifference instead of .subtract work, if the concern is hiding negative durations? (even though this should have been discussed in stage 2)

[06:46:58.0479] <nicolo-ribaudo>
Oh, I guess `a.subtract(b).abs()`

[06:46:59.0652] <littledan>
I'm not convinced that making people use negative durations for their subtract replacement more frequently is the best educational device... I don't think that should be a goal

[06:48:52.0872] <Richard Gibson>
> <@rbuckton:matrix.org> Why is it desirable?

because it maps to what people expect when doing calendar operations based on how constraining logic is asymmetric w.r.t to start-of-month vs. end-of-month (going forward, end-of-month to end-of-month has a zero "days" part, but going backward, doing the same thing would impose lossiness by producing the same result for adjacent inputs)

[06:50:52.0962] <nicolo-ribaudo>
Is the way humans think to use "since" for things in the past and "until" for things in the future?

[06:51:16.0490] <ljharb>
yes

[06:51:19.0029] <ljharb>
 * yes, i'd say so

[06:51:27.0762] <ljharb>
 * yes, i'd say so (in english at least)

[06:52:38.0478] <rbuckton>
I'd almost rather have `since` as I'm sure many users would be tripped up by `until` not being symmetric.

[06:52:43.0465] <nicolo-ribaudo>
Somehow it's much harder for me to think about until than since but this is like... not a data point

[06:53:34.0702] <Richard Gibson>
 * such normalization would not give desired results. actual example (runnable against the polyfill at https://tc39.es/proposal-temporal/ ):

```
Temporal.PlainDate.from("2024-06-30").until("2024-08-31", { largestUnit: "months" });
// => P2M1D
Temporal.PlainDate.from("2024-08-31").until("2024-06-30", { largestUnit: "months" });
// => -P2M
```

[06:54:00.0209] <nicolo-ribaudo>
Also, we said we don't want people to have to think about negative durations and now we are saying "get a negative duration and then re-negate it"?

[06:54:08.0482] <Michael Ficarra>
@nicolo-ribaudo:matrix.org many JS programmers are non-native speakers, so it kinda *is* a data point

[06:54:10.0204] <nicolo-ribaudo>
 * Also, we said it's difficult for people to have to think about negative durations and now we are saying "get a negative duration and then re-negate it"?

[06:54:30.0869] <nicolo-ribaudo>
Oh yeah I clearly remember a song we studied in middle school in my english classes that used "since" a lot üòÇ

[06:59:35.0158] <bakkot>
ljharb: I am confused; stage 2.7->3 is pro-forma on the basis of tests being present

[06:59:39.0617] <bakkot>
it is not about anything other than that

[06:59:49.0651] <bakkot>
 * ljharb: I am confused; stage 2.7->3 is pro-forma on the basis of sufficient tests being present

[06:59:55.0251] <bakkot>
Temporal has lots of tests

[07:00:25.0449] <ljharb>
p sure it's not _just_ about tests

[07:00:47.0645] <ljharb>
and either way this agenda item means its tests are no longer correct

[07:02:00.0057] <bakkot>
all changes at stage 3 invalidate some tests and we don't normally bump things down, and in fact the champions have already done the work to make the changes to the tests for these proposed changes

[07:02:17.0290] <bakkot>
and certainly when 2.7 was introduced I understood it to be about tests

[07:02:47.0179] <bakkot>
the purpose is

> Testing and validation. Validate the design of the feature through the development of a rigorous and comprehensive test suite Develop spec-compliant prototypes to validate implementability, as necessary, or aid in test development

and the entrance criteria for 3 is

> The feature has sufficient testing and appropriate pre-implementation experience


[07:03:03.0968] <bakkot>
perhaps Michael Ficarra can speak more to this?

[07:03:06.0018] <ljharb>
and clearly it wasn't sufficient given the vast quantity of normative changes over almost every meeting in the last 4 years.

[07:03:28.0260] <leftmostcat (UTC-7)>
justingrant ptomato I'd definitely be interested in discussing declarative custom time zone behavior further.

[07:03:46.0102] <littledan>
> <@bakkot:matrix.org> and certainly when 2.7 was introduced I understood it to be about tests

I agree. If we bump something down, it would be to Stage 2. There's no extra consensus-seeking step--that was very much a part of the process reform in the first place.

[07:04:04.0855] <ljharb>
ok, then maybe stage 2 is the right call

[07:04:30.0813] <ljharb>
i mainly feel that stage 3 isn't appropriate for Temporal (and really hasn't been in a long time)

[07:04:57.0411] <ljharb>
a big part of the discussion around 2.7 was admittedly my own stated opinion (but i wasn't alone) that "3 means shippable"

[07:05:04.0360] <ljharb>
temporal is not shippable yet.

[07:05:33.0899] <littledan>
I think Temporal is in a similar state to Decorators: right now it deserves to be at Stage 3, though at some point in the past it might've met the criteria for a demotion and re-promotion.

[07:05:39.0236] <bakkot>
3 means appropriate to implement

[07:05:42.0704] <nicolo-ribaudo>
Can we merge the since() and subtract() methods? And they check their receiver

[07:06:22.0011] <ljharb>
implement !== ship unflagged and use in production

[07:06:29.0157] <littledan>
> <@nicolo-ribaudo:matrix.org> Can we merge the since() and subtract() methods? And they check their receiver

if Shu wanted us to merge random things, he would've said so

[07:06:29.0286] <ljharb>
the intention was for 3 to mean the latter

[07:06:48.0086] <nicolo-ribaudo>
> <@littledan:matrix.org> if Shu wanted us to merge random things, he would've said so

I mean since with the sinces and subtract with the subtracts

[07:06:51.0420] <nicolo-ribaudo>
To have ony one .since and one .subtract

[07:06:54.0001] <nicolo-ribaudo>
Like for .valueOf

[07:07:57.0559] <ljharb>
 * the intention was for 3 to mean the latter; perhaps the 2.7 PR should have tweaked the stage 3 wording better, but i didn't realize it said "implement".

[07:11:06.0647] <bakkot>
> <@ljharb:matrix.org> implement !== ship unflagged and use in production

I don't think engines want us to be in charge of deciding whether they can ship an implementation they're happy with, once we've given the signal that it is ready to implement, so I don't think that's really a thing we can dictate

[07:11:18.0887] <ljharb>
it's not about "in charge", it's about the public signal

[07:11:46.0646] <ljharb>
a lot of the 2.7 discussion was about precisely that - that stage 3 sends the signal that it's ok to use it in production and that it's ok for it to be shipped unflagged. they can do whatever they want regardless, but the signal matters

[07:11:53.0781] <ljharb>
and temporal has had an inaccurate signal for 4 years

[07:12:25.0733] <bakkot>
the only signal relevant to whether you can use something in production is whether it is in the engines that you support

[07:13:06.0608] <ljharb>
that's wildly incorrect, given the existence and usage of polyfills

[07:13:33.0584] <ljharb>
and, not every engine/implementation is always in this room. the stage is a signal to them, too.

[07:13:56.0606] <bakkot>
you can use a polyfill for a feature which has never even been proposed if you want to? I don't know what the relevance of "polyfills exist" is to this

[07:35:51.0870] <shu>
> <@jkup:matrix.org> I sort of read into it as "I understand if you want subtract" but with an undertone of "If you add it back, remove something else" - maybe that's wrong?

no, didn't intend that subtext

[07:36:39.0220] <shu>
the undertone was more like "i understandable, on a case by case basis, if some should be added back. but if too many are added back then we have a problem again"

[07:36:46.0624] <shu>
 * the undertone was more like "it is understandable, on a case by case basis, if some should be added back. but if too many are added back then we have a problem again"

[07:45:11.0271] <Christian Ulbrich>
https://www.youtube.com/watch?v=hnpILIIo9ek

[07:45:30.0392] <Christian Ulbrich>
Or: head over to: https://tcq.staging.tcq-reloaded.tcq.ninja to see tcq-reloaded in action.

[07:47:33.0289] <Christian Ulbrich>
For those, that are interested, the PR is https://github.com/zalari/tcq/pull/7 , it is not persistent, i.e. whenever I redeploy, everything is gone, because I need to write additional adapters. Feedback on above PR is highly appreciated. I have no clue, what the perf requirements for TCQ are, it is a very small VM running on AWS Fargate.

