2024-06-01
[20:29:37.0615] <justingrant>
What's the right process to get consensus on it from TG1 in Helsinki for normative PRs to ECMA-402? Do I add it as a standalone agenda item?  As part of a standing agenda item for 402 changes?  Something else? PR is https://github.com/tc39/ecma402/pull/877

This is mostly a "web reality" change that aligns the spec with how V8 and JSC already behave by tightening under-specified parts of the spec. It also adds forward-looking guidance to handle future issues that may crop up with time zone identifiers.

Ideally I would have asked this question yesterday before the deadline, but I mistakenly believed that all TG2-approved PRs would magically make it into the agenda. Oops. Anyway, I'll add this as a late submission. 

[21:33:25.0929] <bakkot>
I believe you still have two hours before the deadline

[21:34:24.0705] <bakkot>
this is a three-day meeting so the deadline is Saturday rather than Friday (but Saturday in Helsinki, so earlier than it would for meetings in PT)

[01:33:37.0254] <sffc>
Yeah, it should be added under "Needs Consensus PRs". ECMA-402 PRs previously got added automatically, but that practice stopped about a year ago. Now we just make an announcement in the monthly TG2 call to remind champions to add their stuff to the TG1 agenda if it needs TG1 consensus.

[16:11:03.0610] <Rob Palmer>
We still have around 3 hours of spare capacity. So please don't let the agenda deadline stop you from adding more items. 


2024-06-02
[17:12:02.0955] <rbuckton>
I'd hoped to bring back extractors and void bindings for Stage 2 this plenary, but only recently had the time to address feedback from last meeting and I want to give Waldemar time to review the changes intended to address his concerns. I may try to add them as late agenda items since they both seemed fairly close to reaching stage 2 at the last meeting (or, at least that was my impression). 

[15:37:32.0946] <justingrant>
> Yeah, it should be added under "Needs Consensus PRs". ECMA-402 PRs previously got added automatically, but that practice stopped about a year ago. Now we just make an announcement in the monthly TG2 call to remind champions to add their stuff to the TG1 agenda if it needs TG1 consensus.

Serves me right for not listening carefully!  üëÇÔ∏è  I just [submitted](https://github.com/tc39/agendas/pull/1611) a needs-consensus agenda item for that PR.


2024-06-03
[03:19:44.0481] <littledan>
If we seriously have extra time on the agenda, there are a couple wild open discussion topics which might be fun. Emoji-react something if you're interested in them. (Apologies for not raising this before the agenda deadline.)

[03:19:48.0061] <littledan>
Cancellable promises

[03:20:02.0708] <littledan>
Private name declarations outside of classes

[03:34:55.0090] <rbuckton>
> <@littledan:matrix.org> Cancellable promises

Would it make sense to discuss this on https://github.com/tc39/proposal-cancellation? 

[03:37:07.0446] <littledan>
> <@rbuckton:matrix.org> Would it make sense to discuss this on https://github.com/tc39/proposal-cancellation?

oh thanks that gives a lot of helpful references to review. I have been thinking about this area again in the context of AsyncContext, which gives us more options for propagating the cancel token.

[03:37:44.0109] <littledan>
also AbortSignal.any is a very helpful, core capability in this area, which I don't think was there last time we discussed this

[03:40:19.0801] <littledan>
(I guess it basically enables what your previous proposal's `new CancellationTokenSource(linkedTokens?)` does, roughly)

[03:46:36.0415] <rbuckton>
Unfortunately, since `AbortSignal` is outside the purview of TC39 the best forum for that may be WHATWG. 

[03:47:27.0488] <rbuckton>
Though I've long held that cancellation graphs like that are very valuable

[03:47:50.0220] <littledan>
We'll definitely have to collaborate between standards groups to make this happen, but I think you were right to bring this to TC39, and believe we can make some progress together.

[03:49:56.0372] <littledan>
also if we want integration with async/await (e.g., all awaits are implicitly racing with the cancel token), something would need to happen in TC39

[03:50:01.0638] <rbuckton>
I also agree that AsyncContext would have been the way to traffic a cancellation token in the way Yehuda wanted, so long as there was a way to suppress async context flow when needed

[03:50:30.0594] <littledan>
> <@rbuckton:matrix.org> I also agree that AsyncContext would have been the way to traffic a cancellation token in the way Yehuda wanted, so long as there was a way to suppress async context flow when needed

could you say more about this suppression use case?

[03:50:41.0467] <littledan>
I mean, requirements for it

[03:50:47.0027] <rbuckton>
The only avenue given to us at this point is a host hook. 

[03:51:16.0521] <littledan>
IIRC wanting the cancel token to be implicitly propagated was a goal of Domenic's as well

[03:51:41.0981] <rbuckton>
> <@littledan:matrix.org> could you say more about this suppression use case?

Sometimes you *don't* want to propagate the token.

[03:51:55.0355] <rbuckton>
I have to step away, I'll discuss more shortly.

[03:52:03.0559] <littledan>
> <@rbuckton:matrix.org> The only avenue given to us at this point is a host hook.

I hope we can first think about the problem space and what's needed for developers (as you were trying to do) and then we can go from there to "how do we lay this out across the various specs"

[04:02:15.0431] <rbuckton>
With the token as a parameter, it is up to the caller to determine whether to pass the token to a function. If you had a function that invoked a REST API, you might want to allow it to be cancellable in some cases, but not others. If there is no suppression mechanism, then there is no way for the caller to make this determination. The structure of the Cancellation API (so far as that proposal was concerned) ensured an appropriate separation of concerns so that the correct level of control was available with respect to the caller and the call site. 

[04:10:21.0273] <rbuckton>
> <@littledan:matrix.org> (I guess it basically enables what your previous proposal's `new CancellationTokenSource(linkedTokens?)` does, roughly)

One of the major reasons I wanted a linked cancellation graph was to address memory overhead. If cancellation sources could be intrinsically linked, and could be disposed when cancellation was no longer needed, then all of the token subscriptions could be GC'd (incl. the callbacks and closed-over variables that they held).

[04:11:02.0669] <littledan>
> <@rbuckton:matrix.org> With the token as a parameter, it is up to the caller to determine whether to pass the token to a function. If you had a function that invoked a REST API, you might want to allow it to be cancellable in some cases, but not others. If there is no suppression mechanism, then there is no way for the caller to make this determination. The structure of the Cancellation API (so far as that proposal was concerned) ensured an appropriate separation of concerns so that the correct level of control was available with respect to the caller and the call site.

yes, so if we had an AsyncContext variable for the current cancel token, and then a function you could call to set that variable to a fresh token while running a callback, that would achieve suppression, right?

[04:11:20.0600] <littledan>
> <@rbuckton:matrix.org> One of the major reasons I wanted a linked cancellation graph was to address memory overhead. If cancellation sources could be intrinsically linked, and could be disposed when cancellation was no longer needed, then all of the token subscriptions could be GC'd (incl. the callbacks and closed-over variables that they held).

yes, I agree this is important. Do you see AbortSignal.any as solving that issue too?

[04:11:23.0772] <rbuckton>
A fresh token, or no token.

[04:11:51.0719] <rbuckton>
I would have to think about that. IIRC, the issue with `any` is how ownership is controlled for a subgraph.

[04:12:17.0977] <littledan>
> <@rbuckton:matrix.org> I would have to think about that. IIRC, the issue with `any` is how ownership is controlled for a subgraph.

I think `any` has to be used in a sort of opinionated way to make things work

[04:12:48.0595] <littledan>
and your proposed signature sort of already encapsulates that pattern

[04:13:37.0431] <rbuckton>
Let's say I receive a token and want to call another function with both that and my own token. With `any`, I can close *my* source, but since I have no control over the incoming token, the graph can't be GC'd

[04:14:41.0288] <littledan>
which graph do you mean?

[04:16:43.0747] <rbuckton>
```js
function outer(signal) {
  const myController = new AbortController();
  const combined = AbortController.any([signal, myController.signal]);
  const promise = inner(combined.signal);
  ...
  // we've progressed to a point where cancellation shouldn't occur, 
  // but we can't signal that to `inner`
  myController.dispose(); 
}
```

[04:17:03.0949] <rbuckton>
 * ```js
function outer(signal) {
  const myController = new AbortController();
  const combinedSignal = AbortController.any([signal, myController.signal]);
  const promise = inner(combinedSignal);
  ...
  // we've progressed to a point where cancellation shouldn't occur, 
  // but we can't signal that to `inner`
  myController.dispose(); 
}
```

[04:17:22.0439] <rbuckton>
 * ```js
function outer(signal) {
  const myController = new AbortController();
  const combinedSignal = AbortSignal.any([signal, myController.signal]);
  const promise = inner(combinedSignal);
  ...
  // we've progressed to a point where cancellation shouldn't occur, 
  // but we can't signal that to `inner`
  myController.dispose(); 
}
```

[04:17:58.0738] <rbuckton>
Here, even if we think `inner` should keep going, if `signal` is canceled then `combinedSignal` is cancelled.

[04:18:18.0929] <rbuckton>
If `any` returns a signal, then I can't model this relationship using it.

[04:19:34.0859] <rbuckton>
But if `any` returns a controller, then I can exert this level of control:
```js
function outer(signal) {
  const combinedController = AbortController.any([signal]);
  const promise = inner(combinedController.signal);
  ...
  // we've progressed to a point where cancellation shouldn't occur
  combinedController.dispose(); 
}
```

[04:21:02.0607] <rbuckton>
The `new CancellationTokenSource(linkedTokens?)` API allowed you to express this relationship. If you need control over the subgraph, you hold a reference to the source. If you don't need control over the subgraph, you don't hold a reference to the source and just pass along it's `token`.

[04:21:42.0030] <littledan>
Btw did you point this out in any issue on the AbortSignal.any repo?

[04:22:29.0213] <rbuckton>
I wasn't aware of an `AbortSignal.any` repo, but I've definitely discussed it many years ago in TC39 as part of the cancellation proposal.

[04:23:46.0088] <littledan>
This was the repo, but it's already shipping across browsers https://github.com/shaseley/abort-signal-any

[04:24:18.0854] <littledan>
I had trouble following all the aspects of your previous presentation, and was watching this proposal later, and thought it was good and solved the problems you were raising.

[04:26:05.0403] <rbuckton>
Ah, that's unfortunate.

[04:26:19.0641] <littledan>
I have trouble tracing the leak in the above code. It's that it's less apparent that the controller is dead?

[04:26:44.0432] <rbuckton>
No, the problem is that the controller isn't dead in the first example.

[04:27:01.0057] <littledan>
sure, that it isn't dead, so how big of a leak is that?

[04:27:20.0488] <littledan>
it's only referred to by that local variable, and that can be collected once you leave the scope. or is there anything else?

[04:28:06.0034] <littledan>
(I thought solving this particular GC issue was like 80% of the point of AbortSignal.any in the first place)

[04:28:36.0231] <rbuckton>
It's not a leak, it's bigger than that. If I wanted to be able to control whether `inner` could even be cancelled anymore after a certain point, I would not be able to do so in that approach, so it actually affects capabilities, not just memory.

[04:29:00.0966] <rbuckton>
Also, if there is no `dispose()`/`close()` then you're not addressing the GC concern at all.

[04:29:15.0895] <littledan>
how can you do that with the API you're proposing?

[04:29:43.0061] <rbuckton>
It's quite hard to explain in text without drawing a graph :/

[04:57:44.0560] <rbuckton>
Lets assume for a moment that an `AbortController` has a `dispose()` method. In example one, you have an outer abort controller `A` (and signal `a`) and create an inner abort controller `B` (and signal `b`). Calling `AbortSignal.any([a, b])` produces a signal `ab` with the following semantics:
- Aborting `A` aborts `a` and `ab`
- Aborting `B` aborts `b` and `ab` 
- Disposing `A` disposes `a` but not `ab`, because `ab` could still be aborted by `B`.
- Disposing `B` disposes `b` but not `ab`, because `ab` could still be aborted by `A`.

My algorithm reaches a point of no return where I no longer want `inner` to be cancelable, at which point any subscriptions added by `inner` can be collected. Unfortunately, `AbortSignal.any` does not give me this capability since neither `A` nor `B` dominates the token `ab`.

[05:03:15.0189] <rbuckton>
In the `new CancellationTokenSource(linkedTokens?)` approach, you produce a new source/controller that dominates the cancellation interaction with `inner`. You have the same outer controller `A` (and signal `a`), and you wrap it with an inner controller `B(a)` with signal `b(a)`. Signal `b(a)` has the following semantics:

- Aborting `A` aborts `a` and `b(a)`.
- Aborting `B(a)` aborts `b(a)`.
- Disposing `A` disposes `a` but not `b(a)`, because `b(a)` could still be aborted by `B(a)`. However, the link between `B(a)` and a` can be removed and the subscription can be GC'd
- Disposing `B(a)` disposes `b(a)`, but not `a`. Any subscriptions to `b(a)` can be GC'd

[05:03:37.0928] <rbuckton>
 * In the `new CancellationTokenSource(linkedTokens?)` approach, you produce a new source/controller that dominates the cancellation interaction with `inner`. You have the same outer controller `A` (and signal `a`), and you wrap it with an inner controller `B(a)` (with signal `b(a)`). Signal `b(a)` has the following semantics:

- Aborting `A` aborts `a` and `b(a)`.
- Aborting `B(a)` aborts `b(a)`.
- Disposing `A` disposes `a` but not `b(a)`, because `b(a)` could still be aborted by `B(a)`. However, the link between `B(a)` and a\` can be removed and the subscription can be GC'd
- Disposing `B(a)` disposes `b(a)`, but not `a`. Any subscriptions to `b(a)` can be GC'd

[05:04:32.0980] <rbuckton>
 * In the `new CancellationTokenSource(linkedTokens?)` approach, you produce a new source/controller that dominates the cancellation interaction with `inner`. You have the same outer controller `A` (and signal `a`), and you wrap it with an inner controller `B(a)` (with signal `b(a)`). Signal `b(a)` has the following semantics:

- Aborting `A` aborts `a` and `b(a)`.
- Aborting `B(a)` aborts `b(a)`.
- Disposing `A` disposes `a` but not `b(a)`, because `b(a)` could still be aborted by `B(a)`. However, the link between `B(a)` and `a` can be removed and the subscription can be GC'd
- Disposing `B(a)` disposes `b(a)`, but not `a`. Any subscriptions to `b(a)` can be GC'd

[05:08:11.0585] <rbuckton>
So the difference between the two designs is not just one of memory efficiency, but capability. `b(a)` has a capability that `ab` does not.

[05:09:52.0035] <rbuckton>
 * In the `new CancellationTokenSource(linkedTokens?)` approach, you produce a new source/controller that dominates the cancellation interaction with `inner`. You have the same outer controller `A` (and signal `a`), and you wrap it with an inner controller `B(a)` (with signal `b(a)`). Signal `b(a)` has the following semantics:

- Aborting `A` aborts `a` and `b(a)` so long as a link still remains between `a` and `B(a)`.
- Aborting `B(a)` aborts `b(a)`.
- Disposing `A` disposes `a` but not `b(a)`, because `b(a)` could still be aborted by `B(a)`. However, the link between `B(a)` and `a` can be removed and the subscription can be GC'd
- Disposing `B(a)` disposes `b(a)`, but not `a`. Any subscriptions to `b(a)` can be GC'd

[05:10:16.0142] <rbuckton>
 * In the `new CancellationTokenSource(linkedTokens?)` approach, you produce a new source/controller that dominates the cancellation interaction with `inner`. You have the same outer controller `A` (and signal `a`), and you wrap it with an inner controller `B(a)` (with signal `b(a)`). Signal `b(a)` has the following semantics:

- Aborting `A` aborts `a` and `b(a)` so long as a link still remains between `a` and `B(a)`.
- Aborting `B(a)` aborts `b(a)`.
- Disposing `A` disposes `a` but not `b(a)`, because `b(a)` could still be aborted by `B(a)`. However, the link between `B(a)` and `a` can be removed and the subscription can be GC'd.
- Disposing `B(a)` disposes `b(a)`, but not `a`. Any subscriptions to `b(a)` can be GC'd.

[05:27:58.0561] <rbuckton>
I also discuss a lot of this in https://github.com/tc39/proposal-cancellation/blob/master/stage0/README.md, which was pulled out of the explainer when it advanced to stage 1.

[07:52:43.0090] <littledan>
I don't see anything in these docs about disposal. Is disposal really a necessary feature?

[07:57:00.0132] <littledan>
There's some related discussion about being on AbortController vs AbortSignal in https://github.com/shaseley/abort-signal-any/#exposure-through-abortsignal-vs-abortcontroller

[10:03:50.0407] <rbuckton>
> <@littledan:matrix.org> I don't see anything in these docs about disposal. Is disposal really a necessary feature?

See `source.close()` in that stage 0 explainer. I believe it is important, and the lack of it today is wasteful. 

[10:09:56.0125] <rbuckton (traveling)>
https://github.com/tc39/proposal-cancellation/blob/master/stage0%2FREADME.md#sourceclose

[10:17:21.0266] <rbuckton (traveling)>
If you can close/dispose a source, functions that receive the closed token can use more efficency code paths, and registrations that would have introduced closures can be skipped. A source that is left open instead of canceling/closing results in closures holding references to closed over values far longer than necessary. IIRC, AbortSignal doesn't even clean up user code registrations when aborted since user code registrations are event based

[10:18:55.0548] <rbuckton (traveling)>
* If you can close/dispose a source, functions that receive the closed token can use more efficenct code paths, and registrations that would have introduced closures can be skipped. A source that is left open instead of canceling/closing results in closures holding references to closed over values far longer than necessary. IIRC, AbortSignal doesn't even clean up user code registrations when aborted since user code registrations are event based

[10:28:11.0707] <rbuckton (traveling)>
FYI, the most recent iteration of this API is here: https://esfx.js.org/esfx/api/canceltoken.html?tabs=ts

[10:31:45.0010] <rbuckton (traveling)>
Where `CancelToken.race(cancelables)` is the same as `AbortSignal.any`, but `CancelToken.source(cancelables)` is preferred.

[15:00:22.0661] <littledan>
> <@rbuckton:matrix.org> See `source.close()` in that stage 0 explainer. I believe it is important, and the lack of it today is wasteful. 

Oh, I see. This is new for me; I need to think more to understand the implications.


2024-06-04
[03:51:26.0252] <nicolo-ribaudo>
WHATWG adopted a process inspired by our stage-based one:
https://whatwg.org/stages

[07:08:56.0818] <Chris de Almeida>
neat!  I wonder when they'll add 2.7  üßê


2024-06-05
[18:09:06.0532] <Michael Ficarra>
it actually appears it was mostly copied from us before the recent refactoring of the process document and the addition of 2.7

[18:09:09.0905] <Michael Ficarra>
that's a shame

[22:54:19.0718] <littledan>
Actually it matches our new state: tests are required for WHATWG stage 3, which we caught up with when defining Stage 2.7

[03:25:52.0819] <Michael Ficarra>
No, this much more closely matches our process before the 2.7 split. There's no point at which they commit to the specifics of the solution but have not yet created tests and permitted implementation. That was the primary goal of the split. Requiring tests for our stage 3 was only part of it.

[06:21:45.0746] <littledan>
I agree, there‚Äôs no specific intermediate point in their process; people are expected to write tests without that support. Though requiring tests for Stage 3 was a big part for me!


2024-06-07
[11:23:55.0652] <Jack Works>
> <@rbuckton:matrix.org> If you can close/dispose a source, functions that receive the closed token can use more efficency code paths, and registrations that would have introduced closures can be skipped. A source that is left open instead of canceling/closing results in closures holding references to closed over values far longer than necessary. IIRC, AbortSignal doesn't even clean up user code registrations when aborted since user code registrations are event based

yeah, I always write `signal.addEventListener('abort', f, { signal, once: true })`


2024-06-09
[16:21:31.0958] <rbuckton (traveling)>
I tested positive for covid on Saturday and it's hitting me hard. Depending on how my symptoms are tomorrow, I may need to limit my remote attendance to rest. I'll post a late breaking schedule constraint to the agenda tomorrow, if necessary. 

[16:30:51.0360] <Chris de Almeida>
draft schedule is available: https://github.com/tc39/Reflector/issues/527


2024-06-10
[23:37:30.0231] <Chris de Almeida>
please note some items on the schedule have shifted

[23:46:18.0074] <Ashley Claymore>
Oh no! Hope it passes quickly and you're able to some rest Ron

[00:17:23.0438] <nicolo-ribaudo>
> <@softwarechris:matrix.org> draft schedule is available: https://github.com/tc39/Reflector/issues/527

jkup "TG4: Source Maps (5m, Jon Kuperman)" can be removed given that we have the long presentation, right?

[00:17:46.0894] <jkup>
Yes that‚Äôs good with me! I meant to PR removing it 

[13:07:01.0950] <shu>
why is WWDC highlighting RegExp.escape

[13:07:06.0875] <shu>
it's stage 2!

[13:27:56.0110] <Chris de Almeida>
savaged again by the regex hypecycle!

[13:28:07.0263] <kriskowal>
This is funny, but also imagine waiting to jump the gun since https://simonwillison.net/2006/Jan/20/escape/

[13:43:05.0328] <ljharb>
O.o how is wwdc highlighting it?

[13:48:43.0037] <shu>
[https://www.youtube.com/watch?v=RXeOiIDNNek 57:46](https://youtu.be/RXeOiIDNNek?t=3466)

[13:49:09.0883] <shu>
Promise.try too

[13:49:16.0863] <shu>
is this like a list of WIP issues or something

[13:50:04.0282] <Michael Ficarra>
lmao `br_on_cast_fail` what is going on

[13:50:13.0573] <shu>
yeah there are so many questions for that graphic

[13:50:16.0159] <Michael Ficarra>
literally not even developers care about it, that is just for compiler authors

[13:50:27.0442] <shu>
gotta give it to them for keeping it real with showing how the sausage is made

[13:54:07.0185] <jkup>
Oh wow I thought you were joking with the RegExp.escape comment!

[13:54:18.0978] <shu>
me, a joker?


2024-06-11
[18:05:15.0806] <rkirsling>
> <@shuyuguo:matrix.org> Promise.try too

I guess I won't complain that they featured my work like this üòÜ

[23:27:46.0501] <Rob Palmer>
The Zoom is up and the Sign-in form is posted on the Reflector.

https://github.com/tc39/Reflector/issues/527

[00:11:32.0175] <Duncan MacGregor>
Is it the same sign in form for remote and in person?

[00:16:44.0826] <eemeli>
Yes.

[00:18:20.0277] <ryzokuken (TC39 üá´üáÆ)>
have a smooth recovery saminahusain 

[00:20:17.0890] <Aki>
recommendation to presenters: write your summary for notes ahead of time. edit on the fly as needed.

[00:23:33.0946] <littledan>
top quality transcriptionist today

[00:23:44.0791] <littledan>
 * top quality transcription today

[00:28:55.0545] <littledan>
FYI: Google Docs works badly when many people are in the doc. Please close the doc if you just have it in the background, if you're not reading or editing the notes.

[00:32:43.0056] <Michael Ficarra>
@littledan:matrix.org the recurring work was only due to Paged.js failing to break (or not break) according to the breaking rules that we wrote

[00:32:55.0405] <Michael Ficarra>
if a tool supports those rules, we don't need to do that work by hand

[00:33:38.0643] <Michael Ficarra>
for any browser vendors in the room, that tool *could* be your browser if you implement CSS Paged Media btw

[00:34:03.0009] <ryzokuken (TC39 üá´üáÆ)>
cc nicolo-ribaudo üëÄ

[00:34:17.0625] <ryzokuken (TC39 üá´üáÆ)>
 * ^ nicolo-ribaudo üëÄ

[00:37:38.0609] <littledan>
Is ryzokuken audible from remote?

[00:37:49.0999] <Aki>
yes

[00:41:09.0063] <Michael Ficarra>
@littledan:matrix.org in-room audio appears to be modulated separately from zoom audio

[00:41:22.0208] <Michael Ficarra>
if something sounds off to you, ask @eemeli:mozilla.org to adjust it

[00:42:11.0720] <Michael Ficarra>
FYI 402 editors: here is the in-progress editorial conventions document that @bakkot:matrix.org mentioned in the 262 update: https://github.com/tc39/ecma262/wiki/Editorial-Conventions

[00:42:51.0133] <eemeli>
Yeah, in-room and remote audio are routed separately. The speakers on the wall are delivering sound from Zoom, while in-room is from the screen at the other end.

[00:42:56.0744] <littledan>
great bullets bakkot, thanks

[00:50:55.0259] <littledan>
sffc: I would prefer that we not add Gemini-produced summaries in the notes. Let's use our human intelligence to understand what the important points are.

[00:51:24.0585] <littledan>
everyone who wants AI-produced summaries can make them themselves

[00:51:51.0466] <nicolo-ribaudo>
Is the _<< Software identified by reference to the Ecma Standard* ("Software)">>_ in https://github.com/tc39/test262/blob/main/LICENSE#L1 a placeholder, or is it expected to be written like that?

[00:54:24.0594] <Michael Ficarra>
> <@littledan:matrix.org> everyone who wants AI-produced summaries can make them themselves

you're *so close*

[00:54:58.0072] <littledan>
(I don't want to read an AI summary of anything)

[00:55:15.0214] <littledan>
(and it is confusing if they're included in our docs because it looks authoritative)

[00:55:25.0357] <Michael Ficarra>
I agree with both of those statement

[00:55:30.0073] <Michael Ficarra>
* I agree with both of those statements

[00:55:59.0738] <Aki>
holy shit toronto and montreal were merged?

[00:56:13.0908] <Aki>
politically not insignificant

[00:56:19.0300] <Chris de Almeida>
it's Torontreal now

[00:56:34.0128] <Chris de Almeida>
whoops, this isn't TDZ

[00:56:34.0459] <Rob Palmer>
Montronto surely

[00:57:06.0266] <Michael Ficarra>
üëÆ ‚û°Ô∏è #temporaldeadzone:matrix.org

[00:59:20.0345] <hax (HE Shi-Jun)>
typoÔºö chongquing should be chongqing

[00:59:42.0673] <littledan>
> <@haxjs:matrix.org> typoÔºö chongquing should be chongqing

This is a historical entry in TZDB; there are a lot of outdated latinizations there

[01:00:26.0879] <littledan>
(several of the other forwardings discussed were examples of the same)

[01:02:02.0083] <hax (HE Shi-Jun)>
I never see "asia/chongquing" spelling, google shows nothing...

[01:02:37.0411] <rkirsling>
yeah that's an interesting typo that only an English speaker could make

[01:02:46.0464] <littledan>
oh I stand corrected

[01:03:18.0213] <Michael Ficarra>
I thought the whole point of the slide was that some of the timezones were being renamed due to historical misspellings

[01:03:26.0023] <hax (HE Shi-Jun)>
Anyway, "asia/chongqing" -> "asia/shanghai" is a mistake IMO, always cause confusion and accidentaly cause bug üòÇ

[01:03:26.0339] <rkirsling>
(the outdated romanization would be chungking, fwiw)

[01:04:23.0495] <hax (HE Shi-Jun)>
Though it's not the bug of JS, but the bug of TZDB.

[01:06:24.0804] <littledan>
> <@haxjs:matrix.org> Anyway, "asia/chongqing" -> "asia/shanghai" is a mistake IMO, always cause confusion and accidentaly cause bug üòÇ

why is that? is there a chance that China will split into multiple timezones?

[01:08:22.0550] <Richard Gibson>
https://github.com/eggert/tz/blob/d56ae6ee85d496ef67f0428e81060341ec70cec2/backward#L311

[01:08:36.0944] <Chris de Almeida>
> <@littledan:matrix.org> why is that? is there a chance that China will split into multiple timezones?

bit of a misconception there is only one

[01:08:40.0041] <Chris de Almeida>
`Asia/Urumqi`

[01:08:41.0249] <Richard Gibson>
 * https://github.com/eggert/tz/blob/d56ae6ee85d496ef67f0428e81060341ec70cec2/backward#L311
> `Link	Asia/Shanghai		Asia/Chungking	#= Asia/Chongqing`

[01:09:26.0262] <Chris de Almeida>
also different TZ for HK and Macau

[01:09:58.0654] <Chris de Almeida>
although those are UTC+8 same as CST

[01:11:28.0184] <hax (HE Shi-Jun)>
> <@littledan:matrix.org> why is that? is there a chance that China will split into multiple timezones?

It's irrelevant to possible multiple timezones. Asia/Chongqing is a BUG due to misunderstanding of historical timezones in World War II. It never be used broadly in practice in the history. Or if it was been used, it already have no usage from 1950. So keep Asia/chongqing in the TZDB always cause confusion to Chinese programmers and users, especially some users might change the timezone to it and in edge cases it cause weird bugs in the historical dates.

[01:12:59.0643] <littledan>
> <@haxjs:matrix.org> It's irrelevant to possible multiple timezones. Asia/Chongqing is a BUG due to misunderstanding of historical timezones in World War II. It never be used broadly in practice in the history. Or if it was been used, it already have no usage from 1950. So keep Asia/chongqing in the TZDB always cause confusion to Chinese programmers and users, especially some users might change the timezone to it and in edge cases it cause weird bugs in the historical dates.

Great, so sounds like the merge is what should happen

[01:13:51.0887] <JaseW>
TCQ Revolutions

[01:13:53.0531] <hax (HE Shi-Jun)>
> <@littledan:matrix.org> Great, so sounds like the merge is what should happen

Well I think it should be deleted, not merged.. but It might be the deep design philosophy of TZDB which I don't fully agree with.

[01:13:56.0647] <littledan>
Meta: Please link your slides from the agenda so it's easier for folks to follow along (and link the slides from the notes)

[01:14:24.0502] <littledan>
> <@haxjs:matrix.org> Well I think it should be deleted, not merged.. but It might be the deep design philosophy of TZDB which I don't fully agree with.

so if someone uses it, an exception should be thrown, rather than redirecting them to CST?

[01:14:48.0847] <littledan>
Christian Ulbrich: After the presentation, please paste your slide link in the notes

[01:16:08.0854] <ryzokuken (TC39 üá´üáÆ)>
> <@haxjs:matrix.org> Well I think it should be deleted, not merged.. but It might be the deep design philosophy of TZDB which I don't fully agree with.

unfortunately that's not how TZDB is managed, yeah üòï 

[01:16:30.0986] <ryzokuken (TC39 üá´üáÆ)>
so all historic or just incorrect timezones need to stay forever although they could be linked to a more relevant zone

[01:16:46.0098] <hax (HE Shi-Jun)>
> <@littledan:matrix.org> so if someone uses it, an exception should be thrown, rather than redirecting them to CST?

If it's really "merged", I think it's ok. But in fact it will report differently in old dates in 194x ~ 195x. As I understand, TZDB never ensure correctness before 1970, but most OS still use TZDB history part, which IMO is bad, and cause problems.

[01:21:31.0129] <hax (HE Shi-Jun)>
> <@haxjs:matrix.org> If it's really "merged", I think it's ok. But in fact it will report differently in old dates in 194x ~ 195x. As I understand, TZDB never ensure correctness before 1970, but most OS still use TZDB history part, which IMO is bad, and cause problems.

Note "Asia/chongqing" is especially bad case , because in some old version TZDB it even report different time to CST in 198x dates.

[01:27:59.0277] <hax (HE Shi-Jun)>
> <@usharma:igalia.com> so all historic or just incorrect timezones need to stay forever although they could be linked to a more relevant zone

But there were another three China historical timezones in old TZDB and have been deleted, only Asia/Chongqing is merged, not sure why they keep it, IMO they are just from same misunderstand.

[01:28:38.0882] <ryzokuken (TC39 üá´üáÆ)>
> <@haxjs:matrix.org> But there were another three China historical timezones in old TZDB and have been deleted, only Asia/Chongqing is merged, not sure why they keep it, IMO they are just from same misunderstand.

interesting! yeah I have no clue but I'm curious so I'd try to dig around to see why

[01:29:05.0147] <littledan>
> <@haxjs:matrix.org> If it's really "merged", I think it's ok. But in fact it will report differently in old dates in 194x ~ 195x. As I understand, TZDB never ensure correctness before 1970, but most OS still use TZDB history part, which IMO is bad, and cause problems.

Yes, ICU and JS implementations tend to implement this historical part

[01:39:31.0787] <nicolo-ribaudo>
bakkot A few weeks ago I was writing my own source maps decoder, which use base64 but in a weird way: 6-bit-bytes should not be rearranged in 8-bit-bytes, but left as they are (or padded with a leading `00`): `ABCD` is not `[0, 16, 131]` but `[0, 1, 2, 3]`.
The proposals does _not_ support doing anything like this, right? (it's a quite niche use case so I'm not expecting it to, but I'm wondering if I missed something)

[01:39:49.0704] <bakkot>
correct

[01:40:17.0997] <bakkot>
but Michael Ficarra's iterator chunking proposal + flatMap would get you there!

[01:40:44.0549] <bakkot>
actually no it wouldn't, reading closer

[01:41:51.0103] <bakkot>
I guess that's just `[...string].map(x => Uint8Array.fromBase64(x + 'AAA')[0])`

[01:42:37.0696] <bakkot>
or... something like that anyway

[01:42:47.0931] <nicolo-ribaudo>
Oh yes that would work

[01:44:42.0159] <hax (HE Shi-Jun)>
> <@littledan:matrix.org> Yes, ICU and JS implementations tend to implement this historical part

Yeah, even Asia/Shanghai have some weird historical part. So in current js/web application, there is no easy way to represent CST (China standard time) for old dates (just like proleptic Gregorian calendar). It seems the design flaw of TZDB?

[01:45:21.0661] <littledan>
has this feedback been raised to the tzdb mailing list? (we're not really in a position to manage a better tzdb here in TC39)

[01:46:00.0660] <bakkot>
 * I guess that's just `[...string].map(x => Uint8Array.fromBase64(x + 'AAA')[0] >> 2)`

[01:49:25.0098] <sffc>
On the topic of time zones: TZDB and CLDR have both fairly explicitly decided to not prioritize pre-1970 transitions (and especially not pre-WWII transitions) because they were kind of a mess and documentation is kind-of lacking.

[01:50:43.0445] <sffc>
My understanding is that some of the merges are from time zones that had historic differences but have been the same since 1970

[01:52:23.0719] <bakkot>
re: `Symbol.isConcatSpreadable`, not only does no one use it, but also if you do use it then all uses of `Array.p.concat` anywhere on your page get slower in V8: https://www.tines.com/blog/understanding-why-our-build-got-15x-slower-with-webpack-5

[01:57:39.0089] <hax (HE Shi-Jun)>
Is it also get slower in FF/Webkit? Isn't that the bug of v8?

[01:58:02.0666] <bakkot>
it's not a bug, it's an intentional design decision

[01:58:52.0084] <bakkot>
FF and Webkit have similar things though I don't know if they have this specific thing

[02:01:17.0295] <Duncan MacGregor>
There is always going to be a trade off when deoptimising for things likes `isConcatSpreadable`. Just deopting at the particular sites you'll likely use more resources than just noting that the possibility exists everywhere.

[03:20:18.0931] <Luca Casonato>
The `AsyncIterator.propotype.split` thing looks nice

[03:24:20.0116] <Luca Casonato>
I wonder if we can combine the ideas from `split`, but still not require combining  a `split` and `merge`. For example:

```
const parallel = iter.parallelMap(5, (iter) => {
  return iter.map(mapFn).filter(filterFn)
});
```

Would be the same as

```
const parallel = AsyncIterator.merge(
  iter.split(5).map((iter) => {
    return iter.map(mapFn).filter(filterFn);
  })
);
```

[03:24:34.0646] <Luca Casonato>
 * I wonder if we can combine the ideas from `split`, but still not require combining  a `split`, `map` and `merge`. For example:

```
const parallel = iter.parallelMap(5, (iter) => {
  return iter.map(mapFn).filter(filterFn)
});
```

Would be the same as

```
const parallel = AsyncIterator.merge(
  iter.split(5).map((iter) => {
    return iter.map(mapFn).filter(filterFn);
  })
);
```

[03:35:02.0751] <Michael Ficarra>
@aclaymore:matrix.org that's what semaphores are for

[03:44:48.0805] <bakkot>
very pleased to have used 44minutes 30 seconds of a 45 minute timebox

[03:45:01.0756] <bakkot>
> <@michaelficarra:matrix.org> @aclaymore:matrix.org that's what semaphores are for

which we also don't have

[03:45:02.0168] <ryzokuken (TC39 üá´üáÆ)>
like a pro

[03:46:23.0594] <Michael Ficarra>
@bakkot:matrix.org yes but I would prefer the concurrency-limiting function helper anyway

[03:56:25.0040] <bakkot>
> <@lucacasonato:matrix.org> I wonder if we can combine the ideas from `split`, but still not require combining  a `split`, `map` and `merge`. For example:
> 
> ```
> const parallel = iter.parallelMap(5, (iter) => {
>   return iter.map(mapFn).filter(filterFn)
> });
> ```
> 
> Would be the same as
> 
> ```
> const parallel = AsyncIterator.merge(
>   iter.split(5).map((iter) => {
>     return iter.map(mapFn).filter(filterFn);
>   })
> );
> ```

yeah I was thinking about something like this. it's a very weird signature but once you learn to use it I think it does exactly what you want in many cases. a cute thing is that you can pass an async generator as the second argument:

```
iter.parallelMap(5,  async function*(vals) { for await (let item of vals) { yield item + 2 } })
```
or whatever

[03:56:40.0843] <bakkot>
 * yeah I was thinking about something like this. it's a very weird signature but once you learn to use it I think it does exactly what you want in many cases. a cute thing is that you can pass an async generator as the second argument:

```
iter.parallelMap(5, async function* (vals) { for await (let item of vals) { yield item + 2 } })
```

or whatever

[03:58:04.0164] <bakkot>
it does not immediately resolve the question of consuming, but I think that could just be a second function; `iter.concurrentForEach` or something

[03:58:20.0562] <bakkot>
 * it does not immediately resolve the question of consuming without producing a new iterator, but I think that could just be a second function; `iter.concurrentForEach` or something

[03:59:00.0318] <Michael Ficarra>
the note-taker is double-spacing sentences again, are we just gonna fix that up in post?

[03:59:14.0950] <bakkot>
```
let vals = iter.concurrentMap(5, async_generator);

for await (let item of vals) ...
```
and
```
let promise = iter.concurrentForEach(5, async_function);

await promise;
```

[03:59:44.0754] <bakkot>
 * ```
let vals = iter.concurrentMap(5, async_generator_taking_iterator);

for await (let item of vals) ...
```

and

```
let promise = iter.concurrentForEach(5, async_function_taking_iterator);

await promise;
```

[04:00:16.0507] <bakkot>
though maybe `concurrentForEach` would take a `T => void` rather than an `Iterator<T> => void`? unclear

[04:00:53.0393] <bakkot>
(which would make that a bad choice of names)

[04:01:21.0319] <Aki>
> <@michaelficarra:matrix.org> the note-taker is double-spacing sentences again, are we just gonna fix that up in post?

absolutely

[04:01:26.0896] <Aki>
i have a regex for it

[04:03:36.0239] <Michael Ficarra>
k good then we don't need to bug them about it

[04:17:34.0061] <Ashley Claymore>
Option 6 (a-la acorn):

```
const errors = [];
...format(..., { onError: errors });
if (errors.length) { ...}
```

to avoid inline callbacks

[04:23:32.0581] <bakkot>
i can no longer stay awake, but my bot will continue being in the meeting. please don't be misled by its presence, it is just a computer and cannot (yet?) represent my opinions for me

[04:25:08.0596] <bakkot>
for Error.isError, I'm not objecting to stage 2, but I still have reservations about whether it is motivated. i would like it to have strong from other delegates, and the reasons they want it to be captured, before it advances. also I do want to say that it absolutely must consider dom exceptions to be errors; users should not be exposed to that distinction.

[04:34:36.0109] <Luca Casonato>
> <@michaelficarra:matrix.org> @aclaymore:matrix.org that's what semaphores are for

straw man proposal: https://github.com/lucacasonato/proposal-semaphore

[04:34:46.0179] <Luca Casonato>
> <@michaelficarra:matrix.org> @aclaymore:matrix.org that's what semaphores are for

 * straw person proposal: https://github.com/lucacasonato/proposal-semaphore

[04:35:09.0928] <Michael Ficarra>
@lucacasonato:matrix.org lol noooo why?

[04:35:23.0626] <Michael Ficarra>
> @bakkot yes but I would prefer the concurrency-limiting function helper anyway

[04:35:47.0228] <Luca Casonato>
Michael Ficarra: It actually does that too - `semaphore.wait()` is this

[04:36:12.0610] <Luca Casonato>
 * Michael Ficarra: It actually does that too - `semaphore.wait()` is this (minus the wrapping itself)

[04:36:25.0127] <Michael Ficarra>
@lucacasonato:matrix.org that's backwards though

[04:36:44.0052] <mgaudet>
(Do we have a test262 dashboard that has v8 and sm on it? I have https://test262.fyi/ in my history, but this seems incomplete at the moment) 

[04:37:10.0399] <Luca Casonato>
> <@mgaudet:mozilla.org> (Do we have a test262 dashboard that has v8 and sm on it? I have https://test262.fyi/ in my history, but this seems incomplete at the moment)

It's just bugged at the moment - it has V8 and SM usually

[04:37:11.0890] <Michael Ficarra>
`let limitedFunction = fn.limitConcurrency(5)` and then pass `limitedFunction` around in place of `fn`

[04:37:50.0313] <Michael Ficarra>
> <@mgaudet:mozilla.org> (Do we have a test262 dashboard that has v8 and sm on it? I have https://test262.fyi/ in my history, but this seems incomplete at the moment) 

https://github.com/CanadaHonk/test262.fyi/issues/56

[04:38:00.0477] <ptomato>
> <@mgaudet:mozilla.org> (Do we have a test262 dashboard that has v8 and sm on it? I have https://test262.fyi/ in my history, but this seems incomplete at the moment) 

Was just wondering that as well, since I based my remark about implementation status on it üòÖ

[04:38:30.0388] <Luca Casonato>
> <@michaelficarra:matrix.org> @lucacasonato:matrix.org that's backwards though

```js
const semaphore = new Semaphore(12)
function wrap(cb) {
  return (...args) => semaphore.wait(cb);
}
```

I'll add this helper as an open question to the doc :)

[04:39:07.0262] <Michael Ficarra>
yeah but that allows you to wait on the semaphore with multiple functions, right?

[04:39:48.0711] <Luca Casonato>
Yes - I mean isn't that what you want?

[04:40:02.0913] <Luca Casonato>
> <@michaelficarra:matrix.org> `let limitedFunction = fn.limitConcurrency(5)` and then pass `limitedFunction` around in place of `fn`

This lacks flex

[04:40:07.0632] <Michael Ficarra>
no, it's inverted

[04:40:27.0107] <Michael Ficarra>
I want consumers to not have to even know that there's limiting going on

[04:40:57.0802] <Michael Ficarra>
think about it this way: if I am currently passing a function to someone, I want to swap it out with a concurrency-limited one without them changing their implementation

[04:41:14.0857] <Michael Ficarra>
yes I could do that with your wrap helper, and in fact that's how I will always do it

[04:41:30.0561] <Michael Ficarra>
so if I always do it that way, there's no reason to expose the semaphore directly

[04:46:33.0077] <Luca Casonato>
Sure - that makes sense. But there are use cases where this doesn't work - for example if you have `execute` and `query` functions that both operate on the same database, and you want to limit both together.

Another common case for this is when you want to limit the number of FS ops, but there are many different ops. For example you want to limit the number of `stat()`, `realpath()` etc all with the same limiter

Another use case that wrapping is not expressive enough for is if you want to limit the number of open files. Because you "acquire" at every `open` call, but only release once a file handle is explicitly closed.

Also one could propose that we make `Semaphore` sharable across agents :)

[04:49:30.0204] <Luca Casonato>
added a `wrap` method:

```
const semaphore = new Semaphore(5);

const wrappedFunction = semaphore.wrap(async () => {
  // Do some work
});

async function doWork() {
  await wrappedFunction();
}
```

[04:49:34.0938] <Luca Casonato>
 * added a `wrap` method:

```js
const semaphore = new Semaphore(5);

const wrappedFunction = semaphore.wrap(async () => {
  // Do some work
});

async function doWork() {
  await wrappedFunction();
}
```

[04:51:52.0179] <Michael Ficarra>
> <@lucacasonato:matrix.org> Sure - that makes sense. But there are use cases where this doesn't work - for example if you have `execute` and `query` functions that both operate on the same database, and you want to limit both together.
> 
> Another common case for this is when you want to limit the number of FS ops, but there are many different ops. For example you want to limit the number of `stat()`, `realpath()` etc all with the same limiter
> 
> Another use case that wrapping is not expressive enough for is if you want to limit the number of open files. Because you "acquire" at every `open` call, but only release once a file handle is explicitly closed.
> 
> Also one could propose that we make `Semaphore` sharable across agents :)

it does if you virtualise the database through these

[04:52:26.0280] <Luca Casonato>
yeah, but that seems rather unergonomic?

[04:55:28.0516] <Luca Casonato>
You can always do it by creating a function like `(function call(cb, ...args) => cb(args)).limitConcurrency(5)` - but i mean that is very messy and it also does not layer well with `using` - also it's very unergonomic when you are limiting a resource, not a single call

[04:55:48.0955] <Luca Casonato>
 * You can always do it by creating a function like `const call = ((cb, ...args) => cb(args)).limitConcurrency(5)` - but i mean that is very messy and it also does not layer well with `using` - also it's very unergonomic when you are limiting a resource, not a single call

[04:55:50.0317] <Michael Ficarra>
not really, it moves the limiting further inward into like a "kernel"

[04:55:56.0509] <Michael Ficarra>
we should talk over snack break

[04:55:58.0464] <Michael Ficarra>
I want a snack

[04:56:03.0050] <Luca Casonato>
sure :)

[05:02:30.0160] <hax (HE Shi-Jun)>
littledan: 

Regarding `function.sent`, we have discussed use cases and possible solutions in several past meetings. However, there is no consensus on whether the use cases are strong enough to support introducing a syntactic solution. Although I generally still believe this is a problem worth addressing, perhaps solving it through a more general feature like function decorators in the form of an API is more promising than introducing entirely new syntax. Therefore, I hope to revisit this proposal after the function decorator proposal advances to the next stage.

[05:07:34.0223] <ljharb>
good morning. to be clear about Iterator.concat, the behavior I think users will expect has nothing to do with Symbol.concatSpreadable, it's that array concat takes an array or a scalar, and anything with the name concat should do the same (take a container or a thing contained).

[05:07:48.0669] <ljharb>
 * good morning. to be clear about Iterator.concat, the behavior I think users will expect has nothing to do with Symbol.concatSpreadable (which is regrettable and nobody should expect it), it's that array concat takes an array or a scalar, and anything with the name concat should do the same (take a container or a thing contained).

[05:07:54.0966] <ljharb>
 * good morning. to be clear about Iterator.concat, the behavior I think users will expect has nothing to do with Symbol.isConcatSpreadable (which is regrettable and nobody should expect it), it's that array concat takes an array or a scalar, and anything with the name concat should do the same (take a container or a thing contained).

[05:09:36.0714] <ljharb>
 * good morning. to be clear about Iterator.concat, the behavior I think users will expect has nothing to do with Symbol.isConcatSpreadable (which is regrettable and nobody should expect it), it's that array concat takes both arrays or scalars, and anything with the name concat should do the same (take both containers or things contained).

[05:15:29.0761] <ljharb>
link to present for Promise.try: https://github.com/tc39/proposal-promise-try/issues/15

[05:17:46.0151] <littledan>
> <@ljharb:matrix.org> good morning. to be clear about Iterator.concat, the behavior I think users will expect has nothing to do with Symbol.isConcatSpreadable (which is regrettable and nobody should expect it), it's that array concat takes both arrays or scalars, and anything with the name concat should do the same (take both containers or things contained).

ah, sorry for any confusion caused by my misinterpretation

[05:19:04.0925] <Luca Casonato>
test262.fyi is sorta back ^^

[05:19:12.0103] <Michael Ficarra>
it's gradually filling

[05:19:30.0622] <ljharb>


links to present for RegExp.escape:
 - https://github.com/tc39/proposal-regex-escaping/issues/58
 - https://tc39.es/proposal-regex-escaping/


[05:20:01.0312] <littledan>
Congrats ljharb 

[05:20:07.0278] <littledan>
they wouldn't let me clap...

[05:21:51.0619] <littledan>
BTW volunteers welcome for doing the next proposal scrub

[05:32:01.0443] <Michael Ficarra>
I think we should retro the proposal scrub because I value it but it felt unproductive for some parts

[05:32:48.0362] <Ashley Claymore>
> <@haxjs:matrix.org> littledan: 
> 
> Regarding `function.sent`, we have discussed use cases and possible solutions in several past meetings. However, there is no consensus on whether the use cases are strong enough to support introducing a syntactic solution. Although I generally still believe this is a problem worth addressing, perhaps solving it through a more general feature like function decorators in the form of an API is more promising than introducing entirely new syntax. Therefore, I hope to revisit this proposal after the function decorator proposal advances to the next stage.

thanks! I've copied this into the notes in the appropriate section.

[05:34:22.0874] <hax (HE Shi-Jun)>
If do temp check, could we have a simple example to show the difference of two escape solutions ?

[05:34:35.0567] <Rob Palmer>
https://docs.google.com/document/d/19PqeLeKjdy9zTn4OAQEhQVI2zmAxUvZ7eCmnNrKQHeI/edit

[05:34:44.0264] <Rob Palmer>
Nicolo, can you share this on-screen

[05:35:56.0048] <Michael Ficarra>
> <@haxjs:matrix.org> If do temp check, could we have a simple example to show the difference of two escape solutions ?

`\x40` vs `\@`

[05:36:15.0024] <Michael Ficarra>
`for RegExp.escape('@')`

[05:36:23.0659] <Michael Ficarra>
* for `RegExp.escape('@')`

[05:36:48.0167] <Richard Gibson>
> <@haxjs:matrix.org> If do temp check, could we have a simple example to show the difference of two escape solutions ?

if we don't change, `RegExp.escape("$") === "\\$"`. If we do change, `RegExp.escape("$") === "\\x24"`

[05:39:39.0116] <ljharb>


links to present for Error.isError:
 - https://github.com/tc39/proposal-is-error?tab=readme-ov-file#use-cases
 - https://tc39.es/proposal-is-error/

[05:43:43.0014] <Rob Palmer>
I made a mistake of not stating Shu's comments on `RegExp.escape` so will read it out at the next break:

>V8 has no concerns for Stage 2.7.

>As for character vs hex code escapes, V8 can live with either outcome but weakly prefers character escapes. The future stability argument AFAIU is that choosing character escapes makes changing the behavior of character escapes in the future even harder. But it is already very hard to change non-throwing behavior to new non-throwing behavior. We don't understand why this would make it meaningfully harder.

[05:49:47.0894] <Michael Ficarra>
> <@robpalme:matrix.org> I made a mistake of not stating Shu's comments on `RegExp.escape` so will read it out at the next break:
> 
> >V8 has no concerns for Stage 2.7.
> 
> >As for character vs hex code escapes, V8 can live with either outcome but weakly prefers character escapes. The future stability argument AFAIU is that choosing character escapes makes changing the behavior of character escapes in the future even harder. But it is already very hard to change non-throwing behavior to new non-throwing behavior. We don't understand why this would make it meaningfully harder.

that was exactly my opinion

[05:50:58.0145] <littledan>
doesn't it throw an exception if you forget to call super(), unless you take the extreme step of returning something other than this?

[05:51:04.0652] <littledan>
 * doesn't it throw an exception if you forget to call super(), unless you take the extreme step of returning something other than this/undefined?

[05:51:20.0570] <Richard Gibson>
> <@michaelficarra:matrix.org> that was exactly my opinion

I think that's a misunderstanding; the changes would not be from non-throwing to throwing but rather the other way around (such that e.g. `/\@/u` becomes valid)

[05:52:04.0465] <ryzokuken (TC39 üá´üáÆ)>
(possible) hot take: brand checking is orders of magnitude more important (and less icky) than type checking

[05:52:31.0073] <littledan>
> <@usharma:igalia.com> (possible) hot take: brand checking is orders of magnitude more important (and less icky) than type checking

why contrast them? they are both important and just do different things.

[05:52:38.0532] <ryzokuken (TC39 üá´üáÆ)>
oh

[05:52:39.0509] <ryzokuken (TC39 üá´üáÆ)>
true

[05:53:08.0080] <ryzokuken (TC39 üá´üáÆ)>
I guess more accurately: runtime brand checks are important to complement type checks

[05:54:59.0552] <nicolo-ribaudo>
Chris de Almeida (TCQ) Because it's a revoked proxy, so you should not be able to inspect its state

[05:55:02.0866] <nicolo-ribaudo>
Array.isArray does the same

[05:56:17.0012] <Michael Ficarra>
@usharma:igalia.com give me one reason for brand checks

[05:56:58.0896] <ryzokuken (TC39 üá´üáÆ)>
well, you might want to check the "type" of something on runtime? I use code that uses `Array.isArray` all the time?

[05:57:11.0537] <ryzokuken (TC39 üá´üáÆ)>
as do many others I believe

[05:57:13.0758] <littledan>
we're in quite violent agreement about Error.isError returning true for DOMException.

[05:58:56.0950] <Michael Ficarra>
@usharma:igalia.com you should be duck typing, though maybe you need to know whether the object has a magic length property for some reason?

[05:59:13.0448] <ryzokuken (TC39 üá´üáÆ)>
I can give a more specific example from a recent function I wrote but in general when dealing with heterogeneous objects and collections like we do in JS, it's quite useful

[05:59:23.0072] <Michael Ficarra>
like I can see testing for Arrays due to the magic length property and mapped arguments objects because of their magic assignment behaviour

[05:59:44.0014] <Michael Ficarra>
in *general*, you definitely shouldn't be brand checking

[05:59:52.0730] <Michael Ficarra>
those two cases are accounting for language magic

[06:00:17.0081] <ryzokuken (TC39 üá´üáÆ)>
idk what to say... I disagree?

[06:00:35.0696] <ryzokuken (TC39 üá´üáÆ)>
I don't think the stuff I'm writing would be better handled _without_ brand checks

[06:04:32.0613] <Richard Gibson>
> <@michaelficarra:matrix.org> like I can see testing for Arrays due to the magic length property and mapped arguments objects because of their magic assignment behaviour

is there a way to identify a mapped arguments object?

[06:05:01.0824] <ljharb>
> <@gibson042:matrix.org> is there a way to identify a mapped arguments object?

no, this is indeed another missing brand check i seem to always forget about

[06:05:14.0435] <Michael Ficarra>
@ljharb:matrix.org don't you dare

[06:05:15.0775] <ljharb>
> <@gibson042:matrix.org> is there a way to identify a mapped arguments object?

 * no, this is indeed another missing brand check i seem to always forget about. see https://npmjs.com/is-arguments

[06:05:17.0324] <nicolo-ribaudo>
> <@gibson042:matrix.org> is there a way to identify a mapped arguments object?

He said "all _instances_ except for error have a brand check", I found the wording to be carefully chosen :)

[06:05:38.0106] <nicolo-ribaudo>
Can I stop screen sharing?

[06:05:44.0294] <ljharb>
sure, thanks

[06:08:54.0820] <ryzokuken (TC39 üá´üáÆ)>
Michael Ficarra can you expand a bit on "icky"? What's specifically wrong with explicit brand checks apart from just the added cost of an additional static method?

