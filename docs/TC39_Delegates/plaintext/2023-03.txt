2023-03-12
[19:00:52.0741] <Jack Works>
ah

[19:01:01.0146] <Jack Works>
when can we have field declaration in constructor parameter

[19:01:51.0206] <Jack Works>
```js
constructor(#srv) {}
```

rather than

```js
#srv
constructor(srv) {
    this.#srv = srv
}
```

[20:02:28.0439] <ljharb>
what about if you want `this.srv = srv;`?

[21:08:27.0330] <Jack Works>
I don't know ü§£

[01:29:29.0645] <Ashley Claymore>
https://es.discourse.group/t/class-property-parameters/543/12
(Note: this was before I had joined Bloomberg, not a BB proposal)

[07:13:04.0786] <bakkot>
some discussion around `take` being confusing in this thread, with a proposed fix of renaming to `limit`; thoughts? https://github.com/tc39/proposal-iterator-helpers/issues/71#issuecomment-1461841551

[07:13:46.0856] <bakkot>
specifically the confusion is, the subiterator form `take` closes the underlying thing when the subiterator is exhausted, which might confuse people who are wanting to repeatedly take a few items

[07:14:34.0173] <bakkot>
this is a disanalogy with other languages because most things you can call `take` on don't have a notion of "being closed", even iterators

[07:14:37.0750] <bakkot>
cc Michael Ficarra 


2023-03-13
[01:06:56.0495] <bakkot>
ljharb: we have some extra time on the agenda this meeting; if markm's around, do you think we could talk about next steps for making regex escape happen?

[01:07:49.0063] <bakkot>
that is, assuming the next step for that proposal is "talk to the rest of the committee and settle on a design", rather than anything in particular which would need to be done in advance of the meeting

[01:19:48.0498] <bakkot>
(or if anyone has other proposals blocked on similar "we just need to discuss and/or argue about it for a while" issues, this seems like a good time)

[04:41:25.0041] <littledan>
> <@bakkot:matrix.org> (or if anyone has other proposals blocked on similar "we just need to discuss and/or argue about it for a while" issues, this seems like a good time)

Could be fun also to chat about the fundamentals of equality and immutability and what the committee wants there.

[04:43:07.0101] <littledan>
Also, if we are going totally crazy, we could talk about reactivity and signals and observables

[04:43:47.0587] <littledan>
> <@bakkot:matrix.org> (or if anyone has other proposals blocked on similar "we just need to discuss and/or argue about it for a while" issues, this seems like a good time)

 * Could be fun also to chat about the fundamentals of equality and immutability and rekey/compound keys.

[05:08:32.0406] <Jesse>
> <@bakkot:matrix.org> (or if anyone has other proposals blocked on similar "we just need to discuss and/or argue about it for a while" issues, this seems like a good time)

I'm happy to chat about decimal numbers!

[05:13:18.0378] <Jesse>
> <@bakkot:matrix.org> (or if anyone has other proposals blocked on similar "we just need to discuss and/or argue about it for a while" issues, this seems like a good time)

 * I'm happy to chat about numbers (decimal or otherwise)!

[12:36:24.0560] <Michael Ficarra>
‚Ñö?

[12:44:06.0761] <littledan>
‚Ñù?

[12:50:22.0461] <Michael Ficarra>
hopefully not ‚ÑÇ

[15:03:17.0694] <ljharb>
went ahead and added a topic for it


2023-03-14
[01:23:24.0698] <Jesse>
AFAIK there is not current proposal to add ‚ÑÇ to JS ü§£

[01:23:32.0933] <Jesse>
 * AFAIK there is no current proposal to add ‚ÑÇ to JS ü§£

[01:46:42.0155] <nicolo-ribaudo>
https://github.com/tc39/proposal-extended-numeric-literals
"Other numeric types which may be added: [...] Complex numbers" üòõ

[01:48:33.0658] <Andreu Botella>
Next up, quaternions

[01:51:12.0995] <Jesse>
see, there's all sorts of stuff to talk about!

[09:26:19.0632] <Michael Ficarra>
okay, serious question: what advantage do decimals have over rationals?

[09:26:24.0956] <Michael Ficarra>
it seems like rationals would be strictly better

[09:27:20.0136] <Michael Ficarra>
and a rational library is really simple to implement on top of bigints today

[09:36:00.0613] <Jesse>
one concern that comes to mind with rationals would be the normal form representation (unless one wants to expose numerically equal values with different representations). There might be quite a lot of integer division and modulo checks to reduce the numerators and denominators

[09:38:02.0944] <Jesse>
there was a discussion about rationals in proposal-decimal: https://github.com/tc39/proposal-decimal/issues/6

[09:45:27.0832] <littledan>
Rationals and decimals are just different data types. A very common and important operation on decimals is rounding in an inherently base-10 way; this operation doesn't really make sense on rationals.

[09:46:03.0526] <littledan>
pervasive rounding is also important to control size blowup (which, as Waldemar, remains a problem anyway for BigDecimal, but is worse for rationals)

[09:55:21.0264] <Michael Ficarra>
I dunno, that thread seems to support rational pretty well IMO

[09:55:51.0000] <Michael Ficarra>
a smart implementation can amortise the GCDs as appropriate for the platform

[09:56:49.0713] <Michael Ficarra>
anyway, we can talk more about it at the meeting next week

[12:15:53.0207] <littledan>
> <@michaelficarra:matrix.org> I dunno, that thread seems to support rational pretty well IMO

Heh my leading comment there is pretty weak. I'd say that the main factor for me is this round operation. Looking forward to discussing more.


2023-03-15
[12:33:42.0916] <Michael Ficarra>
Reminder for anyone attending the meeting next week: prepare for rain. March is Seattle's rainiest month. It will rain every day.

[12:39:42.0961] <littledan>
ljharb: Just curious, was the ordering there deliberate?

[12:41:17.0821] <ljharb>
 ordering?

[12:59:44.0974] <Ashley Claymore>
Extra please I choose the nearest hotel 

[12:59:50.0213] <Ashley Claymore>
* Extra pleased I choose the nearest hotel

[13:04:03.0989] <Michael Ficarra>
yes, the Lotte literally has a covered walkway between its entrance and the F5 Tower entrance

[13:41:49.0134] <littledan>
the RegExp topic comes amid Stage 3 proposals, even though it's Stage 1

[13:41:56.0048] <littledan>
in the agenda

[14:15:35.0948] <ljharb>
sorting is by timebox first, then stage

[14:15:50.0170] <ljharb>
or did i mess that up, and it‚Äôs the reverse? I‚Äôll check 

[14:16:07.0950] <ljharb>
ah you‚Äôre right, my bad, will fix

[14:33:06.0955] <Michael Ficarra>
no need, I fixed it for you already

[14:36:12.0639] <ljharb>
i saw; there were a few others that needed fixing so i rebased and pushed

[15:25:10.0928] <ptomato>
anyone got any recommendations for where to buy a prepaid SIM card nearby the venue?

[15:33:11.0833] <Michael Ficarra>
ptomato: Will you be arriving via the airport? Usually there are kiosks in the airport.

[15:35:01.0903] <ptomato>
I'm coming by train from north of the border üòÑ

[15:37:42.0944] <Michael Ficarra>
Does your carrier not cover US/Canada? Most US carriers cover Canada at least.

[15:39:45.0772] <ptomato>
I have a very cheap carrier which does not cover the US  - I rarely use talk/text unless I'm travelling, in which case I buy a SIM card

[15:45:52.0233] <Michael Ficarra>
I would probably try this 7-Eleven around the corner: https://goo.gl/maps/Qg11dSu9Fcz2LmRy8

[15:46:24.0313] <ptomato>
thanks!

[15:46:28.0818] <Michael Ficarra>
also if you're picking up masks/tests at the local Bartell Drugs, they may carry prepaid SIM cards

[15:47:02.0001] <ptomato>
those I was going to bring, but that's nonetheless a good tip for others maybe!

[15:48:51.0675] <Michael Ficarra>
it also might not be too late to order a prepaid US SIM online and get it delivered before you leave

[15:49:22.0904] <Michael Ficarra>
that might be better if you're worried about being without talk/text/data on your way from the train to F5 Tower

[15:51:20.0763] <Michael Ficarra>
anyway, if none of those suggestions work, just ping one of us and we can help figure something out

[15:52:09.0715] <ptomato>
I'm not too worried about that, I'd probably be using it more for coordination with other attendees

[15:52:12.0270] <ptomato>
thanks!

[15:53:17.0830] <shu>
https://pagersdirect.net/


2023-03-16
[17:34:50.0862] <Chris de Almeida>
ptomato: if your phone has eSim, I've used the ones you can buy online, and worked well

[17:35:00.0061] <Chris de Almeida>
 * ptomato: if your phone has eSIM, I've used the ones you can buy online, and worked well

[17:36:40.0344] <Chris de Almeida>
well - I only used the data-only one that Orange sells and used in Europe, but presumably can get the same for US from them or another carrier

[17:38:45.0960] <Chris de Almeida>
I avoided the resellers like airalo, etc that route all your stuff through middleperson servers


2023-03-20
[07:55:35.0823] <Rob Palmer>
The draft schedule for this week's TC39 plenary has been posted on [the Reflector](https://github.com/tc39/Reflector/issues/461).  Please do not share the link here because this is a public channel with logs.

[09:03:21.0027] <Rob Palmer>
For those folk in Seattle, we have a dedicated Matrix room for logistics of getting around or meeting for dinner.  Please say if you need an invite.


2023-03-21
[08:14:25.0580] <Rob Palmer>
Hello all.  Plenary meeting begins in just under two hours.

For those attending in person in Seattle, please arrive from 09:20 where you will be met in the F5 lobby.  Breakfast will be served on the same floor as the meeting room from 09:30.

[08:33:28.0750] <shu>
i still don't see a zoom link

[08:43:09.0339] <Rob Palmer>
The entry-form containing the zoom link will be posted in the next 30 mins and I will notify here.

[09:20:52.0868] <Jack Works>
why we're always changing the meeting software ü§î

[09:21:19.0509] <Rob Palmer>
The entry form is now available on the Reflector:  https://github.com/tc39/Reflector/issues/461

[09:22:41.0770] <Rob Palmer>
Jack Works: This is due to host room setup.  The room has been built to work with Zoom, e.g. the AV is connected to an inaccessible Zoom server.  We did try to get Google Meet running with no success.

[09:55:26.0947] <Rob Palmer>
We begin in 5 minutes! 

[09:56:12.0048] <Rob Palmer>
This is our room for the week. 

[09:59:43.0211] <ryzokuken>
looks great!

[10:02:21.0178] <shu>
Customer Engagement Center

[10:04:41.0900] <yulia>
looks really fancy

[10:04:50.0899] <yulia>
(im not present in any form today)

[10:09:55.0474] <Anthony Bullard>
Wish I was there

[10:14:55.0648] <msaboff>
@bakkot You should probably advertise somehow that you are recording for the late arrivals.

[10:25:41.0212] <bakkot>
msaboff: I'll say it again in my editor update

[11:09:14.0210] <shu>
dminor: not sure i understand that point. that sounds like mozilla-internal meeting wrangling

[11:09:44.0985] <ryzokuken>
I think the point they tried to make was that what Shane's mentioning now

[11:09:50.0817] <ryzokuken>
TG2 is run very differently

[11:10:03.0712] <ryzokuken>
for one, the agenda isn't set up clearly ahead of time

[11:10:40.0706] <ryzokuken>
we don't use TCQ but do use a simpler Google Meet queue

[11:10:42.0196] <shu>
ah i misunderstood then, it was about how TG2 is run, not mozilla?

[11:11:07.0994] <ryzokuken>
well, a bit of both I thought

[11:11:32.0299] <ryzokuken>
because of how TG2 is run, Mozilla cannot have structured internal discussions about the agenda a week ahead

[11:11:42.0907] <ryzokuken>
(IIUC, dminor will probably correct me)

[11:11:43.0303] <dminor>
Basically, it would be difficult for us to review proposals properly in advance given the way that TG2 is currently run, so we'd prefer to continue to do advancement in the main committee meetings

[11:12:08.0307] <shu>
dminor: okay, thanks

[11:15:28.0133] <littledan>
Async: Please share the link to the slides on test262 funding so we can reference them from the notes.

[11:25:23.0256] <Ashley Claymore>
https://ptomato.name/talks/tc39-2023-03/

[11:25:27.0795] <Ashley Claymore>
agenda and notes updated

[11:28:54.0614] <Rob Palmer>
To meet Justin Grant's schedule constraint, we are suggesting Temporal will be at 13:00 (first thing after lunch)

[11:31:33.0736] <shu>
wow jordan sounds great

[11:31:37.0004] <shu>
kudos to these room mics

[11:31:43.0224] <apaprocki>
Do any other Ecma TCs have shared costs between member companies that attend? Curious if something like specific TC "dues" could work if rolled up into the yearly fee.

[11:32:20.0825] <apaprocki>
A lot of pain in companies contracting out work if they can't do it themselves is the burden of that internal process... 

[11:35:36.0486] <ljharb>
it definitely seems like the primary purpose of member dues is so Ecma, not individual members, can fund shared needs.

[11:59:02.0634] <HE Shi-Jun>
not sure how renaming to limit/skip solve the problem ...

[12:00:10.0701] <Bradford Smith>
do all of the iterator helpers currently close the underlying iterator?

[12:00:36.0477] <rbuckton>
> <@haxjs:matrix.org> not sure how renaming to limit/skip solve the problem ...

I don't think it does, especially given the rather common meaning of `take` across the ecosystem as well as other languages.

[12:01:13.0781] <littledan>
> <@apaprocki:matrix.org> Do any other Ecma TCs have shared costs between member companies that attend? Curious if something like specific TC "dues" could work if rolled up into the yearly fee.

Ecma folks have told me that there have been shared costs historically, and that members handle their own financial things when it comes up

[12:01:15.0674] <rbuckton>
It's rather trivial to write a wrapper for an iterator that doesn't forward `return`

[12:01:21.0874] <littledan>
(and they consider this best practice in general)

[12:01:35.0695] <Rob Palmer>
We will return in one hour.  If any of the remote attendees have feedback on AV etc please say it here.

[12:01:57.0028] <Bradford Smith>
I find "limit" less understandable than "take". If it helps avoid misunderstanding, I would expect that's only because one has to read the docs to understand what it does at all.

[12:10:06.0956] <peetk>
imo "limit" conveys very clearly that the iterator is closed, i guess because it sounds like SQL limit, and obviously SQL queries are not stateful; whereas "take" is much more ambiguous. but i guess this is a minority view!

[12:56:40.0878] <Bradford Smith>
Are there actually any iterator helpers in the proposal that do *not* close the underlying iterator?

[12:58:20.0647] <Justin Ridgewell>
They all either iterate everything (thus closing the underlying), or close when they early exit

[12:58:26.0161] <bakkot>
`take` is special in that `take` ends _before_ exhausting the underlying iterator

[12:58:33.0685] <Bradford Smith>
My general expectation is that if I pass an iterator off to any other code, I should assume it is exhausted and not touch it again myself.

[12:59:20.0898] <bakkot>
whereas if you `map` or something the expectation is that it either you are exhausting it, which will naturally close the underlying iterator, or closing the `map` helper explicitly

[13:00:03.0787] <Justin Ridgewell>
> <@bakkot:matrix.org> `take` is special in that `take` ends _before_ exhausting the underlying iterator

So does `some`, `every`, and `find`

[13:00:33.0166] <bakkot>
Justin Ridgewell: those don't produce new iterators though

[13:00:37.0297] <rbuckton>
Caveat being that `some`, `every`, and `find` return scalar results

[13:00:42.0904] <bakkot>
they are as it were "consumers" rather than "transfomers"

[13:01:58.0247] <rbuckton>
Though `take` ending before exhausting the iterator is a misconception. The fact it calls `return` is more of an optimization than a meaningful difference when it comes to sequence operators.

[13:02:56.0562] <bakkot>
by "an optimization", do you mean relative to the option of manually exhausting the underlying by calling `.next` repeatedly, or something else?

[13:03:09.0091] <rbuckton>
Yes.

[13:03:41.0995] <rbuckton>
If JS had no `.return` and the only way to close an iterator were to exhaust it, I would expect `take` to exhaust the iterator.

[13:04:14.0735] <rbuckton>
So its good that `return` exists, as it allows us to short-circuit such an expensive operation.

[13:05:10.0505] <rbuckton>
But I'm pretty sure that in every example of prior art in the ecosystem, where `take` is used it means "take X items and exhaust/close the underlying iterator"

[13:05:35.0432] <rbuckton>
If the iterator were a database, I would expect `take` to close the connection when completed. 

[13:05:42.0070] <rbuckton>
 * If the iterator were backed by a database, I would expect `take` to close the connection when completed.

[13:05:55.0389] <rbuckton>
The alternative is resource starvation, which is a bad failure state.

[13:06:41.0972] <rbuckton>
If you want "consume X and not close", that operation is normally named something like `read` (at least, where IO is concerned)

[13:10:50.0479] <ljharb>
erights: i finished the iterator helpers "close the underlying iterator" change before lunch, and it passes all the proposed test262 tests as well as my own

[13:13:24.0852] <Rob Palmer>
We are bringing forward  Async Explicit Resource Management to happen this afternoon.  TCQ and draft schedule are updated accordinlgly.

[13:15:38.0745] <Richard Gibson>
rbuckton: isn't your claim about taking more uncommon directly contradicting by the issue that prompted this discussion?

[13:15:47.0087] <Richard Gibson>
 * rbuckton: isn't your claim about taking more being uncommon directly contradicting by the issue that prompted this discussion?

[13:15:54.0997] <Richard Gibson>
 * rbuckton: isn't your claim about taking more being uncommon directly contradicted by the issue that prompted this discussion?

[13:16:54.0435] <rbuckton>
My impression is that the use case in that issue was a misuse of the API. Perhaps `take` may seem confusing in a vacuum, but not with adequate context

[13:19:18.0829] <littledan>
Why is it "Speaker's summary of key points" rather than "summary of key points" in the notes?

[13:19:25.0606] <Luca Casonato>
Didn't get to it due to time, but there is precedence for a `preventClose`/`preventReturn` option on the web: `preventClose` on `ReadableStream.prototype.pipeTo` and `ReadableStream.prototype.pipeThrough`. I am not necessarily in favour of adding that - but if we did, people may already be familiar with the opt out behaviour.

[13:19:32.0976] <littledan>
> <@littledan:matrix.org> Why is it "Speaker's summary of key points" rather than "summary of key points" in the notes?

I haven't really been seeing speakers fill this in; I think note-takers and the committee could fill it in as well

[13:21:25.0270] <Rob Palmer>
It can be written by anyone so please change the title if you like.  The key is that the presenter ought to be at least approving the summary so that we have some kind of responsibility when distributing the load of writing these summaries.

[13:21:49.0589] <rbuckton>
The confusion is a consequence of choosing to build an API that is dependent on `Iterator` vs the notion of an iterable. As I understood it as the proposal was advancing, basing this on `iterator` meant we were in the realm of "one shot" or "single use" iterators, and that any kind of reusable iteration would rely on arrow functions. IIRC, all of the helper methods are exhaustive, either through repeated calls to `.next` or through the use of `.return`. I don't believe `.take` should be substantially different in this regard. I would much rather have an "opt-out" mechanism to avoid closing an iterator than breaking from the norm here.

[13:24:19.0903] <bakkot>
Definitely agreed that `take` not exhausting is not an option

[13:24:32.0268] <bakkot>
the question was just whether a different name could lead people to correctly intuit the semantics

[13:25:11.0716] <shu>
my intuition is no, unless the name is literally, like `takeAndThenClose`

[13:32:43.0097] <rbuckton>
The alternative, `.limit`, only really makes sense for numeric arguments. It becomes much less clear if you later adopt something like `.limitWhile` (vs. `.takeWhile`). 

[13:33:56.0964] <bakkot>
fun fact, Java has both `limit` and `takeWhile`

[13:34:01.0171] <bakkot>
(and no `take`)

[13:36:27.0529] <apaprocki>
64+32 Abseil: https://github.com/abseil/abseil-cpp/blob/master/absl/time/duration.cc#L15-L50

[13:37:43.0324] <rbuckton>
> <@lucacasonato:matrix.org> Didn't get to it due to time, but there is precedence for a `preventClose`/`preventReturn` option on the web: `preventClose` on `ReadableStream.prototype.pipeTo` and `ReadableStream.prototype.pipeThrough`. I am not necessarily in favour of adding that - but if we did, people may already be familiar with the opt out behaviour.

I know that NodeJS has that concept, i.e.`stream.pipeline(streams, { end: true })` https://nodejs.org/dist/latest-v19.x/docs/api/stream.html#streampipelinestreams-options

[13:38:29.0202] <rbuckton>
and `readable.pipe(dest, { end: true })`. I'm not sure about the DOM APIs offhand

[13:39:17.0292] <Luca Casonato>
for DOM it'd be `readable.pipeTo(writable,  { preventClose: true })`

[13:39:47.0175] <rbuckton>
Yeah, I misread your comment as a question, sorry.

[13:49:37.0810] <shu>
waldemar: the core confusion from me is why do you trust multiple implementations to be correct and interoperable here, if you don't trust the spec to be correct (because it's so tricky to get correct)?

[13:49:51.0898] <shu>
like my goal isn't _just_ a correct document, it's correct interopable implementations

[13:52:12.0744] <waldemar>
shu: It sounds like you're trying to fit the spec around one possible (and pretty problematic) implementation. The spec should be implementation-agnostic about internal details.

[13:53:05.0309] <shu>
in this case my understanding is that the bounds the champions are working to put in place are precisely so that it _is_ implementable with that technique

[13:53:07.0106] <waldemar>
I'm also more interested in the ns vs ¬µs question.

[13:53:15.0568] <shu>
(also why is the 64+32 impl problematic?)

[13:54:26.0790] <littledan>
> <@waldemarh:matrix.org> I'm also more interested in the ns vs ¬µs question.

I know that ptomato framed this as "for future discussion" but I don't see any arguments to switch to microseconds at this point.

[13:54:37.0744] <waldemar>
Elementary math: 64+32 can implement integral counts of subseconds. This is obvious.

[13:55:20.0924] <shu>
well, V8's position is still pro microseconds, but we won't block the proposal on it if implementation complexities and bad performance cliffs are addressed

[13:55:27.0356] <waldemar>
Not obvious: spec that explicitly manages two integers implements integral counts of subseconds. It's easy to get carries and overflows wrong, and you can't tell without examining the entire spec.

[13:55:55.0814] <shu>
i agree with you

[13:56:13.0093] <shu>
what i don't get is, why do you think that trickiness is best left for implementations to all figure out via implication?

[13:56:24.0591] <waldemar>
If you just want ¬µs, then you can store durations in flat 64-bit integers and get a much more efficient implementation with a range of >500,000 years.

[13:56:46.0855] <shu>
indeed! *i* just want us

[13:56:56.0920] <shu>
but v8 has not been able to convince the champion group

[13:57:38.0077] <littledan>
> <@waldemarh:matrix.org> If you just want ¬µs, then you can store durations in flat 64-bit integers and get a much more efficient implementation with a range of >500,000 years.

Do we have any information that this difference in performance will be signficant? there's so much other stuff going on anyway

[13:58:05.0253] <shu>
it's a nuanced conversation that's hard to tease apart

[13:58:26.0047] <shu>
it's not just absolute performance, it's the complexity around supporting optimized paths also

[13:58:29.0671] <shu>
it's philosophical objection

[13:58:51.0766] <waldemar>
Whether a difference in performance is significant depends on who is writing the benchmark ‚ò∫

[13:59:09.0649] <shu>
apaprocki has given examples of other systems that support ns that temporal might want to interface with, which i don't really get at all

[13:59:21.0573] <apaprocki>
ns are common enough nowadays that it seems it would be limiting use cases unnecessarily by limiting to ¬µs, e.g. node embeds v8 and would hopefully like to represent filesystem times without losing precision 

[13:59:25.0919] <shu>
those other systems don't have ns as part of a date-time arithmetic library, they're raw ns counts

[13:59:31.0145] <shu>
they're int64s

[13:59:57.0154] <shu>
what i'm saying is it doesn't follow "ns are common enough -> ns need ot be supported in a fully featured date-time arithmetic library" 

[14:00:08.0297] <shu>
you still can just put the raw ns count into a BigInt

[14:02:34.0445] <shu>
V8 position is:

- ideal: us precision, simple bounded arithmetic + storage follows straightforwardly
- can live with: ns precision, with 64+32 being a tried-and-proven implementation technique from e.g. abseil that we can use
- cannot live with: ns precision, bigint math required

[14:02:47.0123] <apaprocki>
> <@shuyuguo:matrix.org> what i'm saying is it doesn't follow "ns are common enough -> ns need ot be supported in a fully featured date-time arithmetic library"

well, take filesystem times.. certainly those are displayed on screens as formatted date times and not counts

[14:02:59.0803] <shu>
great, it's fine to format them

[14:03:12.0989] <shu>
you need to do full arithmetic to ns precision?

[14:03:18.0717] <shu>
how is that useful?

[14:06:25.0107] <littledan>
> <@shuyuguo:matrix.org> you need to do full arithmetic to ns precision?

I haven't found this as a hard requirement for us when I talked to the relevant groups (except for certain algorithms like PTP which we probably wouldn't end up porting to JS)

[14:06:35.0169] <littledan>
> <@shuyuguo:matrix.org> you need to do full arithmetic to ns precision?

 * I haven't found this as a hard requirement for us when I talked to the relevant groups inside of Bloomberg (except for certain algorithms like PTP which we probably wouldn't end up porting to JS)

[14:08:51.0733] <apaprocki>
there are certain feeds of information where the individual events are represented in ns precision and series of events could be displayed as offsets from an initial event (in essence, durations from an arbitrary epoch rather than UTC epoch)

[14:10:00.0699] <littledan>
> <@shuyuguo:matrix.org> what i'm saying is it doesn't follow "ns are common enough -> ns need ot be supported in a fully featured date-time arithmetic library"

I think using ns would create somewhat of a risk, that Temporal might become obsolete (which is a surprising choice given how much else we decided to be super future-proof for). It's sort of clear that we don't really need to go more precise than ns.

[14:10:54.0630] <littledan>
(and a later evolution here would be really bad, given compat/interop risks)

[14:12:25.0663] <littledan>
> <@shuyuguo:matrix.org> what i'm saying is it doesn't follow "ns are common enough -> ns need ot be supported in a fully featured date-time arithmetic library"

 * I think using us would create somewhat of a risk, that Temporal might become obsolete (which is a surprising choice given how much else we decided to be super future-proof for). It's sort of clear that we don't really need to go more precise than ns.

[14:12:29.0713] <littledan>
yes (edited)

[14:15:43.0565] <littledan>
Good news everyone: The transcriptionist might be available for tomorrow!

[14:15:52.0285] <littledan>
(they got back to me by email)

[14:28:00.0963] <bakkot>
this isn't worth bringing up, but `await` is not reserved in strict mode, only in module code and async functions

[14:28:42.0649] <Michael Ficarra>
very very few people are aware of syntax being dependent on the start symbol

[14:29:36.0312] <ljharb>
bakkot: perhaps we should have `Set.prototype.sort` if the sort order is important?

[14:30:06.0717] <Michael Ficarra>
if you're going to explicitly manage the sort order, put it in an explicitly ordered container

[14:30:08.0011] <bakkot>
the problem is that when I care about the order it's because I care about insertion order specifically

[14:30:15.0760] <bakkot>
and you can't sort it into "insertion order"

[14:32:31.0826] <ljharb>
ah true, hm

[14:35:05.0259] <Michael Ficarra>
I know we don't have much else to go on, but I feel like we're taking these poll results way too seriously

[14:35:24.0998] <bakkot>
right now we're just hearing what they are

[14:35:38.0876] <bakkot>
no one has expressed anything about what to do with them

[14:41:29.0362] <Michael Ficarra>
for await has always felt like an awkward piece of syntax to me, though

[14:41:55.0097] <Michael Ficarra>
like I don't know if we should be using it to guide future syntax choices

[14:44:04.0128] <bakkot>
tbf if we're just picking something because we have to pick something, "difficulty of parsing" is a fine reason to choose - I just wouldn't want "difficulty of parsing" to prevent us from picking a thing we do all think is best

[14:44:46.0829] <littledan>
> <@michaelficarra:matrix.org> for await has always felt like an awkward piece of syntax to me, though

huh? it seems intuitive to me

[14:46:48.0421] <justinfagnani>
as a code reader, I kind of want a syntactic note on the block that it may await at the end, not just on individual statements in the block

[14:46:57.0596] <justinfagnani>
like `async` on a function

[14:48:33.0530] <Rob Palmer>
justin, is this just syntax shock?  I fully have the same initial reaction as you.  I just recall many times when my initial reaction is later overcome once it goes into the language and you get used to it

[14:49:10.0295] <shu>
that's not much of an argument though, because you can make that about literally syntax we choose?

[14:49:10.0331] <justinfagnani>
could be?

[14:49:14.0119] <shu>
"you'll get used to it"

[14:49:22.0426] <shu>
 * that's not much of an argument though, because you can make that about literally any syntax we choose?

[14:49:26.0480] <Rob Palmer>
That could be the JS motto.

[14:50:12.0880] <bakkot>
justinfagnani: yeah the original design was more like python's `with` or java's `try-with-resources`, which has that 

[14:50:21.0966] <bakkot>
but we ultimately decided not that

[14:50:29.0099] <justinfagnani>
Would something like:
```
async {
   await using x = y;
   foo();
}
```
make it more clear that the block may yield at the end?

[14:50:33.0891] <justinfagnani>
bakkot: ok

[14:50:37.0837] <Mathieu Hofman>
FYI, Mark is not active on Matrix

[14:50:46.0510] <rbuckton>
> <@justinfagnani:matrix.org> Would something like:
> ```
> async {
>    await using x = y;
>    foo();
> }
> ```
> make it more clear that the block may yield at the end?

This was something we discussed in depth and resolved in the last meeting

[14:50:55.0721] <justinfagnani>
ok, thanks

[15:05:19.0405] <Chris de Almeida>
so... what just happened?

[15:05:25.0268] <shu>
sorry all didn't mean to make the decision space so complicated

[15:05:31.0549] <littledan>
no this was good

[15:05:45.0358] <littledan>
please read the summary at the bottom of the notes page and edit it or make comments as needed

[15:05:48.0069] <shu>
the only signal i got from the past 10 minutes is, the consensus was not just "we can all live with await using" but in fact "we are now convinced `await using` is the ideal, if achieveable"

[15:05:53.0298] <shu>
which is a good signal

[15:05:57.0943] <shu>
and backs up coming back next meeting

[15:06:00.0607] <rbuckton>
Having a block-level indicator was the issue blocking the async version `using` for the past few years.

[15:06:06.0814] <Chris de Almeida>
> <@littledan:matrix.org> please read the summary at the bottom of the notes page and edit it or make comments as needed

yes -- maybe we should ask for consensus on that summary.. I'm concerned we are not all on the same page

[15:06:14.0876] <Chris de Almeida>
> <@littledan:matrix.org> please read the summary at the bottom of the notes page and edit it or make comments as needed

 * yes -- maybe we should ask for consensus on that summary conclusion.. I'm concerned we are not all on the same page

[15:06:21.0656] <littledan>
> <@shuyuguo:matrix.org> the only signal i got from the past 10 minutes is, the consensus was not just "we can all live with await using" but in fact "we are now convinced `await using` is the ideal, if achieveable"

Yes, I think `await using` has broad support (and this is why I wanted to do a temperature check)

[15:06:29.0154] <littledan>
> <@softwarechris:matrix.org> yes -- maybe we should ask for consensus on that summary conclusion.. I'm concerned we are not all on the same page

could you elaborate?

[15:06:58.0726] <littledan>
(I did ask everyone to review it, but we can come back and project it to force everyone to review it when we come back from the break)

[15:07:33.0412] <shu>
littledan: heh, i still don't like it! but i'm fine with it

[15:08:13.0686] <Chris de Almeida>
what's there atm makes sense to me -- just want to confirm expectations as it seemed we might have been going a different direction for a bit there

[15:21:25.0730] <shu>
i have lost my apartment internet due to what i assume is high winds in SF currently

[15:21:43.0247] <shu>
i don't have good enough cell service to do zoom, so looks like i am out for the remainder of today :/

[15:26:09.0968] <shu>
wait maybe i have enough phone tether to do zoom

[15:26:13.0137] <shu>
it's like 90% packet loss

[15:27:07.0752] <apaprocki>
do you live in a dirigible?

[15:27:45.0497] <shu>
it's called san francisco, thank you

[15:28:38.0743] <sffc>
Frank Tang also said he's been in and out of power/internet

[15:32:32.0318] <littledan>
BTW here are my conclusion notes for the await using topic, please edit in the notes if you want to make changes:

### Summary
Various grammars for async resource disposal were considered, including results from polls. The champion's preference became `await using`, and several delegates were swayed to prefer this option based on the data and arguments presented.
There are concerns about the parse-ability of `await using`, both based on practical implementations and the fit into the ES spec's cover grammars; it's unclear if certain edge cases will be easy to manage.
If `await using` isn't viable, it's likely that `async using` isn't viable, and the committee may come back to the conclusion of `using await`, but this will need to come back to plenary for future discussion.

### Conclusion

The committee resolves to attempt the syntax `await using`.
The grammar will need to be worked out in a PR, which will need to be presented in a future plenary for review and consensus.


[15:44:10.0244] <shu>
i am triggered about static private semantics

[15:44:39.0478] <Chris de Almeida>
same

[15:44:54.0817] <bakkot>
static private semantics are actually fine

[15:45:12.0691] <bakkot>
the problem is that `class extends` implies inheritance not just of instances but of _the constructors themselves_, which is wack

[15:46:15.0692] <littledan>
> <@bakkot:matrix.org> the problem is that `class extends` implies inheritance not just of instances but of _the constructors themselves_, which is wack

I'm like 80% sure I agree. Constructor inheritance is definitely used.

[15:46:57.0635] <bakkot>
yeah I use it myself

[15:47:37.0798] <bakkot>
but it should never have existed, it gives us the wild things like `Promise.resolve` not working unless bound (whereas `Array.from` does, for... reasons)

[15:54:51.0113] <Michael Ficarra>
we *really* need to figure out a more appropriate organisational scheme for well-known symbols than putting them all on Symbol

[15:55:34.0964] <Michael Ficarra>
I don't blame this proposal author for this choice, since we don't have committee guidance on the topic

[15:56:31.0438] <littledan>
> <@michaelficarra:matrix.org> we *really* need to figure out a more appropriate organisational scheme for well-known symbols than putting them all on Symbol

I don't really see the same issue; it's just a single namespace for these things, just like if we had called it `__metadata__`

[15:58:08.0598] <Michael Ficarra>
littledan: yes, a single global namespace for everything is bad, whether that is globalThis or Symbol

[15:58:34.0798] <danielrosenwasser>
Hey all, Ron (rbuckton ) and I will be requesting a new agenda item this Thursday which will propose the preferred `await using` syntax for the [Async Explicit Resource Management proposal](https://github.com/tc39/proposal-async-explicit-resource-management). We're currently working on the grammar, but will let everyone know when the slides and changes are ready to review.

[15:58:35.0874] <Michael Ficarra>
ironically, that opinion is also on-topic for this topic

[15:59:23.0557] <shu>
i don't think a single global namespace is bad

[16:00:01.0605] <shu>
i think it's only ex ante bad but is mostly ok

[16:01:07.0925] <Chris de Almeida>
`var doNotPolluteTheGlobalNamespace = {};`

[16:02:35.0315] <littledan>
Option 3 feels the most bizarre to me, since the intended usage of it needs to go back to the single namespace anyway

[16:02:46.0538] <Michael Ficarra>
shu: surely with time, we will have more than 1 built-in protocol that want to use the same simple name for one of their provided/required fields

[16:03:30.0038] <shu>
that's why i said ex ante bad

[16:03:41.0897] <Michael Ficarra>
none of these well-known symbols have particularly unique simple names

[16:03:44.0980] <shu>
my point is that when we come to that bridge it's usually not a big deal to work around

[16:04:25.0565] <Michael Ficarra>
shu: fair, though it would be nice to set a precedent for userland protocols, especially if we ever have a world with first-class protocols

[16:06:23.0343] <Ashley Claymore>
which class does the metadata get added to? If there was a class decorator which returns a new class, does that get it, or should it have to make sure it 'forwards' on `Symbol.metadata' ?

[16:06:59.0574] <rbuckton>
The final class

[16:07:22.0430] <rbuckton>
(I think)

[16:07:45.0685] <Ashley Claymore>
so might not work if the decorator freezes the class

[16:07:47.0189] <Ashley Claymore>
 * so might not work if the decorator freezes the class?

[16:07:54.0096] <rbuckton>
A _good_ class decorator that performs replacement should either subclass with `extends`, unless it is doing something very complex.

[16:09:06.0150] <ljharb>
either, or what?

[16:09:42.0764] <rbuckton>
 * A _good_ class decorator that performs replacement should either subclass with `extends`, or use `.setPrototypeOf` to emulate that approach, unless it is doing something very complex.

[16:10:34.0688] <Ashley Claymore>
so `Symbol.metadata` would already be there on the class that is being decorated? Rather than added to the final class?

[16:11:04.0438] <rbuckton>
I'd have to recheck the spec

[16:13:52.0835] <shu>
i'm confused about kevin's use case

[16:14:29.0049] <bakkot>
two libraries which both want to use the key `type`

[16:14:38.0539] <bakkot>
including possibly two major versions of the same library

[16:14:46.0128] <bakkot>
you fundamentally cannot use these things at the same time

[16:15:01.0597] <bakkot>
because it's a shared global namespace

[16:15:07.0828] <shu>
is he saying programs will want multiple versions of the same decorator library in the same running app...?

[16:15:34.0624] <bakkot>
multiple versions of a library in the same app is a thing which happens constantly

[16:16:32.0796] <Luca Casonato>
rbuckton: if you want a shared global namespace in scripts, use `globalThis`? why do we need to add a second global namespace? if you really want a global namespace, there already is one already

[16:17:04.0918] <littledan>
> <@bakkot:matrix.org> multiple versions of a library in the same app is a thing which happens constantly

right, I guess the question is: are we more likely to want them to share or partition the namespace? I think share is more pragmatic, given the cases we've heard about. What's more likely to work in practice?

[16:17:20.0627] <shu>
but... why is the app use two major versions of the same library in the same app? that happens?

[16:17:28.0176] <bakkot>
that happens constantly

[16:17:32.0622] <bakkot>
littledan: they can't share

[16:17:38.0673] <rbuckton>
> <@lucacasonato:matrix.org> rbuckton: if you want a shared global namespace in scripts, use `globalThis`? why do we need to add a second global namespace? if you really want a global namespace, there already is one already

That is essentially what `reflect-metadata` does, and one of the things we have sorely wanted to address with this proposal.

[16:17:39.0422] <bakkot>
like, that's the problem

[16:17:41.0650] <bakkot>
they ause the same key

[16:17:44.0692] <bakkot>
 * they use the same key

[16:17:47.0678] <shu>
it happens constantly?

[16:17:51.0130] <rbuckton>
We cannot mutate `globalThis` in a locked down environment like SES

[16:17:51.0819] <bakkot>
and coordinating it becomes the consumer's problem

[16:17:53.0381] <Jesse (TC39)>
the various layers of dependency hell

[16:18:27.0879] <littledan>
> <@bakkot:matrix.org> littledan: they can't share

I don't see why this is such an absolute, rather than pragmatic, thing

[16:18:32.0126] <shu>
okay i think i'm getting the picture. currently the builders do some kind of deduplication / versioning at the build step for regular import/exports

[16:18:36.0226] <rbuckton>
Also, `[Symbol.metadata]` isn't necessarily a "global namespace" any more than a static property on the class is a global namespace. Because the `[Symbol.metadata]` property _is_ a static property on a class.

[16:19:06.0979] <bakkot>
rbuckton: right, class fields are also a shared namespace, which is why string-named mixins was not a viable proposal

[16:19:51.0818] <littledan>
> <@bakkot:matrix.org> rbuckton: right, class fields are also a shared namespace, which is why string-named mixins was not a viable proposal

Symbol-named protocols are also not beyond Stage 1; I still like string-named mixing.

[16:20:01.0209] <rbuckton>
There's a difference between "shared namespace" and "global namespace" though. The 2nd term has more implications

[16:20:02.0006] <littledan>
> <@bakkot:matrix.org> rbuckton: right, class fields are also a shared namespace, which is why string-named mixins was not a viable proposal

 * Symbol-named protocols are also not beyond Stage 1; I still like string-named mixing.

[16:20:08.0593] <littledan>
 * Symbol-named protocols are also not beyond Stage 1; I still like string-named mixins.

[16:20:25.0140] <bakkot>
the names of all fields used in all decorators anywhere must be unique

[16:20:26.0501] <bakkot>
that's global

[16:20:37.0160] <rbuckton>
I want a mutable object _because_ I don't want a shared _global_ namespace.

[16:21:03.0959] <rbuckton>
The alternative to use `globalThis` mandates I do the worse thing

[16:21:13.0143] <bakkot>
rbuckton: but only you

[16:21:14.0723] <Michael Ficarra>
"be careful" assumes that all parties are coordinating, but in reality, pages and applications are often composed of many non-coordinating scripts

[16:21:20.0904] <bakkot>
I am OK with only typescript having to do the worse thing

[16:21:29.0099] <bakkot>
as long as everyone else falls into the happy path of the right thing

[16:21:41.0951] <rbuckton>
Its not only typescript, its every typescript user.

[16:22:10.0865] <ljharb>
TS users presumably would only use an interface TS provides

[16:22:12.0729] <ljharb>
 * TS users presumably would only use an interface TS provides?

[16:22:14.0185] <littledan>
> <@michaelficarra:matrix.org> "be careful" assumes that all parties are coordinating, but in reality, pages and applications are often composed of many non-coordinating scripts

You only have to worry about the set of decorators that a particular class uses.

[16:22:42.0743] <ljharb>
 * TS users presumably would only use an interface TS provides, regardless of which option was chosen?

[16:23:12.0423] <Michael Ficarra>
littledan: and are those decorators always created by a single party or by coordinating parties? I doubt it

[16:23:36.0238] <nicolo-ribaudo>
> <@littledan:matrix.org> You only have to worry about the set of decorators that a particular class uses.

Decorators from different libraries can usually be mixed, so the decorator author doesn't really know what this set is

[16:24:06.0689] <littledan>
> <@nicolo-ribaudo:matrix.org> Decorators from different libraries can usually be mixed, so the decorator author doesn't really know what this set is

I don't think this is really true with framework decorators

[16:24:27.0156] <Michael Ficarra>
littledan: "not true for some cases" is not the bar we're trying to meet here

[16:24:42.0984] <bakkot>
ljharb: re: your queue item, the only reason I suggested a frozen object instead of a symbol is that a frozen object lets you get to the parent metadata

[16:25:53.0459] <ljharb>
makes sense, thanks

[16:27:23.0920] <rbuckton>
`Symbol.for("foo")` isn't much better than `"foo"`

[16:27:32.0974] <bakkot>
I didn't mention this, but the other downside of option 1 is that it is public-by-default, which is... very bad

[16:27:47.0005] <bakkot>
you can remember to be disciplined about it but people will not remember

[16:27:50.0497] <littledan>
> <@bakkot:matrix.org> I didn't mention this, but the other downside of option 1 is that it is public-by-default, which is... very bad

It's not anything by default; it's just as easy to use the WeakMap with it

[16:27:55.0515] <bakkot>
no it isn't

[16:27:56.0570] <rbuckton>
> <@bakkot:matrix.org> I didn't mention this, but the other downside of option 1 is that it is public-by-default, which is... very bad

There is no default. Its purely based on usage. 

[16:28:08.0037] <bakkot>
it is not as a easy to use a weakmap as it is to use a string-named property

[16:28:29.0434] <rbuckton>
But option 2 has the same level of difficulty with weakmaps

[16:28:54.0704] <bakkot>
yes but that's the only way to use it, so that's fine

[16:29:05.0551] <bakkot>
like, as a practical matter, people are going to use public string-named properties with option 1, even when they don't intend to make a public API

[16:29:08.0483] <bakkot>
that is what is going to happen

[16:29:18.0673] <bakkot>
that is what "public-by-default" means

[16:31:01.0734] <rbuckton>
That is more about documentation and learning than it is about capability. If you tell folks, use `WeakMap` or `Symbol`, if you're concerned about collisions, but strings or `Symbol.for` if you're not. Library authors will almost certainly avoid collisions, end user applications often won't need to.

[16:31:19.0821] <rbuckton>
 * That is more about documentation and learning than it is about capability. If you tell folks, use `WeakMap` or `Symbol` if you're concerned about collisions, but strings or `Symbol.for` if you're not. Library authors will almost certainly avoid collisions, end user applications often won't need to.

[16:31:49.0277] <bakkot>
You have a lot more faith in the power of documentation to shape what happens than I do

[16:31:55.0554] <bakkot>
for that matter you also have more faith in the power to shape documentation

[16:31:56.0810] <rbuckton>
Assignments to `context.metadata` will never be so symbol as `context.metadata["a"] = b` anyways

[16:32:08.0603] <littledan>
I really appreciate you being flexible here, bakkot ljharb Michael Ficarra . It's great that we're able to move forward and not have a big gap of metadata-less decorators

[16:32:10.0699] <rbuckton>
 * Assignments to `context.metadata` will never be so simple as `context.metadata["a"] = b` anyways

[16:32:42.0373] <rbuckton>
`context.metadata` is just an object. If you need to differentiate between a class, or a method, or a field you still have more work to do to avoid collisions, even in the `WeakMap` case.

[16:32:49.0981] <Justin Ridgewell>
Is the `context` object (not the `context.metadata` obj) consistent between all decorator invocations on a particular class?

[16:32:57.0366] <Justin Ridgewell>
Or is it a new object for every invocation?

[16:33:09.0032] <rbuckton>
Same object for every decorator on a single class

[16:33:21.0683] <rbuckton>
including the methods and fields.

[16:34:03.0250] <Justin Ridgewell>
If we had chosen Option 2 here, would there even have been a need for `context.metadataKey` at all?

[16:34:15.0750] <Justin Ridgewell>
We could have just keyed the `WeakMap` on `context`

[16:34:18.0484] <rbuckton>
```js
@((_, ctx) => { ctx.metadata["a"] = 1; })
class C {
  @((_, ctx) => { ctx.metadata["b"] = 2; })
  method() {}
}
```
produces a single object with `{ a: 1, b: 2 }`

[16:34:23.0439] <bakkot>
yeah you need it to be available after decoration time

[16:34:29.0746] <bakkot>
and you don't want to share the `context` object

[16:34:36.0275] <bakkot>
which has a bunch of decorator-time-only stuff on it

[16:34:42.0972] <Justin Ridgewell>
Ah, ok

[16:34:45.0017] <rbuckton>
sorry, I misread.

[16:34:51.0692] <rbuckton>
`context` is not shared, only metadata is.

[16:35:10.0461] <rbuckton>
 * sorry, I misread (despite your clarification).


2023-03-22
[08:58:27.0741] <Rob Palmer>
Good morning, all.  Plenary begins in one hour.

[09:27:16.0857] <rbuckton>
For those interested, I have two draft PRs up that illustrate the potential cover grammars for `await using` and `async using`:
- `await using`: https://github.com/tc39/proposal-async-explicit-resource-management/pull/15
- `async using`: https://github.com/tc39/proposal-async-explicit-resource-management/pull/16

[10:18:36.0107] <yulia>
slides for the awkwardly done election (sorry about that y'all) https://docs.google.com/presentation/d/1xQ7huTJQsbcfFM6nhN7Tk3uBUf3h7FHkroM1m56ueZE/edit#slide=id.g6e7d7a6a09_0_98

[10:20:15.0551] <ptomato>
I thought it was fine, I had no problem with the process, personally

[10:21:45.0300] <yulia>
ah nice, i like source as a keyword

[10:22:10.0487] <Michael Ficarra>
I already love this presentation

[10:34:05.0592] <Justin Ridgewell>
Wait, he said "next slide" right?

[10:34:14.0416] <Justin Ridgewell>
I'm still seeing "Import phase syntax" slide

[10:34:37.0723] <Chris de Almeida>
we're on spec: ordering of fetches slide

[10:34:50.0522] <Chris de Almeida>
now on spec: idempotence is unchanged

[10:35:05.0291] <Chris de Almeida>
https://docs.google.com/presentation/d/1F62Jia5erIm6m6nqkm_2pFIlNLOVF0E4ewrVRytSJEs/edit

[10:48:31.0390] <Michael Ficarra>
this seems like a thing that we, as language designers, would notice and/or care about, but users of the language don't want to care about this distinction or have to pass around an awkward intermediate opaque value because of it

[10:49:30.0448] <ryzokuken>
feature request: import/export queue as YAML

[10:49:57.0964] <Jack Works>
some though:
```js
import source wasm from './x.wasm'
// and
import wasm from './x.wasm'
```

both give us reference to undeniable host objects.

[10:50:37.0451] <Michael Ficarra>
I mean that depends on the embedder, right?

[10:51:21.0377] <Michael Ficarra>
the embedder could add hooks for denying that, surely

[10:51:22.0347] <Jack Works>
yes. since it already happens today, IMO we no need to care about deniability in this syntax.

[11:08:42.0875] <Andreu Botella>
Wait, so `import x from "test"` and `import x from "test" with {}` would have different cache keys?

[11:08:53.0542] <littledan>
in that case, no

[11:09:22.0937] <littledan>
keep in mind, it's not that all attributes result in a differing cache key at the host level, they might be normalized just like relative paths

[11:10:10.0803] <Andreu Botella>
slide https://docs.google.com/presentation/d/1Abdr54Iflz_4sah2_yX2qS3K09qDJGV84qIZ6pHAqIk/edit#slide=id.g216c73c7b74_0_35 seems to suggest the cache key for the former would be `#["test", null]` and the latter would be `#["test", #{}]`

[11:12:56.0482] <yulia>
erm, ok. i have maybe a solution to what mark is asking

[11:12:59.0212] <yulia>
i have a slide deck

[11:13:06.0254] <yulia>
but it wasn't totally ready

[11:13:57.0576] <yulia>
I will probably do it as a blog post after i've had a chance to talk to the other modules folks

[11:13:57.0590] <Andreu Botella>
oh, I just checked the spec and it is actually the same cache key, my bad

[11:14:06.0152] <Andreu Botella>
 * oh, I just checked the proposed spec text and it is actually the same cache key, my bad

[11:14:19.0782] <yulia>
here is the deck: https://docs.google.com/presentation/d/1YDFyEj8SxbWXhtPBVjyoSOVnaeydnZ_lexmd-LLgO4U/edit#slide=id.p

[11:14:42.0867] <yulia>
its out of date, please don't take it as anything concrete

[11:15:45.0636] <yulia>
I took it off the agenda because it wasn't concrete but i can talk about it briefly

[11:15:59.0682] <littledan>
I'd encourage you to add this to the agenda as well as the queue

[11:16:25.0802] <Michael Ficarra>
I think Mark was probably just unaware of the coordination already happening between the module proposal authors

[11:16:28.0384] <Rob Palmer>
I've been impressed with how much coordination and participation has gone into the various modules proposals

[11:18:37.0220] <Jesse (TC39)>
OT yulia presented some stuff about this module work (including layering/process improcements) at BOBKonf 2023 just last week (great talk!) https://bobkonf.de/2023/startsev.html

[11:18:56.0513] <yulia>
its very out of date already

[11:19:12.0637] <Jesse (TC39)>
in one week? JS moves faster than I thought!

[11:19:29.0874] <yulia>
yes, i have the wrong names already, probably because i was writing the talk a couple of months ago

[11:19:33.0823] <littledan>
I think it'd be much better to discuss this internally in TC39, even if very very unfinished, before you leave (and maybe this will feed into the blog post, even)

[11:19:58.0920] <littledan>
the bar for something we're discussing just internally should be logically lower than what goes into a public-facing blog post

[11:22:41.0313] <yulia>
my view on layering doesn't need to be adopted, its just my thinking

[11:22:51.0184] <ljharb>
littledan: afaik node already decided to reflag

[11:23:03.0027] <yulia>
and blocking that from going public is something i am against because i have reasons for my opinions even if tc39 disagrees

[11:23:05.0115] <bakkot>
honestly the slow path seems totally fine as long as we update docs and stuff?

[11:23:12.0763] <littledan>
> <@ljharb:matrix.org> littledan: afaik node already decided to reflag

interesting, I guess they don't need a signal from us?

[11:23:18.0411] <bakkot>
like if no new code uses it, I don't see a problem

[11:23:23.0084] <bakkot>
 * like if no new code uses `assert`, I don't see a problem

[11:23:32.0325] <ljharb>
> <@littledan:matrix.org> interesting, I guess they don't need a signal from us?

they reflagged because they had no signal, and the future of the syntax was uncertain

[11:23:37.0953] <Michael Ficarra>
bakkot: it's a bit scary, you don't want to have adoption of the legacy variant increase

[11:23:47.0299] <Michael Ficarra>
hopefully implementations can warn through some side channel

[11:24:15.0764] <bakkot>
console warning would be good too yeah

[11:24:45.0465] <Michael Ficarra>
console warning only if mtime > March TC39 meeting lol

[11:24:56.0362] <littledan>
> <@ljharb:matrix.org> they reflagged because they had no signal, and the future of the syntax was uncertain

has a release actually gone out with the re-flagging?

[11:25:11.0829] <ljharb>
i don't think so yet

[11:27:14.0268] <eemeli>
Do we have any precedent for a MAY or SHOULD statement on emitting warnings for deprecated syntax?

[11:27:52.0009] <bakkot>
nope

[11:27:57.0053] <Michael Ficarra>
eemeli: we have no jurisdiction there

[11:28:24.0147] <bakkot>
we can give suggestions but like we can also give suggestions to Shu, in words

[11:28:48.0365] <shu>
like yes i am not a generative AI

[11:30:12.0985] <eemeli>
Tbf, I think we're just established that it's not just Chrome.

[11:30:42.0571] <bakkot>
does node ever do warnings? warnings from node can break stuff

[11:30:45.0141] <bakkot>
bundlers could, though

[11:30:56.0719] <bakkot>
I guess it does ever do warnings; I have seen some

[11:31:23.0695] <littledan>
> <@yulia:mozilla.org> and blocking that from going public is something i am against because i have reasons for my opinions even if tc39 disagrees

Sorry I did not mean that I or anyone should block you from doing anything, it just seems like you're hesitant to present something unfinished to us and I was trying to encourage you that it'd be OK to share.

[11:31:25.0485] <eemeli>
At least for flagged features, it does.

[11:32:19.0310] <Michael Ficarra>
doesn't do warnings? I have an UnhandledPromiseRejection for you

[11:32:34.0098] <ljharb>
node def does warnings, and has a caching mechanism so it only shows it to you once per process

[11:32:50.0436] <bakkot>
UnhandledPromiseRejection now crashes the process by default, I think

[11:33:17.0036] <Mathieu Hofman>
Where do I find the slides yulia ?

[11:33:32.0777] <yulia>
https://docs.google.com/presentation/d/1YDFyEj8SxbWXhtPBVjyoSOVnaeydnZ_lexmd-LLgO4U/edit#slide=id.p

[11:33:43.0307] <yulia>
its not that much of an evolution of what we've discussed in the module calls

[11:33:50.0557] <yulia>
you will notice things are on different layers and the layers are named

[11:34:02.0071] <yulia>
its in part in response to my thinking of how the layers can be organized

[11:39:44.0692] <danielrosenwasser>
Are there any annex features that don't run on all major browsers?

[11:39:58.0719] <danielrosenwasser>
(I swear I am not trying to start a fight üòÖ)

[11:40:29.0928] <ryzokuken>
editorial notes could help?

[11:40:57.0268] <shu>
this is a spectacularly unnuanced understanding of the purpose of a specification document

[11:41:14.0172] <nicolo-ribaudo>
> <@danielrosenwasser:matrix.org> Are there any annex features that don't run on all major browsers?

This would not be annex b -- annex b must be implemented by all browsers

[11:41:17.0557] <ryzokuken>
I mean, we could include it with a big banner that says "careful"

[11:41:39.0733] <Jack Works>
> <@nicolo-ribaudo:matrix.org> This would not be annex b -- annex b must be implemented by all browsers

annex b + normative optional üòÇ

[11:41:41.0784] <danielrosenwasser>
ah, I see. I'm just trying to understand better.

[11:42:18.0208] <eemeli>
Annex C, anyone? üòá

[11:42:21.0663] <shu>
it is fine if committee wants the lesson V8 to learn from this is "conformance as a proxy measure for shipping reality becomes even more tenuous"

[11:42:33.0028] <shu>
but that will weak TC39's pull in the future, to be clear

[11:43:08.0941] <ljharb>
i'm confused. why would supporting `assert` syntax make you noncompliant?

[11:43:19.0359] <shu>
 * but that will weaken TC39's pull in the future, to be clear

[11:43:28.0412] <ljharb>
the spec already explicitly allows implementations to go nuts with their own syntax

[11:43:33.0770] <bakkot>
speaking of, I still need to specify the `if (false) f() = 0` syntax...

[11:44:14.0576] <bakkot>
ljharb: I do not think we want implementations to think of themselves as being allowed to go nuts with their own syntax, regardless of whether the spec says they are allowed to

[11:44:14.0969] <ljharb>
i very much wouldn't want to make important implementations noncompliant, but omitting `assert` from the spec doesn't seem like it would cause that.

[11:44:21.0839] <ljharb>
> <@bakkot:matrix.org> ljharb: I do not think we want implementations to think of themselves as being allowed to go nuts with their own syntax, regardless of whether the spec says they are allowed to

very true

[11:44:30.0124] <shu>
it is no skin off my back to start going nuts with syntax

[11:44:30.0360] <littledan>
> <@shuyuguo:matrix.org> it is fine if committee wants the lesson V8 to learn from this is "conformance as a proxy measure for shipping reality becomes even more tenuous"

I don't think V8 should take that lesson; it was clear that the committee largely *does* see the spec reflecting reality as a goal.

[11:44:58.0417] <shu>
but more narrowly, because the spec needs to say `assert` has the same semantics as `with`

[11:44:59.0972] <ljharb>
i see that as a goal as well. but it has a purpose beyond that in that it guides new implementations

[11:45:11.0480] <shu>
that's what the "legacy" box is for

[11:45:18.0118] <shu>
that is literally why that box exists

[11:45:36.0331] <ljharb>
sure. but that's for stuff that all browsers already implement. this one's just chrome

[11:46:13.0338] <bakkot>
`Legacy` is actually "must implement"

[11:46:24.0840] <shu>
sorry, normative optional + legacy

[11:46:27.0848] <bakkot>
but `Legacy` plus `Normative Optional` does the thing yes

[11:46:43.0580] <ljharb>
maybe the solution is to invent a new category that's more strongly worded and implies both legacy and normative optional, i dunno

[11:46:46.0449] <Jack Works>
can we try? maybe the migration isn't that hard considering code using import assertions are new and highly likely in maintaining

[11:46:52.0371] <ryzokuken>
odd sidebar, since I'm curious: is it a possibility to eventually move `Date` to this "legacy" section?

[11:47:01.0749] <ljharb>
 but there is a distinct difference to me between the string HTML methods, and the `assert` syntax

[11:47:06.0639] <littledan>
> <@usharma:igalia.com> odd sidebar, since I'm curious: is it a possibility to eventually move `Date` to this "legacy" section?

no? this is a confusing tangent

[11:47:17.0658] <ryzokuken>
yes, sorry

[11:47:18.0247] <ljharb>
seems very unlikely

[11:47:19.0069] <Andreu Botella>
Legacy + Normative Optional + Pls Do Not Ship If At All Possible

[11:47:51.0606] <Jack Works>
you can mark anything as deprecated if you want, but just don't remove it

[11:49:39.0033] <Jack Works>
wonder the real world use rate in Web of Import assertions

[11:49:44.0665] <Jack Works>
is there any data of it?

[11:49:58.0226] <Jesse (TC39)>
> <@jackworks:matrix.org> wonder the real world use rate in Web of Import assertions

I think yulia might have some data there?

[11:49:59.0958] <HE Shi-Jun>
> <@jackworks:matrix.org> wonder the real world use rate in Web of Import assertions

I believe it's very low

[11:50:16.0020] <yulia>
chrome would be the one with the counters

[11:50:18.0601] <justinfagnani>
it has to be very, very low

[11:50:30.0615] <Jack Works>
> <@jesse:igalia.com> I think yulia might have some data there?

but firefox does not ship it?

[11:50:45.0517] <yulia>
at the moment, no

[11:50:50.0431] <yulia>
we have an implementation but it is unshipped

[11:51:01.0888] <yulia>
safari likewise has it behind a flag

[11:51:18.0096] <ljharb>
it would be a really unfortunate outcome imo if anyone newly ships it unflagged (prior to time + evidence that it's unshakeable web reality)

[11:51:34.0393] <yulia>
i believe assert is most used by tooling, Justin Ridgewell would have the context here

[11:51:38.0045] <ljharb>
and given how new this feature is, it seems entirely achievable for everyone using `assert` to migrate to `with`

[11:52:01.0145] <bakkot>
eventually

[11:52:10.0899] <ljharb>
sure, in the fullness of time. but i think on a reasonably short timescale

[11:52:38.0878] <ljharb>
if every browser, and node/deno, shipped `with` today, i'd expect `assert` to be gone in like a year

[11:52:40.0354] <justinfagnani>
the most likely usage is in v8-only environments: Deno, Node, Electron, etc... but those are versioned and also have breaking changes somewhat regularly

[11:52:42.0218] <ljharb>
 * if every browser, and node/deno, shipped `with` today, i'd expect `assert` to be largely gone in like a year

[11:54:02.0172] <Jack Works>
(IIRC some linux let apps use shared electron so maybe for electron it's not so versioned)

[11:54:06.0850] <justinfagnani>
v8 use counters would need to differentiate web from server (if any server env even contributes to use counters, which I doubt?)

[11:54:21.0411] <ljharb>
p sure use counters are in chrome, not v8?

[11:54:24.0644] <justinfagnani>
ah, counter would be web-only

[11:54:43.0872] <shu>
yeah that use counter infra is chrome only i think

[11:55:01.0558] <bakkot>
node's ability to ever ship breaking changes is great, I love that; I also appreciate that it happens quite rarely these days

[11:55:07.0219] <Jack Works>
does Electron has use counter? ¬†üßê

[11:55:21.0800] <bakkot>
I have not had an issue updating a major version of node since 10->12

[11:55:25.0148] <justinfagnani>
I don't know... seems like some sort of metrics would have been useful from server / desktop environments, but I admit I don't know of any that do

[11:55:46.0831] <shu>
this is just the consequence of our staging and shipping model

[11:55:50.0459] <shu>
you can't have your cake and eat it too

[11:56:04.0567] <shu>
i am not interested in spec purity

[11:56:14.0854] <Jack Works>
> <@bakkot:matrix.org> node's ability to ever ship breaking changes is great, I love that; I also appreciate that it happens quite rarely these days

(Node 18 new SSL provider breaks Webpack 4)

[11:56:52.0314] <bakkot>
fortunately webpack is usually a direct dep rather than a transitive dep, so that's not too bad

[11:58:08.0700] <Jack Works>
if we're interested in spec purity, we won't have IsHTMLDDA today

[11:58:32.0179] <ljharb>
*un*fortunately tho, lots of people can't upgrade to webpack 5 because of its node core module polyfilling change, so unless a fix is backported to v4 lots of people will be stuck

[11:59:35.0884] <Michael Ficarra>
ljharb: I would prefer the committee not give too much editorial direction here. I want to retain discretion to best communicate what we understand the committee's opinion to be here.

[11:59:50.0055] <Jack Works>
that one is easy to migrate. the hard part is webpack plugins and loaders

[12:00:03.0470] <bakkot>
this sounds like "deprecated" to me

[12:00:13.0790] <shu>
also sounds like deprecated to me

[12:00:54.0535] <ljharb>
> <@michaelficarra:matrix.org> ljharb: I would prefer the committee not give too much editorial direction here. I want to retain discretion to best communicate what we understand the committee's opinion to be here.

yeah i'm not trying to dictate editorial wording, just the conveyed intent

[12:01:02.0260] <littledan>
+1 to Jordan's comments about the spec being explicit about the hope to remove it (though I'd note that normative-optional advocates like to think the same thing about those sections)

[12:01:41.0512] <msaboff>
Annex B is evidence that we don't have spec purity.  I'd rather that we don't decrease purity.

[12:02:16.0489] <shu>
that's fair, but the bar for me is "is this true of the world", not "is this a wish we have of the world"

[12:02:22.0833] <shu>
and as i said we can find that out empirically

[12:02:45.0376] <shu>
 * that's fair, but the bar for me for when it's acceptable to decrease purity is "is this true of the world", not "is this a wish we have of the world"

[12:03:21.0458] <bakkot>
I am real curious what the real-world in-browser usage will turn out to be

[12:03:51.0014] <shu>
yeah

[12:03:51.0601] <littledan>
> <@msaboff:matrix.org> Annex B is evidence that we don't have spec purity.  I'd rather that we don't decrease purity.

msaboff: What do you think about the point Shu made of, this committee will have more influence if we are willing to be impure in this way?

[12:04:26.0548] <shu>
corollary: be careful how many times you ask people to unship

[13:03:14.0138] <rbuckton>
For those interested, I have two draft PRs up that illustrate the potential cover grammars for await using and async using:

- await using: https://github.com/tc39/proposal-async-explicit-resource-management/pull/15
- async using: https://github.com/tc39/proposal-async-explicit-resource-management/pull/16

[13:04:21.0577] <rbuckton>
Rendered version of #15: https://tc39.es/proposal-async-explicit-resource-management/pr/15
Rendered version of #16: https://tc39.es/proposal-async-explicit-resource-management/pr/16

[13:04:36.0165] <rbuckton>
 * Rendered version of #15 (`await using`): https://tc39.es/proposal-async-explicit-resource-management/pr/15
Rendered version of #16 (`async using`): https://tc39.es/proposal-async-explicit-resource-management/pr/16

[13:06:29.0983] <rbuckton>
Apologies, I need to step out for a few minutes. I will be back shortly. 

[13:06:52.0342] <msaboff>
ljharb: Where would I find the draft standard for patent opt out review?

[13:07:29.0224] <littledan>
Draft notes for the conclusion for import attributes, please edit the notes if you want to refine anything:

#### Summary
Import attributes are the path forward for the standard, having re-achieved Stage 3.
The keyword is `with`
As previously, there is an options bag following it
The options can form part of the interpretation of the module and "cache key"
Unknown attributes in the import statement cause an error.
Although a couple delegates would prefer sticking with the keyword `assert`, the majority preferred switching to the long-term optimal solution of being more semantically well-aligned using `with`
Significant debate focused around how to communicate the deprecation.

#### Conclusion
`assert` will remain in the specification, marked somehow as "deprecated", with the intention to remove it eventually, though with an anticipated timespan of at least multiple years before final removal.
JS environments which currently ship `assert` are *not* encouraged to remove it, but environments which do not yet ship `assert` are discouraged from shipping it.
Chrome will gather data on usage of `assert` on the web, which can inform the deprecation path.
Conditional consensus for Stage 3 on this proposal, with the conditions:
Reviews are still needed from the reviewers who volunteered ‚Äì JRL and JHD, as well as the editors
The wording for normative optional+legacy needs to be updated to something stronger, probably "deprecated", and explaining the goal to remove it from the specification.


[13:08:26.0040] <ljharb>
> <@msaboff:matrix.org> ljharb: Where would I find the draft standard for patent opt out review?

it hasn't been produced/cut yet, so for now you can look at https://tc39.es/ecma262, but i'll create a github release on the spec repo, and a Reflector issue, and i'll post it in here, when it's prepared

[13:08:49.0994] <shu>
yeah, i think tip-of-tree right now will get tagged

[13:09:37.0218] <msaboff>
> <@shuyuguo:matrix.org> yeah, i think tip-of-tree right now will get tagged

Can you or another editor email me when it is tagged?

[13:10:20.0827] <shu>
sure, let me make a reminder

[13:10:40.0942] <Michael Ficarra>
I would phrase that as: the draft is final, is currently at https://tc39.es/ecma262, but will soon be available at the more stable URL https://tc39.es/ecma262/2023/

[13:12:29.0085] <msaboff>
Michael Ficarra: When do you think the stable URL will be available?

[13:12:48.0389] <bakkot>
I actually did not know until looking at this issue that python's `range` does not allow floats, which I think is indicative of how rarely it comes up (at least in the kind of code I tend to write)

[13:12:53.0191] <bakkot>
 * I actually did not know until looking at this issue that python's `range` does not allow non-integer values, which I think is indicative of how rarely it comes up (at least in the kind of code I tend to write)

[13:13:41.0961] <shu>
were floating point use cases the champion considers compelling presented?

[13:13:44.0012] <msaboff>
Seems like **integer only** makes a lot of sense.

[13:13:59.0801] <shu>
i am not understanding who is advocating for floats

[13:14:04.0644] <shu>
(tab is not here)

[13:14:38.0720] <bakkot>
tab advocated non-integers, hax opposed; we are here to find out what the committee as a whole things

[13:14:50.0035] <bakkot>
more people need to express opinions

[13:14:54.0337] <shu>
but are there use cases?

[13:14:58.0893] <shu>
my intuition is strongly integer only

[13:15:21.0064] <shu>
like... why are you doing 0, 0.3, 0.6, 0.9?

[13:17:52.0948] <rbuckton>
For reference, Python's `range()` doesn't allow floats.

[13:19:02.0001] <shu>
from https://github.com/tc39/proposal-Number.range/issues/64, tab says: "Ranges that include floating-point numbers are perfectly fine and reasonable, and people will want to do them - if we arbitrarily restrict it from this API people will just write their own and be justifiably angry at us for screwing up the API and forcing them to reinvent it themselves."

[13:19:19.0780] <shu>
but... really?

[13:19:33.0678] <bakkot>
I found the linked stackoverflow question about python's range informative: https://stackoverflow.com/questions/477486/how-do-i-use-a-decimal-step-value-for-range

[13:20:49.0109] <shu>
what's your take from that SO question?

[13:20:59.0101] <bakkot>
people aren't mad about it, basically

[13:21:05.0931] <shu>
mine is "if we restrict it, people will ask, and be told how to do it correctly, instead of being mad and also doing it wrong"

[13:21:13.0393] <shu>
okay i think that matches with mine

[13:21:15.0037] <bakkot>
or like, reasonable people can give a good answer to the question that is not just "this is a bug"

[13:21:19.0209] <shu>
right

[13:21:27.0275] <bakkot>
possibly some people are mad about it somewhere but clearly not everyone

[13:21:48.0677] <shu>
i don't know how you can be mad at "hold on now, have you heard about rounding errors"

[13:22:29.0826] <bakkot>
oh I'm mad about that, but in the way that I am mad about entropy, not the way that I am mad about idk strings being utf-16 or whatever

[13:22:49.0320] <Michael Ficarra>
I bet most JS programmers don't even know what a float is, and just treat JS numbers as if they were reals

[13:23:03.0544] <Michael Ficarra>
they don't want to hear about rounding errors

[13:23:18.0831] <bakkot>
well if `range()` doesn't allow floats then they won't have to

[13:23:30.0495] <bakkot>
if they put floats in range then they will have to learn about them

[13:24:26.0086] <eemeli>
I found it interesting that these "fail" in slightly different ways:
```
> for (let i = 0; i < 10; i += 1) console.log(i * 0.1)
0
0.1
0.2
0.30000000000000004
0.4
0.5
0.6000000000000001
0.7000000000000001
0.8
0.9

> for (let i = 0; i < 1; i += 0.1) console.log(i)
0
0.1
0.2
0.30000000000000004
0.4
0.5
0.6
0.7
0.7999999999999999
0.8999999999999999
0.9999999999999999
```

[13:24:32.0305] <bakkot>
(to be clear I'm just repeating things Hax already put in the issue, not finding things myself)

[13:26:51.0887] <bakkot>
ljharb: when we say "disallow floats" everyone means "disallow non-integer numbers"

[13:26:59.0571] <bakkot>
no one is suggesting not allowing integral floats

[13:27:10.0701] <bakkot>
though there is some question about whether to allow numbers above max-safe-int

[13:29:48.0348] <Michael Ficarra>
yes I wish we would stop saying "disallow floats", it is confusing people

[13:33:36.0775] <bakkot>
to be clear, this is also how floats work in python; that's how floats work in every language. but python disallows non-integer floats in `range`, and that's fine

[13:33:45.0654] <bakkot>
so it clearly is a thing that a language can choose to do

[13:34:50.0722] <shu>
no the lack of use cases is specifically about range

[13:34:54.0152] <shu>
not about floating point numbers

[13:35:46.0590] <mpcsh>
Willian Martins your name isn't in the delegates list for the notes ‚Äî is your acronym WMS? https://github.com/tc39/notes/blob/main/delegates.txt

[13:35:55.0329] <mpcsh>
(also please send a PR to add yourself to that at your leisure)

[13:35:57.0306] <Jack Works>
consistency vs foogun prevention

[13:36:06.0378] <Jack Works>
ü•≤

[13:36:14.0103] <Willian Martins>
yes

[13:36:54.0276] <ljharb>
see also, the `this` argument on array methods

[13:37:40.0805] <Michael Ficarra>
I see their name in the notes

[13:41:55.0047] <Justin Ridgewell>
Is the current proposal with add or multiply semantics?

[13:42:52.0408] <ljharb>
multiply iirc

[13:43:11.0445] <Michael Ficarra>
multiply

[13:43:58.0968] <Justin Ridgewell>
` start + (step * currentCount)` perfect

[13:44:06.0826] <Justin Ridgewell>
Had to scan the spec for a min

[14:00:36.0978] <Michael Ficarra>
I agree with Shu's point that we should probably align with wasm on whether they add an f16 for these or they get promoted when they cross to wasm

[14:01:30.0597] <mpcsh>
> <@mpcsh_:matrix.org> Willian Martins your name isn't in the delegates list for the notes ‚Äî is your acronym WMS? https://github.com/tc39/notes/blob/main/delegates.txt

dminor you as well ‚Äî I see DLM in the notes, please add yourself to the list üôÇ

[14:02:04.0224] <Michael Ficarra>
Dan is *also* in the list

[14:02:16.0064] <Michael Ficarra>
mpcsh: I think your search is broken

[14:02:30.0817] <Michael Ficarra>
 * Dan is _also_ in the list already

[14:03:16.0881] <mpcsh>
you're right ‚Äî I don't know how I missed Willian. I searched for "Daniel Minor" though here. I see them both now!

[14:17:09.0092] <Justin Ridgewell>
Someone is being very loud in front of a mic

[14:18:25.0578] <Chris de Almeida>
aggressive clicking

[14:18:29.0621] <Luca Casonato>
Is this still the case Justin Ridgewell?

[14:18:38.0322] <Justin Ridgewell>
No

[14:18:42.0401] <Justin Ridgewell>
Sorry, yes

[14:18:45.0139] <Justin Ridgewell>
Still noisy

[14:18:50.0212] <Luca Casonato>
clicking or keyboard?

[14:18:57.0368] <Chris de Almeida>
both

[14:19:00.0087] <Justin Ridgewell>
Clicking?

[14:19:00.0192] <ljharb>
from the room or the call?

[14:19:06.0108] <Justin Ridgewell>
Also shuffling

[14:19:06.0763] <ljharb>
 * from the room or the call? the room i assume

[14:19:06.0882] <Chris de Almeida>
yes?

[14:19:09.0498] <Michael Ficarra>
I don't hear this noise from the room

[14:19:37.0167] <Rob Palmer>
in the room we do not hear aggressive typing or clicking

[14:19:40.0832] <Chris de Almeida>
good now

[14:20:51.0427] <shu>
isn't that a strawperson

[14:21:28.0681] <shu>
like these arguments are formed like "it's impossible to express now", whereas it's more like "we have to use libraries"?

[14:22:09.0969] <shu>
the last bullet point is about accidental casts which i remember littledan and brendan bringing up years ago

[14:22:30.0372] <shu>
that one seems legit as an argument for language inclusion over library

[14:31:23.0989] <bakkot>
anyone know _why_ IEEE decimal distinguishes between 1.2 and 1.20?

[14:31:45.0941] <Michael Ficarra>
sigfigs?

[14:31:55.0718] <littledan>
like high school science

[14:32:19.0182] <littledan>
> <@bakkot:matrix.org> anyone know _why_ IEEE decimal distinguishes between 1.2 and 1.20?

this page explains at way too much length: https://speleotrove.com/decimal/decifaq.html

[14:32:44.0234] <littledan>
there are many use cases posited there for trailing zeroes. The author of this document was participating in the IEEE process.

[14:32:59.0139] <bakkot>
oh boy

[14:33:16.0166] <littledan>
it is actually a fun and well-written piece

[14:35:22.0298] <Michael Ficarra>
last updated today, wow

[14:35:33.0900] <bakkot>
no it just has some JS that writes the current date

[14:35:37.0802] <bakkot>
I was also confused by that

[14:35:53.0368] <Michael Ficarra>
well that is very weird

[14:36:08.0802] <ljharb>
lol that was a common practice in the late 90s

[14:36:20.0036] <ljharb>
next to a "visit counter"

[14:36:40.0270] <bakkot>
actually it appears to be using `document.lastModified`

[14:36:42.0134] <bakkot>
which, TIL

[14:36:48.0920] <ljharb>
huh

[14:38:30.0256] <Rob Palmer>
Feedback from remote attendees is that the room mic is particularly hot where Jordan and Patrick are sitting. We hear clicks and zipping noises, etc.  Just for awareness.

[14:40:21.0545] <shu>
> <@bakkot:matrix.org> actually it appears to be using `document.lastModified`

wow how does it know? whatever the server says i guess?

[14:41:24.0482] <Michael Ficarra>
shu: I think it only works for local files

[14:41:31.0801] <Michael Ficarra>
maybe it goes off a response header though, I dunno

[14:42:07.0581] <bakkot>
> The Document's source file's last modification date and time must be derived from relevant features of the networking protocols used, e.g. from the value of the HTTP `Last-Modified` header of the document, or from metadata in the file system for local files. If the last modification date and time are not known, the attribute must return the current date and time in the above format.

[14:42:09.0560] <bakkot>
https://html.spec.whatwg.org/multipage/dom.html#dom-document-lastmodified-dev

[14:42:22.0250] <shu>
sick

[14:43:46.0109] <littledan>
My point was going to be: I think the more important reason (than performance) for decimal over rational is, the very core and common operation of rounding makes sense for decimals in a way which is a sort of mismatch for rationals. This is very common in financial calculations, to have well-defined rounding of intermediate values.

[14:44:47.0221] <shu>
+1 to dminor 

[14:45:25.0661] <littledan>
I can understand "it's not motivated enough" or "it's too much work to implement" as counterarguments, but "there is a design space" is a common attribute of just about everything we do in TC39.

[14:46:54.0177] <littledan>
Utility as something built-in here is analogous to something like Temporal--it ends up being useful to have some things built-in sometimes. I think this is about the use cases being persuasive enough, which maybe we haven't shown.

[14:47:13.0710] <shu>
in retrospect Temporal should have been a blessed library

[14:47:13.0711] <littledan>
 * Utility as something built-in here is analogous to something like Temporal--it ends up being useful to have some things built-in sometimes. I think this is about the use cases being persuasive enough to pay for the complexity and implementation cost, which maybe we haven't shown.

[14:47:16.0718] <shu>
(IMO)

[14:47:37.0361] <apaprocki>
we don't have a way to do that though

[14:47:43.0770] <Michael Ficarra>
nah, date/time handling is provided (usually poorly) in almost all std libs

[14:47:47.0801] <apaprocki>
interchange is the thing that kills us by not having a vocabulary type

[14:47:55.0427] <Michael Ficarra>
tzdata is live as well

[14:48:03.0655] <shu>
what is a vocabulary type again

[14:48:31.0271] <apaprocki>
literally every single software product/language that exists has decimal, so making NxM products all flow through JS is burdensome 

[14:48:33.0197] <littledan>
like, if we have something built-in, then all the different libraries know that they can use it. This comes up for Promises, Temporal, Decimal, and more

[14:48:47.0622] <shu>
"vocabulary type" means "built-in"?

[14:49:05.0855] <apaprocki>
vocabulary meaning, a concept of interchange between languages/systems

[14:49:11.0473] <apaprocki>
even within the same language/system

[14:49:14.0586] <shu>
okay

[14:49:25.0403] <apaprocki>
so `double` in C++ / `number` in JS

[14:49:40.0314] <shu>
i will be unequivocal about one thing, which is what i was planning to bring in the queue: V8 is not going to be okay with a new value type

[14:49:54.0901] <littledan>
> <@shuyuguo:matrix.org> i will be unequivocal about one thing, which is what i was planning to bring in the queue: V8 is not going to be okay with a new value type

I would really like to have this conversation in plenary in the overflow time

[14:50:01.0613] <shu>
sure

[14:50:03.0051] <apaprocki>
yes, that was the path that was being suggested

[14:50:09.0889] <apaprocki>
path being (not a value type)

[14:50:11.0399] <shu>
well, waldemar brought up === overloading

[14:50:14.0648] <shu>
which is also not something we want

[14:50:33.0471] <Michael Ficarra>
yes, I disagree with that point made by waldemar

[14:50:47.0670] <littledan>
> <@shuyuguo:matrix.org> well, waldemar brought up === overloading

yeah, this is exactly why I'm looking forward to having a conversation about it together (as opposed to isolated points from individuals)

[14:50:51.0407] <shu>
 * which is also not something V8 wants

[14:51:18.0132] <apaprocki>
if we could scope/timebox an overflow specifically about this, it would really help inform champions

[14:51:47.0446] <apaprocki>
assuming an object w/o overloading is being proposed, what are delegate opinions as to why that would not be acceptable

[14:52:28.0960] <littledan>
> <@apaprocki:matrix.org> assuming an object w/o overloading is being proposed, what are delegate opinions as to why that would not be acceptable

Yeah, I think we could divide the discussion into those two parts (I'd also like to discuss why Waldemar wants overloading, and what others think about this topic)

[14:52:38.0679] <Michael Ficarra>
the timebox was just not big enough, we had a ton more to talk about wrt decimal

[14:53:17.0995] <littledan>
> <@michaelficarra:matrix.org> the timebox was just not big enough, we had a ton more to talk about wrt decimal

Good thing we have tons of slack time this meeting.

[14:54:50.0192] <Rob Palmer>
the slack is being consumed at a fast rate

[14:55:24.0034] <Rob Palmer>
we are down to 25mins remaining

[14:57:06.0144] <rbuckton>
I'll be honest, I'd love something a regex tagged template for `x`-mode, but I'd be more likely to want to bring prefix modifiers back for something like:
```js
const re = RegExp`(?x)
# comments
multi|line
regexp
`;
```
as I'm also not a fan of having to nest `` ` `` and `/`.

[14:59:51.0255] <Luca Casonato>
MSL's library that Mark is referring to: https://github.com/mikesamuel/regexp-make-js

[15:03:12.0304] <rbuckton>
I think one of Mark's concerns about string append is character classes. If `Regexp.escape` is safe for `new RegExp("[" + Regexp.escape(input) + "]")`, is that still a concern?

[15:04:14.0526] <Richard Gibson>
also backslash

[15:04:39.0850] <littledan>
I don't understand jridgewell's point

[15:05:27.0919] <HE Shi-Jun>
> <@rbuckton:matrix.org> I think one of Mark's concerns about string append is character classes. If `Regexp.escape` is safe for `new RegExp("[" + Regexp.escape(input) + "]")`, is that still a concern?

how it could be safe?

[15:05:51.0304] <Justin Ridgewell>
```` re``` ```` is just invalid

[15:06:09.0797] <rbuckton>
> <@haxjs:matrix.org> how it could be safe?

Every character can be escaped into something that would be valid in a _ClassAtom_

[15:06:10.0119] <Justin Ridgewell>
You can't match a `` ` `` in a TTL built RegExp

[15:06:18.0971] <Justin Ridgewell>
Because you can't have a lone `` ` `` in a TTL

[15:06:38.0708] <littledan>
I don't understand why `re`\``` or `re`\\`` wouldn't work for this

[15:06:45.0842] <littledan>
(ugh how do I type that?0

[15:06:48.0337] <Richard Gibson>
 * also backslash: https://github.com/tc39/proposal-regex-escaping/issues/37#issue-98309281

[15:06:48.0576] <waldemar>
> <@bakkot:matrix.org> anyone know _why_ IEEE decimal distinguishes between 1.2 and 1.20?

It's just that, unlike IEEE binary which always has an implied 1 as the leading mantissa digit for non-denorms, there are multiple bit patterns that can represent the same IEEE decimal number because the leading mantissa digit can be 0 through 9. For example, there are hundreds of ways to represent +0 as a IEEE decimal, and they're all different and distinguishable.
The situation is similar to how UTF-8 was originally defined: there were multiple ways to encode "a" (either as a single byte, as two bytes, as three bytes, etc.). Eventually this became enough of a problem that UTF-8 was changed to ban encodings other than the shortest possible ones.

[15:06:57.0274] <Justin Ridgewell>
Because the `\` is now included in your regex

[15:07:00.0601] <rbuckton>
> <@jridgewell:matrix.org> You can't match a `` ` `` in a TTL built RegExp

You can, but not easily. You would have to do `` RegExp`${"`"}` ``, which isn't ideal but it is feasible.

[15:07:15.0135] <Justin Ridgewell>
I want to match "`"

[15:07:35.0307] <Justin Ridgewell>
But that won't work for `\`

[15:07:37.0303] <rbuckton>
> <@littledan:matrix.org> I don't understand why `re`\``` or `re`\\`` wouldn't work for this

double backtick (or one more than the number used in the sample)

[15:07:48.0508] <rbuckton>
i.e., ``` `` ` `` ``` produces `` ` ``

[15:07:49.0404] <Justin Ridgewell>
Because `\` is a special char in RegExp that would need to be escaped in the expression for

[15:07:51.0510] <Justin Ridgewell>
 * Because `\` is a special char in RegExp that would need to be escaped in the expression form

[15:08:39.0970] <Justin Ridgewell>
If we had the ```` re``` ``` ```` multitick start/stop form from String.dedent, then it would have worked except for `\`

[15:09:00.0376] <rbuckton>
We can have ```` re``` ``` ````

[15:09:13.0364] <rbuckton>
But it doesnt do what you want)

[15:09:15.0215] <rbuckton>
 * But it doesnt do what you want :)

[15:09:26.0963] <Michael Ficarra>
lol yeah we already have that rbuckton 

[15:09:52.0710] <Justin Ridgewell>
Yah, this got brought up during String.dedent unfortunately

[15:10:00.0143] <Michael Ficarra>
Justin Ridgewell: I still don't see how ``re`\``` doesn't do what you want

[15:10:04.0299] <Michael Ficarra>
jesus

[15:10:08.0800] <Michael Ficarra>
I don't know how to talk about this

[15:10:09.0197] <HE Shi-Jun>
even u have ``` ```, what if u want to match ``` ?

[15:10:19.0461] <Justin Ridgewell>
Tip, matrix supports multitick blocks

[15:10:22.0234] <HE Shi-Jun>
 * even u have `` ``, what if u want to match \`\`\` ?

[15:10:32.0017] <ljharb>
``` ` ```

[15:10:33.0530] <Michael Ficarra>
`` re`\` ``

[15:10:35.0826] <Michael Ficarra>
there

[15:10:38.0588] <Justin Ridgewell>
```` ``` ```` delimits with 4 ticks at start/stop

[15:10:47.0489] <Michael Ficarra>
 * ``re`\\```

[15:10:54.0760] <littledan>
Kleene's regex language, I imagine Mark is referring to

[15:10:55.0278] <HE Shi-Jun>
 * even u have \`\`\` \`\`\`, what if u want to match \`\`\` ?

[15:11:05.0095] <Michael Ficarra>
 * ``re`\\\` ``

[15:11:07.0930] <rbuckton>
> <@michaelficarra:matrix.org> ``re`\\\` ``

`` /\/ `` doesn't work either though

[15:11:08.0482] <shu>
i've always pronounced that Clean-y

[15:11:11.0497] <Michael Ficarra>
omfg

[15:11:14.0770] <shu>
is it actually Clean?

[15:11:18.0124] <Michael Ficarra>
yes I am trying to write two backslashes

[15:11:32.0582] <littledan>
> <@shuyuguo:matrix.org> is it actually Clean?

my theory-heavy coworker pronounced its Clean-y the other day

[15:11:41.0531] <Justin Ridgewell>
> <@rbuckton:matrix.org> `` /\/ `` doesn't work either though

That would be written as `/\\/` to match `s = "\\"`

[15:11:50.0385] <Justin Ridgewell>
But it's not possible to write with a TTL

[15:12:00.0611] <Michael Ficarra>
Justin Ridgewell: please explain why not

[15:12:17.0511] <Justin Ridgewell>
``` re`\` ``` is invalid syntax

[15:12:17.0839] <rbuckton>
Yeah, though your comment indicates that `\` in a RegExp template is impossible, when it seems pretty consistent with RegExp literals

[15:12:37.0208] <Justin Ridgewell>
And ``` re`\\` ``` only matches `s = "\\\\"`

[15:12:46.0692] <shu>
we're on break now right?

[15:12:56.0333] <eemeli>
Yes.

[15:12:57.0198] <rbuckton>
I agree that `` ` `` is problematic, but also rare.

[15:13:03.0412] <Justin Ridgewell>
```String.raw`\\`.length === 3```

[15:13:06.0187] <Justin Ridgewell>
 * ``String.raw`\\`.length === 2``

[15:13:12.0726] <Justin Ridgewell>
 * ``String.raw`\\`.length === 2``, not 1

[15:13:49.0408] <rbuckton>
Yeah, that's fair. raw is a bit weird, though I wonder if that case is possible to detect.

[15:14:35.0211] <Michael Ficarra>
> <@jridgewell:matrix.org> ``` re`\` ``` is invalid syntax

two backslashes

[15:14:46.0336] <rbuckton>
i.e., Treat `\\` as `\` when parsing from a tagged template literal

[15:14:56.0143] <Justin Ridgewell>
See https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$aLh1spEECiImadJ_R3hX7vmWq_x53QWJ5RoJwgTztV4?via=matrix.org&via=igalia.com&via=mozilla.org

[15:15:12.0434] <Justin Ridgewell>
> And `` re`\\` `` only matches `s = "\\\\"`


[15:16:13.0105] <rbuckton>
> <@jridgewell:matrix.org> > And `` re`\\` `` only matches `s = "\\\\"`

Yes, could we not detect that case when parsing from a template tag?

[15:16:21.0516] <Justin Ridgewell>
`` /`/ `` and `` /\\/ `` cannot be represented

[15:17:31.0785] <rbuckton>
I think `/\\/` can be handled. ``/`/`` can't

[15:33:04.0395] <Rob Palmer>
Asumu is primarily addressing the feedback that we ought to explore whether runtime-types should be in-scope.

[15:44:05.0374] <Michael Ficarra>
for proponents of runtime types, what do you expect an engine to do if the declared type is incorrect and an engine optimises based on that type? is it now permitted to have a different result? UB?

[15:44:25.0311] <Justin Ridgewell>
eemeli ljharb I think Asumu is addressing runtime vs compile time in this presentation, and not unification.

[15:45:32.0392] <ljharb>
feel free to move mine to the end of the list, but i still want to bring it up if there's time

[15:47:37.0777] <eemeli>
Same, because this proposal continues to focus on the technical details of a specific solution, and not addressing their stated main goal.

[15:47:54.0753] <Justin Ridgewell>
Ok

[15:48:14.0903] <Justin Ridgewell>
I agree that this is an important topic for the overall proposal, just not sure if he's prepared to address them

[15:48:48.0708] <littledan>
Please feel free to ask these kinds of big-picture questions; they seem important at this stage

[15:48:51.0704] <danielrosenwasser>
I'm prepared to address it provided we have time, but would encourage that we focus on the current topics

[15:49:42.0371] <eemeli>
Part of what I'll want to say I already filed as an issue: https://github.com/tc39/proposal-type-annotations/issues/171

[15:50:41.0550] <Chris de Almeida>
agree -- folks should be heard, but I think it's reasonable to let folks comment on the presentation topic first.  especially as this is not moving for advancement

[15:52:21.0887] <rbuckton>
I'm personally less interested in "unforking" or "unification", but more interested in cutting down development time by avoiding a compile step to get from writing code to running code faster.

[15:53:03.0703] <Michael Ficarra>
there have been some truly excellent presentations at this meeting!

[15:53:06.0935] <Michael Ficarra>
puts me to shame

[15:53:21.0435] <Michael Ficarra>
I am going to need to put more effort into mine in the future now

[15:53:56.0069] <eemeli>
rbuckton: Agreed. But that's not what's presented as the proposal's motivation.

[15:54:23.0327] <eemeli>
And it's not a part of the problem statement that was accepted a year ago.

[15:55:07.0616] <Rob Palmer>
I think it was part of the problem statement - we talked about the developer friction

[15:55:09.0595] <ryzokuken>
100% this

[15:55:10.0647] <Chris de Almeida>
unrelated:  I am unlikely to be able to attend the end of the day.  Ashley Claymore IBM supports stage 1 for `await dictionary`

[15:55:25.0369] <ryzokuken>
we need to talk about unrealistic standards about presentations in TC39 /s

[16:04:01.0331] <shu>
...are people talking about contracts vs types now?

[16:04:29.0119] <shu>
like those are different paradigms

[16:05:28.0355] <Michael Ficarra>
shu: ever heard of gradual typing? checkmate

[16:05:52.0446] <shu>
my brother... 

[16:05:57.0321] <littledan>
> <@michaelficarra:matrix.org> shu: ever heard of gradual typing? checkmate

TypeScript is gradually typed because you can declare some types and not others!!

[16:06:02.0115] <shu>
lol

[16:06:21.0723] <littledan>
No, seriously, given the diversity of meanings of gradual typing (where people unironically use the above form), we deliberately omitted it from this presentation

[16:06:40.0340] <littledan>
Asumu's PhD thesis was on sound gradual typing in Racket (he cited it in the talk!)

[16:07:27.0556] <Rob Palmer>
yes - when Asumu said there was material on the subject he was referring to his own paper

[16:07:56.0168] <littledan>
tl;dr you might be able to use some fancy compiler techniques to make sound Scheme type enforcement not have way too much of a performance penalty (though it breaks down for JS, as Assume explained)

[16:08:05.0941] <littledan>
 * tl;dr you might be able to use some fancy compiler techniques to make sound Scheme type enforcement not have way too much of a performance penalty (though it breaks down for JS, as Asumu explained)

[16:08:12.0745] <Michael Ficarra>
> <@littledan:matrix.org> No, seriously, given the diversity of meanings of gradual typing (where people unironically use the above form), we deliberately omitted it from this presentation

people actually do this? what?

[16:08:21.0097] <Justin Ridgewell>
9min remaining!

[16:08:36.0444] <littledan>
> <@michaelficarra:matrix.org> people actually do this? what?

It is the predominant meaning in our community

[16:12:20.0651] <waldemar>
I don't understand DE's claim that all the things we've been adding to the language since ES6 are "unifying" the language.

[16:14:23.0501] <Justin Ridgewell>
We have 3 min remaining on this item

[16:22:04.0428] <Michael Ficarra>
is there seriously no [NLTH] in the proposed grammar?

[16:22:43.0063] <Justin Ridgewell>
Is this only concerned with `< stuff here >` syntax?

[16:23:32.0788] <Michael Ficarra>
requiring balanced braces would also probably be a good minimum bar

[16:23:34.0590] <HE Shi-Jun>
> <@michaelficarra:matrix.org> is there seriously no [NLTH] in the proposed grammar?

NLTH means "no line terminator" ?

[16:23:43.0201] <Michael Ficarra>
HE Shi-Jun: yes

[16:24:03.0347] <littledan>
> <@waldemarh:matrix.org> I don't understand DE's claim that all the things we've been adding to the language since ES6 are "unifying" the language.

If I said "all", then that was misspeaking by me; I do think it's been a big theme in our work.

[16:24:18.0021] <HE Shi-Jun>
Michael Ficarra: So type is complex and seems need line terminators.

[16:24:47.0999] <littledan>
Even when we add things to the standard library like Array.prototype.group or Temporal, we're unifying the ecosystem where previously people had to use various different libraries to get that functionality.

[16:24:58.0955] <littledan>
this is sort of the normal flow of work for a standards body, I think

[16:25:51.0277] <eemeli>
littledan, danielrosenwasser : Is the big-picture vision that you talked about presented in text anywhere? I think that's the sort of motivation and explanation that I'm most missing here, because I don't see how type annotations can get us from here to there.

[16:25:52.0370] <rbuckton>
`{ a: b } =>` can't be an arrow function or arrow type? I would expect `{}` to be far more limited than `()` and `[]`, at least.

[16:26:41.0830] <rbuckton>
Also, this `foo < a ;` is addressed by the "turbofish" syntax `::<>`, i.e. `foo::< a`

[16:26:51.0411] <littledan>
> <@michaelficarra:matrix.org> is there seriously no [NLTH] in the proposed grammar?

Yeah, fundamentally you don't get into this general token soup space without a paren, so you just have space for a token, or one of the productions that's explicitly there

[16:28:49.0971] <littledan>
> <@eemeli:mozilla.org> littledan, danielrosenwasser : Is the big-picture vision that you talked about presented in text anywhere? I think that's the sort of motivation and explanation that I'm most missing here, because I don't see how type annotations can get us from here to there.

It's fine to ask us to clarify the explainer more, and I'd be happy to talk with you in more detail about how/where our current readme or presentation fails to make this case. At the same time, I'm a bit offended by the implication that the champion group doesn't know what it's trying to get at, just because the documents weren't written in a way which was sufficiently clear/persuasive to everyone.

[16:34:21.0834] <Justin Ridgewell>
1min

[16:37:03.0815] <littledan>
Does anyone know what the issue numbers that Waldemar is referring to?

[16:37:29.0382] <danielrosenwasser>
Unfortunately, people keep saying "turbofish", so I'll clarify that that means `::<...>`

[16:38:08.0347] <rbuckton>
Yes, sorry. "turbofish" is the term used in Rust

[16:38:23.0484] <shu>
why is ordinary fish

[16:38:28.0855] <shu>
 * what is ordinary fish

[16:38:46.0155] <danielrosenwasser>
> <@eemeli:mozilla.org> littledan, danielrosenwasser : Is the big-picture vision that you talked about presented in text anywhere? I think that's the sort of motivation and explanation that I'm most missing here, because I don't see how type annotations can get us from here to there.

https://devblogs.microsoft.com/typescript/a-proposal-for-type-syntax-in-javascript/#whats-next

> This isn‚Äôt a sure-fire thing ‚Äì there are many valuable perspectives within the committee, and we do expect some amount of skepticism. A proposal like this will receive a lot of feedback and appropriate scrutiny. It may involve lots design changes along the way, and may take years to yield results.
>
> But if we pull this all off, we have the chance to make one of the most impactful improvements to the world of JavaScript. We‚Äôre excited by that, and we hope you are too.

[16:39:01.0189] <rbuckton>
 * Yes, sorry. "turbofish" is the term used in Rust, per: https://blog.rust-lang.org/2021/09/09/Rust-1.55.0.html#dedication

[16:39:07.0280] <Michael Ficarra>
`><>`?

[16:39:33.0208] <littledan>
shu: We've seen TS make tricky transitions before, e.g., with class fields. I'm not really sure what more details would make sense at this stage.

[16:39:57.0773] <littledan>
shu: Maybe you could be more concrete with what kind of thing you're looking for?

[16:40:08.0591] <scottwhittaker>
Waldemar's slides are at https://docs.google.com/presentation/d/1TLGdvGfOn2wl-_i_HfrfpgFkdffrhCnisowdkOiebB8/edit#slide=id.g21db78ad531_0_44 ; the two linked issues are https://github.com/tc39/proposal-type-annotations/issues/116 and https://github.com/tc39/proposal-type-annotations/issues/103

[16:40:21.0645] <shu>
littledan: how did manage the transition with class fields? are old style class fields no longer supported?

[16:40:41.0625] <danielrosenwasser>
`--useDefineForClassFields`

[16:41:07.0296] <danielrosenwasser>
it is turned on as soon as your target is `esWhateverVersionTheyGotStandardized`

[16:41:16.0551] <danielrosenwasser>
 * it is turned on as soon as your output `--target` is `esWhateverVersionTheyGotStandardized`

[16:41:23.0265] <shu>
are both kind of fields code exists in the wild and will continue to exist?

[16:41:38.0852] <shu>
 * do both kind of fields code exist in the wild and will continue to exist?

[16:42:23.0447] <littledan>
The class fields transition is significantly harder, because it's different semantics for the same syntax. This is just a syntax subset, completely statically visible with no ambiguity as to how it should run.

[16:42:54.0484] <littledan>
Until decorator metadata is standardized and adopted, set-based fields need to keep existing, unfortunately. I'm glad we're finally getting there.

[16:42:57.0584] <ljharb>
sffc: `await.all` is proposing syntax to match the existing API, not syntax instead, to be clear

[16:43:15.0745] <Rob Palmer>
(Responsible) evolution of TypeScript is in some ways easier than evolving JS because it's already accepted that regular upgrades of TypeScript are mild (responsibly managed) breaking changes.  People accept this and spend effort upgrading.  The benefits are worth it.

[16:43:23.0948] <danielrosenwasser>
I think the framing is partially about transitions, it's about "can we find tasteful alternatives to express the same concepts"

[16:43:27.0338] <ljharb>
shu: function call params are already solved because you can pass and return an object :-p

[16:43:53.0296] <shu>
and so this is also already solved by writing your own code?

[16:44:00.0081] <rbuckton>
Another example might be TypeScript's type cast syntax. We've always had `<T>value`, but added `value as T` to avoid ambiguity with JSX/TSX. We may never fully move everyone to `value as T`, but most TS code I see today uses `as`.

[16:44:12.0686] <ljharb>
> <@shuyuguo:matrix.org> and so this is also already solved by writing your own code?

for a function you author, yes. not for Promise combinators

[16:44:26.0454] <ljharb>
> <@shuyuguo:matrix.org> and so this is also already solved by writing your own code?

 * for a function you author, yes. not for Promise combinators (at least, not without a mildly complex helper function)

[16:44:53.0030] <shu>
rbuckton: i don't define non-divergence by "most code don't diverge", but by "no code diverges"

[16:45:01.0933] <ljharb>
HE Shi-Jun: re your queue item, what would `async let` do exactly?

[16:45:30.0294] <ljharb>
 * HE Shi-Jun: re your queue item, what does `async let` do exactly in swift?

[16:45:36.0177] <danielrosenwasser>
> <@danielrosenwasser:matrix.org> I think the framing is partially about transitions, it's about "can we find tasteful alternatives to express the same concepts"

so type arguments on invocations - we prefer the existing syntax, but

1. they're rarely specified, and typically inferred
2. Rust (everyone's new favorite language) has shown that people are fine with something like `f::<T, U>(...)

[16:45:39.0208] <HE Shi-Jun>
not easy to explain in one sentence

[16:45:41.0488] <justinfagnani>
I would rather see syntax here... like:
```
await const {
  shape = getShape(),
  color = getColor(),
  mass = getMass(),
};
```

[16:45:43.0954] <bakkot>
ljharb: https://www.avanderlee.com/swift/async-let-asynchronous-functions-in-parallel/

[16:46:02.0424] <ljharb>
> <@justinfagnani:matrix.org> I would rather see syntax here... like:
> ```
> await const {
>   shape = getShape(),
>   color = getColor(),
>   mass = getMass(),
> };
> ```

imo that seems like a great followon after it already exists as API

[16:46:04.0535] <bakkot>
it's neat but doesn't translate naturally to JS

[16:46:19.0557] <danielrosenwasser>
so new code can use the `::<>` syntax in TS, use the old syntax in TS, and in JS you'd have to pick one

[16:46:31.0590] <shu>
yes, and now you have diverged...?

[16:46:32.0796] <ljharb>
> <@bakkot:matrix.org> it's neat but doesn't translate naturally to JS

kind of seems like "just don't await the promise until later"?

[16:46:42.0227] <bakkot>
yyyyeah kinda

[16:46:44.0509] <littledan>
> <@shuyuguo:matrix.org> rbuckton: i don't define non-divergence by "most code don't diverge", but by "no code diverges"

Sorry, Shu, I'm trying to understand, what are you getting at? E.g., for the `<T>value` syntax, what harm does it do if TS has a mode that accepts that, and JS never will, but it might support a large other subset of TS/Flow?

[16:46:45.0775] <bakkot>
but there's better syntax for it

[16:46:56.0946] <HE Shi-Jun>
`async let` have some difficulty in JS (eg. variable capture), but I hope we can explore the possibility.

[16:47:12.0087] <ljharb>
i'm sure we could but that sounds like a different proposal maybe?

[16:47:14.0927] <littledan>
I think the important thing for the TSX transitions was, can people "live in TSX"? and in that sense, it was a complete success

[16:47:38.0368] <littledan>
it needs to be that the syntax that Type Annotations supports is enough to live in; it doesn't need to take over all existing code IMO.

[16:47:45.0723] <HE Shi-Jun>
> <@ljharb:matrix.org> i'm sure we could but that sounds like a different proposal maybe?

If it's for the same problem, shouldn't it in one proposal?

[16:47:51.0037] <ljharb>
is it the same problem?

[16:47:51.0559] <Michael Ficarra>
I think an `all` analogue is fine, the others seem to only make sense on unnamed collections

[16:47:52.0954] <rbuckton>
I don't even know what I'd use `Promise.raceOwnProperties` for.

[16:48:15.0097] <ljharb>
i'd use it for allSettled the same as i'd use it for all. the other two i don't see a use case for tho

[16:48:36.0438] <Justin Ridgewell>
But how do you tell which one won the race?

[16:48:46.0620] <shu>
> <@littledan:matrix.org> Sorry, Shu, I'm trying to understand, what are you getting at? E.g., for the `<T>value` syntax, what harm does it do if TS has a mode that accepts that, and JS never will, but it might support a large other subset of TS/Flow?

i understand that the whole point of this proposal is to bring TS syntax "into the fold". the harm is that if the promise is actually "we will work to converge TS and JS syntax in the future", that sounds like ecosystem divergence to me and i do not have the risk appetite for that

[16:48:48.0451] <HE Shi-Jun>
> <@ljharb:matrix.org> is it the same problem?

at least it could solve this problem IMO.

[16:48:50.0602] <bakkot>
> <@michaelficarra:matrix.org> I think an `all` analogue is fine, the others seem to only make sense on unnamed collections

allSettled makes sense on named collections

[16:48:55.0774] <bakkot>
the others, no

[16:49:09.0488] <bakkot>
or at least less so

[16:49:20.0035] <ljharb>
> <@haxjs:matrix.org> at least it could solve this problem IMO.

i'm not sure it would, but we would certainly explore that kind of thing in stage 1

[16:49:22.0976] <Michael Ficarra>
okay yeah I buy that

[16:50:25.0839] <ljharb>
> <@haxjs:matrix.org> at least it could solve this problem IMO.

 * i'm not sure it would, but we would certainly explore that kind of thing in stage 1. altho i think solving it with syntax is a much harder sell prior to API existing.

[16:50:32.0458] <littledan>
> <@shuyuguo:matrix.org> i understand that the whole point of this proposal is to bring TS syntax "into the fold". the harm is that if the promise is actually "we will work to converge TS and JS syntax in the future", that sounds like ecosystem divergence to me and i do not have the risk appetite for that

Yeah, this is why the syntax *is* aligned with TS and Flow for the most part. If we end up doing something like add `::<`, it would be in conjunction with the change on the TS side (it's not even in the current grammar yet).

[16:50:53.0434] <shu>
and i am saying, "for the most part" isn't enough for my risk appetite

[16:51:18.0666] <littledan>
> <@shuyuguo:matrix.org> and i am saying, "for the most part" isn't enough for my risk appetite

maybe this would be a good thing to dig into in another presentation focused on the syntax?

[16:51:37.0002] <rbuckton>
I've used `Promise.all(promises)` to avoid a waterfall when queueing up operations where I only need to wait for completion, so I wouldn't say the fact that its list-oriented is just due to "that's what we had at the time'

[16:51:40.0393] <rbuckton>
 * I've used `Promise.all(promises)` to avoid a waterfall when queueing up operations where I only need to wait for completion, so I wouldn't say the fact that its list-oriented is just due to "that's what we had at the time"

[16:52:11.0620] <bakkot>
yes, sorry, I was speaking loosely

[16:52:31.0920] <bakkot>
there's really two uses - when you have a homogenous list, where you're probably not destructuring, and where you have a heterogenous list, where you probably are

[16:52:42.0634] <bakkot>
Promise.all is perfect for the first case but awkward for the second

[16:53:56.0984] <rbuckton>
Or when you want to avoid repetition for non-degenerate cases like how the example started out.

[16:55:17.0187] <rbuckton>
`const { foo, bar } = Promise.ownProperties({ foo: getFoo(), bar: getBar() })` isn't an improvement over `const [foo, bar] = Promise.all([getFoo(), getBar()])` until you reach a level of complexity where that becomes unmanageable (as was illustrated in the example).

[16:56:39.0047] <bakkot>
I think 2 items is probably the limit though

[16:56:56.0520] <bakkot>
like when I have APIs which return 2 values I might return an unnamed pair, but as soon as it's 3 I'm going to name them instead

[16:57:51.0099] <justinfagnani>
the difference with `await Promise.all()` and function parameters is that you need to lists to use Promise.all vs one args list at the call site for a function (of course a function as a parameter list, but we can't eliminate that)

[16:58:06.0302] <rbuckton>
That said, I'm very much in favor of this as its fairly easy to exhaust that minimum complexity bar for `Promise.all()`. I'm not terribly enthusiastic about `await.` syntax, in general. I think an API approach is the right direction for now. 

[16:58:08.0592] <justinfagnani>
it's cumbersome to keep these lists in sync, and hard to read when they get long

[16:58:13.0403] <shu>
okay, on the motivation front i am now convinced, and this boils down to kevin's reason: "Promise.all is special, because the ordering of its input list is not semantically meaningful, and so is harder to keep track of mentally. except you _have_ to keep track of it mentally because it must match up to the output list"


2023-03-23
[17:00:50.0826] <bakkot>
re: waldemar's point, I agree that more general async dataflow would be great, and is something we should explore, though I think I'd still want this proposal for simple case

[17:02:28.0457] <justinfagnani>
re: Mark's comments now... when you see a ton of code that's accidentally serial instead of parallel, you really wish for a better syntax for all of this that doesn't encourage bad behavior

[17:06:53.0813] <HE Shi-Jun>
> <@bakkot:matrix.org> re: waldemar's point, I agree that more general async dataflow would be great, and is something we should explore, though I think I'd still want this proposal for simple case

but it seems not have big benefit for simple case :)

[17:09:19.0062] <rbuckton>
I'm fairly certain a cover grammar is feasible for `await using`, the big question is whether what I have put together is correct. Given the NLT restrictions, an `await using` declaration must have the first identifier in the binding list on the same line as `await using`, and that is always a syntax error in the expression case. Binding patterns aren't permitted in `using`, so there is no ambiguity with `await using [x]`.

[17:10:06.0968] <shu>
i'm gonna level with you rbuckton, i do not have enough brainpower left today to vet that cover grammar

[17:10:19.0093] <shu>
though i'm more interested in how hard it is to implement in a recursive-descent parser anyhow

[17:10:44.0542] <shu>
i'll try to put time aside before plenary tomorrow to look, but... i also have a presentation tomorrow first thing so also no promises

[17:14:04.0630] <rbuckton>
The gist of it is, the cover is identical to AwaitExpression, but UnaryExpression would fail to parse `await using x` when `x` is on the same line.  AwaitUsingDeclaration however would be able to consume the cover along with a trailing `[no LineTerminator here] BindingList`, which seems pretty much equivalent to CoverParenthesizedExpression

[17:14:33.0120] <rbuckton>
 * The gist of it is, the cover is identical to AwaitExpression, but UnaryExpression would fail to parse `await using x` when `x` is on the same line.  AwaitUsingDeclaration however would be able to consume the cover along with a trailing `[no LineTerminator here] BindingList`, which seems pretty much equivalent to CoverParenthesizedExpressionAndArrowParameterList

[17:15:00.0017] <rbuckton>
 * The gist of it is, the cover is identical to AwaitExpression, but UnaryExpression would fail to parse `await using x` when `x` is on the same line.  AwaitUsingDeclaration however would be able to consume the cover along with a trailing `[no LineTerminator here] BindingList`, which seems pretty much equivalent to CoverParenthesizedExpressionAndArrowParameterList and CoverCallExpressionAndAsyncArrowHead

[17:16:20.0619] <shu>
that... sounds reasonable

[17:16:27.0551] <rbuckton>
Though I'll admit, cover grammars in the spec today sometimes seem a bit hand-wavy in a couple places.

[17:16:53.0700] <shu>
and i just do a bounded look ahead `await` `using` and see if it's an NLTH identifier

[17:17:07.0341] <shu>
in +Await contexts

[17:17:20.0856] <rbuckton>
In TS I'd just do two-token lookahead in +Await

[17:17:53.0906] <rbuckton>
That is one benefit of `await using` over `async using`. For `await using`, both uses of the cover are in +Await, while for `async using`, only one is.

[17:18:56.0079] <shu>
and `await using` without a binding list is unaffected?

[17:19:19.0664] <shu>
well, is supposed to be, according to the cover

[17:19:43.0601] <rbuckton>
> <@rbuckton:matrix.org> In TS I'd just do two-token lookahead in +Await

In fact, I've already done that in my current work on `using` (I was experimenting with all three syntax options).

[17:20:02.0874] <shu>
is TS a hand-written recursive-descent?

[17:22:03.0809] <rbuckton>
> <@shuyuguo:matrix.org> and `await using` without a binding list is unaffected?

I'm not sure what you mean by this. `await using` on its own, or anywhere else legal for a UnaryExpression, should end up treated as an AwaitExpression.

[17:22:15.0127] <shu>
 yes, that is what i meant

[17:25:06.0574] <rbuckton>
From my understanding of cover grammars, we would eagerly parse CoverAwaitExpressionAndAwaitUsingDeclarationHead, but fail to parse the rest of ExpressionStatement. We could then retry the parse as part of AwaitUsingDeclaration, reusing the cover, and be able to successfully continue to parse. Then static semantics kick in and validate that the CoverAwaitExpressionAndAwaitUsingDeclarationHead is a valid AwaitUsingDeclarationHead (e.g., `await [NLT] using`), and parse the remainder of the statement (e.g., ``[NLT] BindingList `;` ``)

[17:25:18.0947] <rbuckton>
 * From my understanding of cover grammars, we would eagerly parse CoverAwaitExpressionAndAwaitUsingDeclarationHead, but fail to parse the rest of ExpressionStatement. We could then retry the parse as part of AwaitUsingDeclaration, reusing the cover, and be able to successfully continue to parse. Then static semantics kick in and validate that the CoverAwaitExpressionAndAwaitUsingDeclarationHead is a valid AwaitUsingDeclarationHead (e.g., `await [NLT] using`)

[17:25:22.0761] <shu>
i am happy enough to go forward with stage 3

[17:27:41.0030] <rbuckton>
I will amend the slides with a summary of these changes and wait to see if Waldemar is able to provide feedback in the meantime.

[19:53:36.0073] <Michael Ficarra>
is there anything we need to do to get Decimal on the overflow, or will it be taken care of?

[20:09:41.0097] <littledan>
> <@michaelficarra:matrix.org> is there anything we need to do to get Decimal on the overflow, or will it be taken care of?

If there is time to go through the queue for decimal, that would be great, but we could also do that next meeting

[20:10:11.0598] <Michael Ficarra>
of course, I just wanted to record it on the list of overflow items

[23:15:01.0706] <bakkot>
ljharb: I made some slides just for mark, if we have time tomorrow, PTAL: https://docs.google.com/presentation/d/1s1IZSo24JpMsI_NponP8vvIKUazld62lcleKF976Ppc/edit?usp=sharing

[07:01:22.0210] <Richard Gibson>
> <@bakkot:matrix.org> ljharb: I made some slides just for mark, if we have time tomorrow, PTAL: https://docs.google.com/presentation/d/1s1IZSo24JpMsI_NponP8vvIKUazld62lcleKF976Ppc/edit?usp=sharing

note the changes would need to be more substantive for dealing with [`v`-mode](https://github.com/tc39/ecma262/pull/2418), which has a wider set of reserved punctuators and semantics for doubled punctuators (https://github.com/tc39/proposal-regexp-v-flag#how-is-the-v-flag-different-from-the-u-flag and https://arai-a.github.io/ecma262-compare/snapshot.html?pr=2418#prod-ClassSetCharacter )

[07:42:52.0841] <rbuckton>
Are we ensuring that RegExp.escape is future proof against potential new syntax? Should we be concerned if the output changes in a later version if we have to escape something new? We could choose to be intentionally over-aggressive with escapes, if we're not already. 

[07:53:27.0434] <rbuckton>
Also, rather than extending u-mode to allow other escapes, we could escape non-u-mode syntax characters using a hexadecimal representation that is legal in all modes. So, instead of adding `\-`, we could choose to escape it as `\x2d`. Same for `\=` (`\x3d`) and `\,` (`\x2c`)

[07:53:56.0876] <rbuckton>
I'm not saying we shouldn't extend u-mode, but this is an option if we decide not to.

[08:12:08.0586] <rbuckton>
Regarding the "exhaustive list of contexts", keep in mind that several proposals add other contexts:
- Modifiers: `(?imsx-imsx:...)`
- Comments: `(?#...)`
- `x`-mode line comments: `# ...`
- Atomic Groups: `(?>...)`

At a quick glance, I think this means that `#` may need to be escaped as well, lest it me misinterpreted in `x` mode.

[08:14:56.0862] <rbuckton>
If there's a chance we want `RegExp.escape` to always remain stable, it may be worth going over the RegExp syntax investigation I did at https://rbuckton.github.io/regexp-features/features/ to ensure we're future-proof against other syntax we may choose to adopt later. Though, I admit that's not a completely exhaustive list.

[08:15:54.0839] <Chris de Almeida>
I've just had to reference the notes as I had to leave early yesterday, and the conclusion/summary was a nice help

[08:16:05.0749] <Chris de Almeida>
 * I've just had to reference the notes as I had to leave early yesterday, and the conclusion/summary for each agenda item was a nice help

[08:20:59.0198] <rbuckton>
 * Regarding the "exhaustive list of contexts", keep in mind that several proposals add other contexts:

- Modifiers: `(?imsx-imsx:...)` (stage 3)
- Comments: `(?#...)` (stage 1)
- `x`-mode line comments: `# ...` (stage 1)
- Atomic Groups: `(?>...)` (stage 1)
- Conditionals: `(?(...)...|...)` (stage 0, though I'm still hoping we'll take it eventually)

At a quick glance, I think this means that `#` may need to be escaped as well, lest it be misinterpreted in `x` mode.

[08:23:46.0570] <Jesse (TC39)>
how does scheduling of overflow stuff happen? asking for a friend

[08:24:30.0435] <bakkot>
> <@gibson042:matrix.org> note the changes would need to be more substantive for dealing with [`v`-mode](https://github.com/tc39/ecma262/pull/2418), which has a wider set of reserved punctuators and semantics for doubled punctuators (https://github.com/tc39/proposal-regexp-v-flag#how-is-the-v-flag-different-from-the-u-flag and https://arai-a.github.io/ecma262-compare/snapshot.html?pr=2418#prod-ClassSetCharacter )

The changes are just a matter of including the punctuators which have meaning (or are reserved) in v-mode; the doubled punctuators don't actually end up mattering as long as the non-doubled versions are all escaped

[08:25:18.0841] <bakkot>
the list of reserved punctuators already includes `#`, which would cover `x`-mode comments too, thankfully

[08:25:31.0306] <bakkot>
 * the list of reserved punctuators already includes `#`, so it would be escaped also, which would cover `x`-mode comments too, thankfully

[08:25:40.0286] <bakkot>
 * the list of reserved punctuators already includes `#`, so it would be escaped also, which would cover `x`-mode line comments too, thankfully

[08:26:01.0277] <rbuckton>
> <@rbuckton:matrix.org> If there's a chance we want `RegExp.escape` to always remain stable, it may be worth going over the RegExp syntax investigation I did at https://rbuckton.github.io/regexp-features/features/ to ensure we're future-proof against other syntax we may choose to adopt later. Though, I admit that's not a completely exhaustive list.

For example, we may never do recursive matching, but it still might be a good idea to escape `&` (used in `(?&name)` for recursive named capture group matching, and `(?(R&name)A|B)` in conditionals to test for recursion of a group).

[08:26:38.0181] <bakkot>
> <@rbuckton:matrix.org> For example, we may never do recursive matching, but it still might be a good idea to escape `&` (used in `(?&name)` for recursive named capture group matching, and `(?(R&name)A|B)` in conditionals to test for recursion of a group).

`&` needs to be escaped anyway for v-mode

[08:26:40.0398] <rbuckton>
> <@bakkot:matrix.org> the list of reserved punctuators already includes `#`, so it would be escaped also, which would cover `x`-mode line comments too, thankfully

That's not shown in the slides though, which only mentions `(){}[]|,.?*+-^$=<>\`

[08:26:46.0298] <bakkot>
it does say "etc"

[08:27:18.0032] <Chris de Almeida>
pull request to the agenda

[08:27:22.0965] <Rob Palmer>
The best way is to PR the agenda as that guarantees all chairs will see it. But normally messaging the chairs in matrix is enough. I will say that after we add Ron's overflow, there is bt much chance of more overflow. 

[08:27:39.0772] <Rob Palmer>
* The best way is to PR the agenda as that guarantees all chairs will see it. But normally messaging the chairs in matrix is enough. I will say that after we add Ron's overflow, there is not much chance of more overflow. 

[08:27:42.0286] <rbuckton>
Yeah, but that's somewhat unclear. If it were to escape `A`, for example, that would be a problem for https://github.com/tc39/proposal-regexp-buffer-boundaries

[08:28:27.0329] <Chris de Almeida>
there's already o-f for async ex res mgmt.  is there an additional item from Ron?

[08:28:42.0084] <Chris de Almeida>
 * there's already o-f for async ex res mgmt - 30 mins.  is there an additional item from Ron?

[08:29:02.0023] <bakkot>
It does also say it's only including punctuators, which would not include `A`

[08:29:13.0921] <Chris de Almeida>
oh... there was only a spare 25 minutes in the schedule to begin with

[08:30:08.0963] <rbuckton>
Plus that list doesn't match the explainer currently, so there doesn't seem to be a definitive source of truth. Maybe that's a stage 2 concern, but if the point of the slides is "RegExp.escape is safe", then its important to clarify how safe.

[08:44:05.0170] <eemeli>
Presumably it's sufficient to guarantee that `RegExp.escape()` safe for its own `RegExp`, rather than being safe forever.

[08:45:35.0944] <bakkot>
Well, that depends on whether anyone starts depending on it _not_ escaping certain things

[08:51:00.0465] <bakkot>
rbuckton: Updated the slides to list proposed contexts as well, and went through all the ones you listed in your research doc as well

[08:51:36.0449] <bakkot>
I'm kinda tempted to just say it escapes _every_ ascii punctuator except `_`, since I've listed I think all of them except the two quotes and backtick at this point

[08:51:49.0340] <bakkot>
I did also update it to include line terminators for `x`-mode line comments

[08:52:05.0147] <bakkot>
 * I did also update it to include line terminators so you can't break out of `x`-mode line comments, which is something I'd previously neglected

[08:53:09.0756] <rbuckton>
That's why I posed the questions earlier. Do we need to ensure `RegExp.escape()` is consistent for all time? If so, do we do that my making a best guess as to what potential syntax characters we might encounter in the future, and will that limit us in terms of what new syntax we can add? Or do we aggressively escape anything that is not alpha-numeric (or equivalent unicode characters)?

[08:54:18.0633] <rbuckton>
> <@bakkot:matrix.org> I'm kinda tempted to just say it escapes _every_ ascii punctuator except `_`, since I've listed I think all of them except the two quotes and backtick at this point

I think that may be safer, though `_` might even be worth escaping since it has meaning as part of some control verbs in Perl.

[08:54:39.0255] <bakkot>
I think we should commit to not using `_` for anything ever

[08:54:57.0792] <bakkot>
v-mode had that discussion already when they decided not to include it in the double-punctuator reservations

[08:55:34.0337] <rbuckton>
Perl has `(*positive_lookahead: ... )`, for example

[08:56:18.0432] <bakkot>
ah, that seems more like it's being used as an identifier character, and doesn't need to be escaped any more than any other identifier character

[08:57:01.0762] <rbuckton>
PCRE also uses `` ` ``, `'`, `"`, and `%` for callouts.

[08:57:18.0921] <rbuckton>
I'm not sure we'll ever do callouts, but you can never be certain.

[08:57:52.0928] <bakkot>
ok I will just say every ascii punctuator

[08:57:55.0696] <bakkot>
except `_`

[08:58:12.0655] <bakkot>
And note that we might be able to make it less aggressive

[08:58:20.0619] <rbuckton>
That's fine with me.

[08:59:02.0845] <bakkot>
re: future constraints, this does mean that we're committing that backslash + punctuator is only ever going to mean the punctuator, but that is I think a good limit to impose

[08:59:23.0921] <rbuckton>
> <@rbuckton:matrix.org> PCRE also uses `` ` ``, `'`, `"`, and `%` for callouts.

`'` is actually used quite a bit across RegExp engines, primarily as an alternative to `<>` for named capture groups.

[09:03:19.0925] <rbuckton>
> <@bakkot:matrix.org> re: future constraints, this does mean that we're committing that backslash + punctuator is only ever going to mean the punctuator, but that is I think a good limit to impose

As far as I can tell, no. The most likely engines that might have that would be Perl, PCRE, and Oniguruma, but I don't see anything like that so far.

[09:04:25.0214] <bakkot>
Sorry, by "no" do you mean "no one uses backslash + punctuator to mean anything other than the punctuator"?

[09:04:43.0397] <rbuckton>
> <@bakkot:matrix.org> Sorry, by "no" do you mean "no one uses backslash + punctuator to mean anything other than the punctuator"?

Correct, though I'm still checking.

[09:05:11.0137] <rbuckton>
I think it would be safe to say that we also would never consider `\`+punctuator to mean anything other than the punctuator.

[09:06:50.0627] <rbuckton>
There are other ways to introduce syntax that would be more meaningful than say, whatever `\~` might mean.

[09:56:40.0347] <shu>
chairs, am i still up first today? if so i'll be about 2-3 mins late

[09:57:29.0852] <Chris de Almeida>
> <@shuyuguo:matrix.org> chairs, am i still up first today? if so i'll be about 2-3 mins late

yes -  Shared structs update

[09:57:51.0218] <shu>
thanks for confirmation

[09:58:09.0252] <shu>
(reason being i still don't have home internet and have to wait till 10 to kick people out of the meeting room i booked)

[09:58:16.0724] <rbuckton>
 * There are other ways to introduce syntax that would be more meaningful than, say, whatever `\~` might mean.

[09:59:36.0688] <Chris de Almeida>
should be fine -- room still fairly empty over there

[10:05:31.0109] <Willian Martins>
I love this deck. 

[10:06:26.0991] <Andreu Botella>
wait, at what stage is shared structs?

[10:06:33.0764] <HE Shi-Jun>
Is that only me can't see shared screen?

[10:06:40.0392] <Andreu Botella>
I can see it

[10:07:38.0035] <Chris de Almeida>
maybe you have something else pinned?

[10:07:50.0929] <Chris de Almeida>
in top left, is there a button to switch to shared content?

[10:08:47.0615] <HE Shi-Jun>
exit and rejoin, still can't see shared screen üò≠

[10:09:26.0673] <Chris de Almeida>
using app or browser?

[10:09:33.0319] <ryzokuken>
> <@abotella:igalia.com> wait, at what stage is shared structs?

1: https://github.com/tc39/proposal-structs

[10:09:49.0064] <HE Shi-Jun>
app

[10:10:07.0021] <Andreu Botella>
oh, I was Ctrl+Fing for "shared" in the proposal lists

[10:10:10.0036] <HE Shi-Jun>
it works now!

[10:10:26.0470] <Andreu Botella>
 * oh, I was Ctrl+Fing for "shared" in the proposal lists and couldn't find it

[10:10:41.0847] <ryzokuken>
well, ideally that'd imply Stage 0 üôà

[10:10:55.0303] <Chris de Almeida>
it's missing from the proposals repo...

[10:10:58.0439] <littledan>
"Shared structs" have always been part of Shu's "structs" proposal.

[10:10:58.0703] <HE Shi-Jun>
ok, i can see the screen now. not sure what happened , may be just network issue.

[10:11:44.0417] <ljharb>
> <@abotella:igalia.com> oh, I was Ctrl+Fing for "shared" in the proposal lists and couldn't find it

stage 1 proposals are in a separate list

[10:11:50.0050] <ljharb>
> <@abotella:igalia.com> oh, I was Ctrl+Fing for "shared" in the proposal lists and couldn't find it

 * stage 1 (and zero) proposals are in a separate list

[10:11:52.0111] <Chris de Almeida>
yeah it;s still missing from the list

[10:12:02.0861] <Chris de Almeida>
https://github.com/tc39/proposals/blob/main/stage-1-proposals.md

[10:12:07.0727] <Andreu Botella>
yeah, I was searching in all lists, but I was searching for "shared" and couldn't find it

[10:12:12.0839] <ljharb>
"fixed shape objects" is in the list

[10:12:24.0272] <ljharb>
that was what it was presented as when it got stage 1, i assume

[10:12:34.0954] <Chris de Almeida>
ohhhh

[10:12:40.0461] <Chris de Almeida>
quick PR incoming

[10:13:07.0362] <ljharb>
Chris de Almeida: i'm not sure that's appropriate

[10:13:08.0346] <Andreu Botella>
Maybe this is just me, but the name "isolate" shouldn't necessarily guide the direction of the language /s

[10:13:20.0116] <ljharb>
at stage 1 the proposal name should describe the problem, and "shared structs" is a solution

[10:14:05.0764] <ljharb>
 * at stage 1 the proposal name should describe the problem, and "shared structs" seems like a solution to me

[10:14:59.0838] <littledan>
> <@abotella:igalia.com> Maybe this is just me, but the name "isolate" shouldn't necessarily guide the direction of the language /s

heh I guess this is more generally intelligible if you replace "isolate" with "garbage collected heap"

[10:15:28.0828] <littledan>
> <@ljharb:matrix.org> at stage 1 the proposal name should describe the problem, and "shared structs" seems like a solution to me

I think we can afford champions some flexibility here, but Shu is clearly referring to this proposal as "shared structs" so it's fine to go with that.

[10:15:48.0967] <ljharb>
fair enough

[10:17:15.0699] <Chris de Almeida>
I think it's reasonable to expect better parity between the title in the tc39/proposals repo and the title on the proposal repo itself

[10:17:20.0678] <littledan>
Note: I believe Shu is using the term "closed" in a mathematical sense, about how these graphs don't point to each other.

[10:18:58.0493] <littledan>
and "mutators" refers to the executing code (which mutates the heap--even if it's purely functional)

[10:27:09.0551] <ljharb>
i usually default to whatever's on the agenda at advancement time in the proposals table

[10:27:18.0579] <ljharb>
but i agree that it would be nice if champions kept that in sync :-)

[10:48:01.0551] <Luca Casonato>
shu: The origin isolation is not really an issue for us in Deno, because our security model ensures that only a single tenant can execute code within a single process. Essentially the effect of cross origin isolation is the default for us. There are some server side runtimes, notably Cloudflare Workers, that run multiple tenants within a single process. They disallow all high precision timers and shared memory entirely.

[10:52:27.0362] <Andreu Botella>
can't you treat a reference to a SAB from inside a shared struct as if it was a per-isolate SAB object

[10:52:43.0055] <Andreu Botella>
separate from any other SAB object pointing to the same backing store in the same isolate

[10:53:42.0012] <Andreu Botella>
 * different from any other SAB object pointing to the same backing store in the same isolate

[10:56:35.0336] <Luca Casonato>
Technically probably possible - the identity continuity seems pretty hard (but probably possible). I think the biggest problem is wether this _should_ work, because magic object cloning is not something we have right now. Also what if you have a custom class that extends SAB?

[10:57:36.0581] <Andreu Botella>
Is there a need for identity continuity? You can currently clone a SAB without identity continuity with `structuredClone(sab)`

[10:57:43.0606] <Andreu Botella>
But I guess it would be needed for some use cases

[10:57:59.0008] <Andreu Botella>
 * Is there a need for identity continuity? You can currently clone a SAB without identity continuity with HTML's `structuredClone(sab)`

[10:58:23.0731] <Luca Casonato>
Yes, but there you have an explicit transfer

[10:58:42.0106] <Andreu Botella>
Oh, right, this would be an assignment transforming into a clone behind the scenes

[10:58:45.0082] <Luca Casonato>
With shared structs, assignment is transfer/publish, which means there is no explicit action a user needs ot to take

[10:59:08.0377] <Luca Casonato>
 * With shared structs, assignment is transfer/publish, which means there is no explicit call that needs to be made to transfer

[10:59:17.0269] <Luca Casonato>
sounds confusing to users

[11:12:35.0140] <shu>
Andreu Botella: you can't make assignment a hidden clone anyway, because you need to clone it into a particular target realm, and a shared struct assignment is more like a broadcasrt

[11:12:39.0199] <shu>
 * Andreu Botella: you can't make assignment a hidden clone anyway, because you need to clone it into a particular target realm, and a shared struct assignment is more like a broadcast

[11:14:10.0508] <Andreu Botella>
you'd also want `struct.sab === struct.sab`, and that would require an extra per-isolate map

[11:15:38.0997] <shu>
yeah

[11:16:22.0825] <Luca Casonato>
You could make the assigment assign the SAB backing store into the shared struct, and then make the property access on the SAB create the JS object on demand - but that sounds slow and ugly and likely difficult to integrate

[11:16:56.0177] <Luca Casonato>
But yeah, to fix identity discontinuity you'd need a backing store -> js object map per isolate

[11:18:55.0707] <shu>
i think the DX of SAB objects themselves just don't matter

[11:19:03.0651] <shu>
since you can only use them via TA objects

[11:19:16.0334] <shu>
so to introduce a new kind of SAB object that can be put into shared structs seems the simplest solution to me

[11:20:16.0084] <littledan>
> <@lucacasonato:matrix.org> You could make the assigment assign the SAB backing store into the shared struct, and then make the property access on the SAB create the JS object on demand - but that sounds slow and ugly and likely difficult to integrate

the inability of SAB to point to JS values (with cycle collection) is a fundamental limitation. This is why I like how shared structs do *not* include the ability to be backed by SABs--it would be a completely different thing.

[11:22:08.0828] <Luca Casonato>
> <@littledan:matrix.org> the inability of SAB to point to JS values (with cycle collection) is a fundamental limitation. This is why I like how shared structs do *not* include the ability to be backed by SABs--it would be a completely different thing.

I don't understand. My comment was about engine internal code, not user code.

[11:22:27.0323] <littledan>
oh sorry I was going on a random tangent because I misunderstood

[11:24:50.0597] <rbuckton>
mark: re `yield`. I'm not sure what the champion's position is on this, but I think my preference is that context _isn't_ preserved. If it isn't preserved, there's an opportunity for a userland runtime to set context when calling `.next()`, which could be useful for something like a dataflow library. 

[11:25:42.0643] <bakkot>
(I have the opposite preference - `yield` should not be meaningfully different than `await` here)

[11:25:56.0140] <rbuckton>
`yield` is meaningly different from `await` though.

[11:26:02.0772] <bakkot>
Not for the purposes of this API

[11:26:24.0451] <HE Shi-Jun>
Both sides seems reasonable üòÇ

[11:26:28.0429] <bakkot>
In both cases the syntax is creating a continuation callback to be called at a future point, and that continuation should capture the current state

[11:26:54.0335] <littledan>
it would probably be helpful to look into the experience in Node.js, where this feature has long existed *without* such support in yield. Has this led to bugs? We should be able to find out.

[11:27:09.0638] <bakkot>
> <@littledan:matrix.org> it would probably be helpful to look into the experience in Node.js, where this feature has long existed *without* such support in yield. Has this led to bugs? We should be able to find out.

No one uses yield so it doesn't come up

[11:27:24.0834] <littledan>
> <@bakkot:matrix.org> No one uses yield so it doesn't come up

shouldn't this show up in generators all the time?

[11:27:57.0310] <bakkot>
no one uses generators either

[11:28:00.0154] <rbuckton>
> <@littledan:matrix.org> shouldn't this show up in generators all the time?

I'd expect a lot of generators run to completion synchronously, so it wouldn't be observable.

[11:28:41.0942] <rbuckton>
> <@bakkot:matrix.org> no one uses generators either

no one is far too strong. TypeScript uses them internally, and there are userland runtimes that rely on them.

[11:28:53.0286] <bakkot>
that's an exaggeration of course, but yeah like Ron says most uses of generators IME are simple enough that it doesn't end up being relevant. to see this in real life you have to do the `next` call on a subsequent turn

[11:28:55.0671] <rbuckton>
> <@bakkot:matrix.org> no one uses generators either

 * "no one" is far too strong. TypeScript uses them internally, and there are userland runtimes that rely on them.

[11:28:59.0157] <nicolo-ribaudo>
For generators that are resumed asynchronously, wouldn't the context be preserved by the async function used to resume the generator?

[11:29:23.0751] <nicolo-ribaudo>
 * For generators that are resumed asynchronously, wouldn't the context be preserved by the async helper used to resume the generator?

[11:29:48.0924] <nicolo-ribaudo>
 * For generators that are resumed asynchronously, wouldn't the context be preserved by the async helper used to resume the generator (a callback, a `promise.then`, etc)?

[11:30:06.0732] <yulia>
dumb question: there is no chance that "context" will be confused with the decorators context? Asking because I just heard context so many times and got reminded that it can be kind of meaningless because it can mean anything. Totally not a blocking concern but wondering if anyone else had the same thought

[11:30:12.0585] <rbuckton>
If `yield` _did_ preserve context, I'd argue we need a mechanism to turn this off on an as-need basis otherwise we'd block a number of valid use cases.

[11:30:35.0137] <ljharb>
are beginner devs using node's async stuff now?

[11:30:36.0471] <bakkot>
I would be OK with a `yield.nocontext` or something I guess

[11:30:52.0901] <shu>
> <@yulia:mozilla.org> dumb question: there is no chance that "context" will be confused with the decorators context? Asking because I just heard context so many times and got reminded that it can be kind of meaningless because it can mean anything. Totally not a blocking concern but wondering if anyone else had the same thought

semi-serious: time to resurrect "Conveyance"!!

[11:31:32.0349] <littledan>
> <@yulia:mozilla.org> dumb question: there is no chance that "context" will be confused with the decorators context? Asking because I just heard context so many times and got reminded that it can be kind of meaningless because it can mean anything. Totally not a blocking concern but wondering if anyone else had the same thought

Yeah it'd be great to have a name brainstorm here (in an issue, not during plenary). https://github.com/tc39/proposal-async-context/issues

[11:31:45.0088] <rbuckton>
> <@bakkot:matrix.org> I would be OK with a `yield.nocontext` or something I guess

That's the problem. In the cases I'm concerned with, the generator is provided by the user to a third party library. You want the library to handle the complexities involved with async context flow control, not the author of the genrator. You want them to not be concerned about choosing which `yield` variant to use.

[11:32:14.0924] <yulia>
i don't have a concrete alternative and context isn't horrible. I don't know if the collision would really take place, just hadn't thought about it

[11:32:26.0094] <rbuckton>
A number of languages with an `AsyncContext`-like mechanism also have some mechanism of explicitly affecting async flow control.

[11:32:26.0698] <yulia>
i'll make an issue

[11:32:31.0247] <littledan>
The thing is, an AsyncContext instance is more like a single *variable*

[11:32:38.0219] <HE Shi-Jun>
> <@bakkot:matrix.org> I would be OK with a `yield.nocontext` or something I guess

`yield.foo` will have diff semantic out of generator, don't like such syntax :P

[11:33:10.0089] <rbuckton>
> <@rbuckton:matrix.org> A number of languages with an `AsyncContext`-like mechanism also have some mechanism of explicitly affecting async flow control.

See https://learn.microsoft.com/en-us/dotnet/api/system.threading.asyncflowcontrol?view=net-8.0, for example.

[11:34:18.0610] <bakkot>
hm. I'll have to think more about `yield`.

[11:34:25.0754] <bakkot>
I could be convinced it should not preserve, probably

[11:34:30.0676] <bakkot>
 * I could be convinced it should not wrap, probably

[11:34:32.0235] <rbuckton>
> <@littledan:matrix.org> The thing is, an AsyncContext instance is more like a single *variable*

.NET calls this an `AsyncLocal<T>`, though that is backed by something called a "Call Context"

[11:37:52.0715] <ljharb>
tbh "context" is a better name for this proposal than for the decorator property

[11:38:02.0099] <ljharb>
 * tbh "context" is a better name for this proposal than for the decorator property, if we had to pick one

[11:39:16.0069] <yulia>
thats fair, up until today i was taking AsyncContext as a name for granted

[11:39:34.0747] <littledan>
let's call it "util"

[11:39:41.0713] <yulia>
oh no, what have i done

[11:39:42.0042] <littledan>
AsyncUtil

[11:40:11.0880] <Ben Newman (Apollo, @benjamn on GH)>
the meaning of "context" is highly context-dependent, unfortunately

[11:40:14.0328] <rbuckton>
`context` is a general purpose term, I'd hate for us to relegate it to a single purpose.

[11:40:43.0492] <shu>
apaprocki: i believe you but BBG is a closed-shop ecosystem, so i wouldn't weigh it too much as predictive of ecosystem integration pains for JS at large

[11:41:31.0031] <apaprocki>
understood, merely relaying experience that for the end users, who are really just writing JS, it wasn't confusing for them to understand why it wasn't working and how to fix it

[11:50:44.0388] <ljharb>
eemeli: pretty sure it's not polyfillable

[11:52:23.0216] <bakkot>
> <@rbuckton:matrix.org> That's the problem. In the cases I'm concerned with, the generator is provided by the user to a third party library. You want the library to handle the complexities involved with async context flow control, not the author of the genrator. You want them to not be concerned about choosing which `yield` variant to use.

so, "the generator is provided by the user to a third party library" seems like exactly the case where we want `yield` to preserve state. taking the example from the readme:

```js
  libraryTakingAnIterator(context.run('id', function* () {
    log('starting');

    yield 0;

    // if the library `await`s before resuming, we've lost our id
    log('done');
  }));
```
Maybe we should say that any library which consumes iterators in this way needs to juggle contexts properly? but on the other hand it's not clear to me how that's even possible here - how would the library ensure that the second half of the generator runs in the correct context?

[11:52:48.0003] <Ben Newman (Apollo, @benjamn on GH)>
you could wrap `Generator.prototype.next`

[11:53:15.0428] <Ben Newman (Apollo, @benjamn on GH)>
 * strawdog idea: you could wrap `Generator.prototype.next`

[11:53:17.0404] <bakkot>
but how does the library it get the original context?

[11:53:17.0882] <littledan>
when the queue opens back up, please feel free to ask questions about AsyncContext, even much more basic ones, about how it works at all.

[11:53:19.0701] <rbuckton>
I'd expect, at least roughly, that the context value remains referenced until `run`'s callstack is exhausted and any `Promise` created is garbage collected.

[11:53:20.0958] <bakkot>
 * but how does the library get the original context?

[11:55:31.0932] <rbuckton>
> <@bakkot:matrix.org> so, "the generator is provided by the user to a third party library" seems like exactly the case where we want `yield` to preserve state. taking the example from the readme:
> 
> ```js
>   libraryTakingAnIterator(context.run('id', function* () {
>     log('starting');
> 
>     yield 0;
> 
>     // if the library `await`s before resuming, we've lost our id
>     log('done');
>   }));
> ```
> Maybe we should say that any library which consumes iterators in this way needs to juggle contexts properly? but on the other hand it's not clear to me how that's even possible here - how would the library ensure that the second half of the generator runs in the correct context?

Hmm. that example feels odd to me, since execution for the generator doesn't actually start until you call `.next()`. That said, I'm fine if context propagates over `yield` if we have a mechanism to affect async flow control.

[11:56:47.0647] <ryzokuken>
note: we'll have to go upto 10m into lunch because of the delays 

[12:01:27.0401] <justinfagnani>
is anyone else not seeing the slides on Zoom?

[12:01:36.0142] <Jesse (TC39)>
yeah

[12:01:42.0899] <Jesse (TC39)>
oops, I mean, I am seeing the slides

[12:01:59.0793] <danielrosenwasser>
quick refresh?

[12:02:28.0103] <justinfagnani>
ah, that did it

[12:02:35.0638] <justinfagnani>
thanks

[12:04:06.0115] <shu>
i would like the conversation to come back to what littledan was proposing on "whether we want this feature"

[12:04:20.0530] <shu>
all these details beg the question of our already having consensus on that

[12:04:31.0965] <bakkot>
I do wish we had more examples yeah

[12:04:39.0725] <bakkot>
this is a big complex thing

[12:04:49.0954] <bakkot>
so I want to see it being useful for a bunch of things

[12:05:00.0615] <bakkot>
and I trust justin that it is useful for all the enumerated things, but I can't visualize how yet

[12:05:16.0388] <littledan>
Chengzhong Wugave a good presentation in WebPerfWG about this

[12:05:17.0818] <rbuckton>
> <@rbuckton:matrix.org> Hmm. that example feels odd to me, since execution for the generator doesn't actually start until you call `.next()`. That said, I'm fine if context propagates over `yield` if we have a mechanism to affect async flow control.

Actually, if `yield` propagates context then I'm not even sure a flow-control mechanism would help, since flow control would probably only affect entry to the generator, not reentry via `next()`.

[12:05:30.0966] <littledan>
Maybe next meeting, this can be given to TC39 again

[12:07:16.0539] <Lenz Weber-Tronic (phryneas)>
bakkot the most pressing issue I can think of at this time is in servers, where functions need to access stuff related to the current request. At this point it's an absolute pain of passing the current request context down and down and down in method arguments, and it's easily lost.

[12:07:59.0716] <Lenz Weber-Tronic (phryneas)>
node has `AsyncLocalStorage` for that, but any framework that wants to support more platforms than that is at a loss at this time.

[12:09:10.0342] <bakkot>
Lenz Weber-Tronic (phryneas): I believe you but I need to see it written out

[12:09:17.0286] <justinfagnani>
there's both a question why it's useful, but why it's valuable as a language feature (which is the inability of userland code to correctly wrap all closure-storing APIs or intercept `await`)

[12:09:24.0082] <rbuckton>
bakkot: I've used to thread request context information for web requests, such as the current authenticated user, request message, etc. Similar to `HttpContext.Current` in .NET (which uses the same mechanisms)

[12:09:45.0841] <justinfagnani>
Angular's zones.js problems with `await` as an example

[12:10:53.0365] <Andreu Botella>
shu: Chengzhong Wu and me are going to prototype a V8 implementation to see performance and integration with task attribution

[12:11:12.0678] <Lenz Weber-Tronic (phryneas)>
bakkot how exactly would "written out" look in this case? Just trying to figure out how to best give you the example.
Imagine you have a call stack that is 50 calls deep. Either you have a `, context` argument in every of those functions, or the one function at depth 50 can call `getCurrentRequest()` which wraps `requestContext.get()`

[12:11:22.0807] <bakkot>
Lenz Weber-Tronic (phryneas): written out meaning, like, code

[12:11:31.0309] <shu>
Andreu Botella: in blink as well? any benchmarks in mind?

[12:11:38.0105] <danielrosenwasser>
I very much don't have expertise to weigh in on this API, so I can just give trust that in the current direction; but it sounds like the feature works "in the abstract". I wish there was a prototype so that we could have a sample in which it could be demonstrated:

* "now let's add logging"
* "now let's add ..."

and see how that composes in practice. And I'm fine with discussing that in stage 2.

[12:11:55.0367] <littledan>
> <@shuyuguo:matrix.org> Andreu Botella: in blink as well? any benchmarks in mind?

In blink: Yes. Benchmarks: welcome.

[12:12:02.0081] <bakkot>
i.e. assume this API exists. what does code using it look like, concretely, that would run if it were in the language

[12:12:04.0104] <danielrosenwasser>
 * I very much don't have expertise to weigh in on this API, so I can just give trust that in the current direction; but it sounds like the feature works "in the abstract". I wish there was a prototype or sample codebase so that we could have a sample in which it could be demonstrated:

- "now let's add logging"
- "now let's add ..."

and see how that composes in practice. And I'm fine with discussing that in stage 2.

[12:12:26.0133] <shu>
littledan: it can't be just "welcome", i'm asking how andreu plans to "see performance"?

[12:12:57.0720] <shu>
we know it's possible to implement

[12:13:05.0886] <apaprocki>
> <@bakkot:matrix.org> i.e. assume this API exists. what does code using it look like, concretely, that would run if it were in the language

You could survey usage of Node's API for example code, since it essentially provides the same functionality

[12:13:14.0030] <littledan>
> <@shuyuguo:matrix.org> littledan: it can't be just "welcome", i'm asking how andreu plans to "see performance"?

OK, well, yeah, this is a reasonable requirement, and we should look into it. Keeping performance good is a goal as Justin has repeatedly said. Bloomberg is sponsoring Igalia's involvement in implementation work.

[12:13:30.0238] <littledan>
and yeah the burden should be on us to prove that it's good.

[12:13:36.0783] <Andreu Botella>
Yeah, we'll be looking into that. We don't yet have any benchmarks in mind, but this is still very early on

[12:13:50.0768] <Andreu Botella>
like, we were literally discussing this earlier today

[12:13:54.0099] <Lenz Weber-Tronic (phryneas)>
bakkot it does exist, in some form, in node

An example would be the NextJs `headers` function. This functionality would not be able at all in React-land without this API:
https://beta.nextjs.org/docs/api-reference/headers

[12:13:57.0206] <shu>
it doesn't have to be a real benchmark

[12:14:04.0762] <shu>
i'm just wondering how you plan to verify anything

[12:14:12.0795] <shu>
(not being flippant if i sounded that way)

[12:14:31.0416] <Chengzhong Wu>
In Node.js we have several micro-benchmarks that we can port to AsyncContext: https://github.com/nodejs/node/tree/main/benchmark/async_hooks

[12:15:45.0329] <Chengzhong Wu>
And we can adopt OpenTelemetry's real world use cases for benchmarking if needed.

[12:15:54.0246] <shu>
sorry let me be clearer

[12:16:08.0495] <shu>
the performance concern is that AsyncContext _itself_ will be too slow

[12:16:11.0633] <shu>
it's fine for new features to be slow

[12:16:31.0376] <shu>
the way this feature must be implemented is In The Deep at the engine level

[12:16:39.0584] <shu>
which means it affects performance of _all_ executions even if they don't use the feature

[12:17:02.0887] <shu>
i would like to see things that suggest that this feature can in fact be pay-as-you-go (or close to it), and executions that don't use the feature don't suffer performance regressions

[12:17:12.0023] <shu>
 * the performance concern is *not* that AsyncContext _itself_ will be too slow

[12:17:16.0915] <shu>
oops, missed an operative "not" above

[12:17:29.0940] <Ben Newman (Apollo, @benjamn on GH)>
V8 is already saving/restoring the `v8::Context::{Get,Set}ContinuationPreservedEmbedderData` today, which is close to what this proposal needs

[12:17:39.0757] <shu>
please, i know how V8 works

[12:17:54.0615] <Ben Newman (Apollo, @benjamn on GH)>
I know!

[12:18:25.0313] <littledan>
Yeah, it will be a clear requirement that this doesn't slow down V8. We can the existing public V8 benchmarks to verify (and I know you have CI that will also verify this after it lands).

[12:18:30.0414] <shu>
but that thing is set by the embedder in a very bounded way, in a way that V8 folks aren't 100% happy with anyway

[12:18:42.0842] <shu>
for this to become JS programmable opens up new unknowns we should understand

[12:18:43.0176] <littledan>
I'm very encouraged by how TaskAttribution landed and is always on in Chrome, apparently without performance overhead

[12:18:44.0230] <Ben Newman (Apollo, @benjamn on GH)>
fair enough / good to know

[12:18:58.0696] <littledan>
> <@shuyuguo:matrix.org> but that thing is set by the embedder in a very bounded way, in a way that V8 folks aren't 100% happy with anyway

Would be great to learn in what way V8 folks aren't happy with it for now

[12:19:19.0505] <shu>
fair, i'll try to understand this unhappiness deeply so i can articulate it

[12:20:06.0335] <Justin Ridgewell>
> <@littledan:matrix.org> Yeah it'd be great to have a name brainstorm here (in an issue, not during plenary). https://github.com/tc39/proposal-async-context/issues

As long as we don't call this `AsyncLocalStorage`, which is AsyncLocal-Storage and not Async-LocalStorage.      

[12:21:27.0505] <HE Shi-Jun>
I still like `AsyncLocal` which make the analog to `ThreadLocal` in other langauges.

[12:21:59.0996] <HE Shi-Jun>
We don't have notes of current topic?

[12:22:07.0228] <Justin Ridgewell>
> <@bakkot:matrix.org> so, "the generator is provided by the user to a third party library" seems like exactly the case where we want `yield` to preserve state. taking the example from the readme:
> 
> ```js
>   libraryTakingAnIterator(context.run('id', function* () {
>     log('starting');
> 
>     yield 0;
> 
>     // if the library `await`s before resuming, we've lost our id
>     log('done');
>   }));
> ```
> Maybe we should say that any library which consumes iterators in this way needs to juggle contexts properly? but on the other hand it's not clear to me how that's even possible here - how would the library ensure that the second half of the generator runs in the correct context?

I think the more natural is to do `context.run(libraryTakingAnIterator(‚Ä¶))`, in which case both call and init time would be equivalent

[12:22:08.0267] <Andreu Botella>
An "async context" in common parlance would seem to refer to the entire async-local map, rather than to an entry

[12:22:17.0317] <Andreu Botella>
so there's also that

[12:22:34.0156] <Justin Ridgewell>
> <@haxjs:matrix.org> We don't have notes of current topic?

It's lunch, not an official presentation

[12:24:49.0454] <HE Shi-Jun>
> <@jridgewell:matrix.org> It's lunch, not an official presentation

ok, though I would like it also have the notes (I use notes as subtitle :)

[12:25:13.0239] <HE Shi-Jun>
especially zoom do not have auto subtitle :(

[12:25:52.0793] <Justin Ridgewell>
> <@abotella:igalia.com> shu: Chengzhong Wu and me are going to prototype a V8 implementation to see performance and integration with task attribution

My hope is that this will literally have 0 performance penalty for code not using `AsyncContext`, and be like 0.00001% slowdown for code that is.

[12:26:17.0330] <Justin Ridgewell>
I believe the current node addon impl has that gurantee

[12:26:28.0911] <Ben Newman (Apollo, @benjamn on GH)>
possible jargon to distinguish between whole-map and individual items: "supertext" (not a real word) and "subtext"?

[12:26:45.0011] <Ben Newman (Apollo, @benjamn on GH)>
I agree this is a common ambiguity when talking about context, even at a linguistic level

[12:30:41.0943] <Justin Ridgewell>
 * I believe the current node addon impl has that guarantee

[12:31:34.0680] <Justin Ridgewell>
Zoom does, but I don't know how to enable it

[12:41:53.0905] <shu>
my hope goes with you

[12:45:04.0557] <shu>
waldemar: so, re: the C++ release fence. in short, you are correct that in the C++ memory model the release fence doesn't sync-with without a corresponding acquire operation on another thread.

the way V8 (and JVM) reason about this i think is more at the ISA level, per ISA. like, we think a store-store fence (`dmb` on ARM) or whatever is sufficient to publish. we need to ensure no store-store reorderings happen at both the codegen level and the CPU level.

the `dmb` guarantees that at the CPU level. a release fence seems to guarantee that at the codegen level, but strictly speaking may be incorrect.

maybe manual inline assembly is better here? idk


[12:45:22.0982] <shu>
in any case V8 mixes C++ generated code and our own generated code liberally anyway, since it's a JIT

[12:45:34.0218] <shu>
and i've never wrapped my head around reasoning at the C++ memory model level

[12:45:39.0435] <shu>
because of course taht doesn't exist for our own generated code

[12:45:57.0836] <shu>
so i generally try to reason about it by divining what ARM guarantees, then trying to shape C++ to generate the right thing

[12:46:15.0357] <shu>
(or what x86 guarantees etc)

[12:47:19.0050] <shu>
in fact, V8 also does the even more un-specified thing around atomics where we just bitcast addresses to `std::atomic`s

[12:47:24.0346] <shu>
but i think that behavior may finally be getting specced?

[12:53:55.0071] <shu>
omg it's this sub-thread that was keeping my notification at 1

[12:54:09.0154] <shu>
and now i've made it worse for other people, sorry

[12:59:18.0328] <rbuckton>
I may be a minute or two late getting back. My dogs need a bio break and don't care about the plenary schedule. 

[13:02:20.0763] <rbuckton>
> <@rbuckton:matrix.org> I may be a minute or two late getting back. My dogs need a bio break and don't care about the plenary schedule.

I'm back

[13:08:44.0772] <bakkot>
ljharb: was it es-shims which deletes it? for the notes

[13:08:59.0588] <ljharb>
`es6-shim`, specifically. 

[13:09:01.0439] <bakkot>
(I just missed the name)

[13:09:02.0615] <Justin Ridgewell>
> <@shuyuguo:matrix.org> my hope goes with you

Worth also noting is that node is already eating performance with usage of `AsyncLocalStorage`, my apps are losing native `async`/`await` performance due to my need to polyfill

[13:09:03.0771] <ljharb>
 * `es6-shim`, specifically. core-js may, i'm not sure

[13:09:22.0198] <littledan>
> <@jridgewell:matrix.org> Worth also noting is that node is already eating performance with usage of `AsyncLocalStorage`, my apps are losing native `async`/`await` performance due to my need to polyfill

Sure, but we also need to make sure that this doesn't make websites slower

[13:09:25.0331] <Justin Ridgewell>
We already live in a slow world, and this API should be much faster than the status quo

[13:09:29.0496] <shu>
the hard line is "no speedometer regressions"

[13:09:35.0626] <shu>
hard-ish

[13:10:20.0610] <littledan>
> <@shuyuguo:matrix.org> the hard line is "no speedometer regressions"

Very helpful to have this line--should be easy to develop against.

[13:10:57.0112] <shu>
godspeed you! async contexter

[13:11:23.0612] <littledan>
what is this referencing?

[13:11:41.0218] <shu>
https://en.wikipedia.org/wiki/Godspeed_You!_Black_Emperor

[13:12:03.0508] <Jesse (TC39)>
great stuff

[13:12:05.0338] <Ben Newman (Apollo, @benjamn on GH)>
the ! placement triggered the memory for me

[13:17:27.0148] <shu>
does anyone have a link to these slides?

[13:17:57.0077] <ryzokuken>
> <@shuyuguo:matrix.org> does anyone have a link to these slides?

https://docs.google.com/presentation/d/1b74GI-zHrG0wDzmwFs_yPWRli24KyVUNx3GeZt8JouA/edit#slide=id.g2227767b447_1_6

[13:18:13.0527] <shu>
ty

[13:18:51.0963] <Justin Ridgewell>
I was always more into Explosions in the Sky

[13:23:44.0489] <Chris de Almeida>
< 10 mins for this item

[13:27:59.0575] <rbuckton>
Is ns precision useful to scientific calculations, or are they more likely to depend on sub-nanosecond values?

[13:28:15.0713] <bakkot>
re: nanoseconds and microseconds, https://www.youtube.com/watch?v=9eyFDBPk4Yw

[13:29:14.0012] <rbuckton>
More to the point that computer-derived wall clock time isn't the only source of time that `Temporal.Instant` and `.Duration` might be useful for.

[13:29:57.0773] <littledan>
I think the interop case doesn't really relate to durations

[13:30:02.0722] <bakkot>
I'm sorry, _quarter_ nanoseconds?

[13:30:04.0872] <bakkot>
_why_

[13:30:27.0689] <littledan>
it fit into the bits?

[13:30:36.0538] <bakkot>
https://github.com/abseil/abseil-cpp/blob/b6de7b80325514018d38de2c4dee1254258c4b31/absl/time/duration.cc#L30-L31

[13:30:38.0004] <bakkot>
sigh

[13:30:41.0816] <bakkot>
yeah that's the reason

[13:31:45.0817] <apaprocki>
yeah, they decided to do that.. in our equivalent class, we opted just for storing nanoseconds and not quarterns like abseil

[13:31:52.0120] <rbuckton>
That and the following two lines about calculating fractional nanoseconds, but I suppose that wouldn't matter if they didn't have fractional nanosecond sto begin with.

[13:31:59.0882] <rbuckton>
 * That and the following two lines about calculating fractional nanoseconds, but I suppose that wouldn't matter if they didn't have fractional nanoseconds to begin with.

[13:32:29.0178] <shu>
that abseil thing exactly characterizes where the interop argument falls down when you tug on the chain

[13:32:40.0584] <shu>
"why did they do it? well... because it fit" is not a good first principles argument

[13:32:48.0289] <shu>
but anyways we'll have ns

[13:33:01.0152] <Richard Gibson>
does abseil _expose_ that data or just keep it internally for arithmetic?

[13:33:24.0030] <apaprocki>
it wasn't just because it fit, but because they stated a need for 0.5 ns + 0.5 ns

[13:33:29.0417] <apaprocki>
they didn't explain *where* they have that requirement

[13:33:31.0192] <apaprocki>
just that it exists

[13:33:57.0203] <shu>
v8's position is there is no good reason, and certainly not on the web

[13:34:04.0539] <littledan>
> <@shuyuguo:matrix.org> that abseil thing exactly characterizes where the interop argument falls down when you tug on the chain

I think interop where there's no standard is the kind of case where you can choose a preponderance-of-the-evidence kind of thing. ns is "good enough" in this sense. That doesn't make it a reductio-ad-absurdum

[13:34:27.0916] <littledan>
> <@shuyuguo:matrix.org> v8's position is there is no good reason, and certainly not on the web

I think half-microseconds aren't really that implausible to be relevant. Anyway there are lots of times where you're *processing* date/times without measuring them locally.

[13:34:55.0355] <shu>
the philosophical objection is actually stronger than than "there might be uses"

[13:35:15.0326] <shu>
it's "where you think you should be using nanoseconds, you are fooling yourself with the extra precision, with very few exceptions"

[13:35:30.0265] <littledan>
yeah I guess I see that and don't like the philosophy.

[13:35:42.0836] <shu>
yes, and we don't have consensus on it anyways

[13:35:48.0599] <apaprocki>
> <@shuyuguo:matrix.org> it's "where you think you should be using nanoseconds, you are fooling yourself with the extra precision, with very few exceptions"

except where law/regulations say they must be passed around... it's not about philosophy, but about preventing foot guns when moving values from one system to another through js

[13:35:59.0041] <shu>
that doesn't relate to temporal

[13:36:02.0270] <shu>
you can use BigInts

[13:36:17.0016] <littledan>
> <@shuyuguo:matrix.org> yes, and we don't have consensus on it anyways

well, I am glad you all brought the point up anyway, and that we were able to discuss it and come to a conclusion

[13:36:52.0725] <shu>
> <@apaprocki:matrix.org> except where law/regulations say they must be passed around... it's not about philosophy, but about preventing foot guns when moving values from one system to another through js

i don't understand this argument, you and others have repeatedly brought this up. why... are people shoehorning everything that represents time into Temporal data types?

[13:37:02.0710] <shu>
like ns timestamps don't need the extra complexity of tepmoral

[13:37:08.0784] <shu>
sometimes it's formatting

[13:37:12.0198] <shu>
which... is a different thing?

[13:37:25.0789] <shu>
 * like ns timestamps don't need the extra complexity of temporal

[13:37:38.0333] <apaprocki>
because you are generically binding to typed database tables or schemas for services, etc. it's a giant foot gun if developers can't take a duration from Postgres and represent it as a duration in js without loss

[13:37:59.0524] <apaprocki>
somehow knowing they need to *not* use the built-in type and use a string or unrelated type.. it's extremely not ergonomic

[13:38:30.0519] <littledan>
this is one of the key reasons for it being in the standard library rather than just telling people to use Moment

[13:38:43.0249] <shu>
first of all, postgres is ms precision?

[13:38:47.0382] <waldemar>
Indiana has (at least) 11 time zones: https://en.wikipedia.org/wiki/Time_in_Indiana

[13:39:02.0460] <apaprocki>
> <@shuyuguo:matrix.org> first of all, postgres is ms precision?

no, everything now uses ns

[13:39:07.0599] <Chris de Almeida>
üôä

[13:39:08.0207] <shu>
oh really?

[13:39:22.0827] <apaprocki>
yes.. haven't found a modern system that hasn't already upgraded (if they didn't start out ns)

[13:39:43.0073] <apaprocki>
like rust had the benefit of starting with ns because it started much later, but python upgraded over time via PEPs

[13:40:13.0852] <shu>
anyway we're not going down microseconds road

[13:40:15.0209] <bakkot>
> <@apaprocki:matrix.org> no, everything now uses ns

hm https://www.postgresql.org/docs/current/datatype-datetime.html

[13:40:27.0765] <shu>
and i would like to evict this conversation from my brain

[13:40:49.0285] <bakkot>
shu: good good, gotta make room for the conversation about time zone name canonicalization differences between TZDB and CLDR

[13:40:56.0589] <shu>
i am having lunch

[13:41:53.0716] <apaprocki>
> <@bakkot:matrix.org> hm https://www.postgresql.org/docs/current/datatype-datetime.html

"time, timestamp, and interval accept an optional precision value p which specifies the number of fractional digits retained in the seconds field. By default, there is no explicit bound on precision. The allowed range of p is from 0 to 6."

[13:43:10.0365] <apaprocki>
there is an extension that allows up to 9

[13:43:12.0187] <bakkot>
ah that's what I get for not reading past the table

[13:44:45.0527] <ryzokuken>
> <@apaprocki:matrix.org> there is an extension that allows up to 9

https://github.com/fvannee/timestamp9

[13:46:34.0626] <apaprocki>
there's a bit of drift between databases (unlike programming languages).. oracle supports ns fully, mssql is 100 ns precision iirc, but the point is that they are < 1us

[13:53:03.0364] <Chris de Almeida>
10 mins on this item

[14:05:33.0092] <apaprocki>
justingrant: thanks for doing this! Literally just starting the 2023a firedrill right now... :D

[14:10:37.0755] <bakkot>
how do people feel about parameter decorators

[14:10:57.0300] <Chris de Almeida>
cautiously... cautious

[14:12:07.0221] <justingrant>
> <@apaprocki:matrix.org> justingrant: thanks for doing this! Literally just starting the 2023a firedrill right now... :D

Thanks!  Hopefully this proposal can reduce the firedrill pain in the future. 

[14:13:59.0576] <ljharb>
i feel a lot better about parameter decorators than i do about supporting DI patterns

[14:13:59.0931] <shu>
> <@bakkot:matrix.org> how do people feel about parameter decorators

somewhere between "maybe okay if sufficiently restricted" and "i'm straight up not having a good time"

[14:14:08.0440] <ljharb>
 * i feel a lot better about parameter decorators than i do about supporting/encouraging DI patterns

[14:17:34.0568] <ljharb>
something i *do* want is the ability to mark constructor arguments as automatically stored in a public, or private, field. but that could be done potentially with a class decorator, i suppose

[14:18:23.0241] <Lenz Weber-Tronic (phryneas)>
> <@ljharb:matrix.org> something i *do* want is the ability to mark constructor arguments as automatically stored in a public, or private, field. but that could be done potentially with a class decorator, i suppose

Could that class decorator know the *name* of those constructor parameters?

[14:18:26.0532] <HE Shi-Jun>
> <@bakkot:matrix.org> how do people feel about parameter decorators

We discussed it in JSCIG meeting and it seems many TS users like it .

[14:18:57.0904] <littledan>
> <@bakkot:matrix.org> how do people feel about parameter decorators

They seem kinda cool but I really want function decorators and, separately, extractors/pattern matching, which are kind of in adjacent spaces. Probably all of this eventually; I don't know how to prioritize.

[14:19:38.0146] <ljharb>
> <@phryneas:matrix.org> Could that class decorator know the *name* of those constructor parameters?

in my ideal world an explicit constructor would be omitted, so the class decorator would define the names

[14:19:41.0495] <littledan>
parameter decorators, or something else in this space, are definitely part of the program of, "how do we find a standard, unified way to solve all of the problems that people are widely doing through language extensions"

[14:19:45.0365] <shu>
as a general philosophy i do not want more and more metaprogramming needing to be supported at runtime

[14:19:45.0383] <HE Shi-Jun>
I also want function decorators. üòÄ 

[14:19:51.0715] <Lenz Weber-Tronic (phryneas)>
> <@bakkot:matrix.org> how do people feel about parameter decorators

They are very commonly used in code I have touched over the last few years. I think the code would have been significantly more complicated without them.

[14:20:14.0050] <shu>
my hot take is that we need to standardize different phases of evaluation in JS

[14:20:19.0270] <bakkot>
> <@phryneas:matrix.org> They are very commonly used in code I have touched over the last few years. I think the code would have been significantly more complicated without them.

I have the exact opposite experience

[14:21:13.0271] <bakkot>
> <@littledan:matrix.org> parameter decorators, or something else in this space, are definitely part of the program of, "how do we find a standard, unified way to solve all of the problems that people are widely doing through language extensions"

wait I don't want that program

[14:21:16.0551] <bakkot>
I never signed up for that program

[14:21:28.0882] <HE Shi-Jun>
> <@shuyuguo:matrix.org> as a general philosophy i do not want more and more metaprogramming needing to be supported at runtime

It seems if we have class decorators, people eventually would ask for "decorate everything".

[14:21:33.0079] <bakkot>
I am explicitly opposed to solving all of the problems that people are doing through language extensions

[14:21:35.0413] <ljharb>
showing me lots of code examples that are ExcessiveNounHavers doesn't make me feel good about the patterns :-/

[14:21:45.0358] <shu>
> <@haxjs:matrix.org> It seems if we have class decorators, people eventually would ask for "decorate everything".

and?

[14:21:50.0121] <littledan>
> <@bakkot:matrix.org> I am explicitly opposed to solving all of the problems that people are doing through language extensions

not all, just the good ones. And sometimes doing things differently, for sure.

[14:22:11.0017] <ljharb>
 * showing me lots of code examples that are ExcessiveNounHavers doesn't make me feel good about the patterns :-/

just because a lot of people write X code in JS doesn't mean JS should support patterns common in X codebases.

[14:22:13.0691] <Chris de Almeida>
I'm generally apprehensive about too much hidden magic that makes grok difficult for grug brain

[14:22:21.0003] <shu>
sorry i'm being very flippant this meeting

[14:22:27.0264] <bakkot>
DI is the canonical example of hidden magic ime

[14:22:36.0016] <Lenz Weber-Tronic (phryneas)>
> <@bakkot:matrix.org> I have the exact opposite experience

NestJS has some very nice usages, fore example the `@Param` decorator in route handlers: https://docs.nestjs.com/controllers
```js

@Get(':id')
findOne(@Param('id') id: string): string {
  return `This action returns a #${id} cat`;
}
```

[14:22:36.0225] <bakkot>
like I have used it in talks as an example of that thing

[14:22:48.0082] <shu>
yes

[14:22:49.0570] <bakkot>
> <@phryneas:matrix.org> NestJS has some very nice usages, fore example the `@Param` decorator in route handlers: https://docs.nestjs.com/controllers
> ```js
> 
> @Get(':id')
> findOne(@Param('id') id: string): string {
>   return `This action returns a #${id} cat`;
> }
> ```

you and I have a different understanding of what counts as "nice", I think

[14:22:53.0631] <Lenz Weber-Tronic (phryneas)>
But I agree that there are very ugly examples as well

[14:22:59.0202] <shu>
more generally this all strikes me as optimizing for the author

[14:23:00.0468] <littledan>
> <@bakkot:matrix.org> DI is the canonical example of hidden magic ime

well, unfortunately for you (maybe), we already enabled Ember's instance field decorator-style DI through field decorators!

[14:23:03.0027] <shu>
which is the wrong audience to optimize for

[14:23:16.0505] <shu>
sometimes it's, like, not too bad

[14:23:18.0166] <shu>
in this case it is bad

[14:23:40.0313] <littledan>
I do have to admit that, with decorators evaluated at class evaluation time, they are sort of a better fit than extractors/pattern matching evaluated each time the function runs.

[14:24:06.0285] <ljharb>
i think param decorators and param pattern matching something are quite different

[14:24:16.0672] <ljharb>
the use cases, anyways, even if the capabilities are similar

[14:24:33.0749] <ljharb>
 * i think param decorators and param pattern matching/extractor "something" are quite different

[14:24:42.0870] <littledan>
> <@shuyuguo:matrix.org> more generally this all strikes me as optimizing for the author

??? isn't this sort of a core goal of programming language design? Like, if it's at the expense of the end user (e.g., for performance), then that's bad, but all else being equal, we do want to optimize for the author?

[14:25:05.0287] <ljharb>
imo we want to optimize for the person reading/maintaining the code *after* the author produces it

[14:25:07.0670] <bakkot>
> <@littledan:matrix.org> ??? isn't this sort of a core goal of programming language design? Like, if it's at the expense of the end user (e.g., for performance), then that's bad, but all else being equal, we do want to optimize for the author?

no we mostly want to optimize for the reader

[14:25:15.0878] <ljharb>
 * imo we want to optimize for the person reading/maintaining the code _after_ the author produces it

that's a far more frequent and important audience.

[14:25:20.0533] <ljharb>
iow, writability < < < readability

[14:25:22.0053] <littledan>
oh you meant author at the expense of reader!

[14:25:25.0190] <shu>
yes, correct

[14:25:35.0732] <danielrosenwasser>
I was also a little confused

[14:25:42.0061] <danielrosenwasser>
maybe all the Daniels were confused

[14:25:48.0032] <Chris de Almeida>
> <@ljharb:matrix.org> imo we want to optimize for the person reading/maintaining the code _after_ the author produces it
> 
> that's a far more frequent and important audience.

counterpoint:  that's often the same audience

[14:25:51.0118] <ljharb>
code that's easy to write but hard to read is not what i would call good code

[14:25:55.0298] <shu>
sorry, not author vis a vis user, but writer vs reader

[14:26:04.0965] <ljharb>
> <@softwarechris:matrix.org> counterpoint:  that's often the same audience

"me" and "me in 6 months" are not the same audience, and "met in 6 months" is often angry at the code i write

[14:26:07.0849] <littledan>
Yeah, I mean, I wouldn't really be a fan of some of the decorators used in this presentation

[14:26:16.0743] <HE Shi-Jun>
> <@shuyuguo:matrix.org> and?

And I think it's reasonable to have param decorators, function decorators, etc. if we support class decorators...

[14:26:21.0154] <Chris de Almeida>
fair

[14:27:20.0530] <shu>
what is the argument for it?

[14:27:27.0255] <shu>
"people ask for it" is usually not sufficient

[14:28:19.0216] <ljharb>
JS also is in a position where a ton of people come to it from different languages, and they write lots of code that matches the idioms of their source langs that does NOT match JS idiom

[14:28:31.0205] <ljharb>
ie the "java devs write java in every language" sentiment

[14:28:50.0035] <Chris de Almeida>
`ImplImplImplImplBuilderImpl`

[14:28:52.0261] <ljharb>
 * ie the "java devs write java in every language" sentiment (not just picking on java here, ofc)

[14:29:00.0311] <ljharb>
excessive nouns, indeed

[14:29:24.0240] <apaprocki>
I'd say something like "it allows you to easily reuse code that would otherwise be repeated (boilerplate), or, more importantly, *omitted* because the author doesn't want to bother due to the size of the boilerplate"

[14:29:33.0563] <apaprocki>
for things like standard parameter validation checks across a large codebase

[14:29:55.0202] <ljharb>
validation checks i 100% agree - that's not the same thing as the extensive metaprogramming demonstrated in the preso

[14:29:56.0784] <littledan>
> <@ljharb:matrix.org> JS also is in a position where a ton of people come to it from different languages, and they write lots of code that matches the idioms of their source langs that does NOT match JS idiom

Another way to frame this would be, "The culture of how people write JS is diverse and influenced by other programming languages' culture"

[14:30:05.0426] <bakkot>
`valid(x)` is almost exactly the same amount of code as `@valid`, and as a bonus also works with destructured parameters

[14:30:11.0724] <ljharb>
sure. it's just not necessarily influenced for the better.

[14:30:30.0562] <Ashley Claymore>
> <@littledan:matrix.org> I do have to admit that, with decorators evaluated at class evaluation time, they are sort of a better fit than extractors/pattern matching evaluated each time the function runs.

the function returned by the decorator does run each time, so a bit like a cached extractor

[14:30:49.0389] <Lenz Weber-Tronic (phryneas)>
> <@ljharb:matrix.org> validation checks i 100% agree - that's not the same thing as the extensive metaprogramming demonstrated in the preso

well, people had 10 years to come up with stuff, the presentation is just showing what people are already doing - and I guess showing the obvious and boring would not make a good case that it is a flexible tool, right? :)

[14:30:55.0609] <Chris de Almeida>
agree that validation seems reasonable as does ORM use case.. request mapping.. I have trouble imagining how the scope can be narrowed though

[14:31:08.0282] <shu>
i deeply hate ORM

[14:31:09.0913] <shu>
but that's personal

[14:31:16.0227] <HE Shi-Jun>
> <@danielrosenwasser:matrix.org> maybe all the Daniels were confused

I was also confused.

[14:31:25.0520] <littledan>
> <@aclaymore:matrix.org> the function returned by the decorator does run each time, so a bit like a cached extractor

right--it'd be nice if extractors could be cached, but that somehow doesn't make as much sense syntactically

[14:31:33.0269] <ljharb>
obligatory https://seldo.com/posts/orm_is_an_antipattern/

[14:31:42.0708] <bakkot>
sidebar: this is I think way too much detail for a stage 1 presentation

[14:31:45.0199] <Jesse (TC39)>
i like the *idea* of ORM but have never found one that meshes with how I want it to work

[14:31:48.0711] <Chris de Almeida>
what do you mean you don't like doing a complete 1-1 of your data model in the frontend?

[14:32:07.0929] <bakkot>
stage 1 needs like 1 slide on potential API

[14:32:14.0509] <ljharb>
i mean, look at all the times use of an ORM has allowed a seamless transition between backing databases!
 - 
 - 
 - 

[14:32:18.0022] <ljharb>
 * ## i mean, look at all the times use of an ORM has allowed a seamless transition between backing databases!

 - 
 - 

[14:32:19.0060] <bakkot>
2 maybe

[14:32:20.0654] <ljharb>
 * i mean, look at all the times use of an ORM has allowed a seamless transition between backing databases!

- 
- 

[14:32:24.0150] <shu>
> <@bakkot:matrix.org> sidebar: this is I think way too much detail for a stage 1 presentation

+1, there are very high-level foundational concerns being raised in the matrix

[14:32:32.0652] <shu>
i should think that deserves discussion time more than detailed semantics

[14:32:35.0880] <Chris de Almeida>
you've convinced me

[14:33:16.0807] <apaprocki>
> <@bakkot:matrix.org> sidebar: this is I think way too much detail for a stage 1 presentation

my gut is telling me people are erring way more on the side of TMI to fend off potential motivation concerns up front

[14:33:36.0581] <bakkot>
I have probably been guilty of this too because I fall in love with proposals and flesh them all out in my head before bringing them to committee

[14:33:48.0153] <bakkot>
but that stuff mostly ought to go in the repo rather than the presentation

[14:34:06.0806] <littledan>
to be fair to Ron, this is 9 years coming; this is very thought out even if we are having a hard time processing it all at once.

[14:35:49.0082] <Justin Ridgewell>
Does anyone else get a strong "corporate java project" vibe from the code?

[14:35:59.0102] <Justin Ridgewell>
I really need to catch up with this matrix logs

[14:36:45.0900] <HE Shi-Jun>
> <@bakkot:matrix.org> sidebar: this is I think way too much detail for a stage 1 presentation

but if not show many use cases people will refuse it because of no enough use cases??

[14:36:46.0048] <shu>
naive question: can you "just like" parse the parameters of the `toString()`'d original method in a method decorator, and... use that?

[14:37:00.0160] <bakkot>
> <@haxjs:matrix.org> but if not show many use cases people will refuse it because of no enough use cases??

the use cases part was good and appropriate

[14:37:09.0536] <bakkot>
the "here is what the type of the `target` field" part is less appropriate

[14:37:13.0796] <bakkot>
 * the "here is what the type of the `target` field should be" part is less appropriate

[14:37:14.0532] <ljharb>
> <@shuyuguo:matrix.org> naive question: can you "just like" parse the parameters of the `toString()`'d original method in a method decorator, and... use that?

yes, but that's what angular 1 did, and it's horrific and breaks whenever minification happens

[14:37:23.0368] <shu>
ah, indeed, minification

[14:37:23.0854] <shu>
thanks

[14:39:50.0318] <ptomato>
> <@jridgewell:matrix.org> Does anyone else get a strong "corporate java project" vibe from the code?

I mean I think DI is a very divisive programming technique? but IMO we should separate "this proposal would enable X footgun" and "this proposal would enable X programming technique that I don't like"

[14:40:21.0425] <bakkot>
the latter is also a valid reason to not add something though

[14:40:56.0816] <bakkot>
e.g., there are languages where constructing code at runtime and evaluating it is a core technique

[14:41:02.0245] <Chris de Almeida>
I do not miss the era of DI being the new shiny

[14:41:35.0514] <bakkot>
but I don't want people to use that technique in JS and would actively oppose features which enabled it (though, of course, that ship has sailed)

[14:41:36.0483] <Justin Ridgewell>
https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$ub45qHDXteYxSbmwfzPGXe-KTZXA2oRYer99mr5tPrY?via=matrix.org&via=igalia.com&via=mozilla.org

[14:43:39.0283] <Justin Ridgewell>
> <@pchimento:igalia.com> I mean I think DI is a very divisive programming technique? but IMO we should separate "this proposal would enable X footgun" and "this proposal would enable X programming technique that I don't like"

I think bakkot's point is also spot on. Java has an overuse of classes for **everything**, and this is shoehorning a bunch into functionality into classes because we want it to be class method param decorators

[14:44:59.0384] <Justin Ridgewell>
I'm not blocking, but god I hope I never have to work on a codebase that uses this style.

[14:45:01.0984] <Lenz Weber-Tronic (phryneas)>
> <@bakkot:matrix.org> but I don't want people to use that technique in JS and would actively oppose features which enabled it (though, of course, that ship has sailed)

I'd say there are frameworks heavily based on that, and also frameworks for the same purpose not using this at all. You probably won't get happy working in a team that loves using these techniques, but that team would find ways of doing so either way - so why not make it easier for them? It will not eradicate the option of working without these features.

[14:47:59.0379] <ljharb>
btw for function decorators can we just decide that decorated function declarations aren't hoisted? or is it more complex than that

[14:48:20.0104] <shu>
that would be extremely weirdf

[14:48:26.0102] <shu>
 * that would be extremely weird

[14:48:44.0241] <shu>
that means decorated functions declarations become non-letrec'ed together

[14:48:47.0148] <shu>
which is... extremely weird

[14:49:43.0390] <Justin Ridgewell>
I've used a lot of `function foo() { foo = function () {} }` memoized declaration wrappers, and I'd like to stop doing that.

[14:51:12.0606] <bakkot>
> <@phryneas:matrix.org> I'd say there are frameworks heavily based on that, and also frameworks for the same purpose not using this at all. You probably won't get happy working in a team that loves using these techniques, but that team would find ways of doing so either way - so why not make it easier for them? It will not eradicate the option of working without these features.

the "that technique" in the bit you quoted was "constructing code at runtime and evaluating it"

[14:51:15.0760] <bakkot>
and like

[14:51:23.0840] <bakkot>
I think we should not make it easier for them so that they don't do it

[14:52:58.0671] <Lenz Weber-Tronic (phryneas)>
> <@bakkot:matrix.org> the "that technique" in the bit you quoted was "constructing code at runtime and evaluating it"

Oh, sorry, I missed the first sentence of that message and assumed you still were talking about the current proposal.

[14:53:53.0447] <bakkot>
yeah, the point was that sometimes features enable you to do things that we, as language designers, don't want to encourage you to do. that is how I feel about this style of DI.

[14:59:56.0274] <msaboff>
TypeScript ‚â† JavaScript.  They don't need to be the same.  I think that would be a false goal of the committee.  They serve different purposes.  Developers choose various tools and language extensions in solve their problems.

[15:02:07.0717] <shu>
i think that's a 4d chess space that deals with developer mindshare and relative tech giants' soft power etc

[15:02:31.0355] <shu>
i have a hard time, attractive as it is, to adopt a more absolutist line like TS and JS can and should just stay separate

[15:03:12.0795] <bakkot>
My hope is that new projects don't adopt TS decorators

[15:03:21.0276] <shu>
 * i think that's a 4d chess space that deals with developer mindshare and respective tech giants' soft power etc

[15:03:23.0556] <bakkot>
Old projects staying on TS decorators I don't really have a problem with

[15:03:39.0568] <msaboff>
Maybe I should say that we shouldn't add something to JS because it is in TS, ...

[15:04:00.0925] <shu>
agreed

[15:04:19.0521] <littledan>
TS and JS are pretty aligned already, and this is important and valuable for Bloomberg. But yes I agree completely that we shouldn't just upstream TS features into JS uncritically.

[15:04:36.0007] <shu>
i take msaboff's statement to be stronger than that

[15:05:41.0766] <Lenz Weber-Tronic (phryneas)>
> <@msaboff:matrix.org> Maybe I should say that we shouldn't add something to JS because it is in TS, ...

Luckily, there are only two TS features that are not JS features, decorators being one of them - so that's not a long-term concern :)

[15:06:13.0453] <shu>
in your opinion, do you think that is a stable equilibrium

[15:06:15.0387] <Lenz Weber-Tronic (phryneas)>
* Luckily, there are only two TS runtime features that are not JS features, decorators being one of them - so that's not a long-term concern :)

[15:06:43.0601] <Lenz Weber-Tronic (phryneas)>
The TS team committed to not adding anything before ECMAScript Stage 3 half a decade ago, and so far they kept that

[15:07:43.0554] <HE Shi-Jun>
> <@bakkot:matrix.org> but I don't want people to use that technique in JS and would actively oppose features which enabled it (though, of course, that ship has sailed)

I agree, yes the ship has sailed. I would accept JS never have decorators, but if we already have class decorators, it's wrong to me to not having function decorators, param decorators, etc.

[15:10:30.0952] <HE Shi-Jun>
> <@shuyuguo:matrix.org> that would be extremely weird

yeah, it's weird but JS have many such weirdness as prior arts üòÇ 

[15:11:53.0353] <Justin Ridgewell>
Ashley Claymore: I would love if calling `Promise.all({ foo: bar })` just worked like MM suggests

[15:12:08.0347] <msaboff>
Maybe I'm pushing back an a theme that seems to be prevalent during this meeting, and that is JS should unify the related ecosystems.  I think that is the wrong target.  We need to be about craeful evolution of the JS language and ensuring compatibility among the various implementations.

That requires saying NO to some proposals for a variety of valid reasons.

[15:17:56.0169] <rbuckton>
> <@ljharb:matrix.org> something i *do* want is the ability to mark constructor arguments as automatically stored in a public, or private, field. but that could be done potentially with a class decorator, i suppose

I've experimented with this. Its easy to do on a simple class, but much harder to support an inherited class without injecting a function in between the super and subclass to perform initialization after `super()`. 

[15:19:00.0138] <HE Shi-Jun>
> <@jridgewell:matrix.org> Ashley Claymore: I would love if calling `Promise.all({ foo: bar })` just worked like MM suggests

I already suggest that in the issue.

[15:19:32.0318] <HE Shi-Jun>
Oh it was closed, could champion reopen that ?

[15:19:59.0076] <Chris de Almeida>
I think there was an item above this

[15:20:26.0499] <bakkot>
> <@haxjs:matrix.org> I agree, yes the ship has sailed. I would accept JS never have decorators, but if we already have class decorators, it's wrong to me to not having function decorators, param decorators, etc.

again by "that ship has sailed" I meant that we had `eval`

[15:20:45.0682] <bakkot>
but that said, in exactly the same way, I don't want us to add new ways to make it easier to have `eval`

[15:21:10.0838] <bakkot>
this is the same way I feel regarding the argument that we have method decorators so should also have parameter decorators

[15:22:34.0974] <rbuckton>
> <@aclaymore:matrix.org> the function returned by the decorator does run each time, so a bit like a cached extractor

This was going to be my point about the potential of parameter decorators to maybe have better performance than `assert`, since the conditions expressed in the decorator are cached for every call, as opposed to needing to be reevaluated each time. 
They are also simpler, since you can reference the parameter name from `context`, rather than duplicate it in an `assert`:

```js

[15:22:59.0319] <ljharb>
> <@haxjs:matrix.org> Oh it was closed, could champion reopen that ?

it's still mostly a nonstarter because of the bug thing; certainly we can keep discussing it tho

[15:23:49.0759] <rbuckton>
> <@aclaymore:matrix.org> the function returned by the decorator does run each time, so a bit like a cached extractor

 * This was going to be my point about the potential of parameter decorators to maybe have better performance than `assert`, since the conditions expressed in the decorator are cached for every call, as opposed to needing to be reevaluated each time.
They are also simpler, since you can reference the parameter name from `context`, rather than duplicate it in an `assert`:

```js
class C {
  method(x) {
    assert(typeof x === "number", "expected x to be a number")
  }
  // vs
  method2(@IsNumber x) { } // already knows the name 'x', no repetition.
} 
```

[15:24:14.0077] <bakkot>
ljharb doesn't the "if there's more than one argument and the first is not iterable, throw" mostly address the bug thing?

[15:24:35.0502] <ljharb>
yes potentially, i haven't discussed it with ashley yet

[15:25:06.0078] <justinfagnani>
Decorators are ultimately about targeted/declarative meta-programming. Without them we'd have no way to ergonomically metaprogram over class fields (and before `accessor` no way at all). Is it not in scope to metaprogram in a similar way over parameters?

[15:25:56.0934] <rbuckton>
> <@littledan:matrix.org> to be fair to Ron, this is 9 years coming; this is very thought out even if we are having a hard time processing it all at once.

I've had other proposals fail to advance explicitly because of a lack of sufficient real world examples, so I may have overcorrected a bit...

[15:26:16.0103] <bakkot>
> <@justinfagnani:matrix.org> Decorators are ultimately about targeted/declarative meta-programming. Without them we'd have no way to ergonomically metaprogram over class fields (and before `accessor` no way at all). Is it not in scope to metaprogram in a similar way over parameters?

It's "in scope" in the sense that you can argue for it, certainly? But I don't think it's "in scope" in the sense that having one implies we must have the other.

[15:26:39.0796] <ljharb>
also "metaprogramming is desirable" isn't necessarily a universal belief

[15:27:10.0366] <justinfagnani>
talk about ships that sailed in JS though

[15:27:30.0021] <bakkot>
the `eval` ship sailed too but like

[15:27:35.0875] <bakkot>
we don't need to add more `eval`

[15:27:39.0684] <ljharb>
that we've allowed one capability does not mean we should open the floodgates

[15:27:46.0162] <ljharb>
 * that we've allowed one form of a capability does not mean we should open the floodgates

[15:28:15.0349] <shu>
i don't even like DSLs!

[15:28:28.0048] <rbuckton>
> <@jridgewell:matrix.org> I think bakkot's point is also spot on. Java has an overuse of classes for **everything**, and this is shoehorning a bunch into functionality into classes because we want it to be class method param decorators

I haven't really seen this in 8 years of this feature in TS. It may happen, but certainly not frequently. 

[15:28:31.0541] <shu>
i have been radicalized despite my PL and compilers upbringing

[15:28:36.0566] <justinfagnani>
this isn't eval, or close. But metaprogramming in JS is as fundamental as the object model, `'x' in o`, `o[x]`, `for (k in o)` etc

[15:29:17.0762] <shu>
what do you mean by metaprogramming? those constructs you listed are not metaprogramming

[15:29:20.0966] <ljharb>
overuse of classes? i've seen that in plenty of codebases

[15:29:22.0056] <shu>
at least not in my head

[15:29:24.0652] <ljharb>
 * overuse of classes? i've seen that in plenty of JS/TS codebases

[15:29:27.0652] <justinfagnani>
> <@shuyuguo:matrix.org> i don't even like DSLs!

tagged template literals sailed too!

[15:29:29.0766] <bakkot>
> <@rbuckton:matrix.org> I haven't really seen this in 8 years of this feature in TS. It may happen, but certainly not frequently.

Isn't the `BooksAPI` example a really clear example of that?

[15:29:42.0302] <bakkot>
There's no reason to make that a class at all except that it's the only way you can get parameter decorators

[15:29:54.0531] <Justin Ridgewell>
I think the code samples in the slides demonstrated it already?

[15:29:55.0553] <bakkot>
In any other context those functions would be separate functions

[15:30:17.0661] <rbuckton>
Only in that it is a fairly limited example. NestJs has better examples. These often are decorated at the class level as well.

[15:30:39.0603] <shu>
> <@justinfagnani:matrix.org> tagged template literals sailed too!

the ability to embed a language between some quotes isn't also the same treatment that languages that care about DSLs give to DSLs. agreed in the abstract but pretty different in degree imo

[15:30:53.0591] <justinfagnani>
> <@shuyuguo:matrix.org> what do you mean by metaprogramming? those constructs you listed are not metaprogramming

being able to introspect objects and dynamically manipulate them is in the realm of metaprogramming for many languages where objects aren't maps. In other languages doing that would specifically require using a reflection API.

[15:30:58.0034] <littledan>
Sorry for causing delay!

[15:31:02.0453] <shu>
i see that as reflection

[15:31:16.0337] <shu>
when i say metaprogramming i specifically mean reflecting _code_ as _data_ that can be manipulated

[15:31:25.0348] <shu>
if you are reflecting data as data, i don't consider that metaprogramming

[15:31:46.0940] <shu>
somewhat confusingly, you sometimes hear this referred to is "homoiconicity" from the schemers

[15:31:57.0745] <shu>
 * somewhat confusingly, you sometimes hear this referred to as "homoiconicity" from the schemers

[15:32:24.0055] <littledan>
> <@rbuckton:matrix.org> I've had other proposals fail to advance explicitly because of a lack of sufficient real world examples, so I may have overcorrected a bit...

I really appreciated all the examples, especially how you showed how people really want to use class parameter decorators, and didn't just focus on the ones that would look best to committee. (And we did hear, today as well, that one convincing example was not enough for AsyncContext.)

[15:33:21.0677] <littledan>
> <@shuyuguo:matrix.org> if you are reflecting data as data, i don't consider that metaprogramming

I think it's reasonable to consider object field names "code"

[15:33:34.0457] <shu>
disagree

[15:33:42.0096] <shu>
i don't think it's reasonable to consider strings code?

[15:33:42.0334] <ljharb>
i also disagree

[15:34:02.0603] <littledan>
I mean, they are code in other languages

[15:34:14.0301] <shu>
what does that mean?

[15:34:17.0842] <shu>
you can jump to a string?

[15:34:49.0697] <littledan>
well, just accessing a field by name in C++ is a fragment of code, and the kind of stuff you can do with `[]` in JS would be "reflection"

[15:35:08.0674] <shu>
i am very confused

[15:35:18.0653] <littledan>
anyway this is philosophy and not relevant to any decision we have here

[15:35:26.0494] <ptomato>
I guess in that there is no way to do this in C++?
```c++
struct S {
  int a;

[15:36:00.0111] <ptomato>
 * I guess in that there is no way to do this in C++?

```c++
struct S {
  int a;
  int b;
};
S s = new S();
const char *fieldname = "a";
s->[fieldname] = 5;
```

[15:36:05.0631] <justinfagnani>
in many languages a utility to replace a method would have to use metaprogramming, in JS you can patch a prototype - same goal, different mechanism. I think it's still metaprogramming.

[15:36:21.0952] <ptomato>
 * I guess in that there is no way to do this in C++?

```c++
struct S {
  int a;
  int b;
};
S* s = new S();
const char *fieldname = "a";
s->[fieldname] = 5;
```

[15:36:23.0063] <shu>
okay, then my apologies for using too imprecise a term

[15:36:41.0573] <littledan>
> <@pchimento:igalia.com> I guess in that there is no way to do this in C++?
> 
> ```c++
> struct S {
>   int a;
>   int b;
> };
> S* s = new S();
> const char *fieldname = "a";
> s->[fieldname] = 5;
> ```

exactly, whereas you can do this with some kind of Java "reflection" API I think

[15:37:18.0933] <shu>
i am specifically against evolving JS to enable more facilities to reflect code as data in order to manipulate that data, and to evaluate the manipulated new data as code

[15:37:29.0776] <shu>
a space that i consider decorators to be in generally, thus the desire to restrict them

[15:37:55.0035] <ptomato>
although, now that I think of it, you _can_ do it in C++ with `offsetof` and/or template parameters

[15:38:05.0692] <justinfagnani>
> and to evaluate the manipulated new data as code

this isn't part of the proposals though, right?

[15:38:16.0786] <apaprocki>
> <@pchimento:igalia.com> although, now that I think of it, you _can_ do it in C++ with `offsetof` and/or template parameters

or using a map from string -> pointer

[15:38:41.0786] <bakkot>
justinfagnani: e.g. the proposal in its current form exposes the names of parameters, which thus far are purely code rather than data except in terms of f.p.toString

[15:38:42.0832] <shu>
> <@justinfagnani:matrix.org> > and to evaluate the manipulated new data as code
> 
> this isn't part of the proposals though, right?

not anymore it isn't, the bag of descriptors thing kinda had that feel

[15:38:49.0998] <justinfagnani>
if it helps to use "reflection" instead of "metaprogramming", to indicate there are no new facilities for evaluating data as code, then ok

[15:39:35.0832] <ljharb>
code as data?

[15:40:08.0126] <shu>
> <@bakkot:matrix.org> justinfagnani: e.g. the proposal in its current form exposes the names of parameters, which thus far are purely code rather than data except in terms of f.p.toString

precisely this. currently you can alpha-convert (or de bruijn index-ize) parameters, if there's no presence of direct eval

[15:40:11.0437] <shu>
decorators prevents this

[15:40:18.0415] <justinfagnani>
I meant "data as code" referring to Shu's objection

[15:40:49.0763] <shu>
i think jordan is just saying you reversed the direction

[15:40:59.0501] <justinfagnani>
I did?

[15:41:19.0250] <justinfagnani>
you oppose reflecting on code as data, then using evaluating that data  as new code

[15:41:20.0495] <ljharb>
"evaluating code as data" is the Bad Thing

[15:41:20.0836] <justinfagnani>
yes?

[15:41:39.0363] <shu>
oh sure, yes, there's a round trip

[15:41:54.0324] <justinfagnani>
right

[15:42:01.0323] <ljharb>
"evaluating data as code" is already eval, and separately we also want to avoid new forms of eval

[15:42:17.0212] <shu>
so thanks for pushing on this i guess i don't strictly mean a full round trip

[15:42:34.0396] <shu>
reifying code as data, then running code on that code-as-data and causing new behavior, also feels like a smell to me

[15:43:15.0852] <shu>
that's how i think of what underlies people not liking "hidden magic"

[15:44:22.0132] <bakkot>
yes for DI in particular

[15:44:43.0995] <bakkot>
like normally the answer to "how did these values get bound to these parameters" is "the caller passed them in, or they are the default values"

[15:44:54.0042] <bakkot>
after parameter decorators, the answer will be "it is literally not knowable'

[15:45:01.0799] <justinfagnani>
I don't use DI myself, but... this is also true in DI

[15:45:18.0088] <justinfagnani>
the DI container passes in the parameters through a normal ctor call

[15:45:32.0838] <ptomato>
I think of hidden magic much more broadly - for me it's anything where execution jumps to an entirely different place and it's not obvious from the code

[15:45:53.0260] <ptomato>
like accessor properties, operator overloading, ...

[15:46:01.0377] <bakkot>
the DI container is a maximally abstract central location for passing values to things

[15:46:18.0742] <bakkot>
"the values are passed by the DI container" doesn't tell you anything about how they got there

[15:47:29.0187] <bakkot>
similarly, if you (as I do) transform your whole program into a bespoke implemented-in-JS VM, and then the main loop of the VM does the dispatch for all function calls in the entire program, that's also "the values are passed by the callers" but it's completely impossible for readers to follow

[15:47:48.0184] <ptomato>
I don't necessarily want to stamp out hidden magic, I think it's great when used responsibly and in reasonable amounts, and I'd hesitate to pass a value judgement on others' codebases that might have different tradeoffs as to what they consider "reasonable"

[15:47:50.0144] <justinfagnani>
it's fine to not like that, but it's pretty analogous to higher-order-functions... those can absolutely be abused in nasty ways.

So many of us would prefer code bases that don't do that too much. But is it invalid as a whole?

[15:48:09.0543] <ptomato>
haha, I think I'm saying the same thing as justinfagnani here :-)

[15:48:11.0474] <bakkot>
I don't know what "invalid" means.

[15:48:21.0806] <bakkot>
Like it does... work? It's a legal program you can write in a language which allows it?

[15:48:41.0178] <bakkot>
But is it something the language should specifically set out to enable? That is a matter of opinion and my opinion is no, it should not.

[15:48:43.0496] <ljharb>
i feel like there was not appetite to add "curry" or "compose", partially or those reasons

[15:48:55.0354] <ljharb>
 * i feel like there was not appetite to add "curry" or "compose", partially for those reasons

[15:53:09.0158] <shu>
man if my Schemer professors could see me now

[15:53:17.0932] <shu>
"macros are bad, actually" "language tower is dumb, actually"

[15:54:10.0618] <Michael Ficarra>
I also reviewed this proposal (aside from the latest grammar changes)

[15:54:11.0584] <bakkot>
do you mean numeric tower or does "language tower" mean a different thing?

[15:54:18.0517] <shu>
no i mean language tower

[15:55:41.0987] <shu>
trying to find some documentation here...

[15:55:45.0254] <Michael Ficarra>
in Scheme, in order to solve any problem, you first create the perfect language for solving that problem, and then you write the solution in that language

[15:56:07.0150] <shu>
but yes, the basic idea is you build a tower of DSLs that bottom out at Core Scheme or whatever

[15:56:19.0234] <Michael Ficarra>
DSLs on DSLs

[15:56:24.0907] <shu>
and hygenic macros pave the way for this wonderful write-only worldview

[15:56:36.0165] <shu>
heaven forbid you should want to collaborate with others

[15:57:12.0414] <Michael Ficarra>
that's why schemers value PL skills so highly, it's because they see every programmer as a PL designer

[15:57:51.0396] <bakkot>
https://softpanorama.org/People/Knuth/index.shtml#Introduction

> As to your real question, the idea of immediate compilation and "unit tests" appeals to me only rarely, when I'm feeling my way in a totally unknown environment and need feedback about what works and what doesn't. Otherwise, lots of time is wasted on activities that I simply never need to perform or even think about. Nothing needs to be "mocked up." ~knuth

[15:59:28.0825] <shu>
 * but yes, the basic idea is you build a tower of DSLs that bottoms out at Core Scheme or whatever

[16:00:04.0093] <Michael Ficarra>
something we haven't done as well on: D&I initiatives

[16:00:54.0736] <shu>
please photoshop me into the photo

[16:06:09.0331] <shu>
you can use this picture 

[16:06:41.0305] <apaprocki>
thought it would be your router with the blinking connection light

[16:09:03.0513] <rbuckton>
> <@shuyuguo:matrix.org> i don't think it's reasonable to consider strings code?

Python considers parameter names to be `__code__`, if that helps.

[16:13:34.0861] <Chris de Almeida>
üéâ

[16:16:43.0689] <waldemar>
> <@pchimento:igalia.com> I guess in that there is no way to do this in C++?
> 
> ```c++
> struct S {
>   int a;
>   int b;
> };
> S* s = new S();
> const char *fieldname = "a";
> s->[fieldname] = 5;
> ```

Without using macros there is no way I can think of to use the field names as string keys. But I've seen dark template magic that lets you take a class such as S and do generic introspection about its fields and their types, iterate through the fields, get the nth field and its type, etc.

[16:33:34.0556] <ptomato>
For sure. After I posted the message, I thought of `offsetof`


2023-03-24
[02:52:49.0632] <yulia>
*mumbles* i know what you are getting at, but. 

[03:10:55.0460] <yulia>
... wait i want to be  in it too. 

[14:43:34.0292] <Michael Ficarra>
can we have the Chicago meeting in VRChat?

[14:46:18.0853] <shu>
well is there a Jar Jar or Goofy avatar?

[14:50:56.0281] <TabAtkins>
in vrchat? of course there is.

[14:56:15.0003] <shu>
then sounds like we can have the chicago meeting in VRChat

[15:36:16.0565] <snek>
+1 we definitely need to have a vrchat meeting 

[15:37:52.0151] <ljharb>
what is vrchat

