2023-03-12
[19:00:52.0741] <Jack Works>
ah

[19:01:01.0146] <Jack Works>
when can we have field declaration in constructor parameter

[19:01:51.0206] <Jack Works>
```js
constructor(#srv) {}
```

rather than

```js
#srv
constructor(srv) {
    this.#srv = srv
}
```

[20:02:28.0439] <ljharb>
what about if you want `this.srv = srv;`?

[21:08:27.0330] <Jack Works>
I don't know ü§£

[01:29:29.0645] <Ashley Claymore>
https://es.discourse.group/t/class-property-parameters/543/12
(Note: this was before I had joined Bloomberg, not a BB proposal)

[07:13:04.0786] <bakkot>
some discussion around `take` being confusing in this thread, with a proposed fix of renaming to `limit`; thoughts? https://github.com/tc39/proposal-iterator-helpers/issues/71#issuecomment-1461841551

[07:13:46.0856] <bakkot>
specifically the confusion is, the subiterator form `take` closes the underlying thing when the subiterator is exhausted, which might confuse people who are wanting to repeatedly take a few items

[07:14:34.0173] <bakkot>
this is a disanalogy with other languages because most things you can call `take` on don't have a notion of "being closed", even iterators

[07:14:37.0750] <bakkot>
cc Michael Ficarra 


2023-03-13
[01:06:56.0495] <bakkot>
ljharb: we have some extra time on the agenda this meeting; if markm's around, do you think we could talk about next steps for making regex escape happen?

[01:07:49.0063] <bakkot>
that is, assuming the next step for that proposal is "talk to the rest of the committee and settle on a design", rather than anything in particular which would need to be done in advance of the meeting

[01:19:48.0498] <bakkot>
(or if anyone has other proposals blocked on similar "we just need to discuss and/or argue about it for a while" issues, this seems like a good time)

[04:41:25.0041] <littledan>
> <@bakkot:matrix.org> (or if anyone has other proposals blocked on similar "we just need to discuss and/or argue about it for a while" issues, this seems like a good time)

Could be fun also to chat about the fundamentals of equality and immutability and what the committee wants there.

[04:43:07.0101] <littledan>
Also, if we are going totally crazy, we could talk about reactivity and signals and observables

[04:43:47.0587] <littledan>
> <@bakkot:matrix.org> (or if anyone has other proposals blocked on similar "we just need to discuss and/or argue about it for a while" issues, this seems like a good time)

 * Could be fun also to chat about the fundamentals of equality and immutability and rekey/compound keys.

[05:08:32.0406] <Jesse>
> <@bakkot:matrix.org> (or if anyone has other proposals blocked on similar "we just need to discuss and/or argue about it for a while" issues, this seems like a good time)

I'm happy to chat about decimal numbers!

[05:13:18.0378] <Jesse>
> <@bakkot:matrix.org> (or if anyone has other proposals blocked on similar "we just need to discuss and/or argue about it for a while" issues, this seems like a good time)

 * I'm happy to chat about numbers (decimal or otherwise)!

[12:36:24.0560] <Michael Ficarra>
‚Ñö?

[12:44:06.0761] <littledan>
‚Ñù?

[12:50:22.0461] <Michael Ficarra>
hopefully not ‚ÑÇ

[15:03:17.0694] <ljharb>
went ahead and added a topic for it


2023-03-14
[01:23:24.0698] <Jesse>
AFAIK there is not current proposal to add ‚ÑÇ to JS ü§£

[01:23:32.0933] <Jesse>
 * AFAIK there is no current proposal to add ‚ÑÇ to JS ü§£

[01:46:42.0155] <nicolo-ribaudo>
https://github.com/tc39/proposal-extended-numeric-literals
"Other numeric types which may be added: [...] Complex numbers" üòõ

[01:48:33.0658] <Andreu Botella>
Next up, quaternions

[01:51:12.0995] <Jesse>
see, there's all sorts of stuff to talk about!

[09:26:19.0632] <Michael Ficarra>
okay, serious question: what advantage do decimals have over rationals?

[09:26:24.0956] <Michael Ficarra>
it seems like rationals would be strictly better

[09:27:20.0136] <Michael Ficarra>
and a rational library is really simple to implement on top of bigints today

[09:36:00.0613] <Jesse>
one concern that comes to mind with rationals would be the normal form representation (unless one wants to expose numerically equal values with different representations). There might be quite a lot of integer division and modulo checks to reduce the numerators and denominators

[09:38:02.0944] <Jesse>
there was a discussion about rationals in proposal-decimal: https://github.com/tc39/proposal-decimal/issues/6

[09:45:27.0832] <littledan>
Rationals and decimals are just different data types. A very common and important operation on decimals is rounding in an inherently base-10 way; this operation doesn't really make sense on rationals.

[09:46:03.0526] <littledan>
pervasive rounding is also important to control size blowup (which, as Waldemar, remains a problem anyway for BigDecimal, but is worse for rationals)

[09:55:21.0264] <Michael Ficarra>
I dunno, that thread seems to support rational pretty well IMO

[09:55:51.0000] <Michael Ficarra>
a smart implementation can amortise the GCDs as appropriate for the platform

[09:56:49.0713] <Michael Ficarra>
anyway, we can talk more about it at the meeting next week

[12:15:53.0207] <littledan>
> <@michaelficarra:matrix.org> I dunno, that thread seems to support rational pretty well IMO

Heh my leading comment there is pretty weak. I'd say that the main factor for me is this round operation. Looking forward to discussing more.


2023-03-15
[12:33:42.0916] <Michael Ficarra>
Reminder for anyone attending the meeting next week: prepare for rain. March is Seattle's rainiest month. It will rain every day.

[12:39:42.0961] <littledan>
ljharb: Just curious, was the ordering there deliberate?

[12:41:17.0821] <ljharb>
 ordering?

[12:59:44.0974] <Ashley Claymore>
Extra please I choose the nearest hotel 

[12:59:50.0213] <Ashley Claymore>
* Extra pleased I choose the nearest hotel

[13:04:03.0989] <Michael Ficarra>
yes, the Lotte literally has a covered walkway between its entrance and the F5 Tower entrance

[13:41:49.0134] <littledan>
the RegExp topic comes amid Stage 3 proposals, even though it's Stage 1

[13:41:56.0048] <littledan>
in the agenda

[14:15:35.0948] <ljharb>
sorting is by timebox first, then stage

[14:15:50.0170] <ljharb>
or did i mess that up, and it‚Äôs the reverse? I‚Äôll check 

[14:16:07.0950] <ljharb>
ah you‚Äôre right, my bad, will fix

[14:33:06.0955] <Michael Ficarra>
no need, I fixed it for you already

[14:36:12.0639] <ljharb>
i saw; there were a few others that needed fixing so i rebased and pushed

[15:25:10.0928] <ptomato>
anyone got any recommendations for where to buy a prepaid SIM card nearby the venue?

[15:33:11.0833] <Michael Ficarra>
ptomato: Will you be arriving via the airport? Usually there are kiosks in the airport.

[15:35:01.0903] <ptomato>
I'm coming by train from north of the border üòÑ

[15:37:42.0944] <Michael Ficarra>
Does your carrier not cover US/Canada? Most US carriers cover Canada at least.

[15:39:45.0772] <ptomato>
I have a very cheap carrier which does not cover the US  - I rarely use talk/text unless I'm travelling, in which case I buy a SIM card

[15:45:52.0233] <Michael Ficarra>
I would probably try this 7-Eleven around the corner: https://goo.gl/maps/Qg11dSu9Fcz2LmRy8

[15:46:24.0313] <ptomato>
thanks!

[15:46:28.0818] <Michael Ficarra>
also if you're picking up masks/tests at the local Bartell Drugs, they may carry prepaid SIM cards

[15:47:02.0001] <ptomato>
those I was going to bring, but that's nonetheless a good tip for others maybe!

[15:48:51.0675] <Michael Ficarra>
it also might not be too late to order a prepaid US SIM online and get it delivered before you leave

[15:49:22.0904] <Michael Ficarra>
that might be better if you're worried about being without talk/text/data on your way from the train to F5 Tower

[15:51:20.0763] <Michael Ficarra>
anyway, if none of those suggestions work, just ping one of us and we can help figure something out

[15:52:09.0715] <ptomato>
I'm not too worried about that, I'd probably be using it more for coordination with other attendees

[15:52:12.0270] <ptomato>
thanks!

[15:53:17.0830] <shu>
https://pagersdirect.net/


2023-03-16
[17:34:50.0862] <Chris de Almeida>
ptomato: if your phone has eSim, I've used the ones you can buy online, and worked well

[17:35:00.0061] <Chris de Almeida>
 * ptomato: if your phone has eSIM, I've used the ones you can buy online, and worked well

[17:36:40.0344] <Chris de Almeida>
well - I only used the data-only one that Orange sells and used in Europe, but presumably can get the same for US from them or another carrier

[17:38:45.0960] <Chris de Almeida>
I avoided the resellers like airalo, etc that route all your stuff through middleperson servers


2023-03-20
[07:55:35.0823] <Rob Palmer>
The draft schedule for this week's TC39 plenary has been posted on [the Reflector](https://github.com/tc39/Reflector/issues/461).  Please do not share the link here because this is a public channel with logs.

[09:03:21.0027] <Rob Palmer>
For those folk in Seattle, we have a dedicated Matrix room for logistics of getting around or meeting for dinner.  Please say if you need an invite.


2023-03-21
[08:14:25.0580] <Rob Palmer>
Hello all.  Plenary meeting begins in just under two hours.

For those attending in person in Seattle, please arrive from 09:20 where you will be met in the F5 lobby.  Breakfast will be served on the same floor as the meeting room from 09:30.

[08:33:28.0750] <shu>
i still don't see a zoom link

[08:43:09.0339] <Rob Palmer>
The entry-form containing the zoom link will be posted in the next 30 mins and I will notify here.

[09:20:52.0868] <Jack Works>
why we're always changing the meeting software ü§î

[09:21:19.0509] <Rob Palmer>
The entry form is now available on the Reflector:  https://github.com/tc39/Reflector/issues/461

[09:22:41.0770] <Rob Palmer>
Jack Works: This is due to host room setup.  The room has been built to work with Zoom, e.g. the AV is connected to an inaccessible Zoom server.  We did try to get Google Meet running with no success.

[09:55:26.0947] <Rob Palmer>
We begin in 5 minutes! 

[09:56:12.0048] <Rob Palmer>
This is our room for the week. 

[09:59:43.0211] <ryzokuken>
looks great!

[10:02:21.0178] <shu>
Customer Engagement Center

[10:04:41.0900] <yulia>
looks really fancy

[10:04:50.0899] <yulia>
(im not present in any form today)

[10:09:55.0474] <Anthony Bullard>
Wish I was there

[10:14:55.0648] <msaboff>
@bakkot You should probably advertise somehow that you are recording for the late arrivals.

[10:25:41.0212] <bakkot>
msaboff: I'll say it again in my editor update

[11:09:14.0210] <shu>
dminor: not sure i understand that point. that sounds like mozilla-internal meeting wrangling

[11:09:44.0985] <ryzokuken>
I think the point they tried to make was that what Shane's mentioning now

[11:09:50.0817] <ryzokuken>
TG2 is run very differently

[11:10:03.0712] <ryzokuken>
for one, the agenda isn't set up clearly ahead of time

[11:10:40.0706] <ryzokuken>
we don't use TCQ but do use a simpler Google Meet queue

[11:10:42.0196] <shu>
ah i misunderstood then, it was about how TG2 is run, not mozilla?

[11:11:07.0994] <ryzokuken>
well, a bit of both I thought

[11:11:32.0299] <ryzokuken>
because of how TG2 is run, Mozilla cannot have structured internal discussions about the agenda a week ahead

[11:11:42.0907] <ryzokuken>
(IIUC, dminor will probably correct me)

[11:11:43.0303] <dminor>
Basically, it would be difficult for us to review proposals properly in advance given the way that TG2 is currently run, so we'd prefer to continue to do advancement in the main committee meetings

[11:12:08.0307] <shu>
dminor: okay, thanks

[11:15:28.0133] <littledan>
Async: Please share the link to the slides on test262 funding so we can reference them from the notes.

[11:25:23.0256] <Ashley Claymore>
https://ptomato.name/talks/tc39-2023-03/

[11:25:27.0795] <Ashley Claymore>
agenda and notes updated

[11:28:54.0614] <Rob Palmer>
To meet Justin Grant's schedule constraint, we are suggesting Temporal will be at 13:00 (first thing after lunch)

[11:31:33.0736] <shu>
wow jordan sounds great

[11:31:37.0004] <shu>
kudos to these room mics

[11:31:43.0224] <apaprocki>
Do any other Ecma TCs have shared costs between member companies that attend? Curious if something like specific TC "dues" could work if rolled up into the yearly fee.

[11:32:20.0825] <apaprocki>
A lot of pain in companies contracting out work if they can't do it themselves is the burden of that internal process... 

[11:35:36.0486] <ljharb>
it definitely seems like the primary purpose of member dues is so Ecma, not individual members, can fund shared needs.

[11:59:02.0634] <HE Shi-Jun>
not sure how renaming to limit/skip solve the problem ...

[12:00:10.0701] <Bradford Smith>
do all of the iterator helpers currently close the underlying iterator?

[12:00:36.0477] <rbuckton>
> <@haxjs:matrix.org> not sure how renaming to limit/skip solve the problem ...

I don't think it does, especially given the rather common meaning of `take` across the ecosystem as well as other languages.

[12:01:13.0781] <littledan>
> <@apaprocki:matrix.org> Do any other Ecma TCs have shared costs between member companies that attend? Curious if something like specific TC "dues" could work if rolled up into the yearly fee.

Ecma folks have told me that there have been shared costs historically, and that members handle their own financial things when it comes up

[12:01:15.0674] <rbuckton>
It's rather trivial to write a wrapper for an iterator that doesn't forward `return`

[12:01:21.0874] <littledan>
(and they consider this best practice in general)

[12:01:35.0695] <Rob Palmer>
We will return in one hour.  If any of the remote attendees have feedback on AV etc please say it here.

[12:01:57.0028] <Bradford Smith>
I find "limit" less understandable than "take". If it helps avoid misunderstanding, I would expect that's only because one has to read the docs to understand what it does at all.

[12:10:06.0956] <peetk>
imo "limit" conveys very clearly that the iterator is closed, i guess because it sounds like SQL limit, and obviously SQL queries are not stateful; whereas "take" is much more ambiguous. but i guess this is a minority view!

[12:56:40.0878] <Bradford Smith>
Are there actually any iterator helpers in the proposal that do *not* close the underlying iterator?

[12:58:20.0647] <Justin Ridgewell>
They all either iterate everything (thus closing the underlying), or close when they early exit

[12:58:26.0161] <bakkot>
`take` is special in that `take` ends _before_ exhausting the underlying iterator

[12:58:33.0685] <Bradford Smith>
My general expectation is that if I pass an iterator off to any other code, I should assume it is exhausted and not touch it again myself.

[12:59:20.0898] <bakkot>
whereas if you `map` or something the expectation is that it either you are exhausting it, which will naturally close the underlying iterator, or closing the `map` helper explicitly

[13:00:03.0787] <Justin Ridgewell>
> <@bakkot:matrix.org> `take` is special in that `take` ends _before_ exhausting the underlying iterator

So does `some`, `every`, and `find`

[13:00:33.0166] <bakkot>
Justin Ridgewell: those don't produce new iterators though

[13:00:37.0297] <rbuckton>
Caveat being that `some`, `every`, and `find` return scalar results

[13:00:42.0904] <bakkot>
they are as it were "consumers" rather than "transfomers"

[13:01:58.0247] <rbuckton>
Though `take` ending before exhausting the iterator is a misconception. The fact it calls `return` is more of an optimization than a meaningful difference when it comes to sequence operators.

[13:02:56.0562] <bakkot>
by "an optimization", do you mean relative to the option of manually exhausting the underlying by calling `.next` repeatedly, or something else?

[13:03:09.0091] <rbuckton>
Yes.

[13:03:41.0995] <rbuckton>
If JS had no `.return` and the only way to close an iterator were to exhaust it, I would expect `take` to exhaust the iterator.

[13:04:14.0735] <rbuckton>
So its good that `return` exists, as it allows us to short-circuit such an expensive operation.

[13:05:10.0505] <rbuckton>
But I'm pretty sure that in every example of prior art in the ecosystem, where `take` is used it means "take X items and exhaust/close the underlying iterator"

[13:05:35.0432] <rbuckton>
If the iterator were a database, I would expect `take` to close the connection when completed. 

[13:05:42.0070] <rbuckton>
 * If the iterator were backed by a database, I would expect `take` to close the connection when completed.

[13:05:55.0389] <rbuckton>
The alternative is resource starvation, which is a bad failure state.

[13:06:41.0972] <rbuckton>
If you want "consume X and not close", that operation is normally named something like `read` (at least, where IO is concerned)

[13:10:50.0479] <ljharb>
erights: i finished the iterator helpers "close the underlying iterator" change before lunch, and it passes all the proposed test262 tests as well as my own

[13:13:24.0852] <Rob Palmer>
We are bringing forward  Async Explicit Resource Management to happen this afternoon.  TCQ and draft schedule are updated accordinlgly.

[13:15:38.0745] <Richard Gibson>
rbuckton: isn't your claim about taking more uncommon directly contradicting by the issue that prompted this discussion?

[13:15:47.0087] <Richard Gibson>
 * rbuckton: isn't your claim about taking more being uncommon directly contradicting by the issue that prompted this discussion?

[13:15:54.0997] <Richard Gibson>
 * rbuckton: isn't your claim about taking more being uncommon directly contradicted by the issue that prompted this discussion?

[13:16:54.0435] <rbuckton>
My impression is that the use case in that issue was a misuse of the API. Perhaps `take` may seem confusing in a vacuum, but not with adequate context

[13:19:18.0829] <littledan>
Why is it "Speaker's summary of key points" rather than "summary of key points" in the notes?

[13:19:25.0606] <Luca Casonato>
Didn't get to it due to time, but there is precedence for a `preventClose`/`preventReturn` option on the web: `preventClose` on `ReadableStream.prototype.pipeTo` and `ReadableStream.prototype.pipeThrough`. I am not necessarily in favour of adding that - but if we did, people may already be familiar with the opt out behaviour.

[13:19:32.0976] <littledan>
> <@littledan:matrix.org> Why is it "Speaker's summary of key points" rather than "summary of key points" in the notes?

I haven't really been seeing speakers fill this in; I think note-takers and the committee could fill it in as well

[13:21:25.0270] <Rob Palmer>
It can be written by anyone so please change the title if you like.  The key is that the presenter ought to be at least approving the summary so that we have some kind of responsibility when distributing the load of writing these summaries.

[13:21:49.0589] <rbuckton>
The confusion is a consequence of choosing to build an API that is dependent on `Iterator` vs the notion of an iterable. As I understood it as the proposal was advancing, basing this on `iterator` meant we were in the realm of "one shot" or "single use" iterators, and that any kind of reusable iteration would rely on arrow functions. IIRC, all of the helper methods are exhaustive, either through repeated calls to `.next` or through the use of `.return`. I don't believe `.take` should be substantially different in this regard. I would much rather have an "opt-out" mechanism to avoid closing an iterator than breaking from the norm here.

[13:24:19.0903] <bakkot>
Definitely agreed that `take` not exhausting is not an option

[13:24:32.0268] <bakkot>
the question was just whether a different name could lead people to correctly intuit the semantics

[13:25:11.0716] <shu>
my intuition is no, unless the name is literally, like `takeAndThenClose`

[13:32:43.0097] <rbuckton>
The alternative, `.limit`, only really makes sense for numeric arguments. It becomes much less clear if you later adopt something like `.limitWhile` (vs. `.takeWhile`). 

[13:33:56.0964] <bakkot>
fun fact, Java has both `limit` and `takeWhile`

[13:34:01.0171] <bakkot>
(and no `take`)

[13:36:27.0529] <apaprocki>
64+32 Abseil: https://github.com/abseil/abseil-cpp/blob/master/absl/time/duration.cc#L15-L50

[13:37:43.0324] <rbuckton>
> <@lucacasonato:matrix.org> Didn't get to it due to time, but there is precedence for a `preventClose`/`preventReturn` option on the web: `preventClose` on `ReadableStream.prototype.pipeTo` and `ReadableStream.prototype.pipeThrough`. I am not necessarily in favour of adding that - but if we did, people may already be familiar with the opt out behaviour.

I know that NodeJS has that concept, i.e.`stream.pipeline(streams, { end: true })` https://nodejs.org/dist/latest-v19.x/docs/api/stream.html#streampipelinestreams-options

[13:38:29.0202] <rbuckton>
and `readable.pipe(dest, { end: true })`. I'm not sure about the DOM APIs offhand

[13:39:17.0292] <Luca Casonato>
for DOM it'd be `readable.pipeTo(writable,  { preventClose: true })`

[13:39:47.0175] <rbuckton>
Yeah, I misread your comment as a question, sorry.

[13:49:37.0810] <shu>
waldemar: the core confusion from me is why do you trust multiple implementations to be correct and interoperable here, if you don't trust the spec to be correct (because it's so tricky to get correct)?

[13:49:51.0898] <shu>
like my goal isn't _just_ a correct document, it's correct interopable implementations

[13:52:12.0744] <waldemar>
shu: It sounds like you're trying to fit the spec around one possible (and pretty problematic) implementation. The spec should be implementation-agnostic about internal details.

[13:53:05.0309] <shu>
in this case my understanding is that the bounds the champions are working to put in place are precisely so that it _is_ implementable with that technique

[13:53:07.0106] <waldemar>
I'm also more interested in the ns vs ¬µs question.

[13:53:15.0568] <shu>
(also why is the 64+32 impl problematic?)

[13:54:26.0790] <littledan>
> <@waldemarh:matrix.org> I'm also more interested in the ns vs ¬µs question.

I know that ptomato framed this as "for future discussion" but I don't see any arguments to switch to microseconds at this point.

[13:54:37.0744] <waldemar>
Elementary math: 64+32 can implement integral counts of subseconds. This is obvious.

[13:55:20.0924] <shu>
well, V8's position is still pro microseconds, but we won't block the proposal on it if implementation complexities and bad performance cliffs are addressed

[13:55:27.0356] <waldemar>
Not obvious: spec that explicitly manages two integers implements integral counts of subseconds. It's easy to get carries and overflows wrong, and you can't tell without examining the entire spec.

[13:55:55.0814] <shu>
i agree with you

[13:56:13.0093] <shu>
what i don't get is, why do you think that trickiness is best left for implementations to all figure out via implication?

[13:56:24.0591] <waldemar>
If you just want ¬µs, then you can store durations in flat 64-bit integers and get a much more efficient implementation with a range of >500,000 years.

[13:56:46.0855] <shu>
indeed! *i* just want us

[13:56:56.0920] <shu>
but v8 has not been able to convince the champion group

[13:57:38.0077] <littledan>
> <@waldemarh:matrix.org> If you just want ¬µs, then you can store durations in flat 64-bit integers and get a much more efficient implementation with a range of >500,000 years.

Do we have any information that this difference in performance will be signficant? there's so much other stuff going on anyway

[13:58:05.0253] <shu>
it's a nuanced conversation that's hard to tease apart

[13:58:26.0047] <shu>
it's not just absolute performance, it's the complexity around supporting optimized paths also

[13:58:29.0671] <shu>
it's philosophical objection

[13:58:51.0766] <waldemar>
Whether a difference in performance is significant depends on who is writing the benchmark ‚ò∫

[13:59:09.0649] <shu>
apaprocki has given examples of other systems that support ns that temporal might want to interface with, which i don't really get at all

[13:59:21.0573] <apaprocki>
ns are common enough nowadays that it seems it would be limiting use cases unnecessarily by limiting to ¬µs, e.g. node embeds v8 and would hopefully like to represent filesystem times without losing precision 

[13:59:25.0919] <shu>
those other systems don't have ns as part of a date-time arithmetic library, they're raw ns counts

[13:59:31.0145] <shu>
they're int64s

[13:59:57.0154] <shu>
what i'm saying is it doesn't follow "ns are common enough -> ns need ot be supported in a fully featured date-time arithmetic library" 

[14:00:08.0297] <shu>
you still can just put the raw ns count into a BigInt

[14:02:34.0445] <shu>
V8 position is:

- ideal: us precision, simple bounded arithmetic + storage follows straightforwardly
- can live with: ns precision, with 64+32 being a tried-and-proven implementation technique from e.g. abseil that we can use
- cannot live with: ns precision, bigint math required

[14:02:47.0123] <apaprocki>
> <@shuyuguo:matrix.org> what i'm saying is it doesn't follow "ns are common enough -> ns need ot be supported in a fully featured date-time arithmetic library"

well, take filesystem times.. certainly those are displayed on screens as formatted date times and not counts

[14:02:59.0803] <shu>
great, it's fine to format them

[14:03:12.0989] <shu>
you need to do full arithmetic to ns precision?

[14:03:18.0717] <shu>
how is that useful?

[14:06:25.0107] <littledan>
> <@shuyuguo:matrix.org> you need to do full arithmetic to ns precision?

I haven't found this as a hard requirement for us when I talked to the relevant groups (except for certain algorithms like PTP which we probably wouldn't end up porting to JS)

[14:06:35.0169] <littledan>
> <@shuyuguo:matrix.org> you need to do full arithmetic to ns precision?

 * I haven't found this as a hard requirement for us when I talked to the relevant groups inside of Bloomberg (except for certain algorithms like PTP which we probably wouldn't end up porting to JS)

[14:08:51.0733] <apaprocki>
there are certain feeds of information where the individual events are represented in ns precision and series of events could be displayed as offsets from an initial event (in essence, durations from an arbitrary epoch rather than UTC epoch)

[14:10:00.0699] <littledan>
> <@shuyuguo:matrix.org> what i'm saying is it doesn't follow "ns are common enough -> ns need ot be supported in a fully featured date-time arithmetic library"

I think using ns would create somewhat of a risk, that Temporal might become obsolete (which is a surprising choice given how much else we decided to be super future-proof for). It's sort of clear that we don't really need to go more precise than ns.

[14:10:54.0630] <littledan>
(and a later evolution here would be really bad, given compat/interop risks)

[14:12:25.0663] <littledan>
> <@shuyuguo:matrix.org> what i'm saying is it doesn't follow "ns are common enough -> ns need ot be supported in a fully featured date-time arithmetic library"

 * I think using us would create somewhat of a risk, that Temporal might become obsolete (which is a surprising choice given how much else we decided to be super future-proof for). It's sort of clear that we don't really need to go more precise than ns.

[14:12:29.0713] <littledan>
yes (edited)

[14:15:43.0565] <littledan>
Good news everyone: The transcriptionist might be available for tomorrow!

[14:15:52.0285] <littledan>
(they got back to me by email)

[14:28:00.0963] <bakkot>
this isn't worth bringing up, but `await` is not reserved in strict mode, only in module code and async functions

[14:28:42.0649] <Michael Ficarra>
very very few people are aware of syntax being dependent on the start symbol

[14:29:36.0312] <ljharb>
bakkot: perhaps we should have `Set.prototype.sort` if the sort order is important?

[14:30:06.0717] <Michael Ficarra>
if you're going to explicitly manage the sort order, put it in an explicitly ordered container

[14:30:08.0011] <bakkot>
the problem is that when I care about the order it's because I care about insertion order specifically

[14:30:15.0760] <bakkot>
and you can't sort it into "insertion order"

[14:32:31.0826] <ljharb>
ah true, hm

[14:35:05.0259] <Michael Ficarra>
I know we don't have much else to go on, but I feel like we're taking these poll results way too seriously

[14:35:24.0998] <bakkot>
right now we're just hearing what they are

[14:35:38.0876] <bakkot>
no one has expressed anything about what to do with them

[14:41:29.0362] <Michael Ficarra>
for await has always felt like an awkward piece of syntax to me, though

[14:41:55.0097] <Michael Ficarra>
like I don't know if we should be using it to guide future syntax choices

[14:44:04.0128] <bakkot>
tbf if we're just picking something because we have to pick something, "difficulty of parsing" is a fine reason to choose - I just wouldn't want "difficulty of parsing" to prevent us from picking a thing we do all think is best

[14:44:46.0829] <littledan>
> <@michaelficarra:matrix.org> for await has always felt like an awkward piece of syntax to me, though

huh? it seems intuitive to me

[14:46:48.0421] <justinfagnani>
as a code reader, I kind of want a syntactic note on the block that it may await at the end, not just on individual statements in the block

[14:46:57.0596] <justinfagnani>
like `async` on a function

[14:48:33.0530] <Rob Palmer>
justin, is this just syntax shock?  I fully have the same initial reaction as you.  I just recall many times when my initial reaction is later overcome once it goes into the language and you get used to it

[14:49:10.0295] <shu>
that's not much of an argument though, because you can make that about literally syntax we choose?

[14:49:10.0331] <justinfagnani>
could be?

[14:49:14.0119] <shu>
"you'll get used to it"

[14:49:22.0426] <shu>
 * that's not much of an argument though, because you can make that about literally any syntax we choose?

[14:49:26.0480] <Rob Palmer>
That could be the JS motto.

[14:50:12.0880] <bakkot>
justinfagnani: yeah the original design was more like python's `with` or java's `try-with-resources`, which has that 

[14:50:21.0966] <bakkot>
but we ultimately decided not that

[14:50:29.0099] <justinfagnani>
Would something like:
```
async {
   await using x = y;
   foo();
}
```
make it more clear that the block may yield at the end?

[14:50:33.0891] <justinfagnani>
bakkot: ok

[14:50:37.0837] <Mathieu Hofman>
FYI, Mark is not active on Matrix

[14:50:46.0510] <rbuckton>
> <@justinfagnani:matrix.org> Would something like:
> ```
> async {
>    await using x = y;
>    foo();
> }
> ```
> make it more clear that the block may yield at the end?

This was something we discussed in depth and resolved in the last meeting

[14:50:55.0721] <justinfagnani>
ok, thanks

[15:05:19.0405] <Chris de Almeida>
so... what just happened?

[15:05:25.0268] <shu>
sorry all didn't mean to make the decision space so complicated

[15:05:31.0549] <littledan>
no this was good

[15:05:45.0358] <littledan>
please read the summary at the bottom of the notes page and edit it or make comments as needed

[15:05:48.0069] <shu>
the only signal i got from the past 10 minutes is, the consensus was not just "we can all live with await using" but in fact "we are now convinced `await using` is the ideal, if achieveable"

[15:05:53.0298] <shu>
which is a good signal

[15:05:57.0943] <shu>
and backs up coming back next meeting

[15:06:00.0607] <rbuckton>
Having a block-level indicator was the issue blocking the async version `using` for the past few years.

[15:06:06.0814] <Chris de Almeida>
> <@littledan:matrix.org> please read the summary at the bottom of the notes page and edit it or make comments as needed

yes -- maybe we should ask for consensus on that summary.. I'm concerned we are not all on the same page

[15:06:14.0876] <Chris de Almeida>
> <@littledan:matrix.org> please read the summary at the bottom of the notes page and edit it or make comments as needed

 * yes -- maybe we should ask for consensus on that summary conclusion.. I'm concerned we are not all on the same page

[15:06:21.0656] <littledan>
> <@shuyuguo:matrix.org> the only signal i got from the past 10 minutes is, the consensus was not just "we can all live with await using" but in fact "we are now convinced `await using` is the ideal, if achieveable"

Yes, I think `await using` has broad support (and this is why I wanted to do a temperature check)

[15:06:29.0154] <littledan>
> <@softwarechris:matrix.org> yes -- maybe we should ask for consensus on that summary conclusion.. I'm concerned we are not all on the same page

could you elaborate?

[15:06:58.0726] <littledan>
(I did ask everyone to review it, but we can come back and project it to force everyone to review it when we come back from the break)

[15:07:33.0412] <shu>
littledan: heh, i still don't like it! but i'm fine with it

[15:08:13.0686] <Chris de Almeida>
what's there atm makes sense to me -- just want to confirm expectations as it seemed we might have been going a different direction for a bit there

[15:21:25.0730] <shu>
i have lost my apartment internet due to what i assume is high winds in SF currently

[15:21:43.0247] <shu>
i don't have good enough cell service to do zoom, so looks like i am out for the remainder of today :/

[15:26:09.0968] <shu>
wait maybe i have enough phone tether to do zoom

[15:26:13.0137] <shu>
it's like 90% packet loss

[15:27:07.0752] <apaprocki>
do you live in a dirigible?

[15:27:45.0497] <shu>
it's called san francisco, thank you

[15:28:38.0743] <sffc>
Frank Tang also said he's been in and out of power/internet

[15:32:32.0318] <littledan>
BTW here are my conclusion notes for the await using topic, please edit in the notes if you want to make changes:

### Summary
Various grammars for async resource disposal were considered, including results from polls. The champion's preference became `await using`, and several delegates were swayed to prefer this option based on the data and arguments presented.
There are concerns about the parse-ability of `await using`, both based on practical implementations and the fit into the ES spec's cover grammars; it's unclear if certain edge cases will be easy to manage.
If `await using` isn't viable, it's likely that `async using` isn't viable, and the committee may come back to the conclusion of `using await`, but this will need to come back to plenary for future discussion.

### Conclusion

The committee resolves to attempt the syntax `await using`.
The grammar will need to be worked out in a PR, which will need to be presented in a future plenary for review and consensus.


[15:44:10.0244] <shu>
i am triggered about static private semantics

[15:44:39.0478] <Chris de Almeida>
same

[15:44:54.0817] <bakkot>
static private semantics are actually fine

[15:45:12.0691] <bakkot>
the problem is that `class extends` implies inheritance not just of instances but of _the constructors themselves_, which is wack

[15:46:15.0692] <littledan>
> <@bakkot:matrix.org> the problem is that `class extends` implies inheritance not just of instances but of _the constructors themselves_, which is wack

I'm like 80% sure I agree. Constructor inheritance is definitely used.

[15:46:57.0635] <bakkot>
yeah I use it myself

[15:47:37.0798] <bakkot>
but it should never have existed, it gives us the wild things like `Promise.resolve` not working unless bound (whereas `Array.from` does, for... reasons)

[15:54:51.0113] <Michael Ficarra>
we *really* need to figure out a more appropriate organisational scheme for well-known symbols than putting them all on Symbol

[15:55:34.0964] <Michael Ficarra>
I don't blame this proposal author for this choice, since we don't have committee guidance on the topic

[15:56:31.0438] <littledan>
> <@michaelficarra:matrix.org> we *really* need to figure out a more appropriate organisational scheme for well-known symbols than putting them all on Symbol

I don't really see the same issue; it's just a single namespace for these things, just like if we had called it `__metadata__`

[15:58:08.0598] <Michael Ficarra>
littledan: yes, a single global namespace for everything is bad, whether that is globalThis or Symbol

[15:58:34.0798] <danielrosenwasser>
Hey all, Ron (rbuckton ) and I will be requesting a new agenda item this Thursday which will propose the preferred `await using` syntax for the [Async Explicit Resource Management proposal](https://github.com/tc39/proposal-async-explicit-resource-management). We're currently working on the grammar, but will let everyone know when the slides and changes are ready to review.

[15:58:35.0874] <Michael Ficarra>
ironically, that opinion is also on-topic for this topic

[15:59:23.0557] <shu>
i don't think a single global namespace is bad

[16:00:01.0605] <shu>
i think it's only ex ante bad but is mostly ok

[16:01:07.0925] <Chris de Almeida>
`var doNotPolluteTheGlobalNamespace = {};`

[16:02:35.0315] <littledan>
Option 3 feels the most bizarre to me, since the intended usage of it needs to go back to the single namespace anyway

[16:02:46.0538] <Michael Ficarra>
shu: surely with time, we will have more than 1 built-in protocol that want to use the same simple name for one of their provided/required fields

[16:03:30.0038] <shu>
that's why i said ex ante bad

[16:03:41.0897] <Michael Ficarra>
none of these well-known symbols have particularly unique simple names

[16:03:44.0980] <shu>
my point is that when we come to that bridge it's usually not a big deal to work around

[16:04:25.0565] <Michael Ficarra>
shu: fair, though it would be nice to set a precedent for userland protocols, especially if we ever have a world with first-class protocols

[16:06:23.0343] <Ashley Claymore>
which class does the metadata get added to? If there was a class decorator which returns a new class, does that get it, or should it have to make sure it 'forwards' on `Symbol.metadata' ?

[16:06:59.0574] <rbuckton>
The final class

[16:07:22.0430] <rbuckton>
(I think)

[16:07:45.0685] <Ashley Claymore>
so might not work if the decorator freezes the class

[16:07:47.0189] <Ashley Claymore>
 * so might not work if the decorator freezes the class?

[16:07:54.0096] <rbuckton>
A _good_ class decorator that performs replacement should either subclass with `extends`, unless it is doing something very complex.

[16:09:06.0150] <ljharb>
either, or what?

[16:09:42.0764] <rbuckton>
 * A _good_ class decorator that performs replacement should either subclass with `extends`, or use `.setPrototypeOf` to emulate that approach, unless it is doing something very complex.

[16:10:34.0688] <Ashley Claymore>
so `Symbol.metadata` would already be there on the class that is being decorated? Rather than added to the final class?

[16:11:04.0438] <rbuckton>
I'd have to recheck the spec

[16:13:52.0835] <shu>
i'm confused about kevin's use case

[16:14:29.0049] <bakkot>
two libraries which both want to use the key `type`

[16:14:38.0539] <bakkot>
including possibly two major versions of the same library

[16:14:46.0128] <bakkot>
you fundamentally cannot use these things at the same time

[16:15:01.0597] <bakkot>
because it's a shared global namespace

[16:15:07.0828] <shu>
is he saying programs will want multiple versions of the same decorator library in the same running app...?

[16:15:34.0624] <bakkot>
multiple versions of a library in the same app is a thing which happens constantly

[16:16:32.0796] <Luca Casonato>
rbuckton: if you want a shared global namespace in scripts, use `globalThis`? why do we need to add a second global namespace? if you really want a global namespace, there already is one already

[16:17:04.0918] <littledan>
> <@bakkot:matrix.org> multiple versions of a library in the same app is a thing which happens constantly

right, I guess the question is: are we more likely to want them to share or partition the namespace? I think share is more pragmatic, given the cases we've heard about. What's more likely to work in practice?

[16:17:20.0627] <shu>
but... why is the app use two major versions of the same library in the same app? that happens?

[16:17:28.0176] <bakkot>
that happens constantly

[16:17:32.0622] <bakkot>
littledan: they can't share

[16:17:38.0673] <rbuckton>
> <@lucacasonato:matrix.org> rbuckton: if you want a shared global namespace in scripts, use `globalThis`? why do we need to add a second global namespace? if you really want a global namespace, there already is one already

That is essentially what `reflect-metadata` does, and one of the things we have sorely wanted to address with this proposal.

[16:17:39.0422] <bakkot>
like, that's the problem

[16:17:41.0650] <bakkot>
they ause the same key

[16:17:44.0692] <bakkot>
 * they use the same key

[16:17:47.0678] <shu>
it happens constantly?

[16:17:51.0130] <rbuckton>
We cannot mutate `globalThis` in a locked down environment like SES

[16:17:51.0819] <bakkot>
and coordinating it becomes the consumer's problem

[16:17:53.0381] <Jesse (TC39)>
the various layers of dependency hell

[16:18:27.0879] <littledan>
> <@bakkot:matrix.org> littledan: they can't share

I don't see why this is such an absolute, rather than pragmatic, thing

[16:18:32.0126] <shu>
okay i think i'm getting the picture. currently the builders do some kind of deduplication / versioning at the build step for regular import/exports

[16:18:36.0226] <rbuckton>
Also, `[Symbol.metadata]` isn't necessarily a "global namespace" any more than a static property on the class is a global namespace. Because the `[Symbol.metadata]` property _is_ a static property on a class.

[16:19:06.0979] <bakkot>
rbuckton: right, class fields are also a shared namespace, which is why string-named mixins was not a viable proposal

[16:19:51.0818] <littledan>
> <@bakkot:matrix.org> rbuckton: right, class fields are also a shared namespace, which is why string-named mixins was not a viable proposal

Symbol-named protocols are also not beyond Stage 1; I still like string-named mixing.

[16:20:01.0209] <rbuckton>
There's a difference between "shared namespace" and "global namespace" though. The 2nd term has more implications

[16:20:02.0006] <littledan>
> <@bakkot:matrix.org> rbuckton: right, class fields are also a shared namespace, which is why string-named mixins was not a viable proposal

 * Symbol-named protocols are also not beyond Stage 1; I still like string-named mixing.

[16:20:08.0593] <littledan>
 * Symbol-named protocols are also not beyond Stage 1; I still like string-named mixins.

[16:20:25.0140] <bakkot>
the names of all fields used in all decorators anywhere must be unique

[16:20:26.0501] <bakkot>
that's global

[16:20:37.0160] <rbuckton>
I want a mutable object _because_ I don't want a shared _global_ namespace.

[16:21:03.0959] <rbuckton>
The alternative to use `globalThis` mandates I do the worse thing

[16:21:13.0143] <bakkot>
rbuckton: but only you

[16:21:14.0723] <Michael Ficarra>
"be careful" assumes that all parties are coordinating, but in reality, pages and applications are often composed of many non-coordinating scripts

[16:21:20.0904] <bakkot>
I am OK with only typescript having to do the worse thing

[16:21:29.0099] <bakkot>
as long as everyone else falls into the happy path of the right thing

[16:21:41.0951] <rbuckton>
Its not only typescript, its every typescript user.

[16:22:10.0865] <ljharb>
TS users presumably would only use an interface TS provides

[16:22:12.0729] <ljharb>
 * TS users presumably would only use an interface TS provides?

[16:22:14.0185] <littledan>
> <@michaelficarra:matrix.org> "be careful" assumes that all parties are coordinating, but in reality, pages and applications are often composed of many non-coordinating scripts

You only have to worry about the set of decorators that a particular class uses.

[16:22:42.0743] <ljharb>
 * TS users presumably would only use an interface TS provides, regardless of which option was chosen?

[16:23:12.0423] <Michael Ficarra>
littledan: and are those decorators always created by a single party or by coordinating parties? I doubt it

[16:23:36.0238] <nicolo-ribaudo>
> <@littledan:matrix.org> You only have to worry about the set of decorators that a particular class uses.

Decorators from different libraries can usually be mixed, so the decorator author doesn't really know what this set is

[16:24:06.0689] <littledan>
> <@nicolo-ribaudo:matrix.org> Decorators from different libraries can usually be mixed, so the decorator author doesn't really know what this set is

I don't think this is really true with framework decorators

[16:24:27.0156] <Michael Ficarra>
littledan: "not true for some cases" is not the bar we're trying to meet here

[16:24:42.0984] <bakkot>
ljharb: re: your queue item, the only reason I suggested a frozen object instead of a symbol is that a frozen object lets you get to the parent metadata

[16:25:53.0459] <ljharb>
makes sense, thanks

[16:27:23.0920] <rbuckton>
`Symbol.for("foo")` isn't much better than `"foo"`

[16:27:32.0974] <bakkot>
I didn't mention this, but the other downside of option 1 is that it is public-by-default, which is... very bad

[16:27:47.0005] <bakkot>
you can remember to be disciplined about it but people will not remember

[16:27:50.0497] <littledan>
> <@bakkot:matrix.org> I didn't mention this, but the other downside of option 1 is that it is public-by-default, which is... very bad

It's not anything by default; it's just as easy to use the WeakMap with it

[16:27:55.0515] <bakkot>
no it isn't

[16:27:56.0570] <rbuckton>
> <@bakkot:matrix.org> I didn't mention this, but the other downside of option 1 is that it is public-by-default, which is... very bad

There is no default. Its purely based on usage. 

[16:28:08.0037] <bakkot>
it is not as a easy to use a weakmap as it is to use a string-named property

[16:28:29.0434] <rbuckton>
But option 2 has the same level of difficulty with weakmaps

[16:28:54.0704] <bakkot>
yes but that's the only way to use it, so that's fine

[16:29:05.0551] <bakkot>
like, as a practical matter, people are going to use public string-named properties with option 1, even when they don't intend to make a public API

[16:29:08.0483] <bakkot>
that is what is going to happen

[16:29:18.0673] <bakkot>
that is what "public-by-default" means

[16:31:01.0734] <rbuckton>
That is more about documentation and learning than it is about capability. If you tell folks, use `WeakMap` or `Symbol`, if you're concerned about collisions, but strings or `Symbol.for` if you're not. Library authors will almost certainly avoid collisions, end user applications often won't need to.

[16:31:19.0821] <rbuckton>
 * That is more about documentation and learning than it is about capability. If you tell folks, use `WeakMap` or `Symbol` if you're concerned about collisions, but strings or `Symbol.for` if you're not. Library authors will almost certainly avoid collisions, end user applications often won't need to.

[16:31:49.0277] <bakkot>
You have a lot more faith in the power of documentation to shape what happens than I do

[16:31:55.0554] <bakkot>
for that matter you also have more faith in the power to shape documentation

[16:31:56.0810] <rbuckton>
Assignments to `context.metadata` will never be so symbol as `context.metadata["a"] = b` anyways

[16:32:08.0603] <littledan>
I really appreciate you being flexible here, bakkot ljharb Michael Ficarra . It's great that we're able to move forward and not have a big gap of metadata-less decorators

[16:32:10.0699] <rbuckton>
 * Assignments to `context.metadata` will never be so simple as `context.metadata["a"] = b` anyways

[16:32:42.0373] <rbuckton>
`context.metadata` is just an object. If you need to differentiate between a class, or a method, or a field you still have more work to do to avoid collisions, even in the `WeakMap` case.

[16:32:49.0981] <Justin Ridgewell>
Is the `context` object (not the `context.metadata` obj) consistent between all decorator invocations on a particular class?

[16:32:57.0366] <Justin Ridgewell>
Or is it a new object for every invocation?

[16:33:09.0032] <rbuckton>
Same object for every decorator on a single class

[16:33:21.0683] <rbuckton>
including the methods and fields.

[16:34:03.0250] <Justin Ridgewell>
If we had chosen Option 2 here, would there even have been a need for `context.metadataKey` at all?

[16:34:15.0750] <Justin Ridgewell>
We could have just keyed the `WeakMap` on `context`

[16:34:18.0484] <rbuckton>
```js
@((_, ctx) => { ctx.metadata["a"] = 1; })
class C {
  @((_, ctx) => { ctx.metadata["b"] = 2; })
  method() {}
}
```
produces a single object with `{ a: 1, b: 2 }`

[16:34:23.0439] <bakkot>
yeah you need it to be available after decoration time

[16:34:29.0746] <bakkot>
and you don't want to share the `context` object

[16:34:36.0275] <bakkot>
which has a bunch of decorator-time-only stuff on it

[16:34:42.0972] <Justin Ridgewell>
Ah, ok

[16:34:45.0017] <rbuckton>
sorry, I misread.

[16:34:51.0692] <rbuckton>
`context` is not shared, only metadata is.

[16:35:10.0461] <rbuckton>
 * sorry, I misread (despite your clarification).


2023-03-22
[08:58:27.0741] <Rob Palmer>
Good morning, all.  Plenary begins in one hour.

[09:27:16.0857] <rbuckton>
For those interested, I have two draft PRs up that illustrate the potential cover grammars for `await using` and `async using`:
- `await using`: https://github.com/tc39/proposal-async-explicit-resource-management/pull/15
- `async using`: https://github.com/tc39/proposal-async-explicit-resource-management/pull/16

[10:18:36.0107] <yulia>
slides for the awkwardly done election (sorry about that y'all) https://docs.google.com/presentation/d/1xQ7huTJQsbcfFM6nhN7Tk3uBUf3h7FHkroM1m56ueZE/edit#slide=id.g6e7d7a6a09_0_98

[10:20:15.0551] <ptomato>
I thought it was fine, I had no problem with the process, personally

[10:21:45.0300] <yulia>
ah nice, i like source as a keyword

[10:22:10.0487] <Michael Ficarra>
I already love this presentation

[10:34:05.0592] <Justin Ridgewell>
Wait, he said "next slide" right?

[10:34:14.0416] <Justin Ridgewell>
I'm still seeing "Import phase syntax" slide

[10:34:37.0723] <Chris de Almeida>
we're on spec: ordering of fetches slide

[10:34:50.0522] <Chris de Almeida>
now on spec: idempotence is unchanged

[10:35:05.0291] <Chris de Almeida>
https://docs.google.com/presentation/d/1F62Jia5erIm6m6nqkm_2pFIlNLOVF0E4ewrVRytSJEs/edit

[10:48:31.0390] <Michael Ficarra>
this seems like a thing that we, as language designers, would notice and/or care about, but users of the language don't want to care about this distinction or have to pass around an awkward intermediate opaque value because of it

[10:49:30.0448] <ryzokuken>
feature request: import/export queue as YAML

[10:49:57.0964] <Jack Works>
some though:
```js
import source wasm from './x.wasm'
// and
import wasm from './x.wasm'
```

both give us reference to undeniable host objects.

[10:50:37.0451] <Michael Ficarra>
I mean that depends on the embedder, right?

[10:51:21.0377] <Michael Ficarra>
the embedder could add hooks for denying that, surely

[10:51:22.0347] <Jack Works>
yes. since it already happens today, IMO we no need to care about deniability in this syntax.

[11:08:42.0875] <Andreu Botella>
Wait, so `import x from "test"` and `import x from "test" with {}` would have different cache keys?

[11:08:53.0542] <littledan>
in that case, no

[11:09:22.0937] <littledan>
keep in mind, it's not that all attributes result in a differing cache key at the host level, they might be normalized just like relative paths

[11:10:10.0803] <Andreu Botella>
slide https://docs.google.com/presentation/d/1Abdr54Iflz_4sah2_yX2qS3K09qDJGV84qIZ6pHAqIk/edit#slide=id.g216c73c7b74_0_35 seems to suggest the cache key for the former would be `#["test", null]` and the latter would be `#["test", #{}]`

[11:12:56.0482] <yulia>
erm, ok. i have maybe a solution to what mark is asking

[11:12:59.0212] <yulia>
i have a slide deck

[11:13:06.0254] <yulia>
but it wasn't totally ready

[11:13:57.0576] <yulia>
I will probably do it as a blog post after i've had a chance to talk to the other modules folks

[11:13:57.0590] <Andreu Botella>
oh, I just checked the spec and it is actually the same cache key, my bad

[11:14:06.0152] <Andreu Botella>
 * oh, I just checked the proposed spec text and it is actually the same cache key, my bad

[11:14:19.0782] <yulia>
here is the deck: https://docs.google.com/presentation/d/1YDFyEj8SxbWXhtPBVjyoSOVnaeydnZ_lexmd-LLgO4U/edit#slide=id.p

[11:14:42.0867] <yulia>
its out of date, please don't take it as anything concrete

[11:15:45.0636] <yulia>
I took it off the agenda because it wasn't concrete but i can talk about it briefly

[11:15:59.0682] <littledan>
I'd encourage you to add this to the agenda as well as the queue

[11:16:25.0802] <Michael Ficarra>
I think Mark was probably just unaware of the coordination already happening between the module proposal authors

[11:16:28.0384] <Rob Palmer>
I've been impressed with how much coordination and participation has gone into the various modules proposals

[11:18:37.0220] <Jesse (TC39)>
OT yulia presented some stuff about this module work (including layering/process improcements) at BOBKonf 2023 just last week (great talk!) https://bobkonf.de/2023/startsev.html

[11:18:56.0513] <yulia>
its very out of date already

[11:19:12.0637] <Jesse (TC39)>
in one week? JS moves faster than I thought!

[11:19:29.0874] <yulia>
yes, i have the wrong names already, probably because i was writing the talk a couple of months ago

[11:19:33.0823] <littledan>
I think it'd be much better to discuss this internally in TC39, even if very very unfinished, before you leave (and maybe this will feed into the blog post, even)

[11:19:58.0920] <littledan>
the bar for something we're discussing just internally should be logically lower than what goes into a public-facing blog post

[11:22:41.0313] <yulia>
my view on layering doesn't need to be adopted, its just my thinking

[11:22:51.0184] <ljharb>
littledan: afaik node already decided to reflag

[11:23:03.0027] <yulia>
and blocking that from going public is something i am against because i have reasons for my opinions even if tc39 disagrees

[11:23:05.0115] <bakkot>
honestly the slow path seems totally fine as long as we update docs and stuff?

[11:23:12.0763] <littledan>
> <@ljharb:matrix.org> littledan: afaik node already decided to reflag

interesting, I guess they don't need a signal from us?

[11:23:18.0411] <bakkot>
like if no new code uses it, I don't see a problem

[11:23:23.0084] <bakkot>
 * like if no new code uses `assert`, I don't see a problem

[11:23:32.0325] <ljharb>
> <@littledan:matrix.org> interesting, I guess they don't need a signal from us?

they reflagged because they had no signal, and the future of the syntax was uncertain

[11:23:37.0953] <Michael Ficarra>
bakkot: it's a bit scary, you don't want to have adoption of the legacy variant increase

[11:23:47.0299] <Michael Ficarra>
hopefully implementations can warn through some side channel

[11:24:15.0764] <bakkot>
console warning would be good too yeah

[11:24:45.0465] <Michael Ficarra>
console warning only if mtime > March TC39 meeting lol

[11:24:56.0362] <littledan>
> <@ljharb:matrix.org> they reflagged because they had no signal, and the future of the syntax was uncertain

has a release actually gone out with the re-flagging?

[11:25:11.0829] <ljharb>
i don't think so yet

[11:27:14.0268] <eemeli>
Do we have any precedent for a MAY or SHOULD statement on emitting warnings for deprecated syntax?

[11:27:52.0009] <bakkot>
nope

[11:27:57.0053] <Michael Ficarra>
eemeli: we have no jurisdiction there

[11:28:24.0147] <bakkot>
we can give suggestions but like we can also give suggestions to Shu, in words

[11:28:48.0365] <shu>
like yes i am not a generative AI

[11:30:12.0985] <eemeli>
Tbf, I think we're just established that it's not just Chrome.

[11:30:42.0571] <bakkot>
does node ever do warnings? warnings from node can break stuff

[11:30:45.0141] <bakkot>
bundlers could, though

[11:30:56.0719] <bakkot>
I guess it does ever do warnings; I have seen some

[11:31:23.0695] <littledan>
> <@yulia:mozilla.org> and blocking that from going public is something i am against because i have reasons for my opinions even if tc39 disagrees

Sorry I did not mean that I or anyone should block you from doing anything, it just seems like you're hesitant to present something unfinished to us and I was trying to encourage you that it'd be OK to share.

[11:31:25.0485] <eemeli>
At least for flagged features, it does.

[11:32:19.0310] <Michael Ficarra>
doesn't do warnings? I have an UnhandledPromiseRejection for you

[11:32:34.0098] <ljharb>
node def does warnings, and has a caching mechanism so it only shows it to you once per process

[11:32:50.0436] <bakkot>
UnhandledPromiseRejection now crashes the process by default, I think

[11:33:17.0036] <Mathieu Hofman>
Where do I find the slides yulia ?

[11:33:32.0777] <yulia>
https://docs.google.com/presentation/d/1YDFyEj8SxbWXhtPBVjyoSOVnaeydnZ_lexmd-LLgO4U/edit#slide=id.p

[11:33:43.0307] <yulia>
its not that much of an evolution of what we've discussed in the module calls

[11:33:50.0557] <yulia>
you will notice things are on different layers and the layers are named

[11:34:02.0071] <yulia>
its in part in response to my thinking of how the layers can be organized

[11:39:44.0692] <danielrosenwasser>
Are there any annex features that don't run on all major browsers?

[11:39:58.0719] <danielrosenwasser>
(I swear I am not trying to start a fight üòÖ)

[11:40:29.0928] <ryzokuken>
editorial notes could help?

[11:40:57.0268] <shu>
this is a spectacularly unnuanced understanding of the purpose of a specification document

[11:41:14.0172] <nicolo-ribaudo>
> <@danielrosenwasser:matrix.org> Are there any annex features that don't run on all major browsers?

This would not be annex b -- annex b must be implemented by all browsers

[11:41:17.0557] <ryzokuken>
I mean, we could include it with a big banner that says "careful"

[11:41:39.0733] <Jack Works>
> <@nicolo-ribaudo:matrix.org> This would not be annex b -- annex b must be implemented by all browsers

annex b + normative optional üòÇ

[11:41:41.0784] <danielrosenwasser>
ah, I see. I'm just trying to understand better.

[11:42:18.0208] <eemeli>
Annex C, anyone? üòá

[11:42:21.0663] <shu>
it is fine if committee wants the lesson V8 to learn from this is "conformance as a proxy measure for shipping reality becomes even more tenuous"

[11:42:33.0028] <shu>
but that will weak TC39's pull in the future, to be clear

[11:43:08.0941] <ljharb>
i'm confused. why would supporting `assert` syntax make you noncompliant?

[11:43:19.0359] <shu>
 * but that will weaken TC39's pull in the future, to be clear

[11:43:28.0412] <ljharb>
the spec already explicitly allows implementations to go nuts with their own syntax

[11:43:33.0770] <bakkot>
speaking of, I still need to specify the `if (false) f() = 0` syntax...

[11:44:14.0576] <bakkot>
ljharb: I do not think we want implementations to think of themselves as being allowed to go nuts with their own syntax, regardless of whether the spec says they are allowed to

[11:44:14.0969] <ljharb>
i very much wouldn't want to make important implementations noncompliant, but omitting `assert` from the spec doesn't seem like it would cause that.

[11:44:21.0839] <ljharb>
> <@bakkot:matrix.org> ljharb: I do not think we want implementations to think of themselves as being allowed to go nuts with their own syntax, regardless of whether the spec says they are allowed to

very true

[11:44:30.0124] <shu>
it is no skin off my back to start going nuts with syntax

[11:44:30.0360] <littledan>
> <@shuyuguo:matrix.org> it is fine if committee wants the lesson V8 to learn from this is "conformance as a proxy measure for shipping reality becomes even more tenuous"

I don't think V8 should take that lesson; it was clear that the committee largely *does* see the spec reflecting reality as a goal.

[11:44:58.0417] <shu>
but more narrowly, because the spec needs to say `assert` has the same semantics as `with`

[11:44:59.0972] <ljharb>
i see that as a goal as well. but it has a purpose beyond that in that it guides new implementations

[11:45:11.0480] <shu>
that's what the "legacy" box is for

[11:45:18.0118] <shu>
that is literally why that box exists

[11:45:36.0331] <ljharb>
sure. but that's for stuff that all browsers already implement. this one's just chrome

[11:46:13.0338] <bakkot>
`Legacy` is actually "must implement"

[11:46:24.0840] <shu>
sorry, normative optional + legacy

[11:46:27.0848] <bakkot>
but `Legacy` plus `Normative Optional` does the thing yes

[11:46:43.0580] <ljharb>
maybe the solution is to invent a new category that's more strongly worded and implies both legacy and normative optional, i dunno

[11:46:46.0449] <Jack Works>
can we try? maybe the migration isn't that hard considering code using import assertions are new and highly likely in maintaining

[11:46:52.0371] <ryzokuken>
odd sidebar, since I'm curious: is it a possibility to eventually move `Date` to this "legacy" section?

[11:47:01.0749] <ljharb>
 but there is a distinct difference to me between the string HTML methods, and the `assert` syntax

[11:47:06.0639] <littledan>
> <@usharma:igalia.com> odd sidebar, since I'm curious: is it a possibility to eventually move `Date` to this "legacy" section?

no? this is a confusing tangent

[11:47:17.0658] <ryzokuken>
yes, sorry

[11:47:18.0247] <ljharb>
seems very unlikely

[11:47:19.0069] <Andreu Botella>
Legacy + Normative Optional + Pls Do Not Ship If At All Possible

[11:47:51.0606] <Jack Works>
you can mark anything as deprecated if you want, but just don't remove it

[11:49:39.0033] <Jack Works>
wonder the real world use rate in Web of Import assertions

[11:49:44.0665] <Jack Works>
is there any data of it?

[11:49:58.0226] <Jesse (TC39)>
> <@jackworks:matrix.org> wonder the real world use rate in Web of Import assertions

I think yulia might have some data there?

[11:49:59.0958] <HE Shi-Jun>
> <@jackworks:matrix.org> wonder the real world use rate in Web of Import assertions

I believe it's very low

[11:50:16.0020] <yulia>
chrome would be the one with the counters

[11:50:18.0601] <justinfagnani>
it has to be very, very low

[11:50:30.0615] <Jack Works>
> <@jesse:igalia.com> I think yulia might have some data there?

but firefox does not ship it?

[11:50:45.0517] <yulia>
at the moment, no

[11:50:50.0431] <yulia>
we have an implementation but it is unshipped

[11:51:01.0888] <yulia>
safari likewise has it behind a flag

[11:51:18.0096] <ljharb>
it would be a really unfortunate outcome imo if anyone newly ships it unflagged (prior to time + evidence that it's unshakeable web reality)

[11:51:34.0393] <yulia>
i believe assert is most used by tooling, Justin Ridgewell would have the context here

[11:51:38.0045] <ljharb>
and given how new this feature is, it seems entirely achievable for everyone using `assert` to migrate to `with`

[11:52:01.0145] <bakkot>
eventually

[11:52:10.0899] <ljharb>
sure, in the fullness of time. but i think on a reasonably short timescale

[11:52:38.0878] <ljharb>
if every browser, and node/deno, shipped `with` today, i'd expect `assert` to be gone in like a year

[11:52:40.0354] <justinfagnani>
the most likely usage is in v8-only environments: Deno, Node, Electron, etc... but those are versioned and also have breaking changes somewhat regularly

[11:52:42.0218] <ljharb>
 * if every browser, and node/deno, shipped `with` today, i'd expect `assert` to be largely gone in like a year

[11:54:02.0172] <Jack Works>
(IIRC some linux let apps use shared electron so maybe for electron it's not so versioned)

[11:54:06.0850] <justinfagnani>
v8 use counters would need to differentiate web from server (if any server env even contributes to use counters, which I doubt?)

[11:54:21.0411] <ljharb>
p sure use counters are in chrome, not v8?

[11:54:24.0644] <justinfagnani>
ah, counter would be web-only

[11:54:43.0872] <shu>
yeah that use counter infra is chrome only i think

[11:55:01.0558] <bakkot>
node's ability to ever ship breaking changes is great, I love that; I also appreciate that it happens quite rarely these days

[11:55:07.0219] <Jack Works>
does Electron has use counter? ¬†üßê

[11:55:21.0800] <bakkot>
I have not had an issue updating a major version of node since 10->12

[11:55:25.0148] <justinfagnani>
I don't know... seems like some sort of metrics would have been useful from server / desktop environments, but I admit I don't know of any that do

[11:55:46.0831] <shu>
this is just the consequence of our staging and shipping model

[11:55:50.0459] <shu>
you can't have your cake and eat it too

[11:56:04.0567] <shu>
i am not interested in spec purity

[11:56:14.0854] <Jack Works>
> <@bakkot:matrix.org> node's ability to ever ship breaking changes is great, I love that; I also appreciate that it happens quite rarely these days

(Node 18 new SSL provider breaks Webpack 4)

[11:56:52.0314] <bakkot>
fortunately webpack is usually a direct dep rather than a transitive dep, so that's not too bad

[11:58:08.0700] <Jack Works>
if we're interested in spec purity, we won't have IsHTMLDDA today

[11:58:32.0179] <ljharb>
*un*fortunately tho, lots of people can't upgrade to webpack 5 because of its node core module polyfilling change, so unless a fix is backported to v4 lots of people will be stuck

[11:59:35.0884] <Michael Ficarra>
ljharb: I would prefer the committee not give too much editorial direction here. I want to retain discretion to best communicate what we understand the committee's opinion to be here.

[11:59:50.0055] <Jack Works>
that one is easy to migrate. the hard part is webpack plugins and loaders

[12:00:03.0470] <bakkot>
this sounds like "deprecated" to me

[12:00:13.0790] <shu>
also sounds like deprecated to me

[12:00:54.0535] <ljharb>
> <@michaelficarra:matrix.org> ljharb: I would prefer the committee not give too much editorial direction here. I want to retain discretion to best communicate what we understand the committee's opinion to be here.

yeah i'm not trying to dictate editorial wording, just the conveyed intent

[12:01:02.0260] <littledan>
+1 to Jordan's comments about the spec being explicit about the hope to remove it (though I'd note that normative-optional advocates like to think the same thing about those sections)

[12:01:41.0512] <msaboff>
Annex B is evidence that we don't have spec purity.  I'd rather that we don't decrease purity.

[12:02:16.0489] <shu>
that's fair, but the bar for me is "is this true of the world", not "is this a wish we have of the world"

[12:02:22.0833] <shu>
and as i said we can find that out empirically

[12:02:45.0376] <shu>
 * that's fair, but the bar for me for when it's acceptable to decrease purity is "is this true of the world", not "is this a wish we have of the world"

[12:03:21.0458] <bakkot>
I am real curious what the real-world in-browser usage will turn out to be

[12:03:51.0014] <shu>
yeah

[12:03:51.0601] <littledan>
> <@msaboff:matrix.org> Annex B is evidence that we don't have spec purity.  I'd rather that we don't decrease purity.

msaboff: What do you think about the point Shu made of, this committee will have more influence if we are willing to be impure in this way?

[12:04:26.0548] <shu>
corollary: be careful how many times you ask people to unship

[13:03:14.0138] <rbuckton>
For those interested, I have two draft PRs up that illustrate the potential cover grammars for await using and async using:

- await using: https://github.com/tc39/proposal-async-explicit-resource-management/pull/15
- async using: https://github.com/tc39/proposal-async-explicit-resource-management/pull/16

[13:04:21.0577] <rbuckton>
Rendered version of #15: https://tc39.es/proposal-async-explicit-resource-management/pr/15
Rendered version of #16: https://tc39.es/proposal-async-explicit-resource-management/pr/16

[13:04:36.0165] <rbuckton>
 * Rendered version of #15 (`await using`): https://tc39.es/proposal-async-explicit-resource-management/pr/15
Rendered version of #16 (`async using`): https://tc39.es/proposal-async-explicit-resource-management/pr/16

[13:06:29.0983] <rbuckton>
Apologies, I need to step out for a few minutes. I will be back shortly. 

[13:06:52.0342] <msaboff>
ljharb: Where would I find the draft standard for patent opt out review?

[13:07:29.0224] <littledan>
Draft notes for the conclusion for import attributes, please edit the notes if you want to refine anything:

#### Summary
Import attributes are the path forward for the standard, having re-achieved Stage 3.
The keyword is `with`
As previously, there is an options bag following it
The options can form part of the interpretation of the module and "cache key"
Unknown attributes in the import statement cause an error.
Although a couple delegates would prefer sticking with the keyword `assert`, the majority preferred switching to the long-term optimal solution of being more semantically well-aligned using `with`
Significant debate focused around how to communicate the deprecation.

#### Conclusion
`assert` will remain in the specification, marked somehow as "deprecated", with the intention to remove it eventually, though with an anticipated timespan of at least multiple years before final removal.
JS environments which currently ship `assert` are *not* encouraged to remove it, but environments which do not yet ship `assert` are discouraged from shipping it.
Chrome will gather data on usage of `assert` on the web, which can inform the deprecation path.
Conditional consensus for Stage 3 on this proposal, with the conditions:
Reviews are still needed from the reviewers who volunteered ‚Äì JRL and JHD, as well as the editors
The wording for normative optional+legacy needs to be updated to something stronger, probably "deprecated", and explaining the goal to remove it from the specification.


[13:08:26.0040] <ljharb>
> <@msaboff:matrix.org> ljharb: Where would I find the draft standard for patent opt out review?

it hasn't been produced/cut yet, so for now you can look at https://tc39.es/ecma262, but i'll create a github release on the spec repo, and a Reflector issue, and i'll post it in here, when it's prepared

[13:08:49.0994] <shu>
yeah, i think tip-of-tree right now will get tagged

[13:09:37.0218] <msaboff>
> <@shuyuguo:matrix.org> yeah, i think tip-of-tree right now will get tagged

Can you or another editor email me when it is tagged?

[13:10:20.0827] <shu>
sure, let me make a reminder

[13:10:40.0942] <Michael Ficarra>
I would phrase that as: the draft is final, is currently at https://tc39.es/ecma262, but will soon be available at the more stable URL https://tc39.es/ecma262/2023/

[13:12:29.0085] <msaboff>
Michael Ficarra: When do you think the stable URL will be available?

[13:12:48.0389] <bakkot>
I actually did not know until looking at this issue that python's `range` does not allow floats, which I think is indicative of how rarely it comes up (at least in the kind of code I tend to write)

[13:12:53.0191] <bakkot>
 * I actually did not know until looking at this issue that python's `range` does not allow non-integer values, which I think is indicative of how rarely it comes up (at least in the kind of code I tend to write)

[13:13:41.0961] <shu>
were floating point use cases the champion considers compelling presented?

[13:13:44.0012] <msaboff>
Seems like **integer only** makes a lot of sense.

[13:13:59.0801] <shu>
i am not understanding who is advocating for floats

[13:14:04.0644] <shu>
(tab is not here)

[13:14:38.0720] <bakkot>
tab advocated non-integers, hax opposed; we are here to find out what the committee as a whole things

[13:14:50.0035] <bakkot>
more people need to express opinions

[13:14:54.0337] <shu>
but are there use cases?

[13:14:58.0893] <shu>
my intuition is strongly integer only

[13:15:21.0064] <shu>
like... why are you doing 0, 0.3, 0.6, 0.9?

[13:17:52.0948] <rbuckton>
For reference, Python's `range()` doesn't allow floats.

[13:19:02.0001] <shu>
from https://github.com/tc39/proposal-Number.range/issues/64, tab says: "Ranges that include floating-point numbers are perfectly fine and reasonable, and people will want to do them - if we arbitrarily restrict it from this API people will just write their own and be justifiably angry at us for screwing up the API and forcing them to reinvent it themselves."

[13:19:19.0780] <shu>
but... really?

[13:19:33.0678] <bakkot>
I found the linked stackoverflow question about python's range informative: https://stackoverflow.com/questions/477486/how-do-i-use-a-decimal-step-value-for-range

[13:20:49.0109] <shu>
what's your take from that SO question?

[13:20:59.0101] <bakkot>
people aren't mad about it, basically

[13:21:05.0931] <shu>
mine is "if we restrict it, people will ask, and be told how to do it correctly, instead of being mad and also doing it wrong"

[13:21:13.0393] <shu>
okay i think that matches with mine

[13:21:15.0037] <bakkot>
or like, reasonable people can give a good answer to the question that is not just "this is a bug"

[13:21:19.0209] <shu>
right

[13:21:27.0275] <bakkot>
possibly some people are mad about it somewhere but clearly not everyone

[13:21:48.0677] <shu>
i don't know how you can be mad at "hold on now, have you heard about rounding errors"

[13:22:29.0826] <bakkot>
oh I'm mad about that, but in the way that I am mad about entropy, not the way that I am mad about idk strings being utf-16 or whatever

[13:22:49.0320] <Michael Ficarra>
I bet most JS programmers don't even know what a float is, and just treat JS numbers as if they were reals

[13:23:03.0544] <Michael Ficarra>
they don't want to hear about rounding errors

[13:23:18.0831] <bakkot>
well if `range()` doesn't allow floats then they won't have to

[13:23:30.0495] <bakkot>
if they put floats in range then they will have to learn about them

[13:24:26.0086] <eemeli>
I found it interesting that these "fail" in slightly different ways:
```
> for (let i = 0; i < 10; i += 1) console.log(i * 0.1)
0
0.1
0.2
0.30000000000000004
0.4
0.5
0.6000000000000001
0.7000000000000001
0.8
0.9

> for (let i = 0; i < 1; i += 0.1) console.log(i)
0
0.1
0.2
0.30000000000000004
0.4
0.5
0.6
0.7
0.7999999999999999
0.8999999999999999
0.9999999999999999
```

[13:24:32.0305] <bakkot>
(to be clear I'm just repeating things Hax already put in the issue, not finding things myself)

[13:26:51.0887] <bakkot>
ljharb: when we say "disallow floats" everyone means "disallow non-integer numbers"

[13:26:59.0571] <bakkot>
no one is suggesting not allowing integral floats

[13:27:10.0701] <bakkot>
though there is some question about whether to allow numbers above max-safe-int

[13:29:48.0348] <Michael Ficarra>
yes I wish we would stop saying "disallow floats", it is confusing people

[13:33:36.0775] <bakkot>
to be clear, this is also how floats work in python; that's how floats work in every language. but python disallows non-integer floats in `range`, and that's fine

[13:33:45.0654] <bakkot>
so it clearly is a thing that a language can choose to do

[13:34:50.0722] <shu>
no the lack of use cases is specifically about range

[13:34:54.0152] <shu>
not about floating point numbers

[13:35:46.0590] <mpcsh>
Willian Martins your name isn't in the delegates list for the notes ‚Äî is your acronym WMS? https://github.com/tc39/notes/blob/main/delegates.txt

[13:35:55.0329] <mpcsh>
(also please send a PR to add yourself to that at your leisure)

[13:35:57.0306] <Jack Works>
consistency vs foogun prevention

[13:36:06.0378] <Jack Works>
ü•≤

[13:36:14.0103] <Willian Martins>
yes

[13:36:54.0276] <ljharb>
see also, the `this` argument on array methods

[13:37:40.0805] <Michael Ficarra>
I see their name in the notes

[13:41:55.0047] <Justin Ridgewell>
Is the current proposal with add or multiply semantics?

[13:42:52.0408] <ljharb>
multiply iirc

[13:43:11.0445] <Michael Ficarra>
multiply

[13:43:58.0968] <Justin Ridgewell>
` start + (step * currentCount)` perfect

[13:44:06.0826] <Justin Ridgewell>
Had to scan the spec for a min

[14:00:36.0978] <Michael Ficarra>
I agree with Shu's point that we should probably align with wasm on whether they add an f16 for these or they get promoted when they cross to wasm

[14:01:30.0597] <mpcsh>
> <@mpcsh_:matrix.org> Willian Martins your name isn't in the delegates list for the notes ‚Äî is your acronym WMS? https://github.com/tc39/notes/blob/main/delegates.txt

dminor you as well ‚Äî I see DLM in the notes, please add yourself to the list üôÇ

[14:02:04.0224] <Michael Ficarra>
Dan is *also* in the list

[14:02:16.0064] <Michael Ficarra>
mpcsh: I think your search is broken

[14:02:30.0817] <Michael Ficarra>
 * Dan is _also_ in the list already

[14:03:16.0881] <mpcsh>
you're right ‚Äî I don't know how I missed Willian. I searched for "Daniel Minor" though here. I see them both now!

[14:17:09.0092] <Justin Ridgewell>
Someone is being very loud in front of a mic

[14:18:25.0578] <Chris de Almeida>
aggressive clicking

[14:18:29.0621] <Luca Casonato>
Is this still the case Justin Ridgewell?

[14:18:38.0322] <Justin Ridgewell>
No

[14:18:42.0401] <Justin Ridgewell>
Sorry, yes

[14:18:45.0139] <Justin Ridgewell>
Still noisy

[14:18:50.0212] <Luca Casonato>
clicking or keyboard?

[14:18:57.0368] <Chris de Almeida>
both

[14:19:00.0087] <Justin Ridgewell>
Clicking?

[14:19:00.0192] <ljharb>
from the room or the call?

[14:19:06.0108] <Justin Ridgewell>
Also shuffling

[14:19:06.0763] <ljharb>
 * from the room or the call? the room i assume

[14:19:06.0882] <Chris de Almeida>
yes?

[14:19:09.0498] <Michael Ficarra>
I don't hear this noise from the room

[14:19:37.0167] <Rob Palmer>
in the room we do not hear aggressive typing or clicking

[14:19:40.0832] <Chris de Almeida>
good now

[14:20:51.0427] <shu>
isn't that a strawperson

[14:21:28.0681] <shu>
like these arguments are formed like "it's impossible to express now", whereas it's more like "we have to use libraries"?

[14:22:09.0969] <shu>
the last bullet point is about accidental casts which i remember littledan and brendan bringing up years ago

[14:22:30.0372] <shu>
that one seems legit as an argument for language inclusion over library

[14:31:23.0989] <bakkot>
anyone know _why_ IEEE decimal distinguishes between 1.2 and 1.20?

[14:31:45.0941] <Michael Ficarra>
sigfigs?

[14:31:55.0718] <littledan>
like high school science

[14:32:19.0182] <littledan>
> <@bakkot:matrix.org> anyone know _why_ IEEE decimal distinguishes between 1.2 and 1.20?

this page explains at way too much length: https://speleotrove.com/decimal/decifaq.html

[14:32:44.0234] <littledan>
there are many use cases posited there for trailing zeroes. The author of this document was participating in the IEEE process.

[14:32:59.0139] <bakkot>
oh boy

[14:33:16.0166] <littledan>
it is actually a fun and well-written piece

[14:35:22.0298] <Michael Ficarra>
last updated today, wow

[14:35:33.0900] <bakkot>
no it just has some JS that writes the current date

[14:35:37.0802] <bakkot>
I was also confused by that

[14:35:53.0368] <Michael Ficarra>
well that is very weird

[14:36:08.0802] <ljharb>
lol that was a common practice in the late 90s

[14:36:20.0036] <ljharb>
next to a "visit counter"

[14:36:40.0270] <bakkot>
actually it appears to be using `document.lastModified`

[14:36:42.0134] <bakkot>
which, TIL

[14:36:48.0920] <ljharb>
huh

[14:38:30.0256] <Rob Palmer>
Feedback from remote attendees is that the room mic is particularly hot where Jordan and Patrick are sitting. We hear clicks and zipping noises, etc.  Just for awareness.

[14:40:21.0545] <shu>
> <@bakkot:matrix.org> actually it appears to be using `document.lastModified`

wow how does it know? whatever the server says i guess?

[14:41:24.0482] <Michael Ficarra>
shu: I think it only works for local files

[14:41:31.0801] <Michael Ficarra>
maybe it goes off a response header though, I dunno

[14:42:07.0581] <bakkot>
> The Document's source file's last modification date and time must be derived from relevant features of the networking protocols used, e.g. from the value of the HTTP `Last-Modified` header of the document, or from metadata in the file system for local files. If the last modification date and time are not known, the attribute must return the current date and time in the above format.

[14:42:09.0560] <bakkot>
https://html.spec.whatwg.org/multipage/dom.html#dom-document-lastmodified-dev

[14:42:22.0250] <shu>
sick

[14:43:46.0109] <littledan>
My point was going to be: I think the more important reason (than performance) for decimal over rational is, the very core and common operation of rounding makes sense for decimals in a way which is a sort of mismatch for rationals. This is very common in financial calculations, to have well-defined rounding of intermediate values.

[14:44:47.0221] <shu>
+1 to dminor 

[14:45:25.0661] <littledan>
I can understand "it's not motivated enough" or "it's too much work to implement" as counterarguments, but "there is a design space" is a common attribute of just about everything we do in TC39.

[14:46:54.0177] <littledan>
Utility as something built-in here is analogous to something like Temporal--it ends up being useful to have some things built-in sometimes. I think this is about the use cases being persuasive enough, which maybe we haven't shown.

[14:47:13.0710] <shu>
in retrospect Temporal should have been a blessed library

[14:47:13.0711] <littledan>
 * Utility as something built-in here is analogous to something like Temporal--it ends up being useful to have some things built-in sometimes. I think this is about the use cases being persuasive enough to pay for the complexity and implementation cost, which maybe we haven't shown.

[14:47:16.0718] <shu>
(IMO)

[14:47:37.0361] <apaprocki>
we don't have a way to do that though

[14:47:43.0770] <Michael Ficarra>
nah, date/time handling is provided (usually poorly) in almost all std libs

[14:47:47.0801] <apaprocki>
interchange is the thing that kills us by not having a vocabulary type

[14:47:55.0427] <Michael Ficarra>
tzdata is live as well

[14:48:03.0655] <shu>
what is a vocabulary type again

[14:48:31.0271] <apaprocki>
literally every single software product/language that exists has decimal, so making NxM products all flow through JS is burdensome 

[14:48:33.0197] <littledan>
like, if we have something built-in, then all the different libraries know that they can use it. This comes up for Promises, Temporal, Decimal, and more

[14:48:47.0622] <shu>
"vocabulary type" means "built-in"?

[14:49:05.0855] <apaprocki>
vocabulary meaning, a concept of interchange between languages/systems

[14:49:11.0473] <apaprocki>
even within the same language/system

[14:49:14.0586] <shu>
okay

[14:49:25.0403] <apaprocki>
so `double` in C++ / `number` in JS

[14:49:40.0314] <shu>
i will be unequivocal about one thing, which is what i was planning to bring in the queue: V8 is not going to be okay with a new value type

[14:49:54.0901] <littledan>
> <@shuyuguo:matrix.org> i will be unequivocal about one thing, which is what i was planning to bring in the queue: V8 is not going to be okay with a new value type

I would really like to have this conversation in plenary in the overflow time

[14:50:01.0613] <shu>
sure

[14:50:03.0051] <apaprocki>
yes, that was the path that was being suggested

[14:50:09.0889] <apaprocki>
path being (not a value type)

[14:50:11.0399] <shu>
well, waldemar brought up === overloading

[14:50:14.0648] <shu>
which is also not something we want

[14:50:33.0471] <Michael Ficarra>
yes, I disagree with that point made by waldemar

[14:50:47.0670] <littledan>
> <@shuyuguo:matrix.org> well, waldemar brought up === overloading

yeah, this is exactly why I'm looking forward to having a conversation about it together (as opposed to isolated points from individuals)

[14:50:51.0407] <shu>
 * which is also not something V8 wants

[14:51:18.0132] <apaprocki>
if we could scope/timebox an overflow specifically about this, it would really help inform champions

[14:51:47.0446] <apaprocki>
assuming an object w/o overloading is being proposed, what are delegate opinions as to why that would not be acceptable

[14:52:28.0960] <littledan>
> <@apaprocki:matrix.org> assuming an object w/o overloading is being proposed, what are delegate opinions as to why that would not be acceptable

Yeah, I think we could divide the discussion into those two parts (I'd also like to discuss why Waldemar wants overloading, and what others think about this topic)

[14:52:38.0679] <Michael Ficarra>
the timebox was just not big enough, we had a ton more to talk about wrt decimal

[14:53:17.0995] <littledan>
> <@michaelficarra:matrix.org> the timebox was just not big enough, we had a ton more to talk about wrt decimal

Good thing we have tons of slack time this meeting.

[14:54:50.0192] <Rob Palmer>
the slack is being consumed at a fast rate

[14:55:24.0034] <Rob Palmer>
we are down to 25mins remaining

[14:57:06.0144] <rbuckton>
I'll be honest, I'd love something a regex tagged template for `x`-mode, but I'd be more likely to want to bring prefix modifiers back for something like:
```js
const re = RegExp`(?x)
# comments
multi|line
regexp
`;
```
as I'm also not a fan of having to nest `` ` `` and `/`.

[14:59:51.0255] <Luca Casonato>
MSL's library that Mark is referring to: https://github.com/mikesamuel/regexp-make-js

[15:03:12.0304] <rbuckton>
I think one of Mark's concerns about string append is character classes. If `Regexp.escape` is safe for `new RegExp("[" + Regexp.escape(input) + "]")`, is that still a concern?

[15:04:14.0526] <Richard Gibson>
also backslash

[15:04:39.0850] <littledan>
I don't understand jridgewell's point

[15:05:27.0919] <HE Shi-Jun>
> <@rbuckton:matrix.org> I think one of Mark's concerns about string append is character classes. If `Regexp.escape` is safe for `new RegExp("[" + Regexp.escape(input) + "]")`, is that still a concern?

how it could be safe?

[15:05:51.0304] <Justin Ridgewell>
```` re``` ```` is just invalid

[15:06:09.0797] <rbuckton>
> <@haxjs:matrix.org> how it could be safe?

Every character can be escaped into something that would be valid in a _ClassAtom_

[15:06:10.0119] <Justin Ridgewell>
You can't match a `` ` `` in a TTL built RegExp

[15:06:18.0971] <Justin Ridgewell>
Because you can't have a lone `` ` `` in a TTL

[15:06:38.0708] <littledan>
I don't understand why `re`\``` or `re`\\`` wouldn't work for this

[15:06:45.0842] <littledan>
(ugh how do I type that?0

[15:06:48.0337] <Richard Gibson>
 * also backslash: https://github.com/tc39/proposal-regex-escaping/issues/37#issue-98309281

[15:06:48.0576] <waldemar>
> <@bakkot:matrix.org> anyone know _why_ IEEE decimal distinguishes between 1.2 and 1.20?

It's just that, unlike IEEE binary which always has an implied 1 as the leading mantissa digit for non-denorms, there are multiple bit patterns that can represent the same IEEE decimal number because the leading mantissa digit can be 0 through 9. For example, there are hundreds of ways to represent +0 as a IEEE decimal, and they're all different and distinguishable.
The situation is similar to how UTF-8 was originally defined: there were multiple ways to encode "a" (either as a single byte, as two bytes, as three bytes, etc.). Eventually this became enough of a problem that UTF-8 was changed to ban encodings other than the shortest possible ones.

[15:06:57.0274] <Justin Ridgewell>
Because the `\` is now included in your regex

[15:07:00.0601] <rbuckton>
> <@jridgewell:matrix.org> You can't match a `` ` `` in a TTL built RegExp

You can, but not easily. You would have to do `` RegExp`${"`"}` ``, which isn't ideal but it is feasible.

[15:07:15.0135] <Justin Ridgewell>
I want to match "`"

[15:07:35.0307] <Justin Ridgewell>
But that won't work for `\`

[15:07:37.0303] <rbuckton>
> <@littledan:matrix.org> I don't understand why `re`\``` or `re`\\`` wouldn't work for this

double backtick (or one more than the number used in the sample)

[15:07:48.0508] <rbuckton>
i.e., ``` `` ` `` ``` produces `` ` ``

[15:07:49.0404] <Justin Ridgewell>
Because `\` is a special char in RegExp that would need to be escaped in the expression for

[15:07:51.0510] <Justin Ridgewell>
 * Because `\` is a special char in RegExp that would need to be escaped in the expression form

[15:08:39.0970] <Justin Ridgewell>
If we had the ```` re``` ``` ```` multitick start/stop form from String.dedent, then it would have worked except for `\`

[15:09:00.0376] <rbuckton>
We can have ```` re``` ``` ````

[15:09:13.0364] <rbuckton>
But it doesnt do what you want)

[15:09:15.0215] <rbuckton>
 * But it doesnt do what you want :)

[15:09:26.0963] <Michael Ficarra>
lol yeah we already have that rbuckton 

[15:09:52.0710] <Justin Ridgewell>
Yah, this got brought up during String.dedent unfortunately

[15:10:00.0143] <Michael Ficarra>
Justin Ridgewell: I still don't see how ``re`\``` doesn't do what you want

[15:10:04.0299] <Michael Ficarra>
jesus

[15:10:08.0800] <Michael Ficarra>
I don't know how to talk about this

[15:10:09.0197] <HE Shi-Jun>
even u have ``` ```, what if u want to match ``` ?

[15:10:19.0461] <Justin Ridgewell>
Tip, matrix supports multitick blocks

[15:10:22.0234] <HE Shi-Jun>
 * even u have `` ``, what if u want to match \`\`\` ?

[15:10:32.0017] <ljharb>
``` ` ```

[15:10:33.0530] <Michael Ficarra>
`` re`\` ``

[15:10:35.0826] <Michael Ficarra>
there

[15:10:38.0588] <Justin Ridgewell>
```` ``` ```` delimits with 4 ticks at start/stop

[15:10:47.0489] <Michael Ficarra>
 * ``re`\\```

[15:10:54.0760] <littledan>
Kleene's regex language, I imagine Mark is referring to

[15:10:55.0278] <HE Shi-Jun>
 * even u have \`\`\` \`\`\`, what if u want to match \`\`\` ?

[15:11:05.0095] <Michael Ficarra>
 * ``re`\\\` ``

[15:11:07.0930] <rbuckton>
> <@michaelficarra:matrix.org> ``re`\\\` ``

`` /\/ `` doesn't work either though

[15:11:08.0482] <shu>
i've always pronounced that Clean-y

[15:11:11.0497] <Michael Ficarra>
omfg

[15:11:14.0770] <shu>
is it actually Clean?

[15:11:18.0124] <Michael Ficarra>
yes I am trying to write two backslashes

[15:11:32.0582] <littledan>
> <@shuyuguo:matrix.org> is it actually Clean?

my theory-heavy coworker pronounced its Clean-y the other day

[15:11:41.0531] <Justin Ridgewell>
> <@rbuckton:matrix.org> `` /\/ `` doesn't work either though

That would be written as `/\\/` to match `s = "\\"`

[15:11:50.0385] <Justin Ridgewell>
But it's not possible to write with a TTL

[15:12:00.0611] <Michael Ficarra>
Justin Ridgewell: please explain why not

[15:12:17.0511] <Justin Ridgewell>
``` re`\` ``` is invalid syntax

[15:12:17.0839] <rbuckton>
Yeah, though your comment indicates that `\` in a RegExp template is impossible, when it seems pretty consistent with RegExp literals

[15:12:37.0208] <Justin Ridgewell>
And ``` re`\\` ``` only matches `s = "\\\\"`

[15:12:46.0692] <shu>
we're on break now right?

[15:12:56.0333] <eemeli>
Yes.

[15:12:57.0198] <rbuckton>
I agree that `` ` `` is problematic, but also rare.

[15:13:03.0412] <Justin Ridgewell>
```String.raw`\\`.length === 3```

[15:13:06.0187] <Justin Ridgewell>
 * ``String.raw`\\`.length === 2``

[15:13:12.0726] <Justin Ridgewell>
 * ``String.raw`\\`.length === 2``, not 1

[15:13:49.0408] <rbuckton>
Yeah, that's fair. raw is a bit weird, though I wonder if that case is possible to detect.

[15:14:35.0211] <Michael Ficarra>
> <@jridgewell:matrix.org> ``` re`\` ``` is invalid syntax

two backslashes

[15:14:46.0336] <rbuckton>
i.e., Treat `\\` as `\` when parsing from a tagged template literal

[15:14:56.0143] <Justin Ridgewell>
See https://matrix.to/#/!WgJwmjBNZEXhJnXHXw:matrix.org/$aLh1spEECiImadJ_R3hX7vmWq_x53QWJ5RoJwgTztV4?via=matrix.org&via=igalia.com&via=mozilla.org

[15:15:12.0434] <Justin Ridgewell>
> And `` re`\\` `` only matches `s = "\\\\"`


[15:16:13.0105] <rbuckton>
> <@jridgewell:matrix.org> > And `` re`\\` `` only matches `s = "\\\\"`

Yes, could we not detect that case when parsing from a template tag?

[15:16:21.0516] <Justin Ridgewell>
`` /`/ `` and `` /\\/ `` cannot be represented

[15:17:31.0785] <rbuckton>
I think `/\\/` can be handled. ``/`/`` can't

[15:33:04.0395] <Rob Palmer>
Asumu is primarily addressing the feedback that we ought to explore whether runtime-types should be in-scope.

[15:44:05.0374] <Michael Ficarra>
for proponents of runtime types, what do you expect an engine to do if the declared type is incorrect and an engine optimises based on that type? is it now permitted to have a different result? UB?

[15:44:25.0311] <Justin Ridgewell>
eemeli ljharb I think Asumu is addressing runtime vs compile time in this presentation, and not unification.

[15:45:32.0392] <ljharb>
feel free to move mine to the end of the list, but i still want to bring it up if there's time

[15:47:37.0777] <eemeli>
Same, because this proposal continues to focus on the technical details of a specific solution, and not addressing their stated main goal.

[15:47:54.0753] <Justin Ridgewell>
Ok

[15:48:14.0903] <Justin Ridgewell>
I agree that this is an important topic for the overall proposal, just not sure if he's prepared to address them

[15:48:48.0708] <littledan>
Please feel free to ask these kinds of big-picture questions; they seem important at this stage

[15:48:51.0704] <danielrosenwasser>
I'm prepared to address it provided we have time, but would encourage that we focus on the current topics

[15:49:42.0371] <eemeli>
Part of what I'll want to say I already filed as an issue: https://github.com/tc39/proposal-type-annotations/issues/171

[15:50:41.0550] <Chris de Almeida>
agree -- folks should be heard, but I think it's reasonable to let folks comment on the presentation topic first.  especially as this is not moving for advancement

[15:52:21.0887] <rbuckton>
I'm personally less interested in "unforking" or "unification", but more interested in cutting down development time by avoiding a compile step to get from writing code to running code faster.

[15:53:03.0703] <Michael Ficarra>
there have been some truly excellent presentations at this meeting!

[15:53:06.0935] <Michael Ficarra>
puts me to shame

[15:53:21.0435] <Michael Ficarra>
I am going to need to put more effort into mine in the future now

[15:53:56.0069] <eemeli>
rbuckton: Agreed. But that's not what's presented as the proposal's motivation.

[15:54:23.0327] <eemeli>
And it's not a part of the problem statement that was accepted a year ago.

[15:55:07.0616] <Rob Palmer>
I think it was part of the problem statement - we talked about the developer friction

[15:55:09.0595] <ryzokuken>
100% this

[15:55:10.0647] <Chris de Almeida>
unrelated:  I am unlikely to be able to attend the end of the day.  Ashley Claymore IBM supports stage 1 for `await dictionary`

[15:55:25.0369] <ryzokuken>
we need to talk about unrealistic standards about presentations in TC39 /s

[16:04:01.0331] <shu>
...are people talking about contracts vs types now?

[16:04:29.0119] <shu>
like those are different paradigms

[16:05:28.0355] <Michael Ficarra>
shu: ever heard of gradual typing? checkmate

[16:05:52.0446] <shu>
my brother... 

[16:05:57.0321] <littledan>
> <@michaelficarra:matrix.org> shu: ever heard of gradual typing? checkmate

TypeScript is gradually typed because you can declare some types and not others!!

[16:06:02.0115] <shu>
lol

[16:06:21.0723] <littledan>
No, seriously, given the diversity of meanings of gradual typing (where people unironically use the above form), we deliberately omitted it from this presentation

[16:06:40.0340] <littledan>
Asumu's PhD thesis was on sound gradual typing in Racket (he cited it in the talk!)

[16:07:27.0556] <Rob Palmer>
yes - when Asumu said there was material on the subject he was referring to his own paper

[16:07:56.0168] <littledan>
tl;dr you might be able to use some fancy compiler techniques to make sound Scheme type enforcement not have way too much of a performance penalty (though it breaks down for JS, as Assume explained)

[16:08:05.0941] <littledan>
 * tl;dr you might be able to use some fancy compiler techniques to make sound Scheme type enforcement not have way too much of a performance penalty (though it breaks down for JS, as Asumu explained)

[16:08:12.0745] <Michael Ficarra>
> <@littledan:matrix.org> No, seriously, given the diversity of meanings of gradual typing (where people unironically use the above form), we deliberately omitted it from this presentation

people actually do this? what?

[16:08:21.0097] <Justin Ridgewell>
9min remaining!

[16:08:36.0444] <littledan>
> <@michaelficarra:matrix.org> people actually do this? what?

It is the predominant meaning in our community

[16:12:20.0651] <waldemar>
I don't understand DE's claim that all the things we've been adding to the language since ES6 are "unifying" the language.

[16:14:23.0501] <Justin Ridgewell>
We have 3 min remaining on this item

[16:22:04.0428] <Michael Ficarra>
is there seriously no [NLTH] in the proposed grammar?

[16:22:43.0063] <Justin Ridgewell>
Is this only concerned with `< stuff here >` syntax?

[16:23:32.0788] <Michael Ficarra>
requiring balanced braces would also probably be a good minimum bar

[16:23:34.0590] <HE Shi-Jun>
> <@michaelficarra:matrix.org> is there seriously no [NLTH] in the proposed grammar?

NLTH means "no line terminator" ?

[16:23:43.0201] <Michael Ficarra>
HE Shi-Jun: yes

[16:24:03.0347] <littledan>
> <@waldemarh:matrix.org> I don't understand DE's claim that all the things we've been adding to the language since ES6 are "unifying" the language.

If I said "all", then that was misspeaking by me; I do think it's been a big theme in our work.

[16:24:18.0021] <HE Shi-Jun>
Michael Ficarra: So type is complex and seems need line terminators.

[16:24:47.0999] <littledan>
Even when we add things to the standard library like Array.prototype.group or Temporal, we're unifying the ecosystem where previously people had to use various different libraries to get that functionality.

[16:24:58.0955] <littledan>
this is sort of the normal flow of work for a standards body, I think

[16:25:51.0277] <eemeli>
littledan, danielrosenwasser : Is the big-picture vision that you talked about presented in text anywhere? I think that's the sort of motivation and explanation that I'm most missing here, because I don't see how type annotations can get us from here to there.

[16:25:52.0370] <rbuckton>
`{ a: b } =>` can't be an arrow function or arrow type? I would expect `{}` to be far more limited than `()` and `[]`, at least.

[16:26:41.0830] <rbuckton>
Also, this `foo < a ;` is addressed by the "turbofish" syntax `::<>`, i.e. `foo::< a`

[16:26:51.0411] <littledan>
> <@michaelficarra:matrix.org> is there seriously no [NLTH] in the proposed grammar?

Yeah, fundamentally you don't get into this general token soup space without a paren, so you just have space for a token, or one of the productions that's explicitly there

[16:28:49.0971] <littledan>
> <@eemeli:mozilla.org> littledan, danielrosenwasser : Is the big-picture vision that you talked about presented in text anywhere? I think that's the sort of motivation and explanation that I'm most missing here, because I don't see how type annotations can get us from here to there.

It's fine to ask us to clarify the explainer more, and I'd be happy to talk with you in more detail about how/where our current readme or presentation fails to make this case. At the same time, I'm a bit offended by the implication that the champion group doesn't know what it's trying to get at, just because the documents weren't written in a way which was sufficiently clear/persuasive to everyone.

[16:34:21.0834] <Justin Ridgewell>
1min

[16:37:03.0815] <littledan>
Does anyone know what the issue numbers that Waldemar is referring to?

[16:37:29.0382] <danielrosenwasser>
Unfortunately, people keep saying "turbofish", so I'll clarify that that means `::<...>`

[16:38:08.0347] <rbuckton>
Yes, sorry. "turbofish" is the term used in Rust

[16:38:23.0484] <shu>
why is ordinary fish

[16:38:28.0855] <shu>
 * what is ordinary fish

[16:38:46.0155] <danielrosenwasser>
> <@eemeli:mozilla.org> littledan, danielrosenwasser : Is the big-picture vision that you talked about presented in text anywhere? I think that's the sort of motivation and explanation that I'm most missing here, because I don't see how type annotations can get us from here to there.

https://devblogs.microsoft.com/typescript/a-proposal-for-type-syntax-in-javascript/#whats-next

> This isn‚Äôt a sure-fire thing ‚Äì there are many valuable perspectives within the committee, and we do expect some amount of skepticism. A proposal like this will receive a lot of feedback and appropriate scrutiny. It may involve lots design changes along the way, and may take years to yield results.
>
> But if we pull this all off, we have the chance to make one of the most impactful improvements to the world of JavaScript. We‚Äôre excited by that, and we hope you are too.

[16:39:01.0189] <rbuckton>
 * Yes, sorry. "turbofish" is the term used in Rust, per: https://blog.rust-lang.org/2021/09/09/Rust-1.55.0.html#dedication

[16:39:07.0280] <Michael Ficarra>
`><>`?

[16:39:33.0208] <littledan>
shu: We've seen TS make tricky transitions before, e.g., with class fields. I'm not really sure what more details would make sense at this stage.

[16:39:57.0773] <littledan>
shu: Maybe you could be more concrete with what kind of thing you're looking for?

[16:40:08.0591] <scottwhittaker>
Waldemar's slides are at https://docs.google.com/presentation/d/1TLGdvGfOn2wl-_i_HfrfpgFkdffrhCnisowdkOiebB8/edit#slide=id.g21db78ad531_0_44 ; the two linked issues are https://github.com/tc39/proposal-type-annotations/issues/116 and https://github.com/tc39/proposal-type-annotations/issues/103

[16:40:21.0645] <shu>
littledan: how did manage the transition with class fields? are old style class fields no longer supported?

[16:40:41.0625] <danielrosenwasser>
`--useDefineForClassFields`

[16:41:07.0296] <danielrosenwasser>
it is turned on as soon as your target is `esWhateverVersionTheyGotStandardized`

[16:41:16.0551] <danielrosenwasser>
 * it is turned on as soon as your output `--target` is `esWhateverVersionTheyGotStandardized`

[16:41:23.0265] <shu>
are both kind of fields code exists in the wild and will continue to exist?

[16:41:38.0852] <shu>
 * do both kind of fields code exist in the wild and will continue to exist?

[16:42:23.0447] <littledan>
The class fields transition is significantly harder, because it's different semantics for the same syntax. This is just a syntax subset, completely statically visible with no ambiguity as to how it should run.

[16:42:54.0484] <littledan>
Until decorator metadata is standardized and adopted, set-based fields need to keep existing, unfortunately. I'm glad we're finally getting there.

[16:42:57.0584] <ljharb>
sffc: `await.all` is proposing syntax to match the existing API, not syntax instead, to be clear

[16:43:15.0745] <Rob Palmer>
(Responsible) evolution of TypeScript is in some ways easier than evolving JS because it's already accepted that regular upgrades of TypeScript are mild (responsibly managed) breaking changes.  People accept this and spend effort upgrading.  The benefits are worth it.

[16:43:23.0948] <danielrosenwasser>
I think the framing is partially about transitions, it's about "can we find tasteful alternatives to express the same concepts"

[16:43:27.0338] <ljharb>
shu: function call params are already solved because you can pass and return an object :-p

[16:43:53.0296] <shu>
and so this is also already solved by writing your own code?

[16:44:00.0081] <rbuckton>
Another example might be TypeScript's type cast syntax. We've always had `<T>value`, but added `value as T` to avoid ambiguity with JSX/TSX. We may never fully move everyone to `value as T`, but most TS code I see today uses `as`.

[16:44:12.0686] <ljharb>
> <@shuyuguo:matrix.org> and so this is also already solved by writing your own code?

for a function you author, yes. not for Promise combinators

[16:44:26.0454] <ljharb>
> <@shuyuguo:matrix.org> and so this is also already solved by writing your own code?

 * for a function you author, yes. not for Promise combinators (at least, not without a mildly complex helper function)

[16:44:53.0030] <shu>
rbuckton: i don't define non-divergence by "most code don't diverge", but by "no code diverges"

[16:45:01.0933] <ljharb>
HE Shi-Jun: re your queue item, what would `async let` do exactly?

[16:45:30.0294] <ljharb>
 * HE Shi-Jun: re your queue item, what does `async let` do exactly in swift?

[16:45:36.0177] <danielrosenwasser>
> <@danielrosenwasser:matrix.org> I think the framing is partially about transitions, it's about "can we find tasteful alternatives to express the same concepts"

so type arguments on invocations - we prefer the existing syntax, but

1. they're rarely specified, and typically inferred
2. Rust (everyone's new favorite language) has shown that people are fine with something like `f::<T, U>(...)

[16:45:39.0208] <HE Shi-Jun>
not easy to explain in one sentence

[16:45:41.0488] <justinfagnani>
I would rather see syntax here... like:
```
await const {
  shape = getShape(),
  color = getColor(),
  mass = getMass(),
};
```

[16:45:43.0954] <bakkot>
ljharb: https://www.avanderlee.com/swift/async-let-asynchronous-functions-in-parallel/

[16:46:02.0424] <ljharb>
> <@justinfagnani:matrix.org> I would rather see syntax here... like:
> ```
> await const {
>   shape = getShape(),
>   color = getColor(),
>   mass = getMass(),
> };
> ```

imo that seems like a great followon after it already exists as API

[16:46:04.0535] <bakkot>
it's neat but doesn't translate naturally to JS

[16:46:19.0557] <danielrosenwasser>
so new code can use the `::<>` syntax in TS, use the old syntax in TS, and in JS you'd have to pick one

[16:46:31.0590] <shu>
yes, and now you have diverged...?

[16:46:32.0796] <ljharb>
> <@bakkot:matrix.org> it's neat but doesn't translate naturally to JS

kind of seems like "just don't await the promise until later"?

[16:46:42.0227] <bakkot>
yyyyeah kinda

[16:46:44.0509] <littledan>
> <@shuyuguo:matrix.org> rbuckton: i don't define non-divergence by "most code don't diverge", but by "no code diverges"

Sorry, Shu, I'm trying to understand, what are you getting at? E.g., for the `<T>value` syntax, what harm does it do if TS has a mode that accepts that, and JS never will, but it might support a large other subset of TS/Flow?

[16:46:45.0775] <bakkot>
but there's better syntax for it

[16:46:56.0946] <HE Shi-Jun>
`async let` have some difficulty in JS (eg. variable capture), but I hope we can explore the possibility.

[16:47:12.0087] <ljharb>
i'm sure we could but that sounds like a different proposal maybe?

[16:47:14.0927] <littledan>
I think the important thing for the TSX transitions was, can people "live in TSX"? and in that sense, it was a complete success

[16:47:38.0368] <littledan>
it needs to be that the syntax that Type Annotations supports is enough to live in; it doesn't need to take over all existing code IMO.

[16:47:45.0723] <HE Shi-Jun>
> <@ljharb:matrix.org> i'm sure we could but that sounds like a different proposal maybe?

If it's for the same problem, shouldn't it in one proposal?

[16:47:51.0037] <ljharb>
is it the same problem?

[16:47:51.0559] <Michael Ficarra>
I think an `all` analogue is fine, the others seem to only make sense on unnamed collections

[16:47:52.0954] <rbuckton>
I don't even know what I'd use `Promise.raceOwnProperties` for.

[16:48:15.0097] <ljharb>
i'd use it for allSettled the same as i'd use it for all. the other two i don't see a use case for tho

[16:48:36.0438] <Justin Ridgewell>
But how do you tell which one won the race?

[16:48:46.0620] <shu>
> <@littledan:matrix.org> Sorry, Shu, I'm trying to understand, what are you getting at? E.g., for the `<T>value` syntax, what harm does it do if TS has a mode that accepts that, and JS never will, but it might support a large other subset of TS/Flow?

i understand that the whole point of this proposal is to bring TS syntax "into the fold". the harm is that if the promise is actually "we will work to converge TS and JS syntax in the future", that sounds like ecosystem divergence to me and i do not have the risk appetite for that

[16:48:48.0451] <HE Shi-Jun>
> <@ljharb:matrix.org> is it the same problem?

at least it could solve this problem IMO.

[16:48:50.0602] <bakkot>
> <@michaelficarra:matrix.org> I think an `all` analogue is fine, the others seem to only make sense on unnamed collections

allSettled makes sense on named collections

[16:48:55.0774] <bakkot>
the others, no

[16:49:09.0488] <bakkot>
or at least less so

[16:49:20.0035] <ljharb>
> <@haxjs:matrix.org> at least it could solve this problem IMO.

i'm not sure it would, but we would certainly explore that kind of thing in stage 1

[16:49:22.0976] <Michael Ficarra>
okay yeah I buy that

[16:50:25.0839] <ljharb>
> <@haxjs:matrix.org> at least it could solve this problem IMO.

 * i'm not sure it would, but we would certainly explore that kind of thing in stage 1. altho i think solving it with syntax is a much harder sell prior to API existing.

[16:50:32.0458] <littledan>
> <@shuyuguo:matrix.org> i understand that the whole point of this proposal is to bring TS syntax "into the fold". the harm is that if the promise is actually "we will work to converge TS and JS syntax in the future", that sounds like ecosystem divergence to me and i do not have the risk appetite for that

Yeah, this is why the syntax *is* aligned with TS and Flow for the most part. If we end up doing something like add `::<`, it would be in conjunction with the change on the TS side (it's not even in the current grammar yet).

[16:50:53.0434] <shu>
and i am saying, "for the most part" isn't enough for my risk appetite

[16:51:18.0666] <littledan>
> <@shuyuguo:matrix.org> and i am saying, "for the most part" isn't enough for my risk appetite

maybe this would be a good thing to dig into in another presentation focused on the syntax?

[16:51:37.0002] <rbuckton>
I've used `Promise.all(promises)` to avoid a waterfall when queueing up operations where I only need to wait for completion, so I wouldn't say the fact that its list-oriented is just due to "that's what we had at the time'

[16:51:40.0393] <rbuckton>
 * I've used `Promise.all(promises)` to avoid a waterfall when queueing up operations where I only need to wait for completion, so I wouldn't say the fact that its list-oriented is just due to "that's what we had at the time"

[16:52:11.0620] <bakkot>
yes, sorry, I was speaking loosely

[16:52:31.0920] <bakkot>
there's really two uses - when you have a homogenous list, where you're probably not destructuring, and where you have a heterogenous list, where you probably are

[16:52:42.0634] <bakkot>
Promise.all is perfect for the first case but awkward for the second

[16:53:56.0984] <rbuckton>
Or when you want to avoid repetition for non-degenerate cases like how the example started out.

[16:55:17.0187] <rbuckton>
`const { foo, bar } = Promise.ownProperties({ foo: getFoo(), bar: getBar() })` isn't an improvement over `const [foo, bar] = Promise.all([getFoo(), getBar()])` until you reach a level of complexity where that becomes unmanageable (as was illustrated in the example).

[16:56:39.0047] <bakkot>
I think 2 items is probably the limit though

[16:56:56.0520] <bakkot>
like when I have APIs which return 2 values I might return an unnamed pair, but as soon as it's 3 I'm going to name them instead

[16:57:51.0099] <justinfagnani>
the difference with `await Promise.all()` and function parameters is that you need to lists to use Promise.all vs one args list at the call site for a function (of course a function as a parameter list, but we can't eliminate that)

[16:58:06.0302] <rbuckton>
That said, I'm very much in favor of this as its fairly easy to exhaust that minimum complexity bar for `Promise.all()`. I'm not terribly enthusiastic about `await.` syntax, in general. I think an API approach is the right direction for now. 

[16:58:08.0592] <justinfagnani>
it's cumbersome to keep these lists in sync, and hard to read when they get long

[16:58:13.0403] <shu>
okay, on the motivation front i am now convinced, and this boils down to kevin's reason: "Promise.all is special, because the ordering of its input list is not semantically meaningful, and so is harder to keep track of mentally. except you _have_ to keep track of it mentally because it must match up to the output list"


2023-03-23
[17:00:50.0826] <bakkot>
re: waldemar's point, I agree that more general async dataflow would be great, and is something we should explore, though I think I'd still want this proposal for simple case

[17:02:28.0457] <justinfagnani>
re: Mark's comments now... when you see a ton of code that's accidentally serial instead of parallel, you really wish for a better syntax for all of this that doesn't encourage bad behavior

[17:06:53.0813] <HE Shi-Jun>
> <@bakkot:matrix.org> re: waldemar's point, I agree that more general async dataflow would be great, and is something we should explore, though I think I'd still want this proposal for simple case

but it seems not have big benefit for simple case :)

[17:09:19.0062] <rbuckton>
I'm fairly certain a cover grammar is feasible for `await using`, the big question is whether what I have put together is correct. Given the NLT restrictions, an `await using` declaration must have the first identifier in the binding list on the same line as `await using`, and that is always a syntax error in the expression case. Binding patterns aren't permitted in `using`, so there is no ambiguity with `await using [x]`.

[17:10:06.0968] <shu>
i'm gonna level with you rbuckton, i do not have enough brainpower left today to vet that cover grammar

[17:10:19.0093] <shu>
though i'm more interested in how hard it is to implement in a recursive-descent parser anyhow

[17:10:44.0542] <shu>
i'll try to put time aside before plenary tomorrow to look, but... i also have a presentation tomorrow first thing so also no promises

[17:14:04.0630] <rbuckton>
The gist of it is, the cover is identical to AwaitExpression, but UnaryExpression would fail to parse `await using x` when `x` is on the same line.  AwaitUsingDeclaration however would be able to consume the cover along with a trailing `[no LineTerminator here] BindingList`, which seems pretty much equivalent to CoverParenthesizedExpression

[17:14:33.0120] <rbuckton>
 * The gist of it is, the cover is identical to AwaitExpression, but UnaryExpression would fail to parse `await using x` when `x` is on the same line.  AwaitUsingDeclaration however would be able to consume the cover along with a trailing `[no LineTerminator here] BindingList`, which seems pretty much equivalent to CoverParenthesizedExpressionAndArrowParameterList

[17:15:00.0017] <rbuckton>
 * The gist of it is, the cover is identical to AwaitExpression, but UnaryExpression would fail to parse `await using x` when `x` is on the same line.  AwaitUsingDeclaration however would be able to consume the cover along with a trailing `[no LineTerminator here] BindingList`, which seems pretty much equivalent to CoverParenthesizedExpressionAndArrowParameterList and CoverCallExpressionAndAsyncArrowHead

[17:16:20.0619] <shu>
that... sounds reasonable

[17:16:27.0551] <rbuckton>
Though I'll admit, cover grammars in the spec today sometimes seem a bit hand-wavy in a couple places.

[17:16:53.0700] <shu>
and i just do a bounded look ahead `await` `using` and see if it's an NLTH identifier

[17:17:07.0341] <shu>
in +Await contexts

[17:17:20.0856] <rbuckton>
In TS I'd just do two-token lookahead in +Await

[17:17:53.0906] <rbuckton>
That is one benefit of `await using` over `async using`. For `await using`, both uses of the cover are in +Await, while for `async using`, only one is.

[17:18:56.0079] <shu>
and `await using` without a binding list is unaffected?

[17:19:19.0664] <shu>
well, is supposed to be, according to the cover

[17:19:43.0601] <rbuckton>
> <@rbuckton:matrix.org> In TS I'd just do two-token lookahead in +Await

In fact, I've already done that in my current work on `using` (I was experimenting with all three syntax options).

[17:20:02.0874] <shu>
is TS a hand-written recursive-descent?

[17:22:03.0809] <rbuckton>
> <@shuyuguo:matrix.org> and `await using` without a binding list is unaffected?

I'm not sure what you mean by this. `await using` on its own, or anywhere else legal for a UnaryExpression, should end up treated as an AwaitExpression.

[17:22:15.0127] <shu>
 yes, that is what i meant

[17:25:06.0574] <rbuckton>
From my understanding of cover grammars, we would eagerly parse CoverAwaitExpressionAndAwaitUsingDeclarationHead, but fail to parse the rest of ExpressionStatement. We could then retry the parse as part of AwaitUsingDeclaration, reusing the cover, and be able to successfully continue to parse. Then static semantics kick in and validate that the CoverAwaitExpressionAndAwaitUsingDeclarationHead is a valid AwaitUsingDeclarationHead (e.g., `await [NLT] using`), and parse the remainder of the statement (e.g., ``[NLT] BindingList `;` ``)

[17:25:18.0947] <rbuckton>
 * From my understanding of cover grammars, we would eagerly parse CoverAwaitExpressionAndAwaitUsingDeclarationHead, but fail to parse the rest of ExpressionStatement. We could then retry the parse as part of AwaitUsingDeclaration, reusing the cover, and be able to successfully continue to parse. Then static semantics kick in and validate that the CoverAwaitExpressionAndAwaitUsingDeclarationHead is a valid AwaitUsingDeclarationHead (e.g., `await [NLT] using`)

[17:25:22.0761] <shu>
i am happy enough to go forward with stage 3

[17:27:41.0030] <rbuckton>
I will amend the slides with a summary of these changes and wait to see if Waldemar is able to provide feedback in the meantime.

[19:53:36.0073] <Michael Ficarra>
is there anything we need to do to get Decimal on the overflow, or will it be taken care of?

[20:09:41.0097] <littledan>
> <@michaelficarra:matrix.org> is there anything we need to do to get Decimal on the overflow, or will it be taken care of?

If there is time to go through the queue for decimal, that would be great, but we could also do that next meeting

[20:10:11.0598] <Michael Ficarra>
of course, I just wanted to record it on the list of overflow items

[23:15:01.0706] <bakkot>
ljharb: I made some slides just for mark, if we have time tomorrow, PTAL: https://docs.google.com/presentation/d/1s1IZSo24JpMsI_NponP8vvIKUazld62lcleKF976Ppc/edit?usp=sharing

[07:01:22.0210] <Richard Gibson>
> <@bakkot:matrix.org> ljharb: I made some slides just for mark, if we have time tomorrow, PTAL: https://docs.google.com/presentation/d/1s1IZSo24JpMsI_NponP8vvIKUazld62lcleKF976Ppc/edit?usp=sharing

note the changes would need to be more substantive for dealing with [`v`-mode](https://github.com/tc39/ecma262/pull/2418), which has a wider set of reserved punctuators and semantics for doubled punctuators (https://github.com/tc39/proposal-regexp-v-flag#how-is-the-v-flag-different-from-the-u-flag and https://arai-a.github.io/ecma262-compare/snapshot.html?pr=2418#prod-ClassSetCharacter )

[07:42:52.0841] <rbuckton>
Are we ensuring that RegExp.escape is future proof against potential new syntax? Should we be concerned if the output changes in a later version if we have to escape something new? We could choose to be intentionally over-aggressive with escapes, if we're not already. 

[07:53:27.0434] <rbuckton>
Also, rather than extending u-mode to allow other escapes, we could escape non-u-mode syntax characters using a hexadecimal representation that is legal in all modes. So, instead of adding `\-`, we could choose to escape it as `\x2d`. Same for `\=` (`\x3d`) and `\,` (`\x2c`)

[07:53:56.0876] <rbuckton>
I'm not saying we shouldn't extend u-mode, but this is an option if we decide not to.

[08:12:08.0586] <rbuckton>
Regarding the "exhaustive list of contexts", keep in mind that several proposals add other contexts:
- Modifiers: `(?imsx-imsx:...)`
- Comments: `(?#...)`
- `x`-mode line comments: `# ...`
- Atomic Groups: `(?>...)`

At a quick glance, I think this means that `#` may need to be escaped as well, lest it me misinterpreted in `x` mode.

[08:14:56.0862] <rbuckton>
If there's a chance we want `RegExp.escape` to always remain stable, it may be worth going over the RegExp syntax investigation I did at https://rbuckton.github.io/regexp-features/features/ to ensure we're future-proof against other syntax we may choose to adopt later. Though, I admit that's not a completely exhaustive list.

[08:15:54.0839] <Chris de Almeida>
I've just had to reference the notes as I had to leave early yesterday, and the conclusion/summary was a nice help

[08:16:05.0749] <Chris de Almeida>
 * I've just had to reference the notes as I had to leave early yesterday, and the conclusion/summary for each agenda item was a nice help

