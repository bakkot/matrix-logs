2023-06-01
[17:11:34.0425] <bakkot>
new question: should `Math.sum` do kahan summation

[17:11:42.0279] <bakkot>
acceptable answers are "yes" and "of course"

[03:50:37.0198] <Jack Works>
https://github.com/terser/terser/blob/master/test/compress/labels.js#L84-L104

[03:51:14.0409] <Jack Works>
Does anyone know why? These two codes have the same observable semantics to me

[07:40:08.0579] <Justin Ridgewell>
That could be changed

[08:56:08.0537] <Michael Ficarra>
yes, but there's basically an unlimited number of variants of Kahan's that track an additional N compensation vars, so what should our N be for a reasonable precision/perf trade-off?

[08:56:21.0727] <Michael Ficarra>
something like 3 is probably ideal

[08:58:33.0101] <bakkot>
my vote is to just do whatever Python does

[08:58:37.0311] <bakkot>
for fsum

[08:58:54.0142] <bakkot>
which appears to be... 32

[08:59:00.0357] <bakkot>
https://github.com/python/cpython/blob/a241003d048f33c9072d47217aa6e28beb7ac54f/Modules/mathmodule.c#L1284

[08:59:07.0394] <bakkot>
32 might be overkill...

[09:00:25.0457] <Michael Ficarra>
holy crap, 32?!

[09:04:03.0406] <bakkot>
java uses just the basic (one partial) kahan if I'm reading this right https://github.com/openjdk/jdk/blob/e8271649e00771a8bbee240aa1bbbc27a672b22a/src/java.base/share/classes/java/util/stream/Collectors.java#L717

[09:08:06.0526] <bakkot>
ok no python uses an unbounded number of partials

[09:08:09.0853] <bakkot>
that's wild

[09:08:51.0352] <bakkot>
they do this so that it's actually correct

[09:08:58.0191] <bakkot>
like, _actually_ correct, not just bounded error

[09:09:00.0089] <bakkot>
https://code.activestate.com/recipes/393090/

[09:09:27.0422] <bakkot>
while attractive I think that probably is in fact overkill

[09:10:05.0350] <Michael Ficarra>
I mean, I'm up for it if implementers are


2023-06-02
[01:00:25.0117] <eemeli>
A `Math.sum` that does Kahan summation actually sounds exactly like the sort of thing I think we ought to add to JS. It's a bit tricky to get right, and it solves a problem that's not necessarily obvious for a developer to realise is a problem or that the solution even exists.

[13:45:05.0442] <Justin Ridgewell>
Related: https://github.com/swc-project/swc/pull/7478


2023-06-03
[08:53:25.0963] <Hemanth H.M>
üëè which is the best way to set up an incubator call? 


2023-06-05
[22:53:26.0025] <bakkot>
why do the dataview methods default to big-endian 

[22:54:15.0558] <bakkot>
who is running JS on big-endian systems and why did we decide they should get the simpler form

[22:56:33.0893] <bakkot>
sidebar: we should probably expose endianness as a constant somewhere

[22:57:00.0461] <bakkot>
it is kind of unfortunate that it's implementation-defined but since it is we at least ought to let you test for it without having to write a value and read it back

[01:54:43.0510] <littledan>
> <@bakkot:matrix.org> who is running JS on big-endian systems and why did we decide they should get the simpler form

Internet protocols??

[01:55:07.0755] <littledan>
> <@bakkot:matrix.org> it is kind of unfortunate that it's implementation-defined but since it is we at least ought to let you test for it without having to write a value and read it back

Sure but is there an actual (valid) use case for that?

[08:10:06.0652] <bakkot>
> <@littledan:matrix.org> Sure but is there an actual (valid) use case for that?

if you're using DataView methods you need to be explicit about it 

[08:10:41.0408] <bakkot>
since they don't fall back to the platform default

[08:11:39.0410] <bakkot>
bare `float64Array[x] = y` does fall back to the platform default, so if you write a value using that syntax and then want to read it with a DataView you need to know which endianness to specify for the DataView methods

[12:38:04.0217] <littledan>
Sure but who is forcing you to use the DataView methods?

[13:32:55.0251] <ljharb>
lol is that a serious question? there's a reason dataview exists

[13:50:53.0457] <littledan>
Well, I don‚Äôt really see any particular logic to the system beyond, TypedArray is for when you want to use native endianness, and DataView is when you want explicit endianness

[14:01:41.0481] <Kris Kowal>
Unfortunately, DataView is not that orthogonal to other TypedArrays in its design. It‚Äôs also useful for heterogenous data like a serial protocol buffer, for which big-endian is indeed a great default, or an allocation arena for structs, where little-endian would be a great default.

[14:06:45.0096] <littledan>
Well, it‚Äôs unergonomic but can‚Äôt you superimpose different TypedArrays on top of the same arraybuffer to do that heterogeneous, native endian access?

[14:07:02.0134] <littledan>
If we enable more, it seems like ergonomics would be the motivation, right?

[14:11:54.0436] <Kris Kowal>
You also need to superimpose your Uint64Array at 8 initial offsets, and do some math to choose.

[14:12:07.0413] <Kris Kowal>
So, yes, ergonomics.

[14:12:45.0097] <Kris Kowal>
As opposed to contortion.

[14:14:01.0614] <littledan>
So, sure, I have nothing against an ergonomics-motivated way to get at the platform endianness, for the sake of passing into the DataView methods

[14:14:17.0649] <littledan>
*BigUint64Array

[14:14:52.0318] <littledan>
Also when you use that API please write a note to the poor implementers who did all the work and weren‚Äôt sure if it was useful


2023-06-08
[16:04:27.0350] <ljharb>
it seems weird to me that there's no DataView methods for getUint8C and setUint8C - it's the only typed array type that doesn't have them

[16:16:16.0796] <bakkot>
`get` doesn't really make sense

[16:16:25.0189] <bakkot>
the special behavior is only when setting

[16:48:00.0767] <Michael Ficarra>
the setter seems pretty well motivated, especially since it's not all that easy to write the round-ties-to-even behaviour of ToUint8Clamped

[16:48:59.0292] <Michael Ficarra>
 * the setter seems pretty well motivated, especially since it's not all that easy to write the round-ties-to-even behaviour of ToUint8Clamp

[16:49:22.0251] <Michael Ficarra>
 * the setter seems pretty well motivated, especially since it's not all that easy to write the round-ties-to-even behaviour of ToUint8Clamp yourself


2023-06-09
[17:03:18.0020] <bakkot>
ehhh... I feel like the dataview methods only tend to make sense when you have data of mixed types in a buffer, and I don't think that's very likely for Uint8ClampedArray data

[17:04:02.0956] <bakkot>
wouldn't be opposed though

[22:06:56.0671] <ljharb>
any reason not to have the get tho, for consistency?

[22:07:00.0153] <ljharb>
 * any reason not to have the get tho also, for consistency?

[22:23:54.0267] <bakkot>
I feel like it is misleading? or like... allows people who are confused to lean into their confusion instead of discovering it

[22:24:16.0355] <bakkot>
it is better to notice what you are doing and just use getUint8 if you actually want it

[22:24:35.0384] <bakkot>
if someone reaches for it and it's not there, and then they stop and think about why that is, that's good

[23:14:51.0927] <leftmostcat>
I think it's rare that toolboxes are complete enough that most devs will think, "Should I not be doing this?" if the tool is missing, so that intent would need to be well-documented.

[05:50:03.0246] <littledan>
I think Clamped is good to leave out; it is just some weird canvas legacy

[08:37:54.0889] <ljharb>
it‚Äôs there everywhere else tho

[10:21:59.0153] <ljharb>
ok well i made https://github.com/ljharb/proposal-dataview-get-set-uint8c and put it on the agenda, we can see what everyone thinks :-)

[10:26:09.0057] <Michael Ficarra>
the get method makes me pretty uncomfortable

[10:27:46.0567] <ljharb>
why?

[10:34:35.0990] <Michael Ficarra>
because it's no different than the regular Uint8 getter

[10:34:51.0991] <Michael Ficarra>
and someone will be confused by its existence

[10:36:54.0512] <ljharb>
seems like just part of the confusion of Uint8ClampedArray existing itself

[10:38:58.0499] <bakkot>
It is kind of weird that Uint8Clamped exists, but it at least does a coherent, non-duplicative thing

[10:39:06.0208] <bakkot>
 * It is kind of weird that Uint8ClampedArray exists, but it at least does a coherent, non-duplicative thing

[10:39:10.0878] <bakkot>
but getUint8Clamped would be duplicative

[10:40:31.0187] <ljharb>
`[0]` on a Uint8Array and Uint8ClampedArray is duplicative too, no?

[10:41:24.0716] <ljharb>
adding the set without the get is still improving consistency imo, but i really don't see the harm here of having it be duplicative.

[10:43:51.0196] <bakkot>
> `[0]` on a Uint8Array and Uint8ClampedArray is duplicative too, no?

... no? I mean if you have a Uint8ClampedArray you do need to be able to read from it

[10:46:08.0388] <ljharb>
right but i mean that there's no difference in reading values from both of the uint8 arrays

[10:47:00.0203] <bakkot>
yes but you can't provide Uint8ClampedArray without the ability to read from it

[10:47:13.0908] <bakkot>
so it does not make sense to say that `[0]` is duplicative

[10:47:41.0689] <bakkot>
"ability to read from a Uint8Array" and "ability to read from a Uint8ClampedArray" are distinct operations even though they implement the same logic

[10:48:05.0109] <bakkot>
but "read a Uint8 from an ArrayBuffer" is not a distinct operation from "read a Uint8Clamped from an ArrayBuffer"

[10:48:20.0735] <ljharb>
fair

[10:48:48.0733] <ljharb>
the current state means i have to special-case my code that dynamically builds the dataview method name, because Uint8C isn't there

[10:48:59.0298] <ljharb>
so for me, having it missing is what's confusing

[10:50:58.0213] <bakkot>
I think that case is probably pretty niche

[10:52:26.0304] <ljharb>
sure, but i'd bet in a similar bucket of niche as using the dataview methods at all

[11:49:44.0302] <rbuckton>
> <@ljharb:matrix.org> sure, but i'd bet in a similar bucket of niche as using the dataview methods at all

Just for `Uint8` or in general? `ar[0]` uses native endianness. `dataView.get*` and `dataView.set*` use big-endian/native byte order by default, and allows you to specify little-endian if needed, so they're pretty useful for decoding binary-format files without having to detect endianness and adjust

[11:50:01.0970] <rbuckton>
> <@ljharb:matrix.org> sure, but i'd bet in a similar bucket of niche as using the dataview methods at all

 * Just for `Uint8` or in general? `ar[0]` uses native endianness. `dataView.get*` and `dataView.set*` use big-endian/native byte order by default, and allows you to specify little-endian if needed, so they're pretty useful for decoding binary-format files without having to detect endianness and adjust manually

[11:50:05.0359] <ljharb>
fair

[11:50:16.0630] <ljharb>
 * fair, altho i think that's not a common use case :-)

[11:50:30.0653] <ljharb>
not saying they're not useful, just not common

[11:50:47.0826] <ljharb>
the ability to specify endianness is why i'm using them

[11:51:04.0186] <rbuckton>
I would venture to guess folks using web sockets would disagree that it's not common.

[12:07:41.0803] <Michael Ficarra>
anybody processing any binary network protocols, really

[12:38:06.0372] <rbuckton>
Of course, then there's me, using `DataView` to parse a PE header to find the base address of a Windows executable (which are encoded in little-endian)...


2023-06-13
[21:46:18.0276] <rkirsling>
so I've never attended a general assembly meeting, but since there's one happening in Tokyo, I was like "oh cool let's check that out", yet

[21:46:57.0924] <rkirsling>
the invite appears to correspond to the CEST work day?

[21:53:06.0378] <rkirsling>
ah digging through my emails, it literally is in Geneva

[21:53:12.0500] <rkirsling>
what the heck happened there

[03:31:38.0993] <littledan>
Oh it was going to be in Tokyo but then people didn‚Äôt sign up for it so it will be in Geneva 

[03:31:52.0004] <littledan>
In a few weeks, right?

[03:32:20.0234] <littledan>
We had an email thread about this among frequent GA attendees‚Ä¶ that clearly should‚Äôve included more people 

[03:32:33.0697] <littledan>
Where did you see the erroneous mention of Tokyo? We should fix that.

[07:14:54.0933] <rkirsling>
> <@littledan:matrix.org> Where did you see the erroneous mention of Tokyo? We should fix that.

oh no it's just that I had responded months ago to Patrick's request for Tokyo attendance and then I never heard about it being changed

[07:16:43.0240] <rkirsling>
so then a Doodle came last week and I glanced at it and it was on CEST schedule so I was like "well clearly the Tokyo one must be some other time...but wait, when the heck was that meant to be anyway" and sure enough it was the same timeframe

[07:17:21.0626] <rkirsling>
 * so then a Doodle came last week and I glanced at it and it was on CEST schedule so I was like "well clearly the Tokyo one must be some other time" and ignored it until today when I was like "...but wait, when the heck was that meant to be anyway" and sure enough, it's the same one

[07:18:58.0240] <rkirsling>
it's not a big deal; I had merely felt that it would be for me to _not_ go and see how GA is conducted if it's so nearby

[07:19:04.0028] <rkirsling>
 * it's not a big deal; I had merely felt that it would be a waste for me to _not_ go and see how GA is conducted if it's so nearby

[08:12:22.0590] <littledan>
well, I hope you call into the GA so you can see how it's conducted!

[12:54:37.0031] <TabAtkins>
Yeah, I knew that summation error due to FP roundoff was a thing, but I actually wasn't aware there was a general (and pretty easy) technique for correcting this.


2023-06-14
[18:59:16.0567] <rkirsling>
that's fair, it is a pretty reasonable time for me

[01:16:37.0292] <Rob Palmer>
Hey all, I realize for the Norway July meeting there is no specific designated hotel because "they are all good". But just in case folk wish to coordinate, does anyone wish to share a suggestion?

[01:18:37.0480] <nicolo-ribaudo>
Igalians are all at Citybox 

[01:24:19.0066] <Rob Palmer>
Thanks.  There are two CityBox:  Bergen to the north of the University, and Danmarksplass to the south over the bridge.  Both look a similar distance.  which did you pick?

[01:26:49.0373] <nicolo-ribaudo>
The one north, which has the advantage of also being closer to the city center 

[06:53:46.0765] <Michael Ficarra>
I chose Scandic Byparken

[06:54:55.0783] <Michael Ficarra>
there's a nearby bike share that I plan to take full advantage of while I'm there

[08:00:08.0179] <eemeli>
Dan and I ended up at Hotel Park Bergen.

[09:01:57.0698] <littledan>
> <@michaelficarra:matrix.org> I chose Scandic Byparken

I'm there too

[10:26:58.0436] <Rob Palmer>
I went with Norge by Scandic which is nearby them. 

[13:40:50.0063] <Michael Ficarra>
how much of this decision was based on them having a pool?

[14:16:03.0713] <shu>
ugh you know what i forgot to instrument for import assertions `assert`, the dynamic import case

[14:18:49.0476] <Ashley Claymore>
What does "instrument" mean in this case?

[14:19:06.0820] <Ashley Claymore>
Performance?

[14:19:15.0918] <shu>
use counters to see if we can unship `assert`

[14:19:19.0256] <shu>
in favor of `with`

[14:19:29.0102] <shu>
i only added use counters for the static syntax :(

[14:19:29.0286] <Ashley Claymore>
Oh right. That was going to be my second guess 

[14:19:41.0538] <Ashley Claymore>
We forgive you!

[14:19:50.0276] <shu>
the good news is that there's diminishingly small use of the static syntax at least

[14:20:21.0357] <Kris Kowal>
That‚Äôs a good signal. We can expect dynamic import to be even less.

[14:20:33.0331] <shu>
i hope so

[14:21:54.0189] <shu>
i don't know if that implication usually holds though

[14:22:10.0878] <shu>
wouldn't there be a bunch more dynamic imports because you can use that from classic script?

[14:22:10.0912] <Kris Kowal>
very curious to see data, for sure

[14:25:35.0840] <Kris Kowal>
since you‚Äôre looking at real figures, can you verify it‚Äôs too late to unship ESM ;-)

[14:30:08.0600] <shu>
yes

[14:30:19.0680] <shu>
more than 4% of page visits use dynamic import alone

[14:30:41.0792] <Kris Kowal>
nice. that‚Äôs not 0!

[14:30:50.0471] <shu>
that is like, 140MM daily page visits

[14:31:57.0053] <Kris Kowal>
this is a good figure to have in my back pocket if anyone asks me why i‚Äôm working with what we have and not suggesting we go back to 2010 and start over.


2023-06-15
[00:29:53.0239] <Rob Palmer>
Didn't know they had a pool. I went more by Google Maps rating.

[00:39:59.0785] <Rob Palmer>
> <@shuyuguo:matrix.org> more than 4% of page visits use dynamic import alone

Is it possible to know what % of page loads are using other user-land module systems? I.e. webpack chunks or require.js.

Because 4% of all page loads is good, but if we knew that 50% of all page loads were basic HTML docs that didn't use any module system, then we could say that adoption amongst the target audience is more like 8% (twice as good).

[00:49:33.0917] <Jesse>
FYI the decimal proposal will be hosting an incubator call on Thursday, July 29, at 15:00 UTC. Anyone interested in (decimal) numbers is welcome to attend. The meeting will last at most one hour. https://github.com/tc39/incubator-agendas/pull/30

[07:40:47.0638] <shu>
it is not

[07:41:06.0170] <shu>
use counters are, how do i say, "very dumb"

[07:41:44.0186] <shu>
i don't think it's feasible to add any _browser_-level instrumentation for any userland pattern

[09:28:40.0548] <ljharb>
july? or june?

[09:29:06.0603] <TabAtkins>
Ehhh it depends, but generally yes. You can do some surprising amounts of detection, but it has to be relatively cheap. (CSS stuff, for example, is already expensive enough that use counters can do a decent amount before they become troublesome.)

[09:29:56.0287] <TabAtkins>
July 29th is a Saturday, so I assume they meant June.

[09:32:08.0448] <Michael Ficarra>
the PR correctly says June: v

[09:32:16.0237] <Michael Ficarra>
 * the PR correctly says June: https://github.com/tc39/incubator-agendas/pull/30/files

[11:13:37.0093] <Rob Palmer>
Hello all, the Interest Survey for Tokyo plenary is now posted.

https://github.com/tc39/Reflector/issues/478

Please fill it in by 25th June. It takes 60 seconds. 

[13:07:55.0906] <ljharb>
i'm indeed assuming the matrix message is wrong, but wanted to confirm


2023-06-16
[23:31:10.0122] <Jesse>
oops, yes, I meant June, sorry

[13:45:33.0259] <shu>
one unfortunate about grouping being static methods is that the fast path got more tricky to reason about

[13:47:30.0411] <shu>
because of the iterables thing

[13:49:37.0512] <bakkot>
shu: would it get easier if we froze the `next` method on ArrayIteratorPrototype

[13:49:45.0548] <bakkot>
if so can we just do that

[13:50:02.0716] <bakkot>
(also also the `Symbol.iterator` method on Array.prototype I guess)

[13:50:05.0277] <bakkot>
 * (and also the `Symbol.iterator` method on Array.prototype I guess)

[13:51:44.0304] <shu>
well we already cache an IteratorRecord so mutations to the iterator or the prototype during iteration won't be reflected

[13:52:21.0688] <shu>
i don't think we need to do anything, i'm just venting

[14:13:43.0782] <ljharb>
We wouldn‚Äôt have to freeze it if we made IsArray things that weren‚Äôt proxies or subclasses always call the intrinsic next/Symbol.iterator :-p

[15:46:54.0164] <littledan>
> <@ljharb:matrix.org> We wouldn‚Äôt have to freeze it if we made IsArray things that weren‚Äôt proxies or subclasses always call the intrinsic next/Symbol.iterator :-p

This would be a very implementation-friendly change (well, a lot to do at this point but it would allow engines to rip out a number of annoying fast paths)

[15:47:39.0837] <littledan>
Except I don‚Äôt understand the ‚Äúthat aren‚Äôt proxies or subclasses‚Äù part, what the line would be

[15:47:54.0920] <littledan>
No idea if any change there is web compatible 

[15:53:33.0510] <ljharb>
i mean like, a proxy to an array would still need to generate the Gets, as would a subclass, to be web compatible


2023-06-20
[17:04:21.0731] <bakkot>
question for implementers: the current design of the base64 proposal, in the streaming case, allocations a new Uint8Array window (of a pre-existing buffer) once per chunk. is that actually expensive enough to warrant reconsidering the design? I would have assumed that new views of existing buffers would be cheap

[17:04:24.0445] <bakkot>
cc shu ^

[00:02:52.0345] <snek>
there is more logic than there used to be, cuz of resizable array buffers, but its essentially just a couple checks for detached and alignment and then making an allocation. seems reasonable to me ü§∑

[00:29:41.0522] <shu>
bakkot: for v8 it's probably okay, and i imagine there to be relatively few chunks per streaming session?

[00:30:21.0949] <shu>
i'd check with SpiderMonkey, i don't remember exactly but i kind of recall that each buffer kept a list of views pointing to it?

[00:30:23.0629] <shu>
mgaudet: ^

[04:09:34.0952] <Rob Palmer>
This is a reminder to please fill in [**the Interest Survey**](https://github.com/tc39/Reflector/issues/478) for the Sept/Nov in-person plenary meeting in Tokyo.

It only take 60s to complete.  The deadline is Sunday 25th June (five days time).

Thank you to the 23 people who have already completed it üëç

[04:48:36.0471] <Jesse>
do we by chance have any snapshots (whether text or screenshot) of old TCQ states? In other words, the state of the queue after a certain presentation

[05:43:27.0248] <Ashley Claymore>
sometimes the note takers will take a screen shot and paste into the google doc

[05:43:42.0032] <Ashley Claymore>
if it's not there then I would guess: no


2023-06-21
[00:10:48.0497] <justingrant>
One of the entrance requirements for Stage 3 is "All ECMAScript editors have signed off on the current spec text". How should champions go about getting that signoff? I'm asking because we're hoping to ask for Stage 3 for proposal-canonical-tz at the July TC39 meeting.
 
For Stage 3 reviewers, I've been creating issues like https://github.com/tc39/proposal-canonical-tz/issues/33 and https://github.com/tc39/proposal-canonical-tz/issues/35. 

Should I do the same for each of the ECMA-262 editors? Should I open one issue and tag @tc39/ecma262-editors?  Something else?

[00:17:06.0588] <nicolo-ribaudo>
Tagging ecma262-editors is enough to get their attention. I recommend doing it as early as possible to make it easier for them, because reviewing proposals is very time consuming

[08:17:23.0445] <Michael Ficarra>
justingrant: Yeah, you can simply ping `@tc39/ecma262-editors` on a tracking issue. Personally, I prefer to review as a PR against tc39/ecma262 (you're going to have to open one eventually anyway), but that's not necessary.

[08:20:06.0321] <Michael Ficarra>
Every editor call, we check the agenda for proposals marked for advancement to stage 3/4 to prepare for reviews. If a lot of stuff gets added just before the deadline for advancement, it can get pretty hard to get reviews in on time. It's why we've had to do "conditional advancement" a few times, though we'd prefer not to have to do that again. So the earlier you let us know about it, the better.

[08:23:10.0141] <Michael Ficarra>
Also you can ask us questions any time in #tc39-editors:matrix.org 

[08:23:34.0830] <mgaudet>
> <@bakkot:matrix.org> question for implementers: the current design of the base64 proposal, in the streaming case, allocations a new Uint8Array window (of a pre-existing buffer) once per chunk. is that actually expensive enough to warrant reconsidering the design? I would have assumed that new views of existing buffers would be cheap

Sorry - meant to reply yesterday. It sounds like we're mostly ok with it. The creation of many short lived objects isn't amazing, but it's not a reason to be substantially less ergonomic (translating for team, errors mine)

[08:35:58.0593] <shu>
mgaudet: does SM keep a list of views from each array buffer? perhaps i'm misremembering

[08:36:33.0437] <mgaudet>
shu: AIUI a hash set, but yes

[08:37:03.0549] <shu>
that's the thing i wasn't sure is acceptable, not so much the short-lived objects part

[08:37:49.0200] <mgaudet>
Mostly it should be ok unless we have to resize; but that's the cost of amortized cost data structures

[08:49:23.0992] <rbuckton>
bakkot, Michael Ficarra: The Async Iterator Helpers proposal uses the term "async method" to allow `Await()` in its algorithm steps without the heavy lifting of manually writing out interactions with PromiseCapability, but this isn't formalized either in that proposal or in ECMA-262 proper. I've been considering how I could use that to simplify the algorithm steps of `AsyncDisposableStack.prototype.disposeAsync()`, so I was wondering if any formal description of "async method" had been written yet, since I couldn't find one in https://tc39.es/proposal-async-iterator-helpers/. 

[09:09:48.0913] <Michael Ficarra>
rbuckton: it's here: https://github.com/tc39/ecma262/pull/2942

[09:11:52.0125] <rbuckton>
Thanks!

[09:12:46.0300] <Michael Ficarra>
we're still trying to figure out whether we actually want to allow this form in the spec though: https://github.com/tc39/ecma262/pull/2942#issuecomment-1515412109

[09:13:04.0806] <Michael Ficarra>
Shu has some concerns

[09:19:01.0805] <shu>
i lean towards "this is our (V8)'s problem to solve, not really the spec's", but there's also a principled argument to be made about maximizing interop likelihood for multiple implementation techniques

[09:20:26.0516] <shu>
there is also some evidence that the act of speccing at the high level of async functions or generators gives rise to blind spots, like in iterator helpers

[10:12:00.0096] <snek>
time to add `await` to torque

[12:14:37.0216] <justingrant>
> <@michaelficarra:matrix.org> Also you can ask us questions any time in #tc39-editors:matrix.org

Thanks Michael, will do... except I get a "You do not have permission to post to this room" error in Matrix after joining that room. Expected?

