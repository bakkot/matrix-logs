2023-06-01
[17:11:34.0425] <bakkot>
new question: should `Math.sum` do kahan summation

[17:11:42.0279] <bakkot>
acceptable answers are "yes" and "of course"

[03:50:37.0198] <Jack Works>
https://github.com/terser/terser/blob/master/test/compress/labels.js#L84-L104

[03:51:14.0409] <Jack Works>
Does anyone know why? These two codes have the same observable semantics to me

[07:40:08.0579] <Justin Ridgewell>
That could be changed

[08:56:08.0537] <Michael Ficarra>
yes, but there's basically an unlimited number of variants of Kahan's that track an additional N compensation vars, so what should our N be for a reasonable precision/perf trade-off?

[08:56:21.0727] <Michael Ficarra>
something like 3 is probably ideal

[08:58:33.0101] <bakkot>
my vote is to just do whatever Python does

[08:58:37.0311] <bakkot>
for fsum

[08:58:54.0142] <bakkot>
which appears to be... 32

[08:59:00.0357] <bakkot>
https://github.com/python/cpython/blob/a241003d048f33c9072d47217aa6e28beb7ac54f/Modules/mathmodule.c#L1284

[08:59:07.0394] <bakkot>
32 might be overkill...

[09:00:25.0457] <Michael Ficarra>
holy crap, 32?!

[09:04:03.0406] <bakkot>
java uses just the basic (one partial) kahan if I'm reading this right https://github.com/openjdk/jdk/blob/e8271649e00771a8bbee240aa1bbbc27a672b22a/src/java.base/share/classes/java/util/stream/Collectors.java#L717

[09:08:06.0526] <bakkot>
ok no python uses an unbounded number of partials

[09:08:09.0853] <bakkot>
that's wild

[09:08:51.0352] <bakkot>
they do this so that it's actually correct

[09:08:58.0191] <bakkot>
like, _actually_ correct, not just bounded error

[09:09:00.0089] <bakkot>
https://code.activestate.com/recipes/393090/

[09:09:27.0422] <bakkot>
while attractive I think that probably is in fact overkill

[09:10:05.0350] <Michael Ficarra>
I mean, I'm up for it if implementers are


2023-06-02
[01:00:25.0117] <eemeli>
A `Math.sum` that does Kahan summation actually sounds exactly like the sort of thing I think we ought to add to JS. It's a bit tricky to get right, and it solves a problem that's not necessarily obvious for a developer to realise is a problem or that the solution even exists.

[13:45:05.0442] <Justin Ridgewell>
Related: https://github.com/swc-project/swc/pull/7478


2023-06-03
[08:53:25.0963] <Hemanth H.M>
üëè which is the best way to set up an incubator call? 


2023-06-05
[22:53:26.0025] <bakkot>
why do the dataview methods default to big-endian 

[22:54:15.0558] <bakkot>
who is running JS on big-endian systems and why did we decide they should get the simpler form

[22:56:33.0893] <bakkot>
sidebar: we should probably expose endianness as a constant somewhere

[22:57:00.0461] <bakkot>
it is kind of unfortunate that it's implementation-defined but since it is we at least ought to let you test for it without having to write a value and read it back

[01:54:43.0510] <littledan>
> <@bakkot:matrix.org> who is running JS on big-endian systems and why did we decide they should get the simpler form

Internet protocols??

[01:55:07.0755] <littledan>
> <@bakkot:matrix.org> it is kind of unfortunate that it's implementation-defined but since it is we at least ought to let you test for it without having to write a value and read it back

Sure but is there an actual (valid) use case for that?

[08:10:06.0652] <bakkot>
> <@littledan:matrix.org> Sure but is there an actual (valid) use case for that?

if you're using DataView methods you need to be explicit about it 

[08:10:41.0408] <bakkot>
since they don't fall back to the platform default

[08:11:39.0410] <bakkot>
bare `float64Array[x] = y` does fall back to the platform default, so if you write a value using that syntax and then want to read it with a DataView you need to know which endianness to specify for the DataView methods

[12:38:04.0217] <littledan>
Sure but who is forcing you to use the DataView methods?

[13:32:55.0251] <ljharb>
lol is that a serious question? there's a reason dataview exists

[13:50:53.0457] <littledan>
Well, I don‚Äôt really see any particular logic to the system beyond, TypedArray is for when you want to use native endianness, and DataView is when you want explicit endianness

[14:01:41.0481] <Kris Kowal>
Unfortunately, DataView is not that orthogonal to other TypedArrays in its design. It‚Äôs also useful for heterogenous data like a serial protocol buffer, for which big-endian is indeed a great default, or an allocation arena for structs, where little-endian would be a great default.

[14:06:45.0096] <littledan>
Well, it‚Äôs unergonomic but can‚Äôt you superimpose different TypedArrays on top of the same arraybuffer to do that heterogeneous, native endian access?

[14:07:02.0134] <littledan>
If we enable more, it seems like ergonomics would be the motivation, right?

[14:11:54.0436] <Kris Kowal>
You also need to superimpose your Uint64Array at 8 initial offsets, and do some math to choose.

[14:12:07.0413] <Kris Kowal>
So, yes, ergonomics.

[14:12:45.0097] <Kris Kowal>
As opposed to contortion.

[14:14:01.0614] <littledan>
So, sure, I have nothing against an ergonomics-motivated way to get at the platform endianness, for the sake of passing into the DataView methods

[14:14:17.0649] <littledan>
*BigUint64Array

[14:14:52.0318] <littledan>
Also when you use that API please write a note to the poor implementers who did all the work and weren‚Äôt sure if it was useful


2023-06-08
[16:04:27.0350] <ljharb>
it seems weird to me that there's no DataView methods for getUint8C and setUint8C - it's the only typed array type that doesn't have them

[16:16:16.0796] <bakkot>
`get` doesn't really make sense

[16:16:25.0189] <bakkot>
the special behavior is only when setting

[16:48:00.0767] <Michael Ficarra>
the setter seems pretty well motivated, especially since it's not all that easy to write the round-ties-to-even behaviour of ToUint8Clamped

[16:48:59.0292] <Michael Ficarra>
 * the setter seems pretty well motivated, especially since it's not all that easy to write the round-ties-to-even behaviour of ToUint8Clamp

[16:49:22.0251] <Michael Ficarra>
 * the setter seems pretty well motivated, especially since it's not all that easy to write the round-ties-to-even behaviour of ToUint8Clamp yourself


2023-06-09
[17:03:18.0020] <bakkot>
ehhh... I feel like the dataview methods only tend to make sense when you have data of mixed types in a buffer, and I don't think that's very likely for Uint8ClampedArray data

[17:04:02.0956] <bakkot>
wouldn't be opposed though

[22:06:56.0671] <ljharb>
any reason not to have the get tho, for consistency?

[22:07:00.0153] <ljharb>
 * any reason not to have the get tho also, for consistency?

[22:23:54.0267] <bakkot>
I feel like it is misleading? or like... allows people who are confused to lean into their confusion instead of discovering it

[22:24:16.0355] <bakkot>
it is better to notice what you are doing and just use getUint8 if you actually want it

[22:24:35.0384] <bakkot>
if someone reaches for it and it's not there, and then they stop and think about why that is, that's good

[23:14:51.0927] <leftmostcat>
I think it's rare that toolboxes are complete enough that most devs will think, "Should I not be doing this?" if the tool is missing, so that intent would need to be well-documented.

[05:50:03.0246] <littledan>
I think Clamped is good to leave out; it is just some weird canvas legacy

[08:37:54.0889] <ljharb>
it‚Äôs there everywhere else tho

[10:21:59.0153] <ljharb>
ok well i made https://github.com/ljharb/proposal-dataview-get-set-uint8c and put it on the agenda, we can see what everyone thinks :-)

[10:26:09.0057] <Michael Ficarra>
the get method makes me pretty uncomfortable

[10:27:46.0567] <ljharb>
why?

[10:34:35.0990] <Michael Ficarra>
because it's no different than the regular Uint8 getter

[10:34:51.0991] <Michael Ficarra>
and someone will be confused by its existence

[10:36:54.0512] <ljharb>
seems like just part of the confusion of Uint8ClampedArray existing itself

[10:38:58.0499] <bakkot>
It is kind of weird that Uint8Clamped exists, but it at least does a coherent, non-duplicative thing

[10:39:06.0208] <bakkot>
 * It is kind of weird that Uint8ClampedArray exists, but it at least does a coherent, non-duplicative thing

[10:39:10.0878] <bakkot>
but getUint8Clamped would be duplicative

[10:40:31.0187] <ljharb>
`[0]` on a Uint8Array and Uint8ClampedArray is duplicative too, no?

[10:41:24.0716] <ljharb>
adding the set without the get is still improving consistency imo, but i really don't see the harm here of having it be duplicative.

[10:43:51.0196] <bakkot>
> `[0]` on a Uint8Array and Uint8ClampedArray is duplicative too, no?

... no? I mean if you have a Uint8ClampedArray you do need to be able to read from it

[10:46:08.0388] <ljharb>
right but i mean that there's no difference in reading values from both of the uint8 arrays

[10:47:00.0203] <bakkot>
yes but you can't provide Uint8ClampedArray without the ability to read from it

[10:47:13.0908] <bakkot>
so it does not make sense to say that `[0]` is duplicative

[10:47:41.0689] <bakkot>
"ability to read from a Uint8Array" and "ability to read from a Uint8ClampedArray" are distinct operations even though they implement the same logic

[10:48:05.0109] <bakkot>
but "read a Uint8 from an ArrayBuffer" is not a distinct operation from "read a Uint8Clamped from an ArrayBuffer"

[10:48:20.0735] <ljharb>
fair

[10:48:48.0733] <ljharb>
the current state means i have to special-case my code that dynamically builds the dataview method name, because Uint8C isn't there

[10:48:59.0298] <ljharb>
so for me, having it missing is what's confusing

[10:50:58.0213] <bakkot>
I think that case is probably pretty niche

[10:52:26.0304] <ljharb>
sure, but i'd bet in a similar bucket of niche as using the dataview methods at all

[11:49:44.0302] <rbuckton>
> <@ljharb:matrix.org> sure, but i'd bet in a similar bucket of niche as using the dataview methods at all

Just for `Uint8` or in general? `ar[0]` uses native endianness. `dataView.get*` and `dataView.set*` use big-endian/native byte order by default, and allows you to specify little-endian if needed, so they're pretty useful for decoding binary-format files without having to detect endianness and adjust

[11:50:01.0970] <rbuckton>
> <@ljharb:matrix.org> sure, but i'd bet in a similar bucket of niche as using the dataview methods at all

 * Just for `Uint8` or in general? `ar[0]` uses native endianness. `dataView.get*` and `dataView.set*` use big-endian/native byte order by default, and allows you to specify little-endian if needed, so they're pretty useful for decoding binary-format files without having to detect endianness and adjust manually

[11:50:05.0359] <ljharb>
fair

[11:50:16.0630] <ljharb>
 * fair, altho i think that's not a common use case :-)

[11:50:30.0653] <ljharb>
not saying they're not useful, just not common

[11:50:47.0826] <ljharb>
the ability to specify endianness is why i'm using them

[11:51:04.0186] <rbuckton>
I would venture to guess folks using web sockets would disagree that it's not common.

[12:07:41.0803] <Michael Ficarra>
anybody processing any binary network protocols, really

[12:38:06.0372] <rbuckton>
Of course, then there's me, using `DataView` to parse a PE header to find the base address of a Windows executable (which are encoded in little-endian)...


2023-06-13
[21:46:18.0276] <rkirsling>
so I've never attended a general assembly meeting, but since there's one happening in Tokyo, I was like "oh cool let's check that out", yet

[21:46:57.0924] <rkirsling>
the invite appears to correspond to the CEST work day?

[21:53:06.0378] <rkirsling>
ah digging through my emails, it literally is in Geneva

[21:53:12.0500] <rkirsling>
what the heck happened there

[03:31:38.0993] <littledan>
Oh it was going to be in Tokyo but then people didn‚Äôt sign up for it so it will be in Geneva 

[03:31:52.0004] <littledan>
In a few weeks, right?

[03:32:20.0234] <littledan>
We had an email thread about this among frequent GA attendees‚Ä¶ that clearly should‚Äôve included more people 

[03:32:33.0697] <littledan>
Where did you see the erroneous mention of Tokyo? We should fix that.

[07:14:54.0933] <rkirsling>
> <@littledan:matrix.org> Where did you see the erroneous mention of Tokyo? We should fix that.

oh no it's just that I had responded months ago to Patrick's request for Tokyo attendance and then I never heard about it being changed

[07:16:43.0240] <rkirsling>
so then a Doodle came last week and I glanced at it and it was on CEST schedule so I was like "well clearly the Tokyo one must be some other time...but wait, when the heck was that meant to be anyway" and sure enough it was the same timeframe

[07:17:21.0626] <rkirsling>
 * so then a Doodle came last week and I glanced at it and it was on CEST schedule so I was like "well clearly the Tokyo one must be some other time" and ignored it until today when I was like "...but wait, when the heck was that meant to be anyway" and sure enough, it's the same one

[07:18:58.0240] <rkirsling>
it's not a big deal; I had merely felt that it would be for me to _not_ go and see how GA is conducted if it's so nearby

[07:19:04.0028] <rkirsling>
 * it's not a big deal; I had merely felt that it would be a waste for me to _not_ go and see how GA is conducted if it's so nearby

[08:12:22.0590] <littledan>
well, I hope you call into the GA so you can see how it's conducted!

