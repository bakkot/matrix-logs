2025-07-01
[20:58:12.0154] <rkirsling>
I have definitely never heard anyone say the word milliard or billiard though

[20:59:23.0525] <rkirsling>
so I remain feeling like this is just some long troll being played on Americans

[23:35:05.0082] <Jesse>
upon moving to Germany, I was confronted with the million/milliard/billion distinction fairly early on


2025-07-02
[05:51:38.0499] <Jack Works>
https://github.com/webpack/webpack/pull/16567
webpack merged support for import defer proposal!

[09:11:17.0335] <dminor>
Would someone here have permissions to make mgaudet and I collaborators on https://github.com/tc39/proposal-error-capturestacktrace? Neither of us has access to the settings since the transfer to the tc39 org, and I'd like to fix up the deploy of the spec text to gh-pages.

[09:14:08.0533] <Chris de Almeida>
mgaudet has write permission, and now you do as well

[09:14:14.0782] <Chris de Almeida>
* mgaudet already had write permission, and now you do as well

[09:17:45.0633] <dminor>
Thank you, but I'm still not seeing the `settings`, does that require a separate permission?

[09:54:41.0486] <Chris de Almeida>
oh.. yes

[09:55:34.0894] <Chris de Almeida>
try now

[11:13:32.0552] <dminor>
Working now, thank you for the help :)


2025-07-03
[06:04:20.0409] <Michael Ficarra>
congratulations @robpalme:matrix.org! ü•≥

[06:47:23.0512] <Anthony Bullard>
i feel like i missed an announcement

[06:50:22.0882] <saminahusain>
The 129th General Assembly held in Geneva (Switzerland) on 25 June 2025, approved new recognition awards to honour Touradj Ebrahimi, Hyun Kahng, **Robert Palmer** and Michael Saboff for their contributions and services to Ecma.

[06:50:56.0685] <saminahusain>
https://ecma-international.org/ecma-fellow-awards-and-ecma-recognition-awards/#ecma-recognition-award

[06:52:12.0465] <saminahusain>
Please see below the endorsement and nomination citation:

---------------------

Rob Palmer for contributions to TC39

Rob Palmer has been an integral part of the TC39 chair group since 2020, making an outstanding and lasting impact. In plenary sessions, he has kept the agenda running seamlessly, demonstrating exceptional patience and finding balanced solutions amidst heated debates and time constraints‚Äîtruly setting a standard for leadership.

His unwavering support for meeting hosts has significantly eased the pressures of a demanding role, ensuring smooth and efficient proceedings. Beyond the committee, Rob has been a welcoming and approachable representative, actively engaging with the broader community through social media, fostering transparency and inclusivity.

Rob‚Äôs contributions have undeniably strengthened TC39, leaving a positive and lasting mark on the committee.

---------------------


[06:52:58.0205] <saminahusain>
Congratulations from my side and thank you for your contributions.

[06:54:18.0706] <Anthony Bullard>
Well, congratulations to Rob!

[10:38:07.0423] <Rob Palmer>
Thank you all!

[10:39:04.0959] <Rob Palmer>
And congrats to Michael Saboff who is doubly worth the recognition given his contributions to both TC39 and Ecma where he served as ExeCom Chair. 

[13:25:01.0097] <Aki>
Well deserved, both of you

[13:25:30.0524] <Aki>
Can someone point me to the conversation about normatively referencing WebIDL? I'm doing‚Ä¶ research.

[13:31:16.0031] <nicolo-ribaudo>
I think it's most in emails and calls, I'll forward them to you tomorrow 

[13:31:41.0812] <nicolo-ribaudo>
Oh nevermind I was thinking of infra, not webidl

[13:43:29.0450] <Michael Ficarra>
which conversation? the one from plenary?

[13:44:01.0903] <Aki>
I don't know, I saw it referenced at some point in Matrix. If there was one from the last plenary I can go read the notes!

[13:44:21.0428] <Michael Ficarra>
yeah you can see the notes for that

[13:44:27.0238] <Michael Ficarra>
also there's still conversation happening in https://github.com/tc39/proposal-idl/issues

[14:55:45.0496] <Aki>
do any of the TC39 standards from any TG reference anything published by w3c? (normatively or informatively)(or even in the biblio)


2025-07-04
[19:06:34.0220] <Ashley Claymore>
https://github.com/tc39/ecma426/blob/main/spec.emu#L157

[19:07:46.0318] <Ashley Claymore>
Source Map spec references W3C wasm


2025-07-06
[14:06:41.0936] <bakkot>
I hadn't realized that when node started doing automatic typescript type stripping they also exposed that functionality as an API

[14:06:56.0378] <bakkot>
that makes it pretty trivial to strip types when serving files

[14:07:32.0998] <bakkot>
which... I think eats most of the motivation for https://github.com/tc39/proposal-type-annotations ? at least the motivations I was aware of

[14:07:59.0587] <bakkot>
demo https://github.com/bakkot/buildless-ts-webapp


2025-07-07
[09:28:16.0359] <Rob Palmer>
That is a very cool project, bakkot:

It shows how many pieces of the puzzle are coming to allow TS and ESM to be used in a simple way. 

[09:30:02.0612] <ljharb>
it'd be cool to also describe/provide a variant that avoids the speed overhead that takes one of these apps and pre-transpiles it so that it still works

[09:30:21.0592] <Rob Palmer>
On the motivations for type annotations, the Node work demonstrates that runtimes can play a large part in the story of reducing developer friction. Deno/Bun also showed that earlier on. 

[09:31:19.0101] <Rob Palmer>
There are still some remaining gaps, such a browser debugging. Using the console/REPL with TS still isn't as frictionless as using JS. 

[09:32:30.0865] <Rob Palmer>
The other motivation was language coordination. Something Mark raised strongly in Feb 2025 during the post plenary session on type annotations. Monutes are available. 

[09:32:44.0225] <Rob Palmer>
* The other motivation was language coordination. Something Mark raised strongly in Feb 2025 during the post plenary session on type annotations. Minutes are available. 

[09:33:03.0494] <bakkot>
Fair point about language coordination, yeah

[09:33:41.0899] <bakkot>
myself I've always kind of been on the other side of that, because I like it when TS adds good syntax (`satisfies` etc) instead of trying to fit it into a pre-reserved syntax space

[09:34:53.0354] <Rob Palmer>
(Though I see the TS introduction of the new "erasableSyntaxOnly" tsconfig flag + TC39 advancement of the Stage 1 enum proposal as highly positive indications of all sides leaning in to attempts to coordinate already.)

[09:37:05.0424] <bakkot>
I actually have found that debugging ts-blank-space strip'd types is totally frictionless; do you just mean the bit where you can't copy-paste TS code into the repl? I think that would be adequately solved by having Chrome devtools ship swc

[09:48:29.0039] <Rob Palmer>
Yes, I mean copy-pasting into the REPL. And I agree that if we coordinate across the ecosystem to intercept all the places that JS is debugged so they implement these same type-stripping semantics, then from a user's perspective using TS should be pretty much as frictionless as JS.

[09:49:48.0459] <Rob Palmer>
(I.e. Chrome is not the only debugger) 


2025-07-08
[06:55:29.0062] <nicolo-ribaudo>
I wonder if we have a name for documents containing instructions for multiple parties in an ecosystem to coordinate on some shared agreed upon behavior...

[10:20:04.0318] <bakkot>
I definitely do not want typescript to have to go through a standards body to introduce new syntax, that is one of my main goals here


2025-07-11
[10:00:53.0925] <Chris de Almeida>
can someone from google please help me out with a delegate email address?  please DM if so

[10:01:35.0347] <Chris de Almeida>
* can someone from Google or Ecma please help me out with a Google delegate's email address?  please DM if so


2025-07-16
[01:35:29.0967] <Rob Palmer>
The next TC39 plenary is 28th-31st July.

___Reminder:___ The agenda advancement deadline is [July 18th 10:00 PDT](https://www.timeanddate.com/countdown/generic?p0=1440&iso=20250718T18&msg=TC39%20Submission%20deadline) which is just over two days away.

Please try to share all materials by this time so folk can carry out their pre-plenary reviews.

[10:04:53.0113] <Michael Ficarra>
does anyone mind if I replace GitHub usernames with real names on the agenda?

[10:05:31.0594] <Michael Ficarra>
it's hard enough remembering everyone's name, affiliation, and TLA, I don't want to also have to remember their GitHub usernames

[10:14:00.0113] <Chris de Almeida>
fine to do it for Ruben, but please reach out to `@styfle` before changing theirs -- they don't have their name listed publicly, and they may not want to use their real name on the agenda

[10:14:40.0043] <Chris de Almeida>
cc styfle ‚òùÔ∏è

[10:18:20.0271] <styfle>
I prefer `@styfle` since thats going to be the easiest way to identify me on github, matrix, x, etc

[10:21:09.0842] <Chris de Almeida>
if it's not for privacy reasons, it's preferable to use your real name in these contexts.  no pressure though üôÇ 

[10:21:27.0736] <Chris de Almeida>
* if it's not for privacy reasons, it's preferable and customary to use your real name in these contexts.  no pressure though üôÇ 

[10:21:36.0632] <styfle>
It is for privacy

[10:21:50.0586] <Chris de Almeida>
got it

[10:22:17.0364] <Michael Ficarra>
FYI, you're going to be recorded in the notes, associated with a TLA, and indexed in https://github.com/tc39/notes/blob/main/delegates.txt

[10:23:17.0606] <nicolo-ribaudo>
Come on all, a pseudonym is perfectly fine if it's the only way we refer to somebody. I never showed anybody a document proving that Nicol√≤ is my real name. There are multiple reasons to not use the actual name people have in their documents.

It only gets problematic when we refer to somebody as X in half places and Y in the other half

[10:23:44.0133] <Michael Ficarra>
@nicolo-ribaudo:matrix.org that's exactly the thing I'm worried about though

[10:24:17.0514] <Michael Ficarra>
because in the notes and (presumably) in-person we're going to refer to them as their real name, but we have the agenda listing their GitHub name

[10:25:00.0330] <Chris de Almeida>
we have precedent for both pseudonyms and mononyms.  Ecma needs to know their identity, but we technically do not.  ultimately this is up to the individual to decide, not us

[10:25:52.0569] <Michael Ficarra>
if it was separate for privacy reasons, the best thing would've been to list only the real name on the agenda (and notes, etc), and the public wouldn't be able to associate it with the pseudonym

[10:29:09.0246] <Michael Ficarra>
we have no precedent for using pseudonyms in the notes

[10:29:38.0694] <ptomato>
we certainly do in TG2

[10:30:44.0184] <Chris de Almeida>
we do actually. I will DM

[11:00:17.0404] <Michael Ficarra>
I want to be clear about what I'm asking: for each delegate, we're going to list some name in delegates.txt alongside a TLA, and I would like to refer to the delegate by that name or TLA in other formal contexts, such as the agenda and during plenary. I don't care whether it's their legal name or common name or a pseudonym made just for this purpose, just that it's used consistently. I think the issue here was that we don't yet have an entry in delegates.txt for @styfle:matrix.org and I had assumed that they were going to use the name submitted in the new delegate form. Apologies for jumping the gun here. We can continue the conversation, if needed, once we figure out what's going in delegates.txt.

[11:01:39.0477] <styfle>
I would like to use `@styfle` for public documents

[11:12:52.0683] <Michael Ficarra>
would you make a PR to delegates.txt?

[11:13:07.0084] <Michael Ficarra>
I hope the ordering enforcement handles `@` properly üò∞


2025-07-18
[17:01:03.0397] <styfle>
Well I realized I'm already in `fetch` https://github.com/whatwg/fetch/blob/main/fetch.bs

[17:01:15.0473] <styfle>
So here we go https://github.com/tc39/notes/pull/378

[17:12:50.0506] <bakkot>
reminder that the deadline to add things to the agenda for the coming meeting is in 17 hours

[17:13:07.0875] <bakkot>
currently it's pretty light

[19:36:56.0687] <styfle>
Added slides https://github.com/tc39/agendas/pull/1913

[22:56:18.0334] <bakkot>
awful lot of Slides TBD items still on the agenda

[22:57:41.0172] <bakkot>
general reminder that proposals looking to advance must link the supporting material by the deadline, in addition to being on the agenda. people need time to review things before the meeting.

[00:03:02.0237] <ljharb>
at least proposals trying to hit stage 2+


2025-07-23
[01:57:16.0619] <naugtur>
Slides for `new Global` https://github.com/endojs/proposal-new-global/tree/main/slides
some further clarifications pending. I'm new here, so any amount of kind feedback on what's worth adding/explaining will be appreciated.

[02:43:41.0640] <bakkot>
naugtur: for new proposals it's best to focus on the problem to be solved, rather than a particular solution 

[02:46:13.0762] <bakkot>
People may not remember Evaluators, so the comparison to that proposal isn't enough on its own

[10:26:41.0279] <TabAtkins>
naugtur: Yes to what bakkot said, tho I do generally see the obvious niceties of isolated test-runner or isolation environments. I don't understand how this has relevance to DSLs, tho, but that's the first bullet point on the motivation slide

[11:02:53.0070] <naugtur>
TabAtkins: the testrunner's API is the DSL in question - describe, it etc. - where the testing code is in a special global contour that should not be visible to the app sources being tested.

[11:07:01.0850] <TabAtkins>
Ahh, that's not what I usually think of when I hear DSL and evaluation contexts being mentioned together. Ok.


2025-07-24
[15:15:46.0598] <naugtur>
Is 5 min assigned to AsyncContext in the agenda a typo? It doesn't seem like the slides could be read that fast

[15:18:50.0823] <Andreu Botella>
I timed myself and it's not impossible

[15:19:37.0422] <Andreu Botella>
I did add a couple bullet points since then, but I think I can fit it in

[15:21:21.0891] <naugtur>
No discussion planned then

[15:22:25.0458] <Andreu Botella>
this was just an update on the work since the last plenary and our current plan aligns with the result of the brainstorming we did back then

[15:22:39.0478] <naugtur>
understood. 


2025-07-25
[10:29:50.0545] <Michael Ficarra>
it does mean the agenda's out of order though @abotella:igalia.com

[10:30:27.0454] <Michael Ficarra>
items with smaller timeboxes should be listed before other items at the same stage


2025-07-27
[15:25:38.0440] <Chris de Almeida>
draft schedule is up, see reflector issue for link:  https://github.com/tc39/Reflector/issues/565


2025-07-28
[09:44:43.0412] <Rob Palmer>
Hello all

[09:45:17.0081] <Rob Palmer>
We've posted a new TCQ Reloaded link on the Reflector.  Please can folk verify they have access.

https://github.com/tc39/Reflector/issues/565

(and do NOT post the TCQ link here)

[09:48:52.0403] <Jesse>
works for me!

[09:50:37.0076] <Rob Palmer>
Plenary begins in 9 minutes!

[09:54:03.0151] <Jesse>
looks like the notes google doc may need to be opened (normally it's available for edits right away, but I just found it to be read-only)

[09:54:19.0356] <Jesse>
* looks like the privs for the notes google doc may need to be changed (normally it's available for edits right away, but I just found it to be read-only)

[09:55:45.0267] <Rob Palmer>
permissions on the docs are fixed

[09:56:05.0237] <Jesse>
can confirm

[10:06:06.0514] <Michael Ficarra>
FYI the note taker has newlines

[10:06:11.0153] <Michael Ficarra>
the transcriptionist I mean

[10:06:14.0365] <Chris de Almeida>
new TCQ is not a complete rewrite.  it is a fork, main changes were to add abstraction to use with different infra, I think it's made containerized now.  shouldn't be much, if anything, in the way of feature diffs

[10:06:23.0982] <Chris de Almeida>
https://github.com/zalari/tcq/compare/bterlson%3Atcq%3Amaster...reloaded

[10:07:12.0365] <Chris de Almeida>
this should save us from some pain though:  

https://github.com/zalari/tcq/compare/bterlson%3Atcq%3Amaster...reloaded

[10:07:24.0397] <Chris de Almeida>
* this should save us from some pain though:  

https://github.com/bterlson/tcq/commit/6039a03d7c602f82af2203acc0e938cb59dd3a84

[10:08:48.0393] <ljharb>
the notetaker also double spaces after periods

[10:09:09.0429] <Aki>
regular expressions hide all sins

[10:10:57.0820] <ljharb>
not the irregular ones

[10:13:04.0941] <snek>
only commented out in the html... üòà

[10:13:11.0208] <nicolo-ribaudo>
Writing a different number of spaces each time so that a regexp cannot catch me

[10:13:43.0131] <Chris de Almeida>
get's the job done üòÑ

[10:13:57.0849] <Chris de Almeida>
the bad-linebreaks script will catch you

[10:14:05.0543] <Aki>
s/  / /g

[10:14:33.0749] <ljharb>
repeated replace-alls of `.  ` to `. ` will get you eventually

[10:15:12.0920] <Justin Ridgewell>
Regex has the power

[10:15:17.0535] <Chris de Almeida>
```

const reBadLinebreaks = /(?<=[\w\d \p{P}])\n(?=[\w\d ])/gu;
const reExtraWhitespaceParagraph = /^ +| (?= )| +$/gm;
const reExtraWhitespaceList = /(?<=^ {0,}[-*+] |\d+\. ) +|(?<=\w+ ) +| +$/gm;
```

[10:15:21.0141] <Chris de Almeida>
* ```
const reBadLinebreaks = /(?<=[\w\d \p{P}])\n(?=[\w\d ])/gu;
const reExtraWhitespaceParagraph = /^ +| (?= )| +$/gm;
const reExtraWhitespaceList = /(?<=^ {0,}[-*+] |\d+\. ) +|(?<=\w+ ) +| +$/gm;
```

[10:17:07.0991] <ljharb>
(consensys is metamask, in case you're like me and have never heard of the former)

[10:17:24.0599] <naugtur>
I'm always hesitating which one to put as company

[10:27:57.0798] <waldemar>
Curious to hear about the exciting new features in ECMA 404‚Ä¶

[10:28:30.0617] <ryzokuken>
"...features not found" 

[10:28:39.0464] <ryzokuken>
/me üèÉ

[10:41:55.0321] <Chris de Almeida>
https://github.com/tc39/code-of-conduct/issues/62

[10:47:10.0180] <Michael Ficarra>
I will start including a summary as my final slide

[10:57:23.0223] <naugtur>
And we could edit it on the spot as conclusions are reached.

[10:57:25.0552] <Michael Ficarra>
thank you very much for the presentation, this helped clarify what was expected from summary and conclusions

[10:58:56.0783] <Aki>
oh yay, i'm so happy to read that Michael Ficarra 

[10:59:45.0775] <saminahusain>
Thank you for the feedback.

[10:59:57.0224] <keith_miller>
https://github.com/tc39/ecma262/issues/3652

[11:02:43.0559] <nicolo-ribaudo>
naugtur It might be useful to screen-share https://tc39.es/ecma262/#sec-setfunctionname for Mark

[11:11:59.0319] <nicolo-ribaudo>
And highlight step 5.b.i :)

[11:12:00.0355] <naugtur>
Sorry, struggled to find where this notification came from 

[11:16:35.0740] <eemeli>
An explicit Annex B list seems like the best solution here.

[11:19:40.0358] <nicolo-ribaudo>
Chairs, if we end up having 20 minutes free before lunch I'm happy to do my 20m topic

[11:20:08.0115] <nicolo-ribaudo>
Oh well they are both 20m, I guess any of them

[11:38:02.0190] <ljharb>
um, i had the reloaded queue open and never saw any emoji

[11:40:57.0739] <naugtur>
nicolo-ribaudo: I'm wondering if this change could have impact on require(esm) in Node

[11:40:59.0795] <eemeli>
Heh, I saw the emoji but they went away when I switched out of my browser on Android in order to figure out what they meant.

[11:41:19.0519] <naugtur>
* nicolo-ribaudo: I'm wondering if this change could have impact on require(esm) in Node. Probably not as it's not supporting top level await

[11:44:14.0647] <nicolo-ribaudo>
Yeah this is only about dynamic import of TLA module graphs

[11:48:07.0131] <naugtur>
I feel like we should be seeing something else in screen share

[13:07:08.0773] <Michael Ficarra>
@softwarechris:matrix.org DJM is @dmitrymakhnev:matrix.org

[13:07:17.0019] <Michael Ficarra>
DJM and DLM both gave +1

[13:07:22.0758] <Chris de Almeida>
yep

[13:07:33.0874] <Chris de Almeida>
but DLM was incorrect in there as DM until I fixed it üôÇ

[13:12:17.0859] <TabAtkins>
So in favor of this, it's great

[13:31:23.0278] <Andreu Botella>
I thought this would be a first step, to then consider doing the same for set iterators and so on

[13:32:32.0125] <Michael Ficarra>
@abotella:igalia.com true, giving up on freezing and instead exploring the Array special-casing is ignoring how we could apply the freezing to other built-in iterators

[13:33:20.0997] <nicolo-ribaudo>
Chris de Almeida: I need to stop taking notes at the top of the hour, rather than when my topic starts as I said before

[13:35:07.0081] <Michael Ficarra>
spreading array literals happens more than you might think

[13:35:33.0338] <ljharb>
i would be surprised if arrays weren't many 9's of the things being spreaded

[13:36:01.0610] <Michael Ficarra>
we don't have an "optionally include this element" so it's common to spread `...(a ? [b] : [])` within an array initialiser

[13:36:06.0269] <kriskowal>
Our position at Agoric regarding initially immutable intrinsics is really subtle. When we create the HardenedJS environment, we don‚Äôt just freeze all of (what we call) Shared Intrinsics, but some of those intrinsics have to be changed, like `Date.now`, `Math.random`, so _in general_ we rely on the pervasive mutability of the language to enable language evolution. We do not believe the specific proposed change hinders us in building HardenedJS environments. But, for the evolution of the web, ‚ÄúEven the very wise do not know all ends‚Äù and pervasive mutability has been good actually, allowing us to plug all manner of holes.

[13:46:14.0683] <Michael Ficarra>
@keith_miller:matrix.org translate it back?

[13:47:04.0119] <ljharb>
see translationparty.com

[13:48:30.0247] <Aki>
ISO policy would theoretically cover Discourse. ISO's whole point (imo) boils down to "use LLMs all you want, just don't show your output to anyone"

[13:50:41.0199] <nicolo-ribaudo>
We can redact the notes before publishing them

[13:50:54.0861] <Michael Ficarra>
we saw that other venues are covering this behaviour in their CoC-equivalent policies, why wouldn't we?

[13:52:41.0929] <ljharb>
is the ISO's in a code of conduct? that's a very specific kind of document.

[13:54:04.0774] <Chris de Almeida>
I don't think so

[13:54:07.0918] <Michael Ficarra>
I think the ISO and ACM policies predate people calling these policies out as "CoC"

[13:54:36.0079] <Michael Ficarra>
but that's effectively what they are

[13:54:50.0170] <Michael Ficarra>
they govern your behaviour in your various interactions with those groups

[13:54:53.0139] <Chris de Almeida>
https://www.iso.org/publication/PUB100011.html

[13:56:46.0439] <ljharb>
so they have a coc, and the ai policy is in a different document

[13:58:26.0692] <kriskowal>
I have learned that people are avoiding em-dashes and Oxford commas in order for their manually-intelligent writing less resemble AI-generated content. Is their a sufficiently reliable criterion that distinguishes rude vs non-rude generative content?

[13:58:43.0219] <ljharb>
psh, you can pry my oxford comma from my cold dead hands

[13:58:49.0831] <Michael Ficarra>
you prefer having more than one document that governs committee interactions?

[13:58:58.0809] <kriskowal>
You have failed CAPTCHA.

[13:58:59.0061] <ljharb>
we already do. that's what "how we work" is

[13:59:15.0469] <ljharb>
* we already do. that's what "how we work" is, and the contribution guide, and a number of other things

[13:59:40.0912] <Michael Ficarra>
none of those warn of formal consequences if not followed

[13:59:53.0610] <ljharb>
nor need they, we can impose consequences any time we want, arbitrarily

[13:59:58.0502] <ljharb>
i don'

[13:59:58.0929] <kriskowal>
* I have learned that people are avoiding em-dashes and Oxford commas in order for their manually-intelligent writing less resemble AI-generated content. Is their a sufficiently reliable criterion that distinguishes rude vs non-rude ~generative~ content, regardless of whether it‚Äôs generated?

[14:00:07.0390] <ljharb>
* i don't need permission to hide someone's comments on my proposal repo, for example

[14:00:21.0426] <Michael Ficarra>
we should not do that, we should have a written policy of the things that will have formal consequences associated with them

[14:00:27.0991] <Michael Ficarra>
like a CoC

[14:00:28.0244] <ljharb>
the purpose of this phrasing is to establish a norm; it doesn't imbue us with any new capabilities

[14:00:39.0496] <ljharb>
* the purpose of this phrasing is to establish a norm that we can cite; it doesn't imbue us with any new capabilities

[14:01:26.0576] <Michael Ficarra>
somebody interacting with committee should have all the tools/info they need to make a contribution without worry that it will come with consequences

[14:01:27.0078] <ljharb>
* the purpose of this addition, wherever it lives, is to establish a norm that we can cite; it doesn't imbue us with any new capabilities

[14:01:29.0696] <Michael Ficarra>
such as by reading the CoC

[14:01:47.0689] <ljharb>
ok but that's a "should" you believe, it's not the current rule/policy, nor is it the case in basically any venue

[14:01:58.0823] <ljharb>
and the CoC is already not the sole place one must read

[14:02:00.0368] <ryzokuken>
if the idea is to moderate contributions from external folks on github and discourse i don't see why formally making it a part of our coc is necessary

[14:02:03.0016] <ljharb>
* and the CoC is already not the sole place one must read to gather that info

[14:02:10.0880] <Michael Ficarra>
it's not?

[14:02:25.0461] <ljharb>
no. the contributor guide is the primary place, and *that* links to the CoC

[14:02:39.0788] <Andreu Botella>
I can take over

[14:02:40.0048] <ljharb>
the CoC talks about comportment and demeanor. the contributor guide talks about how you contribute.

[14:02:42.0942] <Michael Ficarra>
violations of the contributor guide don't get you banned

[14:02:51.0864] <ljharb>
they absolutely could if they're repeated

[14:03:03.0258] <ljharb>
and we wouldn't ban someone for a single AI-generated contribution anyways

[14:03:04.0605] <Michael Ficarra>
no matter how much I'd like to ban someone who omits the Oxford comma

[14:03:46.0786] <ljharb>
the goal isn't to ban people, it's to establish norms so enforcement isn't practically needed in the first place

[14:04:05.0993] <ljharb>
the consequences aren't the point - the *explicit expectation* is the point

[14:04:42.0441] <ljharb>
for example, if my kids only behave because of consequences then i've not done a good job :-)

[14:05:02.0647] <ljharb>
* for example, if my kids only behave because of consequences then i've not done a good job :-) (which, to be clear, is empirically the case at times)

[14:05:56.0977] <Chris de Almeida>
to be clear, use of generative AI in a way that we have prohibited would 100% be subject to enforcement action via the CoC regardless of where the guidance/rules live

[14:14:07.0191] <Michael Ficarra>
where will this bikeshedding be happening? the same coc repo thread?

[14:15:10.0596] <Chris de Almeida>
that issue and the forthcoming PR with the proposed text

[14:28:03.0625] <naugtur>
nicolo-ribaudo: part of your long paragraph is really mixed up. couldn't save it

[14:28:31.0266] <nicolo-ribaudo>
I'll go through it, don't worry

[14:28:34.0169] <nicolo-ribaudo>
Thanks for the ping

[14:46:34.0359] <Andreu Botella>
let me fix my mic

[14:52:51.0986] <nicolo-ribaudo>
The whole presentation is already a summary :P

[14:55:50.0620] <nicolo-ribaudo>
Who volunteers to squeeze their 30min topic in the next 4 minutes?

[15:00:38.0362] <naugtur>
There were a couple moments where the transcriptionist would struggle to catch up and drop whole sentences. I think we could make a conscious effort to make a ~1 second pause after each outburst of content when one person is talking, especially with longer sentences where logic of the sentence is non-trivial.


2025-07-29
[05:59:24.0709] <styfle>
Are the meetings recording audio or video? Or is it just text transcripts?

[06:00:03.0917] <nicolo-ribaudo>
Just transcripts 

[07:23:22.0715] <kriskowal>
Yes, and my understanding is that individual presenters are welcome to ask the committee for permission to record their own presentations, but not the conversation about their presentation, and publish in their own venues. This happens rarely enough that I don‚Äôt feel bad reminding seasoned delegates. :-)

[09:53:43.0142] <ryzokuken>
@room we're starting in 7 mins!

[10:09:05.0595] <Michael Ficarra>
Rich Hickey created Clojure, Rich Harris created Svelte

[10:19:54.0046] <bakkot>
what if we just had an explicit "IsProxy"...

[10:20:07.0786] <bakkot>
I would also like to be able to tell if touching a random object in any way at all is going to have side effects

[10:20:15.0972] <bakkot>
I think that's a capability I should be allowed to have

[10:21:05.0061] <Michael Ficarra>
@bakkot:matrix.org you'll still have accessors to worry about

[10:21:19.0172] <bakkot>
I can tell if a non-proxy has an accessor

[10:23:25.0382] <Mathieu Hofman>
Where did nicolo-ribaudo 's AsyncContext question go ??

[10:24:21.0415] <Michael Ficarra>
people can delete their own TCQ items

[10:24:39.0483] <Mathieu Hofman>
I was interested in that question ;)

[10:25:23.0797] <Michael Ficarra>
you can always add it yourself

[10:25:27.0407] <nicolo-ribaudo>
I was going to say "Svelte will switch to AsyncContext rather than synchronously reading .then", but probably svelte moving away from it in a few years means that we'll never be able to assume everybody updated anyway 

[10:27:06.0327] <ljharb>
you know _i'm_ gonna love a `Promise.isPromise`

[10:27:30.0442] <Chris de Almeida>
no lies detected

[10:27:45.0483] <Justin Ridgewell>
styfle: I no longer have access to the private Vercel repos. Can you check if the AsyncLocalStroage polyfill I implemented for edge runtime usess a `.then` accessor?

[10:32:00.0512] <bakkot>
Mathieu Hofman: `Symbol.unthenable ` is _another_ lookup

[10:32:04.0917] <bakkot>
that's the opposite of the point

[10:32:31.0846] <nicolo-ribaudo>
4 hours on the last day all for this topic!

[10:32:50.0015] <Mathieu Hofman>
Right it'd require a non proxy check, and these to be non-configurable and non-writable, which is kinda meh

[10:33:07.0999] <bakkot>
just seems way worse than having an internal slot

[10:33:11.0660] <nicolo-ribaudo>
* 4 hours on the last day all for this topic! React with ü´† to vote in favour of this

[10:33:35.0892] <Mathieu Hofman>
I'd love a temp check on `Promise.isPromise` see if it'd be viable to bring as a proposal

[10:34:12.0863] <naugtur>
Would it also have `Promise.isThenable` ?

[10:34:21.0958] <bakkot>
you can sort of build it already by adding a `.constructor` t othe object

[10:34:31.0159] <bakkot>
* you can sort of build it already by adding a `.constructor` getter to the object and then `await`ing it

[10:34:38.0466] <bakkot>
so... would be nice to have something better than that

[10:34:46.0877] <bakkot>
except no one is doing that afaict

[10:34:47.0258] <naugtur>
`assert(!Promise.isThenable({}))` would be a good first line of program code

[10:36:31.0352] <Mathieu Hofman>
To be clear I would use `Promise.isPromise` to build a safe `Promise.safeResolve` and `Promise.withSafeResolvers` that introduces an extra tick unless the objects is an unmodified native promise.

[10:36:38.0496] <Mathieu Hofman>
* To be clear I would use `Promise.isPromise` to build a safe userland `Promise.safeResolve` and `Promise.withSafeResolvers` that introduces an extra tick unless the objects is an unmodified native promise.

[10:37:42.0396] <Mathieu Hofman>
Why not `assert(!Object.getOwnProperty(Object.prototype, 'then'))` ?

[10:38:57.0202] <bakkot>
what if we changed the `in` operator to return `false` if there is a nonwritable-nonconfigurable `undefined`-valued data property

[10:39:11.0857] <mgaudet>
Whooooooops

[10:39:13.0712] <bakkot>
so that we could just make `Object.prototype.then` permanently undefined without breaking people doing `'then' in foo`

[10:39:21.0294] <naugtur>
My idea was to be future-compatible with a situation when there's a change to then on prototypes being ignored when considering a thenable

[10:39:44.0405] <ljharb>
my immediate instinct is that would break a ton of things in subtle ways

[10:39:57.0908] <Mathieu Hofman>
The TCQ queue didn't advance for me

[10:39:58.0175] <bakkot>
I bet it would be fine, that situation doesn't come up much

[10:49:59.0730] <Chris de Almeida>
still?

[11:09:57.0385] <Mathieu Hofman>
bakkot: did I capture your suggestion correctly regarding stack accessor being a closure? https://github.com/tc39/proposal-error-capturestacktrace/issues/1#issuecomment-3133528880

[11:10:15.0818] <bakkot>
yup

[11:22:13.0652] <rbuckton>
This is one of the reasons I pushed for `static {}` to be included in the same edition as private fields, so that they were more likely to be transpiled in the same step to avoid any intermediate static private fields.

[11:24:24.0907] <snek>
not that people *can* object to babel making changes...

[11:29:32.0783] <keith_miller>
I think TCQ is still on "Non-extensible Applies to Private status update"

[11:40:14.0982] <bakkot>
https://github.com/whatwg/webidl/issues/1487

[11:48:41.0054] <ryzokuken>
sorry for the TCQ hiccups everyone, we're taking note of every bug and issue and will finally have the chance to get all the fixes in by the next meeting thanks to the volunteers working on the fork 

[11:59:46.0807] <Aki>
Back on my notes reminder: also don't forget to go clean up your summaries and conclusions. If you spoke them, go in quick and make them into bulleted lists or otherwise clear and concise copy

[12:03:15.0423] <Aki>
As far as remembering to record your summaries and conclusions, I'll start reminding individual speakers (privately) tomorrow.

[12:58:45.0573] <Chris de Almeida>
we are restarting

[13:01:12.0126] <Andreu Botella>
I can take notes

[13:02:08.0764] <naugtur>
I could do the next 30 minutes, but then I'm off to sleep

[13:07:03.0188] <nicolo-ribaudo>
Idea: note taking duty falls on the delegates in the timezone of the meeting

[13:08:26.0170] <nicolo-ribaudo>
Love the slides telling me I gave feedback way too late, sorry Michael

[13:08:31.0782] <nicolo-ribaudo>
* Love the slide telling me I gave feedback way too late, sorry Michael

[13:10:29.0480] <nicolo-ribaudo>
Steve Hicks I think your topic is better as a reply to mine

[13:10:32.0771] <nicolo-ribaudo>
Since it seems to be the same

[13:10:49.0231] <nicolo-ribaudo>
* Since it seems to be the same concern I had in the issue

[13:21:29.0142] <ljharb>
should we do a temp check on the two options?

[13:21:52.0753] <ljharb>
* should we do a temp check on the two options? (2 methods vs param)

[13:23:49.0268] <Justin Ridgewell>
A required param would also suffice for this.

[13:24:49.0138] <ljharb>
true, but if the param is required then it of forces it to be a string for ergonomics, and because options bags are supposed to be for optional options

[13:24:54.0709] <ljharb>
* true, but if the param is required then it forces it to be a string for ergonomics, and because options bags are supposed to be for optional options

[13:26:24.0203] <Justin Ridgewell>
Sorry, I'm (badly) trying to be an impartial moderator

[13:26:52.0589] <nicolo-ribaudo>
Moderators are entitled to opinions! :P

[13:28:09.0761] <ljharb>
* true, but/and if the param is required then it forces it to be a string for ergonomics, and because options bags are supposed to be for optional options

[13:28:34.0463] <bakkot>
waldemar:  I really dislike the "with remainder" naming because it implies to me that it's like how `chunks` gives you a truncated final chunk even in the case that the input is longer than the chunk size (if it is not a multiple)

[13:29:45.0973] <ljharb>
why wouldn't we make the default "throw"?

[13:30:28.0122] <bakkot>
Michael Ficarra doesn't like throwing

[13:31:29.0926] <ljharb>
i love throwing

[13:31:49.0756] <nicolo-ribaudo>
I'd very much prefer to make it required than do "throw"

[13:32:01.0547] <nicolo-ribaudo>
Throw is an exception that depends on the shape of the input, rather than on how you are using the API

[13:33:44.0117] <sffc>
Can we do a TG5 study to help with this? Seems like something easy to write research questions for

[13:34:25.0117] <bakkot>
we have lots of exceptions that depend on the shape of the input? that's totally normal

[13:34:33.0026] <Andreu Botella>
same

[13:34:42.0696] <Chris de Almeida>
sorry...

[13:34:46.0694] <bakkot>
"this input is too small to handle the outputs you asked for" is a very normal case for throwing

[13:36:04.0035] <nicolo-ribaudo>
Well it doesn't mean that it's good -- it's for example common to forger that if you don't pass the second argument with .reduce it could throw, and you forget to test the empty array case

[13:36:09.0876] <nicolo-ribaudo>
* Well it doesn't mean that it's good -- it's for example common to forget that if you don't pass the second argument with .reduce it could throw, and you forget to test the empty array case

[13:36:44.0897] <bakkot>
well, sure, but that's still the right behavior for that method

[13:37:31.0199] <bakkot>
bad inputs are a fact about the world and throwing on them is usually the best option

[13:37:40.0854] <bakkot>
the problem isn't the API, it's the bad input

[13:37:44.0579] <Michael Ficarra>
here, you can hang it on your wall

[13:57:39.0002] <Michael Ficarra>
we literally just advanced "upsert" to Stage 3, I don't think we have much of an appetite for renaming proposals

[13:58:05.0781] <Michael Ficarra>
that's why it's important to name your proposals appropriately (focusing on the problem statement) from the beginning

[13:58:43.0320] <bakkot>
in fairness the problem statement here is also reduced from the original

[13:58:56.0533] <Aki>
wasn't upsert reduced as well?

[13:59:08.0344] <bakkot>
true

[14:16:35.0908] <Jesse>
FYI we essentially agreed to drop `currency` https://github.com/tc39/proposal-measure/pull/44

[14:17:05.0882] <Jesse>
(so the slides are technically up-to-date but don't quite reflect current thinking among those working on these ideas)

[14:30:44.0463] <bakkot>
I am curious if anyone else shares my concern about this not being super well-motivated as a language feature

[14:32:27.0696] <sffc>
About internal slots: the Temporal proposal looks at slots in order to choose a formatting code path in Intl.DateTimeFormat: https://tc39.es/proposal-temporal/#sec-temporal-handledatetimevalue

[14:33:31.0180] <bakkot>
is that AO called on arguments, or just the receiver?

[14:33:40.0492] <bakkot>
I guess presumably arguments given it's DateTimeFormat

[14:33:56.0796] <sffc>
And it looks like it reads the inner `[ISODate]` slot to figure out what to actually render

[14:33:58.0637] <ljharb>
i think we can just presuppose that internal slots aren't accessed on arguments of prototype methods

[14:34:17.0165] <sffc>
This is in `Intl.DateTimeFormat.prototype.format`, when passing a Temporal instance

[14:34:18.0668] <ljharb>
but for a true slotted object, an implementation would presumably be able to have a fast path

[14:35:12.0110] <kriskowal>
I like the idea of having a precedent-setting example of the protocol needed by Intl, and also like having ‚Äúbig decimal‚Äù, such that ‚Äúdecimal‚Äù might strictly show up as a typed array view, as is consistent with uint64 being reified as bigint.

[14:35:12.0167] <sffc>
IIRC, the champions proposed this shape for Intl.DTF so that we could use fast paths and avoid calling user code

[14:36:08.0244] <bakkot>
the usual pattern in Temporal, which I assumed would extend to Intl.DTF, is to check for the slots but fall back to reading properties if the slots are not present https://tc39.es/proposal-temporal/#sec-temporal.plaindatetime.from

[14:36:48.0662] <kriskowal>
Thanks for noting that. It does suggest an impasse.

[14:37:34.0988] <kriskowal>
I‚Äôll run this by Mark.

[14:39:08.0117] <TabAtkins>
We could have a built-in class *and* a same-shaped protocol, and fast-path the built-in one, yeah.

[14:40:42.0482] <kriskowal>
My intuition is that inspecting internal slots and falling back to properties would settle the issue for purposes of membrane transparency, but pending response from MarkM.

[14:41:04.0048] <bakkot>
it's _technically_ not transparent in that you can take an instance of the built-in class and define own getters which make the observable properties different from the internal slots, and then a Proxy for that will not behave like the thing itself, but like... whatever

[14:42:25.0099] <kriskowal>
Aye. I‚Äôm still absorbing how far the goalpost of ‚Äúpractical‚Äù in ‚Äúpractical membrane transparency‚Äù can move. I suspect that this is practical.

[14:43:31.0929] <bakkot>
might be worth extending Intl.DTF to do the same thing, if practical

[14:44:17.0660] <Justin Ridgewell>
Could I use this to tell if I have a Proxy wrapped object?

[14:44:35.0905] <Justin Ridgewell>
Re: promise.then proposal suggestion about not impacting objects without a .then property

[14:44:57.0413] <nicolo-ribaudo>
No, it would look like a plain object with the same shape but no internal slot

[14:45:20.0493] <nicolo-ribaudo>
It would look like a polyfilled version

[14:45:23.0244] <Justin Ridgewell>
Yah, but I could set an accessor for the field and see if it's accessed?

[14:45:38.0175] <bakkot>
it would be accessed for both a proxy and a plain object

[14:45:55.0931] <bakkot>
this allows you to distinguish a Proxy for a Temporal object from a non-Proxy'd Temporal object

[14:46:04.0239] <bakkot>
it does not allow you to identify arbitrary Proxies

[14:46:33.0220] <bakkot>
and all the methods which look at the slot on their `this` also distinguish a Proxy for a Temporal object from a non-Proxy'd Temporal object

[14:46:42.0456] <bakkot>
so it's not a new capability

[14:47:19.0156] <Justin Ridgewell>
Wouldn't the method invoke on it's target? Usually this is a throw when invoking on a non-instance directly.

[14:47:44.0276] <nicolo-ribaudo>
Justin Ridgewell could you maybe convert Jordan and my topics as replied to the current topic?

[14:47:45.0752] <bakkot>
right, and "non-instance" here includes "proxy for an instance"

[14:47:51.0334] <nicolo-ribaudo>
* Justin Ridgewell could you maybe convert Jordan and my topics as replies to the current topic?

[14:48:18.0700] <Justin Ridgewell>
Done

[14:54:11.0351] <ljharb>
+1 to justin

[14:54:33.0027] <ljharb>
* +1 to justin, sigfig shrinkage only

[14:55:23.0506] <ljharb>
oh hm, that's also a good point for currency from waldemar, i now hold contradictory beliefs

[14:56:03.0465] <Andreu Botella>
can we create a new Amount with additional significant digits?

[14:56:42.0472] <ljharb>
that seems reasonable regardless because it's explicit

[14:58:12.0375] <waldemar>
Is there any potential for future ambiguity where the same string can be both a unit and. currency?

[14:58:38.0826] <nicolo-ribaudo>
I _think_ in unicode all units are lowercase, and we could say all currencies are uppercase

[15:04:10.0342] <Jesse>
that's right

[15:04:20.0614] <Jesse>
lots of discussion, please do file issues!

[15:04:38.0236] <Chris de Almeida>
https://github.com/tc39/proposal-measure/issues

[15:05:07.0201] <Chris de Almeida>
also note:  #tc39-decimal:matrix.org 

[15:05:16.0373] <Jesse>
currently Amount is agnostic about this; only in Intl.NumberFormat, configured to render an amount as currency or as a unit, would we throw

[15:05:45.0994] <mgaudet>
 kWh? 

[15:05:47.0185] <Jesse>
so e.g. `new Amount(5, { unit: "eur" })` is fine from Amount's point of view, but Intl.NumberFormat would complain if you pretend that "eur" is a currency

[15:06:23.0070] <nicolo-ribaudo>
> <@mgaudet:mozilla.org>  kWh? 

I mean K too, but Unicode writes them out the long way lowercase rather than abbreviated

[15:06:24.0662] <Jesse>
we're looking mainly at this for inspriation: https://github.com/unicode-org/cldr/blob/main/common/supplemental/units.xml

[15:06:56.0854] <mgaudet>
Ahh, I follow now

[15:07:10.0092] <Andreu Botella>
how does Unicode write GiB

[15:07:29.0081] <Jesse>
I think the question is settled by just removing the currency option? https://github.com/tc39/proposal-measure/pull/44

[15:08:00.0222] <Jesse>
`kilowatt-per-hour`

[15:08:31.0015] <Jesse>
there's also compound units like `kilowatt-hour`

[15:09:11.0726] <eemeli>
In https://tc39.es/ecma402/#sec-currency-codes we have an existing dependency on ISO 4217, which states that currency codes are canonically uppercase. And we can (and should!) explicitly require upper-case currency codes in Amount.

[15:10:53.0718] <Jesse>
you can create an amount from e.g. a string, query the significant digits, and then use the `with` method to create a new amount with the same underlying mathematical value but with more significant digits

[15:11:03.0318] <Jesse>
(IIUC)

[15:14:49.0119] <Jesse>
I think nicolo-ribaudo suggested having an option for banning more significant digits than exist in the original value?

[15:15:16.0144] <nicolo-ribaudo>
Nope

[15:20:42.0180] <sffc>
On the ToIntlMV question: I did some archaeology for where it came from. It was discussed in the November 2022 and January 2023 TC39 meetings, in the following PR. It does not appear that I specifically asked waldemar to review the PR, which in hindsight would have been a good call. https://github.com/tc39/proposal-intl-numberformat-v3/pull/128#issuecomment-3134230756

[15:38:00.0623] <Justin Ridgewell>
eemeli: Given the objection to Amounts proposal, do we still need the continuation for Trailing Zero's 2.7 discussion?

[15:39:01.0822] <Justin Ridgewell>
If we don't, then we could possibly fit all items into tomorrow's timeslots and wrap up on Day 3.

[15:40:45.0523] <eemeli>
Yes, I would still very much like a continuation for keep-trailing-zeros. As I understood it, during the Amount discussion we were able to identify that waldemar's blocking concern for it is beyond its scope, and ought to be addressed separately. So I'm interested in seeing if sffc has time to review the spec still during this meeting, so that it might advance to 2.7.

[15:41:32.0314] <eemeli>
* Yes, I would still very much like a continuation for keep-trailing-zeros. As I understood it, during the Amount discussion we were able to identify that waldemar's blocking concern for it (in ToInltMathematicalValue) is beyond its scope, and ought to be addressed separately. So I'm interested in seeing if sffc has time to review the spec still during this meeting, so that it might advance to 2.7.


2025-07-30
[18:00:11.0037] <styfle>
Is it too late to change this for tomorrow? https://github.com/tc39/agendas/pull/1932

[18:08:51.0297] <Michael Ficarra>
it's not too late, but people may block advancement to 2 based on late notice

[18:14:42.0615] <Michael Ficarra>
at this point, there's not much point in updating the agenda though, it's virtually the same as just springing it on people during your agenda item

[09:53:17.0536] <ryzokuken>
@room starting in 7 mins!

[10:04:00.0553] <nicolo-ribaudo>
Wow this note taker is excellent

[10:07:35.0637] <nicolo-ribaudo>
And I fix a mistake they make, they see it, and they write it correctly the next time

[10:08:46.0897] <nicolo-ribaudo>
What, Ujjwal said "Shane" and the person wrote "SFC"???

[10:09:36.0322] <Aki>
!! amazing

[10:10:11.0083] <Jesse>
I've also seen that before; I wonder if it's in part due to being early in the day

[10:11:42.0725] <bakkot>
note taker was doing it yesterday too

[10:11:49.0936] <bakkot>
I was very impressed

[10:12:19.0720] <Zb Tenerowicz (ZTZ/naugtur)>
this week's notetaker can even recognize speakers by voice (saw that yesterday)

[10:15:14.0978] <nicolo-ribaudo>
They are just adding attributions by themselves, it's impressive I good they are

[10:15:24.0256] <nicolo-ribaudo>
I'm basically just reading the notes instead of fixing things

[10:16:33.0253] <Chris de Almeida>
this is great feedback, and also feedback we can provide to the service, which helps them as well

[10:17:03.0360] <Chris de Almeida>
and it's always nice to hear about good things about the transcription since (understandably) usually if we get any feedback, it's negative

[10:17:19.0052] <ljharb>
(there's still hard wraps in the middle of a paragraph tho, and still double spaces after punctuation) otherwise tho it is quite excellent

[10:17:34.0189] <ljharb>
* (there's still hard wraps in the middle of a paragraph tho, and still double spaces after punctuation, which are fixable later) otherwise tho it is quite excellent

[10:17:41.0897] <Chris de Almeida>
ü§´ shhhh.... no tears now.  only dreams

[10:20:43.0062] <Chris de Almeida>
it appears that someone copy/pasted the day 2 attendee list into day 3.  please don't do that

[10:23:25.0284] <Chris de Almeida>
I have removed from the day 3 list those who are not in attendance

[10:24:38.0300] <snek>
not anything against this proposal in particular but i feel like conditional advancement is really becoming popular lately 

[10:25:00.0172] <snek>
not sure if its a good or bad thing. good to get more velocity i guess.

[10:26:07.0251] <ljharb>
it's reduced bureacracy and plenary time

[10:27:50.0422] <ryzokuken>
basically it saves the plenary 5-10 mins (of us coming back in two months) and saves us anywhere from two months to a few weeks.

[10:29:23.0069] <ryzokuken>
honestly it doesn't change much practically but now we can pretty much start writing tests right away with the understanding that any remaining questions would likely be editorial in nature. If there was indeed a high chance of changes it'd have been irresponsible to ask for conditional advancement, so this is basically what helps me decide 

[10:29:36.0162] <ryzokuken>
* honestly it doesn't change much practically but now we can pretty much start writing tests right away with the understanding that any remaining questions would most likely be editorial in nature. If there was indeed a high chance of changes it'd have been irresponsible to ask for conditional advancement, so this is basically what helps me decide 

[10:31:13.0089] <nicolo-ribaudo>
kriskowal: You'll need to edit the notes because the transcriber is too good now so all of the pronounciations have been replaced by ZTZ

[10:33:47.0997] <bakkot>
so, how do we feel about this being based on `eval`

[10:34:07.0629] <bakkot>
I would feel more positively about a proposal in this vein based on module expressions

[10:34:41.0955] <nicolo-ribaudo>
Would it be with a method on the global "run this module expression"?

[10:34:50.0606] <bakkot>
yeah basically

[10:34:55.0364] <Mathieu Hofman>
I don't think the proposal is based on eval, it simply deals with the fact evaluators exists in the language

[10:35:14.0646] <bakkot>
the proposal literally only provides new mechanisms if you are using `eval`

[10:35:23.0184] <nicolo-ribaudo>
I vaguely remember talking with you about not having more paths to evaluation, a method to evaluate a module might be one

[10:35:45.0445] <bakkot>
or rather, module expressions are syntax, but it would be "run this module source" and then have module expressions which evaluate to module sources

[10:35:46.0734] <Mathieu Hofman>
if you can evaluate a module expression in a new Global, you need to ensure the evaluators in available in there don't let you evaluate in the original global

[10:36:39.0884] <bakkot>
sure, I am open to considering which ancillary features would be necessary to make my suggestion work

[10:36:51.0607] <bakkot>
but the proposal as is is _only_ about evaluators

[10:37:56.0801] <Mathieu Hofman>
Having a mechanism to trigger evaluation in a new Global being based on ModuleSource without requiring an `eval` call does make sense.

[10:38:31.0594] <Mathieu Hofman>
The proposal is about adding a level of indirection between Realm and the Evaluation Context

[10:38:48.0631] <Mathieu Hofman>
evaluators are the visible side effect of that

[10:38:57.0772] <Ashley Claymore>
`import(module { ... })`

[10:39:12.0964] <nicolo-ribaudo>
This doesn't work on a different global, because import is not a property of it

[10:40:04.0820] <nicolo-ribaudo>
From this past slide it looks like indeed there is a need for evaluting sources, since it's exactly what it did with `eval("s => import(s)")`

[10:40:10.0886] <snek>
wouldn't we need a watchdog api for this to handle untrusted input

[10:40:31.0258] <Mathieu Hofman>
whatchdog ?

[10:40:41.0735] <snek>
like "run code with timeout"

[10:40:48.0686] <bakkot>
also the proposal as is still lets you do `[].constructor.constructor('whatever')` so... I just don't understand that argument at all

[10:40:49.0075] <snek>
otherwise you can do while (true) {}

[10:42:06.0412] <Mathieu Hofman>
Sure, and? you're running code in the same agent. ShadowRealm does not have any availability guarantee. This is not pretending to add any such guarantee either.

[10:42:22.0888] <snek>
well i'm just replying to "run untrusted code"

[10:42:28.0749] <snek>
as a general concept

[10:42:37.0458] <snek>
which seems like a dangerous goal if you don't solve dos somehow

[10:42:51.0278] <Mathieu Hofman>
As was mentioned first, this proposal is the necessary minimum for sandboxing, it is not sufficient, and user land has other work to do if sandboxing is the goal

[10:43:10.0197] <bakkot>
ok but then why can't that work be like "replace `eval` and Function"

[10:44:05.0516] <Mathieu Hofman>
Because there is no way to create in userland an eval and Function implementation that work with that new Global

[10:44:14.0216] <bakkot>
right but why do you want that

[10:44:22.0259] <bakkot>
why are we concerned about providing new facilities for using `eval`

[10:44:25.0126] <bakkot>
just don't use `eval`

[10:44:47.0286] <Mathieu Hofman>
because those are part of the language? Why do you want to remove them? they exist in a global today

[10:45:32.0649] <bakkot>
in practice they do not exist because almost all frontend code is or ought to be written on the assumption that it will be running in an environment in which CSP forbids use of `eval`

[10:45:36.0486] <nicolo-ribaudo>
bakkot is this specifically about `eval`, or in general about the concept of "running some code with a different global context"? like the module expression solution you suggested earlier

[10:45:45.0575] <bakkot>
`eval` (and friends)

[10:45:50.0157] <bakkot>
string-based evaluation

[10:45:57.0926] <Mathieu Hofman>
Ok and CSP would keep applying here, so I don't understand the concern

[10:45:58.0312] <nicolo-ribaudo>
It seems to me like eval here is not the goal but just the tool identified to reach it

[10:46:02.0556] <bakkot>
running code in a different global context is a reasonable idea as long as that code doesn't come from strings

[10:46:26.0456] <bakkot>
the concern is, why is this proposal going to a bunch of effort to provide new ways to use `eavl`

[10:46:28.0360] <bakkot>
* the concern is, why is this proposal going to a bunch of effort to provide new ways to use `eval`

[10:46:34.0683] <bakkot>
I do not want to provide new ways to use `eval`

[10:46:39.0118] <nicolo-ribaudo>
heh, to implement a module system at some point you need to read a file and turn that into runnable code

[10:46:48.0922] <bakkot>
the host can do that for you though!

[10:47:23.0206] <Jesse>
`chmod +x file` boom

[10:47:26.0745] <Ashley Claymore>
`import.source`

[10:47:32.0235] <snek>
>the host will save you from getting code from strings
>look inside the host
>getting code from strings
/s

[10:47:43.0292] <snek>
* >the host will save you from getting code from strings
>look inside the host
>getting code from strings

/s

[10:47:51.0604] <snek>
* \>the host will save you from getting code from strings
\>look inside the host
\>getting code from strings

/s

[10:48:06.0011] <snek>
* \>the host will save you from getting code from strings 
\>look inside the host 
\>getting code from strings 

/s

[10:48:21.0617] <Ashley Claymore>
I bet it's using memory addresses too.
Wild

[10:48:33.0541] <snek>
element won't let me format this as proper green text aaaaaaaaa

[10:48:56.0268] <bakkot>
```
> try to greentext
> can't
```

[10:49:20.0077] <snek>
so true

[10:57:38.0165] <nicolo-ribaudo>
bakkot Fyi many people working on modules agree with your point  about the import hook, but it's a psot-stage-1 thing

[10:58:36.0659] <nicolo-ribaudo>
* bakkot Fyi many people working on modules agree with your point  about the import hook, but it's a post-stage-1 thing

[11:03:38.0807] <nicolo-ribaudo>
Without eval you wouldn't be able to load existing CommonJS-based libraries, right?

[11:03:42.0275] <nicolo-ribaudo>
CommonJS depends on eval

[11:03:55.0459] <ljharb>
how does it depend on eval

[11:04:06.0305] <ljharb>
i mean in node it's an implementation detail

[11:04:14.0666] <nicolo-ribaudo>
How would you implement it without eval?

[11:04:16.0559] <ljharb>
and in browsers via bundlers it doesn't rely on eval

[11:05:05.0441] <nicolo-ribaudo>
I mean this whole proposal can be replaced with a build step, replacing all global references `thatThing` with `myCustomGlobal.thatThing`

[11:05:06.0582] <ljharb>
i don't consider "let the engine evaluate it outside of JS" eval, so you'd modify the source and give it to the engine

[11:05:26.0409] <ljharb>
"eval" in this context imo is `eval` and `Function` and `setTimeout` strings etc

[11:05:30.0573] <snek>
how do you give it to the engine without eval

[11:05:54.0003] <ljharb>
the engine isn't using javascript `eval`, so it's not eval :-)

[11:06:04.0153] <ljharb>
obviously it's turtles all the way down but that's not relevant

[11:06:17.0108] <snek>
so some new thing called ScriptSource or something

[11:06:20.0307] <snek>
instead of eval 

[11:07:15.0490] <ljharb>
inside node it could be done in C++ or something, the point is that user JS code wouldn't be doing the string evaluation

[11:20:23.0851] <nicolo-ribaudo>
The fact that this shares all the globals, unlike Node.js's VM, doesn't really make it seem like a sandbox to me

[11:21:46.0364] <ljharb>
it's confusing to me that it shares a % of globals that's not zero and not 100

[11:22:10.0219] <bakkot>
I mean the whole point of it is evaluating things in a way that they can't see some of your stuff

[11:22:19.0201] <bakkot>
that sounds like a sandbox to me

[11:23:09.0536] <nicolo-ribaudo>
But it doesn't hide your stuff by default, at all

[11:23:13.0621] <rekmarks>
IMO, people confuse Node's vm module for a sandbox because it's called "VM", which is something used for sandboxing. I don't see why a JavaScript developer would assume that "an API that creates a new global object" would function as a sandbox, nor do I think that its potential / off-label use as a building block for an actual sandbox makes this more likely.

[11:23:36.0642] <bakkot>
right but that is literally the whole point of it

[11:23:59.0881] <bakkot>
there is no reason to use this unless you care about being able to evaluate code in a way that it can't see some of your stuff

[11:26:00.0315] <nicolo-ribaudo>
Or to run some code that sees _more_ stuff, like you have a file expecting a given global to be available (`regeneratorRuntime`? üëÄ) but you don't want to actually make that global globally available just because of one bad library

[11:27:35.0340] <bakkot>
sure, I guess

[11:27:36.0682] <snek>
creating new environments to run code that isn't untrusted is a valid use case

[11:27:45.0504] <snek>
and doesn't require a sandbox

[11:27:49.0423] <snek>
i agree its a footgun though

[11:28:14.0145] <snek>
* creating new environments to run trusted code that expect a different runtime environment is a valid use case

[11:31:32.0238] <snek>
hm something i do wonder. agoric's security model currently requires actively analyzing every proposed change to the language to see whether it would break it. if we are adding this functionality to replace compartments/etc, are we increasing the surface area that requires this active approach? or reducing it? compared to stronger apis that actually guarantee isolation.

[11:31:48.0279] <nicolo-ribaudo>
Zb Tenerowicz (ZTZ/naugtur): kriskowal Would the champions be ok with the problem statement roughly as worded by Kevin?

[11:32:51.0713] <dminor>
Sorry to cut that off, I'm sure we'll find time to continue this plenary. I just want to make sure Steven gets his full time slot.

[11:33:10.0649] <bakkot>
I think of import hooks as being motivated completely independently of the "new global" thing, personally, so I am happy to hear they're different proposals

[11:38:19.0063] <Michael Ficarra>
oof is snek's TCQ entry PoO worthy?

[11:38:29.0211] <snek>
i wasn't really sure

[11:38:37.0904] <nicolo-ribaudo>
Michael Ficarra It's in the same class as the json modules proposal

[11:39:01.0056] <Michael Ficarra>
let's just make sure we address it before the rest of the queue

[11:41:48.0950] <bakkot>
eemeli: I also like `type: "text"` but I think it would have to be its own proposal, with its own motivation

[11:43:24.0782] <Michael Ficarra>
@eemeli:mozilla.org you'd need an encoding

[11:43:29.0211] <snek>
i feel aesthetically displeased with gradually adding all this stuff to modules but we can't do it properly like `include_bytes!` in compiled languages so maybe it's ok to put it in modules...

[11:43:50.0296] <bakkot>
no it would just be utf8

[11:43:54.0606] <bakkot>
everything on the web assumes utf8

[11:44:06.0949] <Michael Ficarra>
WTF-8?

[11:44:30.0255] <bakkot>
well, something like that anyway

[11:44:37.0877] <bakkot>
like TextEncoder doesn't provide any other encodings, etc

[11:44:45.0930] <nicolo-ribaudo>
Just add a second attribute for encoding /s

[11:44:52.0309] <bakkot>
if you want something else you have to import bytes and do your own transcode 

[11:44:53.0879] <eemeli>
Yeah, I only want utf-8

[11:45:05.0748] <snek>
this is decoding not encoding. and TextDecoder does support more encodings

[11:45:45.0252] <bakkot>
... huh, for some reason I thought it didn't

[11:45:51.0381] <bakkot>
I guess I was just thinking of Encoder

[11:45:53.0184] <snek>
TextEncoder only supports utf8

[11:45:54.0207] <snek>
yeah

[11:46:24.0102] <snek>
happy to leave that can of worms to a separate proposal though :>

[11:51:58.0728] <nicolo-ribaudo>
Getting my point off the queue to not waste the timebox with process, but I think we are the right venue here. Unlike CSS modules, Uint8Arrays are something that _we_ provide. And unlike WinterTC, this is very much also important (especially?) on non-web-like runtimes

[11:52:07.0909] <Michael Ficarra>
thanks for the great responses to my query, they have made me feel a lot better about this proposal

[11:52:37.0124] <nicolo-ribaudo>
What we would be doing, however, is only saying "if there is this import and it does not fail, it must result in a Uint8Array". How that actually happens would be host-defined, because we don't deal with I/O

[11:53:05.0782] <bakkot>
but also in practice I think ~all hosts which support imports would want this

[11:53:18.0714] <bakkot>
unless they have something bespoke going on where you can only import a specified set of built-in modules or something

[11:53:42.0105] <snek>
`import "node:fs" with { type: buffer }`

[11:54:00.0019] <bakkot>
:D

[11:54:16.0680] <nicolo-ribaudo>
That's to get fs API with Node.js Buffer instead of Uint8Arrays for reading files

[11:56:49.0633] <ljharb>
tbh we're (or would have been) the right venue for a *lot* of the things that browsers and server runtimes have added over the years

[11:57:04.0228] <bakkot>
I still have some faint hope that we can steal some of them

[11:57:08.0905] <bakkot>
like TextEncoder

[11:57:24.0174] <snek>
we can steal TextEncoder as part of type: text

[11:57:44.0798] <Michael Ficarra>
do we need a process document reading?

[11:57:53.0582] <snek>
and then engines will be forced to implement it which means we can write proper optimizations for it üò≠

[12:00:32.0757] <ljharb>
did notes stop?

[12:00:43.0903] <Michael Ficarra>
no I see them

[12:00:49.0738] <Justin Ridgewell>
bakkot: I sent you a DM, but Matrix's UI is horrible for new chats and I don't know if you've seen it.

[12:00:56.0557] <ljharb>
hm i see "EAO:  I fig my luck.  So we can have stage one for this proposal but replacing" as the last bit

[12:01:15.0703] <ljharb>
nvm, a couple refreshes did it

[12:01:17.0485] <Michael Ficarra>
nope, refresh

[12:01:21.0691] <ljharb>
took like 5

[12:01:22.0925] <bakkot>
nope and it's not even hidden, there's just nothing there

[12:01:30.0047] <Chris de Almeida>
works on my machine!

[12:01:34.0317] <Michael Ficarra>
you always have to do 5 to be sure

[12:01:49.0625] <ljharb>
only way to be sure

[12:01:58.0586] <Justin Ridgewell>
You have to go to the "Home" tab in Elements to see it

[12:02:00.0036] <bakkot>
you can dm on twitter or bluesky I guess?

[12:02:05.0015] <ljharb>
ok so this did get stage 2, yes?

[12:02:07.0330] <Justin Ridgewell>
I have neither.

[12:02:11.0639] <Chris de Almeida>
yes

[12:02:19.0034] <styfle>
So it sounds like we basically want to revert this PR, correct? https://github.com/styfle/proposal-import-buffer/pull/7

[12:02:26.0789] <Chris de Almeida>
seems like it

[12:02:28.0864] <bakkot>
I did, nada

[12:04:47.0501] <nicolo-ribaudo>
Just use email folks

[12:05:07.0830] <Michael Ficarra>
the decision was a Uint8Array *backed by* an immutable ArrayBuffer IIRC

[12:05:08.0672] <nicolo-ribaudo>
> <@styfle:matrix.org> So it sounds like we basically want to revert this PR, correct? https://github.com/styfle/proposal-import-buffer/pull/7

We want to keep it immitable

[12:05:13.0497] <Justin Ridgewell>
We need something better than Matrix.

[12:05:38.0797] <nicolo-ribaudo>
> <@nicolo-ribaudo:matrix.org> We want to keep it immitable

An Uint8Array backed by an immutable array buffer 

[12:07:58.0720] <bakkot>
(but not itself a frozen object, i.e. people can still attach non-integer data properties)

[12:43:31.0875] <bakkot>
adding AI_POLICY.md as discussed yesterday: https://github.com/tc39/how-we-work/pull/164

[12:43:36.0748] <bakkot>
* adding AI\_POLICY\.md as discussed yesterday: https://github.com/tc39/how-we-work/pull/164

[12:43:42.0044] <bakkot>
* adding AI\_POLICY. md as discussed yesterday: https://github.com/tc39/how-we-work/pull/164

[12:58:23.0074] <Chris de Almeida>
we resume in < 2 mins

[12:59:06.0779] <Chris de Almeida>
cool people volunteer to help with notes.  YOU can be a cool person too!

[13:01:00.0779] <nicolo-ribaudo>
Damn I was hoping to get the day back

[13:01:24.0384] <ljharb>
fast advancement of all 4 proposals tomorrow would mean you have most of the day back ;-)

[13:05:35.0066] <Mathieu Hofman>
Justin Ridgewell: can you remove my unthenable comment, it wasn't fully serious or worth of the time

[13:06:16.0768] <Justin Ridgewell>
Done

[13:16:16.0698] <ljharb>
i like the idea of fixing certain algorithms, fwiw

[13:16:47.0905] <bakkot>
`Promise.resolveNotThennable`?

[13:17:06.0937] <bakkot>
`new Promise((res, rej) => {...}, true)`?

[13:17:09.0384] <Mathieu Hofman>
I consider the general approach between Justin and I to be the same, just with slightly different actual resolutions

[13:18:17.0039] <nicolo-ribaudo>
I like Justin's idea but I'd like it to be spec-internal, i.e. we somehow guarantee that the promise returned to the user does not resolve with a thenable

[13:18:41.0339] <nicolo-ribaudo>
Otherwise `.then(x => x)` will start changing what the promise resolves to

[13:19:08.0791] <Mathieu Hofman>
Which is why I prefer the tick delay approach, so it doesn't leak out as much to the user

[13:21:30.0561] <ljharb>
if there's no solution that prevents a promise resolving to a thenable, then might i suggest there's no solution?

[13:22:26.0874] <Chris de Almeida>
help wanted:  add a definition of `thenable` to https://github.com/tc39/how-we-work/blob/main/terminology.md

[13:22:58.0394] <Chris de Almeida>
related: 

https://github.com/tc39/ecma262/issues/2868
https://github.com/tc39/ecma262/pull/2869/files

[13:23:18.0991] <Andreu Botella>
WebIDL-defined methods can *take* promises, which currently accept thenables. AFAIK this is only ever used in `WebAssembly.instantiateStreaming`, since it's supposed to accept the return value from `fetch`, but there might be code in the wild passing thenables to that

[13:23:23.0937] <Mathieu Hofman>
Unless we change the definition of thenable to exclude the objects that are "unthenable" by internal slot

[13:23:51.0928] <Mathieu Hofman>
But then we also need a predicate to test for that

[13:24:09.0067] <ljharb>
but then wouldn't that break userland thenables?

[13:24:18.0732] <Andreu Botella>
* WebIDL-defined methods can _take_ promises, which currently accept thenables. AFAIK this is only ever used in `WebAssembly.{compile,instantiate}Streaming`, since it's supposed to accept the return value from `fetch`, but there might be code in the wild passing thenables to that

[13:24:25.0515] <ljharb>
because the check would then be `typeof x.then === 'function' && Promise.isPromise(x)`

[13:24:34.0480] <Mathieu Hofman>
unless they updated, yes

[13:24:41.0891] <ljharb>
like, it's actually a feature that userland thenables can exist, and i'd bet lots of code relies on it

[13:24:49.0718] <bakkot>
I think `respondWith` also takes a promise?

[13:25:00.0100] <bakkot>
https://w3c.github.io/ServiceWorker/#fetch-event-respondwith

[13:25:22.0899] <Andreu Botella>
oh, that's right

[13:25:46.0618] <bakkot>
(`waitUntil` is maybe a cleaner example)

[13:26:16.0338] <bakkot>
ugh I hate reading these specs, the prose is so imprecise

[13:28:01.0290] <bakkot>
anyway yeah it does `new Promise(r => r(argument))` https://webidl.spec.whatwg.org/#js-promise

[13:28:32.0907] <bakkot>
I think this is unlikely to be buggy though, web idl argument coercion very often executes user code anyway so algorithms are presumably robust to that

[13:29:35.0195] <Michael Ficarra>
this isn't TC39 jargon, it's on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#thenables

[13:30:03.0968] <bakkot>
our glossary can link MDN

[13:30:28.0620] <dminor>
Did we get Stage 2 reviewers for `import buffer`?

[13:31:34.0358] <Chris de Almeida>
no, and I blame whoever was chairing at the time, frankly

[13:31:48.0268] <nicolo-ribaudo>
No, I guess I can review though

[13:31:49.0467] <Chris de Almeida>
* no, and I blame whoever was chairing at the time, frankly  `/s`

[13:32:29.0327] <eemeli>
Who could help with renaming the `proposal-measure` repo as `proposal-amount`?

[13:32:57.0368] <Chris de Almeida>
`/voluntell @ljharb`

[13:34:34.0493] <ljharb>
on it

[13:35:20.0332] <ljharb>
* on it ‚Ä¶ done

[13:36:23.0754] <eemeli>
Thank you!

[13:39:27.0988] <sffc>
If there's time, it would be helpful to discuss Waldemar's Intl MV issue: https://github.com/tc39/ecma402/issues/1017

[13:42:37.0608] <ljharb>
so this was the new Global proposal, renamed to "proposal-module-global"?

[13:43:01.0213] <ljharb>
* so this was the new Global proposal, renamed to "proposal-module-global" that got stage 1?

[13:43:10.0277] <Zb Tenerowicz (ZTZ/naugtur)>
yes

[13:44:29.0030] <Aki>
germany-heavy showing there

[13:45:08.0974] <Chris de Almeida>
yes, confirmed this at the end of discussion

[13:45:20.0269] <Chris de Almeida>
timebox?

[13:45:51.0264] <sffc>
20m?

[13:52:08.0802] <ljharb>
heads up to those with conditional advancement: please DM or ping me on matrix when the conditions are met, so i can update the proposals table

[16:41:39.0944] <styfle>
In the meeting today, someone (I think nicolo-ribaudo) mentioned that Uint8Array is preferred and then citied something but I don't recall what document they were citing. Does anyone know?

[16:42:46.0406] <Andreu Botella>
I think it's https://www.w3.org/TR/design-principles/#uint8array


2025-07-31
[17:12:54.0999] <styfle>
Thanks! I updated the readme and transferred it to the org: https://github.com/tc39-transfer/proposal-import-bytes

[10:06:45.0296] <bakkot>
queue needs to be advanced I think

[10:06:47.0910] <Michael Ficarra>
reminder: add your slides links to the notes

[10:10:05.0718] <nicolo-ribaudo>
Does anybody have the link to share here?

[10:11:47.0025] <nicolo-ribaudo>
Also, I still see the queue at the notetakers item

[10:13:09.0467] <Justin Ridgewell>
I advanced the queue

[10:20:59.0183] <Chris de Almeida>
if this gets stage 2, don't let us forget to assign reviewers  üòá

[10:25:14.0892] <ljharb>
kevin, those don't cover symbols, only strings (re tcq)

[10:26:15.0424] <ljharb>
but if you mean the weird API design part, yes, and it's gross

[10:30:17.0069] <nicolo-ribaudo>
Are there use cases for having just the number of symbols?

[10:31:43.0431] <Michael Ficarra>
I like the -Length functions design

[10:31:48.0759] <nicolo-ribaudo>
The readme has a ton of links, last time I asked to write for the various links which option they are supporting, but it has not been done, so it's difficult to actually navigate through them

[10:32:42.0204] <kriskowal>
I like -Length and has- as a mnemonic pattern.

[10:32:54.0310] <nicolo-ribaudo>
I really struggle to imagine use cases other than for:
- count all properties
- count all enumerable properties

maybe with the matrix of "include all properties, or just string properties"

[10:34:08.0377] <kriskowal>
MarkM wrote a summary of property enumeration for our own edification at Agoric/Endo and I captured them for posterity here https://kriskowal.com/enumerating-properties/

[10:37:01.0871] <Michael Ficarra>
steal time from the other presentations?

[10:37:32.0569] <ljharb>
@erights Mark Miller (Agoric) MM: fwiw it does whatever you'd expect it to do on proxies, via the internal methods, just like the existing methods

[10:38:25.0827] <bakkot>
Ruben: assuming you mean https://github.com/tc39/proposal-object-property-count/issues/2#issuecomment-2784901702, almost all of those examples are devtools or otherwise not super relevant (like babel's object spread helper)

[10:38:38.0417] <Richard Gibson>
I don't think "whatever you'd expect" is coherent, because property keys are reported by one trap while property attributes are reported by another, so the two can disagree

[10:38:57.0807] <bakkot>
* Ruben: assuming you mean https://github.com/tc39/proposal-object-property-count/issues/2#issuecomment-2784901702, many of those examples are devtools or otherwise not super relevant (like babel's object spread helper)

[10:39:03.0255] <ljharb>
i mean, in terms of impact - babel's object spread helper alone is probably more beneficial to the web than many of the proposals we've advanced in the last couple years

[10:39:34.0542] <ljharb>
* i mean, in terms of impact - babel's object spread helper alone being made faster is probably more beneficial to the web than many of the proposals we've advanced in the last couple years

[10:39:46.0137] <bakkot>
the spread operator isn't doing a count, to be clear

[10:39:47.0800] <ljharb>
ah, ok fair. the current spec did make a choice, iirc it's calling "ownpropertykeys"

[10:39:51.0946] <bakkot>
it's actually spreading enumerable symbols

[10:39:54.0645] <ljharb>
ah k

[10:39:56.0694] <bakkot>
so it isn't relevant to this proposal

[10:41:10.0928] <Richard Gibson>
right, but that doesn't expose enumerability

[10:41:49.0478] <ljharb>
it has to get the property descriptor for each key as well, yep

[10:42:35.0726] <ljharb>
same approach as https://tc39.es/ecma262/#sec-object.getownpropertydescriptors, iirc

[10:42:52.0262] <bakkot>
I still like my "just add fooLength versions of all the foo methods" suggestion, which answers this trivially

[10:42:59.0465] <Richard Gibson>
so the question basically comes down to: what happens when `getOwnPropertyDescriptor` reports nonexistence of a key that was returned from `ownKeys`?

[10:43:25.0875] <ljharb>
the same thing that Object.getOwnPropertyDescriptors does - it skips it

[10:43:40.0772] <Ashley Claymore>
What happens is you know you've found a proxy 

[10:44:04.0301] <nicolo-ribaudo>
|             | **enmumerable** | **non-enumerable** | **all** |
| ----------- | --------------- | ------------------ | ------- |
| **strings** | ‚úîÔ∏è              |                    | ‚úîÔ∏è      |
| **symbols** | ?               |                    |
| **all**     | ‚úîÔ∏è              |                    | ‚úîÔ∏è      |

Fyi here the checkmark is for where I'm convinced that there may be a use case (the question mark is where I'm very little convinced but more than zero). I'd like to see examples showing that the usage of the rest is so widespread that it makes more sense to design an API to explicitly support it rather than just do the difference of the other two things in the same row/column.


[10:44:07.0375] <ljharb>
(tbh i'm not sure why it's important what happens with a misbehaving proxy as long as it accounts for it)

[10:44:15.0510] <nicolo-ribaudo>
Come on matrix

[10:44:35.0407] <nicolo-ribaudo>
Because a 3x3 matrix with only the corners filled in is just a complete 2x2 matrix

[10:44:38.0377] <ljharb>
i often need all symbols

[10:44:50.0355] <nicolo-ribaudo>
Can you show me one code example?

[10:45:16.0063] <bakkot>
I have ever needed all symbols but I don't think I've ever need the _number_ of all symbols

[10:45:58.0993] <ljharb>
true, the code example i was about to provide isn't getting the count, let me look more

[10:53:33.0148] <ljharb>
k well i can't actually find a case where i need the count of symbols and not the actual symbols themselves

[10:54:01.0815] <ljharb>
although if getting the count was much faster than getting the symbols themselves, i'd probably change a bunch of places to check the count first - that's a lot of "if"s tho

[10:57:06.0128] <Ashley Claymore>
`arr.toSliced()` will give you a dense array even if the original had holes

[10:57:39.0650] <Ashley Claymore>
oh no, not that one that my brain llm made up 

[10:57:42.0311] <Ashley Claymore>
The other ones 

[10:58:47.0995] <bakkot>
- Reflect.ownKeysLength
- Object.keysLength
- Object.getOwnPropertyNamesLength
- Object.getOwnPropertySymbolsLength

doesn't give you (string + symbol) x (enumerable) though I guess I would be open to a proposal for a new way to get _values_ for (string + symbol) x (enumerable), and then also have the `fooLength` version of that

[11:00:07.0689] <Richard Gibson>
that method doesn't exist, but `arr.toSpliced()` does

[11:00:28.0349] <ljharb>
`.slice()`

[11:00:41.0708] <Richard Gibson>
nope, `.slice()` preserves holes

[11:00:49.0903] <ljharb>
oh oof, ok

[11:01:09.0388] <ljharb>
`.flatMap(x => [x])` :-p

[11:01:39.0112] <ljharb>
so like, `Reflect.ownEnumerableKeys`?

[11:01:51.0943] <bakkot>
yeah sure

[11:03:02.0837] <Richard Gibson>
seeing those written out, I would prefer "count" rather than "length"

[11:03:07.0327] <snek>
`[...array]` kills holes right

[11:03:11.0835] <snek>
and ensures you have a real array

[11:03:19.0999] <snek>
all in one glorious expression

[11:04:04.0819] <rbuckton>
Yes, though holes are removed rather than replaced with `undefined`, so indices to elements change.

[11:04:14.0746] <Chris de Almeida>
nicolo-ribaudo: your topic is still in the queue

[11:04:17.0630] <Chris de Almeida>
(next)

[11:04:49.0428] <snek>
looks like they are replaced with undefined

[11:05:09.0176] <ljharb>
a glorious one that uses the much slower iterator protocol :-(

[11:05:19.0709] <ljharb>
`Array.from()` might work tho

[11:05:37.0550] <snek>
Array.from does it too

[11:05:47.0014] <snek>
both are probably better optimization targets than isSparse branches

[11:05:54.0651] <waldemar>
+1 on Nicolo's comment

[11:06:09.0228] <Richard Gibson>
`.toSpliced()` does not use Symbol.iterator

[11:06:32.0360] <ljharb>
the problem tho isn't "we don't want sparse arrays", it's "to accurately describe this object we need to know if it's sparse", so densification doesn't help

[11:07:04.0062] <Justin Ridgewell>
My topic: we can solve this with the previous property count proposal.

[11:07:17.0309] <Justin Ridgewell>
We don't need a sparse check that depends on internal engine details

[11:07:28.0594] <nicolo-ribaudo>
Wouldn;t `[1, , 3, foo: 4]` look like it's dense

[11:07:35.0753] <Justin Ridgewell>
A dense array has `Object.keys(arr).length === arr.length`

[11:07:36.0918] <Richard Gibson>
only if there's an "index" filter

[11:07:41.0673] <Justin Ridgewell>
No

[11:07:50.0341] <Justin Ridgewell>
Yes

[11:07:52.0633] <nicolo-ribaudo>
It has three properties and a length of three

[11:07:56.0306] <nicolo-ribaudo>
Oh ok

[11:08:08.0509] <Justin Ridgewell>
It has 2 index properties

[11:08:24.0153] <nicolo-ribaudo>
Well, `Object.keys(arr).length === arr.length` returns true on that

[11:08:56.0817] <Justin Ridgewell>
That's why we need the property count proposal

[11:09:02.0342] <Justin Ridgewell>
I was giving a really basic case

[11:09:13.0212] <Justin Ridgewell>
But we can build on the previous proposal for "sparse" checks

[11:09:35.0725] <nicolo-ribaudo>
My point about time-of-check vs time-of-use still stands though

[11:09:43.0294] <Justin Ridgewell>
Yes

[11:09:43.0501] <nicolo-ribaudo>
Even if you check like that

[11:09:53.0286] <waldemar>
{0: 0, 1: 0,  3: 0, 17: 0, length: 4} would have a length of 4 and four index-named properties

[11:11:05.0320] <ljharb>
but it'd not be Array.isArray. almost all these use cases are inside a context where that's already been checked

[11:11:20.0712] <Justin Ridgewell>
I though the proposal only worked on Arrays

[11:11:33.0772] <Justin Ridgewell>
* I thought the proposal only worked on Arrays

[11:13:16.0503] <waldemar>
That's still being debated.

[11:13:16.0947] <rbuckton>
I continue to wish JS had syntax and semantics for custom indexers, much like how TypedArrays are handled. This proposal brings that back to mind.

[11:13:57.0912] <Chris de Almeida>
we are going to go over time most likely.  please indicate your preference:

ü¶Ü - continue the meeting into the lunch break, and conclude plenary
üêì - break for lunch, and return after to continue meeting ,then conclude

[11:14:03.0829] <Justin Ridgewell>
Wouldn't any handling of array-like (specifically excluding arrays here) have to be linear?

[11:14:28.0698] <Justin Ridgewell>
We could just implement in userland, there's no benefit of a native API

[11:15:00.0554] <waldemar>
Yes, it would be linear. But, given today's comments, a lot of cases on Arrays would also be linear.

[11:15:37.0387] <Justin Ridgewell>
Not if we use property count, since the length is ü™Ñ

[11:16:35.0704] <Justin Ridgewell>
Index keys are stored in a special array (in V8), and length is always guaranteed to be the max index's value +1.

[11:16:48.0759] <Justin Ridgewell>
So the check could be constant for arrays specifically

[11:17:45.0013] <waldemar>
So you're saying that it is possible to implement Array.isSparse in O(1) time?

[11:18:11.0497] <Justin Ridgewell>
In V8 at least, without depending on the element's kind internal stucture.

[11:18:44.0389] <Justin Ridgewell>
Don't know about the other engines, but they had to implement special ordering rules for Object.keys(), so they may have index keys stored separately.

[11:22:15.0522] <nicolo-ribaudo>
Only `Object.keys` and `Object.propertyCount`, passing as the second parameter a bitflag to do all the filtering üß†

[11:23:02.0808] <Richard Gibson>
now you're thinking like a 1990s DOM API üòé

[11:25:32.0987] <snek>
proposal: add a one true Object.getPropertyNames which accepts this options bag: https://docs.rs/v8/latest/v8/struct.GetPropertyNamesArgs.html

[11:29:35.0084] <Olivier Fl√ºckiger>
no. it's O(1) to skip indices (which might or might not have holes)

[11:29:48.0065] <rbuckton>
Rather than using `'all'` to fight defaults, why not have these APIs always include everything by default and use the presence and value of `enumerable` et al to control behavior, much like `defineProperty` (which ignores missing attributes as long as the property already exists).

[11:31:28.0561] <Justin Ridgewell>
This response seems like a negative of a negative? I'm not sure how to understand it.

[11:31:42.0654] <rbuckton>
for this API and `propertyCount`, have it be `propertyCount(target)` to count all properties, and use `propertyCount(target, { enumerable: true })` to count only enumerable keys. Much like how `getOwnPropertyKeys` gets all own keys

[11:33:05.0831] <Olivier Fl√ºckiger>
We can give you the max index. but not tell you how many elements up to that index exist in the array.

[11:33:17.0130] <nicolo-ribaudo>
+1, maybe calling it `enumerableOnly`

[11:33:31.0221] <Justin Ridgewell>
It should be the count of the index keys array, right?

[11:33:52.0058] <Olivier Fl√ºckiger>
which is implicitly defined by not being a hole in the array backing store...

[11:34:44.0095] <bakkot>
has anyone ever enumerated a sufficiently large typed array to observe this

[11:34:52.0820] <Justin Ridgewell>
Does a the hole have an entry in the index keys arrays?

[11:35:20.0783] <Olivier Fl√ºckiger>
we don't separately store keys for arrays

[11:35:46.0632] <bakkot>
I don't think the thing Richard said is true

[11:35:59.0546] <bakkot>
Richard Gibson: https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-typedarray-ownpropertykeys

[11:36:57.0483] <bakkot>
exotic objects are allowed to have different key enumeration order than the default array-index-first behavior that ordinary objects have

[11:37:09.0967] <ljharb>
i agree with you; TAs already cover that

[11:37:40.0456] <Richard Gibson>
ack, I accept the correction

[11:38:39.0267] <rbuckton>
I'm a fan of just mirroring the attribute names, in the event we ever care about also supporting `configurable` or `writable`

[11:39:12.0497] <ljharb>
if it's called `enumerable` tho then it can't cover "all"

[11:39:19.0758] <ljharb>
only true and false

[11:39:23.0622] <nicolo-ribaudo>
The reason I suggested that is that `enumerable: true` could either be "include enumerable keys" or "include _only_ enumerable  keys"

[11:39:43.0009] <rbuckton>
It can cover it by being missing or `undefined`, just like how `defineProperty` handles it for existing properties.

[11:40:24.0235] <ljharb>
true, but it's very awkward to have a three-state boolean, and in this case the default would be `true`, and boolean option should always default to `false` when absent

[11:40:51.0481] <rbuckton>
i.e.:
- `propertyCount(target, {})` count all properties. 
- `propertyCount(target, { enumerable: true })` count only enumerable properties
- `propertyCount(target, { enumerable: false })` count only non-enumerable properties


[11:40:56.0496] <ljharb>
also if we added "writable" how would it work with accessor properties

[11:41:06.0286] <ljharb>
* also if we added "writable" how would it work with accessor properties, i don't think we can ever add that one

[11:41:13.0074] <ljharb>
* also if we added "writable" how would it work with accessor properties, i don't think we could ever add that one

[11:41:26.0368] <keith_miller>
Named String and Symbol properties are mixed in JSC's Structures

[11:41:50.0130] <keith_miller>
That said, it's easy enough to skip over the symbols and we already have that functionality

[11:41:52.0054] <snek>
whether a setter is present?

[11:41:57.0612] <rbuckton>
If we ever wanted anything that detailed, we could use `propertyCount(t, { writable: true }) + propertyCount(t, { set: true })`

[11:42:01.0841] <Michael Ficarra>
`Object.getOwnEnumerablePropertySymbols`, can we go home now?

[11:42:14.0137] <ljharb>
lol but i mean, if you say "true" or "false" then you're skipping all accessor properties?

[11:42:32.0460] <ljharb>
so the mirroring is broken because the type of `set` no longer matches

[11:42:40.0215] <nicolo-ribaudo>
I have to leave now, but I'm +1 on this proposal going to stage 1, and -1 on the first two advancing. For the first one until the use cases for the various combinations are clarified with actual examples, then it'll turn into +1 at a future meeting. For the one about isSparse I'm not convinced that it's what actually is needed to get a fast path. (cc ryzokuken as both Igalian and chair :P)

[11:42:47.0110] <nicolo-ribaudo>
* I have to leave now, but I'm +1 on this array indexes proposal going to stage 1, and -1 on the first two advancing. For the first one until the use cases for the various combinations are clarified with actual examples, then it'll turn into +1 at a future meeting. For the one about isSparse I'm not convinced that it's what actually is needed to get a fast path. (cc ryzokuken as both Igalian and chair :P)

[11:43:12.0732] <waldemar>
What is doable in O(1)? Getting the total number of properties? Getting the number of indexed properties? Nonindexed properties?

[11:43:14.0351] <nicolo-ribaudo>
* I have to leave now, but I'm +1 on this array indexes proposal going to stage 1, and -1 on the other two advancing. For the first one until the use cases for the various combinations are clarified with actual examples, then it'll turn into +1 at a future meeting. For the one about isSparse I'm not convinced that it's what actually is needed to get a fast path. (cc ryzokuken as both Igalian and chair :P)

[11:43:22.0345] <bakkot>
Object.symbols, surely

[11:43:23.0377] <nicolo-ribaudo>
* I have to leave now, but I'm +1 on this array indexes proposal going to stage 1, and -1 on the first two advancing. For the first one until the use cases for the various combinations are clarified with actual examples, then it'll turn into +1 at a future meeting. For the one about isSparse I'm not convinced that it's what actually is needed to get a fast path. (cc ryzokuken as both Igalian and chair :P)

[11:44:12.0729] <rbuckton>
My concern with having a bunch of methods on `Object` over the property bag is that it is inflexible without the number of similar property names on `Object` ballooning out of control. I wouldn't look forward to scrolling through the autocomplete list for that case. An options bag keeps the API rational and flexible.

[11:44:34.0620] <ljharb>
and, as i argued earlier, more discoverable

[11:44:37.0181] <bakkot>
we already have almost the whole matrix

[11:44:40.0027] <Michael Ficarra>
WFM

[11:44:54.0685] <bakkot>
we have Object.keys, Reflect.ownKeys, Object.getOwnPropertyNames, Object.getOwnPropertySymbols

[11:44:57.0697] <bakkot>
these are all their own method

[11:44:59.0169] <Olivier Fl√ºckiger>
Probably number of nonindexed properties (but I would have to think about it) and if the array happens to have a particular internal shape, then the number of indexed propoerties.

[11:45:02.0664] <ljharb>
`Object.symbols`, but don't forget `Object.symbolValues` and `Object.symbolEntries`

[11:45:07.0959] <rbuckton>
Its still similar enough, IMO.

[11:45:23.0058] <bakkot>
any new thing in this matrix should also be its own method

[11:45:36.0967] <ljharb>
and if we add `Object.symbols()` then what about a `.symbols()` iterator method on Set/Map/Array?

[11:45:39.0422] <bakkot>
`entries` is not an item in this matrix; there's only one of it

[11:45:50.0589] <rbuckton>
And they could just be one method with options that allows for future extensibility without adding even more methods to `Object`.

[11:45:53.0620] <bakkot>
why would we want that?

[11:45:57.0640] <ljharb>
lol i'm just saying that we have a LOT of keys/values/entries parallels

[11:46:01.0020] <bakkot>
but they all already exist

[11:46:07.0702] <snek>
javascript i have seen your future https://gc.gy/d452a7e4-49d7-4b50-be21-ce3f6cdc0fb4.png

[11:46:10.0740] <ljharb>
if your argument for method over option bag is "filling in the matrix", then we have a much larger matrix to fill in

[11:46:30.0402] <bakkot>
no my argument is _if_ we are filling in part of the matrix _then_ it must be in keeping with the rest of the existing matrix

[11:46:45.0681] <Michael Ficarra>
you failed to predict when we add a new kind of property key in 2028

[11:46:54.0538] <ljharb>
and the matrix includes keys/values/entries on Object/Set/Map/Array.

[11:46:59.0957] <snek>
getOwnDecimalkeys

[11:47:06.0782] <snek>
* getOwnPropertyDecimals

[11:47:08.0210] <bakkot>
that is a matrix but is not the one we are talking about, no

[11:47:11.0275] <rbuckton>
That approach doesn't scale to a larger number of permutations. 

[11:47:11.0949] <bakkot>
it is just not relevant at all

[11:47:22.0343] <bakkot>
there's no more permutations

[11:47:31.0790] <bakkot>
if we start doing configurable vs not or whatever, we can do that as options bags

[11:50:04.0099] <rbuckton>
The fact that `keys` vs `getOwnPropertyNames` differentiates by enumerability is definitely non-obvious to a new developer.

[11:50:16.0809] <bakkot>
I agree but it is how it works

[11:50:31.0567] <bakkot>
we can't say "the existing way is not sufficiently obvious so we're going to add a new way"

[11:50:39.0436] <bakkot>
* we can't say "the existing methods names are not sufficiently obvious so we're going to add a new way"

[11:50:45.0272] <ljharb>
why can't we?

[11:50:54.0924] <snek>
i would personally not put filling out matrixes over like how we have learned to design better apis from the last 25 years

[11:50:58.0455] <Richard Gibson>
for generic property key enumeration, I think the current (incomplete) matrix is {string, symbol, both} √ó {enumerable, ignore-enumerability}

[11:51:35.0373] <bakkot>
that is _a_ matrix but { string, symbol } x { enumerable, all } is another matrix, which has three entries, and this is the fourth entry in that matrix

[11:51:40.0738] <rbuckton>
That sounds like a perfectly valid reason to consider a different design for an API. 

[11:51:48.0018] <bakkot>
the very slightest modicum of taste?

[11:52:22.0501] <ljharb>
taste is a subjective thing, and my taste tends to consider "deprecate the bad thing, make a much better new thing" more pleasant than "never learn from our mistakes"

[11:53:02.0876] <Richard Gibson>
I disagree that such a reduced matrix is relevant, but don't want to complete either for their own sake anyway

[11:53:09.0483] <bakkot>
it is a fine reason to consider designing new APIs in a different way, when they are not just extensions of the existing API

[11:53:23.0216] <bakkot>
I strongly agree that we don't want to complete either for their own sake and have said as much on several occasions

[11:53:40.0014] <bakkot>
however, _if_ we are filling a the matrix of functionality _then_ it must match the exiting parts of the matrix

[11:53:44.0451] <bakkot>
* however, _if_ we are filling a the matrix of functionality _then_ it must match the existing parts of the matrix

[11:53:51.0667] <bakkot>
* however, _if_ we are filling a matrix of functionality _then_ it must match the existing parts of the matrix

[11:53:52.0739] <Michael Ficarra>
Same, where it matters a whole lot, like with avoiding coercions. This does not matter a whole lot.

[11:54:38.0988] <ljharb>
"matter" is also subjective :-)

[11:55:01.0196] <Michael Ficarra>
aesthetics is at the bottom of the mattering ladder

[11:55:23.0792] <rbuckton>
Shifting from a 2x2 matrix to a 3x3 matrix when there is potential to shift to an _n_ x _n_ matrix seems like enough of a trigger to me.

[11:55:25.0761] <ljharb>
PropertyReflectionFactoryBean, then

[11:55:35.0670] <Richard Gibson>
I strongly disagree with this, for reasons that align with statements from others above. In short, the current representation is bad and should not be extended, although _reworking_ might be appropriate

[11:55:52.0016] <bakkot>
but this proposal is _not_ shifting from a 2x2 matrix to a 3x3 matrix

[11:56:33.0055] <keith_miller>
Have folks actually seen these enumeration+filters show up as a meaningful point of performance overheads? I don't think I've ever seen this as a hotspot any traces from benchmarks or live sites.

[11:57:01.0251] <Justin Ridgewell>
Mostly comes up in development and testing

[11:57:02.0992] <keith_miller>
I'm sure you can make a microbenchmark but in large codebases

[11:57:05.0440] <ljharb>
ruben's experience in node is directly having it be very meaningful

[11:57:17.0021] <bakkot>
node's experience does not generalize to the web at all

[11:57:27.0892] <Justin Ridgewell>
I don't think this is expected in prod code

[11:57:32.0367] <ljharb>
sure, not claiming it does

[11:57:52.0020] <ljharb>
production code does value inspection quite often, in the web and in node, sometimes in failure paths but not always.

[11:58:35.0732] <Richard Gibson>
Agoric code enumerates object properties as part of shape verification

[11:58:36.0611] <keith_miller>
Sure, but failure paths are not usually ‚Ñ¢Ô∏è hot though

[11:58:46.0950] <Richard Gibson>
not limited to failure paths

[11:58:50.0152] <ljharb>
sure, which is why i said "not always" :-)

[11:59:22.0017] <Justin Ridgewell>
Making tests and logging faster would be valuable for me as the dev, but unlikely to impact my users.

[11:59:41.0995] <bakkot>
for extremely obscure things, I can _maybe_ buy this on a case-by-case basis, if there's some hope people might migrate off of the current representation. but `Object.keys` is the opposite of obscure

[12:00:41.0448] <Richard Gibson>
the *presence* of `Object.keys` is not obscure, but ignoring Symbol-keyed and non-enumerable properties **is**

[12:02:23.0981] <Justin Ridgewell>
I think using symbols is obscure. And making non-enumerables (outside prototype methods)

[12:03:06.0643] <Michael Ficarra>
üï∞Ô∏è remember to leave time if we're looking for stage advacnement

[12:04:03.0148] <bakkot>
like, to be clear, the proposal is:

- How do you get all own strings? Object.getOwnPropertyNames()
- How do you get all own symbols? Object.getOwnPropertySymbols()
- How do you get enumerable own keys? Object.keys()
- How do you get enumerable own symbols? Object.getOwnPropertySymbols({ enumerable: true })

[12:04:11.0531] <bakkot>
that is dumb

[12:04:14.0129] <bakkot>
we are not doing that

[12:04:30.0333] <bakkot>
* that is extremely unpleasant to me

[12:04:30.0840] <Chris de Almeida>
tempted to break for lunch and come back.. my fear is that the calls for advancement may take more time than we think

[12:04:48.0834] <ljharb>
fwiw i can't come back after lunch; i'd planned on not going late

[12:04:50.0278] <Chris de Almeida>
though the ducks did win out easily over the chickens

[12:04:55.0947] <Michael Ficarra>
I am not coming back

[12:06:03.0502] <Michael Ficarra>
it's easy to make a call for advancement go fast FWIW

[12:06:13.0001] <Michael Ficarra>
"if it's not blocking, I don't want to hear it"

[12:06:26.0709] <Michael Ficarra>
we can do all 4 in under a minute if we do it right

[12:06:38.0564] <ljharb>
you think it's easy to get a group of language pedants to willingly not voice their opinion? O.o

[12:06:49.0119] <ljharb>
* you think it's easy to get an entire group of language pedants to willingly not voice their opinion? O.o

[12:06:58.0808] <Richard Gibson>
I agree with not doing that. But an alternative is introducing a single new thing that handles all four of those.

[12:07:07.0018] <Michael Ficarra>
yes, admins have a mute button

[12:07:25.0461] <keith_miller>
To further clarify, optimizing the enumerability is somewhat difficult in the semi-optimizing tiers of an engine because it's hard to prove how the JS is going to use the result of the `getOwnPropertyDescriptor` object without doing a full escape analysis.

[12:07:54.0012] <bakkot>
How do you get all own strings? Object.getOwnPropertyNames()
How do you get all own symbols? Object.getOwnPropertySymbols()
How do you get enumerable own keys? Object.keys()
How do you get enumerable own symbols? Object.getEveryPossibleCombination({ symbols: true, enumerable: true })

this is not better

[12:08:10.0551] <ljharb>
in that world you'd change the answer to the first 3 to use the new method

[12:08:16.0241] <Michael Ficarra>
y'all are lucky I'm not a chair because I would be *so* much stricter than our current chairs

[12:08:18.0200] <ljharb>
and the first three would just be legacy

[12:08:18.0478] <bakkot>
* How do you get all own strings? Object.getOwnPropertyNames()
How do you get all own symbols? Object.getOwnPropertySymbols()
How do you get enumerable own keys? Object.keys()
How do you get enumerable own symbols? Object.getEveryPossibleCombination({ kind: 'symbols', enumerable: true })

this is not better

[12:08:44.0358] <bakkot>
if these were very very obscure you might have some hope of that

[12:08:45.0438] <ljharb>
* and the first 3 would just be marked legacy

[12:08:48.0907] <bakkot>
Object.keys is not obscure and never will be

[12:08:54.0882] <ljharb>
true. the others are very obscure tho

[12:09:01.0179] <Richard Gibson>
but the others are

[12:09:14.0497] <rbuckton>
This is still an API that doesn't scale if you consider `propertyCount` or other APIs that would filter the results (like getNonIndexPropertyNames, etc.). From a blank slate, I would strongly have preferred an API like `getPropertyNames(o, { own, enumerable, ... })` and `propertyCount(o, { own, enumerable, ... })` than repeating 3-4 static methods for each output type.

[12:10:43.0039] <bakkot>
it scales fine, just tack "Count" on the end of all of those

[12:10:46.0829] <bakkot>
this is my preferred solution

[12:11:16.0139] <ljharb>
in a world where we trimmed dozens of methods from Temporal because engines don't want to add a ton of methods?

[12:11:25.0121] <rbuckton>
i.e., `getPropertyNames(o, { own: true, symbol: false })` -> `getOwnPropertyNames(o)`, `getPropertyNames(o, { own: true, enumerable: true, symbol: false })` -> `keys(o)`, etc.

[12:11:35.0783] <bakkot>
I agree from a blank slate we would probably do something different but this is javascript, the slate is never blank

[12:11:48.0844] <ljharb>
* in a world where we trimmed dozens of methods from Temporal because browsers don't want to add a ton of methods?

[12:12:09.0656] <ljharb>
like in the same way as browser implementation reality has basically meant "no new array prototype methods", aren't we already in the world of "minimize the number of added methods"? which would strongly push options bags as The Way to add stuff when it makes sense?

[12:12:23.0315] <bakkot>
to be clear I do not insist on a separate fooCount method being the solution to counting thing, just that I would be fine with that outcome

[12:12:35.0573] <Justin Ridgewell>
DIdn't we split this from a super-everything API a few meetings ago?

[12:12:45.0072] <bakkot>
we do not already have fooCount methods so we can do those however we'd like

[12:13:44.0361] <rbuckton>
It is, however, indicative of a preferred state. We only have ~3 methods in this category for now. this doubles that and more, and any other permutations would result in needing to switch and leave behind now 6-8 "legacy" methods.

[12:13:56.0211] <rbuckton>
I don't look forward to completions for `Object.getOwn|` expanding to a large list you have to scroll through to get the correct method.

[12:14:12.0646] <nicolo-ribaudo>
What was the consensus outcome, for those that left earlier?

[12:14:24.0849] <Chris de Almeida>
üòë

[12:14:38.0626] <snek>
`Object.iterateProperties().filter(x => typeof x.name === 'symbol' && x.enumerable).reduce((c, _) => c + 1, 0)`

[12:14:53.0708] <Michael Ficarra>
I actually look forward to this

[12:15:04.0218] <bakkot>
"this" does not double that, "this" is literally just `Object.symbols`, I am only insisting on `Object.symbols` _specifically_ as the solution to the "get enumerable own symbols"

[12:15:24.0830] <Michael Ficarra>
there has been no request for consensus on anything yet

[12:16:04.0062] <nicolo-ribaudo>
Ugh good luck

[12:16:15.0394] <bakkot>
I have not claimed and do not believe this means we have to add a bunch of other methods as the solution to other problems

[12:16:24.0723] <bakkot>
* "this" does not double that, "this" is literally just `Object.symbols` (or some other name), I am only insisting on `Object.symbols` _specifically_ as the solution to the "get enumerable own symbols"

[12:16:43.0705] <ljharb>
that would destroy discoverability

[12:16:56.0088] <ljharb>
* that would destroy discoverability, much like how you can't meaningfully read through the list of methods on `window` anymore

[12:17:16.0386] <rbuckton>
IMO, `Object.keys()` is a terrible name that does not accurately describe what it does. `Object.symbols()` would be going down the wrong track, IMO.

[12:17:42.0816] <rbuckton>
I'd much rather have a more descriptive `getOwnEnumerablePropertySymbols` than `symbols` for clarity.

[12:18:02.0083] <ljharb>
none yet

[12:18:16.0513] <ljharb>
* none yet, still going

[12:18:39.0648] <rbuckton>
I'll admit I needed to check the documentation for `keys` to clarify whether it return only own keys or inherited keys. It's a terrible name.

[12:19:31.0972] <Richard Gibson>
I'm very much against adding a plethora of new functions. But if the **only** introduction here is "get enumerable own symbols", then I agree with bakkot that it must be `Object.symbols`.

[12:20:01.0471] <ljharb>
only own

[12:20:20.0328] <ljharb>
nothing returns inherited keys

[12:20:36.0029] <bakkot>
`Object.keys` is not a great name but it's also among the most widely used methods in the language, we are not getting away from it

[12:27:17.0006] <Chris de Almeida>
I meant 'elder' as in experience, not age!  üòÑ

[12:27:22.0693] <rbuckton>
True, but that doesn't mean we should continue down that path.

[12:32:14.0319] <Chris de Almeida>
I forgot to thank our note-takers:

```
ABO
JMN
JRL
KG
MF
NRO
RGN
SFC
SHS
ZTZ
```

thank you all very much!  üëèüëèüëèüëèüëèüëèüëè

[16:32:10.0565] <ljharb>
k well my matrix is taking forever to send messages, and i have to run anyways, so i'm off üëã

