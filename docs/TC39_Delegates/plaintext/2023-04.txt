2023-04-01
[18:26:35.0385] <Chris de Almeida>
https://github.com/tc39/how-we-work/issues/94

‚òùÔ∏è üö®  important calendar info  üö® ‚òùÔ∏è

[18:26:50.0945] <Chris de Almeida>
 * https://github.com/tc39/how-we-work/issues/94#issuecomment-1492775885

‚òùÔ∏è üö®  important calendar info  üö® ‚òùÔ∏è


2023-04-03
[22:08:13.0803] <ljharb>
ES2023: https://github.com/tc39/Reflector/issues/466

[16:03:42.0565] <shu>
Michael Ficarra: did you intend step 5 of https://tc39.es/proposal-iterator-helpers/#sec-iteratorprototype.reduce to be "not present", as in an arguments length check? it is consistent with Array.prototype.reduce, but is generally weirder than just checking for undefined nowadays

[16:06:41.0132] <Michael Ficarra>
hmm, yeah it seems like the right call, as that's how we distinguish two pretty radically different behaviors

[16:07:27.0736] <Michael Ficarra>
reduce can either be passed the initial memo (which is perfectly reasonable to be `undefined`) or it can assume the structure is non-empty and use the first element as the initial memo

[16:07:52.0971] <Michael Ficarra>
I think a presence check is the only thing we can do short of separating `reduce` and `reduce1`

[16:07:59.0791] <shu>
ah good point, undefined is a good initial value, so the only choice here is an arguments length check

[16:08:03.0593] <shu>
thanks


2023-04-04
[17:13:30.0800] <TabAtkins>
Yeah, reduce() def needs the presence check rather than undefinedness.

[18:33:10.0051] <Michael Ficarra>
shu: FYI there's another 2 iterator helper topics added to the May agenda

[18:33:23.0766] <Michael Ficarra>
they're some minor inconsistencies that I discovered while working on the tests

[18:34:12.0075] <Michael Ficarra>
the slides should be self-explanatory

[18:45:19.0695] <shu>
do they really need 30 minutes each

[18:47:36.0715] <Michael Ficarra>
hopefully not

[18:51:29.0580] <Michael Ficarra>
does anyone remember a discussion about whether `const [] = { [Symbol.iterator]() { return {}; } };` (a malformed iterator that never gets iterated) should throw?

[18:51:39.0298] <Michael Ficarra>
I vaguely remember Justin Ridgewell being involved I think

[18:53:37.0986] <Michael Ficarra>
bakkot found it! https://github.com/tc39/ecma262/pull/1288#issuecomment-424457388

[18:53:38.0759] <Justin Ridgewell>
We discussed whether a malformed iterator would close the underlying

[18:55:46.0820] <Michael Ficarra>
notes: https://github.com/tc39/notes/blob/main/meetings/2018-09/sept-25.md#normative-use-getmethod-instead-of-getv-to-get-iterator-next

[19:25:41.0388] <bakkot>
had not encountered this particular downside of floats

[19:26:05.0540] <bakkot>
though it's of course an instance of a the same problem as all the other things we've been discussing lately

[19:26:18.0017] <bakkot>
 * though it's of course an instance of the same problem as all the other things we've been discussing lately

[19:26:32.0678] <bakkot>
(this example is from https://speleotrove.com/decimal/decifaq.html about why a Decimal type is warranted)

[05:29:12.0624] <littledan>
I'm curious what you're trying to do. I got the feeling that the committee as a whole wasn't totally convinced that decimal was actually a general-purpose, useful thing, as opposed to something very specialized.

[05:29:38.0424] <littledan>
 * I'm curious what you're trying to do that made you run into this--was it just researching decimal, or do you have a specific application? I got the feeling that the committee as a whole wasn't totally convinced that decimal was actually a general-purpose, useful thing, as opposed to something very specialized.

[07:50:12.0199] <bakkot>
finally got around to reading the FAQ linked during the discussion, which has this example

[07:50:47.0986] <bakkot>
I didn't actually run into it in real life

[08:29:51.0068] <littledan>
ah OK. Yeah I really enjoyed the FAQ.


2023-04-05
[10:58:49.0467] <Justin Ridgewell>
Can someone invite me to the TC39/JavaScript tools discussion? I missed the meeting today because Calendar doesn't send notifications for shared meetings, only ones I'm invited to.

[11:01:07.0154] <Michael Ficarra>
littledan manages it

[11:01:36.0247] <littledan>
actually Romulo Cintra does these days

[11:02:21.0416] <littledan>
Use this contact form: https://forms.gle/rSNWHknikVSpGHmD6


2023-04-06
[23:33:06.0461] <bakkot>
updated the base64 proposal and added a playground. would love feedback on the design (and the contents of the playground, the design of which I ripped off wholesale from temporal) https://tc39.github.io/proposal-arraybuffer-base64/

[23:51:49.0914] <bakkot>
 * updated the base64 proposal and added a playground. would love feedback on the proposal API (and the contents of the playground, the design of which I ripped off wholesale from temporal) https://tc39.github.io/proposal-arraybuffer-base64/

[10:11:40.0270] <dminor>
Chris de Almeida: re: the declined TC39 meeting, it looks like Rob created the meeting and then invited the TC39 Events Calendar. I think the way to fix it is for someone to create a new Chairs Meeting directly on the TC39 Events Calendar and for Rob to then remove the existing one. If you share your preferred email address with me, I can give you write access to the TC39 Events Calendar.

[11:12:43.0414] <Michael Ficarra>
I would rename the "alphabet" option to something like "alphabetName" so we know it's an identifier and not the alphabet itself being passed in (without referring to docs)

[11:13:12.0048] <Michael Ficarra>
alternatively, actually pass the alphabet in and define constants for standard ones

[11:22:13.0177] <bakkot>
I was imaging you could specify either by identifier or by an entire alphabet

[11:22:41.0984] <bakkot>
as long as we don't want to support identifiers which are exactly 64 characters long we can just let the name be overloaded, and not require the user to find the constants somewhere

[11:24:23.0285] <Michael Ficarra>
well that's certainly creative

[13:19:42.0192] <TabAtkins>
...huh, having an overlapping value space which is definitely disjoint in practice is very interesting.

[13:21:00.0395] <TabAtkins>
Might be too magic when we can just have two different options in the bag, but it does avoid us having to answer the question of what to do when the author specifies both, I guess.

[13:22:00.0772] <bakkot>
yeah

[13:22:06.0957] <bakkot>
also, I dunno it's not that magic

[13:22:53.0540] <bakkot>
no more so than `new Temporal.TimeZone('UTC');` and `new Temporal.TimeZone('+00:00');` both working

[13:25:08.0369] <Michael Ficarra>
it's not even like we couldn't have a well-known alphabet have a 64-character name, it just can't refer to some *other* alphabet, which would be a misleading name to say the least

[13:26:36.0438] <bakkot>
right, also the space is even more constrained because all 64 characters need to be unique, which... you are probably not going to run into an identifier which looks like that

[13:28:51.0748] <Michael Ficarra>
can't wait to see the TypeScript type for it

[13:38:46.0134] <littledan>
`any` should work

[13:47:04.0997] <TabAtkins>
Can typescript represent strings of a particular length?

[13:47:29.0756] <TabAtkins>
If not, then worst case you can just type it as `String` (no need to fall all the way down to `any`)

[13:48:15.0074] <littledan>
Of course, was joking

[13:48:36.0441] <TabAtkins>
man distinguishing shitposts from serious suggestions can get really hard sometimes

[13:58:54.0849] <bakkot>
the question of what typescript "can" represent is somewhat complicated because it has a very powerful type system

[13:59:17.0021] <bakkot>
I am confident there is a way to abuse it into representing "strings of length 64" but it is not something built in and you'd probably get a horrible error message

[13:59:59.0676] <ljharb>
maybe some nonsense with template literal types

[14:05:41.0057] <TabAtkins>
just do a disjuction of literals, with the known keywords and all, uh, 128^64 valid alphabet literals?

[14:08:11.0951] <bakkot>
unfortunately it refuses to represent unions larger than ~10k members, because it is a coward

[14:18:29.0389] <TabAtkins>
Sigh, guess we'll have to throw the whole idea out, then.

[15:51:14.0630] <Michael Ficarra>
RFC 4648 has like base32 and stuff, is there any way that could be added in the future?

[15:53:56.0439] <bakkot>
see https://github.com/tc39/proposal-arraybuffer-base64#what-other-encodings-should-be-included-if-any

[15:54:09.0660] <bakkot>
and specifically https://github.com/tc39/proposal-arraybuffer-base64/issues/7#issuecomment-872536851


2023-04-07
[06:07:34.0734] <Francisco Tolmasky>
Has there been any discussion around "nullish coallescing destructuring", that is, making something like `function a ({ x = 10 }) { }` "just work" for the `a()` case and having x just be set to 10 instead of throwing? Perhaps using syntax like `function a({ x ?= 10 }) { }` or something?

[07:25:38.0285] <rbuckton-pto>
While not as efficient, you can already do `function a ({ x = 10 } = {}) { }`

[07:35:26.0429] <Justin Ridgewell>
There were a few discussions in the Optional Chaining proposal: https://github.com/search?q=repo%3Atc39%2Fproposal-optional-chaining+destructuring&type=issues

[10:09:53.0060] <TabAtkins>
Yeah the `= {}` trick works for top-level, but it's more annoying if you want to destructure deeper into the object; you've got to supply more dummy objects for each path you take.

[10:45:13.0336] <Francisco Tolmasky>
Right, the concern is when it starts to nest pretty deep

[11:51:44.0992] <Justin Ridgewell>
Oh, there was also https://github.com/tc39/agendas/pull/1122, but it was never presented

[11:54:46.0602] <Chris de Almeida>
https://twitter.com/TheJoin95/status/1644387103105482753

speaking of...

[12:00:15.0413] <bakkot>
I feel like doing very deep destructuring all in one go is generally less clear than splitting it up, so I'm not sure I would want to add syntax which is mostly useful for very deep destructuring 

[12:01:10.0413] <Chris de Almeida>
well.. could simplify the example:

```
const state = {
    profileMenu: null
}

const {
    profileMenu: {
      username: ProfileMenuUsername
    }
} = state; ```

[12:01:22.0514] <Chris de Almeida>
 * well.. could simplify the example:

```
const state = {
    profileMenu: null
}

const {
    profileMenu: {
      username: ProfileMenuUsername
    }
} = state;
```

[12:03:35.0570] <ljharb>
`const { username: ProfileMenuUsername } = {} = state.profileMenu;` ?

[12:03:41.0543] <Chris de Almeida>
 * well.. could simplify the example:

```
const state = {
  profileMenu: null
}

const {
  profileMenu: {
    username: ProfileMenuUsername
  }
} = state;
```

[12:03:44.0737] <ljharb>
 * `const { username: ProfileMenuUsername } = {} = state?.profileMenu;` ?

[12:05:03.0582] <Chris de Almeida>
> <@ljharb:matrix.org> `const { username: ProfileMenuUsername } = {} = state?.profileMenu;` ?

`Cannot read properties of null (reading 'username')`

[12:05:36.0850] <ljharb>
`const { username: ProfileMenuUsername } = state?.profileMenu ?? {};` then :-p

[12:07:01.0288] <Chris de Almeida>
well that gives you a diff obj ü§∑

