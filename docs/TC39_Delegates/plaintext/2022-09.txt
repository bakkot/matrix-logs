2022-09-01
[13:58:31.0354] <Justin Ridgewell>
Can I get write access to test262?

[13:58:52.0185] <Justin Ridgewell>
Trying to update the group/groupToMap PRs made by another contributor, but I can't push without access.


2022-09-02
[09:07:30.0976] <ljharb>
Justin Ridgewell: i just added you with write access, in theory CODEOWNERS should prevent you from merging but Write should allow you to force push to the PR; please lmk if theory doesn't hold

[09:28:51.0497] <Justin Ridgewell>
Thanks

[09:50:33.0114] <bterlson>
< 24 hours to get your agenda items in for the next meeting! Looks like this will be a short one unless folks are waiting for the last possible second.

[15:03:56.0082] <bakkot>
ljharb (or any admin): can I be given write access to https://github.com/tc39/proposal-set-methods? ðŸ˜…

[15:20:57.0381] <ljharb>
done

[16:48:49.0262] <bakkot>
ljharb re https://github.com/tc39/proposal-iterator-helpers/issues/117#issuecomment-1235980915 "i'd prefer it brand-check" - what do you actually want it to brand check?

[16:49:05.0131] <bakkot>
I'm confused about what the ask is

[16:58:02.0516] <ljharb>
instances of iterator

[16:58:17.0160] <ljharb>
so it throws if anyone extracts the getter and dot calls it on something different


2022-09-03
[18:18:56.0824] <bakkot>
so an `instanceof` check, you mean? that doesn't seem that useful; you can do that yourself

[22:05:49.0750] <ljharb>
no, not an instanceof check, those are forgeable and don't work across realms. a brand check.

[09:00:22.0548] <bakkot>
ljharb: what brand do you imagine checking? there are a bunch of different built-in iterators in the language and the web platform, and they don't have a common brand

[09:00:46.0177] <bakkot>
the whole point of iterator being an interface is that the interface is implemented by a bunch of different classes, including userland classes

[09:02:50.0840] <littledan>
IMO the appropriate level for a brand check here would be to revert the whole Symbol.toStringTag change in the first place... what a bad idea of a feature. Not clear if it makes sense to "chip away at it" as much as I'm sympathetic with the idea to try.

[09:06:01.0455] <littledan>
it's not unthinkable to add a brand just for this purpose in https://tc39.es/proposal-iterator-helpers/#sec-iterator but I don't see the point

[09:06:41.0126] <littledan>
(do we want to start telling people, they shouldn't be pasting iterator helpers onto a base class by messing with a prototype chain? that seems like a useful mode to me)

[09:07:01.0926] <littledan>
 * (do we want to start telling people, they shouldn't be pasting iterator helpers onto a base class by messing with a prototype chain? that seems like a useful mode to me)


2022-09-04
[18:42:16.0345] <ljharb>
they do have a common brand now, itâ€™s what Iterator.from provides

[18:42:40.0929] <ljharb>
and a userland class will be wrapped by a branded object.

[08:36:39.0724] <bakkot>
Iterator.from checks `instanceof Iterator` and returns the original object if that returns true

[08:36:52.0231] <bakkot>
so no, it does not provide a common brand

[08:37:01.0436] <bakkot>
 * so no, it does not provide a common brand

[10:33:56.0875] <snek>
without first class protocols the only ways to check if something is an actual iterator is either rely on the prototype or exhaustively interrogate its methods 

[10:34:20.0633] <snek>
* without first class protocols the only ways to check if something is an actual iterator is either rely on the prototype or exhaustively interrogate its methods 

[11:17:16.0208] <rbuckton>
This is one reason why I'm still wary of using Iterator rather than an Iterable. 


2022-09-05
[18:13:02.0539] <ljharb>
i didnâ€™t realize that. It shouldnâ€™t use instanceof - like everything else in the language, it should use a brand.

[18:17:51.0847] <bakkot>
no, it's an interface

[18:17:54.0377] <bakkot>
it's not a class

[18:17:58.0963] <bakkot>
I mean, it is also a class

[18:18:30.0356] <bakkot>
but there is no particular reason a userland instance needs to have the brand

[19:14:15.0471] <snek>
> <@ljharb:matrix.org> i didnâ€™t realize that. It shouldnâ€™t use instanceof - like everything else in the language, it should use a brand.

how do you brand something whose definition is "has a next method that returns { value, done }"

[19:15:56.0312] <snek>
or if you subscribe to the other idea, "an object inheriting Iterator.prototype"

[20:35:23.0409] <ljharb>
objects in the language that inherit from a prototype also have a brand, thats checked in places. 

[20:38:35.0852] <snek>
no i like

[20:38:42.0553] <snek>
i do not understand the mechanic by which this would work

[10:17:26.0579] <ljharb>
anything that's `instanceof Iterator` in the language would have an internal slot, which is what Iterator.from would check

[10:28:14.0641] <bakkot>
in the language or, presumably, the web platform?

[10:28:28.0850] <bakkot>
I suppose that would be possible but... why?

[11:22:09.0722] <snek>
> <@ljharb:matrix.org> anything that's `instanceof Iterator` in the language would have an internal slot, which is what Iterator.from would check

how do they get the internal slot? they're just random objects

[11:23:40.0028] <snek>
oh are you saying Iterator.from would be the thing that produces objects with that slot

[11:25:30.0272] <snek>
technically the new object it returns has `[[Iterated]]`

[11:25:31.0130] <snek>
but

[11:25:37.0717] <snek>
it doesn't have to return the new object

[11:26:10.0577] <snek>
like if i run `Iterator.from({ next() {}, __proto__: Iterator.prototype })`, it should return that argument unchanged

[12:26:30.0104] <ljharb>
that doesnâ€™t seem like what it should be doing at all.

[12:27:17.0394] <ljharb>
Array.from doesnt pass through return an arraylike object that has a proto of Array.prototype - it returns a proper array. So should Iterator.from.

[12:28:31.0086] <bakkot>
the definition of "proper iterator" _is_ "inherits from Iterator.prototype", in this context

[12:44:30.0140] <ljharb>
i don't think that is or should be the definition

[13:00:34.0611] <bakkot>
why?

[14:08:11.0778] <snek>
Iterator is not a concrete thing, I'd rather rename the method if that's the problem

[14:15:40.0372] <ljharb>
the whole point of Iterator.from is that it's becoming a concrete thing

[14:15:49.0067] <snek>
no its just that its giving it the prototype

[14:16:05.0528] <snek>
its a convenience for the methods

[14:16:47.0742] <ljharb>
â€¦ and the methods do a wrap (to something with the slot) if they're `.call`ed on a random object?

[14:17:33.0567] <snek>
i don't understand what this means

[14:17:41.0235] <ljharb>
the `[[Iterated]]` slot you mentioned

[14:18:21.0801] <snek>
`[[Iterated]]` is just used for %WrapForValidIteratorPrototype%.next/return

[14:18:33.0754] <ljharb>
how can the next method retain internal state unless it has a place to put it?

[14:19:11.0869] <snek>
WrapForValidIteratorPrototype objects don't have any internal state

[14:19:24.0161] <snek>
[[Iterated]] is just the object they wrap

[14:19:41.0461] <snek>
well, the iterator record for it

[14:20:57.0151] <ljharb>
ok so like `map`. it has to hold on to the original iterator, and to the callback

[14:21:15.0595] <ljharb>
so presumably the iterator object returned by `map` holds that, in an internal slot

[14:21:53.0713] <snek>
they use closures

[14:22:27.0105] <ljharb>
so the iterator object doesn't use a shared `next` method, it makes a new one each time `map` is called?

[14:22:39.0264] <snek>
uhh

[14:22:43.0674] <snek>
it uses %IteratorHelperPrototype%.next

[14:22:47.0801] <snek>
 * it uses %IteratorHelperPrototype%.next

[14:22:48.0948] <ljharb>
right. but that's a shared method.

[14:22:55.0382] <snek>
which is just %GeneratorPrototype%.next but fancy

[14:22:56.0847] <ljharb>
so it can't close over something that's unique to a given `map` call

[14:23:10.0849] <ljharb>
because it exists before `map` is ever called.

[14:23:11.0878] <snek>
 * which is just %GeneratorPrototype%.next but fancy

[14:23:24.0823] <ljharb>
so where is that state held so that `next` can access it?

[14:23:39.0873] <snek>
same place that normal generators store it

[14:23:50.0121] <snek>
the only thing is

[14:24:06.0149] <snek>
you can grep for `[[GeneratorBrand]]` in the spec

[14:24:06.0150] <ljharb>
right but that's in a slot on the generator instance, no?

[14:24:13.0324] <snek>
https://tc39.es/ecma262/#sec-generatorvalidate

[14:24:19.0829] <snek>
this is the only way it tells them apart

[14:24:28.0839] <snek>
but that just tells you if it was a generator helper method

[14:24:42.0969] <snek>
tbh i'm not sure why we separate them at all, they just call `GeneratorResume`

[14:25:04.0878] <ljharb>
right. and [[GeneratorContext]] and [[GeneratorState]] are slots on the iterator object that hold the state

[14:25:22.0708] <snek>
yeah its a generator

[14:25:27.0530] <ljharb>
right

[14:26:03.0805] <ljharb>
and GeneratorValidate brand-checks the iterator. it doesn't matter what its [[Prototype]] is, it matters if it has the expected slots.

[14:26:12.0585] <snek>
ye

[14:26:25.0083] <ljharb>
so i assume that Iterator Helper methods all do the same validation

[14:26:51.0015] <snek>
iterator helper methods do not know about those brand checks, they perform them via calling stuff like `GeneratorResume`

[14:26:57.0036] <ljharb>
right but they still exist

[14:26:59.0533] <snek>
sure

[14:27:01.0744] <ljharb>
which means that `{ __proto__: Iterator.prototype }` would fail that check, and not be a usable receiver with the Iterator Helper methods. which means Iterator.from musn't ever return it.

[14:27:17.0449] <ljharb>
which means that Iterator.from always returns a brand-checkable object, one that GeneratorValidate will accept.

[14:27:26.0938] <snek>
uhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh

[14:27:27.0624] <snek>
no

[14:27:36.0444] <ljharb>
what am i missing there?

[14:28:00.0628] <snek>
assuming this `let iterWithGeneratorSlots = [].values().map(x => x); `

[14:28:22.0541] <snek>
`Iterator.from(iterWithGeneratorSlots)` passes it through unchanged because it inherits from %Iterator.prototype%

[14:28:24.0787] <snek>
but

[14:28:57.0242] <snek>
if you do `Iterator.from({ next() {}, __proto__: Iterator.prototype })` it also passes it through unchanged

[14:29:04.0970] <snek>
that's not doing any generator stuff

[14:29:29.0694] <snek>
if you do `Iterator.from({ next() {} })` that creates a %WrapForValidIteratorPrototype% object and returns it

[14:29:30.0204] <ljharb>
ok but what happens with `Iterator.from({ next() {}, __proto__: Iterator.prototype }).map(x => x)`?

[14:29:37.0331] <snek>
but that still doesn't have any generator slots

[14:29:40.0615] <snek>
cuz its not a generator

[14:29:44.0860] <snek>
its just a stupid wrapper

[14:29:51.0977] <snek>
> <@ljharb:matrix.org> ok but what happens with `Iterator.from({ next() {}, __proto__: Iterator.prototype }).map(x => x)`?

that has generator slots cuz you called map

[14:30:06.0286] <ljharb>
ok, and `.map` doesn't care if its receiver has the slots?

[14:30:07.0853] <ljharb>
 * ok, and `.map` doesn't care if its receiver has the slots?

[14:30:12.0540] <snek>
no it does not

[14:30:15.0145] <ljharb>
oof

[14:30:19.0662] <snek>
all it cares is that the receiver is an iterator

[14:30:59.0446] <snek>
https://gc.gy/130118458.png

[14:32:13.0928] <snek>
this is why `{ next() {}, __proto__: Iterator.prototype }` is valid

[14:32:52.0882] <snek>
with protocols you have to assume that the object is already created as some other shape, you're augmenting them with the functionality, implementing the protocol on top of something else

[14:33:04.0619] <ljharb>
i don't understand why, if everyone's going to `Iterator.from()` anyways to get the methods, we wouldn't want to unconditionally wrap - ie, to unconditionally `.map(x => x)`

[14:33:24.0469] <ljharb>
 * i don't understand why, if everyone's going to `Iterator.from()` anyways to get the methods, we wouldn't want to unconditionally wrap - ie, to unconditionally `.map(x => x)`

[14:33:32.0370] <snek>
i think its pretty rare that you would *need* to use Iterator.from

[14:33:34.0392] <ljharb>
that way we have a consistent "real iterator" definition

[14:34:06.0617] <ljharb>
i think you'll want to do it any time you're dealing with a user-supplied iterator. which will be frequent.

[14:34:27.0005] <snek>
i mean, those are rare lol

[14:34:27.0301] <ljharb>
you'd want to maximally accept and normalize all possible iterators

[14:34:33.0290] <ljharb>
that's what `Promise.resolve` is good for too

[14:34:36.0360] <snek>
yeah i mean

[14:34:41.0810] <ljharb>
it normalizes thenables into Real Promises, which are always preferred

[14:34:46.0635] <snek>
if you're you, writing some sort of complex fancy library that has to deal with the world

[14:34:49.0388] <ljharb>
similarly i'd always want a Real Iterator, not just an "iterator"

[14:34:51.0688] <snek>
go for it

[14:35:06.0469] <ljharb>
this isn't just a "my unique coding style" thing tho, this is any package

[14:35:25.0531] <ljharb>
anything that accepts an iterator. just like anything that accepts a thenable always uses Promise.resolve or `await` to normalize it first into a real promise

[14:35:35.0379] <ljharb>
Iterator.from will be exceedingly common imo.

[14:35:35.0989] <snek>
its a nice convenient method yeah

[14:35:38.0604] <snek>
i was just pointing out

[14:35:44.0264] <snek>
its superfluous in 99% of cases

[14:36:01.0138] <snek>
so we made it not add extra overhead

[14:36:01.0299] <ljharb>
i don't think that's true

[14:36:08.0795] <ljharb>
i think 99% of cases will be dealing with untrusted iterators

[14:36:19.0924] <ljharb>
the case where you're iterating your own iterator are likely to be far rarer. (where "your own" doesn't deal with who the author is, but which chunk of code owns it)

[14:36:36.0548] <ljharb>
 * the case where you're iterating your own iterator are likely to be far rarer. (where "your own" doesn't deal with who the author is, but which chunk of code owns it)

[14:37:23.0449] <ljharb>
"extra overhead" isn't a real problem (it can be optimized away), but a footgun like "sometimes it doesn't wrap" imo would be

[14:37:27.0301] <snek>
the genesis of this proposal was the observation that all web and js platform iterators already inherit from a shared %IteratorPrototype%

[14:37:31.0109] <ljharb>
 * "extra overhead" isn't a real problem (it can be optimized away), but a footgun like "sometimes it doesn't wrap" imo would be

[14:37:45.0242] <snek>
and the remaining weird ones often use the `(function*(){})().next().__proto__` trick or whatever it is

[14:37:45.0962] <ljharb>
then whose don't need to wrap because they'll have the slots to begin with, so it doesn't matter what `Iterator.from` does for them

[14:38:12.0240] <ljharb>
why are we concerned with "overhead" for the highly unlikely case of someone doing `{ __proto__: Iterator.prototype }`?

[14:38:42.0354] <ljharb>
unlikely still means nonzero, and having to deal with that complexity (in the current case) is far more dangerous than "it's a bit slower if you do something super weird" (in the "always wrap" case)

[14:38:59.0139] <ljharb>
 * unlikely still means nonzero, and having to deal with that complexity (in the current case) is far more dangerous than "it's a bit slower if you do something super weird" (in the "always wrap" case)

[14:39:45.0721] <snek>
i am lost now

[14:40:36.0674] <snek>
the overhead is when you wrap something that is already matching the "iterator with prototype" definition, which is most iterator objects flying around

[14:41:08.0230] <snek>
 * the overhead is when you wrap something that is already matching the "iterator with prototype" definition, which is most iterator objects flying around

[14:44:11.0723] <ljharb>
anything created from the language or a generator or the web would/could already have the slots it needs. Itâ€™d only be a custom iterator implementation thatâ€™d need wrapping. How common are those?

[14:44:33.0604] <snek>
most custom ones already inherit from Iterator.prototype

[14:44:46.0954] <snek>
or they did, i haven't looked in several years 

[14:44:55.0217] <snek>
i would assume they didn't delete that though lol

[14:45:31.0244] <snek>
the pattern is `[][Symbol.iterator]().__proto__.__proto__`

[14:45:49.0173] <snek>
or getPrototypeOf instead

[14:47:35.0746] <snek>
so anyway to handle the case where they don't, we have this `Iterator.from` helper, and you can throw that in random places as needed

[14:47:49.0977] <snek>
but it exists purely to paper over the prototype

[14:48:43.0178] <snek>
like just thinking about the code i write for my day-to-day work, i would basically never use `Iterator.from`

[15:14:56.0504] <bakkot>
> i think 99% of cases will be dealing with untrusted iterators

i would guess well over 99% of code is internal, not in libraries, and in internal code you are not dealing with untrusted stuff, as a rule

[15:19:10.0909] <bakkot>
also I guess I am missing what the benefit of the internal slot is supposed to be

[15:28:48.0186] <rbuckton>
I voiced an opinion, several years ago now, that I believed the iterator helper methods should always just do `this[Symbol.iterator]()` so that they would work for both `Iterator` *and* Iterables. Then, the presence of `Symbol.iterator` would be enough of a brand check (insomuch as it is the same amount of brand checking that `yield*` and `for..of` care about). 

[15:30:18.0451] <rbuckton>
> <@devsnek:matrix.org> most custom ones already inherit from Iterator.prototype

Most custom "Iterators" I've seen are just `{ next() { ... }, [Symbol.iterator]() { return this; } }`.

[15:40:59.0748] <bakkot>
rbuckton: why would you ever be invoking an iterator helper method on something which was an iterable-and-not-iterator?

[15:41:20.0412] <bakkot>
what is an example of some code where that might come up?

[15:51:22.0240] <rbuckton>
My original argument stems from my belief that Iterator is still the wrong level of abstraction. But aside from that, if the iterator helper methods were to only care about whether the object had a `next()` then we would have the same kind of duck typing we get with `.then()` on Promises. As a result, we end up needing a brand check of some kind which a custom iterator like `{ next() { ... } }` wouldn't have.

[15:51:37.0395] <rbuckton>
 * My original argument stems from my belief that Iterator is still the wrong level of abstraction. But aside from that, if the iterator helper methods were to only care about whether the object had a `next()` then we would have the same kind of duck typing we get with `.then()` on Promises. As a result, we end up needing a brand check of some kind which a custom iterator like `{ next() { ... } }` wouldn't have.

[15:51:43.0883] <ljharb>
that wouldn't be any different than the current proposal which just checks the [[Prototype]] - it's not a brand check if it's based on a public property.

[15:52:15.0471] <ljharb>
> <@rbuckton:matrix.org> Most custom "Iterators" I've seen are just `{ next() { ... }, [Symbol.iterator]() { return this; } }`.

i agree, but why would those use Iterator Helper methods without being passed through `Iterator.from` first?

[15:52:36.0703] <rbuckton>
Honestly I wish we'd left IteratorPrototype alone and had adopted a chainable wrapper object over Iterable, or just bare functions to work with `|>`, but we're probably already too far gone.

[15:53:01.0718] <snek>
i definitely do not want to argue about iterable vs iterator more

[15:55:11.0971] <rbuckton>
> <@devsnek:matrix.org> i definitely do not want to argue about iterable vs iterator more

I've never really changed my opinion, and the fact we're introducing an `Iterator.from()` that could have been an `Iterable.from()` (or some other name) that works over Iterables really reinforces that belief.

[15:55:41.0087] <ljharb>
as has been said many times, iterable isn't a thing. We don't have `Thenable.from` either.

[15:56:04.0549] <ljharb>
it's an adjective to describe the presence of a method.

[15:56:13.0860] <rbuckton>
Iterable is a thing in the spec. Its an object with a `[Symbol.iterator]()` method. 

[15:56:15.0488] <snek>
thats what an iterator is too

[15:56:16.0623] <ljharb>
iterators are kind of both, in that they're a thing and also a protocol

[15:56:18.0309] <snek>
its all a huge mess

[15:56:25.0959] <ljharb>
and yes, iterators are a mess

[15:56:35.0857] <ljharb>
Iterator.from always wrapping into a "Real" Iterator will help clean it up.

[15:57:03.0941] <ljharb>
(that built-in iterators all happen to be iterable isn't a part of the iterator contract, it's just a convenience these happen to have)

[15:57:06.0034] <rbuckton>
According to the spec, a "Real" iterator is an object with a `next()` method that returns a `{ value, done }` object.

[15:57:24.0839] <rbuckton>
The fact that built-in iterators happen to have a shared prototype doesn't matter to that definition.

[15:57:41.0976] <rbuckton>
And the fact they have a shared prototype was always strange to me.

[15:57:56.0504] <snek>
js is indeed strange

[15:58:49.0131] <ljharb>
a real Promise is more than just a thenable. what i thought this proposal was doing was reifying a concept of a real iterator.

[15:59:09.0794] <rbuckton>
TBH, I will almost never reach for iterator helpers when I could use a more fully-capable third-party library, which is the only reason I haven't pushed back harder against it.

[16:00:01.0209] <rbuckton>
I don't think reifying `Iterator` will have anywhere near the impact that `Promise` did. At least, I certainly hope it doesn't.

[16:00:23.0160] <ljharb>
i think that it wouldn't on its own, but the iterator helpers themselves are why it will.

[16:01:06.0542] <ljharb>
i believe this proposal advancing will trigger a sea change in the way APIs are designed - everyone will start preferring lazy computation and passing around iterators instead of collections, which is a big shift from the current world where people tend to pass arrays.

[16:05:33.0616] <rbuckton>
> <@ljharb:matrix.org> i believe this proposal advancing will trigger a sea change in the way APIs are designed - everyone will start preferring lazy computation and passing around iterators instead of collections, which is a big shift from the current world where people tend to pass arrays.

I'm hoping it doesn't. It's the wrong abstraction. I hope it's relegated to the "I need to do this basic thing", and developers reach for the right abstraction for more complex scenarios. 

[16:08:06.0448] <rbuckton>
I honestly think that if `|>` had advanced more quickly we wouldn't be pursuing this at all. 

[16:08:54.0321] <snek>
i really wish we could add things to the stdlib without every delegate being involved in every single decision of every function

[16:09:18.0717] <snek>
temporal achieved this by being large and complex

[16:11:14.0165] <rbuckton>
> <@devsnek:matrix.org> i really wish we could add things to the stdlib without every delegate being involved in every single decision of every function

This is a little more impactful than adding a single function though. 

[16:11:59.0066] <snek>
everything is impactful in some way ðŸ¤·

[16:12:23.0715] <snek>
and to be clear i didn't mean you specifically, i was just thinking about how this has been a proposal for like 3 years

[16:12:43.0919] <snek>
its depressing ðŸ˜”

[16:17:25.0820] <bakkot>
in fairness it's mostly just that people pick it up and put it down

[16:17:34.0935] <bakkot>
it's advancing now because michael and I found time to get back to it

[16:17:50.0431] <bakkot>
not so much because of there being an insurmountable number of details

[16:20:40.0858] <bakkot>
Iterator helper methods _do_ only care about whether their receiver has a `next` method. But this is not at all the same kind of duck typing as with `.then` on promises, because it's on the _receiver_, not an arbitrary other thing; also nothing switches on its presence, just unconditionally attempts to call it. So it lacks the big two problems that thenables have, which are a.) consuming a string-named property on an _argument_, not just the receiver, and b.) changing behavior based on the presence or absence of the property instead of simply throwing in its absence

[16:22:04.0627] <bakkot>
> <@rbuckton:matrix.org> My original argument stems from my belief that Iterator is still the wrong level of abstraction. But aside from that, if the iterator helper methods were to only care about whether the object had a `next()` then we would have the same kind of duck typing we get with `.then()` on Promises. As a result, we end up needing a brand check of some kind which a custom iterator like `{ next() { ... } }` wouldn't have.

 * Iterator helper methods _do_ only care about whether their receiver has a `next` method. But this is not at all the same kind of duck typing as with `.then` on promises, because it's on the _receiver_, not an arbitrary other thing; also nothing switches on its presence, just unconditionally attempts to call it. So it lacks the big two problems that thenables have, which are a.) consuming a string-named property on an _argument_, not just the receiver, and b.) changing behavior based on the presence or absence of the property instead of simply throwing in its absence

[16:23:27.0109] <bakkot>
on that note, ljharb  should we maybe merge https://github.com/tc39/agendas/pull/1233 now, so delegates get a chance to review? we can always back it out if approval doesn't come through

[16:23:35.0448] <bakkot>
> <@devsnek:matrix.org> i definitely do not want to argue about iterable vs iterator more

 * on that note, ljharb  should we maybe merge https://github.com/tc39/agendas/pull/1233 now, so delegates get a chance to review? we can always back it out if approval doesn't come through

[16:24:42.0799] <bakkot>
anyway, I do want to strongly affirm that iterator helpers are precisely the correct abstraction for what they are

[16:26:22.0043] <bakkot>
if the helpers consumed iterables they either a.) produce single-shot iterables, which would be weird and confusing or b.) produce reusable iterables, which would be weird and confusing for other reasons, i.e. https://stackoverflow.com/a/28513908

[16:27:49.0311] <bakkot>
"iterator helpers" or some equivalent are a solution common to most mainstream languages - java, rust, scala, c++ (boost), scala - and they work well

[16:28:17.0893] <bakkot>
 * if the helpers consumed iterables they either a.) produce single-shot iterables, which would be weird and confusing or b.) produce reusable iterables, which would be weird and confusing for other reasons, i.e. https://stackoverflow.com/a/28513908

[16:28:34.0737] <bakkot>
this is not uncharted territory here

[16:29:42.0581] <bakkot>
and I do expect them to get wide adoption, for the same reason they get wide adoption in other languages: they are the right abstraction to express what you want in a wide variety of scenarios, namely single-shot deferred computation

[16:29:54.0494] <bakkot>
 * and I do expect them to get wide adoption, for the same reason they get wide adoption in other languages: they are the right abstraction to express what you want in a wide variety of scenarios, namely single-shot deferred computation

[16:45:52.0531] <rbuckton>
ES2015 established syntactic support for Iterable with `for..of` and `yield*`, even "one-shot" Iterables with generators. The only reason iterator helpers can be used with these constructs is that they are also "one-shot" Iterables. The languages you've referenced with a preference for iterator's are all statically typed. A function can receive an iterator and *know* its an iterator. 

[16:47:29.0135] <rbuckton>
In JS, we are left with either "duck typing" or checking @@iterator. If @ljharb is correct, an ecosystem will be built around *receiving* iterators as well as producing them. And those functions may also need to check the input type. 

[16:48:59.0688] <rbuckton>
Since the ecosystem likes to write overloads, they need some way to check if the input is an Iterator. `next()` is not sufficient. It *is* Promise.p.then() all over again, even if it's a smaller case. 

[16:50:09.0458] <rbuckton>
Today the best way to do that overload check is to check for @@iterator, making the check for an Iterable. That at least still works for iterator helpers, but not for user defined `{ next() {}}`. 

[16:51:41.0504] <snek>
all iterators are also iterables

[16:51:44.0749] <snek>
i think checking for `@@iterator` is fine

[16:51:49.0704] <snek>
 * i think checking for `@@iterator` is fine

[16:51:59.0948] <rbuckton>
Maybe a reified Iterator helps, but it is still just a "one-shot" Iterable as far as `for-of`, `yield*`, `[...iter]`, etc. are concerned. 

[16:52:29.0847] <bakkot>
I do not expect there to be an ecosystem built around receiving iterators. why would there be? you can receive an iterable and consume it only once, and that works just as well.

[16:52:36.0206] <snek>
as for "passing iterators around" that would be interesting i guess, though i don't imagine it becoming that common

[16:52:40.0504] <snek>
looking at other languages like rust

[16:52:43.0460] <rbuckton>
> <@devsnek:matrix.org> all iterators are also iterables

This is false. All built-in iterators and generators, maybe. But not "all". 

[16:53:06.0110] <snek>
yes you're right, all the ones that inherit from the prototype

[16:53:15.0051] <rbuckton>
> <@devsnek:matrix.org> as for "passing iterators around" that would be interesting i guess, though i don't imagine it becoming that common

This is exactly what @ljharb was describing earlier

[16:53:27.0160] <snek>
yeah i don't agree with the prediction 

[16:55:12.0348] <snek>
but either way i don't think it is too problematic

[16:57:08.0220] <ljharb>
if the only way to know if something is an iterator is to consume it, then everyone will have to Iterator.from(x).map(x=>x) to be sure theyâ€™re dealing with one. so why not build that into Iterator.from?

[16:57:22.0194] <bakkot>
the `.map` is not necessary

[16:57:25.0171] <bakkot>
it does nothing


2022-09-06
[17:08:22.0085] <rbuckton>
> <@devsnek:matrix.org> yeah i don't agree with the prediction 

I'd be more inclined to agree if we weren't making it so convenient. If these were just additions to built-in iterators and *maybe* generators, I'd be less concerned. Introducing a global `Iterator` and an adapter like `Iterator.from` feels more like TC39 blessing this as "the way", which I'm not comfortable with. 

[17:13:09.0883] <rbuckton>
Augmenting IteratorPrototype and making it easier to reach for just feels like another opportunity for Array.prototype-like patching that we've been dealing with for years, especially if people start feeling like the helpers available aren't comprehensive enough. 

[17:13:24.0232] <rbuckton>
* Augmenting IteratorPrototype and making it easier to reach for just feels like another opportunity for Array.prototype-like patching that we've been dealing with for years, especially if people start feeling like the helpers available aren't comprehensive enough. 

[17:18:03.0817] <snek>
if pipeline moved forward

[17:18:15.0836] <snek>
i wouldn't be wholly against functions

[17:18:27.0274] <snek>
but without that there's no point even discussing it

[17:59:24.0343] <rbuckton>
As much as I still prefer F#-style, if pipeline could settle on a topic I'd be happy.

[18:01:47.0850] <rbuckton>
> <@devsnek:matrix.org> temporal achieved this by being large and complex

Temporal is amazing for constructing date, time, and tz info. Its API for comparing dates/times is unfortunately ungainly since there's no mechanism for operator overloading, and the fact that `.now()` is detached into its own thing is exceedingly frustrating the times I've used it.

[18:02:05.0624] <rbuckton>
It's like 10 steps forward and 5 steps back

[18:05:52.0203] <rbuckton>
Determining whether an `Instant` occurs in the past is painfully verbose:
```js
Temporal.Instant.compare(instant, Temporal.Now.instant()) < 0
```
But it seems like the API design is very focused on "only one way to do it", regardless of convenience.

[18:09:15.0350] <ptomato>
I don't like `Temporal.Now` either! but it's always been a hard requirement from the plenary AFAIU

[18:09:22.0262] <ptomato>
 * I don't like `Temporal.Now` either! but it's always been a hard requirement from the plenary AFAIU

[18:14:05.0561] <ptomato>
> <@rbuckton:matrix.org> Determining whether an `Instant` occurs in the past is painfully verbose:
> ```js
> Temporal.Instant.compare(instant, Temporal.Now.instant()) < 0
> ```
> But it seems like the API design is very focused on "only one way to do it", regardless of convenience.

I hope nothing I've said caused you to get this impression; eliminating multiple ways to achieve the same thing is not something we've spent time on at all! there's no idiomatic `isBefore` / `isAfter` method because we had to draw the line somewhere

[18:14:53.0819] <ptomato>
you may want to subscribe to https://github.com/js-temporal/proposal-temporal-v2/issues/6

[18:14:56.0874] <snek>
its interesting that `compare` is not an instance method

[18:15:12.0543] <rbuckton>
I think a more general `compareTo` is better.

[18:15:23.0916] <rbuckton>
> <@devsnek:matrix.org> its interesting that `compare` is not an instance method

Its good as a static method for use with `.sort()`

[18:15:34.0865] <snek>
but either way i'm fine with this, people who care deeply about temporal apis are already working on this as has been linked ðŸ˜„

[18:16:04.0939] <rbuckton>
> <@pchimento:igalia.com> you may want to subscribe to https://github.com/js-temporal/proposal-temporal-v2/issues/6

IIRC I commented on a thread about this in the proposal repo at one point

[18:17:04.0236] <snek>
> <@rbuckton:matrix.org> Its good as a static method for use with `.sort()`

yeah personally i'd say just write an arrow function

[18:17:07.0099] <snek>
but this is the sort of thing

[18:17:07.0859] <rbuckton>
Or maybe it was in matrix. I can't find the issue.

[18:17:13.0052] <snek>
i much prefer it existing at all

[18:17:19.0648] <snek>
to it going back and forth based on my opinion

[18:17:23.0558] <snek>
so ðŸ¤·

[18:20:56.0165] <rbuckton>
I really want to introduce generic comparison (not operators) at some point, i.e.:

```ts
interface Equaler {
  equals(a, b): boolean;
  hashCode(x): number;
}
interface Comparer {
  compareTo(a, b): number;
}
```

And allow you to pass an `Equaler` to a `Map`/`Set` constructor, and add things like a `SortedMap`/`StortedSet` like I put together in `@esfx/equaler`, `@esfx/collections-hashmap`, `@esfx/collections-hashset`, `@esfx/collections-stortedmap`, `@esfx/collections-sortedset` (which I wrote as a test bed to test out the implementation).

[18:21:18.0850] <rbuckton>
 * I really want to introduce generic comparison (not operators) at some point, i.e.:

```ts
interface Equaler {
  equals(a, b): boolean;
  hashCode(x): number;
}
interface Comparer {
  compareTo(a, b): number;
}
```

And allow you to pass an `Equaler` to a `Map`/`Set` constructor, and add things like a `SortedMap`/`StortedSet` like I put together in `@esfx/equaler`, `@esfx/collections-hashmap`, `@esfx/collections-hashset`, `@esfx/collections-stortedmap`, `@esfx/collections-sortedset` (which I wrote as a test bed to test out the implementation).

[18:21:50.0708] <rbuckton>
I'd love to be able to have a `Map` whose keys are `URL` or `Temporal.Instant` without having to coerce to a string.

[18:21:52.0384] <Kris Kowal>
Iâ€™ve done similar work with only slightly different names.

[18:22:31.0188] <Kris Kowal>
We had a relevant conversation about deep equality at the most recent SES meeting.

[18:22:32.0399] <bakkot>
> <@rbuckton:matrix.org> Augmenting IteratorPrototype and making it easier to reach for just feels like another opportunity for Array.prototype-like patching that we've been dealing with for years, especially if people start feeling like the helpers available aren't comprehensive enough.

The patching of Array which we occasionally run into is almost entirely pre-ES6 libraries. People are not at all doing that these days, from what I can tell. So I don't really share this concern. Evangelism about not doing that worked, eventually, especially once we started actually adding useful stuff ever.

[18:23:35.0006] <Kris Kowal>
SES meeting on deep equality, where we differentiate structural deep equality and deep equality protocols https://youtu.be/z_gXDSYKlWI

[18:24:43.0638] <Kris Kowal>
Equality, hash, and compare protocols are in http://www.collectionsjs.com/

[18:25:35.0258] <Kris Kowal>
(CollectionsJS isnâ€™t a viable project in its current form because I mispredicted some Array shims. Ooops.)

[18:26:37.0919] <rbuckton>
`@esfx/equatable` has definitions for equality, comparability, structural equality, and structural comparability.

[18:27:22.0987] <rbuckton>
Though my most recent npm publish (today) has a few issues I'm trying to fix. I just switched the hashCode generation to use native code on Node when possible and that's had some hiccups.

[18:27:55.0960] <rbuckton>
 * Though my most recent npm publish (today) has a few issues I'm trying to fix. I just switched the hashCode generation to use native code on Node when possible and that's had some hiccups.

[18:28:00.0470] <Kris Kowal>
Adding protocols to the standard library probably means different Map and Set implementations or a very clever system for overloading their behavior.

[18:29:30.0168] <snek>
i really wish we had a `System.hash(v)` api

[18:29:32.0363] <Kris Kowal>
Collections went the cheap route of random numbers and a weak map. It predates intrinsic Map and Set, so there it does some odd stuff. But, not surfacing information divined from pointers is important.

[18:29:36.0391] <snek>
so we could write our own collections

[18:30:16.0110] <rbuckton>
Agreed. `@esfx/equatable` exposes a `rawHash(v)` API which is essentially the same.

[18:30:34.0325] <snek>
does that hash structurally or based on js identity 

[18:30:42.0224] <rbuckton>
I don't use pointers, I use the same hash identity that V8 uses for objects as keys in a map.

[18:30:49.0614] <rbuckton>
JS identity.

[18:30:54.0665] <snek>
oh its a native fn?

[18:31:02.0983] <Kris Kowal>
Yeah, I suspect thatâ€™s still a side channel.

[18:31:40.0973] <snek>
feel free to `delete System.hash` :P

[18:31:46.0954] <rbuckton>
> <@devsnek:matrix.org> oh its a native fn?

When I can get away with it, yeah. Otherwise its a WeakMap and a random number as a fallback.

[18:31:55.0386] <snek>
oh nice

[18:31:59.0567] <snek>
that's basically how v8 works anyway

[18:32:05.0430] <snek>
well not a weakmap but random numbers yes

[18:32:15.0268] <rbuckton>
At least, as soon as I finish wrangling breaking changes in my monorepo

[18:35:53.0499] <snek>
> <@kriskowal:matrix.org> Yeah, I suspect thatâ€™s still a side channel.

thinking about this more i don't think hash is a side channel 

[18:36:28.0684] <snek>
you can't communicate with it

[18:37:11.0461] <bakkot>
as long as it's mixed with an actually random number

[18:37:33.0454] <snek>
i think every js engine that cares about this sort of thing does that anyway

[18:37:36.0878] <snek>
due to hash collision attacks

[18:37:51.0016] <snek>
 * i think every js engine that cares about this sort of thing does that anyway

[18:38:26.0122] <bakkot>
yeah and because getting the address of an object in memory is one gadget which is used as a step in a lot of exploits

[18:38:37.0323] <snek>
oh right yeah do not use the address lmao

[18:39:03.0157] <bakkot>
I suspect none of the major engines would do it but if were were adding something like this we'd need to have a big loud note about including a good random value as a component

[18:39:27.0054] <snek>
i hear 4 is a great random number

[18:39:27.0258] <bakkot>
and it would be another source of nondeterminism, which... we should figure out a better story about adding those in general

[18:41:27.0745] <snek>
hmmmmmmMMMMMM

[18:41:36.0801] <snek>
actually no i'm dumb

[18:41:58.0533] <snek>
i was gonna say "does the hash actually have to be a transparent value" and then i realized how useless it would be if it was opaque lul

[18:42:25.0347] <snek>
 * i was gonna say "does the hash actually have to be a transparent value" and then i realized how useless it would be if it was opaque lul

[18:47:54.0717] <rbuckton>
It needs to be a number value (preferably uint32) to bucketize things efficiently.

