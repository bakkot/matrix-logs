2022-09-01
[13:58:31.0354] <Justin Ridgewell>
Can I get write access to test262?

[13:58:52.0185] <Justin Ridgewell>
Trying to update the group/groupToMap PRs made by another contributor, but I can't push without access.


2022-09-02
[09:07:30.0976] <ljharb>
Justin Ridgewell: i just added you with write access, in theory CODEOWNERS should prevent you from merging but Write should allow you to force push to the PR; please lmk if theory doesn't hold

[09:28:51.0497] <Justin Ridgewell>
Thanks

[09:50:33.0114] <bterlson>
< 24 hours to get your agenda items in for the next meeting! Looks like this will be a short one unless folks are waiting for the last possible second.

[15:03:56.0082] <bakkot>
ljharb (or any admin): can I be given write access to https://github.com/tc39/proposal-set-methods? 😅

[15:20:57.0381] <ljharb>
done

[16:48:49.0262] <bakkot>
ljharb re https://github.com/tc39/proposal-iterator-helpers/issues/117#issuecomment-1235980915 "i'd prefer it brand-check" - what do you actually want it to brand check?

[16:49:05.0131] <bakkot>
I'm confused about what the ask is

[16:58:02.0516] <ljharb>
instances of iterator

[16:58:17.0160] <ljharb>
so it throws if anyone extracts the getter and dot calls it on something different


2022-09-03
[18:18:56.0824] <bakkot>
so an `instanceof` check, you mean? that doesn't seem that useful; you can do that yourself

[22:05:49.0750] <ljharb>
no, not an instanceof check, those are forgeable and don't work across realms. a brand check.

[09:00:22.0548] <bakkot>
ljharb: what brand do you imagine checking? there are a bunch of different built-in iterators in the language and the web platform, and they don't have a common brand

[09:00:46.0177] <bakkot>
the whole point of iterator being an interface is that the interface is implemented by a bunch of different classes, including userland classes

[09:02:50.0840] <littledan>
IMO the appropriate level for a brand check here would be to revert the whole Symbol.toStringTag change in the first place... what a bad idea of a feature. Not clear if it makes sense to "chip away at it" as much as I'm sympathetic with the idea to try.

[09:06:01.0455] <littledan>
it's not unthinkable to add a brand just for this purpose in https://tc39.es/proposal-iterator-helpers/#sec-iterator but I don't see the point

[09:06:41.0126] <littledan>
(do we want to start telling people, they shouldn't be pasting iterator helpers onto a base class by messing with a prototype chain? that seems like a useful mode to me)

[09:07:01.0926] <littledan>
 * (do we want to start telling people, they shouldn't be pasting iterator helpers onto a base class by messing with a prototype chain? that seems like a useful mode to me)


2022-09-04
[18:42:16.0345] <ljharb>
they do have a common brand now, it’s what Iterator.from provides

[18:42:40.0929] <ljharb>
and a userland class will be wrapped by a branded object.

[08:36:39.0724] <bakkot>
Iterator.from checks `instanceof Iterator` and returns the original object if that returns true

[08:36:52.0231] <bakkot>
so no, it does not provide a common brand

[08:37:01.0436] <bakkot>
 * so no, it does not provide a common brand

[10:33:56.0875] <snek>
without first class protocols the only ways to check if something is an actual iterator is either rely on the prototype or exhaustively interrogate its methods 

[10:34:20.0633] <snek>
* without first class protocols the only ways to check if something is an actual iterator is either rely on the prototype or exhaustively interrogate its methods 

[11:17:16.0208] <rbuckton>
This is one reason why I'm still wary of using Iterator rather than an Iterable. 


2022-09-05
[18:13:02.0539] <ljharb>
i didn’t realize that. It shouldn’t use instanceof - like everything else in the language, it should use a brand.

[18:17:51.0847] <bakkot>
no, it's an interface

[18:17:54.0377] <bakkot>
it's not a class

[18:17:58.0963] <bakkot>
I mean, it is also a class

[18:18:30.0356] <bakkot>
but there is no particular reason a userland instance needs to have the brand

[19:14:15.0471] <snek>
> <@ljharb:matrix.org> i didn’t realize that. It shouldn’t use instanceof - like everything else in the language, it should use a brand.

how do you brand something whose definition is "has a next method that returns { value, done }"

[19:15:56.0312] <snek>
or if you subscribe to the other idea, "an object inheriting Iterator.prototype"

[20:35:23.0409] <ljharb>
objects in the language that inherit from a prototype also have a brand, thats checked in places. 

[20:38:35.0852] <snek>
no i like

[20:38:42.0553] <snek>
i do not understand the mechanic by which this would work

[10:17:26.0579] <ljharb>
anything that's `instanceof Iterator` in the language would have an internal slot, which is what Iterator.from would check

[10:28:14.0641] <bakkot>
in the language or, presumably, the web platform?

[10:28:28.0850] <bakkot>
I suppose that would be possible but... why?

[11:22:09.0722] <snek>
> <@ljharb:matrix.org> anything that's `instanceof Iterator` in the language would have an internal slot, which is what Iterator.from would check

how do they get the internal slot? they're just random objects

[11:23:40.0028] <snek>
oh are you saying Iterator.from would be the thing that produces objects with that slot

[11:25:30.0272] <snek>
technically the new object it returns has `[[Iterated]]`

[11:25:31.0130] <snek>
but

[11:25:37.0717] <snek>
it doesn't have to return the new object

[11:26:10.0577] <snek>
like if i run `Iterator.from({ next() {}, __proto__: Iterator.prototype })`, it should return that argument unchanged

[12:26:30.0104] <ljharb>
that doesn’t seem like what it should be doing at all.

[12:27:17.0394] <ljharb>
Array.from doesnt pass through return an arraylike object that has a proto of Array.prototype - it returns a proper array. So should Iterator.from.

[12:28:31.0086] <bakkot>
the definition of "proper iterator" _is_ "inherits from Iterator.prototype", in this context

[12:44:30.0140] <ljharb>
i don't think that is or should be the definition

[13:00:34.0611] <bakkot>
why?

[14:08:11.0778] <snek>
Iterator is not a concrete thing, I'd rather rename the method if that's the problem

[14:15:40.0372] <ljharb>
the whole point of Iterator.from is that it's becoming a concrete thing

[14:15:49.0067] <snek>
no its just that its giving it the prototype

[14:16:05.0528] <snek>
its a convenience for the methods

[14:16:47.0742] <ljharb>
… and the methods do a wrap (to something with the slot) if they're `.call`ed on a random object?

[14:17:33.0567] <snek>
i don't understand what this means

[14:17:41.0235] <ljharb>
the `[[Iterated]]` slot you mentioned

[14:18:21.0801] <snek>
`[[Iterated]]` is just used for %WrapForValidIteratorPrototype%.next/return

[14:18:33.0754] <ljharb>
how can the next method retain internal state unless it has a place to put it?

[14:19:11.0869] <snek>
WrapForValidIteratorPrototype objects don't have any internal state

[14:19:24.0161] <snek>
[[Iterated]] is just the object they wrap

[14:19:41.0461] <snek>
well, the iterator record for it

[14:20:57.0151] <ljharb>
ok so like `map`. it has to hold on to the original iterator, and to the callback

[14:21:15.0595] <ljharb>
so presumably the iterator object returned by `map` holds that, in an internal slot

[14:21:53.0713] <snek>
they use closures

[14:22:27.0105] <ljharb>
so the iterator object doesn't use a shared `next` method, it makes a new one each time `map` is called?

[14:22:39.0264] <snek>
uhh

[14:22:43.0674] <snek>
it uses %IteratorHelperPrototype%.next

[14:22:47.0801] <snek>
 * it uses %IteratorHelperPrototype%.next

[14:22:48.0948] <ljharb>
right. but that's a shared method.

[14:22:55.0382] <snek>
which is just %GeneratorPrototype%.next but fancy

[14:22:56.0847] <ljharb>
so it can't close over something that's unique to a given `map` call

[14:23:10.0849] <ljharb>
because it exists before `map` is ever called.

[14:23:11.0878] <snek>
 * which is just %GeneratorPrototype%.next but fancy

[14:23:24.0823] <ljharb>
so where is that state held so that `next` can access it?

[14:23:39.0873] <snek>
same place that normal generators store it

[14:23:50.0121] <snek>
the only thing is

[14:24:06.0149] <snek>
you can grep for `[[GeneratorBrand]]` in the spec

[14:24:06.0150] <ljharb>
right but that's in a slot on the generator instance, no?

[14:24:13.0324] <snek>
https://tc39.es/ecma262/#sec-generatorvalidate

[14:24:19.0829] <snek>
this is the only way it tells them apart

[14:24:28.0839] <snek>
but that just tells you if it was a generator helper method

[14:24:42.0969] <snek>
tbh i'm not sure why we separate them at all, they just call `GeneratorResume`

[14:25:04.0878] <ljharb>
right. and [[GeneratorContext]] and [[GeneratorState]] are slots on the iterator object that hold the state

[14:25:22.0708] <snek>
yeah its a generator

[14:25:27.0530] <ljharb>
right

[14:26:03.0805] <ljharb>
and GeneratorValidate brand-checks the iterator. it doesn't matter what its [[Prototype]] is, it matters if it has the expected slots.

[14:26:12.0585] <snek>
ye

[14:26:25.0083] <ljharb>
so i assume that Iterator Helper methods all do the same validation

[14:26:51.0015] <snek>
iterator helper methods do not know about those brand checks, they perform them via calling stuff like `GeneratorResume`

[14:26:57.0036] <ljharb>
right but they still exist

[14:26:59.0533] <snek>
sure

[14:27:01.0744] <ljharb>
which means that `{ __proto__: Iterator.prototype }` would fail that check, and not be a usable receiver with the Iterator Helper methods. which means Iterator.from musn't ever return it.

[14:27:17.0449] <ljharb>
which means that Iterator.from always returns a brand-checkable object, one that GeneratorValidate will accept.

[14:27:26.0938] <snek>
uhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh

[14:27:27.0624] <snek>
no

[14:27:36.0444] <ljharb>
what am i missing there?

[14:28:00.0628] <snek>
assuming this `let iterWithGeneratorSlots = [].values().map(x => x); `

[14:28:22.0541] <snek>
`Iterator.from(iterWithGeneratorSlots)` passes it through unchanged because it inherits from %Iterator.prototype%

[14:28:24.0787] <snek>
but

[14:28:57.0242] <snek>
if you do `Iterator.from({ next() {}, __proto__: Iterator.prototype })` it also passes it through unchanged

[14:29:04.0970] <snek>
that's not doing any generator stuff

[14:29:29.0694] <snek>
if you do `Iterator.from({ next() {} })` that creates a %WrapForValidIteratorPrototype% object and returns it

[14:29:30.0204] <ljharb>
ok but what happens with `Iterator.from({ next() {}, __proto__: Iterator.prototype }).map(x => x)`?

[14:29:37.0331] <snek>
but that still doesn't have any generator slots

[14:29:40.0615] <snek>
cuz its not a generator

[14:29:44.0860] <snek>
its just a stupid wrapper

[14:29:51.0977] <snek>
> <@ljharb:matrix.org> ok but what happens with `Iterator.from({ next() {}, __proto__: Iterator.prototype }).map(x => x)`?

that has generator slots cuz you called map

[14:30:06.0286] <ljharb>
ok, and `.map` doesn't care if its receiver has the slots?

[14:30:07.0853] <ljharb>
 * ok, and `.map` doesn't care if its receiver has the slots?

[14:30:12.0540] <snek>
no it does not

[14:30:15.0145] <ljharb>
oof

[14:30:19.0662] <snek>
all it cares is that the receiver is an iterator

[14:30:59.0446] <snek>
https://gc.gy/130118458.png

[14:32:13.0928] <snek>
this is why `{ next() {}, __proto__: Iterator.prototype }` is valid

[14:32:52.0882] <snek>
with protocols you have to assume that the object is already created as some other shape, you're augmenting them with the functionality, implementing the protocol on top of something else

[14:33:04.0619] <ljharb>
i don't understand why, if everyone's going to `Iterator.from()` anyways to get the methods, we wouldn't want to unconditionally wrap - ie, to unconditionally `.map(x => x)`

[14:33:24.0469] <ljharb>
 * i don't understand why, if everyone's going to `Iterator.from()` anyways to get the methods, we wouldn't want to unconditionally wrap - ie, to unconditionally `.map(x => x)`

[14:33:32.0370] <snek>
i think its pretty rare that you would *need* to use Iterator.from

[14:33:34.0392] <ljharb>
that way we have a consistent "real iterator" definition

[14:34:06.0617] <ljharb>
i think you'll want to do it any time you're dealing with a user-supplied iterator. which will be frequent.

[14:34:27.0005] <snek>
i mean, those are rare lol

[14:34:27.0301] <ljharb>
you'd want to maximally accept and normalize all possible iterators

[14:34:33.0290] <ljharb>
that's what `Promise.resolve` is good for too

[14:34:36.0360] <snek>
yeah i mean

[14:34:41.0810] <ljharb>
it normalizes thenables into Real Promises, which are always preferred

[14:34:46.0635] <snek>
if you're you, writing some sort of complex fancy library that has to deal with the world

[14:34:49.0388] <ljharb>
similarly i'd always want a Real Iterator, not just an "iterator"

[14:34:51.0688] <snek>
go for it

[14:35:06.0469] <ljharb>
this isn't just a "my unique coding style" thing tho, this is any package

[14:35:25.0531] <ljharb>
anything that accepts an iterator. just like anything that accepts a thenable always uses Promise.resolve or `await` to normalize it first into a real promise

[14:35:35.0379] <ljharb>
Iterator.from will be exceedingly common imo.

[14:35:35.0989] <snek>
its a nice convenient method yeah

[14:35:38.0604] <snek>
i was just pointing out

[14:35:44.0264] <snek>
its superfluous in 99% of cases

[14:36:01.0138] <snek>
so we made it not add extra overhead

[14:36:01.0299] <ljharb>
i don't think that's true

[14:36:08.0795] <ljharb>
i think 99% of cases will be dealing with untrusted iterators

[14:36:19.0924] <ljharb>
the case where you're iterating your own iterator are likely to be far rarer. (where "your own" doesn't deal with who the author is, but which chunk of code owns it)

[14:36:36.0548] <ljharb>
 * the case where you're iterating your own iterator are likely to be far rarer. (where "your own" doesn't deal with who the author is, but which chunk of code owns it)

[14:37:23.0449] <ljharb>
"extra overhead" isn't a real problem (it can be optimized away), but a footgun like "sometimes it doesn't wrap" imo would be

[14:37:27.0301] <snek>
the genesis of this proposal was the observation that all web and js platform iterators already inherit from a shared %IteratorPrototype%

[14:37:31.0109] <ljharb>
 * "extra overhead" isn't a real problem (it can be optimized away), but a footgun like "sometimes it doesn't wrap" imo would be

[14:37:45.0242] <snek>
and the remaining weird ones often use the `(function*(){})().next().__proto__` trick or whatever it is

[14:37:45.0962] <ljharb>
then whose don't need to wrap because they'll have the slots to begin with, so it doesn't matter what `Iterator.from` does for them

[14:38:12.0240] <ljharb>
why are we concerned with "overhead" for the highly unlikely case of someone doing `{ __proto__: Iterator.prototype }`?

[14:38:42.0354] <ljharb>
unlikely still means nonzero, and having to deal with that complexity (in the current case) is far more dangerous than "it's a bit slower if you do something super weird" (in the "always wrap" case)

[14:38:59.0139] <ljharb>
 * unlikely still means nonzero, and having to deal with that complexity (in the current case) is far more dangerous than "it's a bit slower if you do something super weird" (in the "always wrap" case)

[14:39:45.0721] <snek>
i am lost now

[14:40:36.0674] <snek>
the overhead is when you wrap something that is already matching the "iterator with prototype" definition, which is most iterator objects flying around

[14:41:08.0230] <snek>
 * the overhead is when you wrap something that is already matching the "iterator with prototype" definition, which is most iterator objects flying around

[14:44:11.0723] <ljharb>
anything created from the language or a generator or the web would/could already have the slots it needs. It’d only be a custom iterator implementation that’d need wrapping. How common are those?

[14:44:33.0604] <snek>
most custom ones already inherit from Iterator.prototype

[14:44:46.0954] <snek>
or they did, i haven't looked in several years 

[14:44:55.0217] <snek>
i would assume they didn't delete that though lol

[14:45:31.0244] <snek>
the pattern is `[][Symbol.iterator]().__proto__.__proto__`

[14:45:49.0173] <snek>
or getPrototypeOf instead

[14:47:35.0746] <snek>
so anyway to handle the case where they don't, we have this `Iterator.from` helper, and you can throw that in random places as needed

[14:47:49.0977] <snek>
but it exists purely to paper over the prototype

[14:48:43.0178] <snek>
like just thinking about the code i write for my day-to-day work, i would basically never use `Iterator.from`

[15:14:56.0504] <bakkot>
> i think 99% of cases will be dealing with untrusted iterators

i would guess well over 99% of code is internal, not in libraries, and in internal code you are not dealing with untrusted stuff, as a rule

[15:19:10.0909] <bakkot>
also I guess I am missing what the benefit of the internal slot is supposed to be

[15:28:48.0186] <rbuckton>
I voiced an opinion, several years ago now, that I believed the iterator helper methods should always just do `this[Symbol.iterator]()` so that they would work for both `Iterator` *and* Iterables. Then, the presence of `Symbol.iterator` would be enough of a brand check (insomuch as it is the same amount of brand checking that `yield*` and `for..of` care about). 

[15:30:18.0451] <rbuckton>
> <@devsnek:matrix.org> most custom ones already inherit from Iterator.prototype

Most custom "Iterators" I've seen are just `{ next() { ... }, [Symbol.iterator]() { return this; } }`.

[15:40:59.0748] <bakkot>
rbuckton: why would you ever be invoking an iterator helper method on something which was an iterable-and-not-iterator?

[15:41:20.0412] <bakkot>
what is an example of some code where that might come up?

[15:51:22.0240] <rbuckton>
My original argument stems from my belief that Iterator is still the wrong level of abstraction. But aside from that, if the iterator helper methods were to only care about whether the object had a `next()` then we would have the same kind of duck typing we get with `.then()` on Promises. As a result, we end up needing a brand check of some kind which a custom iterator like `{ next() { ... } }` wouldn't have.

[15:51:37.0395] <rbuckton>
 * My original argument stems from my belief that Iterator is still the wrong level of abstraction. But aside from that, if the iterator helper methods were to only care about whether the object had a `next()` then we would have the same kind of duck typing we get with `.then()` on Promises. As a result, we end up needing a brand check of some kind which a custom iterator like `{ next() { ... } }` wouldn't have.

[15:51:43.0883] <ljharb>
that wouldn't be any different than the current proposal which just checks the [[Prototype]] - it's not a brand check if it's based on a public property.

[15:52:15.0471] <ljharb>
> <@rbuckton:matrix.org> Most custom "Iterators" I've seen are just `{ next() { ... }, [Symbol.iterator]() { return this; } }`.

i agree, but why would those use Iterator Helper methods without being passed through `Iterator.from` first?

[15:52:36.0703] <rbuckton>
Honestly I wish we'd left IteratorPrototype alone and had adopted a chainable wrapper object over Iterable, or just bare functions to work with `|>`, but we're probably already too far gone.

[15:53:01.0718] <snek>
i definitely do not want to argue about iterable vs iterator more

[15:55:11.0971] <rbuckton>
> <@devsnek:matrix.org> i definitely do not want to argue about iterable vs iterator more

I've never really changed my opinion, and the fact we're introducing an `Iterator.from()` that could have been an `Iterable.from()` (or some other name) that works over Iterables really reinforces that belief.

[15:55:41.0087] <ljharb>
as has been said many times, iterable isn't a thing. We don't have `Thenable.from` either.

[15:56:04.0549] <ljharb>
it's an adjective to describe the presence of a method.

[15:56:13.0860] <rbuckton>
Iterable is a thing in the spec. Its an object with a `[Symbol.iterator]()` method. 

[15:56:15.0488] <snek>
thats what an iterator is too

[15:56:16.0623] <ljharb>
iterators are kind of both, in that they're a thing and also a protocol

[15:56:18.0309] <snek>
its all a huge mess

[15:56:25.0959] <ljharb>
and yes, iterators are a mess

[15:56:35.0857] <ljharb>
Iterator.from always wrapping into a "Real" Iterator will help clean it up.

[15:57:03.0941] <ljharb>
(that built-in iterators all happen to be iterable isn't a part of the iterator contract, it's just a convenience these happen to have)

[15:57:06.0034] <rbuckton>
According to the spec, a "Real" iterator is an object with a `next()` method that returns a `{ value, done }` object.

[15:57:24.0839] <rbuckton>
The fact that built-in iterators happen to have a shared prototype doesn't matter to that definition.

[15:57:41.0976] <rbuckton>
And the fact they have a shared prototype was always strange to me.

[15:57:56.0504] <snek>
js is indeed strange

[15:58:49.0131] <ljharb>
a real Promise is more than just a thenable. what i thought this proposal was doing was reifying a concept of a real iterator.

[15:59:09.0794] <rbuckton>
TBH, I will almost never reach for iterator helpers when I could use a more fully-capable third-party library, which is the only reason I haven't pushed back harder against it.

[16:00:01.0209] <rbuckton>
I don't think reifying `Iterator` will have anywhere near the impact that `Promise` did. At least, I certainly hope it doesn't.

[16:00:23.0160] <ljharb>
i think that it wouldn't on its own, but the iterator helpers themselves are why it will.

[16:01:06.0542] <ljharb>
i believe this proposal advancing will trigger a sea change in the way APIs are designed - everyone will start preferring lazy computation and passing around iterators instead of collections, which is a big shift from the current world where people tend to pass arrays.

[16:05:33.0616] <rbuckton>
> <@ljharb:matrix.org> i believe this proposal advancing will trigger a sea change in the way APIs are designed - everyone will start preferring lazy computation and passing around iterators instead of collections, which is a big shift from the current world where people tend to pass arrays.

I'm hoping it doesn't. It's the wrong abstraction. I hope it's relegated to the "I need to do this basic thing", and developers reach for the right abstraction for more complex scenarios. 

[16:08:06.0448] <rbuckton>
I honestly think that if `|>` had advanced more quickly we wouldn't be pursuing this at all. 

[16:08:54.0321] <snek>
i really wish we could add things to the stdlib without every delegate being involved in every single decision of every function

[16:09:18.0717] <snek>
temporal achieved this by being large and complex

[16:11:14.0165] <rbuckton>
> <@devsnek:matrix.org> i really wish we could add things to the stdlib without every delegate being involved in every single decision of every function

This is a little more impactful than adding a single function though. 

[16:11:59.0066] <snek>
everything is impactful in some way 🤷

[16:12:23.0715] <snek>
and to be clear i didn't mean you specifically, i was just thinking about how this has been a proposal for like 3 years

[16:12:43.0919] <snek>
its depressing 😔

[16:17:25.0820] <bakkot>
in fairness it's mostly just that people pick it up and put it down

[16:17:34.0935] <bakkot>
it's advancing now because michael and I found time to get back to it

[16:17:50.0431] <bakkot>
not so much because of there being an insurmountable number of details

[16:20:40.0858] <bakkot>
Iterator helper methods _do_ only care about whether their receiver has a `next` method. But this is not at all the same kind of duck typing as with `.then` on promises, because it's on the _receiver_, not an arbitrary other thing; also nothing switches on its presence, just unconditionally attempts to call it. So it lacks the big two problems that thenables have, which are a.) consuming a string-named property on an _argument_, not just the receiver, and b.) changing behavior based on the presence or absence of the property instead of simply throwing in its absence

[16:22:04.0627] <bakkot>
> <@rbuckton:matrix.org> My original argument stems from my belief that Iterator is still the wrong level of abstraction. But aside from that, if the iterator helper methods were to only care about whether the object had a `next()` then we would have the same kind of duck typing we get with `.then()` on Promises. As a result, we end up needing a brand check of some kind which a custom iterator like `{ next() { ... } }` wouldn't have.

 * Iterator helper methods _do_ only care about whether their receiver has a `next` method. But this is not at all the same kind of duck typing as with `.then` on promises, because it's on the _receiver_, not an arbitrary other thing; also nothing switches on its presence, just unconditionally attempts to call it. So it lacks the big two problems that thenables have, which are a.) consuming a string-named property on an _argument_, not just the receiver, and b.) changing behavior based on the presence or absence of the property instead of simply throwing in its absence

[16:23:27.0109] <bakkot>
on that note, ljharb  should we maybe merge https://github.com/tc39/agendas/pull/1233 now, so delegates get a chance to review? we can always back it out if approval doesn't come through

[16:23:35.0448] <bakkot>
> <@devsnek:matrix.org> i definitely do not want to argue about iterable vs iterator more

 * on that note, ljharb  should we maybe merge https://github.com/tc39/agendas/pull/1233 now, so delegates get a chance to review? we can always back it out if approval doesn't come through

[16:24:42.0799] <bakkot>
anyway, I do want to strongly affirm that iterator helpers are precisely the correct abstraction for what they are

[16:26:22.0043] <bakkot>
if the helpers consumed iterables they either a.) produce single-shot iterables, which would be weird and confusing or b.) produce reusable iterables, which would be weird and confusing for other reasons, i.e. https://stackoverflow.com/a/28513908

[16:27:49.0311] <bakkot>
"iterator helpers" or some equivalent are a solution common to most mainstream languages - java, rust, scala, c++ (boost), scala - and they work well

[16:28:17.0893] <bakkot>
 * if the helpers consumed iterables they either a.) produce single-shot iterables, which would be weird and confusing or b.) produce reusable iterables, which would be weird and confusing for other reasons, i.e. https://stackoverflow.com/a/28513908

[16:28:34.0737] <bakkot>
this is not uncharted territory here

[16:29:42.0581] <bakkot>
and I do expect them to get wide adoption, for the same reason they get wide adoption in other languages: they are the right abstraction to express what you want in a wide variety of scenarios, namely single-shot deferred computation

[16:29:54.0494] <bakkot>
 * and I do expect them to get wide adoption, for the same reason they get wide adoption in other languages: they are the right abstraction to express what you want in a wide variety of scenarios, namely single-shot deferred computation

[16:45:52.0531] <rbuckton>
ES2015 established syntactic support for Iterable with `for..of` and `yield*`, even "one-shot" Iterables with generators. The only reason iterator helpers can be used with these constructs is that they are also "one-shot" Iterables. The languages you've referenced with a preference for iterator's are all statically typed. A function can receive an iterator and *know* its an iterator. 

[16:47:29.0135] <rbuckton>
In JS, we are left with either "duck typing" or checking @@iterator. If @ljharb is correct, an ecosystem will be built around *receiving* iterators as well as producing them. And those functions may also need to check the input type. 

[16:48:59.0688] <rbuckton>
Since the ecosystem likes to write overloads, they need some way to check if the input is an Iterator. `next()` is not sufficient. It *is* Promise.p.then() all over again, even if it's a smaller case. 

[16:50:09.0458] <rbuckton>
Today the best way to do that overload check is to check for @@iterator, making the check for an Iterable. That at least still works for iterator helpers, but not for user defined `{ next() {}}`. 

[16:51:41.0504] <snek>
all iterators are also iterables

[16:51:44.0749] <snek>
i think checking for `@@iterator` is fine

[16:51:49.0704] <snek>
 * i think checking for `@@iterator` is fine

[16:51:59.0948] <rbuckton>
Maybe a reified Iterator helps, but it is still just a "one-shot" Iterable as far as `for-of`, `yield*`, `[...iter]`, etc. are concerned. 

[16:52:29.0847] <bakkot>
I do not expect there to be an ecosystem built around receiving iterators. why would there be? you can receive an iterable and consume it only once, and that works just as well.

[16:52:36.0206] <snek>
as for "passing iterators around" that would be interesting i guess, though i don't imagine it becoming that common

[16:52:40.0504] <snek>
looking at other languages like rust

[16:52:43.0460] <rbuckton>
> <@devsnek:matrix.org> all iterators are also iterables

This is false. All built-in iterators and generators, maybe. But not "all". 

[16:53:06.0110] <snek>
yes you're right, all the ones that inherit from the prototype

[16:53:15.0051] <rbuckton>
> <@devsnek:matrix.org> as for "passing iterators around" that would be interesting i guess, though i don't imagine it becoming that common

This is exactly what @ljharb was describing earlier

[16:53:27.0160] <snek>
yeah i don't agree with the prediction 

[16:55:12.0348] <snek>
but either way i don't think it is too problematic

[16:57:08.0220] <ljharb>
if the only way to know if something is an iterator is to consume it, then everyone will have to Iterator.from(x).map(x=>x) to be sure they’re dealing with one. so why not build that into Iterator.from?

[16:57:22.0194] <bakkot>
the `.map` is not necessary

[16:57:25.0171] <bakkot>
it does nothing


2022-09-06
[17:08:22.0085] <rbuckton>
> <@devsnek:matrix.org> yeah i don't agree with the prediction 

I'd be more inclined to agree if we weren't making it so convenient. If these were just additions to built-in iterators and *maybe* generators, I'd be less concerned. Introducing a global `Iterator` and an adapter like `Iterator.from` feels more like TC39 blessing this as "the way", which I'm not comfortable with. 

[17:13:09.0883] <rbuckton>
Augmenting IteratorPrototype and making it easier to reach for just feels like another opportunity for Array.prototype-like patching that we've been dealing with for years, especially if people start feeling like the helpers available aren't comprehensive enough. 

[17:13:24.0232] <rbuckton>
* Augmenting IteratorPrototype and making it easier to reach for just feels like another opportunity for Array.prototype-like patching that we've been dealing with for years, especially if people start feeling like the helpers available aren't comprehensive enough. 

[17:18:03.0817] <snek>
if pipeline moved forward

[17:18:15.0836] <snek>
i wouldn't be wholly against functions

[17:18:27.0274] <snek>
but without that there's no point even discussing it

[17:59:24.0343] <rbuckton>
As much as I still prefer F#-style, if pipeline could settle on a topic I'd be happy.

[18:01:47.0850] <rbuckton>
> <@devsnek:matrix.org> temporal achieved this by being large and complex

Temporal is amazing for constructing date, time, and tz info. Its API for comparing dates/times is unfortunately ungainly since there's no mechanism for operator overloading, and the fact that `.now()` is detached into its own thing is exceedingly frustrating the times I've used it.

[18:02:05.0624] <rbuckton>
It's like 10 steps forward and 5 steps back

[18:05:52.0203] <rbuckton>
Determining whether an `Instant` occurs in the past is painfully verbose:
```js
Temporal.Instant.compare(instant, Temporal.Now.instant()) < 0
```
But it seems like the API design is very focused on "only one way to do it", regardless of convenience.

[18:09:15.0350] <ptomato>
I don't like `Temporal.Now` either! but it's always been a hard requirement from the plenary AFAIU

[18:09:22.0262] <ptomato>
 * I don't like `Temporal.Now` either! but it's always been a hard requirement from the plenary AFAIU

[18:14:05.0561] <ptomato>
> <@rbuckton:matrix.org> Determining whether an `Instant` occurs in the past is painfully verbose:
> ```js
> Temporal.Instant.compare(instant, Temporal.Now.instant()) < 0
> ```
> But it seems like the API design is very focused on "only one way to do it", regardless of convenience.

I hope nothing I've said caused you to get this impression; eliminating multiple ways to achieve the same thing is not something we've spent time on at all! there's no idiomatic `isBefore` / `isAfter` method because we had to draw the line somewhere

[18:14:53.0819] <ptomato>
you may want to subscribe to https://github.com/js-temporal/proposal-temporal-v2/issues/6

[18:14:56.0874] <snek>
its interesting that `compare` is not an instance method

[18:15:12.0543] <rbuckton>
I think a more general `compareTo` is better.

[18:15:23.0916] <rbuckton>
> <@devsnek:matrix.org> its interesting that `compare` is not an instance method

Its good as a static method for use with `.sort()`

[18:15:34.0865] <snek>
but either way i'm fine with this, people who care deeply about temporal apis are already working on this as has been linked 😄

[18:16:04.0939] <rbuckton>
> <@pchimento:igalia.com> you may want to subscribe to https://github.com/js-temporal/proposal-temporal-v2/issues/6

IIRC I commented on a thread about this in the proposal repo at one point

[18:17:04.0236] <snek>
> <@rbuckton:matrix.org> Its good as a static method for use with `.sort()`

yeah personally i'd say just write an arrow function

[18:17:07.0099] <snek>
but this is the sort of thing

[18:17:07.0859] <rbuckton>
Or maybe it was in matrix. I can't find the issue.

[18:17:13.0052] <snek>
i much prefer it existing at all

[18:17:19.0648] <snek>
to it going back and forth based on my opinion

[18:17:23.0558] <snek>
so 🤷

[18:20:56.0165] <rbuckton>
I really want to introduce generic comparison (not operators) at some point, i.e.:

```ts
interface Equaler {
  equals(a, b): boolean;
  hashCode(x): number;
}
interface Comparer {
  compareTo(a, b): number;
}
```

And allow you to pass an `Equaler` to a `Map`/`Set` constructor, and add things like a `SortedMap`/`StortedSet` like I put together in `@esfx/equaler`, `@esfx/collections-hashmap`, `@esfx/collections-hashset`, `@esfx/collections-stortedmap`, `@esfx/collections-sortedset` (which I wrote as a test bed to test out the implementation).

[18:21:18.0850] <rbuckton>
 * I really want to introduce generic comparison (not operators) at some point, i.e.:

```ts
interface Equaler {
  equals(a, b): boolean;
  hashCode(x): number;
}
interface Comparer {
  compareTo(a, b): number;
}
```

And allow you to pass an `Equaler` to a `Map`/`Set` constructor, and add things like a `SortedMap`/`StortedSet` like I put together in `@esfx/equaler`, `@esfx/collections-hashmap`, `@esfx/collections-hashset`, `@esfx/collections-stortedmap`, `@esfx/collections-sortedset` (which I wrote as a test bed to test out the implementation).

[18:21:50.0708] <rbuckton>
I'd love to be able to have a `Map` whose keys are `URL` or `Temporal.Instant` without having to coerce to a string.

[18:21:52.0384] <Kris Kowal>
I’ve done similar work with only slightly different names.

[18:22:31.0188] <Kris Kowal>
We had a relevant conversation about deep equality at the most recent SES meeting.

[18:22:32.0399] <bakkot>
> <@rbuckton:matrix.org> Augmenting IteratorPrototype and making it easier to reach for just feels like another opportunity for Array.prototype-like patching that we've been dealing with for years, especially if people start feeling like the helpers available aren't comprehensive enough.

The patching of Array which we occasionally run into is almost entirely pre-ES6 libraries. People are not at all doing that these days, from what I can tell. So I don't really share this concern. Evangelism about not doing that worked, eventually, especially once we started actually adding useful stuff ever.

[18:23:35.0006] <Kris Kowal>
SES meeting on deep equality, where we differentiate structural deep equality and deep equality protocols https://youtu.be/z_gXDSYKlWI

[18:24:43.0638] <Kris Kowal>
Equality, hash, and compare protocols are in http://www.collectionsjs.com/

[18:25:35.0258] <Kris Kowal>
(CollectionsJS isn’t a viable project in its current form because I mispredicted some Array shims. Ooops.)

[18:26:37.0919] <rbuckton>
`@esfx/equatable` has definitions for equality, comparability, structural equality, and structural comparability.

[18:27:22.0987] <rbuckton>
Though my most recent npm publish (today) has a few issues I'm trying to fix. I just switched the hashCode generation to use native code on Node when possible and that's had some hiccups.

[18:27:55.0960] <rbuckton>
 * Though my most recent npm publish (today) has a few issues I'm trying to fix. I just switched the hashCode generation to use native code on Node when possible and that's had some hiccups.

[18:28:00.0470] <Kris Kowal>
Adding protocols to the standard library probably means different Map and Set implementations or a very clever system for overloading their behavior.

[18:29:30.0168] <snek>
i really wish we had a `System.hash(v)` api

[18:29:32.0363] <Kris Kowal>
Collections went the cheap route of random numbers and a weak map. It predates intrinsic Map and Set, so there it does some odd stuff. But, not surfacing information divined from pointers is important.

[18:29:36.0391] <snek>
so we could write our own collections

[18:30:16.0110] <rbuckton>
Agreed. `@esfx/equatable` exposes a `rawHash(v)` API which is essentially the same.

[18:30:34.0325] <snek>
does that hash structurally or based on js identity 

[18:30:42.0224] <rbuckton>
I don't use pointers, I use the same hash identity that V8 uses for objects as keys in a map.

[18:30:49.0614] <rbuckton>
JS identity.

[18:30:54.0665] <snek>
oh its a native fn?

[18:31:02.0983] <Kris Kowal>
Yeah, I suspect that’s still a side channel.

[18:31:40.0973] <snek>
feel free to `delete System.hash` :P

[18:31:46.0954] <rbuckton>
> <@devsnek:matrix.org> oh its a native fn?

When I can get away with it, yeah. Otherwise its a WeakMap and a random number as a fallback.

[18:31:55.0386] <snek>
oh nice

[18:31:59.0567] <snek>
that's basically how v8 works anyway

[18:32:05.0430] <snek>
well not a weakmap but random numbers yes

[18:32:15.0268] <rbuckton>
At least, as soon as I finish wrangling breaking changes in my monorepo

[18:35:53.0499] <snek>
> <@kriskowal:matrix.org> Yeah, I suspect that’s still a side channel.

thinking about this more i don't think hash is a side channel 

[18:36:28.0684] <snek>
you can't communicate with it

[18:37:11.0461] <bakkot>
as long as it's mixed with an actually random number

[18:37:33.0454] <snek>
i think every js engine that cares about this sort of thing does that anyway

[18:37:36.0878] <snek>
due to hash collision attacks

[18:37:51.0016] <snek>
 * i think every js engine that cares about this sort of thing does that anyway

[18:38:26.0122] <bakkot>
yeah and because getting the address of an object in memory is one gadget which is used as a step in a lot of exploits

[18:38:37.0323] <snek>
oh right yeah do not use the address lmao

[18:39:03.0157] <bakkot>
I suspect none of the major engines would do it but if were were adding something like this we'd need to have a big loud note about including a good random value as a component

[18:39:27.0054] <snek>
i hear 4 is a great random number

[18:39:27.0258] <bakkot>
and it would be another source of nondeterminism, which... we should figure out a better story about adding those in general

[18:41:27.0745] <snek>
hmmmmmmMMMMMM

[18:41:36.0801] <snek>
actually no i'm dumb

[18:41:58.0533] <snek>
i was gonna say "does the hash actually have to be a transparent value" and then i realized how useless it would be if it was opaque lul

[18:42:25.0347] <snek>
 * i was gonna say "does the hash actually have to be a transparent value" and then i realized how useless it would be if it was opaque lul

[18:47:54.0717] <rbuckton>
It needs to be a number value (preferably uint32) to bucketize things efficiently.

[19:15:06.0739] <snek>
for the constraints of js i think it *must* be in u32 range otherwise you can't modulo it 

[19:15:26.0966] <snek>
or bitwise it

[19:19:51.0324] <rbuckton>
and u64 is outside the range of allowable array indices

[19:32:13.0927] <rbuckton>
ok, I *think* I fixed my breaking changes. `@esfx/equatable` defines the following:
- `Equatable` - A "protocol" involving two symbol-named methods (`[Equatable.equals](other)` and `[Equatable.hash]()`) indicating an object defines its own equality mechanism.
- `Comparable` - A "protocol" involving one symbol-named method (`[Comparable.compareTo](other)`) indicating an object defines its own comparability mechanism.
- `StructuralEquatable` - A "protocol" for `[StructuralEquatable.structuralEquals](other, equaler)` and `[StructuralEquatable.structuralHash](equaler)`
- `StructuralComparable` - A "protocol" for `[StructuralComparable.structuralCompareTo(other, comparer)`.
- `Equaler` - An "interface" describing an object with `{ equals(a, b), hash(x) }` methods, as well as a namespace object with default implementations (`defaultEqualer`, `structuralEqualer`, `tupleEqualer` (actually compares arrays), `tupleStructuralEqualer`), a `create` helper method to create an `Equaler` from callbacks, and a `combineHashes` function to help with complex hashCode construction (via bit shifting and XOR).
- `Comparer` - An "interface" describing an object with `{ compare(a, b) }` methods, as well as a namespace object with default implementations (`defaultComparer`, `structuralComparer`, `tupleComparer`, and `tupleStructuralComparer`).

There's also a `@esfx/equatable-shim` package that shims the `Equatable` and `Comparable` interfaces onto built-ins (and all of those methods are symbol-named, so no issues like with `.flatten`, etc.)

[19:33:54.0166] <Kris Kowal>
The CollectionsJS deep equality protocol carried an ibid map to break cycles and allowed an override for the contentEquals of the children.

[19:33:55.0287] <rbuckton>
I use the equality and comparison interfaces pretty heavily in the `@esfx/collections-*` packages as well as the `@esfx/iter-*` and `@esfx/async-iter-*` packages.

[19:34:43.0658] <rbuckton>
Mine doesn't do ad-hoc structural equality, but rather expects something that would be structurally equal to something else to explicitly implement that structural equality.

[19:35:35.0920] <rbuckton>
I haven't had much cause to use that part though, about 99% of my use cases have been shallow equality via custom `Equaler` and `Comparer` objects.

[19:38:31.0409] <rbuckton>
If I were to propose to TC39, I'd primarily focus on Equaler (`{ equals(a, b), hash(x) }`) and Comparer (`{ compare(a, b) }`) support in collection classes, default implementations of each that would align with existing behavior in Map and Set for keys, and a `hash` function reachable from somewhere (even if it's just `Equaler.defaultEqualer.hash`).

[19:40:29.0285] <rbuckton>
After that, maybe `Symbol.equals`, `Symbol.hash`, and `Symbol.compareTo` to hook equality and comparability on an instance. But at no point would any of that affect relational operators like `==`, `>`, etc. (overloading would be far out of scope).

[20:44:30.0935] <ljharb>
Doesn’t it return an iterator instance that has the slots of a generator?

[20:58:47.0361] <bakkot>
not exactly? it returns an iterator instance that has the slots of an _iterator helper_

[20:58:52.0425] <bakkot>
which is not the same thing as a generator

[21:00:04.0918] <bakkot>
like you can't `(function*(){})().next.call(that helper thing)`; that will not work

[21:00:28.0431] <bakkot>
 * like you can't `(function*(){})().next.call(that helper thing)`; that will not work

[21:01:44.0007] <bakkot>
I guess to be precise, the way it's written down it does have the same slots as a generator, but that's not actually observable by anything, just an editorial convenience

[21:05:42.0315] <bakkot>
anyway it is probably easier to talk about this in terms of observable behavior. there is very little observable difference between `Iterator.from(x)` and `Iterator.from(x).map(a => a)`. if there is a specific difference in observable behavior between the two you are worried about, post a code snippet and I can tell you what it does?


2022-09-08
[20:25:53.0587] <bakkot>
ljharb: re https://github.com/tc39/ecma262/issues/404, I just read the original issue description again and saw you were asking about being able to write specifically `a < b`, which ecmarkup doesn't support even with https://github.com/tc39/ecmarkup/pull/481 - `&lt;` and `&amp;` are specifically excluded so that HTML parsers still work. Would you consider https://github.com/tc39/ecma262/pull/2901 to close [#404](https://github.com/tc39/ecma262/issues/404) or should I leave it open?

[20:38:03.0484] <ljharb>
i think it’s fine to go with best effort here

[20:43:38.0190] <jschoi>
I forgot: Before Stage 3, are champions supposed to reach out to multiple editors to get a sign-off for Stage 3? 

proposal-array-from-async has two reviewers, and one of them is an editor, but I don’t remember how to fulfill the criterion that “all ECMAScript editors have signed off on the current spec text”.

[20:44:09.0088] <bakkot>
as a rule, yes, if you want editors to review you should ping us

[20:45:32.0389] <jschoi>
Dang, that was my bad, then. So it’s probably too late to request Stage 3 for next week, and I probably should delay to November…

[20:48:12.0691] <bakkot>
eh, we do pretty often advance things to "stage 3 pending editor review" or something like that

[20:48:21.0387] <bakkot>
fromAsync is simple enough that it's probably fine

[21:38:52.0446] <jschoi>
* Dang, that was my bad, then. So it’s probably too late to request Stage 3 for next week, and I probably should delay to November?

[21:38:58.0049] <jschoi>
Alright, sounds good, thanks.

[03:16:11.0226] <ryzokuken>
process proposal: let's switch to hedgedoc/hackmd for notes instead of gdocs so we could just write markdown and publish on github without having to convert formats

[03:16:16.0654] <ryzokuken>
 * process proposal: let's switch to hedgedoc/hackmd for notes instead of gdocs so we could just write markdown and publish on github without having to convert formats

[10:51:39.0763] <shu>
for the folks who attended the incubator call today, the transcription is up

[10:51:42.0782] <shu>
it's not too bad!

[10:51:53.0178] <shu>
still needs a human touch obviously but slightly better than i thought

[11:00:01.0124] <ptomato>
how is it better than the plenary autotranscription if they both use google technology?

[11:24:43.0582] <bakkot>
if nothing else it's able to do attribution

[11:26:28.0482] <bakkot>
but I think the main thing was just that everyone had an accent the bot could handle; the biggest struggle for the bot is non-native accents

[11:27:11.0103] <ptomato>
oh yeah, I was literally just wondering that, most of the attendees had North American accents

[11:31:44.0116] <shu>
it's probably also slightly delayed?

[11:31:49.0940] <shu>
it wasn't live, i just got a doc at the end

[11:40:03.0586] <bakkot>
that is also part of it yeah

[11:41:04.0633] <bakkot>
the API actually gives me both "in progress" and "finalized" events, but the finalized events are often ~20-30 seconds delayed from the start of the vocalization they're transcribing, which I found is too long to try to edit in real time

[11:41:16.0754] <bakkot>
so I am using the less-good "in progress" events

[11:41:41.0725] <bakkot>
 * the API actually gives me both "in progress" and "finalized" events, but the finalized events are often ~20-30 seconds delayed from the start of the vocalization they're transcribing, which I found is too long to try to edit in real time

[11:42:04.0459] <bakkot>
(they're not that different, though. a word or two here and there.)

[13:21:19.0309] <rbuckton>
> <@jschoi:matrix.org> Dang, that was my bad, then. So it’s probably too late to request Stage 3 for next week, and I probably should delay to November?

I was also hoping to get to Stage 3 for resource management, but I haven't heard back from my reviewers.

[13:25:48.0978] <rbuckton>
Is there an easy way to @-mention the editors in a tc39 repo? I see groups for chairs, and ecma402-editors, but not for ecma262 editors.

[13:38:17.0847] <ljharb>
there’s an editors group but I’m not sure if it’s referencable by others, I’ll look into it

[13:38:38.0683] <shu>
rbuckton: there was a lot of material given right at the deadline, it's not procedurally an issue of course but i'm personally not likely to have the time to give it a full review. still trying for a best effort

[13:38:47.0685] <shu>
 * rbuckton: there was a lot of material given right at the deadline, it's not procedurally an issue of course but i'm personally not likely to have the time to give it a full review. still trying for a best effort

[13:49:33.0410] <rbuckton>
> <@shuyuguo:matrix.org> rbuckton: there was a lot of material given right at the deadline, it's not procedurally an issue of course but i'm personally not likely to have the time to give it a full review. still trying for a best effort

I appreciate what time you can take, thanks.

[16:15:21.0456] <jschoi>
bakkot: When looking at your Set methods presentation for next week (https://docs.google.com/presentation/d/1HCqPMsWiTtsn92gA3b1luVpnVHWVVR0iKaAE0marxkA/edit#slide=id.g13a69787e9f\_0\_0), I’m starting to wonder is why we excluded Set.union, Set.intersection, etc. as static methods rather than instance methods. Why were static methods excluded, again?

[16:15:36.0716] <jschoi>
 * bakkot: When looking at your Set methods presentation for next week (https://docs.google.com/presentation/d/1HCqPMsWiTtsn92gA3b1luVpnVHWVVR0iKaAE0marxkA/edit#slide=id.g13a69787e9f\_0\_0), I’m starting to wonder is why we excluded Set.union, Set.intersection, etc. as static methods. Why were these excluded, again?

[16:15:41.0878] <jschoi>
I don’t see mentions of this option in the previous Set methods presentations. Static methods might be able to sidestep the issues with the “`this` Set uses internal slots and argument Sets use a symbol-based public API” approach.

The only discussion I can find about the static-methods option is in https://github.com/tc39/proposal-set-methods/issues/1, and I don’t really see any compelling reasoning against static methods given in there.

[16:15:45.0471] <jschoi>
 * I don’t see much about this option in the previous Set methods presentations. It may be able to sidestep a lot of the issues with the “`this` Set uses internal slots and argument Sets use symbol-based public API”. The only discussion I can find about this is in https://github.com/tc39/proposal-set-methods/issues/1, and I don’t really see any compelling reasoning given in there.

[16:16:05.0329] <jschoi>
 * bakkot: When looking at your Set methods presentation for next week (https://docs.google.com/presentation/d/1HCqPMsWiTtsn92gA3b1luVpnVHWVVR0iKaAE0marxkA/edit#slide=id.g13a69787e9f\_0\_0), I’m starting to wonder is why we excluded Set.union, Set.intersection, etc. as static methods rather than instance methods. Why were static methods excluded, again?

[16:16:39.0006] <jschoi>
 * I don’t see much about this option in the previous Set methods presentations. It might be able to sidestep the issues with the “`this` Set uses internal slots and argument Sets use symbol-based public API” approach. 

The only discussion I can find about this is in https://github.com/tc39/proposal-set-methods/issues/1, and I don’t really see any compelling reasoning given in there.

[16:16:55.0229] <jschoi>
 * I don’t see much about this option in the previous Set methods presentations. It might be able to sidestep the issues with the “`this` Set uses internal slots and argument Sets use symbol-based public API” approach.

The only discussion I can find about the static-methods option is in https://github.com/tc39/proposal-set-methods/issues/1, and I don’t really see any compelling reasoning against static methods given in there.

[16:17:43.0906] <jschoi>
 * I don’t see mentions of this option in the previous Set methods presentations. Static methods might be able to sidestep the issues with the “`this` Set uses internal slots and argument Sets use a symbol-based public API” approach.

The only discussion I can find about the static-methods option is in https://github.com/tc39/proposal-set-methods/issues/1, and I don’t really see any compelling reasoning against static methods given in there.


2022-09-09
[06:01:01.0477] <dminor>
ryzokuken: I'm seeing a "you need permission" page when I try to fill out the in-person attendance form for the A Coruña meeting

[06:01:17.0606] <ryzokuken>
ah, shucks. Let me fix that.

[06:57:37.0356] <ryzokuken>
btw, thanks for the reminder dminor 

[06:57:58.0897] <ryzokuken>
ICYMI: Next meeting info just dropped: https://github.com/tc39/Reflector/issues/446

[06:58:17.0021] <ryzokuken>
please check it out and fill the signup form if you plan to attend at your earliest convenience, thanks!

[10:57:49.0363] <sffc>
The doodle link on the 93rd Meeting reflector thread doesn't work

[11:07:48.0710] <Kris Kowal>
A Coruña is lovely. My brother-in-law married a Galecian and their wedding was there. Be sure to take the time for a long walk around the shoreline if you’re visiting!


2022-09-10
[00:04:43.0838] <snek>
could someone fill out the missing date/time info on the reflector post 

[00:04:45.0057] <snek>
https://gc.gy/130498461.png

[00:05:19.0822] <snek>
well i guess the only thing really missing is the timezone, everything else can be inferred

[01:31:57.0158] <Rob Palmer>
Thanks Gus - all fixed now.

[01:44:47.0389] <Rob Palmer>
Next week's plenary is on the Tokyo JST timezone.  That means the start time of 10am on Tuesday in Tokyo corresponds to:

- Monday 6pm in Seattle (PT)
- Monday 9pm in New York (ET)
- Tuesday 2am in London (BST)
- Tuesday 3am in Berlin (CET)
- Tuesday 6:30am in Bengalaru (IST)
- Tuesday 9am in Shanghai (CST)

[01:46:09.0220] <nicolo-ribaudo>
JST stands for "JavaScript Time"

[01:49:16.0748] <Rob Palmer>
It's always JavaScript time ;-)

[10:27:56.0374] <snek>
javascript space telescope 


2022-09-12
[00:48:39.0487] <bakkot>
> <@jschoi:matrix.org> I don’t see mentions of this option in the previous Set methods presentations. Static methods might be able to sidestep the issues with the “`this` Set uses internal slots and argument Sets use a symbol-based public API” approach.
> 
> The only discussion I can find about the static-methods option is in https://github.com/tc39/proposal-set-methods/issues/1, and I don’t really see any compelling reasoning against static methods given in there.


it does not sidestep the issue - the fundamental problem is "how do you get the data from a Set which you take as an argument", and taking two Sets as arguments instead of one doesn't help 

[00:51:44.0459] <bakkot>
ignoring that and considering only questions of design, instance methods seem much more natural to me? that's how it works in Java/rust/etc also

[00:51:48.0360] <bakkot>
 * ignoring that and considering only questions of design, instance methods seem much more natural to me? that's how it works in Java/rust/etc also

[07:57:11.0128] <ryzokuken>
hi delegates! the draft schedule has been linked from the reflector.

[10:08:17.0252] <TabAtkins>
rbuckton: Yo, in your Resource Management slides, it appears that slide 2 has several smaller slides embedded into it? These are *unreadably* small, fyi. It looks like they're actually meaningful to explaining the proposal motivations, tho, so you might want to format this differently.

[10:12:56.0144] <rbuckton>
You can click into them for the full slide (in PowerPoint, at least) 

[10:18:21.0557] <TabAtkins>
Can't do that on the web, and not willing to install a new office suite just to read slides. 

[10:20:36.0474] <TabAtkins>
(And I'd hazard that a pretty small fraction of delegates are going to do so either, even if they *have* Powerpoint, since it involves downloading the file and loading them up in a new program.) So optimizing for web display seems prudent, imo.

[10:32:00.0568] <rbuckton>
The slides are also present at the end of the deck as "Backup Slides", which seem to be visible in the web viewer. 

[10:32:28.0066] <TabAtkins>
Ah, I suspected that might be the case, since the web viewer stops 6 slides from the end and won't show me those final ones. ^_^

[10:34:30.0999] <TabAtkins>
(iow, I can get to slide 32 of 38 in the web viewer, but the Next button doesn't take me past that point)

[10:35:03.0896] <rbuckton>
I'm not in a position to make any changes to the deck at the moment, so hopefully that workaround suffices. 

[10:36:01.0181] <TabAtkins>
It doesn't, as I said. But you have a few days before the presentation anyway, so I hope it'll be fixed by then. (Hopefully by inlining the slides where they are meant to be displayed, as I assume you'll be showing those slides at that point in the presentation anyway.)


2022-09-13
[18:04:18.0540] <ljharb>
i'm confused, i don't hear any audio coming out of jitsi (but i do hear jitsi sound effects) but i see the notes transcribing things

[18:04:27.0323] <ljharb>
 * i'm confused, i don't hear any audio coming out of jitsi (but i do hear jitsi sound effects( but i see the notes transcribing things

[18:04:30.0014] <ljharb>
 * i'm confused, i don't hear any audio coming out of jitsi (but i do hear jitsi sound effects) but i see the notes transcribing things

[18:04:45.0769] <littledan>
maybe try refreshing? I hear audio

[18:04:53.0557] <ljharb>
rejoining didn't seem to help, i'll try force quitting the app and reopening it

[18:05:13.0532] <ljharb>
still nothing

[18:05:26.0926] <bakkot>
did you mute the tab?

[18:05:42.0668] <ljharb>
it's not a tab, it's the native iPad app i've used every other time

[18:05:47.0148] <bakkot>
ah, hm

[18:05:59.0095] <littledan>
note that this isn't 8x8, it's Igalia's server

[18:06:31.0751] <ljharb>
ah, i thought igalia's server didn't work for us multiple times. either way i'm connected to it and it's not sending me audio :-(

[18:06:58.0685] <Michael Ficarra>
ljharb: I've had that issue and reconnecting to the meeting fixed it

[18:07:03.0566] <littledan>
Igalia updated its Jitsi instance; I think it worked well after that (just not from Google's room). Maybe try joining via the browser if your app doesn't work?

[18:07:09.0421] <ljharb>
i've already tried that twice; i'll try one more time

[18:08:08.0782] <ljharb>
i do hear it through the web (a third try on the app didn't work)

[18:08:22.0864] <ljharb>
 * i do hear it through the web (a third try on the app didn't work)

[18:08:37.0191] <ljharb>
why aren't we using 8x8?

[18:09:05.0055] <Michael Ficarra>
what's the difference between them? jitsi version?

[18:09:11.0121] <ryzokuken>
> <@littledan:matrix.org> Igalia updated its Jitsi instance; I think it worked well after that (just not from Google's room). Maybe try joining via the browser if your app doesn't work?

yeah, the reason we switched to meet in the last meeting was because the room was set up to work with meet

[18:09:42.0538] <ljharb>
right, but we used the 8x8 for jitsi the last year or two, no?

[18:10:11.0017] <ryzokuken>
we had issues with it a few meetings ago

[18:11:38.0752] <littledan>
there's a general jtsii app, it's just a different app from the 8x8 app

[18:14:16.0081] <ljharb>
the one i use is called "Jitsi Meet", which is from 8x8 - i'm not aware of another ipad-compatible jitsi app (altho maybe the search results are drowned out by keyword spam)

[18:14:35.0384] <ljharb>
it's worked fine since we started using jitsi, until now :-/

[18:14:38.0027] <littledan>
OK, yes, Jitsi Meet worked for me in the past with Igalia's servers

[18:14:38.0079] <ljharb>
 * it's worked fine since we started using jitsi, until now :-/

[18:14:47.0672] <ljharb>
yeah same, so i'm confused why it wouldn't be working now

[18:15:16.0767] <ryzokuken>
Jitsi Meet _should_ ideally work with our servers, but I have to admit that I just use the browser, even when connecting on my phone

[18:16:03.0214] <littledan>
> <@michaelficarra:matrix.org> what's the difference between them? jitsi version?

yeah I think the 8x8 servers were configured in too underpowered of a way

[18:16:54.0956] <Bradford Smith>
Did I miss an announcement explaining why we don´t have a professional stenographer this time? I thought that was the plan.

[18:17:14.0876] <littledan>
Bradford Smith: I've submitted a request, and will be raising it at the ExeCom meeting in three weeks

[18:17:21.0893] <Bradford Smith>
ah, thx

[18:34:18.0022] <littledan>
Huh? What is this hardcoded logic, and why can't those people sign the form?

[18:36:11.0005] <bakkot>
littledan: ask ljharb for details

[18:36:17.0732] <bakkot>
it's for existing commits in the repo, though

[18:36:19.0534] <bakkot>
not for new PRs

[18:36:51.0751] <msaboff>
Please add your name, abbreviation and organization to the top of today's notes.

[18:37:04.0543] <littledan>
yeah, when I started the IPR form I went back and solicited signatures for past contributors who I couldn't find IPR documentation of; sounds like it's time to do that exercise again

[18:37:09.0196] <bakkot>
I believe it's people who contributed long ago and aren't visibly marked as delegates on Github? something like that

[18:37:33.0558] <littledan>
(everyone agreed to sign this form except Domenic; we still lack a paper trail for the Promise spec IPR)

[18:39:28.0166] <ljharb>
littledan: yes, i've started to do that, but they're hard to track down

[18:39:38.0980] <littledan>
ah great, I appreciate that!

[18:39:59.0407] <ljharb>
feel free to reach out as well; it's an array or Set or something called "exceptions" in the script

[18:40:23.0657] <littledan>
yeah could you link to that in the source, so I could help?

[18:41:48.0469] <ljharb>
https://github.com/tc39/ecma262/blob/main/scripts/check-form.js#L162-L202

[18:42:59.0797] <Michael Ficarra>
this is so much better!

[18:43:28.0393] <Michael Ficarra>
dodged a bullet accepting "all truthy strings"

[18:48:35.0346] <bakkot>
^ this is the sort of thing TG1 can help with I think

[18:50:23.0921] <shu>
yes, 100%

[18:50:47.0728] <shu>
i think chip's and my comments are directed at the actual domain-specific i18n stuff

[18:50:51.0225] <littledan>
TG1?

[18:50:58.0767] <shu>
plenary

[18:56:47.0955] <bakkot>
could one of the DurationFormat people update the conclusion with a precise list of the things we just gave consensus for?

[18:56:56.0992] <ryzokuken>
will do

[18:56:58.0258] <bakkot>
I don't like having just "consensus for presented changes" but don't have time to fix it up

[18:57:00.0136] <bakkot>
thanks!

[18:57:32.0682] <littledan>
I'm wondering, is DurationFormat "shippable"? Do we anticipate further changes?

[18:58:16.0146] <ryzokuken>
littledan: I believe so, but I can do a quick triage and let you know precisely.

[18:59:14.0682] <littledan>
Great news! If so, maybe announce this specifically to the committee in a follow-on topic if there's time, since that wasn't quite clear so far? This is a nice conclusion to a string of fix-up presentations.

[19:01:53.0375] <littledan>
Great news on the RFC side for Temporal. If we have consensus among the relevant parties for moving forward on this, I'm not sure we need to wait for formal publication before shipping this in browsers. (Isn't the IETF all about running code?)

[19:06:43.0118] <bakkot>
oh no, why is a string of eight digits a valid calendar name

[19:07:51.0539] <shu>
have you read the temporal 8601 grammar

[19:08:12.0816] <bakkot>
if I have I presumably wiped that from my memory after reading

[19:08:20.0608] <shu>
it makes me throw up a little in my mouth every time

[19:08:28.0603] <shu>
we did not invent formal grammar for this

[19:08:40.0030] <shu>
 * we did not invent formal grammar for this

[19:10:40.0985] <snek>
hello everyone

[19:16:24.0496] <littledan>
Is there an issue for this frozen calendar topic?

[19:16:34.0602] <Michael Ficarra>
I just noticed we adopted the agenda with this PR open: https://github.com/tc39/agendas/pull/1252

[19:17:03.0399] <Michael Ficarra>
is that presenter in here? should we amend the agenda?

[19:17:13.0148] <littledan>
(FWIW I'm skeptical of using frozen intrinsic objects here; I was pushing against custom calendars exactly because this sort of thing is likely infeasible)

[19:18:13.0013] <littledan>
I don't understand the motivation for what Jordan is talking about; maybe this could be filed as an issue?

[19:19:22.0239] <littledan>
+1 to Philip's point about the critical flag

[19:20:00.0305] <ryzokuken>
fwiw, this interpretation of the flag is also shared by the folks at IETF

[19:21:54.0196] <littledan>
also note that there are other sorts of normalization around the spec, e.g., in Intl locales

[19:22:05.0809] <littledan>
this seems analogous

[19:23:22.0478] <littledan>
Yay Justin's back!!!

[19:23:31.0238] <shu>
ljharb: AFAIU the crux of the argument is that Temporal objects are not meant for interchange, and that they are already lossy wrt some input

[19:23:46.0890] <bakkot>
can presenter or someone capture what we did and did not get consensus for on the notes?

[19:23:49.0565] <bakkot>
 * can presenter or someone capture what we did and did not get consensus for on the notes?

[19:24:11.0552] <ptomato>
I can

[19:24:12.0974] <ljharb>
https://github.com/tc39/proposal-temporal/issues/2403 is the issue

[19:24:23.0381] <shu>
i also understand there to be that there's no implication of the form "critical annotation implies serialized for further interchange"

[19:24:29.0212] <ljharb>
that doesn't sound like a compelling argument to add more lossiness

[19:24:43.0811] <shu>
but this isn't more lossiness

[19:24:56.0340] <shu>
this is just existing lossiness (lossiness via toString)

[19:25:35.0084] <ljharb>
the toString part is i think a separate item; i'm saying that i would expect/hope that Temporal could parse a string and give me sufficient info about what was in that string

[19:25:51.0077] <shu>
and my understanding is that that was never the case and won't be the case

[19:26:04.0118] <shu>
because of what frank was saying about "ignorable brackets"

[19:26:22.0722] <ljharb>
i understand the ignorable annotation stuff would be lost

[19:26:24.0313] <ryzokuken>
I think you might be misunderstanding the purpose of the critical flag here. It's just not relevant for Temporal

[19:26:36.0333] <shu>
yeah i'd like to understand your use case jordan

[19:26:52.0721] <ljharb>
i don't have a use case in mind - i just learned about this flag 20 minutes ago

[19:27:10.0502] <ljharb>
but it seems shortsighted to throw out data gathered during a difficult parse

[19:27:10.0553] <shu>
but you have a position -- that this be preserved for toString, what's the motivation for that position

[19:27:32.0759] <ljharb>
i only mildly care about preserving it in toString - i think it's important to have a way to get it from the object

[19:27:37.0205] <shu>
that doesn't follow for me, i don't see why that's shortsighted when other stuff is already thrown out?

[19:27:42.0153] <ljharb>
like `parsed.isCritical` or something

[19:28:06.0627] <shu>
yeah but _why_

[19:28:08.0479] <ljharb>
"some stuff is thrown out so it's fine to throw anything else out" is a slippery slope argument.

[19:28:28.0210] <ljharb>
because it was in the string, and per the slide, "some consumers may care about it"

[19:28:41.0913] <ljharb>
if somebody cares about it then it seems important to preserve. if nobody cares about it then why support it at all

[19:28:44.0795] <shu>
yes, but _not_ via an instantiated Temporal object!

[19:28:47.0111] <ljharb>
 * if somebody cares about it then it seems important to preserve. if nobody cares about it then why support it at all

[19:28:57.0223] <shu>
the consumer IS the temporal object, the code instantiating the temporal object

[19:29:04.0975] <ptomato>
I think the intention of the RFC _is_ that the flag is thrown out when parsed; it just says "do not ignore this annotation when you parse it"; and Temporal doesn't ignore it

[19:29:05.0198] <shu>
not the users of the instantiated object

[19:29:19.0861] <ryzokuken>
> <@pchimento:igalia.com> I think the intention of the RFC _is_ that the flag is thrown out when parsed; it just says "do not ignore this annotation when you parse it"; and Temporal doesn't ignore it

right, exactly

[19:29:39.0774] <shu>
like does this come down to how it's called "Critical"

[19:29:47.0806] <shu>
what if it wasn't that, and was "Temporal parser don't ignore"

[19:29:50.0028] <shu>
err

[19:29:57.0553] <shu>
 * what if it wasn't that, and was "Temporal parser don't ignore"

[19:30:11.0089] <ljharb>
lol but it's in an IETF standard.

[19:30:22.0657] <ptomato>
I would also be fine getting rid of the option to output it, for now 😄

[19:30:23.0772] <shu>
let me rephrase

[19:30:39.0385] <littledan>
> <@ljharb:matrix.org> lol but it's in an IETF standard.

lots of IETF standards have things that get normalized out and don't need to be part of the post-parse representation

[19:30:45.0018] <shu>
what if "critical" had a very particular meaning in the IETF standard, and that meaning was "Temporal parser don't ignore"

[19:30:46.0379] <littledan>
(e.g., locales, which we support)

[19:31:09.0057] <ryzokuken>
but temporal parser never ignores 

[19:31:12.0217] <ljharb>
i understand that temporal doesn't do anything different based on the presence of the flag. and if nobody ever ends up with a use case where they need to know if the ! was present, then obviously it'd be fine.

[19:31:20.0876] <ljharb>
but that's only 1 of the 4 possible outcomes

[19:31:26.0980] <shu>
what i'm sensing is mainly there's more read into the "criticality" than what is actually meant

[19:31:54.0184] <shu>
by both IETF and the temporal champions

[19:32:10.0382] <ljharb>
either we have it, and it's needed; we have it, it's not needed; we don't have it, it's not needed; or we don't have it and it's needed. in 2 of those, everything's fine, in 1 of those, we have an extra unneeded bit on temporal instances, and in 1, somebody's use case is impossible

[19:32:22.0009] <Michael Ficarra>
is there a temporal channel or something we could take this to? I'd rather discuss the current topic here

[19:32:22.0732] <shu>
sigh

[19:32:23.0803] <ljharb>
why wouldn't we want to avoid the "it's impossible" outcome?

[19:32:41.0775] <ljharb>
 * why wouldn't we want to avoid the "it's impossible" outcome?

[19:33:08.0584] <ljharb>
 * either we have it, and it's needed; we have it, it's not needed; we don't have it, it's not needed; or we don't have it and it's needed. in 2 of those, everything's fine, in 1 of those, we have an extra unneeded bit on temporal instances, and in 1, somebody's use case is impossible

[19:33:10.0928] <Michael Ficarra>
anyway, for something that's supposed to be a function of only how the source text is formatted, only looking at raw sounds like the right idea

[19:34:28.0145] <HE Shi-Jun>
what happened if called as function? 

[19:35:59.0479] <littledan>
IMO reusing ParseText seems better to avoid (unlikely) future mismatch

[19:36:45.0188] <littledan>
> <@haxjs:matrix.org> what happened if called as function?

Well, this is just a tagged string template; what's the question?

[19:36:52.0406] <HE Shi-Jun>
I assume it will try to read `raw` prop ? what will happen if no `raw` prop?

[19:36:56.0713] <bakkot>
it will throw

[19:37:03.0195] <snek>
big lunch

[19:37:26.0929] <Anthony Bullard>
Sorry, I missed the time to reconvene?

[19:37:36.0843] <snek>
one hour and 23 minutes from now

[19:37:44.0819] <HE Shi-Jun>
> <@bakkot:matrix.org> it will throw

A little bit weird but maybe acceptable... 

[19:37:58.0285] <ljharb>
don't all/most template tags behave like that?

[19:38:01.0492] <ljharb>
 * don't all/most template tags behave like that?

[19:38:07.0719] <bakkot>
a lot of template tags only care about the cooked code

[19:38:11.0035] <ljharb>
ah k

[19:38:12.0249] <bakkot>
so no, it's somewhat unusual

[19:38:13.0810] <bakkot>
but only somewhat

[19:38:24.0295] <bakkot>
mostly they're not built to be used as functions directly

[19:38:36.0742] <bakkot>
but I'm going to do that until we have a way to dedent a non-source-text string

[19:39:06.0723] <bakkot>
which will be slightly awkward now because I have to escape `\`s to prevent them getting cooked before passing them

[19:39:08.0035] <bakkot>
but whatever

[19:39:28.0057] <HE Shi-Jun>
I asked that because JSCIG discussed this proposal and someone asked that. Not sure everyone happy with throwing.

[19:39:38.0075] <bakkot>
see https://github.com/tc39/proposal-string-dedent/issues/45 for the "dedenting strings which are not source text" use case

[19:39:59.0299] <Anthony Bullard>
Justin Ridgewell: One thing I was going to ask if not for my terrible connection, is it seems odd that we respect the cooked value of some escaped characters(`\n`), but not others in this new proposal .  Am I misunderstanding?

[19:40:01.0248] <bakkot>
HE Shi-Jun: do you know why they aren't happy with it? or can you ask?

[19:40:37.0969] <Justin Ridgewell>
I think you're misunderstanding

[19:40:52.0238] <Justin Ridgewell>
All escape sequences will be cooked, they're just cooked _after_ dedenting

[19:41:24.0405] <Anthony Bullard>
But `\n` has the following characters treated as if it were a newline, no?

[19:41:33.0621] <Anthony Bullard>
Is that true in all cooked strings?

[19:42:09.0422] <Justin Ridgewell>
In the current implementation, it cooks first then dedents.

[19:42:29.0858] <HE Shi-Jun>
> <@bakkot:matrix.org> HE Shi-Jun: do you know why they aren't happy with it? or can you ask?

I will ask the question in the wechat group of JSCIG.

[19:42:39.0417] <Justin Ridgewell>
So the `\n` turns into a newline, then dedenting finds the content after that as part of the common indentation calculation.

[19:43:04.0523] <Justin Ridgewell>
In the PR, it calculates common indentation, dedents, then cooks the `\n`

[19:43:32.0911] <Justin Ridgewell>
A `\x20` sequence would behave the same.

[19:43:50.0553] <Justin Ridgewell>
Currently, cook first, then dedent (it only matters if it appears before any content chars)

[19:43:57.0272] <Anthony Bullard>
I looked at the slides again, and I see what I expect

[19:43:58.0438] <Justin Ridgewell>
Proposed, dedent first, then cook

[19:44:00.0146] <Anthony Bullard>
My apologies

[19:44:31.0189] <Anthony Bullard>
My only concern is that we aren't special casing newlines

[19:44:56.0203] <Anthony Bullard>
Thanks for following up Justin

[19:45:10.0293] <shu>
i zoned out for a bit, are we coming back at 2100 PT?

[19:45:30.0526] <Anthony Bullard>
shu:  yes

[19:45:35.0635] <shu>
thanks

[19:45:40.0492] <Anthony Bullard>
 * shu:  yes

[19:46:16.0857] <Anthony Bullard>
 * My only concern was that we were special casing newlines

[19:52:05.0831] <Anthony Bullard>
Since this is my first meeting, I wanted to understand the protocol.  The meetings can take _up to_ the four days, but only if the agenda takes us that long?

[19:52:24.0127] <shu>
the amount of stuff on the agenda waxes and wanes over the years

[19:52:34.0332] <shu>
the trend recently has been more undersubscription than oversubscription

[19:52:45.0060] <shu>
for most of TC39 i've attended in years past, we've often been quite stretched for time

[19:52:47.0832] <shu>
this agenda is especially short

[19:53:15.0059] <shu>
so yes, we have 4 days allotted, but may end early (i hope so!)

[19:53:31.0836] <Anthony Bullard>
Awesome, this is a tough schedule from CST

[19:53:38.0718] <ryzokuken>
it heavily depends on a lot of complicated factors... like timezones

[19:55:11.0828] <ryzokuken>
also some might've deferred their presentations in favor of giving it at the next meeting in person (and same with pulling forward for the last one).

[19:55:27.0504] <ryzokuken>
 * also some might've deferred their presentations in favor of giving it at the next meeting in person (and same with pulling forward for the last one).

[19:56:59.0034] <bakkot>
Justin Ridgewell: what happens if you do ``String.dedent`\invalid```?

[19:57:20.0414] <bakkot>
ugh, markup. String.dedent but you use an invalid escape in the template.

[19:58:00.0086] <Justin Ridgewell>
Currently, it would have `[undefined]` and `['\\invalid']`

[19:58:24.0075] <Justin Ridgewell>
It should be the same after the PR

[19:58:27.0675] <Justin Ridgewell>
(I hope)

[19:59:13.0570] <bakkot>
I mean when used as a tag directly, not when used as a wrapper for another tag

[19:59:42.0743] <bakkot>
that's reasonable behavior for passing to the wrapped tag, in the tag-wrapping case, but when used as a tag directly it gives you a string; what string does it give you?

[19:59:56.0301] <Justin Ridgewell>
It throws as part of the `String.cooked` implementation

[20:00:00.0426] <bakkot>
ah great

[20:00:14.0103] <bakkot>
I could not find that in the spec text

[20:00:14.0946] <Justin Ridgewell>
[`CookTemplateStringsArray`](https://tc39.es/proposal-string-dedent/#sec-cook-template-strings-array)

[20:00:27.0543] <bakkot>
oh, indeed, I see that

[20:00:28.0980] <Justin Ridgewell>
7.C

[20:00:35.0149] <bakkot>
seems like it should be a SyntaxError but otherwise yes good

[20:57:25.0989] <bakkot>
Justin Ridgewell: https://github.com/tc39/proposal-string-dedent/pull/67

[20:57:44.0510] <Rob Palmer>
We are resuming plenary in 2 mins!

[21:03:37.0595] <ryzokuken>
you can turn down the connection quality

[21:21:43.0429] <HE Shi-Jun>
so we only have message, no error name?

[21:22:05.0319] <caridy>
https://github.com/tc39/proposal-shadowrealm/pull/372/files#r966197227

[21:22:22.0656] <caridy>
that's the specific normative note that @littledan is referencing to.

[21:23:37.0502] <littledan>
note, this isn't just Mathieu and me, Caridy proposed something sort of in between (not as concrete as I'd do it but I don't want to be too picky)

[21:23:59.0959] <littledan>
IMO the `name` doesn't give you very much, but also it's not a big deal to make an observable Get

[21:25:13.0849] <littledan>
Note, whether there's an observable Get, and whether the contents of the message are totally implementation-defined, are two separate questions

[21:26:32.0445] <littledan>
My position is that it's simply overkill to avoid the Get; I think it'd be fine to use the approach Mathieu suggests, of first checking [[ErrorData]] and then doing GetOwnProperty and then using it only if it's a value

[21:29:24.0861] <Michael Ficarra>
> <@jridgewell:matrix.org> It throws as part of the `String.cooked` implementation

wait why would this throw? tagged templates are allowed to have invalid escapes

[21:30:15.0210] <bakkot>
it's only for non-tagged

[21:31:02.0696] <bakkot>
when you use String.dedent to wrap a tagged template it doesn't throw

[21:31:19.0821] <bakkot>
but if you use it directly as a tag it should throw, because the original code would have thrown without `String.dedent`

[21:34:51.0869] <Michael Ficarra>
> <@bakkot:matrix.org> but if you use it directly as a tag it should throw, because the original code would have thrown without `String.dedent`

I don't agree with this. Is there an issue I can comment on?

[21:34:52.0225] <Justin Ridgewell>
``` String.cooked`\invalid` ``` throws

[21:35:25.0344] <Justin Ridgewell>
When you're concatting the values, it sees an `undefined`, and throws

[21:35:26.0200] <bakkot>
Michael Ficarra: what... would you want it to do

[21:35:36.0149] <bakkot>
would you want it to interpolate the string "undefined"?

[21:35:41.0370] <bakkot>
 * Michael Ficarra: what... would you want it to do

[21:35:56.0374] <bakkot>
there is no issue for this because there is no other imaginable semantics, but you can make one to propose some other unimaginable semantics if you want

[21:35:59.0436] <Michael Ficarra>
cooked should still be undefined but raw should be dedented

[21:36:04.0780] <bakkot>
that's what it is

[21:36:20.0736] <bakkot>
but again, if you use it as a tag _directly_, there is no "cooked" vs "raw" distinction

[21:36:24.0258] <bakkot>
you get a string out, not an array

[21:36:32.0972] <bakkot>
and the string has to be a string

[21:36:36.0871] <Justin Ridgewell>
So, ``` String.dedent`foo` ``` performs `String.cooked` internally, because it's the default tag implementation.

[21:36:45.0419] <Anthony Bullard>
Etherpad link?

[21:37:00.0859] <Justin Ridgewell>
``` String.dedent(String.raw)`\invalid` ``` wouldn't throw an error

[21:37:03.0696] <littledan>
The notes link is in the Reflector

[21:37:19.0079] <Michael Ficarra>
the reflector link is in the channel topic

[21:37:42.0607] <Rob Palmer>
* please don't post direct URLs in this logged public channel! * (reflector links are ok)

[21:40:23.0020] <Justin Ridgewell>
 * ``String.dedent(String.raw)`\invalid``` wouldn't throw an error, ``String.dedent(String.cooked)`\invalid``` would

[21:40:32.0730] <snek>
we should put that in the MOTD

[21:40:40.0188] <Justin Ridgewell>
 * ````String.dedent(String.raw)`\invalid``` wouldn't throw an error, ``` String.dedent(String.cooked)`\invalid` ``` would

[21:41:04.0634] <Michael Ficarra>
we should put it at the top of the reflector post in big red letters

[21:41:19.0418] <Justin Ridgewell>
 * ``` String.dedent(String.raw)`\invalid` ``` wouldn't throw an error, ``` String.dedent(String.cooked)`\invalid` ``` would

[21:41:30.0333] <snek>
we should do the twitch chat thing, every 60 seconds or so a bot posts a reminder here

[21:42:09.0291] <Michael Ficarra>
Twitch chat would just automod the link away before it propagates

[21:43:25.0088] <HE Shi-Jun>
One thing I want to confirm, does `Reflect.get(#{x:1}, "x"` work or throw? I suppose it should throw?

[21:43:37.0973] <bakkot>
it works; why would it throw?

[21:43:56.0829] <bakkot>
(I assume anyway)

[21:43:57.0860] <ljharb>
if `#{x:1}.x` works then that should certainly work

[21:44:02.0609] <ljharb>
since they're the same operation

[21:44:23.0833] <HE Shi-Jun>
If Reflect works, so new Proxy(#{x: 1}, {}) also works??

[21:45:12.0246] <Michael Ficarra>
`{ __proto__: #{} }` doesn't work though

[21:45:52.0809] <ljharb>
hm, hax makes a good point

[21:45:54.0648] <bakkot>
ljharb: eh, "str"[0] works

[21:46:09.0262] <bakkot>
but `Reflect.get("str", 0)` does not

[21:46:10.0756] <ljharb>
yeah true

[21:46:31.0658] <littledan>
> <@haxjs:matrix.org> If Reflect works, so new Proxy(#{x: 1}, {}) also works??

No, this would throw; Proxy targets need to be objects, not primitives

[21:46:34.0012] <HE Shi-Jun>
Currently Reflect API throws for all primitives.

[21:47:20.0373] <ljharb>
it makes sense that Reflect shouldn't work for anything that can't be a Proxy target, since reflect's only supposed to be for proxy traps

[21:47:21.0093] <littledan>
there was a somewhat detailed look into whether R&T could be Proxy targets, and Caridy noted that, given the Proxy invariants, this would not be remotely useful

[21:47:40.0933] <bakkot>
I think there is an open issue about which existing APIs should work  

[21:47:44.0333] <ljharb>
it would be useful for observation, just not really changing the results

[21:47:46.0345] <bakkot>
which might have discussion of Reflect

[21:48:12.0300] <bakkot>
ljharb: IIRC the currently discussed issue was raised by you?

[21:48:15.0067] <bakkot>
the brand checking thing

[21:48:19.0151] <ljharb>
yes

[21:48:21.0106] <bakkot>
did you ever come up with a concrete use case?

[21:48:35.0010] <ljharb>
i haven't written anything up, no.

[21:48:51.0076] <ljharb>
one of them tho is for debugging, to be able to tell users what kind of value it is

[21:49:21.0744] <ljharb>
test frameworks, node, https://npmjs.com/object-inspect, etc all do similar things with existing boxed primitives

[21:50:44.0917] <HE Shi-Jun>
I think there is a conflict, on one side, we might want record/tuple could be used as replace of object/array in most cases, on the other side, we need to keep consistency with current API design, and many APIs treat primitives/objects very different.

[21:51:16.0770] <ljharb>
i agree. R&T occupy a very weird space where they're conceptually both objects and primitives, so it's hard to know what the best tradeoffs are between DX and consistency and existing axioms

[21:51:22.0232] <ljharb>
 * i agree. R&T occupy a very weird space where they're conceptually both objects and primitives

[21:52:00.0962] <snek>
i don't like this idea but i'm not entirely sure why

[21:52:04.0125] <ljharb>
 * i agree. R&T occupy a very weird space where they're conceptually both objects and primitives, so it's hard to know what the best tradeoffs are between DX and consistency and existing axioms

[21:52:58.0463] <HE Shi-Jun>
Another interesting case was raised in our JSCIG meeting, someone ask whether class { constructor() { return #{} } } works...

[21:53:13.0487] <msaboff>
shu: What Web API's for ShadowRealms do you have questions about Safari 16 supporting?

[21:53:55.0227] <Robin Ricard>
HE Shi-Jun: might be worth raising on the queue

[21:54:03.0337] <shu>
msaboff: my question is 1) what part of ShadowRealms did Safari 16 ship, since web API integration isn't yet finished, 2) was it a mistake, as saam suggested on twitter

[21:54:19.0226] <littledan>
ljharb: Did you end up developing a use case for the other issue we discussed, of the Record prototype? The current state of the proposal is still that Records have a null [[Prototype]]

[21:54:34.0884] <ljharb>
no, i haven't written anything up yet

[21:54:36.0824] <bakkot>
+1 to not calling `.join`

[21:54:40.0286] <bakkot>
that was always crazy

[21:54:59.0415] <HE Shi-Jun>
> <@rricard:mozilla.org> HE Shi-Jun: might be worth raising on the queue

can someone raise that? I am not sure my mic work because I use a different computer today

[21:55:11.0304] <Michael Ficarra>
one of very few places we defer to a method lookup by string

[21:55:16.0971] <Robin Ricard>
ljharb: also feel free to bring up the debug use case in tcq

[21:55:45.0203] <littledan>
> <@shuyuguo:matrix.org> msaboff: my question is 1) what part of ShadowRealms did Safari 16 ship, since web API integration isn't yet finished, 2) was it a mistake, as saam suggested on twitter

msaboff: Do ShadowRealms in Safari 16 support any Web APIs at all? e.g., AbortController, TextEncoder

[21:57:59.0809] <Michael Ficarra>
also looks like undefined values are printed as "undefined", not empty

[21:58:47.0408] <msaboff>
> <@littledan:matrix.org> msaboff: Do ShadowRealms in Safari 16 support any Web APIs at all? e.g., AbortController, TextEncoder

I do think the ShadowRealms we have support the Web APIs.

[22:00:46.0711] <littledan>
Oh, that's a relief. So if the list of web APIs ends up matching (and I can't imagine what kind of semantic mismatch might exist), the only mismatch would be the error message semantics, which is unlikely to be much of a compatibility issue

[22:00:55.0945] <bakkot>
have we considered just not boxing these things even in sloppy mode

[22:01:01.0742] <Jack Works>
how can you observe the stringification result of Symbol?

[22:01:02.0615] <bakkot>
that would be a weird divergence in sloppy mode

[22:01:05.0744] <msaboff>
> <@littledan:matrix.org> msaboff: Do ShadowRealms in Safari 16 support any Web APIs at all? e.g., AbortController, TextEncoder

 * I don't think the ShadowRealms we have support the Web APIs.

[22:01:05.0772] <shu>
littledan: is the list of web APIs finalized?

[22:01:11.0892] <shu>
like, the list Exposed=* stuff

[22:01:15.0251] <bakkot>
but you should not be in sloppy mode so I don't care if there are weird divergences

[22:01:23.0172] <bakkot>
 * but you should not be in sloppy mode so I don't care if there are weird divergences

[22:01:26.0283] <Jack Works>
I tried Object.prototype.toString, `"" + ...` and with Object wrapper for Symbol, they don't work

[22:01:27.0476] <littledan>
shu: Yeah this has been stable for more than a month and is generally landed upstream

[22:01:33.0985] <shu>
okay, great

[22:01:50.0975] <bakkot>
Jack Works: String(Symbol())

[22:01:51.0249] <Michael Ficarra>
shu: `#[0]` and `#[0n]` have the same toString

[22:02:03.0100] <nicolo-ribaudo>
> <@bakkot:matrix.org> have we considered just not boxing these things even in sloppy mode

Yes, but it would break "Object(value) always returns an object"

[22:02:11.0307] <bakkot>
throw

[22:02:12.0908] <shu>
Michael Ficarra: right, thanks

[22:02:14.0149] <bakkot>
I guess

[22:02:20.0051] <bakkot>
or just make a copy instead of a wrapper

[22:02:57.0378] <Michael Ficarra>
 * shu: `#[0]` and `#[0n]` have the same toString

[22:03:40.0154] <littledan>
IMO we should decide on whether to introduce a brand check based on use cases today, rather than promises in the ES6 era

[22:04:10.0532] <ljharb>
the use cases remain the same.

[22:05:47.0416] <shu>
then those aren't invariants, those are just properties

[22:06:04.0031] <leobalter>
Rob Palmer: do we have other topics for today?

[22:06:24.0798] <Rob Palmer>
Michael Ficarra will be next

[22:06:37.0897] <ljharb>
note that "a primitive has a wrapper" is another "invariant-esque property"

[22:06:43.0439] <ljharb>
 * note that "a primitive has a wrapper" is another "invariant-esque property"

[22:06:51.0375] <bakkot>
is it one you care about

[22:06:53.0262] <Jack Works>
what invariant?

[22:06:54.0016] <bakkot>
it is not one I care about

[22:06:56.0009] <ljharb>
bakkot: yes; tons of old on the web will likely break if that property is broken

[22:06:59.0754] <ljharb>
 * @bakkot yes

[22:07:21.0734] <ljharb>
 * bakkot: yes; tons of old on the web will likely break if that property is broken

[22:07:41.0602] <nicolo-ribaudo>
The old code on the web doesn't use R&T

[22:07:50.0622] <nicolo-ribaudo>
 * The old code on the web doesn't use R&T

[22:08:18.0228] <ljharb>
no, but the old code includes shims like es5-shim, and people *will* pass R&Ts to those shimmed methods. and some of them shim even in modern engines.

[22:08:42.0846] <msaboff>
> <@msaboff:matrix.org> I don't think the ShadowRealms we have support the Web APIs.

Our Web API support in ShadowRealms is behind an experimental flag, which is off by default. 

[22:08:52.0053] <snek>
the shims are not written in sloppy mode are they?

[22:08:55.0934] <bakkot>
> <@ljharb:matrix.org> no, but the old code includes shims like es5-shim, and people *will* pass R&Ts to those shimmed methods. and some of them shim even in modern engines.

I am OK with that

[22:09:16.0099] <ljharb>
i am not

[22:10:07.0366] <bakkot>
we definitely should not be trying to maintain the property that old code works when you pass it new values

[22:10:09.0910] <shu>
the backwards compat promise is that unmaintained sites continue to work

[22:10:24.0683] <shu>
it is not sites continue to work regardless of what modifications they make

[22:10:33.0627] <ljharb>
i'm not sure how simple that is given that people update third-party dependencies they don't control.

[22:10:38.0927] <ljharb>
but fair enough

[22:10:52.0607] <rbuckton>
there exists a fair amount of code in the wild that preferred `Object(value) === value` to test for objects instead of `typeof value === "object" && value !== null || typeof value === "function"`. Not boxing would cause code that expects to be safe to evaluate to become unsafe.

[22:11:49.0762] <snek>
Object(#{}) === #{} would be false, since it is not an object

[22:11:51.0690] <littledan>
> <@msaboff:matrix.org> I don't think the ShadowRealms we have support the Web APIs.

Oh wow I somehow missed the word "don't" here. So, now this makes a compatibility matrix for ShadowRealms that I was hoping we could avoid.

[22:12:16.0659] <rbuckton>
> <@devsnek:matrix.org> Object(#{}) === #{} would be false, since it is not an object

Correct. That's the expected behavior.

[22:12:29.0560] <shu>
> <@littledan:matrix.org> Oh wow I somehow missed the word "don't" here. So, now this makes a compatibility matrix for ShadowRealms that I was hoping we could avoid.

ha so did i, i read your response first

[22:12:45.0067] <shu>
msaboff: given that i'm asking something radical: i'd consider this a mistake and a respin would be nice, if possible

[22:12:50.0641] <msaboff>
> <@littledan:matrix.org> Oh wow I somehow missed the word "don't" here. So, now this makes a compatibility matrix for ShadowRealms that I was hoping we could avoid.

The Web APIs are currently behind an experimental flag that is off by default.

[22:12:51.0196] <shu>
but of course, safari rel-eng makes the decision

[22:13:02.0721] <rbuckton>
Throwing would be unexpected and has the potential to break code paths that are expected to not throw for anything.

[22:13:04.0632] <Richard Gibson>
I would not have guessed Records & Tuples to break a language that already has string primitives with both numeric index properties and a named property

[22:13:10.0472] <shu>
msaboff: is ShadowRealm unflagged or on-by-default?

[22:13:17.0947] <Anthony Bullard>
Thanks whoever is helping on notes

[22:14:13.0744] <msaboff>
> <@shuyuguo:matrix.org> msaboff: is ShadowRealm unflagged or on-by-default?

I believe that ShadowRealms themself are on, but Web API support is behind an experimental flag which is off by default.

[22:14:41.0335] <rbuckton>
What would be the point of creating a Proxy for a record/tuple? 

[22:15:03.0916] <shu>
msaboff: hmm, i see. at the risk of forward interop, i think a respin would be good if at all possible

[22:15:17.0497] <rbuckton>
You can't create a proxy for a number or string

[22:15:29.0372] <ljharb>
> <@rbuckton:matrix.org> What would be the point of creating a Proxy for a record/tuple?

not much of one, to be sure.

[22:15:42.0532] <shu>
leobalter: no that's not a good thing!

[22:15:51.0935] <snek>
problem solved? https://gc.gy/130751150.png

[22:16:10.0294] <msaboff>
@shu littledan I am checking on the true status of Web APIs and ShadowRealms in Safari 16.  I'm looking at the current ToT WebKit.

[22:16:12.0674] <bakkot>
> <@gibson042:matrix.org> I would not have guessed Records & Tuples to break a language that already has string primitives with both numeric index properties and a named property

I can't tell what this means

[22:16:24.0868] <shu>
msaboff: thank you

[22:17:12.0867] <leobalter>
shu: I believe the Web API on by default could lead to unwanted usage if we eventually drop anything from what is currently offered

[22:17:56.0715] <shu>
leobalter: but SRs being shipped unflagged is not good for forward compat

[22:18:13.0923] <shu>
if that is the case, maybe it isn't

[22:18:27.0297] <Richard Gibson>
> <@bakkot:matrix.org> I can't tell what this means

that we already have much precedent in the String type, and it's not clear to me what benefits would come from deviating

[22:19:01.0544] <leobalter>
shu: I understand that, and I've been talking to WebKit people all day at TPAC. My 🙌 reaction was to the least blast of impact

[22:20:53.0558] <snek>
is anyone talking right now

[22:20:54.0440] <bakkot>
Richard Gibson: what specific deviation are you referring to?

[22:21:00.0446] <ryzokuken>
yes

[22:21:00.0988] <snek>
oh nvm

[22:21:17.0914] <HE Shi-Jun>
I am not sure I understand the brand-checking issue. What `Object.p.toString.call(Object(#{}))` returns as current draft??

[22:22:08.0099] <Richard Gibson>
@bakkot: `Object(#{…})` returning anything other than a wrapper object

[22:22:22.0580] <Ashley Claymore>
"\[Object record\]"

[22:22:29.0735] <Ashley Claymore>
> <@haxjs:matrix.org> I am not sure I understand the brand-checking issue. What `Object.p.toString.call(Object(#{}))` returns as current draft??

 * "\[Object record\]"

[22:22:42.0223] <Richard Gibson>
 * @bakkot: `Object(#{…})` returning anything other than a wrapper object

[22:22:43.0722] <bakkot>
Richard Gibson: the benefit is not introducing a new kind of wrapper object

[22:22:52.0103] <bakkot>
I would like to only introduce new kinds of things if we want them

[22:22:53.0579] <HE Shi-Jun>
So we already have brand check via Object.p.toString ?

[22:23:16.0980] <Ashley Claymore>
Object.p.toString can be faked with Symbol.toStringTag

[22:23:39.0785] <Ashley Claymore>
so would need to check if the value has the symbol, but that can be faked with a proxy

[22:23:49.0827] <leobalter>
shu: from my end, this release is forcing me to prioritize the shadowrealms work internally, I keep committed to make sure we mitigate the risk of impact. I'm trying this through resolution for the last parts needed to unlock regular implementation. That's why I summarize them, I wanted to make sure I'm not missing anything.

[22:23:51.0191] <Mathieu Hofman>
Promise does not have a brand check that has no side effects

[22:24:13.0293] <shu>
leobalter: understood

[22:24:16.0852] <snek>
you can brand check a promise?

[22:24:47.0248] <Richard Gibson>
> <@bakkot:matrix.org> I would like to only introduce new kinds of things if we want them

at the cost of decades of intuition, supported even in the recent past with Symbol and BigInt?

[22:24:49.0369] <Mathieu Hofman>
You can but it may execute user code. I don't know if that's a requirement for other brand checks

[22:24:51.0294] <rbuckton>
Bradford Smith: `{ __proto__: null, toString() { return "#{" } }` would satisfy your example and not be a record wrapper.

[22:25:21.0945] <ljharb>
Mathieu Hofman: that's true. but `Promise.resolve(p) === p` ends up being "fine" in practice. i'd certainly prefer a robust approach, ofc.

[22:25:44.0286] <ljharb>
 * Mathieu Hofman: that's true. but `Promise.resolve(p) === p` ends up being "fine" in practice. i'd certainly prefer a robust approach, ofc.

[22:25:45.0998] <snek>
oh with Promise.resolve right

[22:26:18.0035] <Robin Ricard>
agree: fine to go ahead without brand check

[22:26:31.0049] <Robin Ricard>
unconvinced: something is needed to address brand check

[22:26:31.0220] <bakkot>
Richard Gibson: it is not clear to me why this intuition is valuable?

[22:26:41.0670] <snek>
ljharb this feels kind of like "your scientists were so preoccupied with whether they could they didn't stop to think if they should"

[22:26:43.0098] <bakkot>
like, who cares whether it is an actual wrapper or a copy? who is that important to?

[22:27:03.0520] <leobalter>
shu: also, our membrane framework at Salesforce deletes all the Web APIs from a ShadowRealm and we don't rely on the errors (we have userland mechanisms to capture details cross realms). We won't ship the membrane framework using ShadowRealms for at least 6 months, guaranteed.

[22:27:03.0609] <ljharb>
to users who want to realize they accidentally wrapped a primitive. it happens, albeit rarely.

[22:27:15.0211] <rbuckton>
Any reason not to have Records have a prototype that is frozen and has a `valueOf` method?

[22:27:24.0832] <ljharb>
then you couldn't have a record with a `valueOf` key

[22:27:26.0538] <shu>
leobalter: i am not concerned about SF, it is clear enough that y'all can push updates out if needed

[22:27:56.0163] <Richard Gibson>
> <@bakkot:matrix.org> like, who cares whether it is an actual wrapper or a copy? who is that important to?

there's lots of code that uses `Object(…)` as an "is not primitive" predicate

[22:27:58.0919] <rbuckton>
ljharb: it could have an own `valueOf` key, just like an object.

[22:28:04.0288] <bakkot>
Richard Gibson: that would not be broken by my proposal

[22:28:12.0812] <leobalter>
shu: once again, I'm trying to mitigate the impact by usage of the feature. It's what I can do at this point. 

[22:28:26.0788] <Jack Works>
what is temp checking RN?

[22:28:29.0307] <ljharb>
rbuckton: so then you wouldn't be able to safely `.valueOf` on a record. there was a strong desire to avoid that kind of problem.

[22:28:31.0531] <rbuckton>
bakkot: that could be significantly more expensive than `Object(0)`

[22:28:48.0731] <nicolo-ribaudo>
> <@jackworks:matrix.org> what is temp checking RN?

"Do we care strongly about brand checking for record wrappers?"

[22:28:51.0243] <waldemar>
We opened such a Pandora's box by letting folks customize Object.prototype.toString tags.

[22:29:03.0029] <ljharb>
yep, and we shouldn't have

[22:29:23.0625] <ljharb>
we could have pulled toStringTag from ES6 and left time to come up with a better solution, but we didn't do that (and i was too green to realize i could have insisted)

[22:29:34.0150] <rbuckton>
Having `Object(#{ arbitrarilyLargeRecord })` convert the record to an object seems expensive for such a test.

[22:29:41.0010] <ljharb>
 * we could have pulled toStringTag from ES6 and left time to come up with a better solution, but we didn't do that (and i was too green to realize i could have insisted)

[22:29:43.0510] <littledan>
yeah, like half of the symbols were a mistake

[22:30:04.0234] <snek>
most of javascript was a mistake tbh

[22:30:10.0089] <snek>
bigints are good though

[22:30:22.0842] <Michael Ficarra>
and throwing them all on a big string-based namespace under `Symbol` is both ironic and stupid

[22:30:45.0111] <shu>
and making Symbol.for symbols different from strings lol

[22:30:46.0978] <bakkot>
that's fair, but I don't think it would be expensive in practice - how expensive is `Object.entries`? (It wouldn't be a deep conversion, to be clear)

[22:30:54.0160] <Mathieu Hofman>
I still wish all `Symbol.toStringTag` were actually getters that brand checked like for the TypedArray prototype. Then we'd solve all brand check problems

[22:31:18.0979] <ljharb>
> <@mhofman:matrix.org> I still wish all `Symbol.toStringTag` were actually getters that brand checked like for the TypedArray prototype. Then we'd solve all brand check problems

and if i'd thought of that in 2014 then i'd have suggested it, but i didn't come up with it til it was too late :-(

[22:31:49.0720] <ljharb>
altho i'm pretty sure it would still be web-compatible to change them all into those now, it's just that the committee at large likely doesn't care enough to want to spend time on that.

[22:32:47.0834] <rbuckton>
If we don't have a prototype, could we have a `Record.unwrap(wrappedRecord)` (or other name) that throws on non-record, and non-wrapped-records? It could act as a brand check and give you a `valueOf` workaround.

[22:33:18.0711] <ljharb>
that's what the champions think is ill-fitting.

[22:33:48.0138] <ljharb>
record primitives could also have an own Symbol.toPrimitive method. there's lots of ways to solve it, but it seems unpalatable to some.

[22:34:40.0009] <bakkot>
> <@rbuckton:matrix.org> Having `Object(#{ arbitrarilyLargeRecord })` convert the record to an object seems expensive for such a test.

 * that's fair, but I don't think it would be expensive in practice - how expensive is `Object.entries`? (It wouldn't be a deep conversion, to be clear)

[22:37:41.0565] <danielrosenwasser>
can someone advance the queue?

[22:38:30.0280] <shu>
is this really an FYI for committee?

[22:38:57.0437] <shu>
is there feedback R&T champions are specifically looking for from TC39 and not just from TS?

[22:39:25.0437] <danielrosenwasser>
well it's implementer feedback from tooling - e.g., "if we do XYZ, a linter or type-checker cannot catch ...."

[22:40:04.0622] <bakkot>
danielrosenwasser: is it though?

[22:40:07.0481] <bakkot>
what's the XYZ here?

[22:40:09.0561] <danielrosenwasser>
It is?

[22:40:14.0999] <littledan>
there are also lots of TS users in committee, and this all ties together, so it's good to get more developer feedback here

[22:40:22.0917] <littledan>
 * there are also lots of TS users in committee, and this all ties together, so it's good to get more developer feedback here

[22:40:26.0007] <bakkot>
like I'm missing what the feedback for the proposal actually is

[22:40:31.0974] <shu>
that's all fine, but i'm looking for the actual ask

[22:40:32.0794] <bakkot>
I am in general in favor of such feedback

[22:40:33.0350] <HE Shi-Jun>
Agree TS is very important to consider in any proposals.

[22:40:50.0272] <shu>
it is not a general thing that proposals lay out what TS integration looks like

[22:41:25.0928] <littledan>
A big takeaway: TS raised a reasonable compatibility risk, Bloomberg investigated this and found that the breakage was much less than some other TS upgrades have been

[22:41:43.0561] <shu>
but... did the proposal itself need changing?

[22:41:44.0756] <littledan>
the compatibility risk is based on our choice of typeof (in the language!)

[22:41:49.0772] <shu>
okay

[22:41:50.0368] <Ashley Claymore>
FWIW we also looked at how flow models its core types. And the story is different there as they are generally stricter about modelling things like primitive vs object and readonly

[22:41:57.0403] <littledan>
> <@shuyuguo:matrix.org> but... did the proposal itself need changing?

No, but they're explaining why

[22:42:03.0630] <shu>
i see

[22:42:19.0233] <littledan>
IMO this is pretty relevant to JS developers

[22:42:46.0764] <bakkot>
I am glad to hear that TS is exploring how to make this work and the champions think it will probably work with minimal breaking changes, if that is the intended takeaway?

[22:43:17.0277] <littledan>
> <@bakkot:matrix.org> I am glad to hear that TS is exploring how to make this work and the champions think it will probably work with minimal breaking changes, if that is the intended takeaway?

IMO yes, but the champions can confirm

[22:44:43.0780] <Anthony Bullard>
I have to drop, thanks all

[22:48:35.0114] <danielrosenwasser>
> <@bakkot:matrix.org> like I'm missing what the feedback for the proposal actually is

My 2 cents here - the state of this proposal poses a set of possible design directions for type-checkers.

In the case of TypeScript, for example, we must decide whether our current object-like hierarchy can also model records and tuples, or if it must create a completely separate type hierarchy (or perhaps something in between if we think very hard). Bloomberg investigated how disruptive choosing one path would be, and wanted to provide their feedback on the experience.

So it's relevant to discuss here because maybe there are ideas/thoughts from the committee, or maybe there are possible suggestions for the champions on how the proposal can make adjustments.

[22:49:33.0050] <Anthony Bullard>
Someone please take my place helping with notes - to the extent I was a help at all

[22:49:43.0469] <nicolo-ribaudo>
> <@anthonybullard:matrix.org> Someone please take my place helping with notes - to the extent I was a help at all

I can do it

[22:49:50.0304] <Anthony Bullard>
Thank you nicolo-ribaudo !

[22:51:13.0790] <shu>
danielrosenwasser: thank you, that's a very helpful summary

[22:52:26.0446] <snek>
does `\p{Surrogate}` only match unpaired surrogates?

[22:52:27.0586] <littledan>
yeah probably my takeaway was too strong, but it's just my personal opinion, how I understand it. You notice both the champions and Daniel are refraining from drawing such a strong reading...

[22:53:00.0381] <Justin Ridgewell>
I imagine it does in `u` mode

[22:55:51.0342] <waldemar>
The spec text of this proposal is delightfully short!

[22:55:55.0432] <littledan>
+1 to this proposal advancing

[22:55:57.0747] <bakkot>
danielrosenwasser: I guess I think TC39 probably isn't going to be all that helpful for suggestions for how TS should represent or typecheck stuff, as a rule, 'cause we don't really have the tradeoffs internalized for what breakages are acceptable and etc

[22:57:37.0455] <Justin Ridgewell>
👍️ Unicode says to use the Replacement Character

[22:58:45.0704] <littledan>
> <@bakkot:matrix.org> danielrosenwasser: I guess I think TC39 probably isn't going to be all that helpful for suggestions for how TS should represent or typecheck stuff, as a rule, 'cause we don't really have the tradeoffs internalized for what breakages are acceptable and etc

Maybe not all of TC39, but TC39 has a number of TS users in it who may weigh in. There are a lot of things we discuss that not everyone can have opinions on.

[23:02:24.0476] <bakkot>
I'm definitely such a person. I just don't think I have feedback in my capacity as a TC39 member, vs as a person who writes TS, if that makes sense?

[23:02:25.0474] <HE Shi-Jun>
waldemar: Current slice() may break a well formed string into non well formed pieces. I am considering possible extensions of slice notation proposal (not current, because current draft do not include string) might solve that.

[23:03:32.0805] <littledan>
> <@bakkot:matrix.org> I'm definitely such a person. I just don't think I have feedback in my capacity as a TC39 member, vs as a person who writes TS, if that makes sense?

I guess I feel like, it's *good* if delegates bring different aspects of their expertise/experience into the committee

[23:03:45.0548] <littledan>
(so, no, it doesn't make sense to me)

[23:04:22.0295] <bakkot>
well, it's more a question of what the committee is? the committee is a good venue for discussing JS, the language, and so is a good place for discussions like "what changes can we make to the proposal to make it easier for TS to typecheck, if they're having difficulties"

[23:04:57.0731] <bakkot>
but I don't think it is a good venue for discussing "what are the tradeoffs TS should make when typechecking this feature we've proposed", even if that's a subject I do have opinions on

[23:05:22.0920] <shu>
i was approaching it from a pure time efficiency standpoint. it seemed to me at the time there was risk of delegates getting nerdsniped with no material effect on the proposal, which didn't seem like a good use of time

[23:05:48.0139] <bakkot>
it is maybe a good place for questions like "how do we expect this proposal to be used?", as data for the TS team to use to make decisions about those tradeoffs, but I didn't really hear a question of that form in this discussion

[23:08:09.0886] <Ashley Claymore>
This is good feedback. We had a mix of items, some were about sharing the outcomes of our research, others were items we explicitly wanted feedback on. We did not make it clear which were which.

[23:08:19.0037] <Ashley Claymore>
 * This is good feedback. We had a mix of items, some were about sharing the outcomes of our research, others were items we explicitly wanted feedback on. We did not make it clear which were which.


2022-09-14
[17:52:00.0408] <Axel Rauschmayer (self-employed)>
Sorry, off-topic, but could we do a quick test if showing my slides works?

[17:55:48.0880] <Robert Pamely>
Is the video conference live?

[17:56:00.0815] <Robert Pamely>
I see waiting for host

[17:56:07.0453] <bterlson>
it is not started yet

[17:56:08.0860] <Axel Rauschmayer (self-employed)>
Me too. We need a host, yes.

[17:56:13.0793] <bterlson>
waiting for an igalian to do so :)

[17:56:15.0185] <Robert Pamely>
ok thanks Brian

[17:56:25.0301] <Axel Rauschmayer (self-employed)>
Hehe

[17:59:16.0969] <Ashley Claymore>
> <@rauschma:matrix.org> Sorry, off-topic, but could we do a quick test if showing my slides works?

very on-topic! :D top tip: sometimes have to restart the browser if only just given permission to share screen for the first time

[17:59:54.0648] <Axel Rauschmayer (self-employed)>
Yeah, already did that (the screen sharing background helps with testing).

[18:01:39.0974] <littledan>
I guess you can try screen sharing now?

[18:09:35.0378] <littledan>
Are we ready to get started?

[18:09:53.0949] <shu>
haven't we already started?

[18:10:12.0621] <bakkot>
we have in fact already started

[18:10:14.0245] <snek>
axel has been presenting for like 5 minutes

[18:14:10.0513] <littledan>
Oh! A problem on my end

[18:15:41.0141] <Michael Ficarra>
what is meant by "a wrapping API" here?

[18:16:29.0962] <ljharb>
isn't `Iterable.from()` already a wrapping API? it's just that most builtin iterators are/will be pre-wrapped

[18:16:30.0022] <bakkot>
something like Jquery

[18:16:45.0948] <ljharb>
 * isn't `Iterable.from()` already a wrapping API? it's just that most builtin iterators are/will be pre-wrapped

[18:16:55.0701] <bakkot>
where you do `$(document.querySelectorAll(...))` and then get a new thing that has a bunch of helper functions

[18:17:36.0034] <Michael Ficarra>
how is that different than what we do?

[18:17:50.0536] <bakkot>
you don't need to wrap most of the time

[18:17:51.0132] <HE Shi-Jun>
A real example of "wrapping API"

[18:17:57.0528] <HE Shi-Jun>
Emitter proposal

[18:18:06.0464] <HE Shi-Jun>
https://github.com/tc39/proposal-emitter

[18:18:07.0751] <bakkot>
like if you do `map.values().filter()` there's no explicit wrapper

[18:18:16.0238] <ljharb>
right, builtins are "pre-wrapped"

[18:18:21.0717] <ljharb>
(or some better way to describe it)

[18:18:26.0372] <Michael Ficarra>
yeah, that's kinda my mental model

[18:19:02.0724] <HE Shi-Jun>
Emitter proposal also use function style.

[18:19:46.0254] <HE Shi-Jun>
```js
const { on, map, filter, run } = Emitter

run(
  on(document, 'click')
, filter(ev => ev.target.tagName === 'BUTTON')
, map(ev => ({ x: ev.clientX, y: ev.clientY }))
, coords => console.log(coords)
)
```

[18:20:00.0822] <Michael Ficarra>
that's applicative style, no?

[18:21:44.0112] <ljharb>
Axel Rauschmayer (self-employed): re builtin modules, pending that proposal advancing, short answer is no, not in the cards (shu's queue item covers this also)

[18:22:00.0434] <ljharb>
 * Axel Rauschmayer (self-employed): re builtin modules, pending that proposal advancing, short answer is no, not in the cards (shu's queue item covers this also)

[18:23:24.0999] <Michael Ficarra>
it's iterable ONCE, which is the important point

[18:24:28.0590] <Michael Ficarra>
iterators are kind of lying by implementing Symbol.iterator

[18:25:25.0274] <shu>
snek: wait, you are in favor of using iterable helper functions as Axel proposed?

[18:26:08.0988] <Michael Ficarra>
shu: no I think they were saying iterator helpers as functions (conditional on pipe operator)

[18:26:26.0246] <shu>
we need a better word than "functions" here

[18:26:46.0547] <Michael Ficarra>
non-this-value-users

[18:27:09.0894] <ljharb>
"standalone functions" vs "methods" imo

[18:29:21.0016] <shu>
yes that's good

[18:31:05.0767] <ljharb>
Axel Rauschmayer (self-employed): for clarity; consensus typically means "some explicit yes's and no explicit no's" and does not imply or require universal enthusiasm :-)

[18:32:12.0296] <rbuckton>
I'm primarily in favor of the standalone function approach because its more flexible and is composable with third-party packages without the need for prototype patching (which is obviously bad). Yes that puts more of a dependency on pipeline, but I think pipeline can advance once the topic variable issue is addressed.

[18:34:33.0333] <snek>
to be clear i was concerned about wasting work on consensus, not work on spec text 

[18:35:59.0961] <Michael Ficarra>
oh god, a superclass of all collection types would be as bad an idea as Object.prototype already is

[18:36:32.0117] <shu>
haha oh no please no

[18:36:37.0721] <snek>
`class TCPConnection extends Collection`

[18:36:49.0655] <ljharb>
we could just call it `FragileBaseClass`

[18:36:52.0134] <ljharb>
oh wait sorry wrong channel

[18:36:58.0591] <Michael Ficarra>
why do so many people have this same bad idea?

[18:37:20.0824] <rbuckton>
ecosystem can/does have chaining-style via wrapping. And given the limited number of helper methods I'm still more likely to reach for 3rd-party.

[18:38:45.0171] <Michael Ficarra>
rbuckton: we have plans to add a lot more

[18:38:54.0091] <Michael Ficarra>
remember the current proposal is what we consider "minimal"

[18:39:09.0708] <ljharb>
so many more

[18:39:19.0966] <Michael Ficarra>
okay not *that* many

[18:39:22.0349] <snek>
i closed a lot of issues/prs for more methods

[18:39:22.0885] <Michael Ficarra>
like a dozen?

[18:39:31.0645] <snek>
 * i closed a lot of issues/prs for more methods

[18:40:20.0064] <bakkot>
https://github.com/tc39/proposal-iterator-helpers/issues?q=is%3Aissue+is%3Aclosed+label%3A%22good+follow-on+proposal%22

[18:40:32.0669] <rbuckton>
But until you do, and as long as there is an iterator helper I need that isn't in that list, I'm still bouncing between methods and functions. _Until we have pipeline_, but if we have pipeline I'd still rather have functions.

[18:42:38.0160] <Michael Ficarra>
we have 15 min underflow during this session, we might want to just let this topic go over by 15 min?

[18:43:08.0051] <Michael Ficarra>
especially given that this presenter is an invited expert, it would be nice to be more lenient with the timebox

[18:43:30.0136] <Anthony Bullard>
I don't think these functions would be global, correct Axel Rauschmayer (self-employed) ?

[18:43:41.0854] <Anthony Bullard>
I'm assuming they would be in a global namespace, like Math

[18:43:59.0089] <ljharb>
what would we call it tho - "Iterable" isn't a "thing", it's a trait

[18:44:35.0280] <rbuckton>
I have all of these as functions (`@esfx/iter-fn` and `@esfx/async-iter-fn`), and wrapping via a `Query` class (`@esfx/iter-query` and `@esfx/async-iter-query`). All of these are iterable (multi-shot if source returns a new itererator each time, single shot if the source returns the same iterator each time).

[18:44:37.0135] <ljharb>
to be fair, iterators aren't a thing either, but the helpers proposal makes a *wrapped* iterator A Thing, via `Iterator.from`

[18:44:45.0237] <Anthony Bullard>
That's a great point, but is there a concern with there being a global for the trait?

[18:44:54.0448] <ljharb>
it's just weird

