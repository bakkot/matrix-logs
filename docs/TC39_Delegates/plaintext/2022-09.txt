2022-09-01
[13:58:31.0354] <Justin Ridgewell>
Can I get write access to test262?

[13:58:52.0185] <Justin Ridgewell>
Trying to update the group/groupToMap PRs made by another contributor, but I can't push without access.


2022-09-02
[09:07:30.0976] <ljharb>
Justin Ridgewell: i just added you with write access, in theory CODEOWNERS should prevent you from merging but Write should allow you to force push to the PR; please lmk if theory doesn't hold

[09:28:51.0497] <Justin Ridgewell>
Thanks

[09:50:33.0114] <bterlson>
< 24 hours to get your agenda items in for the next meeting! Looks like this will be a short one unless folks are waiting for the last possible second.

[15:03:56.0082] <bakkot>
ljharb (or any admin): can I be given write access to https://github.com/tc39/proposal-set-methods? ðŸ˜…

[15:20:57.0381] <ljharb>
done

[16:48:49.0262] <bakkot>
ljharb re https://github.com/tc39/proposal-iterator-helpers/issues/117#issuecomment-1235980915 "i'd prefer it brand-check" - what do you actually want it to brand check?

[16:49:05.0131] <bakkot>
I'm confused about what the ask is

[16:58:02.0516] <ljharb>
instances of iterator

[16:58:17.0160] <ljharb>
so it throws if anyone extracts the getter and dot calls it on something different


2022-09-03
[18:18:56.0824] <bakkot>
so an `instanceof` check, you mean? that doesn't seem that useful; you can do that yourself

[22:05:49.0750] <ljharb>
no, not an instanceof check, those are forgeable and don't work across realms. a brand check.

[09:00:22.0548] <bakkot>
ljharb: what brand do you imagine checking? there are a bunch of different built-in iterators in the language and the web platform, and they don't have a common brand

[09:00:46.0177] <bakkot>
the whole point of iterator being an interface is that the interface is implemented by a bunch of different classes, including userland classes

[09:02:50.0840] <littledan>
IMO the appropriate level for a brand check here would be to revert the whole Symbol.toStringTag change in the first place... what a bad idea of a feature. Not clear if it makes sense to "chip away at it" as much as I'm sympathetic with the idea to try.

[09:06:01.0455] <littledan>
it's not unthinkable to add a brand just for this purpose in https://tc39.es/proposal-iterator-helpers/#sec-iterator but I don't see the point

[09:06:41.0126] <littledan>
(do we want to start telling people, they shouldn't be pasting iterator helpers onto a base class by messing with a prototype chain? that seems like a useful mode to me)

[09:07:01.0926] <littledan>
 * (do we want to start telling people, they shouldn't be pasting iterator helpers onto a base class by messing with a prototype chain? that seems like a useful mode to me)


2022-09-04
[18:42:16.0345] <ljharb>
they do have a common brand now, itâ€™s what Iterator.from provides

[18:42:40.0929] <ljharb>
and a userland class will be wrapped by a branded object.

[08:36:39.0724] <bakkot>
Iterator.from checks `instanceof Iterator` and returns the original object if that returns true

[08:36:52.0231] <bakkot>
so no, it does not provide a common brand

[08:37:01.0436] <bakkot>
 * so no, it does not provide a common brand

[10:33:56.0875] <snek>
without first class protocols the only ways to check if something is an actual iterator is either rely on the prototype or exhaustively interrogate its methods 

[10:34:20.0633] <snek>
* without first class protocols the only ways to check if something is an actual iterator is either rely on the prototype or exhaustively interrogate its methods 

[11:17:16.0208] <rbuckton>
This is one reason why I'm still wary of using Iterator rather than an Iterable. 


2022-09-05
[18:13:02.0539] <ljharb>
i didnâ€™t realize that. It shouldnâ€™t use instanceof - like everything else in the language, it should use a brand.

[18:17:51.0847] <bakkot>
no, it's an interface

[18:17:54.0377] <bakkot>
it's not a class

[18:17:58.0963] <bakkot>
I mean, it is also a class

[18:18:30.0356] <bakkot>
but there is no particular reason a userland instance needs to have the brand

[19:14:15.0471] <snek>
> <@ljharb:matrix.org> i didnâ€™t realize that. It shouldnâ€™t use instanceof - like everything else in the language, it should use a brand.

how do you brand something whose definition is "has a next method that returns { value, done }"

[19:15:56.0312] <snek>
or if you subscribe to the other idea, "an object inheriting Iterator.prototype"

[20:35:23.0409] <ljharb>
objects in the language that inherit from a prototype also have a brand, thats checked in places. 

[20:38:35.0852] <snek>
no i like

[20:38:42.0553] <snek>
i do not understand the mechanic by which this would work

[10:17:26.0579] <ljharb>
anything that's `instanceof Iterator` in the language would have an internal slot, which is what Iterator.from would check

[10:28:14.0641] <bakkot>
in the language or, presumably, the web platform?

[10:28:28.0850] <bakkot>
I suppose that would be possible but... why?

[11:22:09.0722] <snek>
> <@ljharb:matrix.org> anything that's `instanceof Iterator` in the language would have an internal slot, which is what Iterator.from would check

how do they get the internal slot? they're just random objects

[11:23:40.0028] <snek>
oh are you saying Iterator.from would be the thing that produces objects with that slot

[11:25:30.0272] <snek>
technically the new object it returns has `[[Iterated]]`

[11:25:31.0130] <snek>
but

[11:25:37.0717] <snek>
it doesn't have to return the new object

[11:26:10.0577] <snek>
like if i run `Iterator.from({ next() {}, __proto__: Iterator.prototype })`, it should return that argument unchanged

[12:26:30.0104] <ljharb>
that doesnâ€™t seem like what it should be doing at all.

[12:27:17.0394] <ljharb>
Array.from doesnt pass through return an arraylike object that has a proto of Array.prototype - it returns a proper array. So should Iterator.from.

[12:28:31.0086] <bakkot>
the definition of "proper iterator" _is_ "inherits from Iterator.prototype", in this context

[12:44:30.0140] <ljharb>
i don't think that is or should be the definition

[13:00:34.0611] <bakkot>
why?

[14:08:11.0778] <snek>
Iterator is not a concrete thing, I'd rather rename the method if that's the problem

[14:15:40.0372] <ljharb>
the whole point of Iterator.from is that it's becoming a concrete thing

[14:15:49.0067] <snek>
no its just that its giving it the prototype

[14:16:05.0528] <snek>
its a convenience for the methods

[14:16:47.0742] <ljharb>
â€¦ and the methods do a wrap (to something with the slot) if they're `.call`ed on a random object?

[14:17:33.0567] <snek>
i don't understand what this means

[14:17:41.0235] <ljharb>
the `[[Iterated]]` slot you mentioned

[14:18:21.0801] <snek>
`[[Iterated]]` is just used for %WrapForValidIteratorPrototype%.next/return

[14:18:33.0754] <ljharb>
how can the next method retain internal state unless it has a place to put it?

[14:19:11.0869] <snek>
WrapForValidIteratorPrototype objects don't have any internal state

[14:19:24.0161] <snek>
[[Iterated]] is just the object they wrap

[14:19:41.0461] <snek>
well, the iterator record for it

[14:20:57.0151] <ljharb>
ok so like `map`. it has to hold on to the original iterator, and to the callback

[14:21:15.0595] <ljharb>
so presumably the iterator object returned by `map` holds that, in an internal slot

[14:21:53.0713] <snek>
they use closures

[14:22:27.0105] <ljharb>
so the iterator object doesn't use a shared `next` method, it makes a new one each time `map` is called?

[14:22:39.0264] <snek>
uhh

[14:22:43.0674] <snek>
it uses %IteratorHelperPrototype%.next

[14:22:47.0801] <snek>
 * it uses %IteratorHelperPrototype%.next

[14:22:48.0948] <ljharb>
right. but that's a shared method.

[14:22:55.0382] <snek>
which is just %GeneratorPrototype%.next but fancy

[14:22:56.0847] <ljharb>
so it can't close over something that's unique to a given `map` call

[14:23:10.0849] <ljharb>
because it exists before `map` is ever called.

[14:23:11.0878] <snek>
 * which is just %GeneratorPrototype%.next but fancy

[14:23:24.0823] <ljharb>
so where is that state held so that `next` can access it?

[14:23:39.0873] <snek>
same place that normal generators store it

[14:23:50.0121] <snek>
the only thing is

[14:24:06.0149] <snek>
you can grep for `[[GeneratorBrand]]` in the spec

[14:24:06.0150] <ljharb>
right but that's in a slot on the generator instance, no?

[14:24:13.0324] <snek>
https://tc39.es/ecma262/#sec-generatorvalidate

[14:24:19.0829] <snek>
this is the only way it tells them apart

[14:24:28.0839] <snek>
but that just tells you if it was a generator helper method

[14:24:42.0969] <snek>
tbh i'm not sure why we separate them at all, they just call `GeneratorResume`

[14:25:04.0878] <ljharb>
right. and [[GeneratorContext]] and [[GeneratorState]] are slots on the iterator object that hold the state

[14:25:22.0708] <snek>
yeah its a generator

[14:25:27.0530] <ljharb>
right

[14:26:03.0805] <ljharb>
and GeneratorValidate brand-checks the iterator. it doesn't matter what its [[Prototype]] is, it matters if it has the expected slots.

[14:26:12.0585] <snek>
ye

[14:26:25.0083] <ljharb>
so i assume that Iterator Helper methods all do the same validation

[14:26:51.0015] <snek>
iterator helper methods do not know about those brand checks, they perform them via calling stuff like `GeneratorResume`

[14:26:57.0036] <ljharb>
right but they still exist

[14:26:59.0533] <snek>
sure

[14:27:01.0744] <ljharb>
which means that `{ __proto__: Iterator.prototype }` would fail that check, and not be a usable receiver with the Iterator Helper methods. which means Iterator.from musn't ever return it.

[14:27:17.0449] <ljharb>
which means that Iterator.from always returns a brand-checkable object, one that GeneratorValidate will accept.

[14:27:26.0938] <snek>
uhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh

[14:27:27.0624] <snek>
no

[14:27:36.0444] <ljharb>
what am i missing there?

[14:28:00.0628] <snek>
assuming this `let iterWithGeneratorSlots = [].values().map(x => x); `

[14:28:22.0541] <snek>
`Iterator.from(iterWithGeneratorSlots)` passes it through unchanged because it inherits from %Iterator.prototype%

[14:28:24.0787] <snek>
but

[14:28:57.0242] <snek>
if you do `Iterator.from({ next() {}, __proto__: Iterator.prototype })` it also passes it through unchanged

[14:29:04.0970] <snek>
that's not doing any generator stuff

[14:29:29.0694] <snek>
if you do `Iterator.from({ next() {} })` that creates a %WrapForValidIteratorPrototype% object and returns it

[14:29:30.0204] <ljharb>
ok but what happens with `Iterator.from({ next() {}, __proto__: Iterator.prototype }).map(x => x)`?

[14:29:37.0331] <snek>
but that still doesn't have any generator slots

[14:29:40.0615] <snek>
cuz its not a generator

[14:29:44.0860] <snek>
its just a stupid wrapper

[14:29:51.0977] <snek>
> <@ljharb:matrix.org> ok but what happens with `Iterator.from({ next() {}, __proto__: Iterator.prototype }).map(x => x)`?

that has generator slots cuz you called map

[14:30:06.0286] <ljharb>
ok, and `.map` doesn't care if its receiver has the slots?

[14:30:07.0853] <ljharb>
 * ok, and `.map` doesn't care if its receiver has the slots?

[14:30:12.0540] <snek>
no it does not

[14:30:15.0145] <ljharb>
oof

[14:30:19.0662] <snek>
all it cares is that the receiver is an iterator

[14:30:59.0446] <snek>
https://gc.gy/130118458.png

[14:32:13.0928] <snek>
this is why `{ next() {}, __proto__: Iterator.prototype }` is valid

[14:32:52.0882] <snek>
with protocols you have to assume that the object is already created as some other shape, you're augmenting them with the functionality, implementing the protocol on top of something else

[14:33:04.0619] <ljharb>
i don't understand why, if everyone's going to `Iterator.from()` anyways to get the methods, we wouldn't want to unconditionally wrap - ie, to unconditionally `.map(x => x)`

[14:33:24.0469] <ljharb>
 * i don't understand why, if everyone's going to `Iterator.from()` anyways to get the methods, we wouldn't want to unconditionally wrap - ie, to unconditionally `.map(x => x)`

[14:33:32.0370] <snek>
i think its pretty rare that you would *need* to use Iterator.from

[14:33:34.0392] <ljharb>
that way we have a consistent "real iterator" definition

[14:34:06.0617] <ljharb>
i think you'll want to do it any time you're dealing with a user-supplied iterator. which will be frequent.

[14:34:27.0005] <snek>
i mean, those are rare lol

[14:34:27.0301] <ljharb>
you'd want to maximally accept and normalize all possible iterators

[14:34:33.0290] <ljharb>
that's what `Promise.resolve` is good for too

[14:34:36.0360] <snek>
yeah i mean

[14:34:41.0810] <ljharb>
it normalizes thenables into Real Promises, which are always preferred

[14:34:46.0635] <snek>
if you're you, writing some sort of complex fancy library that has to deal with the world

[14:34:49.0388] <ljharb>
similarly i'd always want a Real Iterator, not just an "iterator"

[14:34:51.0688] <snek>
go for it

[14:35:06.0469] <ljharb>
this isn't just a "my unique coding style" thing tho, this is any package

[14:35:25.0531] <ljharb>
anything that accepts an iterator. just like anything that accepts a thenable always uses Promise.resolve or `await` to normalize it first into a real promise

[14:35:35.0379] <ljharb>
Iterator.from will be exceedingly common imo.

[14:35:35.0989] <snek>
its a nice convenient method yeah

[14:35:38.0604] <snek>
i was just pointing out

[14:35:44.0264] <snek>
its superfluous in 99% of cases

[14:36:01.0138] <snek>
so we made it not add extra overhead

[14:36:01.0299] <ljharb>
i don't think that's true

[14:36:08.0795] <ljharb>
i think 99% of cases will be dealing with untrusted iterators

[14:36:19.0924] <ljharb>
the case where you're iterating your own iterator are likely to be far rarer. (where "your own" doesn't deal with who the author is, but which chunk of code owns it)

[14:36:36.0548] <ljharb>
 * the case where you're iterating your own iterator are likely to be far rarer. (where "your own" doesn't deal with who the author is, but which chunk of code owns it)

[14:37:23.0449] <ljharb>
"extra overhead" isn't a real problem (it can be optimized away), but a footgun like "sometimes it doesn't wrap" imo would be

[14:37:27.0301] <snek>
the genesis of this proposal was the observation that all web and js platform iterators already inherit from a shared %IteratorPrototype%

[14:37:31.0109] <ljharb>
 * "extra overhead" isn't a real problem (it can be optimized away), but a footgun like "sometimes it doesn't wrap" imo would be

[14:37:45.0242] <snek>
and the remaining weird ones often use the `(function*(){})().next().__proto__` trick or whatever it is

[14:37:45.0962] <ljharb>
then whose don't need to wrap because they'll have the slots to begin with, so it doesn't matter what `Iterator.from` does for them

[14:38:12.0240] <ljharb>
why are we concerned with "overhead" for the highly unlikely case of someone doing `{ __proto__: Iterator.prototype }`?

[14:38:42.0354] <ljharb>
unlikely still means nonzero, and having to deal with that complexity (in the current case) is far more dangerous than "it's a bit slower if you do something super weird" (in the "always wrap" case)

[14:38:59.0139] <ljharb>
 * unlikely still means nonzero, and having to deal with that complexity (in the current case) is far more dangerous than "it's a bit slower if you do something super weird" (in the "always wrap" case)

[14:39:45.0721] <snek>
i am lost now

[14:40:36.0674] <snek>
the overhead is when you wrap something that is already matching the "iterator with prototype" definition, which is most iterator objects flying around

[14:41:08.0230] <snek>
 * the overhead is when you wrap something that is already matching the "iterator with prototype" definition, which is most iterator objects flying around

[14:44:11.0723] <ljharb>
anything created from the language or a generator or the web would/could already have the slots it needs. Itâ€™d only be a custom iterator implementation thatâ€™d need wrapping. How common are those?

[14:44:33.0604] <snek>
most custom ones already inherit from Iterator.prototype

[14:44:46.0954] <snek>
or they did, i haven't looked in several years 

[14:44:55.0217] <snek>
i would assume they didn't delete that though lol

[14:45:31.0244] <snek>
the pattern is `[][Symbol.iterator]().__proto__.__proto__`

[14:45:49.0173] <snek>
or getPrototypeOf instead

[14:47:35.0746] <snek>
so anyway to handle the case where they don't, we have this `Iterator.from` helper, and you can throw that in random places as needed

[14:47:49.0977] <snek>
but it exists purely to paper over the prototype

[14:48:43.0178] <snek>
like just thinking about the code i write for my day-to-day work, i would basically never use `Iterator.from`

[15:14:56.0504] <bakkot>
> i think 99% of cases will be dealing with untrusted iterators

i would guess well over 99% of code is internal, not in libraries, and in internal code you are not dealing with untrusted stuff, as a rule

[15:19:10.0909] <bakkot>
also I guess I am missing what the benefit of the internal slot is supposed to be

