2022-09-01
[13:58:31.0354] <Justin Ridgewell>
Can I get write access to test262?

[13:58:52.0185] <Justin Ridgewell>
Trying to update the group/groupToMap PRs made by another contributor, but I can't push without access.


2022-09-02
[09:07:30.0976] <ljharb>
Justin Ridgewell: i just added you with write access, in theory CODEOWNERS should prevent you from merging but Write should allow you to force push to the PR; please lmk if theory doesn't hold

[09:28:51.0497] <Justin Ridgewell>
Thanks

[09:50:33.0114] <bterlson>
< 24 hours to get your agenda items in for the next meeting! Looks like this will be a short one unless folks are waiting for the last possible second.

[15:03:56.0082] <bakkot>
ljharb (or any admin): can I be given write access to https://github.com/tc39/proposal-set-methods? ðŸ˜…

[15:20:57.0381] <ljharb>
done

[16:48:49.0262] <bakkot>
ljharb re https://github.com/tc39/proposal-iterator-helpers/issues/117#issuecomment-1235980915 "i'd prefer it brand-check" - what do you actually want it to brand check?

[16:49:05.0131] <bakkot>
I'm confused about what the ask is

[16:58:02.0516] <ljharb>
instances of iterator

[16:58:17.0160] <ljharb>
so it throws if anyone extracts the getter and dot calls it on something different


2022-09-03
[18:18:56.0824] <bakkot>
so an `instanceof` check, you mean? that doesn't seem that useful; you can do that yourself

[22:05:49.0750] <ljharb>
no, not an instanceof check, those are forgeable and don't work across realms. a brand check.

[09:00:22.0548] <bakkot>
ljharb: what brand do you imagine checking? there are a bunch of different built-in iterators in the language and the web platform, and they don't have a common brand

[09:00:46.0177] <bakkot>
the whole point of iterator being an interface is that the interface is implemented by a bunch of different classes, including userland classes

[09:02:50.0840] <littledan>
IMO the appropriate level for a brand check here would be to revert the whole Symbol.toStringTag change in the first place... what a bad idea of a feature. Not clear if it makes sense to "chip away at it" as much as I'm sympathetic with the idea to try.

[09:06:01.0455] <littledan>
it's not unthinkable to add a brand just for this purpose in https://tc39.es/proposal-iterator-helpers/#sec-iterator but I don't see the point

[09:06:41.0126] <littledan>
(do we want to start telling people, they shouldn't be pasting iterator helpers onto a base class by messing with a prototype chain? that seems like a useful mode to me)

[09:07:01.0926] <littledan>
 * (do we want to start telling people, they shouldn't be pasting iterator helpers onto a base class by messing with a prototype chain? that seems like a useful mode to me)


2022-09-04
[18:42:16.0345] <ljharb>
they do have a common brand now, itâ€™s what Iterator.from provides

[18:42:40.0929] <ljharb>
and a userland class will be wrapped by a branded object.

[08:36:39.0724] <bakkot>
Iterator.from checks `instanceof Iterator` and returns the original object if that returns true

[08:36:52.0231] <bakkot>
so no, it does not provide a common brand

[08:37:01.0436] <bakkot>
 * so no, it does not provide a common brand

[10:33:56.0875] <snek>
without first class protocols the only ways to check if something is an actual iterator is either rely on the prototype or exhaustively interrogate its methods 

[10:34:20.0633] <snek>
* without first class protocols the only ways to check if something is an actual iterator is either rely on the prototype or exhaustively interrogate its methods 

[11:17:16.0208] <rbuckton>
This is one reason why I'm still wary of using Iterator rather than an Iterable. 


2022-09-05
[18:13:02.0539] <ljharb>
i didnâ€™t realize that. It shouldnâ€™t use instanceof - like everything else in the language, it should use a brand.

[18:17:51.0847] <bakkot>
no, it's an interface

[18:17:54.0377] <bakkot>
it's not a class

[18:17:58.0963] <bakkot>
I mean, it is also a class

[18:18:30.0356] <bakkot>
but there is no particular reason a userland instance needs to have the brand

[19:14:15.0471] <snek>
> <@ljharb:matrix.org> i didnâ€™t realize that. It shouldnâ€™t use instanceof - like everything else in the language, it should use a brand.

how do you brand something whose definition is "has a next method that returns { value, done }"

[19:15:56.0312] <snek>
or if you subscribe to the other idea, "an object inheriting Iterator.prototype"

[20:35:23.0409] <ljharb>
objects in the language that inherit from a prototype also have a brand, thats checked in places. 

[20:38:35.0852] <snek>
no i like

[20:38:42.0553] <snek>
i do not understand the mechanic by which this would work

[10:17:26.0579] <ljharb>
anything that's `instanceof Iterator` in the language would have an internal slot, which is what Iterator.from would check

[10:28:14.0641] <bakkot>
in the language or, presumably, the web platform?

[10:28:28.0850] <bakkot>
I suppose that would be possible but... why?

[11:22:09.0722] <snek>
> <@ljharb:matrix.org> anything that's `instanceof Iterator` in the language would have an internal slot, which is what Iterator.from would check

how do they get the internal slot? they're just random objects

[11:23:40.0028] <snek>
oh are you saying Iterator.from would be the thing that produces objects with that slot

[11:25:30.0272] <snek>
technically the new object it returns has `[[Iterated]]`

[11:25:31.0130] <snek>
but

[11:25:37.0717] <snek>
it doesn't have to return the new object

[11:26:10.0577] <snek>
like if i run `Iterator.from({ next() {}, __proto__: Iterator.prototype })`, it should return that argument unchanged

[12:26:30.0104] <ljharb>
that doesnâ€™t seem like what it should be doing at all.

[12:27:17.0394] <ljharb>
Array.from doesnt pass through return an arraylike object that has a proto of Array.prototype - it returns a proper array. So should Iterator.from.

[12:28:31.0086] <bakkot>
the definition of "proper iterator" _is_ "inherits from Iterator.prototype", in this context

[12:44:30.0140] <ljharb>
i don't think that is or should be the definition

[13:00:34.0611] <bakkot>
why?

[14:08:11.0778] <snek>
Iterator is not a concrete thing, I'd rather rename the method if that's the problem

[14:15:40.0372] <ljharb>
the whole point of Iterator.from is that it's becoming a concrete thing

[14:15:49.0067] <snek>
no its just that its giving it the prototype

[14:16:05.0528] <snek>
its a convenience for the methods

[14:16:47.0742] <ljharb>
â€¦ and the methods do a wrap (to something with the slot) if they're `.call`ed on a random object?

[14:17:33.0567] <snek>
i don't understand what this means

[14:17:41.0235] <ljharb>
the `[[Iterated]]` slot you mentioned

[14:18:21.0801] <snek>
`[[Iterated]]` is just used for %WrapForValidIteratorPrototype%.next/return

[14:18:33.0754] <ljharb>
how can the next method retain internal state unless it has a place to put it?

[14:19:11.0869] <snek>
WrapForValidIteratorPrototype objects don't have any internal state

[14:19:24.0161] <snek>
[[Iterated]] is just the object they wrap

[14:19:41.0461] <snek>
well, the iterator record for it

[14:20:57.0151] <ljharb>
ok so like `map`. it has to hold on to the original iterator, and to the callback

[14:21:15.0595] <ljharb>
so presumably the iterator object returned by `map` holds that, in an internal slot

[14:21:53.0713] <snek>
they use closures

[14:22:27.0105] <ljharb>
so the iterator object doesn't use a shared `next` method, it makes a new one each time `map` is called?

[14:22:39.0264] <snek>
uhh

[14:22:43.0674] <snek>
it uses %IteratorHelperPrototype%.next

[14:22:47.0801] <snek>
 * it uses %IteratorHelperPrototype%.next

[14:22:48.0948] <ljharb>
right. but that's a shared method.

[14:22:55.0382] <snek>
which is just %GeneratorPrototype%.next but fancy

[14:22:56.0847] <ljharb>
so it can't close over something that's unique to a given `map` call

[14:23:10.0849] <ljharb>
because it exists before `map` is ever called.

[14:23:11.0878] <snek>
 * which is just %GeneratorPrototype%.next but fancy

[14:23:24.0823] <ljharb>
so where is that state held so that `next` can access it?

[14:23:39.0873] <snek>
same place that normal generators store it

[14:23:50.0121] <snek>
the only thing is

[14:24:06.0149] <snek>
you can grep for `[[GeneratorBrand]]` in the spec

[14:24:06.0150] <ljharb>
right but that's in a slot on the generator instance, no?

[14:24:13.0324] <snek>
https://tc39.es/ecma262/#sec-generatorvalidate

[14:24:19.0829] <snek>
this is the only way it tells them apart

[14:24:28.0839] <snek>
but that just tells you if it was a generator helper method

[14:24:42.0969] <snek>
tbh i'm not sure why we separate them at all, they just call `GeneratorResume`

