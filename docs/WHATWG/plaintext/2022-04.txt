2022-04-01
[23:32:28.0182] <annevk>
It's not useful to know that it can only throw due to OOM? Is there anything else?

[08:46:36.0334] <Domenic>
Stack overflow IIRC was a big thing for our implementation

[09:55:29.0747] <mgaudet>
annevk: I'm not sure. Certainly for reading the specification, and trying to hold it together as a concept I think it's helpful. As an implementer, I'm less sure of the value (could be wrong, would welcome other opinion). 

[09:55:30.0931] <mgaudet>
I know I definitely came into some of this with an incorrect assumption that OOM handling was something done on the web in complicated code bases-- that seems to not actually be the case though?

[09:56:32.0326] <mgaudet>
(The concern I had/have is broken streams that originate from states 'impossible' in the specification, generated by things like OOM, or stack overflow) 

[13:21:31.0325] <Jesper van den Ende>
Hey, I noticed setting Node.parentElement works in all browsers. But the spec says it is readonly, doesn't that mean setting it should throw. Or am I missing something?

[13:24:06.0541] <evilpie>
How could I get someone else interested in https://github.com/whatwg/html/issues/3255  ?

[13:31:41.0751] <Jesper van den Ende>
> <@jespertheend:matrix.org> Hey, I noticed setting Node.parentElement works in all browsers. But the spec says it is readonly, doesn't that mean setting it should throw. Or am I missing something?

ah never mind, I was trying this in the inspector console, which doesn't use `"use strict"` I guess


2022-04-02
[08:37:20.0920] <annevk>
mgaudet: I think only for ArrayBuffer allocation is OOM defined; some have the ambition to define it more exhaustively, but I haven't seen progress on that for many years


2022-04-03
[15:19:56.0300] <Domenic>
> <@evilpie:mozilla.org> How could I get someone else interested in https://github.com/whatwg/html/issues/3255  ?

I will ping the relevant internal team chat, and make frowny faces at them for not responding earlier :(


2022-04-04
[07:42:06.0079] <evilpie>
> <@domenicdenicola:matrix.org> I will ping the relevant internal team chat, and make frowny faces at them for not responding earlier :(

Thank you!

[14:13:23.0296] <smaug>
hober: by any chance, do you happen to know examples of "we found several examples of web pages that had incorrect behavior when requestAnimationFrame() callbacks were fired at a non-60Hz frequency." mentioned in https://github.com/WebKit/explainers/tree/main/animation-frame-rate ?

[14:14:13.0115] <hober>
> <@smaug:mozilla.org> hober: by any chance, do you happen to know examples of "we found several examples of web pages that had incorrect behavior when requestAnimationFrame() callbacks were fired at a non-60Hz frequency." mentioned in https://github.com/WebKit/explainers/tree/main/animation-frame-rate ?

I'll ask!

[14:14:21.0458] <smaug>
thanks!

[16:20:22.0927] <c8fdy5dbkp>
smaug: 


2022-04-05
[14:49:27.0838] <vrafaeli>
Anyone can explain the difference between embed and iframe tags? (any reason to ever use embed instead of iframe in modern browsers)

[14:49:46.0333] <vrafaeli>
 * Anyone can explain the difference between embed and iframe tags? (any reason to ever use embed instead of iframe)

[14:50:07.0196] <vrafaeli>
 * Anyone can explain the difference between embed and iframe tags? (any reason to ever use embed instead of iframe in modern browsers)

[14:51:15.0749] <Andreu Botella>
come to think about it, maybe embed and object could be moved to the obsolete features section

[14:52:18.0944] <vrafaeli>
btw nice to see you Andreu. I think we chatted a bit before on IRC


2022-04-06
[23:35:57.0122] <annevk>
Yeah, the plan is to obsolete `embed`/`object`. `object` in particular has some capabilities that are unique to it still, but we're chipping away at those.

[01:02:51.0320] <annevk>
GitHub's "smart URL paste" continues to trip me up, I keep forgetting it's there and ending up with a result I don't want

[01:03:18.0944] <annevk>
And I kinda worry that if I learn it I'll expect it in other places and run into trouble there

[02:23:57.0117] <freddy>
I'm looking for something that resets a whole document, including expando attributes etc. - I suppose I could emulate this by serializing+parsing the whole document or by cloning it. But, ideally, I'm looking for existing patterns for this "reset" or at least individual puzzle pieces. It seems to me that even the puzzle piece that removes "all" event handlers from an element seems to be a "no" already :/

[04:54:03.0550] <annevk>
freddy: "document open steps" does a bunch of that

[04:55:20.0364] <freddy>
I _did_ see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#opening-the-input-stream, but it "replace the document with a new object" sounded to me as if the corresponding element-tree would be gone?!

[04:56:03.0246] <freddy>
OK, I realize I only read the non-normative stuff (I feel bad now)

[04:56:08.0438] <freddy>
 * OK, I realize I only read the non-normative stuff (I feel bad now)

[04:57:36.0122] <annevk>
freddy: it definitely doesn't do sanitization though; for sanitize() I'm still curious what the actual envisioned usage patterns are

[04:58:13.0194] <annevk>
But we do have primitives such as "remove all listeners" in the platform, but they're not widely available

[04:59:41.0350] <freddy>
Yeah, so the thing is that there's an apparent lack of "inside knowledge" from the sanitizer folks (freddy, otherdaniel, koto) about the potential state that could be attached to the document. The lack of knowledge lead to a security-conservative "we want it all gone" design goal. Similar to the other security-conservative choices we made (can't just a string-to-string API and hope for the best, can't parse a string with implicit/wrong context element, etc.).

[05:00:17.0222] <freddy>
So, one ideas is that I'm trying to find out if there's an algorithm that would a) shine some light on the apparent lack of details and b) alleviate the concerns by being an existing thing.

[05:00:54.0823] <annevk>
Again though, what's the actual input here? If you start with a tree, don't you have to trust that tree already?

[05:01:08.0909] <freddy>
On the other hand, I know that all other sanitizer libraries traverse a DOM tree based on the input (or parse it based on the input) and not even re-use those elements but create completely new ones and copy the bits over selectively. Which is a bit like a clone, but more... iterative

[05:01:56.0050] <freddy>
No. You don't. E.g., `<iframe sandbox="allow-same-origin" src="bad stuff>` contains attacker-controlled stuff and you want to "promote" it into the current document, but need it to be sanitized first

[05:02:13.0997] <freddy>
so `sanitize(iframe.contentDocument)`

[05:03:50.0083] <freddy>
OK, admittedly a `sandbox`ed iframe wouldn't have event listeners (because it doesnt script). But maybe your privilege-separation mechanism is `<iframe sandbox="allow-script" src="some-sandbox-domain-for-user-content">` (google, github, mdn, bugzilla use those sandbox-domains _A LOT_). And if you'd want to promote that into a current document you wouldn't iframe it, but instead `XHR()` it and sanitize the returned `document`

[05:04:03.0954] <freddy>
 * OK, admittedly a `sandbox`ed iframe wouldn't have event listeners (because it doesnt script). But maybe your privilege-separation mechanism is `<iframe sandbox="allow-script" src="some-sandbox-domain-for-user-content">` (google, github, mdn, bugzilla use those sandbox-domains _A LOT_). And if you'd want to promote that into a current document you wouldn't iframe it, but instead `XHR()` it and sanitize the returned `document`

[09:13:31.0461] <vrafaeli>
Let me explain one thing that I'm concerned now. Imagine the following scenario.
You list through several PDFs, and in-between (when the loading happens for example) you don't want to show the document.

But I guess we don't want the iframe/embed/object to be removed from the DOM and then added again, cause that might cause performance penalty?
We can hide this HTML element using CSS I guess which is probably optimal.
One of the alternatives is to put "about:blank" in the "src" attribute. But then "iframe" will lose the type information.
So I'm concerned that in this alternative the browser's PDF engine will get "remounted" which might cause performance penalty?

(this is perhaps browser specific thing, but I'd appreciate your thoughts on this)

[09:14:11.0833] <vrafaeli>
> <@annevk:mozilla.org> Yeah, the plan is to obsolete `embed`/`object`. `object` in particular has some capabilities that are unique to it still, but we're chipping away at those.

 * Let me explain one thing that I'm concerned now. Imagine the following scenario.
You list through several PDFs, and in-between (when the loading happens for example) you don't want to show the document.

But I guess we don't want the iframe/embed/object to be removed from the DOM and then added again, cause that might cause performance penalty?
We can hide this HTML element using CSS I guess which is probably optimal.
One of the alternatives is to put "about:blank" in the "src" attribute. But then "iframe" will lose the type information.
So I'm concerned that in this alternative the browsers PDF engine will do the "remount" which might cause performance penalty?

(this is perhaps browser specific thing, but I'd appreciate your thoughts on this)

[09:14:40.0987] <vrafaeli>
 * Let me explain one thing that I'm concerned now. Imagine the following scenario.
You list through several PDFs, and in-between (when the loading happens for example) you don't want to show the document.

But I guess we don't want the iframe/embed/object to be removed from the DOM and then added again, cause that might cause performance penalty?
We can hide this HTML element using CSS I guess which is probably optimal.
One of the alternatives is to put "about:blank" in the "src" attribute. But then "iframe" will lose the type information.
So I'm concerned that in this alternative the browser's PDF engine will do the "remount" which might cause performance penalty?

(this is perhaps browser specific thing, but I'd appreciate your thoughts on this)

[09:14:55.0456] <vrafaeli>
 * Let me explain one thing that I'm concerned now. Imagine the following scenario.
You list through several PDFs, and in-between (when the loading happens for example) you don't want to show the document.

But I guess we don't want the iframe/embed/object to be removed from the DOM and then added again, cause that might cause performance penalty?
We can hide this HTML element using CSS I guess which is probably optimal.
One of the alternatives is to put "about:blank" in the "src" attribute. But then "iframe" will lose the type information.
So I'm concerned that in this alternative the browser's PDF engine will get "remounted" which might cause performance penalty?

(this is perhaps browser specific thing, but I'd appreciate your thoughts on this)

