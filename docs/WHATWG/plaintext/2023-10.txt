2023-10-01
[06:46:57.0034] <Alexander Kalenik>
hi, any chance anybody could point me at the place in navigation specification where document's url need to be updated when same-document navigation happens (for example https://html.spec.whatwg.org/multipage/browsing-the-web.html#navigate-fragid)?

[08:22:46.0187] <Alexander Kalenik>
it's actually seems like a spec bug because by the time popstate/hashchange event is fired on step 13 (update document for history step application) document's url should be updated but non of previous steps does that.

[08:48:16.0103] <Domenic>
https://html.spec.whatwg.org/multipage/browsing-the-web.html#url-and-history-update-steps step 8 does it for popstate/hashchange/navigation API intercept

[08:48:33.0621] <Domenic>
Did we somehow mess it up for fragment navigation?

[08:52:47.0019] <Domenic>
Please file an issue


2023-10-02
[00:00:50.0505] <annevk>
TabAtkins: not sure if this is a problem, but when I updated WHATWG's bikeshed boilerplate for a change in new issue URLs, it was picked up automatically without me having to generate the manifest

[00:01:23.0037] <annevk>
TabAtkins: I have now updated the manifest as well, but that makes it seem redundant

[01:50:55.0658] <Noam Rosenthal>
Domenic: added https://github.com/whatwg/html/issues/9824 to track the event loop spec vs. impl differences. hoping to tackle it gradually

[01:53:18.0743] <Noam Rosenthal>
smaug: I think I said something misleading about `fetchLater` when we spoke about it a few days ago. It *is* reliable in the "renderer process is killed" scenario, as the whole logic is spec'ed to work in the network process (inside fetch, in spec terms). It's actually a main feature of `fetchLater` as opposed to sending beacons in `pagehide`.

[01:54:43.0388] <smaug>
ok, so whatever is representing a "network process" in each browser

[01:55:38.0886] <smaug>
OS can still kill those processes on mobile, no?

[01:59:26.0473] <Noam Rosenthal>
smaug: yes, but that's equivalent to killing the whole browser in a way.

[02:01:09.0518] <Noam Rosenthal>
our recommendation (it's also in the spec) is that if there are indication that the browser itself is about to lose execution rights or be killed (e.g. backgrounded on iOS) then flush those ASAP

[02:01:41.0780] <smaug>
depends on the browser.  But yes. And the point is still that we are replacing one unreliable API with another one. The new one is likely less unreliable.

[02:03:34.0746] <Noam Rosenthal>
smaug: It's as reliable as calling `fetch`, which can also not happen if the network process gets killed

[02:03:35.0334] <smaug>
and browsers could have implemented also the old API in a more reliable way, but have chosen not to

[02:04:05.0761] <Noam Rosenthal>
they couldn't. because if the renderer process is killed, you wouldn't get JS execution and `pagehide`

[02:06:09.0623] <smaug>
I didn't say the old one would be as reliable. I said they could have implemented it in a more reliable way.

[02:06:50.0378] <Noam Rosenthal>
you'd need something like "you're about to lose execution rights or be killed, please fire this event"

[02:07:04.0896] <Noam Rosenthal>
That's not a feasible premise

[02:07:52.0093] <Noam Rosenthal>
I would say that `fetchLater(url)` is a practical alternative to something like firing `pagehide` as a kill signal... note that renderer processes that get killed might have already crashed or have a hanging main thread

[02:08:44.0558] <smaug>
I haven't said fetchLater is somehow bad API ðŸ™‚ 

[02:08:50.0643] <Noam Rosenthal>
if your renderer process crashed/hang, `fetchLater` would still work while I don't see how we could make `addEventListener('pagehide', () => fetch(...)` work

[02:09:01.0952] <smaug>
But we need to always think what extra complexity we want to add to the platform

[02:10:14.0574] <smaug>
per the proposal, implementation could handle fetchLater asap a page is being unloaded or moved to bfcache, right?

[02:10:41.0319] <Noam Rosenthal>
yes

[02:10:57.0478] <Noam Rosenthal>
we try to leave a lot of room for simpler implementations

[02:22:39.0023] <smaug>
What about the page becoming a background page, I mean user switches tab (or whatever similar concepts mobile has)? Ah, looks like activationTimeout is just a hint

[02:23:08.0206] <smaug>
So UA could trigger fetchLater fetches immediately also in that case

[02:23:14.0437] <Noam Rosenthal>
smaug: yes, it's "please fetch this, no later than `activationTimeout` if posslbe"

[02:24:13.0175] <smaug>
I wonder if that property should have "hint" in its name, or perhaps deadline or some such, just to give the impression that it isn't by no means accurate 

[02:24:36.0787] <Noam Rosenthal>
I'm fine with calling it deadline

[02:30:13.0969] <Noam Rosenthal>
(by "fine with" I mean I agree that it tells a more accurate story)

[02:32:56.0411] <smaug>
Noam Rosenthal: so there is no way to track which fetches have been processed?

[02:35:45.0097] <Noam Rosenthal>
smaug: sure, the return value of `fetchLater` has an `activated` boolean

[02:36:08.0309] <smaug>
how does that tell it?

[02:36:21.0127] <smaug>
oh, I see

[02:37:09.0557] <Noam Rosenthal>
yea when the fetch is activated the network process also posts a task on the document to flip the flag

[02:37:18.0327] <Noam Rosenthal>
... if the document is still around

[04:02:53.0331] <annevk>
Jeffrey Yasskin: thanks, that indeed seems to work well!

[04:32:54.0772] <canadahonk>
Was `MessageEvent.userActivation` ever added to the HTML spec, afaict only the navigator interface was? (ref https://github.com/whatwg/html/pull/8254)

[04:34:58.0128] <annevk>
canadahonk: I don't think it was, nor was that proposal ever finalized afaik

[04:36:29.0108] <canadahonk>
What would be needed to get it in the spec? (Chrome has been shipping since 2018)

[04:43:27.0609] <annevk>
canadahonk: a specification with a design that has agreement?

[04:44:03.0818] <annevk>
canadahonk: I haven't looked at this recently, but I believe this feature has a repository with a number of outstanding issues

[04:44:19.0912] <canadahonk>
Yeah https://github.com/dtapuska/useractivation

