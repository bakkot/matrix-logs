2023-02-01
[00:32:19.0257] <sideshowbarker>
https://twitter.com/Hixie/status/1620694008405331968

[00:32:39.0205] <sideshowbarker>
https://docs.google.com/document/d/1peUSMsvFGvqD5yKh3GprskLC3KVdAlLGOsK6gFoEOD0/edit?resourcekey=0-bPajpoo9IBZpG__-uCBE6w#

[00:46:02.0914] <sideshowbarker>
https://twitter.com/Hixie/status/1620704532748701697

[00:51:26.0327] <sideshowbarker>
maybe we could call it “The Second System”…

[00:52:15.0697] <sideshowbarker>
or if we’re really optimizing for irony, “Web4”

[00:53:25.0437] <sideshowbarker>
or else just skip to “Web5” (and also create some entertaining narrative for why we skipped past “Web4”)

[00:56:23.0383] <sideshowbarker>
anyway, this rightly seems like something we should have seriously started working on already — and I’ve not heard any sound objections to it other than some assertions that the performance benefits wouldn’t be significant enough to merit the spec work and implementation work required

[00:57:12.0544] <sideshowbarker>
but as Hixie says in one of his tweets, _“The goal is simplicity and developer ergonomics, more than performance”_

[00:57:49.0001] <sideshowbarker>
 * anyway, this rightly seems like something we should have seriously started working on already — and I’ve not heard any sound objections to it other than some assertions that the performance benefits wouldn’t be significant enough to merit the spec work and implementation work required

[03:53:34.0758] <sideshowbarker>
WABI

[05:57:52.0023] <Domenic>
"applications could ship with their own implementations of high-level concepts like layout, widgets, and gestures" seems like an anti-goal to me.

[05:58:10.0698] <Domenic>
And not one any other successful platform has embraced

[06:39:44.0482] <sideshowbarker>
I think Flutter at least has already essentially embraced it, for their Web output — at least as an option.

See https://docs.flutter.dev/development/platform-integration/web/renderers — the CanvasKit renderer: https://skia.org/docs/user/modules/canvaskit/, which amounts to every app shipping with its own embedded layout engine (Skia)

[07:44:42.0424] <bkardell>
I feel like I have a lot of thoughts myself, but also - I kind of don't get at all how aria fits in that particular mix really

[08:12:01.0441] <bkardell>
well, I guess "at all" is an overstatement really

[08:14:18.0595] <bkardell>
but like - it feels like a lot of the industry was trying to go in a not totally dissimilar direction around 2004 before whatwg... like, lots of VMs with core and then a thing atop trying to add an application version of a markup maybe - flex/flash, java/jfx, silverlight/xaml ... no?

[11:12:47.0694] <timothygu>
Has anyone seen https://github.com/ada-url/ada?

[12:32:54.0273] <Ian Hickson>
> <@domenicdenicola:matrix.org> And not one any other successful platform has embraced

what about X11/Wayland?

[12:33:09.0759] <Ian Hickson>
and Android now, with Jetpack Compose

[12:33:27.0562] <Ian Hickson>
also, most gaming platforms

[12:34:32.0453] <Ian Hickson>
really the web is the _only_ platform where the bootstrap mode is so high-level that you're literally a document

[12:35:03.0635] <Ian Hickson>
even android, which bootstraps you into a java environment via the zygote doesn't start that high

[13:15:16.0649] <bkardell>
Ian Hickson: do you imagine any kind of document there? One geared toward apps? like that sort of thing almost existed  (did in a way in flex, xaml, xul, jfx) and they do kind of exist now - like QML is a thing, right?

[13:17:32.0921] <bkardell>
 * Ian Hickson: do you imagine any kind of document there? One geared toward apps? like that sort of thing almost existed  (did in a way in flex, xaml, xul, jfx) and they do kind of exist now - like QML is a thing, right?

[13:21:07.0899] <bkardell>
 * Ian Hickson: do you not imagine any kind of document there? One geared toward apps? like that sort of thing almost existed  (did in a way in flex, xaml, xul, jfx) and they do kind of exist now - like QML is a thing, right?

[13:39:06.0678] <Ian Hickson>
not sure i understand the question

[14:04:24.0672] <bkardell>
> <@hixie:matrix.org> not sure i understand the question

Yeah, I mean, I guess I kind of confused too, so probably not asking the question well enough... sorry :(. 

[14:22:53.0608] <bkardell>
so in your idea, things still have a URL I guess and the thing at the end of the URL is just.... straight to WASM, and that WASM you're suggesting would have some kind of (new) core libraries available to it based on WebGPU, WebHID and ARIA (the taxonomies, at least)... I guess it would probably need _some_ additional primitives there or I'm not sure how you apply them together? Am I understanding that at least generally or just way off what you are describing?

[14:23:35.0235] <bkardell>
(also, happy to take this to a different room if this is just silly for the main whatwg channel but you're still willing to answer potentially dumb questions)

[14:31:39.0870] <bkardell>
 * so in your idea, things still have a URL I guess and the thing at the end of the URL is just.... straight to WASM (but like, an archive? some descriptor?), and that WASM you're suggesting would have some kind of (new) core libraries available to it based on WebGPU, WebHID and ARIA (the taxonomies, at least)... I guess it would probably need _some_ additional primitives there or I'm not sure how you apply them together? Am I understanding that at least generally or just way off what you are describing?


2023-02-02
[16:50:49.0249] <sideshowbarker>
bkardell: yeah, every web app still has a URL, and the thing at the end of the URL is straight to WASM

That is, the thing at the end of the URL is a single binary, a single executable, completely just object code — a single `.wasm` file/resource

And so then for that app, all that the browser does is just to load that single binary into memory and execute it — execute it in the existing WebAssembly execution environment that all browsers already have.

And that’s all in contrast to what browsers need to do now with the current HTML/DOM+JS+CSS stack, which is: browsers must load three different things into memory: the must a DOM tree/object, a JavaScript global object, and CSS cascade/Stylesheet object — and then also keep those three in sync through all the DOM mutations and everything

[16:52:40.0951] <sideshowbarker>
With this WABI alternative, there’s no DOM at all, there’s no JavaScript global at all, there’s CSS Stylesheet at all

[16:53:19.0969] <sideshowbarker>
Instead, browsers load only the binary object code for the app, and just execute that

[16:55:26.0486] <sideshowbarker>
And the WABI binary is the equivalent of statically linked object code — that is, it has all of its dependencies already compiled in, and doesn’t need to link into anything else nor load anything else

[16:56:34.0611] <sideshowbarker>
So a WABI binary can contain its own layout engine, and its own complete runtime

[17:00:05.0119] <sideshowbarker>
As far as that goes, one analogy is how server-side Java apps can be built today — which is that you use `jlink` to compiles a singole binary that embeds a JVM runtime and all the Java libraries that the app depends on (and so, users don’t need to have a Java runtime installed on their systems to run that app, because the app itself contains the runtime)

[17:04:23.0402] <sideshowbarker>
But that analogy is not at all exact, because in that case the binary is an architecture-specific binary that can only run on a single platform — that is, a Windows binary, or a Linux binary, or a macOS binary.

But a WABI binary is not architecture-specific but instead is a portable binary in every way that WASM binaries already are

[17:08:58.0019] <sideshowbarker>
I think the loading code that’s currently required in browsers for HTML/DOM loading and JS loading and CSS loading may be the single most complex part of browsers implementations, and may be one of the most fragile parts — in the sense that it’s prone to regressions and to new bugs getting introduced that are hard to troubleshoot

[17:11:05.0727] <sideshowbarker>
And at least I can say from experience as patch contributor to Chrome, that loading code is just incredibly complicated and intimidating to try to work on. Chrome has an entire team that’s devoted to just that loading code.

[17:14:50.0374] <sideshowbarker>
And for web apps (as opposed to documents), all that loading code arguably should be unnecessary anyway — it’s just a side effect of having needed to bolt an application-execution environment on top of a model that’s not fundamentally designed for running apps but instead is just designed for laying out documents

[17:19:01.0842] <sideshowbarker>
So there is huge value alone in just being able to cut out the need for all that loading code, and all its complexity, and (over the long run) all its ongoing maintenance cost in implementations. (Because this is the web, implementations would also forever need to still retain all that code — to run all the content that exists on the web now — but over the long run, developers building web apps would mostly move to targeting WABI instead, and most web apps would be running in the WABI execution environment instead.)

[17:30:48.0367] <sideshowbarker>
 * bkardell: yeah, every web app still has a URL, and the thing at the end of the URL is straight to WASM

That is, the thing at the end of the URL is a single binary, a single executable, completely just object code — a single `.wasm` file/resource

And so then for that app, all that the browser does is just to load that single binary into memory and execute it — execute it in the existing WebAssembly execution environment that all browsers already have.

And that’s all in contrast to what browsers need to do now with the current HTML/DOM+JS+CSS stack, which is: browsers must load three different things into memory: they must a DOM tree/object, a JavaScript global object, and CSS cascade/Stylesheet object — and then also keep those three in sync through all the DOM mutations and everything

[17:31:24.0915] <sideshowbarker>
 * As far as that goes, one analogy is how server-side Java apps can be built today — which is that you use `jlink` to compile a singole binary that embeds a JVM runtime and all the Java libraries that the app depends on (and so, users don’t need to have a Java runtime installed on their systems to run that app, because the app itself contains the runtime)

[17:31:31.0624] <sideshowbarker>
 * As far as that goes, one analogy is how server-side Java apps can be built today — which is that you use `jlink` to compile a single binary that embeds a JVM runtime and all the Java libraries that the app depends on (and so, users don’t need to have a Java runtime installed on their systems to run that app, because the app itself contains the runtime)

[17:32:05.0030] <sideshowbarker>
 * I think the loading code that’s currently required in browsers for HTML/DOM loading and JS loading and CSS loading may be the single most complex part of browser implementations, and may be one of the most fragile parts — in the sense that it’s prone to regressions and to new bugs getting introduced that are hard to troubleshoot

[17:32:18.0981] <sideshowbarker>
 * And at least I can say from experience as a patch contributor to Chrome, that loading code is just incredibly complicated and intimidating to try to work on. Chrome has an entire team that’s devoted to just that loading code.

[17:33:04.0590] <sideshowbarker>
 * So there is huge value alone in just being able to cut out the need for all that loading code, and all its complexity, and (over the long run) all its ongoing maintenance cost in implementations. (Though, because this is the web, implementations would also forever need to still retain all that code — to run all the content that exists on the web now — but over the long run, developers building web apps would mostly move to targeting WABI instead, and most web apps would be running in the WABI execution environment instead.)

[01:55:04.0086] <Andreu Botella>
annevk: About `URLSearchParams` `has()` and `delete()`, do you think use counters would be helpful to see if they're called with extra arguments?

[04:54:59.0817] <jub0bs>
Posting here for more visibility: https://github.com/whatwg/fetch/issues/1601

[06:14:16.0289] <Domenic>
> <@sideshowbarker:matrix.org> So there is huge value alone in just being able to cut out the need for all that loading code, and all its complexity, and (over the long run) all its ongoing maintenance cost in implementations. (Though, because this is the web, implementations would also forever need to still retain all that code — to run all the content that exists on the web now — but over the long run, developers building web apps would mostly move to targeting WABI instead, and most web apps would be running in the WABI execution environment instead.)

I disagree. That code, or something equivalent, will still be needed---it will just be built by framework developers. And re-built, over and over and over, with the same mistakes repeated and missed and some of the frameworks good at using the a11y parts of the "ABI" and some bad and some doing a good job at meeting user expectations and some bad. For better or for worse, to build a successful UI framework you *need* a lot of code complexity---witness the thousands of people-years spent on them throughout history, from Win32 to WPF to Cocoa to Carbon to the web. Ones built by smaller teams, e.g. Flutter or the various Java or Linux GUI-framework-from-scratch attempts, tend to be painful for end users. GUI frameworks are just a hard problem; wishing you could start over and do it better this time is, IMO, not a good use of the tech industry's collective effort. The web works, and we even have escape hatches like wasm and WebGPU on top of it for cases like video games or CAD software or porting native apps to the web or whatever. But if you want a set of controls, loading primitives, etc., what we have is good and recreating it will not work well.

[06:15:09.0390] <Domenic>
(Try using a Flutter Web app and you'll see what I mean!)

[06:18:10.0872] <Domenic>
> <@timothygu:matrix.org> Has anyone seen https://github.com/ada-url/ada?

This is neat! Hadn't seen it before.

[06:21:11.0571] <sideshowbarker>
Domenic: I think mobile is the place where the current HTML/DOM+JS+CSS stack is not working well — as far as providing good user experiences for end users on mobile

[06:23:42.0696] <sideshowbarker>
I think it’s clear that we began to lose a huge segment of developer share around 2009 when the iPhone really took off and Android did too, and we were busy enough anyway, in the following years, with just trying to evolve the core web runtime in the necessary ways, with the features that were needed for good app experiences on the web to viable at all even on desktop

[06:24:07.0838] <sideshowbarker>
…and we have not won those developers back

[06:24:31.0223] <Domenic>
I think that problem is two-pronged. One, "document-like" web sites/apps are bad on mobile because of cookie banners/ads/etc. "App-like" mobile web apps are few and relatively hard to build well, but it also seems clear if the developer puts in enough effort they can get good results: see e.g. Twitter or Uber. For the rest, are developers not putting in enough effort, or is it too hard to put in enough effort because the web's UI framework is bad comparatively? I could see it being the latter. I doubt having everyone download a UI framework per web app, created by indie teams, would be a good solution though.

[06:25:04.0902] <sideshowbarker>
yes, the web's UI framework is bad comparatively

[06:25:09.0769] <Domenic>
Reasons developers might not put in the effort are mostly around: capabilities gap; lack of app store access. There's some really interesting UX research by Chrome folks about this

[06:25:39.0535] <Domenic>
E.g. teams which tried to build web apps but found when surveying users that the users found the web app *less* trustworthy than a native app---the web is where all the viruses come from, etc.

[06:26:02.0352] <Domenic>
(Or just, the competitors were on the app store, so users assumed something must be wrong with the web app if it couldn't make it through the app store process.)

[06:26:38.0772] <sideshowbarker>
I think the core reason currently starts from the reality that _users_ currently choose mobile apps because the user experience of those apps is relatively much better than they get from web apps


[06:27:51.0467] <sideshowbarker>
and developers choose to write native mobile apps because those mobile apps provide a better user experience for users, and are relatively dead simple to create using available SDKs and tooling

[06:28:18.0690] <sideshowbarker>
developers do not need to be stellar developers in order to create mobile apps that end users will actually use

[06:28:24.0601] <Domenic>
It's not clear there's any one core reason, such that if you fixed it we'd change things. I suspect it's a bunch of self-reinforcing reasons, which have trapped us in an inadequate equilibrium. E.g. if you could snap your fingers and fix the web's UI framework, the app store stickiness and capabilities gap remain. If you could fix the capabilities gap, the other two issues remain. And even if you could magically fix them all, the historical inertia remains. It's not great.

[06:28:46.0373] <sideshowbarker>
they can instead just develop mobile apps only, with much less trouble and pain

[06:29:49.0245] <sideshowbarker>
…and they forgo creating web apps because, in practice currently, their users prefer native mobile apps anyway

[06:31:49.0441] <sideshowbarker>
And I think the reason that SDK and authoring-tool vendors don’t consistently provide mechanisms for generating output for the web runtime with a great user experience is: in practice it’s still so incredibly hard and costly to implement and maintain the code needed to generate HTML/DOM+JS+CSS output that provides a great user experience on mobile

[06:31:55.0292] <Domenic>
It's a potential hypothesis that it's easier for a company to create two good native mobile apps than one good mobile web app. I'd give it somewhere around 50% odds. I don't think WABI is really related to that hypothesis; building a good web UI framework to make app development easier isn't something that framework developers have been unable to do because the browser doesn't have a native MIME type handler for application/wasm.

[06:32:11.0724] <Domenic>
 * It's a potential hypothesis that it's easier for a company to create two good native mobile apps than one good mobile web app. I'd give it somewhere around 50% odds. I don't think WABI is really related to that hypothesis; building a good web UI framework to make app development easier isn't something that framework developers have been unable to do because the browser doesn't have a native MIME type handler for application/wasm.

[06:32:16.0893] <sideshowbarker>
 * And I think the reason that SDK and authoring-tool vendors don’t consistently provide mechanisms for generating output for the web runtime with a great user experience is: in practice it’s still so incredibly hard and costly to implement and maintain the code needed to generate HTML/DOM+JS+CSS output that provides a great user experience on mobile

[06:32:53.0685] <sideshowbarker>
yes, I think the _“potential hypothesis that it's easier for a company to create two good native mobile apps than one good mobile web app”_ has proven to be true thus far

[06:33:01.0614] <sideshowbarker>
 * yes, I think the _“potential hypothesis that it's easier for a company to create two good native mobile apps than one good mobile web app”_ has proven to be true thus far

[06:33:07.0089] <bkardell>
> <@sideshowbarker:matrix.org> I think the core reason currently starts from the reality that _users_ currently choose mobile apps because the user experience of those apps is relatively much better than they get from web apps
> 

 that's really far too over simplified imo, there's so many factors here pushing users that way i don't think you can say users really chose tbh

[06:33:18.0884] <Domenic>
I think it would remain incredibly hard---in fact, probably be harder---if you chose to restrict yourself to WebGPU + ARIA + whatever when creating this hypothetical better-than-iOS-and-Android-SDKs web framework.

[06:35:03.0010] <bkardell>
I agree with Domenic on this ^

[06:35:43.0885] <sideshowbarker>
well part of the context around this is, we’ve been trying with the current stack since at least 2009 to create an ecosystem where better-than-iOS-and-Android-SDKs web frameworks can be developed and can flourish — but it has not happened

[06:35:49.0128] <Domenic>
(and the user experience will at the very least involve a long download time for first load, which is not a great start.)

[06:36:04.0737] <sideshowbarker>
> <@domenicdenicola:matrix.org> (and the user experience will at the very least involve a long download time for first load, which is not a great start.)

that’s very true yeah

[06:36:27.0138] <bkardell>
But also i feel like this aria part (much if it really) needs a little meat to be able to even discuss it. The "and aria" i feel like is handwaved but load bearing

[06:37:06.0231] <Domenic>
Again, I think it's really unclear whether iOS/Android SDKs are that much better. Remember that Flutter and SwiftUI are based on the React paradigm, which was pioneered on the web!

[06:38:39.0296] <Domenic>
My hypothesis is that the gap comes mainly in a good control library, and having stuck my foot in that area for a half-year and failed with a small team of Googlers, it comes back to my earlier point that you basically need major institutional buy-in (e.g. a large team working for 5-10 years) to get to the same level that Windows/macOS/Android/iOS have gotten to.

[06:39:17.0702] <Domenic>
Saying "you have WebGPU, raw HID events, and some ARIA thing---community, please build a good control library!" seems like a recipe for disaster to me.

[06:40:04.0620] <Domenic>
Flutter's tried for some number of years, don't know the size of their team, and the apps still feel quite unnatural to try to use on both Android and the web.

[06:40:22.0187] <sideshowbarker>
> <@domenicdenicola:matrix.org> My hypothesis is that the gap comes mainly in a good control library, and having stuck my foot in that area for a half-year and failed with a small team of Googlers, it comes back to my earlier point that you basically need major institutional buy-in (e.g. a large team working for 5-10 years) to get to the same level that Windows/macOS/Android/iOS have gotten to.

Yes — and the companies that are financially in the position to put that kind of investment in making it happen may not have great incentives for doing so

[06:43:40.0695] <sideshowbarker>
But part of what’s implicit in the design sketch as Hixie wrote it up is that the primitives would not all need to be implemented at once anyway

[06:44:37.0377] <sideshowbarker>
We could start with just the “ABI to spawn a JavaScript environment” piece

[06:44:45.0886] <Domenic>
The primitives are all already there; the only novel thing in Hixie's writeup is the new MIME type handler to remove the need for a one-line HTML document. (And, I guess, the magic world where we get Safari/Firefox to implement WebHID.)

[06:45:18.0940] <Domenic>
The document is basically "what if Flutter apps could save one line of code?"

[06:49:31.0254] <sideshowbarker>
my understanding of implementation costs could be naïve, but it seems to me there is in fact a non-insignificant real cost to currently needing the HTML and JS “glue code” for WASM apps to run, and to needing to parse and load that

[06:49:43.0866] <Domenic>
Cost to who?

[06:51:12.0129] <sideshowbarker>
I meant, cost to browser implementors relative to a new code path that didn’t require it

[06:52:08.0167] <Domenic>
Nah, no cost. If you have a JS escape hatch/bridge of the type Hixie's doc talks about, then the JS -> wasm step is free from that. And the HTML -> JS step has been implemented for ~20 years.

[06:52:44.0561] <sideshowbarker>
I see

[06:53:21.0308] <Domenic>
Building something that was straight wasm would be more costly, as you'd have to figure out what kind of document that produces (presuming you don't want it to just auto-generate <html><canvas></canvas></html> like .pdf generates <html><object></object></html>; I feel like the latter would violate the spirit of the thing)

[06:53:57.0849] <Domenic>
(And you need a "document" in at least some broad sense, so that you have some idea of what the back/forward button does, and what other windows see when they reach into yours.)

[06:56:55.0080] <sideshowbarker>
would it absolutely have to create a document at all? could it instead be done without even instantiating a document at all but instead having a new kind of object that the browser operates directly?

[06:57:03.0139] <sideshowbarker>
 * would it absolutely have to create a document at all? could it instead be done without even instantiating a document at all but instead having a new kind of object that the browser operates directly?

[06:57:20.0303] <sideshowbarker>
ah, I see you answered that already

[06:57:55.0218] <sideshowbarker>
so Hixie responded somewhat to that already, in his Twitter thread, I think

[06:58:03.0955] <sideshowbarker>
/me looks

[06:59:43.0639] <Domenic>
Yeah I mean it's conceivable you could invent something new, and have some sort of Document-like facade when other parts of the browser or other websites look at it, but it's unclear what the gain is; especially if the point was to reduce implementation complexity, I am quite sure that sort of thing would not reduce it.

[06:59:54.0099] <Matthew Phillips>
> <@domenicdenicola:matrix.org> Saying "you have WebGPU, raw HID events, and some ARIA thing---community, please build a good control library!" seems like a recipe for disaster to me.

very much agree here. 

[07:00:33.0600] <Noam Rosenthal>
it would very quickly be "you have WebGPU, raw HID events, some ARIA thing and flutter"...

[07:08:02.0722] <Matthew Phillips>
A more interesting question to me is not why developers aren't using the web as much for these app-like experiences, but why the web is not used even for document experiences. For example, why isn't the web the dominant way that readers read ebooks? Why isn't it the dominant way that publishers publish ebooks?

[07:08:52.0726] <Matthew Phillips>
Lack of integration with stores is part of it, but that can't be the only thing or public domain books would be read on the web, and I don't believe that they are.

[07:13:10.0492] <bkardell>
I agree it's useful to look at other stuff there too, but I also think anyone looking for a *the* technical why on any of these is trying to force simplcity where it doesn't exist like that in practice. There are tons of reasons and often they aren't even techinically good or necessarily logical.  

[07:17:13.0460] <Domenic>
The ebooks question is quite interesting as a smaller test case of the app question. I like that; I hadn't thought about it much before.

[07:18:28.0763] <Domenic>
Possible answers: the web is bad for commercial distribution; HTML subsetting allowing a wider tooling/device ecosystem; the technical lack of packaging format makes parts of the pipeline awkward

[07:21:22.0672] <bkardell>
Why people use 'native apps' is many things.  It's a combination of the fact that the app stores tell us we should and the app store is by the same people who make the OS, and sometimes the device too so as customers people say "seems legit".  It's the fact that sometimes people _like_ the app store... If you're looking for a thing you open over and over again it's very handy - you _think_ of it as an app and you don't want to search the web for that... You want maybe somewhere where you can see how many other people got it and read some reviews and comparisons -- a lot like why you would use a brick and mortar store... You have some sense that you can learn somethign about the quality. In practice I think that is mostly bunk - we need to do better than what we do, but yeah, same reason people like amazon reviews/purchase data, etc. You can't get that easily today with the web. But also then we built this whole movement where businesses which would do great with a PWA and who could build the great UX, etc still think they gotta build the native thing and use their site to push you to it, which again makes users think "oh, I guess that's better"... Basically that is a self-fulfilling prophecy even if all other things were equal (I think they aren't, but still)

[07:21:34.0225] <bkardell>
 * Why people use 'native apps' is many things.  It's a combination of the fact that the app stores tell us we should and the app store is by the same people who make the OS, and sometimes the device too so as customers people say "seems legit".  It's the fact that sometimes people _like_ the app store... If you're looking for a thing you open over and over again it's very handy - you _think_ of it as an app and you don't want to search the web for that... You want maybe somewhere where you can see how many other people got it and read some reviews and comparisons -- a lot like why you would use a brick and mortar store... You have some sense that you can learn somethign about the quality. In practice I think that is mostly bunk - we need to do better than what we do, but yeah, same reason people like amazon reviews/purchase data, etc. You can't get that easily today with the web. But also then we built this whole movement where businesses which would do great with a PWA and who could build the great UX, etc still think they gotta build the native thing and use their site to push you to it, which again makes users think "oh, I guess that's better"... Basically that is a self-fulfilling prophecy even if all other things were equal (I think they aren't, but still)

[07:21:35.0210] <Domenic>
Public domain books do exist on the web, e.g. Project Gutenberg, https://standardebooks.org/, things like the Rust book etc. But the online reading experience is not great for those in my experience. E.g. my bookmarks get lost among a sea of other bookmarks; reliance on scroll position instead of pagination

[07:22:44.0107] <Domenic>
(And of course, no Kindle integration)

[07:23:22.0326] <bkardell>
> <@domenicdenicola:matrix.org> Public domain books do exist on the web, e.g. Project Gutenberg, https://standardebooks.org/, things like the Rust book etc. But the online reading experience is not great for those in my experience. E.g. my bookmarks get lost among a sea of other bookmarks; reliance on scroll position instead of pagination

I think for a brief moment edge had a built in ebook reader

[07:26:38.0154] <bkardell>
ebooks are differently complex than apps in a way because standards have changed and moved venues and probably they tried to solve a lot of problems before we had critical things in place.  It would be really great to make that wonderful at last

[07:26:56.0803] <bkardell>
now they can at least all display math :)

[07:27:48.0870] <Domenic>
Can they, though. Publishers still tend to use pixelated pngs for math in the eBooks I've seen.

[07:28:25.0942] <Matthew Phillips>
now i kind of want to build some ebook web components.

[07:30:29.0045] <Matthew Phillips>
Building an ereader in HTML/JS shouldn't be that difficult, I can't think of any technical limitations that prevent it. I think things like Project Gutenberg don't have great web ereaders because not enough of their users use it, to make it worth their while

[07:30:31.0546] <bkardell>
> <@domenicdenicola:matrix.org> Can they, though. Publishers still tend to use pixelated pngs for math in the eBooks I've seen.

where do you read your eboooks?

[07:30:59.0519] <Domenic>
Kindle

[07:31:00.0163] <bkardell>
(can was referring to browsers can, sorry)

[07:31:08.0707] <bkardell>
kindle has their own rendering engine for that

[07:32:13.0859] <Domenic>
Yeah I meant it's more of a publisher pipeline thing, presumably

[07:32:21.0224] <bkardell>
yeah

[07:33:28.0092] <bkardell>
also another (I think) critical thing is the next gen rendering engine reworks in theory enable a lot of that stuff to actually be practical -- like pagination, etc... previously kind of very shoehorned, but we have good fragmentation design etc now

[07:33:54.0262] <bkardell>
so like, the web today would be a real nice basis IMO for all this

[07:36:24.0560] <bkardell>
 * so like, the web today would be a much nicer basis IMO for all this if we were coming at it fresh today

[08:37:55.0131] <bkardell>
"shouldn't be" means ideally or today?  The guttenberg thing is very chicken and egg. I have only read a few books digitally and all but one has been public domain.  I just like physical books 🤷 in fact, I like physical book _stores_ still, and libraries :) Even as a lover of the web, any kind of digital is still just not my ideal choice for most of my actual _book_ reading.

[08:38:00.0221] <bkardell>
> <@matthewcp:matrix.org> Building an ereader in HTML/JS shouldn't be that difficult, I can't think of any technical limitations that prevent it. I think things like Project Gutenberg don't have great web ereaders because not enough of their users use it, to make it worth their while

 * "shouldn't be" means ideally or today?  The guttenberg thing is very chicken and egg. I have only read a few books digitally and all but one has been public domain.  I just like physical books 🤷 in fact, I like physical book _stores_ still, and libraries :) Even as a lover of the web, any kind of digital is still just not my ideal choice for most of my actual _book_ reading.

[08:39:52.0291] <bkardell>
I think if you were solving this problem today you would probably not come up with .epub

[11:14:20.0911] <TabAtkins>
As an avid ebook user, I believe the ebook "issue" is almost entirely (1) payment/drm, and (2) pagination. For the latter, it just turns out that pagination is *usually* a bad UI pattern on the web and scrolling is better; books are one of the rare places where the opposite is true.

[11:15:28.0877] <TabAtkins>
Related: *good* book rendering involves some algorithms that have bad worst-case runtime complexity but are perfectly fine for rendering things like book pages.

[11:15:46.0563] <bkardell>
I will agree those are a very big part :)

[11:16:13.0242] <TabAtkins>
So once you're inventing pagination yourself, doing *the rest* of book rendering is actually quite simple and avoids most of the problems with replacing the web (no need for a bunch of input controls, complex layouts, etc)

[11:17:17.0188] <TabAtkins>
So the cost of doing it all natively, vs wrangling the web into doing it when you're trying to tweak things at a level below the primitives it naturally exposes, just leans pretty heavily towards native, and that's not unreasoanble.

[11:18:25.0323] <TabAtkins>
I'd certainly *like* good book rendering on the web, like we could just iframe an epub and it would Just Work, but it would be a pretty large effort with very questionable return on value.

[11:19:27.0875] <bkardell>
why would you need to iframe it?

[11:19:59.0714] <TabAtkins>
I mean, loading up a `http://example.com/book.epub` would work just as well, sure

[11:20:11.0371] <TabAtkins>
but assuming you were rendering a reader site around it

[11:20:21.0387] <bkardell>
right. I think that used to work in ms briefly

[11:21:15.0181] <bkardell>
maybe not well - idk I never used it... I just think I remember someone, maybe rossen showing me some talks

[11:30:03.0603] <Jake Archibald>
I'm always surprised that folks think UAs would produce an excellent epub reader, given how bad things like HTML date inputs were (and continue to be, depending on UA) for years

[11:46:29.0709] <bkardell>
kinda curious how those are related - I definitely think what Matthew Phillips is saying is that books are documents about text, you know the thing the web is supposed to be great at. Date pickers, are mostly used in stuff that is more of a stretch for that model

[12:02:21.0728] <TabAtkins>
Yeah, I'm not seeing the connection. Several browsers rendered some form controls in a relatively shitty manner (tho I've seen *worse* in userland; rarely, but still), but that doesn't seem to have any bearing on how everything else is rendered.

[14:19:38.0496] <Ian Hickson>
fwiw, i think the "but then you'd have a million frameworks all reinventing text editing" argument doesn't match reality. we've run the experiment. there aren't a million frameworks on android, there's a half dozen real ones and maybe a dozen more small ones. on the other hand the web has literally thousands and more pop up every year. they don't reinvent text editing, instead they reinvent other things, but they still exist, in a way that just doesn't happen on other platforms. i'm not sure i 100% understand why, but i think it's curious nonetheless.
also, "save flutter one line of code" is exactly what this proposal is, yes. i mean, it's more like "one stub file" than "one line of code", but it's basically the same thing. the idea is for the web to recognize it's in 2023 not 1991, so that when you boot a web app it doesn't have to first get you from real mode to protected mode and then from protected mode to long x64 mode (or rather, from 1991 CERN document mode to 1997 DOM mode to 2020 Wasm mode to 2023 WasmGC mode etc). everything this proposal suggests is already possible, the proposal is just to clean up the technical debt around it.

[14:22:29.0713] <Ian Hickson>
there's shades of the 2004 w3c apps & compound documents meeting in this, where mozilla and apple (and microsoft and sun!) were telling the w3c they can either get on the train or be left at the station, except this time the train is wasm&webgpu :-)

[14:43:54.0679] <bkardell>
> <@hixie:matrix.org> there's shades of the 2004 w3c apps & compound documents meeting in this, where mozilla and apple (and microsoft and sun!) were telling the w3c they can either get on the train or be left at the station, except this time the train is wasm&webgpu :-)

this is exactly what I was getting at/referencing above in https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$iRXTwv9IAQjoP_M8ri_OoA0RIJlMYqvDPXnausitzK4?via=matrix.org&via=mozilla.org&via=igalia.com

[15:06:24.0000] <bkardell>
we are saying completely different things about how it is related to 2004 I think though :)

[15:23:31.0599] <bkardell>
 * we are saying completely different things about how we interpreted its relationship to 2004 I think though :)

[15:26:13.0324] <Ian Hickson>
WPF would have been amazing, i'm still surprised microsoft didn't succeed at that

[15:26:35.0388] <Ian Hickson>
it only really lacked two things, a security model and vendor-neutrality

[15:27:00.0202] <Ian Hickson>
this is our opportunity to finally get there 20 years later though

[15:27:17.0099] <bkardell>
if you squint at your proposal the right way does it resemble flash a little?

[15:27:25.0937] <Ian Hickson>
it resembles flash a lot

[15:27:51.0782] <Ian Hickson>
flash was a huge boon for the web, with a few fatal flaws, the prime of which was again, lack of vendor-neutrality

[15:28:08.0513] <bkardell>
ok 😆 I was afraid to say that because I didn't want to insult you or something, but it is what I was saying too

[15:28:10.0764] <Ian Hickson>
it's kind of amazing that nothing ever really took its place

[15:28:20.0876] <Ian Hickson>
SVG i guess sort of did

[15:28:35.0895] <Ian Hickson>
but not like back then

[15:28:35.0952] <bkardell>
this thing called html 5 came along and told it to stop

[15:28:37.0366] <bkardell>
:)

[15:28:49.0839] <Ian Hickson>
well, html5 was sort of orthogonal to what flash did

[15:29:00.0423] <Ian Hickson>
html5 was more about stopping xforms

[15:29:23.0651] <bkardell>
that might have been the intent

[15:29:37.0218] <Ian Hickson>
i think apple had more of a hand in killing flash than html5

[15:29:47.0326] <bkardell>
but we also got canvas and animations and all kinds of things that made flash less necessary

[15:30:08.0398] <Ian Hickson>
somewhat. but those animations that flash made? we never really got them back.

[15:30:21.0584] <Ian Hickson>
youtube provides the non-interactive version i guess

[15:30:23.0731] <bkardell>
svg coming :)

[15:30:34.0111] <Ian Hickson>
if svg was going to do it, it would have done it already

[15:31:18.0535] <Ian Hickson>
anyway, i think wasm+webgpu is going to enable a whole category of things that we've been lacking every since flash and wpf died

[15:31:28.0699] <Ian Hickson>
(whether or not we do the thing i proposed)

[15:31:42.0916] <Ian Hickson>
we see it already in the kinds of apps people are making with flutter on web

[15:31:44.0552] <Ian Hickson>
like Rive

[15:31:58.0010] <bkardell>
youtube is interesting I was saying the other day how i wanted to write a post called Howard the Doc about this idea that how you think about what it is you're doing is hard and you always have to kind of squint at it. A doc is one model, but like, flash's was a movie.  Hypercards was a stack. 

[15:32:26.0022] <bkardell>
 * youtube is interesting I was saying the other day how i wanted to write a post called Howard the Doc about this idea that how you think about what it is you're doing is hard and you always have to kind of squint at it. A doc is one model, but like, flash's was a movie.  Hypercards was a stack. 

[15:33:16.0461] <bkardell>
none of those are apps, but what is an app?  When you look at the UI history the web and native clearly cross pollenate one another with ideas on how the model should be

[15:34:05.0362] <bkardell>
> <@hixie:matrix.org> like Rive

LInk?  I'm unfamiiliar it seems hard to google

[15:34:41.0986] <bkardell>
> <@hixie:matrix.org> anyway, i think wasm+webgpu is going to enable a whole category of things that we've been lacking every since flash and wpf died

what about webxr?  you see any relationship here?

[15:38:29.0772] <Ian Hickson>
rive.app, it's the first google result for "rive"

[15:38:46.0523] <Ian Hickson>
not familiar with webxr


2023-02-03
[17:00:28.0884] <bkardell>
Ah apparently i was searching with... Not Google 😊

[17:08:41.0670] <sideshowbarker>
for users and developers, we definitely have regressed from what could be done easily with Flash

[17:09:58.0741] <sideshowbarker>
…for that class of web content that was being produced with Flash — that timeline-based experience

[17:11:14.0539] <sideshowbarker>
which is admittedly only a subset, and different from a full “app” experience the way that mobile apps provide

[17:11:37.0281] <sideshowbarker>
but the web losing Flash was not a win for end users and developers

[17:12:33.0175] <sideshowbarker>
Flash enabled a lot of people to develop content without needing to be “coders” — the tooling made it easy for them to create content

[17:13:16.0617] <sideshowbarker>
and they did it on scale, and users on scale liked the experience it provided

[17:16:04.0567] <sideshowbarker>
And it had ubiquity all the way up until the first iPhone came out — on which even Safari was just barely even usable running on the iPhone on its own. And so it just literally wasn’t feasible to have the Flash runtime also running on top of the browser runtime in Safari on the first iPhones

[17:16:30.0764] <sideshowbarker>
And so Flash lost the key property of ubiquity it’d had until then

[17:17:02.0168] <sideshowbarker>
 * And it had ubiquity all the way up until the first iPhone came out — on which even Safari was just barely even usable running on the iPhone on its own. And so it just literally wasn’t feasible to have the Flash runtime also running on top of the browser runtime in Safari on the first iPhones

[17:55:13.0219] <sideshowbarker>
I’ve been thinking back to 2004–2005 when Flickr and other such sites first launched, and I was still working at Openwave and we had a mobile browser

[17:55:33.0768] <sideshowbarker>
 * I’ve been thinking back to 2004–2005 when Flickr and other such sites first launched, and I was still working at Openwave and we had a mobile browser

[17:57:36.0929] <sideshowbarker>
once I learned that XHR was what those sites were using to make the user experience they gave, I remember talking with people on the browser team and saying to them, Well, clearly now we really need to enable XHR in our browser

[17:58:08.0558] <sideshowbarker>
But there response at the time was, No, we really don’t, because what we have now is working

[17:59:49.0663] <sideshowbarker>
And they were provably right when they said that, because our browser (EZWeb browser) was shipping preinstalled on literally millions of browsers in Japan, and that browser was solving problems for literally millions of people in Japan who were using it every day to do all kinds of things

[18:00:22.0970] <sideshowbarker>
And we were making great money from it all

[18:00:48.0199] <sideshowbarker>
But my feeling was still, we can do better than this

[18:02:53.0779] <sideshowbarker>
The browser was well designed, and worked with content written in XHTML and CSS, not just WML — and it even had scripting. But it wasn’t JavaScript — it was WMLScript instead

[18:06:03.0146] <sideshowbarker>
And I remember people from the browser team patiently telling me that, with just our current stack, we could actually enable developers to create richer user experiences of the kind that were coming out in sites then, in 2004 and 2005 — that it in part, just needed developers to start doing some things differently and better (and providers buying more of our server products)

[18:07:46.0718] <sideshowbarker>
And then into our market came the full Opera browser shipping preinstalled on just one phone, labeled as “PC Site Viewer” — and users in Japan could then, on their mobile phones, access real full web content, from real web sites

[18:09:08.0339] <sideshowbarker>
with some XHR support in the browser

[18:09:55.0336] <sideshowbarker>
but for us at Openwave, enabling XHR meant adding support to JavaScript, switching from WMLScript to JavaScript

[18:12:04.0201] <sideshowbarker>
but the company just did not at all have the economic incentives to invest in doing that — we already had the customers shipping our browser on millions of devices, we had a huge number of developers creating content that worked well in it already, and we had millions of users already using it

[18:13:07.0350] <sideshowbarker>
and the browser PMs and engineers just saw no good strong need for it

[18:13:47.0305] <sideshowbarker>
…and that’s when I left and went to work at Opera

[18:16:41.0700] <sideshowbarker>
among the great things at Opera was that among the engineering team and QA team the default attitude really was “we can do better than this”, and they were wiling to try out some risky, nutty, unproven ideas — and the company management then really supported that (all the way up to Jon von Tetzchner and Haakon, especially)

[18:20:30.0342] <sideshowbarker>
 * but for us at Openwave, enabling XHR meant adding support for JavaScript to the browser, switching from WMLScript to JavaScript

[10:30:28.0205] <wanderview>
Is there a canonical way to go from a Navigator to the environment settings object that contains it?

[10:44:18.0065] <wanderview>
I guess I want relevant settings object

[10:59:37.0671] <Matthew Phillips>
> <@tabatkins:matrix.org> So the cost of doing it all natively, vs wrangling the web into doing it when you're trying to tweak things at a level below the primitives it naturally exposes, just leans pretty heavily towards native, and that's not unreasoanble.

I don't think I understand this point. Are you saying that not having built in pagination elements / primitives / whatever is enough of a reason to go native? Not debating just trying to understand the point.

[11:00:28.0550] <TabAtkins>
I'm saying that the cost of reproducing those, compared with the cost of losing the rest of the web platform, tilts the economics pretty decently toward "do it yourself in native code"

[11:00:45.0871] <TabAtkins>
You just don't need much of the web platform in an ereader

[11:01:14.0461] <TabAtkins>
But you do need pagination and better text layout, which the web platform doesn't provide and doesn't give you the primitives to reasonably do yourself.

[11:01:36.0809] <Matthew Phillips>
No, but building a full ereader from scratch in native is more complicated than building a pagination widget in JS, no?

[11:01:51.0517] <Matthew Phillips>
 * No, but building a full ereader from scratch in native is more complicated than building a pagination widget, no?

[11:02:05.0395] <Matthew Phillips>
 * No, but building a full ereader from scratch in native is more complicated than building a pagination widget in JS, no?

[11:02:27.0449] <TabAtkins>
That one bit, yes. There's more that you end up needing to reinvent.

[11:03:10.0217] <TabAtkins>
Other things I mentioned above: drm (and its precursor, dependable local storage)

[11:04:35.0588] <Matthew Phillips>
Ok, so things that are possibly fixable.

[11:04:52.0646] <TabAtkins>
Everything's potentially fixable, yeah

[11:05:26.0006] <Matthew Phillips>
But small things in comparison to the "reinvent the web on wasm" idea :)

[11:05:34.0077] <TabAtkins>
It's just that several of them aren't high-prio (or even perhaps medium prio) for web content as it exists today, so making the argument for working on it (specs and impls) isn't easy.

[11:05:55.0334] <TabAtkins>
Different people are reinventing the stuff in that case, with different incentives. ^_^

[11:08:18.0316] <Matthew Phillips>
The upside here is potentially huge though. Inventing an ereader in native is a lot of work. So much so that only a few companies have ever even tried.

The web is close here. And the upside would be that publishers could avoid the Amazon tax.

[11:09:33.0459] <Matthew Phillips>
So what is it about payment? Is it just the friction (which presumably web payments removes) or is it something else?

[11:10:07.0478] <TabAtkins>
Payment's gotten a lot better in the last few years! It was still pretty bad even five years ago.

[11:10:41.0019] <TabAtkins>
Tho the app stores getting more aggressive with their cuts make the friction argument less and less relevant to the bottom line.

[11:11:23.0191] <TabAtkins>
Like, the Nook app on Android no longer lets you buy books in it (because they'd have to give 30% of the price to Google). All you can do is wishlist, then they'll link you to the b&n website to actually buy it.

[11:11:57.0571] <Matthew Phillips>
Does Google take the same cut from web payments?

[11:13:00.0532] <TabAtkins>
Surely not; the CC processers would scream bloody murder and they're a powerful mafia.

[11:13:14.0145] <TabAtkins>
But I don't know the details.

[11:13:15.0171] <Matthew Phillips>
Comixology (Amazon company) had to do the same thing in their Android app. It makes the experience really bad. Feels like an opportunity for the web.

[11:14:23.0734] <Matthew Phillips>
ok, that makes sense, i was thinking that web payments had the same UI overlay as native but that doesn't mean that google is taking a cut

[11:20:29.0574] <Matthew Phillips>
So if we were doing a list:

- Payments: fixed?
- Pagination: some nice web components could pave the way for builtins later.
- DRM: What is this? preventing Save Page As?
- Better text layout: What is this one? What's wrong with text on the web?

[13:57:23.0309] <zip>
DRM: Remove


2023-02-04
[18:56:16.0469] <Alan Stearns>
Pagination: there are plenty of ways to simulate pagination in web components, but since we do not provide useful primitives for this they all rely on breaking apart and re-assembling markup elements which is a hard and expensive thing to do

[18:58:22.0095] <Alan Stearns>
Better text layout: The main missing thing (at least for English text) is better line breaking. If you consider more than one line of text at a time, you can come up with better line breaks over an entire paragraph. All browsers only consider one line at a time at the moment.

[06:54:12.0136] <Domenic>
I would not call payments near fixed, at the moment. The web is stuck in a very inadequate equilibrium there and I suspect no single actor could move it. (E.g., even if all browsers wanted to move, payment processors / merchants might not.) But I guess if books are already shelling out to the web, at least a web-based reader would not be worse.


2023-02-06
[01:13:24.0056] <annevk>
hsivonen: have you made up your mind on how to deal with the gb18030 update? Or maybe Adam Rice looked into it?

[01:44:57.0725] <hsivonen>
> <@annevk:matrix.org> hsivonen: have you made up your mind on how to deal with the gb18030 update? Or maybe Adam Rice looked into it?

It's unclear to me to if the upstream standard change is driven by practical improvement or by theory. At least I'm not advocating in favor of a browser change at this time.

[01:45:27.0377] <hsivonen>
Or are we talking about a different gb18030 update?

[01:53:26.0665] <annevk>
hsivonen: nah that one; https://www.unicode.org/L2/L2023/23003r-gb18030-recommendations.pdf was also brought to my attention

[02:34:37.0894] <hsivonen>
> <@annevk:matrix.org> hsivonen: nah that one; https://www.unicode.org/L2/L2023/23003r-gb18030-recommendations.pdf was also brought to my attention

Interesting. I guess a reasonable position for the Encoding Standard is to wait and see what reaction (if any) that letter gets.

[03:08:12.0217] <annevk>
Andreu Botella: Luca Casonato: will either of you update https://github.com/whatwg/fetch/pull/1346?

[03:10:18.0956] <annevk>
I'm also happy to do some work if that would be easier. I think there's enough agreement to merge this and give it a go.

[03:53:42.0338] <Andreu Botella>
> <@annevk:matrix.org> Andreu Botella: Luca Casonato: will either of you update https://github.com/whatwg/fetch/pull/1346?

I would update it if I had write permissions for fetch

[03:57:40.0024] <Andreu Botella>
or if Luca gave me write access to his branch

[04:00:35.0846] <annevk>
Andreu Botella: I gave you write access

[04:00:43.0540] <Andreu Botella>
thanks

[04:08:18.0920] <Noam Rosenthal>
Is there a place I'm missing where UI events create a task on the event loop? Seems like they don't and we rely on "SHOULD"-style somewhat implementation-specific behavior, but I wanted to make sure

[04:17:34.0736] <annevk>
Noam Rosenthal: the sequence of events should be that there's user input, which results in some computation and a task consisting of a set of steps, and those steps then end up dispatching the event

[04:17:50.0148] <annevk>
Noam Rosenthal: you're correct that UI events has been hand-wavy about this since say forever

[04:18:15.0610] <annevk>
Noam Rosenthal: there are some issues and depending on where you look you might find me complaining about it

[04:24:41.0496] <Noam Rosenthal>
annevk: gotcha, thanks for the context. 

[06:59:32.0259] <hsivonen>
Ms2ger: What use case is this test ensuring proper support for? https://github.com/tc39/test262/issues/1696 That is, are you aware of a use case where it's actually useful to load a search collation into the sorting-oriented API? I'm seriously considering sending an Intent to unship: Search collations. (Due to making libxul larger with no reasonable use case that I can see given the API surface available.)

[07:01:05.0251] <hsivonen>
(My question at https://github.com/tc39/ecma402/issues/256#issuecomment-979760435 has remained unanswered for over a year.)

[10:23:48.0361] <littledan>
> <@hsivonen:mozilla.org> Ms2ger: What use case is this test ensuring proper support for? https://github.com/tc39/test262/issues/1696 That is, are you aware of a use case where it's actually useful to load a search collation into the sorting-oriented API? I'm seriously considering sending an Intent to unship: Search collations. (Due to making libxul larger with no reasonable use case that I can see given the API surface available.)

This sounds like something to raise to TC39-TG2, the ECMA-402 committee, to see if people are still interested. It's been part of Intl since the beginning.

[10:24:11.0791] <littledan>
e.g., in one of their calls

[10:25:37.0860] <littledan>
I raised this in #tc39-ecma402:matrix.org 

[13:22:31.0223] <TabAtkins>
> <@matthewcp:matrix.org> So if we were doing a list:
> 
> - Payments: fixed?
> - Pagination: some nice web components could pave the way for builtins later.
> - DRM: What is this? preventing Save Page As?
> - Better text layout: What is this one? What's wrong with text on the web?

Re: the DRM part, I mean a way to serve purchased books that doesn't trivially allow the user to just save the file and email it to someone else. (I feel very strongly that DRM is fundamentally immoral, but it's absolutely a business requirement in this case.)

[13:23:47.0533] <TabAtkins>
For example, if I buy a book from B&N for my Nook, by default it's in a proprietary format that's locked to my account. Luckily the DRM is easy to strip off to obtain the epub inside the container, so I can archive my book collection, but aiui the process is somewhat more difficult for Kindle books.


2023-02-07
[01:02:06.0251] <hsivonen>
> <@littledan:matrix.org> I raised this in #tc39-ecma402:matrix.org

Thanks. It doesn't look particularly indicative of strong use cases existing that there isn't already a use case given on the channel while two collator implementors (Markus Scherer and I) on GitHub are saying that the sorting API isn't suitable for searching.

[01:25:16.0631] <littledan>
> <@hsivonen:mozilla.org> Thanks. It doesn't look particularly indicative of strong use cases existing that there isn't already a use case given on the channel while two collator implementors (Markus Scherer and I) on GitHub are saying that the sorting API isn't suitable for searching.

I have no opinion about the contents of this, but would you be interested in joining one of ECMA-402’s fortnightly calls to discuss with people who might? It would be nice to make a cross-browser decision about unshipping.

[01:41:07.0489] <hsivonen>
> <@littledan:matrix.org> I have no opinion about the contents of this, but would you be interested in joining one of ECMA-402’s fortnightly calls to discuss with people who might? It would be nice to make a cross-browser decision about unshipping.

When is the call scheduled?

[02:40:10.0676] <Ms2ger>
> <@hsivonen:mozilla.org> When is the call scheduled?

I have a monthly call on my calendar which is next Thursday (the 9th) at 10:00-12:30 Pacific

[03:14:05.0452] <Ms2ger>
> <@hsivonen:mozilla.org> Ms2ger: What use case is this test ensuring proper support for? https://github.com/tc39/test262/issues/1696 That is, are you aware of a use case where it's actually useful to load a search collation into the sorting-oriented API? I'm seriously considering sending an Intent to unship: Search collations. (Due to making libxul larger with no reasonable use case that I can see given the API surface available.)

And to answer your question: I don't recall

[05:57:20.0387] <hsivonen>
> <@ms2ger:igalia.com> I have a monthly call on my calendar which is next Thursday (the 9th) at 10:00-12:30 Pacific

Thanks.

[05:58:49.0229] <hsivonen>
> <@ms2ger:igalia.com> And to answer your question: I don't recall

OK. I remain unaware of a use case, then.

[07:02:29.0144] <annevk>
TabAtkins: is https://twitter.com/tabatkins/status/1622642301163175937 another base 6 ploy? 😂

[07:06:48.0886] <TabAtkins>
Actually no! My base 6 ploy for time is at https://www.xanthir.com/hex/clock/

[13:11:46.0056] <Yagiz Nizipli>
Hello, We just released the first version of Ada, a spec compliant url parser, which is also the successor of Node.js's URL parser. https://github.com/ada-url/ada/releases/tag/v1.0.0


2023-02-08
[00:22:34.0252] <Domenic>
> <@yagiznizipli:matrix.org> Hello, We just released the first version of Ada, a spec compliant url parser, which is also the successor of Node.js's URL parser. https://github.com/ada-url/ada/releases/tag/v1.0.0

Very cool! Looking forward to you upstreaming the additional tests I see you all have been working on.

[01:37:32.0998] <Andreu Botella>
huh, I show up twice as a co-author in https://github.com/web-platform-tests/wpt/commit/14151646ae4684a32638d73187381fc0ed86e2c8

[01:38:18.0834] <Andreu Botella>
 * huh, I show up twice as a co-author in https://github.com/web-platform-tests/wpt/commit/14151646ae4684a32638d73187381fc0ed86e2c8

[01:45:39.0958] <annevk>
Andreu Botella: you were listed twice with separate email addresses and I didn't want to presume so I kept both

[01:46:49.0218] <annevk>
Also, congrats to you and Luca Casonato for getting that feature done. I'm personally quite happy Headers now has full HTTP parity

[01:47:07.0298] <Andreu Botella>
thanks! 🎉

[01:47:48.0884] <Andreu Botella>
I still have the task of convincing the TAG and the Chromium API owners that it's a good idea though 😅

[01:50:20.0068] <Andreu Botella>
about that, I kept my personal email as the github default, since not everything open-source I do is related to Igalia, but that causes trouble when committing suggestions

[01:50:29.0832] <Andreu Botella>
> <@annevk:matrix.org> Andreu Botella: you were listed twice with separate email addresses and I didn't want to presume so I kept both

 * about that, I kept my personal email as the github default, since not everything open-source I do is related to Igalia, but that causes trouble when committing suggestions

[01:52:17.0531] <Luca Casonato>
thanks annevk! happy that this is landed now :)

[03:08:06.0490] <jgraham>
A C++ implementation of the URL standard called Ada? Maybe next we can have a Java implementation called Rust? ;p

[05:02:37.0898] <annevk>
I guess we may or may not have all the Twitter bots breaking on us: https://twitter.com/TwitterDev/status/1621026986784337922 vs https://twitter.com/elonmusk/status/1622082025166442505

[05:31:22.0761] <jub0bs>
I've just published a post about what a good CORS middleware library should look like. Feedback welcome! https://jub0bs.com/posts/2023-02-08-fearless-cors

[05:34:47.0762] <jub0bs>
It's quite long, but I've broken it down into 12 principles, so you can dip in and out 😇

[05:55:42.0601] <Yagiz Nizipli>
> <@jgraham_:matrix.org> A C++ implementation of the URL standard called Ada? Maybe next we can have a Java implementation called Rust? ;p

:) The project is a gift to my first soon-to-be born child, who will be named Ada

[05:56:14.0560] <Yagiz Nizipli>
Ada also means "island" in Turkish

[06:00:32.0146] <annevk>
I'm just gonna assume the vCard way to specify Mastodon is `X-SOCIALPROFILE;type=mastodon:[URL]` which is near identical to what I have for Twitter, but if that can be improved let me know

[06:00:58.0784] <annevk>
 * I'm just gonna assume the vCard way to specify Mastodon is `X-SOCIALPROFILE;type=mastodon:[URL]` which is near identical to what I have for Twitter, but if that can be improved let me know

[06:03:15.0723] <jgraham>
Yagiz Nizipli: Congratulations in advance on the child :)

[06:13:50.0179] <annevk>
johannhof: could you please fix the URL Standard build error as I believe you said you would? If you're otherwise occupied I can take care of it though

[06:19:12.0241] <johannhof>
annevk: ah, thanks for reminding me. I can take care of it, but need a few mins to get back to a computer :)

[06:19:37.0024] <annevk>
/me is reminded of Chris Pine

[06:27:58.0520] <jgraham>
I C what you did there

[06:29:59.0473] <Yagiz Nizipli>
We're looking to implement domain to ascii algorithm of URL spec to drop the ICU requirement of Ada. It's an ongoing process at https://github.com/ada-url/idna. Is there an example implementation other than ICU for it?

[06:30:40.0149] <jub0bs>
 * It's quite long, but I've broken it down into 12 principles, so you can dip in and out 😇
Thanks to sideshowbarker, who kindly agreed to review an early draft of the post 🙏

[07:02:18.0352] <annevk>
hsivonen: I vaguely recall you looking into the above?

[07:03:01.0309] <annevk>
Yagiz Nizipli: there's also https://github.com/mathiasbynens/punycode.js though be mindful of https://github.com/jsdom/whatwg-url/issues/239

[07:22:37.0732] <annevk>
Yagiz Nizipli: it might make sense to list Ada in https://github.com/whatwg/spec-factory/blob/main/factory.json and https://github.com/whatwg/meta/blob/main/MAINTAINERS.md; at some point we probably need a better system for that, but I don't think we hit the breaking point yet

[07:36:15.0982] <Yagiz Nizipli>
annevk: Yes, Ada is merged into Node.js. I think we should add Ada. We have a Github workflow for keeping our tests in sync with WPT - https://github.com/ada-url/ada/blob/main/.github/workflows/wpt-updater.yml. Might be a good idea to recommend such approach to all implementers, in order to reduce the non-automated part of compliance.

[07:36:24.0511] <Yagiz Nizipli>
 * annevk: Yes, Ada is merged into Node.js. I think we should add Ada. We have a Github workflow for keeping our tests in sync with WPT - https://github.com/ada-url/ada/blob/main/.github/workflows/wpt-updater.yml. Might be a good idea to recommend such approach to all implementers, in order to reduce the non-automated part of compliance.

[07:42:35.0090] <annevk>
Yagiz Nizipli: I see, I guess in that case for URL we may no longer need to ping Node.js directly? It would be good to keep it to one of the projects in any case

[07:47:10.0706] <Yagiz Nizipli>
annevk: I'd still recommend keeping Node.js in the loop. There are some folks who might be interested & informed about the changes. If other runtimes will adopt Ada, we might drop them and just keep Ada for creating issues.

[07:48:18.0447] <Yagiz Nizipli>
annevk: Due to the missing tests on WPT, Ada can't test every change directly, simply because we don't have a JS layer to test it on. If this wasn't the case, it would be a lot easier to maintain and the need to inform Node.js would significantly decrease.

[07:52:40.0414] <annevk>
Yagiz Nizipli: to be clear, you cannot modify the template on whatwg/url directly, you'll have to modify the files I linked above

[12:54:53.0552] <hsivonen>
annevk Yagiz Nizipli : https://github.com/unicode-org/icu4x/issues/2850 is on my mental todo list, but haven't gotten further than writing down what I've written down in that issue.


2023-02-09
[00:27:26.0417] <annevk>
hsivonen: nice, note that Validity Criteria might change if they accept my upcoming CheckBidi feedback (CheckBidi would move to Processing)

[00:54:33.0064] <Luca Casonato>
> <@yagiznizipli:matrix.org> We're looking to implement domain to ascii algorithm of URL spec to drop the ICU requirement of Ada. It's an ongoing process at https://github.com/ada-url/idna. Is there an example implementation other than ICU for it?

There is a Rust implementation that does not rely on ICU

[00:56:20.0328] <Luca Casonato>
https://github.com/servo/rust-url/tree/master/idna

[07:46:21.0119] <littledan>
Could I join the WinterCG triage call today (for the ShadowRealms topic)?

[08:02:15.0517] <annevk>
littledan: I'm guessing you mean HTML, I can DM you the link

[08:03:35.0887] <littledan>
 * Could I join the HTML triage call today (for the ShadowRealms topic)?

[08:03:49.0815] <littledan>
oops yes please!

[08:03:55.0960] <littledan>
thank you

[08:06:00.0355] <annevk>
To be clear, as far as I know Domenic is out so we might have to defer

[08:28:02.0349] <annevk>
If you help with issue triage and miss labels, please add suggestions to https://github.com/whatwg/meta/issues/270

[08:28:57.0177] <Yagiz Nizipli>
> <@lucacasonato:matrix.org> There is a Rust implementation that does not rely on ICU

Thanks!

[09:03:40.0464] <Dominic Farolino>
Does CORB live in any spec today?

[09:04:10.0540] <Dominic Farolino>
https://www.chromium.org/Home/chromium-security/corb-for-developers/ links to https://fetch.spec.whatwg.org/#corb which DNE

[09:04:26.0870] <Dominic Farolino>
and I know ORB is currently stuck in a Fetch PR

[09:06:39.0258] <Yagiz Nizipli>
Question: Is there a publicly known benchmark suite across URL parsers? I'm searching for research done within this area.

[09:40:56.0686] <annevk>
Dominic Farolino: it was removed due to there being only a single impl

[09:41:06.0290] <annevk>
 * Dominic Farolino: it was removed due to there being only a single impl

[09:41:18.0572] <annevk>
Yagiz Nizipli: not aware

[13:24:17.0190] <Eric Portis (he/him)>
Has there ever been a discussion about requiring JPEG, PNG, or GIF support in visual browsers? I was going down a  <video>/<audio> codec requirements memory lane today and found myself wondering if the same thing had ever happened for images...


2023-02-10
[23:13:23.0028] <Ms2ger>
HTML says "This specification does not specify which image types are to be supported."

[00:03:01.0761] <Pierre-Yves Gérardy>
Hi folks, coming here from https://github.com/whatwg/dom/issues/586 per @annevk's suggestion

[00:04:41.0808] <Pierre-Yves Gérardy>
The proposed API looks to me like a "better horse" situation, hence my comments...

[00:07:28.0281] <annevk>
Pierre-Yves Gérardy: hey welcome, thanks for joining! And thanks for giving feedback, but note that for effective participation it's usually better to support an existing comment that says as much or leave a single comment that clearly makes your point. Adding a lot of comments to an issue will make them look noisy and more easily ignorable.

[00:08:57.0267] <annevk>
And to be clear, the API as proposed wouldn't make it in. If we actually want CSS parity it would need move semantics as discussed in the issue I linked.

[00:17:01.0908] <Pierre-Yves Gérardy>
Move semantics... could you explain? As in not detaching the nodes from the document/parent while moving them around? If so I'm with you from my first comment on...

[00:19:43.0285] <Pierre-Yves Gérardy>
Losing the state of media elements, iframes, and the focus when moving nodes is an anti-feature of the current DOM methods.

[00:30:59.0221] <Pierre-Yves Gérardy>
A single `parent.spliceChildren(nodes: Nodes[], {previousSibling?, nextSibling?, delayRemoval?: (n:Node)=>Promise)` method would cover all the cases used in the wild in frameworks AFAIK, and would be more ergonomic than asking users to tag nodes with an attribute for the browser to reorder

[00:32:05.0660] <annevk>
Pierre-Yves Gérardy: right, at the moment the DOM only has insert, remove, and replace all, essentially.

[00:32:42.0482] <annevk>
That signature looks more complex than what I had in mind, but there's a lot of pre-requisites to sort out first anyway. (As noted in my comment.)

[00:39:47.0654] <Pierre-Yves Gérardy>
Do you mean https://github.com/whatwg/dom/issues/808?

[00:49:16.0032] <Pierre-Yves Gérardy>
Re. signature,  `(nodes, options?)` has the advantage of future extensibility. For the simple case(reorder all nodes) the options are not needed. If you want to move a subset of nodes from one point to another, it becomes `splice(nodes, splicePoint)` which is as convenient as it gets...

[00:49:54.0959] <annevk>
What would prevent us from adding a dictionary when we need it?

[00:50:19.0893] <Pierre-Yves Gérardy>
The modern DOM methods are variadic

[00:51:15.0699] <annevk>
Those could still have a dictionary at the end if we wanted to. And yeah, that issue is a pre-requisite. The other issue that's referenced discusses move semantics.

[00:59:43.0704] <Pierre-Yves Gérardy>
In my ideal world, moving nodes within a document wouldn't tigger a state teardown/init if done atomically. A manual `remove`/`insert` would though.

Could these APIs be extended to accept arrays of nodes, so that we don't have to splice them in? That would avoid iterating twice over the list.

[01:13:15.0183] <Pierre-Yves Gérardy>
They already do, my bad :-)

[01:17:10.0228] <Pierre-Yves Gérardy>
Actually, they don't, and can't be updated for Web compat reasons I guess, since arrays are stringified :-/

[01:24:33.0741] <annevk>
Pierre-Yves Gérardy: you can use apply, it's fine

[01:28:01.0778] <Pierre-Yves Gérardy>
And push the options at the end of the array if they ever were supported I suppose. 👍️

Re. #808 why can't we add methods that don't trigger the state reinitialization when moving within the same document? Wouldn't that give us the CSS parity you're after?

[01:28:46.0388] <Pierre-Yves Gérardy>
... and side-step #808 altogether

[01:29:26.0965] <annevk>
In order to understand what you can ignore, you first have to understand what you will be ignoring.

[01:30:01.0961] <Pierre-Yves Gérardy>
:-) Gotcha, I'll read more about it and come back. Thanks for your patience

[01:35:24.0437] <sideshowbarker>
Is this use of the term _“move semantics”_ inspired by the same concept from C++?

And is it some new usage? I don’t so that term anywhere in the DOM spec itself yet…

[01:44:27.0650] <annevk>
sideshowbarker: maybe? The idea is that you wouldn't remove or insert a node (current primitives), but move it. This would also result in a different mutation record, for instance.

[01:50:31.0276] <sideshowbarker>
I see. I asked just because I’ve not ever seen “move semantics” used in a general sense for anything, and because it have a very specific specialized meaning in C++. I would think that C++ programmers might find the use of the term for DOM operations to be a bit odd — or that it might imply to them some special behavior similar to what it has in C++.

But maybe not. I guess Rust uses the term, though I think Rust uses in much the same way that C++ does.

Anyway, was just curious

[01:58:18.0567] <Pierre-Yves Gérardy>
@annevk are MutationEvents still a concern in 2023? If so, move semantics could be spec'ed such that mutation events throw errors. That would be Web compatible, and would push folks who still use MutationEvents and want to opt into move semantics to migrate away from them.

[02:05:21.0564] <Pierre-Yves Gérardy>
A gentler option would be to ignore the mutation events and issue warnings.

[02:40:44.0955] <annevk>
sideshowbarker: it's not quite "general sense" though :-) it's in the context of the node tree 

[02:42:23.0976] <annevk>
Pierre-Yves Gérardy: mutation events still exist and will be a problem of sorts, but they're not the main problem I think

[02:42:54.0532] <Pierre-Yves Gérardy>
Yes, I'm reading through the various issues listed in #808

[02:44:02.0935] <Pierre-Yves Gérardy>
I was just wondering if throwing bones at folks that still use them was deemed fair game if we don't break existing sites

[02:44:34.0538] <annevk>
I'm not quite sure what that means. It sounds like it would make event listeners observable which seems bad.

[02:48:13.0683] <Pierre-Yves Gérardy>
Because one can spy on `console.warn`? The warning could be issued asynchronously...

[02:49:44.0974] <Pierre-Yves Gérardy>
By "throwing a bone", I mean creating features that are deliberately incompatible with the ones you want to deprecate.

[02:50:36.0249] <annevk>
Yeah sure, I suspect we might do that. Again, not the biggest issue.

[02:56:47.0261] <Pierre-Yves Gérardy>
I see, the race conditions described in #808 and friends look "fun"

[03:13:43.0574] <Pierre-Yves Gérardy>
Regarding these issues, is there a notion of atomic transactions in DOM operations? As in "no user code runs during a DOM transaction"?

[03:14:33.0886] <annevk>
Nope

[03:15:13.0593] <Pierre-Yves Gérardy>
That sounds like a useful concept to tie these issues together

[03:17:18.0166] <Pierre-Yves Gérardy>
I don't mean exposing the concept to user code, but relying on it to define DOM operations in the spec

[03:20:14.0044] <annevk>
It wouldn't help with move. The problem isn't userland. The problem is with element-specific behavior (some of which potentially needed).

[03:24:20.0393] <Pierre-Yves Gérardy>
So far the issues I've seen are about code within script tags that runs before its siblings are present. I've yet to dig into the iframe issues

[03:24:47.0561] <annevk>
It's not even clear to me you can completely avoid trashing animations as selectors will end up matching different nodes so some amount of invalidation will be needed.

[03:25:52.0954] <annevk>
Pierre-Yves Gérardy: well that's a thing that happens when you insert `script`. We probably don't have to invoke those callbacks when we move. (But in order to be sure we better first understand insert.)

[03:41:08.0162] <Pierre-Yves Gérardy>
I supposed as much re. script insertion. Who's the "we" that should better understand insertion and removal? The WhatWG? Implementers? Both? In any case, is there something I can do that would help?

Animations are another can of worms, yes :-).

If we allow to move nodes across parents, I suppose that the `connectedCallback` will have to fire. Could there be a `movedCallback` when the parent doesn't change, or would you overload `connectedCallback`? Related, moving style tags around can change the cascade or apply to a different root...

[03:44:30.0316] <annevk>
Pierre-Yves Gérardy: the last time I looked at that browser behavior differed. It's also not specified. Getting it properly specified and agreed upon would be a good first step.

[04:07:20.0753] <zcorpan>
I think I'll stop using "good first issue" labels. It seems it mostly accomplishes getting comments saying "please assign to me", but no PRs


2023-02-11
[10:58:46.0912] <hacknorris>
someone  knows how to properly add href attribute to a custom html tag? wanted to avoid js but i dont see any option in css or similar...

[10:58:57.0101] <hacknorris>
 * someone  knows how to properly add href attribute to a custom html tag? wanted to avoid js but i dont see any option in css or similar...

[11:11:48.0941] <hacknorris>
?


2023-02-13
[01:37:24.0592] <Ms2ger>
Use the `a` element, that's what it's for

[01:55:22.0033] <networkException>
Hey, I'm having trouble implementing some steps relating to the [WebIDL Promise](https://webidl.spec.whatwg.org/#idl-promise) type:

In [react to a Promise](https://webidl.spec.whatwg.org/#dfn-perform-steps-once-promise-is-settled)

> 5. Let constructor be promise.[[Promise]].[[Realm]].[[Intrinsics]].[[%Promise%]].

I would assume the `promise` given to be a [PromiseCapability Record](https://tc39.es/ecma262/#sec-promisecapability-records) as the `[[Promise]]` field (containing "an object that is usable as a promise") gets accessed.

However, in the case of [fetching the descendants of and linking a module script](https://html.spec.whatwg.org/multipage/webappapis.html#fetch-the-descendants-of-and-link-a-module-script)

> 5. Let loadingPromise be record.LoadRequestedModules(state).

> 6. Upon fulfillment of loadingPromise, run the following steps:

`loadingPromise` (which is passed to [fulfillment](https://webidl.spec.whatwg.org/#upon-fulfillment) and [react](https://webidl.spec.whatwg.org/#dfn-perform-steps-once-promise-is-settled) subsequently) is clearly (already?) a promise object and and not a capability record, returned by [LoadRequestedModules](https://tc39.es/ecma262/#sec-LoadRequestedModules):

> 2. Let pc be ! NewPromiseCapability(%Promise%).

> 5. Return pc.[[Promise]].

[02:03:17.0498] <Ms2ger>
Looks like a bug in LoadRequestedModules

[02:15:22.0452] <networkException>
so the WebIDL promise is supposed to be a capability record then? It would be good to have that clarified

[02:27:19.0481] <Ms2ger>
> IDL promise type values are represented by ECMAScript PromiseCapability records.

[02:27:23.0757] <Ms2ger>
https://webidl.spec.whatwg.org/#es-promise

[02:28:59.0512] <Andreu Botella>
wait, does that mean that an operation of the form `Promise<any> identity(Promise<any> input)` cannot return the input promise object?

[02:29:12.0475] <Andreu Botella>
and that any operation that takes a `Promise<T>` can't resolve or reject the promise

[02:29:27.0958] <Andreu Botella>
though I guess only the wasm streaming API takes a promise

[02:29:36.0110] <Andreu Botella>
 * though I guess only the wasm streaming API takes a promise

[02:30:48.0511] <networkException>
> <@ms2ger:igalia.com> https://webidl.spec.whatwg.org/#es-promise

ah great, I'm blind :)

[02:58:09.0256] <Ms2ger>
> <@abotella:igalia.com> wait, does that mean that an operation of the form `Promise<any> identity(Promise<any> input)` cannot return the input promise object?

Well, no, because it's a capability both ways

[03:10:44.0908] <annevk>
Andreu Botella: there's `waitUntil()` in service workers

[03:12:59.0269] <Andreu Botella>
oh, right

[03:13:34.0438] <Andreu Botella>
I guess it is a potential spec-writing pitfall if spec authors don't realize using the resolve/reject algorithms on promises converted from JS objects won't work

[03:14:31.0017] <Andreu Botella>
but it seems like only those two cases take promises, so it's fine for now

[03:26:01.0110] <annevk>
Andreu Botella: you're thinking of a pattern whereby a promise is supplied that the spec will resolve? Can't immediately think of a use case for that

[03:26:38.0670] <Andreu Botella>
I don't have a use case, it's just something I intuitively expected to be able to do

[03:33:38.0339] <annevk>
The only output parameter use case we have thus far is for byte buffers, which makes sense. I do agree though that as far as IDL goes there's a lot of potential cleanup to be done there around JS and IDL objects and how specifications can manage that.

[03:40:15.0835] <sideshowbarker>
annevk: Does the WebKit team have any position on WebHID stated anywhere other than it just being in the _“Here are some examples of features we have decided to not yet implement due to fingerprinting, security, and other concerns”_ list at https://webkit.org/tracking-prevention/#anti-fingerprinting?

I looked in the standards-position issue tracker but didn’t find anything.

[03:44:40.0108] <annevk>
sideshowbarker: I'm not sure if there's a stated position. There would have to be something either on standards-positions or webkit-dev for that.

[03:45:45.0053] <sideshowbarker>
OK

[05:21:48.0391] <Ms2ger>
annevk: what is "this's relevant Realm" in a static method? https://fetch.spec.whatwg.org/#dom-response-error

[05:25:19.0882] <annevk>
Ms2ger: hmm, spec-UB?

[05:27:08.0908] <Ms2ger>
Yeah, seems like "this" is null in https://webidl.spec.whatwg.org/#dfn-create-operation-function

[05:27:11.0683] <Andreu Botella>
more like a spec bug – it seems clear that this should be the realm in which the `Response` interface object was constructed, right?

[05:29:57.0406] <annevk>
Andreu Botella: spec-UB is a bug :-) And I don't think we have access to that realm. Prolly needs to use current.

[05:30:54.0178] <Andreu Botella>
I think current might give the wrong result sometimes (`Response.error() instanceof Response` being false)

[05:31:24.0673] <Andreu Botella>
oh, wait, that's not right

[05:31:34.0633] <Andreu Botella>
 * oh, wait, that's not right

[05:32:44.0609] <annevk>
I feel like we should charge all this tech debt to the person who came up with sync script access `frame`s

[05:34:19.0674] <Ms2ger>
Filed https://github.com/whatwg/fetch/issues/1603

[05:36:03.0636] <Andreu Botella>
 * <del>oh, wait, that's not right</del> turns out it *is* right

[05:37:49.0907] <Pierre-Yves Gérardy>
In https://html.spec.whatwg.org/multipage/nav-history-apis.html#named-access-on-the-window-object the *names* object is mentioned in step 3, but only defined in step 4. I understand that it is a permanent object that may pre-exist when the algo runs but it isn't mentioned... Is it a spec bug?

[05:38:43.0072] <Andreu Botella>
> <@annevk:matrix.org> Andreu Botella: spec-UB is a bug :-) And I don't think we have access to that realm. Prolly needs to use current.

Response.[[Realm]] should be that realm, IIUC

[05:47:25.0539] <Ms2ger>
> <@pygy_:matrix.org> In https://html.spec.whatwg.org/multipage/nav-history-apis.html#named-access-on-the-window-object the *names* object is mentioned in step 3, but only defined in step 4. I understand that it is a permanent object that may pre-exist when the algo runs but it isn't mentioned... Is it a spec bug?

Looks like a bug

[05:48:32.0395] <Pierre-Yves Gérardy>
Should I file an issue?

[05:49:02.0266] <Ms2ger>
Yes please

[05:49:09.0783] <Ms2ger>
cc Domenic 

[05:55:55.0430] <Pierre-Yves Gérardy>
https://github.com/whatwg/html/issues/8881

[05:57:21.0608] <annevk>
Andreu Botella: but how is that different from the current realm?

[05:57:39.0441] <annevk>
Andreu Botella: because where do I get Response from

[06:00:35.0075] <annevk>
Minor milestone: all IDNA feedback has been submitted. All but the CheckBidi feedback (submitted just now) has also been acknowledged. And now we wait for ~2-3 months.

[06:15:57.0919] <Andreu Botella>
> <@annevk:matrix.org> Andreu Botella: because where do I get Response from

Oh, right. I don't yet fully understand the differences between current/entry/incumbent... but I think some of the pieces have finally clicked in my head 😅

[06:19:03.0632] <Ms2ger>
Gecko will get the relevant global of the `Response.error` function, as far as I can tell

[06:21:18.0465] <Jake Archibald>
fwiw, the static methods on `Promise` _do_ use `this`

[06:21:54.0085] <Jake Archibald>
I don't know if that's unusual in JS land

[06:25:14.0821] <annevk>
Hmm yeah, this is always so confusing to me

[06:25:51.0051] <Jake Archibald>
I guess the question is, `class Foo extends Response {}`, what type should `Foo.error()` be?

[06:25:58.0832] <Jake Archibald>
 * I guess the question is, `class Foo extends Response {}`, what type should `Foo.error()` be?

[06:30:48.0828] <Jake Archibald>
fwiw, `Object.entries()` appears to be bound to `Object`, like `Response.error()`

[06:30:57.0869] <Jake Archibald>
So maybe promises are the odd one out

[06:33:31.0161] <Jake Archibald>
annevk: our devtools folks are looking into standardising/improving sourcemaps. Is there someone in particular at WebKit who works on that?

[06:36:53.0744] <Jake Archibald>
 * fwiw, `Object.fromEntries()` appears to be bound to `Object`, like `Response.error()`

[06:37:13.0155] <annevk>
DevTools folks presumably. Perhaps bring it up on some coordination list, depending on what you're looking for?

[06:41:33.0611] <Jake Archibald>
annevk: they're exploring defining sourcemaps (in WHATWG if it makes sense), and they're looking for a WebKit contact, to see if there'd be an objection to such a spec, or any WebKit-specific requirements

[08:00:17.0294] <annevk>
Jake Archibald: if there's a proposal of sorts WebKit/standards-positions would be great

[08:00:51.0059] <annevk>
Jake Archibald: if not I guess email me and I'll ask around

[08:01:16.0155] <Jake Archibald>
annevk: standards-positions sounds fine to me

[08:02:05.0190] <annevk>
(WHATWG makes sense to me, we already have a tooling-related spec)

[08:03:09.0068] <Jake Archibald>
Yeah, especially since sourcemaps aren't specific to JavaScript, so it's not like TC39 is a better fit

[08:09:46.0722] <annevk>
(I vaguely recall yulia also being involved in sourcemap discussions)

[08:12:23.0135] <yulia>
> <@jakea:matrix.org> annevk: they're exploring defining sourcemaps (in WHATWG if it makes sense), and they're looking for a WebKit contact, to see if there'd be an objection to such a spec, or any WebKit-specific requirements

I think there are a couple of homes for it. In the past, we've tried to define a more mature home for it, which ended up being the wasm debugging group (originally it was wasm/js debugging group) in w3c but i believe that has folded. fitzgen has the most context regarding the original plans for this

[08:14:51.0361] <yulia>
I would need to spend some time to recall properly how this went last time, happy to help how i can though

[08:15:35.0167] <yulia>
I don' think TC39 is the right place

[08:21:01.0744] <Jake Archibald>
yulia: I'll let them know. I'll get them to file a standards position at Mozilla too

[08:25:12.0558] <yulia>
I personally support getting this moved into a proper spec if we keep working on it, and i think thats going to be the case for now

[11:53:38.0899] <TabAtkins>
WebIDL question: since dictionaries can be argument *or* return types, their values are limited to things valid for return types - primitives, interfaces, etc. But this means that if you're using a dictionary for an argument type (an options bag, for example), you *can't* have any of the members be an argument-only type like sequence or record. Right? 

[11:54:01.0287] <TabAtkins>
And if correct, uhh, is there any way to get around this so you can specify an options argument that takes a sequence or record for one of the options?

[11:54:22.0895] <TabAtkins>
(The end-run of `record<DOMString, Any>` is of course possible but desirable to avoid at all costs.)

[12:02:35.0195] <TabAtkins>
wait nm i was misreading the spec, ignore all of the above


2023-02-14
[22:41:06.0893] <zcorpan>
A friend asked if there’s a better way to do this: https://stackoverflow.com/questions/60262041/is-there-a-way-to-get-child-class-file-path-in-parent-class/60262174#60262174

i.e. in constructor() of A get the url of B, without modifying B’s constructor. import.meta.url only gives A.js. It’s possible to catch an exception and get the stack trace, but that’s not ideal :)

[22:42:47.0709] <shark adsm>
acsebility

[23:07:15.0368] <Domenic>
> <@zcorpan:mozilla.org> A friend asked if there’s a better way to do this: https://stackoverflow.com/questions/60262041/is-there-a-way-to-get-child-class-file-path-in-parent-class/60262174#60262174
> 
> i.e. in constructor() of A get the url of B, without modifying B’s constructor. import.meta.url only gives A.js. It’s possible to catch an exception and get the stack trace, but that’s not ideal :)

No, except for the stack trace loophole, there's generally no way to know what file code comes from.

[23:08:18.0885] <zcorpan>
Domenic: thanks. Do you know if that's intentional or something we should add?

[23:08:59.0571] <Domenic>
I think it's semi-intentional in that implementers really hate having to keep that sort of info around for stack traces (for memory reasons)?

[23:10:06.0685] <zcorpan>
but they do keep it around, yes?

[23:10:09.0610] <Domenic>
It's also pretty fragile in the face of bundlers, etc., which are still widely used.

[23:10:32.0670] <Domenic>
I guess they must, for functions at least. Not sure about how things like inlining, etc. effect that.

[23:15:45.0156] <zcorpan>
interesting, maybe there are cases where the engine knows a function can't throw and can drop the stack information. But an API would mean they can't drop it

[05:54:36.0736] <Yagiz Nizipli>
Is there an incentive to improve the toascii.json in web-platform-tests?

[05:58:38.0844] <annevk>
Yagiz Nizipli: you mean in contrast IdnaTestV2?

[06:09:14.0602] <Yagiz Nizipli>
> <@annevk:matrix.org> Yagiz Nizipli: you mean in contrast IdnaTestV2?

Yes

[06:15:31.0382] <annevk>
Yagiz Nizipli: I dunno, I guess I'd like us to continue to add tests to toascii.json as we come across browser Interop issues. Perhaps if someone was willing to take the initiative to donate them to Unicode and deduplicate them with IdnaTestV2 that would be better, but I'm not sure if that's an easy process.

[07:31:00.0551] <hsivonen>
> <@littledan:matrix.org> I have no opinion about the contents of this, but would you be interested in joining one of ECMA-402’s fortnightly calls to discuss with people who might? It would be nice to make a cross-browser decision about unshipping.

Thanks for this. The meeting turned up a use case: Instead of the haystack being a long string from which needle would be searched as a substring, the ECMA-402 API can be used if haystack is a list of strings and the operation is to find the list items that match the needle on a full-string basis. So now I'm aware of a potential use case instead of being totally unaware of a use case. I'm still _very_ skeptical of the presented use case arising in JS programs on the Web in practice. The case mentioned was an address book, but with the ECMA-402 API, the user would have to enter a full given name or a full family name instead of being able to enter a prefix of a name.

[07:31:57.0857] <littledan>
hsivonen: Interesting, so is that to say that you didn't reach a shared conclusion one way or another yet?

[07:33:32.0537] <hsivonen>
> <@littledan:matrix.org> hsivonen: Interesting, so is that to say that you didn't reach a shared conclusion one way or another yet?

No shared conclusion, but I'm still pursuing unshipping search collation data, but now I'm considering unshipping it less fully and adding more special-casing to try to hide the fact that the data isn't there a bit more carefully.

[07:35:20.0740] <hsivonen>
I'm also trying to understand better what the Korean search tailoring in the search root is trying to accomplish. After reading the CLDR source and issues, I had an expectation of what it would do in Chrome's ctrl-f, but I can't get Chrome's ctrl-f to do anything different from Firefox's ctrl-f for Korean.

[07:35:44.0220] <hsivonen>
Next, I'm going to experiment with cmd-f in macOS Finder in Korean to see if something interesting happens there.

[09:10:46.0178] <zero-one>
i'm writing a URL parser that follows the WHATWG URL spec, and i'm wondering how i can shortcut the implementation a little bit if i assume that all input to the parser is already UTF-8 encoded

[09:11:10.0922] <zero-one>
afaict, all codepoints > `0x7F` end up being percent-encoded byte-by-byte anyway

[09:11:22.0858] <zero-one>
so can i just parse byte-by-byte instead of codepoint-by-codepoint?

[09:11:59.0189] <zero-one>
 * afaict, all codepoints > 0x7F end up being percent-encoded byte-by-byte anyway

[09:13:01.0652] <zero-one>
 * afaict, all codepoints > `0x7F` end up being percent-encoded byte-by-byte anyway

[09:32:11.0629] <annevk>
zero-one: you'll need special code for host names, but for determining component boundaries that should totally work

[09:33:30.0086] <zero-one>
can you elaborate? is that because of the opaque-host parsing?

[09:33:56.0712] <annevk>
zero-one: the opposite, for domain to ASCII you need a bunch of logic around code points

[09:36:35.0572] <zero-one>
oh, i see... we percent-decode here and then punycode it or something

[09:40:03.0570] <annevk>
Yeah, it's great 😂

[09:40:53.0532] <zero-one>
but as long as i hack around that, there's no other big roadblock to basically ignoring the encoding and just going byte-by-byte?

[09:45:46.0751] <annevk>
zero-one: for UTF-8 inputs, yeah

[09:45:53.0626] <zero-one>
cool

[09:46:10.0275] <zero-one>
thanks for the help, i'm still trying to wrap my head around everything

[09:46:56.0626] <annevk>
Heh. Me too!


2023-02-15
[01:17:17.0987] <annevk>
Domenic: not using "return" in "in parallel" to exit is still a thing, right?

[01:23:12.0992] <annevk>
 * Domenic: not using "return" in "in parallel" to exit is still a thing, right? (Context: https://github.com/whatwg/fs/pull/95.)

[02:54:54.0972] <annevk>
krosylight: there's "<li><p>Run the following steps [=in parallel=]:" too; I guess with regards to CI maybe we need to wait a little

[02:55:22.0297] <annevk>
krosylight: at least https://github.com/whatwg/fetch/pull/1605 suggests there's some nonsense going on

[03:05:39.0192] <krosylight>
Seems it's https://github.com/speced/bikeshed/issues/2471

[04:36:27.0768] <sideshowbarker>
annevk: Is there anything blocking https://github.com/whatwg/fetch/pull/1442 (ORB)?

[04:37:25.0900] <sideshowbarker>
ah, now I see the checklist — _“Define "validate a partial response" (and Content-Range header parser)”_

[04:45:02.0397] <annevk>
Yeah, there's a couple minor things still. I'd like to get back to it at some point. Or find someone who wants to take over.

[04:45:36.0722] <sideshowbarker>
OK

[04:47:41.0895] <sideshowbarker>
Chrome is still shipping CORB I guess? I think it’s a continuing point of confusion to developers — both that they get this behavior only in Chrome, and also now that there’s no spec which defines the behavior they’re seeing

[04:48:32.0569] <sideshowbarker>
Developers posting to Stack Overflow almost always assume it’s some part of CORS

[04:49:04.0533] <annevk>
They ship a variant of the original CORB and I think are still planning to converge on ORB

[04:49:25.0600] <annevk>
I mean, they're not entirely wrong; it's all part of the SOP

[06:47:01.0612] <Yagiz Nizipli>
It's harder to visualize this, than to implement it :)

[07:30:56.0048] <annevk>
:ouch: 

[07:38:10.0256] <Domenic>
> <@annevk:matrix.org> Domenic: not using "return" in "in parallel" to exit is still a thing, right? (Context: https://github.com/whatwg/fs/pull/95.)

Still a thing. Not sure where we've landed is great, but current style is to use "abort these steps" for nested algorithms and reserve "return" for top-level ones.

[07:52:26.0902] <annevk>
Domenic: so callbacks can never return anything? In my mind the divide was main thread / in parallel

[07:54:42.0626] <annevk>
I guess it might need some more experience

[10:06:26.0120] <annevk>
Domenic: should we consider a dedicated Maintainers section in standards for https://github.com/whatwg/sg/issues/210 as well? Maybe just something to keep in mind if it keeps coming up

[15:55:07.0151] <Domenic>
> <@annevk:matrix.org> Domenic: so callbacks can never return anything? In my mind the divide was main thread / in parallel

So, again, none of this is very principled or even good. But the style I've been using is that *inline* callbacks can't return things; if it has a real return value you need to pull it out into a separate named algorithm.

[15:55:26.0771] <Domenic>
The more I describe it, the worse it sounds, so maybe we should have a real discussion about coming up with something better and more principled.

[15:56:00.0501] <Domenic>
You mean like, separate from the Acknowledgments?

[15:56:07.0884] <Domenic>
> <@annevk:matrix.org> Domenic: should we consider a dedicated Maintainers section in standards for https://github.com/whatwg/sg/issues/210 as well? Maybe just something to keep in mind if it keeps coming up

 * You mean like, separate from the Acknowledgments?


2023-02-16
[16:44:18.0473] <Domenic>
The platform is highly inconsistent on timeStamp vs. timestamp 😭

[22:29:26.0882] <annevk>
Domenic: yeah, just a section following Ack

[22:30:05.0130] <Domenic>
But purposefully not putting them back in the headers? Hmm. I don't have strong feelings either way, I guess.

[22:30:48.0109] <annevk>
I'm not sure what you mean by that :-) Gotta go for a bit

[22:53:31.0813] <Domenic>
I mean, if the goal is to make maintainers more prominent, the obvious thing to do is go back to W3C-style/default Bikeshed style, and have a headers line item alongside Participate / Commits / Tests / Translations.

[22:53:51.0979] <Domenic>
But I guess your suggestion is something less prominent than that, but more prominent than our current practice of putting them first in Acks

[23:26:34.0357] <annevk>
I was more thinking along the lines of clarity

[23:45:58.0568] <annevk>
Domenic: can you rubberstamp https://github.com/whatwg/html/pull/8889?

[01:06:16.0305] <regina_hallad>
Hi 👋

Most people would love
to get started online
working from home...

...but they don't know what
to do or where to start.

Here's a simple solution:

CLICK HERE to be take to the site which will change your life.
👇 👇 👇 
https://t.me/Stevecoldham001

[05:33:53.0163] <Noam Rosenthal>
Domenic: I've received this script `deferred` question you might have some historical insight on... is there a spec/compatibility reason to run all deferred scripts in the same task like we do? Splitting them to a-task-per-script can remove some blockage

[05:36:20.0069] <Noam Rosenthal>
In the spec we "spin the event loop" before each script, which IIUC is the equivalent of an `async await`, so adding a task barrier between steps would still be per spec (though perhaps should become the standard). 

[06:20:14.0747] <annevk>
Noam Rosenthal: spinning means other tasks can already go inbetween

[06:22:35.0398] <annevk>
TabAtkins: CI is still failing on the ID stuff

[06:23:26.0957] <Noam Rosenthal>
annevk: yes, that's how I understand it spec-wise. But seems like all implementations execute those scripts in the same task if they're ready

[06:42:51.0883] <Noam Rosenthal>
Jake Archibald: you probably have some context about ^^^

[06:48:09.0836] <Ms2ger>
annevk: could you take a look at https://github.com/WebAssembly/spec/pull/1537?

[07:03:46.0840] <TabAtkins>
> <@annevk:matrix.org> TabAtkins: CI is still failing on the ID stuff

Which specs? Still Fetch?

[07:09:42.0758] <annevk>
TabAtkins: yeah, when I wrote that https://github.com/whatwg/fetch/pull/1564 had just completed again

[07:10:16.0093] <TabAtkins>
That's quite bizarre, I'll check it out in about an hour.

[07:10:27.0681] <annevk>
TabAtkins: if you want to play there's also https://github.com/whatwg/fetch/pull/1605, I can give you write access if that would help

[07:11:10.0999] <TabAtkins>
Okay you're not actually running the new code.

[07:12:13.0735] <TabAtkins>
Ah I haven't cut the new version yet, duh, I was waiting on my own CI

[07:13:39.0853] <TabAtkins>
Looks like we are indeed passing now, gimme five seconds, then the server a few minutes to update.

[07:19:05.0034] <annevk>
An okay, so krosylight was correct

[07:19:13.0833] <annevk>
Ms2ger: done

[07:23:53.0114] <Ms2ger>
Damn, now I need to think :)

[07:27:19.0097] <annevk>
Ms2ger: in retrospect Wasm being so strict was maybe not the best idea, but changing it now is likely involved as well

[07:28:20.0801] <Ms2ger>
I decline to have an opinion on that :)

[07:39:58.0772] <annevk>
At this point I also suspect that it would be better if header list's get always did an isomorphic decode, but I don't wanna drive that change

[12:54:30.0983] <TabAtkins>
OKAY, I don't know *why* Bikeshed's 3.11.8 didn't work (it has all the files, and my local version finds the paths as expected) but 3.11.9 DOES work, and is installed on the API server now.


2023-02-17
[16:57:56.0251] <sirisian>
Domenic: I noticed you're in a lot of the focus/dialog issues, so maybe you'll know this. https://jsfiddle.net/9pwdjr38/3/ This is consistent on both FF and Chrome. The behavior seems unusual to me though. I assume it's part of the spec though?

[18:14:47.0440] <Domenic>
> <@noamr:matrix.org> Domenic: I've received this script `deferred` question you might have some historical insight on... is there a spec/compatibility reason to run all deferred scripts in the same task like we do? Splitting them to a-task-per-script can remove some blockage

No real context, but I know some Chrome people (including Hiroshige who I think you know) who have poked at script execution timing a lot, and they might have better insight.

[18:17:55.0125] <Domenic>
> <@sirisian:matrix.org> Domenic: I noticed you're in a lot of the focus/dialog issues, so maybe you'll know this. https://jsfiddle.net/9pwdjr38/3/ This is consistent on both FF and Chrome. The behavior seems unusual to me though. I assume it's part of the spec though?

This seems to be related to the changes made in https://github.com/whatwg/html/pull/6531 , which I personally thought was a bad idea but a lot of people preferred. Might be worth filing a bug to see if the people involved are willing to change again.

[18:18:49.0940] <Domenic>
I'm not sure shadow DOM is doing any work in your example, I think you would get the same behavior without it

[18:19:07.0366] <Domenic>
Maybe that change is just especially bad for non-modal dialogs.

[18:57:46.0744] <sirisian>
Good call. https://jsfiddle.net/sirisian/9f7t5pbm/ This is weirder than I thought. It is calling pointerdown.

[18:58:36.0539] <sirisian>
I'm opening an issue about this with this example. Will expand on the bullet points though.

[19:03:08.0045] <sirisian>
Whoops, forgot to set pointerdown to once. Analyzing this more.

[19:09:56.0219] <sirisian>
 * The main thing is it saves the last focus on show which is annoying when you want the focus to be able to change. (I haven't looked into popover much). I'll still open an issue as this is an unfortunate default behavior for non-modals. https://jsfiddle.net/sirisian/9f7t5pbm/1/

[00:34:51.0906] <annevk>
sirisian: make sure to at mention all the relevant people

[00:35:49.0388] <sirisian>
Yeah, was wondering about that. Saw domenic did it immediately. Now to wait patiently for a year.

[00:37:18.0703] <annevk>
If it's any consolation, I started pushing for URL Interop in 2012 or so. We might be getting somewhere this year.

[03:17:11.0143] <Ms2ger>
annevk: ugh, forgot to save the file before pushing like an idiot 🙈

[03:30:38.0831] <annevk>
Ms2ger: ooh I was wondering what happened there, heh

[05:03:58.0371] <Ms2ger>
(I blame TabAtkins - if my local bikeshed install wasn't being difficult, I'd have noticed)

[07:45:45.0792] <annevk>
Refactoring reflection is rather sleep-inducing. I might also just be tired

[08:04:38.0076] <annevk>
zcorpan: what's the difference between "limited to only non-negative numbers greater than zero with fallback" and "limited to only non-negative numbers greater than zero with fallback"?

[08:04:53.0720] <annevk>
zcorpan: they can both have a default value so this seems kinda pointless?

[08:08:26.0127] <annevk>
Never mind, it's the setter!

[08:11:59.0016] <jgraham>
(I choose to believe this would be less confusing if you hadn't written "what's the difference between (two identical strings)", which was presumably not the intent :)

[08:12:23.0742] <annevk>
Haha the former should not have "with fallback"

[08:52:52.0517] <Ms2ger>
Do we still have blame for the html spec somewhere?

[09:02:06.0218] <evilpie>
> <@ms2ger:igalia.com> Do we still have blame for the html spec somewhere?

Maybe searchfox could work?

[09:03:56.0762] <Ms2ger>
Good idea, thx

[09:11:00.0872] <annevk>
Yeah, that's why it's in searchfox


2023-02-18
[23:11:26.0164] <krosylight>
> <@annevk:matrix.org> Yeah, that's why it's in searchfox

TIL, where can I find it? 👀

[23:25:50.0373] <annevk>
krosylight: it's linked from the whatwg/html README and from the searchfox website, enjoy!


2023-02-20
[01:42:05.0121] <misty1peters2022>
Two.txt

[04:03:35.0768] <Andreu Botella>
Why is it that `Set-Cookie` headers are never exposed on `Response` objects?

[04:04:42.0307] <Andreu Botella>
https://jakearchibald.com/2021/cors/ says this is to avoid leaking cookies across sites, but that doesn't explain why they're not exposed even for same-origin fetches (since you can observe the cookies either way with `document.cookie`)

[04:06:17.0006] <Andreu Botella>
I'm also not convinced it would leak anything for third-party origins/sites, since the request is made without credentials, and any `Set-Cookie` headers wouldn't make it into the cookie jar either way

[04:08:02.0023] <Andreu Botella>
Same for not allowing authors to add `Cookie` headers to requests

[04:08:23.0369] <Andreu Botella>
A use case for allowing it would be "faking" a third-party-site/origin cookie jar

[04:38:17.0327] <annevk>
Andreu Botella: are you familiar with HttpOnly cookies?

[04:38:46.0653] <Andreu Botella>
oh, that's right

[04:47:40.0003] <Andreu Botella>
I'd completely forgotten `HttpOnly` cookies existed 😅

[05:35:05.0552] <annevk>
HTML has this note under reflecting of an `unrestricted double`: "The values Infinity and Not-a-Number (NaN) values throw an exception on setting, as defined in Web IDL."

[05:35:14.0069] <annevk>
I guess that's wrong given https://webidl.spec.whatwg.org/#es-unrestricted-double?

[05:37:11.0186] <annevk>
Wow, `unrestricted double` is older than I thought, Hixie-era

[05:44:50.0032] <annevk>
Well, there are no reflected attributes using it, so I guess I'll remove it

[08:08:45.0900] <annevk>
Can I interest anyone else in reviewing a refactor of reflection? Domenic did a couple earlier rounds and I just did self-review: https://github.com/whatwg/html/pull/8496

[08:09:44.0512] <annevk>
Also, if someone can come up with enumerated attribute IDL syntax for https://github.com/whatwg/html/issues/3238 that would be really cool

[09:04:50.0614] <Jake Archibald>
annevk: the service worker spec wants to abort one fetch if another is aborted. Right now it's referring to `[=fetch controller/state=]` which isn't exported. Should I create a PR to export that, or is there a 'proper' way to listen for that state change?

[09:08:54.0309] <Jake Archibald>
https://github.com/whatwg/fetch/pull/1608 PR for that

[09:10:21.0959] <Yagiz Nizipli>
For anybody interested, I'm trying to bench all existing WHATWG supported URL parsers in Ada. I've added servo/url, whatwg (c++), curl. Do you know any other available standard compliant parsers? Referencing: https://github.com/ada-url/ada/pull/223

[09:11:51.0754] <Yagiz Nizipli>
(Curl does not follow whatwg, but widely used)

[09:12:23.0925] <annevk>
I think curl isn't interested in complying with any spec... But does like to make a lot of noise whenever following the WHATWG would have helped them.

[09:12:57.0329] <Yagiz Nizipli>
Yes, Curl is following RFC 3986 with additional quirks

[09:28:48.0724] <annevk>
It is? I thought it was mostly garbage in, garbage out

[09:29:50.0948] <Yagiz Nizipli>
Referencing docs: "curl recognizes a URL syntax that we call "RFC 3986 plus". - https://curl.se/docs/url-syntax.html

[09:30:44.0466] <annevk>
rego: smaug: would appreciate your input on https://github.com/whatwg/html/issues/8545

[09:39:21.0804] <zcorpan>
annevk: the expando surviving or not surviving could be done similarly to https://dom.spec.whatwg.org/#concept-getelementsbytagname ? i.e. allow it to be GCed even if it has an expando

[09:41:23.0551] <annevk>
zcorpan: that makes GC observable and ideally we wouldn't do that I think

[10:23:42.0000] <zcorpan>
annevk: right


2023-02-21
[23:07:58.0808] <annevk>
Domenic: now I wonder what happens when you assign to a long and it's out-of-range

[23:09:03.0304] <Domenic>
annevk: The setter will never receive it, but yeah if you have `contentattribute="1111111111111111111111111"`... I suspect that does fall back to the default, but I wonder.

[23:09:49.0834] <annevk>
Domenic: oh right, it's because all the magic is in the getters that we can't rely on Clamp and such, meh

[23:11:12.0721] <annevk>
Although, maybe if ConvertToInt took EnforceRange and Clamp as arguments of sorts we could actually be using that

[23:16:58.0764] <annevk>
It would be nice to investigate if we could have fewer number parsers, but that would be a hell of a yak shave for this project, probably worth at least a follow-up issue though

[23:19:14.0750] <annevk>
Domenic: I was also thinking that we could express enumerated attribute tables as two arrays/sets in Web IDL, but it might get rather unwieldy and we'd have two sources of information; arguably that's the case with something like [ReflectURL] as well, but that would make it pretty glaring

[23:20:03.0409] <Domenic>
Yes, I have had similar thoughts. However I believe most engines have some sort of IDL for enumerated attributes. It doesn't match the spec's model that well, but somehow gives the same observable results.

[23:21:06.0817] <Domenic>
I think maybe it only takes care of the getter/setter behavior and doesn't take care of producing a "state" which the rest of the spec/implementation can consult?

[23:21:07.0541] <annevk>
Hmm, perhaps with some custom logic for the bad cases? I guess we need to look into that first then.

[23:21:36.0327] <Domenic>
So like you don't need to identify that "rect" and "rectangle" both go to the same state, in the IDL.

[23:22:08.0909] <annevk>
Hmm, but if you set to one you get the other back, right? You'd have to encode that somehow.

[23:23:13.0839] <Domenic>
Ah, only if "limited to only known values", and area's shape="" is not one of those...

[23:23:15.0740] <Domenic>
Let's see...

[23:24:04.0297] <annevk>
I gotta go for a bit, prolly back when you're away, but happy to see a thought dump 😀

[23:26:50.0681] <Domenic>
In Chromium at least it appears to be all hacks that are just enough to work with the spec's current model. There's a special ReflectEmpty which you can use for cases where the empty string maps to another keyword and is not the canonical keyword. If we ever created something that was both (a) limited to only known values; and (b) had two non-empty-string values mapping to a single state, Chromium would be unable to cope.

[23:45:47.0074] <Ms2ger>
Or would need to hack around it some more :)

[23:47:28.0497] <Domenic>
Right, or just write custom bindings. It's just sad that there's no ready-made answer waiting for us that fits with the spec's model.

[00:29:59.0997] <annevk>
Domenic: on the other hand, maybe we shouldn't add such stuff?

[01:40:39.0595] <annevk>
So clamping doesn't affect the setter steps apparently. How is that even useful? The getter will give you 1000, but the content attribute (which carries the semantics, supposedly) will indicate 5000 or whatever it was set to...

[01:41:10.0228] <annevk>
Some of this stuff we should probably prefix with legacy to discourage further usage of.

[03:24:50.0400] <Domenic>
Did you test the setter in implementations? I don't really trust the spec very much...

[04:58:04.0305] <annevk>
Domenic: yeah I did

[04:58:33.0694] <annevk>
Domenic: and I guess it makes some sense because you cannot constrain `setAttribute()` anyway, but still, it all seems rather awkward

[05:00:18.0019] <annevk>
Domenic: there is definitely some redundancy in the specification around clamping, the default value concept, positive numbers; I think we could simplify that somewhat and at the very least remove some redundancy here and there, but would prefer to sort that out as a follow-up to ease review and make it clearer to future people where we made mistakes

[06:57:54.0846] <littledan>
> <@annevk:matrix.org> Andreu Botella: are you familiar with HttpOnly cookies?

Just to check my understanding: the reasoning here is, there isn't much point in exposing an API only for non-HttpOnly cookies since we're encouraging a move towards those anyway for security purposes?

[07:00:28.0216] <Ms2ger>
I thought the issue was that `response.headers.get("Set-Cookie")` would expose cookies to scripts that shouldn't be

[07:00:59.0445] <zcorpan>
Domenic: are we changing how html numbers in attributes are parsed?

[07:01:57.0214] <Andreu Botella>
I guess you could filter `Set-Cookie` headers depending on whether they are `HttpOnly`, but that would mean parsing the header at filter time, which could cause parsing differences to result in XSS I guess

[07:03:20.0399] <Ms2ger>
Does `response.headers` do any normalization right now?

