2025-06-02
[21:43:16.0915] <jmdyck>
In https://html.spec.whatwg.org/#steps-to-expose-a-media-resource-specific-text-track, under MPEG-4, there are a couple occurrences of roughly "the concatenation of A, B, and C, or D if condition". It's unclear what the 'scope' of the "or" is. Is it (A+B+C) or (D)? Or is it A+B+(C or D)?

[06:26:21.0725] <zcorpan>
Domenic: fyi https://www.debugbear.com/blog/google-blocked-website

[09:27:17.0733] <jmdyck>
I looked for how browsers implemented that paragraph, but haven't yet found one that does.

[09:27:55.0418] <jmdyck>
* I looked for how browsers implemented that MPEG-4 paragraph, but haven't yet found one that does.

[10:21:26.0113] <jmdyck>
Looks like Hixie added it in 2012 (d485159e) and it hasn't been touched much since then.

[10:41:03.0251] <Ms2ger (🇪🇸)>
I have an open PR that I need to get back to to clean up that algorithm a bit, but I don't touch that part

[11:13:15.0951] <TabAtkins>
Testing would be good to verify, but I'm 95% certain that "or" is tightly bound, so it's just "C or D". The C is always "the first FOO field" and the D condition is"if there is no FOO field", so it's extremely likely that the D (always an empty string) is providing a default for the missing C case.

[12:33:45.0518] <jmdyck>
Testing implementations? You'd first have to find one that implements that chunk of the spec, and I'm doubtful there is one. (I don't think anything in WPT calls inBandMetadataTrackDispatchType, so you can't find implementations that way.) And then you'd need to find or create an MPEG-4 file that triggered the condition in question.

[12:39:23.0399] <jmdyck>
The A+B+(C or D) interpretation is 'better' in that it distinguishes more cases. But it seems odd to me that a dispatch type could have a trailing space.

[12:47:37.0644] <TabAtkins>
Oh, you know what, you're right, I misread. This is absolutely `(A + B + C) or D`, I was being silly. So you get either `"metx FOO"` or `""` (or whatever, for the other field names).

[12:48:00.0809] <TabAtkins>
Anyway, 100% needs a rewrite

[14:37:27.0217] <jmdyck>
Wouldn't have to be a rewrite to disambiguate: you can establish the left edge of the or's scope just by inserting an "either". But a bigger rewrite could improve the readability. (It's interesting that the source, with its judicious linebreaks, is more readable than the rendered spec.) OTOH, if nobody is implementing it, maybe it's not worth the bother.

[14:59:21.0244] <TabAtkins>
I've committed the same sins when writing before, precisely because my source linebreaks make it clearer, and it's more ambiguous when rendered inline instead :/

[14:59:34.0151] <TabAtkins>
But anyway, it's the work of like a minute to fix.


2025-06-03
[04:09:42.0503] <freddy>
The `<xmp highlight="json">` looks really fugly in https://w3c.github.io/webappsec-subresource-integrity/#example-2319c0a9 (Source at https://github.com/w3c/webappsec-subresource-integrity/blob/2089aeb95782970d35f96283d1f3da89beaa8802/index.bs#L721). Looking at the bikeshed docs for `<xmp>` didn't really help me, anyone got a better idea?

[06:15:52.0378] <Ms2ger (🇪🇸)>
That highlighting sure didn't work for json

[06:42:45.0070] <Noam Rosenthal>
Anyone from Gecko/WebKit cares to respond to a standard position on navigation API precommit handlers? The spec PR is pretty much ready (https://github.com/whatwg/html/pull/10919) and the standard position requests are pending..

It's a minor/medium sized addition to the navigation API that was requested by multiple early adopters and frameworks.

/cc zcorpan annevk 

[14:51:07.0012] <TabAtkins>
Lol woah, what the fuck happened with that highlighting.

[14:56:16.0957] <TabAtkins>
Ah, that's not actually valid JSON (JSON uses double quotes), so it's making the lexer just do some nonsense behavior.

[14:57:00.0591] <TabAtkins>
(Aside from webidl, highlighting is done by Pygments, btw)

[15:17:48.0294] <TabAtkins>
https://github.com/w3c/webappsec-subresource-integrity/pull/139


2025-06-04
[19:46:43.0441] <Domenic>
It's interesting that popular syntax highlighters have generally chosen to be kind of loose and produce nonsense output in the face of nonsense input. For some cases, like writing specs, having them be strict would be quite useful---bonus syntax checking in your build process. But for cases like writing GitHub comments, I guess you want loose.

[00:24:08.0336] <freddy>
thanks TabAtkins 

[00:29:52.0146] <TabAtkins>
> <@domenicdenicola:matrix.org> It's interesting that popular syntax highlighters have generally chosen to be kind of loose and produce nonsense output in the face of nonsense input. For some cases, like writing specs, having them be strict would be quite useful---bonus syntax checking in your build process. But for cases like writing GitHub comments, I guess you want loose.

An issue is handling new syntaxes. Strict parsing means you'll break if there's an update to the language, or someone uses it on a proposal for something new, or someone is highlighting a fragment of syntax that you didn't expect them to start on, etc.

Strict also requires a Real Parser, whereas I know the Pygments model is a pile of regexes, at least by default. That's simpler for most people to author.

[00:30:09.0999] <TabAtkins>
That says, the failure mode here was *weird*

[00:30:19.0859] <TabAtkins>
* That said, the failure mode here was *weird*

[07:40:29.0172] <Luke Warlow (🇪🇸)>
jarhar: regarding ToggleEvent.source tests, The spec PR is merged but the tests still seem to be tentative to me, is there a PR to update them?

[09:06:21.0481] <jarhar>
https://chromium-review.googlesource.com/c/chromium/src/+/6621684


2025-06-05
[19:49:12.0746] <Domenic>
annevk: do you know if request's URL list is used for anything "after fetch"? Or would it be an unobservable change for the ecosystem, if we were to truncate it to just « the final URL » at the end of the fetch algorithm?

(Context: some gnarly prefetch algorithm stuff.)

[23:23:47.0966] <annevk>
Request’s `url` has to return the first URL. But in general something like that could probably work. I wonder if we can move the construct to the controller to clarify.

[09:17:15.0233] <Eric Portis (he/him)>
Noam Rosenthal: Why is there a blocking attribute on <style>? Aren't <style>s in the <head> already render-blocking? https://html.spec.whatwg.org/multipage/semantics.html#dom-style-blocking

[09:21:20.0716] <zcorpan>
Eric Portis (he/him): https://html.spec.whatwg.org/multipage/semantics.html#the-style-element:implicitly-potentially-render-blocking:~:text=A%20style%20element%20is%20implicitly%20potentially%20render%2Dblocking%20if%20the%20element%20was%20created%20by%20its%20node%20document%27s%20parser

[09:23:36.0542] <Eric Portis (he/him)>
zcorpan: What can create an element besides the node-document's parser? Script?

[09:24:22.0895] <zcorpan>
Eric Portis (he/him): yes. or you can move a parser-created element from one document to another document

[09:25:37.0908] <Eric Portis (he/him)>
Ok. And in those scenarios, the <style> is not render-blocking. Even if the script that's moving or creating the <style> is  synchronous/in-the-head?

[09:25:50.0093] <zcorpan>
I don't know what happens in an XSLT transform

[09:26:19.0370] <zcorpan>
Right

[09:26:53.0112] <Eric Portis (he/him)>
But if a <script> creates a <script blocking=render> in the head, it *is* render blocking.

[09:28:58.0955] <zcorpan>
I assume you mean it creates `<style blocking=render>`, then yes

[09:53:50.0040] <Eric Portis (he/him)>
@zcorpan: here's my current understanding based on our conversation, and earlier conversations with Noam Rosenthal . https://gist.github.com/eeeps/318812c9d4471136363a6aaa4a448251 Happy to wait until June 16th to understand where I'm wrong btw (:

[09:54:05.0149] <Eric Portis (he/him)>
* @zcorpan : here's my current understanding based on our conversation, and earlier conversations with Noam Rosenthal . https://gist.github.com/eeeps/318812c9d4471136363a6aaa4a448251 Happy to wait until June 16th to understand where I'm wrong btw (:

[09:54:56.0758] <Eric Portis (he/him)>
* zcorpan (OOO until June 16): here's my current understanding based on our conversation, and earlier conversations with Noam Rosenthal . https://gist.github.com/eeeps/318812c9d4471136363a6aaa4a448251 Happy to wait until June 16th to understand where I'm wrong btw (:

[09:57:45.0593] <Noam Rosenthal>
What's on June 16th?
This gist seems right to me

[09:57:58.0022] <Noam Rosenthal>
I believe the "no idea" bit is not render-blocking

[09:58:10.0229] <Eric Portis (he/him)>
(when Simon's OOO ends)

[09:59:17.0073] <Eric Portis (he/him)>
Noam Rosenthal: Thanks!

[11:39:59.0370] <Eric Portis (he/him)>
Noam Rosenthal: a review would be appreciated https://github.com/mdn/content/pull/39809

[11:55:52.0809] <zcorpan (OOO until June 16)>
Eric Portis (he/him): I think that's correct

[11:57:42.0733] <zcorpan (OOO until June 16)>
There are tests here https://wpt.fyi/results/html/dom/render-blocking?label=master&label=experimental&aligned&q=%2Fhtml%2Fdom%2Frender-blocking%2F

[12:00:20.0242] <Noam Rosenthal>
Nice work! Added a few comments.

[15:42:30.0322] <Eric Portis (he/him)>
Noam Rosenthal: Comments are super helpful, thank you! Hope to make some time to address them tomorrow.


2025-06-07
[17:48:14.0744] <Sam Sneddon [:gsnedders]>
What's the intention of things like fingerprinting warnings? I _guess_ these aren't intended to be complete, but e.g. if you read https://html.spec.whatwg.org/multipage/interaction.html#interaction-with-details-and-hidden=until-found you might think "hmm maybe we should suppress the toggle event" if you were trying to mitigate this, not realising that the beforematch event also provides a similar threat.

[02:18:27.0856] <annevk>
I think the main aim is to catalogue them, see also https://infra.spec.whatwg.org/#privacy


2025-06-09
[04:47:44.0652] <Andreu Botella>
I've found a case where `<wbr>` renders differently in different browsers, and once again I'm wondering why `<br>` and `<wbr>` are still specified in terms of `display-outside`, which is not part of CSS currently, and which I doubt was ever in a published CSS standard

[04:48:21.0108] <Andreu Botella>
* I've found a case where `<wbr>` renders differently in different browsers, and once again I'm wondering why the rendering of `<br>` and `<wbr>` is still specified in terms of `display-outside`, which is not part of CSS currently, and which I doubt was ever in a published CSS standard

[05:06:26.0453] <akaster>
> <@abotella:igalia.com> I've found a case where `<wbr>` renders differently in different browsers, and once again I'm wondering why the rendering of `<br>` and `<wbr>` is still specified in terms of `display-outside`, which is not part of CSS currently, and which I doubt was ever in a published CSS standard

Isn't that <https://github.com/whatwg/html/issues/2291> ? I don't know that anyone actually knows how to spec those elements properly

[05:09:03.0323] <Andreu Botella>
Surely we can do better than using non-existent CSS property

[05:09:38.0132] <akaster>
Oh I guess Domenic: has this old PR that specifies them as "UA magic 🪄" https://github.com/whatwg/html/pull/2298

[05:10:31.0809] <Domenic>
It might be good if someone resurrects that to just add a bunch of XXX boxes, instead of using CSS.

[05:10:41.0767] <Domenic>
I guess the main open question is what CSS properties apply to those elements

[05:12:02.0517] <Domenic>
Hmm I feel like that PR is somewhat mergeable as-is, reviewing its contents. Maybe just change one `<p>` to `<p class="XXX">`. I think I just wasn't confident enough in my new editorship in 2017 to feel comfortable merging it.

[05:12:23.0137] <Domenic>
If someone resurrects it I can review and merge.

[05:14:48.0715] <nicolo-ribaudo>
Lol, Element is not escaping the br in that link preview title

[05:25:52.0554] <Andreu Botella>
The rendering difference I found is that, with inherited `white-space: nowrap`, `<wbr>` in Chromium allows line breaking, but it doesn't in Firefox or Webkit

[05:25:55.0035] <Andreu Botella>
there's a parallel to `nobr wbr { white-space: normal }`

[05:26:26.0117] <Andreu Botella>
but we can figure this out after the magic PR is merged

[06:51:34.0956] <Domenic>
That may be https://github.com/whatwg/html/issues/6227


2025-06-10
[18:29:18.0417] <james7474>
Join BlackHat_Nexus – Trusted by Over 23,000 Subscribers
Your reliable hub for Cybersecurity, Digital Recovery, and Tech Support Services.
We provide fast, secure, and confidential solutions for a wide range of digital challenges—trusted by individuals and businesses worldwide Our Expert Services Include:      
  🔐 Account Recovery – Email, Social Media, Crypto Wallets
💼 Digital Investigations & Fund Recovery – Lost funds, scam cases
📱 Lost Device Tracking – Phones, Laptops, Vehicles
🧠 Password Recovery & Access Support – Secure, consent-based assistance
🛡️ Cybersecurity Consultations – Protect your digital identity
🧰 System Troubleshooting – Windows, Android, iOS
🌐 Website Security Audits – Vulnerability detection & protection
🎓 Academic Access Support – Authorized educational record recovery
📡 Network Security Testing – Wi-Fi & CCTV configuration & checks
👁️‍🗨️ Ethical Monitoring Solutions – Discreet and compliant digital oversight
---

Why Choose Us?
✅ Fast, Professional Response
✅ 24/7 Availability
✅ Confidential & Secure Handling
✅ Experienced Digital Experts


---

Join us today and secure your digital world.
https://t.me/BlackHat_Nexus




[07:58:44.0953] <gogo>
Hello. I want to document the latest version of the w3c parser for finding client side vulnerabilities.

I started with a DOM XSS using the RFC of the parser with element.innerHTML = "XSS";. My goal is to have the syntax possible for each XSS possible. 

I started with:

https://html.spec.whatwg.org/multipage/parsing.html#overview-of-the-parsing-model

according to the schema, the loop starts at the HTML tree builder at https://github.com/WebKit/WebKit/blob/main/Source/WebCore/html/parser/HTMLTreeBuilder.cpp#L816 and then 


I am wondering if according to the code at https://github.com/WebKit/WebKit/blob/2246a2aa28d527e129ebec66183569db035fdc8a/Source/WebCore/dom/Element.cpp#L4347 , the policy of innerHTML could deny to execute a script even if not sanitized. I need to find the parser location to see the grammar syntax for potential XSS as mentrionned there: https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-element-innerhtml .

Is Elements::replaceChildrenWithMarkup the parser please?

[08:28:30.0863] <akaster>
if you're looking for the HTML parser, have you tried looking in the directory called "html/parser" ? https://github.com/WebKit/WebKit/tree/main/Source/WebCore/html/parser

[08:32:34.0216] <akaster>
also your definition of XSS doesn't seem to make much sense. in what way is javascript code that calls the innerHTML setter of an arbitrary element a cross-site  scripting vulnerability?

[08:38:10.0577] <gogo>
Yes I did. I mentionned it for parser/element webkit folder.

[08:44:47.0669] <gogo>
To clarify technically:

Element.innerHTML = "<script>alert(1);</script>";

Will not execute contrary to:

Element.innerHTML = "<img src='error' onerror='alert(1);'>";

That will print the 1.

[08:45:22.0849] <gogo>
In this contextvi need the parser code of policy/ parser of innerHTML output

[09:00:10.0316] <Luke Warlow>
you're setting JavaScript code to a HTML sink, if you wrap it in a script element it will execute (I think)

[13:37:37.0953] <gogo>
no. It will not. Sanitization is *one* of the securing methodologies. Check out at https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-innerhtml-sink to see what you must do with the syntax to make it run.

[13:37:44.0954] <gogo>
* wrong. It will not. Sanitization is _one_ of the securing methodologies. Check out at https://portswigger.net/web-security/cross-site-scripting/dom-based/lab-innerhtml-sink to see what you must do with the syntax to make it run.

[14:16:21.0368] <TabAtkins>
Domenic or annevk : Would be really useful to have one of y'all comment on https://github.com/tc39/proposal-idl/issues/8 about the history of getting W3C to be able to refer to WHATWG specs (so ECMA can do the same).

[14:28:19.0526] <gogo>
element.innerHTML = "XXX"; calls setInnerHTML at 

[14:28:28.0500] <gogo>
https://github.com/WebKit/WebKit/blob/main/Source/WebCore/dom/Element.cpp#L4347

[16:30:19.0023] <Domenic>
There isn't much to say. One day W3C decided to stop self-inflicting problems on themselves. SDOs can set their own policies. Ecma can decide at any time what it wants, and TC39 has a lot of power over Ecma since it's the main spec Ecma produces.


2025-06-11
[00:16:27.0253] <gogo>
> <@gogo2464:matrix.org> Hello. I want to document the latest version of the w3c parser for finding client side vulnerabilities.
> 
> I started with a DOM XSS using the RFC of the parser with element.innerHTML = "XSS";. My goal is to have the syntax possible for each XSS possible. 
> 
> I started with:
> 
> https://html.spec.whatwg.org/multipage/parsing.html#overview-of-the-parsing-model
> 
> according to the schema, the loop starts at the HTML tree builder at https://github.com/WebKit/WebKit/blob/main/Source/WebCore/html/parser/HTMLTreeBuilder.cpp#L816 and then 
> 
> 
> I am wondering if according to the code at https://github.com/WebKit/WebKit/blob/2246a2aa28d527e129ebec66183569db035fdc8a/Source/WebCore/dom/Element.cpp#L4347 , the policy of innerHTML could deny to execute a script even if not sanitized. I need to find the parser location to see the grammar syntax for potential XSS as mentrionned there: https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-element-innerhtml .
> 
> Is Elements::replaceChildrenWithMarkup the parser please?

Could I ask again for the setinnerhtml parser please?

[00:17:02.0473] <gogo>
> <@gogo2464:matrix.org> Could I ask again for the setinnerhtml parser please?

I need the policy parser

[06:42:28.0205] <annevk>
If anyone wanted to review https://github.com/whatwg/html/pull/10548 before it lands, now would be a very good time.

[06:59:36.0635] <jmdyck>
gogo: Re "the setinnerhtml parser": You linked to  https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-element-innerhtml . So 2 lines down from that is "Element's innerHTML setter steps" (which refer to "the fragment parsing algorithm steps", which refer to "the HTML fragment parsing algorithm", etc). Does that answer your question? If not, could you be more specific?

[07:00:12.0369] <annevk>
Luca Casonato: https://github.com/whatwg/webidl/pull/1489

[07:10:53.0670] <gogo>
yes. I showed you a link of my previous work. In 1000 pages, I showed you the link I finally found. I need:
- to know if the policy parser could ignore not sanitized scripts
- if responsible, I need the policy parser

[07:51:32.0428] <annevk>
Luke Warlow keithamus smaug: based on the discussion we had last week, are https://github.com/whatwg/html/pull/11255 and https://github.com/whatwg/html/pull/11345 still accurate or will they need changes? Per my recollection I think they match what we wanted in the end. Which was not composed, retargeted, and no further changes to event dispatch for referencetarget. (Olli was not in the room, but I'd like to make sure he agrees so maybe Keith can chat with Olli or some such.)

[07:52:32.0154] <Luke Warlow>
> <@annevk:matrix.org> Luke Warlow keithamus smaug: based on the discussion we had last week, are https://github.com/whatwg/html/pull/11255 and https://github.com/whatwg/html/pull/11345 still accurate or will they need changes? Per my recollection I think they match what we wanted in the end. Which was not composed, retargeted, and no further changes to event dispatch for referencetarget. (Olli was not in the room, but I'd like to make sure he agrees so maybe Keith can chat with Olli or some such.)

I think that's correct those two things should be enough.

[07:53:10.0331] <gogo>
I need to understand why are not executed the <script> tag after innerHTML while not sanitized and while <img onerror="alert(1)">*

[08:04:16.0653] <akaster>
> These properties' setters perform no sanitization to remove potentially-dangerous elements and attributes like script or event handler content attributes.

setting an element's innerHTML to untrusted input is a horrible idea in any case. it's almost guaranteed to lead to the problems like the ones outlined in your lab. There are better ways to dynamically add elements to the page than blindly treating a string from the network as html markup.

[08:06:29.0923] <gogo>
Yes. I stated it.

What is the other way to secure with no sanitization please? 

[08:06:37.0723] <gogo>
* Yes. I agree with it.

What is the other way to secure with no sanitization please? 

[08:08:37.0956] <akaster>
for that simple example of a search form? you could do something trivial like `document.createTextNode` and then `appendChild` that to the responsible div. or call the textContent setter on something but usage questions like this are out of scope for this forum

[08:09:18.0417] <akaster>
* for that simple example of a search form? you could do something trivial like `document.createTextNode` and then `appendChild` that to the responsible div. or call the textContent setter on something. But in general usage questions like this are out of scope for this forum

