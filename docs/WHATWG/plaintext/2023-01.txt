2023-01-02
[16:38:43.0996] <sideshowbarker>
https://stackoverflow.com/questions/74978033/how-should-this-erroneous-html5-be-parsed-where-should-the-end-tag-be-inserte

[00:55:14.0015] <annevk>
jugglinmike: jgraham: can either of you tackle https://github.com/w3c/webdriver-bidi/issues/347?

[01:00:25.0469] <annevk>
kblom3: frank-dspeed: while we're not super strict regarding what is on and off topic, this channel is generally intended for discussions about web standards, and primarily WHATWG standards.

[02:18:21.0506] <frank-dspeed>
i guess your correct i am still struggling with correcting my mind model but your right it was my failure this channel is only about WHATWG related stuff not about internet or web or browsers and WHATWG is a standard that is open to get used by people who like it and ignored by people who do not agree with it 

[02:19:51.0228] <frank-dspeed>
i want to apologice for that it is really a missconception in my mind because as i was a kid i expected internet to be equal to WHATWG 

[02:20:58.0635] <frank-dspeed>
and that was still holding me back i need to pray to my self that browsers are not related to whatwg as it is a indipendent free standard without any affilation to real world

[02:32:38.0355] <frank-dspeed>
the real world is equal to the browsers dom api's and HTML is just a syntax that can get translated to it so it is a declarativ instruction set a language not more not less 

[02:33:42.0210] <frank-dspeed>
frameworks like react circumvent the WHATWG standard total while still use the term html which is maybe also missleading

[03:36:27.0610] <Andreu Botella>
I'm currently setting up a personal blog, and I thought I'd cross-publish my post from the WHATWG blog on newline normalization in forms (https://blog.whatwg.org/newline-normalizations-in-form-submission)

[03:36:29.0531] <Andreu Botella>
and as part of that, I noticed there's a code sample in that post that uses the `DataTransfer` hack for setting an `<input type="file">`'s file list, with no explanation

[03:37:38.0106] <Andreu Botella>
I don't have edit permissions, but it'd be great to add even a one-line comment like
```js
// This is a hack to add files to an <input type="file"> from JS.
```

[03:38:10.0161] <Andreu Botella>
 * I'm currently setting up a personal blog, and I thought I'd cross-publish my post from the WHATWG blog on newline normalization in forms (https://blog.whatwg.org/newline-normalizations-in-form-submission)

[07:49:56.0397] <annevk>
Domenic: is putting effort into https://github.com/whatwg/url/pull/502 worth it? Would you implement it in whatwg-url?


2023-01-03
[17:58:51.0456] <Domenic>
annevk: I was thinking of doing it as a holiday project... and I still have 8 days of holiday in Japan. So, probably?

[17:59:46.0329] <Domenic>
"doing it" = "adding full validation error support to jsdom/whatwg-url"

[18:00:02.0317] <Domenic>
Which could then be extended pretty easily with named variants

[00:27:49.0056] <Noam Rosenthal>
annevk: with getting the "internal response" - do I need to do something like "if this is a filtered response, getting response's internal response, otherwise response" 

[00:31:35.0981] <Noam Rosenthal>
ok answered on the issue, thanks :)

[00:35:19.0403] <annevk>
Noam Rosenthal: if you find a place where that would be useful we should upstream HTML's unsafe response (perhaps if it's really useful for HTML we should do that anyway, but I still need to convince myself)

[00:36:05.0856] <Noam Rosenthal>
annevk: gotcha, will take a look

[00:55:19.0606] <annevk>
smaug: emilio: did you see my ping in https://github.com/whatwg/fullscreen/issues/149? If you all are still on break feel free to ignore, I'll try to remember to ping again

[02:17:23.0644] <emilio>
annevk: Yeah I think while retargetting would make some amount of sense, it's not really useful for fullscreen/pip

[02:18:09.0391] <frank-dspeed>
what was the exact usecase of shadow dom?

[02:18:25.0117] <frank-dspeed>
css encapsulating, offering slots?

[02:18:34.0557] <frank-dspeed>
what was the main driver does any one know that?

[02:21:29.0316] <frank-dspeed>
i mean i never used it for any usefull use case only for demos when i import css as ESModule so a CSSDeclaration Object and Object.assign(el.style, cssDeclaration)

[02:21:44.0550] <frank-dspeed>
i get cached compose able css that is applyed directly on the element

[02:22:48.0273] <frank-dspeed>
much less to write no id tag clashing nothing i do not even use ID or class when i programatical create html Elements a combo of document.create object.assign gives me total declarativ js syntax to compose elements and styles

[02:23:44.0804] <frank-dspeed>
i write whole app dependent component frameworks in less then 20 lines of code and complex elements with a lot of events like whole IDE Environments in 50 sloc

[02:26:45.0102] <frank-dspeed>
```js
const createComponent = (el = {}, componentDefinition = {}) => {
    Object.assign(el.style, componentDefinition.style);
    Object.keys(componentDefinition).filter((key) => key !== 'style')
        .forEach((key) => (el[key] = componentDefinition[key]));
    return el;
};
const appendNewComponent = (el,tagName, componentDefinition) => el.appendChild(
    createComponent(createElement(tagName),componentDefinition));

// End framework
    const controls = el.appendChild(document.createElement('ul'));          
    appendNewComponent(controls, 'button', { innerText: `${getChildIndex(el)}|+`, onclick: (ev) => {
        el.parentElement.appendChild(new Notebook());
    }, style: { color: "red" } }); 

 appendNewComponent(controls, 'input', { onclick: (ev) => {}, placeholder: `https://.....js`, value: ``, style: { color: "red" } });
    appendNewComponent(controls, 'button', { onclick: (ev) => {}, innerText: `FETCH`, style: { color: "red" } });
```

[03:25:34.0961] <smaug>
annevk: emilio yeah, I'm not sure retargeting the css state would be useful here.

[04:27:14.0492] <annevk>
smaug: emilio: could either of you elaborate in the issue as to why? Ryosuke seemed to think it was necessary still; I was hoping to avoid having to dive into it myself (I forgot the design rationale)

[04:34:28.0024] <emilio>
annevk: I guess the idea is that it'd be necessary to avoid exposing the existence of the shadow tree (so that you can't know if the element has a closed shadow tree if `document.fullscreenElement && !document.fullscreenElement.matches(":fullscreen")`)

[04:34:32.0245] <emilio>
 * annevk: I guess the idea is that it'd be necessary to avoid exposing the existence of the shadow tree (so that you can't know if the element has a closed shadow tree if `document.fullscreenElement && !document.fullscreenElement.matches(":fullscreen")`)

[04:34:56.0171] <emilio>
annevk: which is true, but it doesn't make much sense to style an ancestor of the fullscreen element based on it having a shadow descendant in fullscreen

[04:37:11.0730] <annevk>
emilio: maybe we should offer `:fullscreen-within` or something similar to the `:focus-within` thingie?

[04:47:45.0733] <annevk>
Oh, `:focus-within` is different. It would be more akin to how `:fullscreen` is defined per specification.

[04:48:00.0178] <emilio>
Right, that doesn't quite make much sense to me

[04:49:52.0336] <annevk>
Oh, so `:focus` should match the shadow host, but `:focus-visible` does not. How many focus-related pseudo-classes do we need?

[04:50:25.0323] <emilio>
Yeah, that focus retargetting is also slightly weird fwiw

[04:50:44.0653] <emilio>
but it's less problematic because what you really want to style is `:focus-visible` 99% of the time

[04:52:37.0183] <annevk>
I'm also confused as to how it helps as that still gives you a shadow host detector

[05:00:29.0671] <annevk>
Anyway, thanks emilio for the useful example. I'll chat a bit more with rniwa and Tim.

[05:01:33.0001] <emilio>
annevk: focus-visible kind of can match and not mach depending on various things, but yeah it does if you do `host.focus({ focusVisible: true })` and then `:focus-visible` doesn't match on the host but on a nested kid (because of `delegatesFocus`)

[05:38:18.0407] <annevk>
 * Anyway, thanks emilio for the useful example. I'll chat a bit more with rniwa and ntim.

[13:44:16.0291] <jugglinmike>
> <@annevk:matrix.org> jugglinmike: I suppose, but that would be confusing for all callers as it's to be used from web platform specs, which don't really use completion records

As a reader familiar with ECMA262, I'm confused by the subversion of that convention. I hear what you're saying about the web platform not using completion records, and that makes me think that maybe the `?` shorthand isn't really appropriate. It's only used three times in Infra, so perhaps we could replace it with a different macro-like expansion--one which doesn't rely on 262's control flow conventions. What do you think? (Also, happy new year!)


2023-01-04
[23:41:30.0455] <annevk>
jugglinmike: Happy New Year to you as well! There's a couple places where we mix styles at the moment. HTML, Web IDL, and Infra. It might be worth addressing in some way, but I'm not sure if that would end up being more or less confusing and it would also be quite a bit of work. I suppose it's worth tracking formally as an issue somewhere.


2023-01-05
[17:50:52.0930] <jugglinmike>
annevk: Thanks! I'll see if I can write something up in the next week or so

[07:12:53.0535] <Dominic Farolino>
Just a heads up to anyone interested: https://github.com/domfarolino/specfmt is in decent shape and works in most cases I use it for, so I'd love for people to try it out more and report bugs so we can make it even better. Please give it a shot!

[07:13:44.0252] <Dominic Farolino>
It's not to the point yet where we can just perfectly format full pre-existing specs, but I think it's getting there...

[07:16:19.0633] <Dominic Farolino>
And it also currently follows WHATWG column-limit line breaking instead of semantic line breaking, so some people hate it :) Maybe it should have 2 modes

[07:35:23.0190] <jgraham>
Dominic Farolino: Oh interesting. Does it try to keep named things on the same line (i.e. for things like `[=long reference=]` avoid linebreaks after `[=long`)? That's been requested on the WebDriver-BiDi spec because people were finding it hard to find/update by search when needing to consider the possibility of linebreaks, and led to a proposed lint to disallow them (but no automatic enforcement, which makes me worry about the tradeoffs).

[07:35:54.0905] <Dominic Farolino>
No, that would be semantic line breaking, which the tool (and WHATWG specs more generally to my knowledge) do not follow.

[07:36:24.0366] <jgraham>
It's not what I think of when I think of semantic linebreaking at least

[07:36:55.0962] <jgraham>
(I thought sematic linebreaking was about putting each clause on a seperate line, even if it's rather short, which I personally dislike)

[07:37:04.0431] <annevk>
Dominic Farolino: most of "my" specs break at a 100 columns but never break inside a term, e.g., Fetch (sometimes I don't catch it in review though)

[07:38:01.0119] <annevk>

(and I tend to not break inside tags)

[07:38:07.0850] <Dominic Farolino>
Perhaps I don't know what semantic line breaking is then

[07:38:51.0506] <Dominic Farolino>
I was going off of https://github.com/tabatkins/bikeshed/issues/662#issuecomment-1332775833, which seems to indicate that WHATWG specs all break and column length regardless of whether we're inside a term

[07:39:14.0280] <Dominic Farolino>
Apparently that's not the case (though in HTML it definitely seems to be the case)

[07:40:11.0898] <Arthur Hemery>
Completely unrelated question about response headers in a navigation redirect chain: Cross-Origin-Opener-Policy was designed to be taken into account during redirects, but as far as I can tell, the HTTP fetch step (https://fetch.spec.whatwg.org/#http-fetch, S7.2.manual) returns a response with nulled out headers (https://fetch.spec.whatwg.org/#concept-filtered-response-opaque-redirect). Am I missing something or is it broken?

[07:40:36.0716] <jgraham>
Per my understanding,
semantic linebreaking is when you always break after a clause,
usually a comma or a fullstop,
kind of like this.
The argument is it makes for cleaner diffs.
But I find it's hard to read,
like poetry.

[07:41:20.0786] <annevk>
Dominic Farolino: HTML allows a break whenever there's already whitespace (you don't get to insert additional whitespace though, such as between a start tag and the first character)

[07:42:00.0650] <Dominic Farolino>
Yeah, the tool wraps to what I believe is consistent with HTML (I mostly wrote the tool while working on the navigation and session history rewrite)

[07:42:43.0811] <annevk>
Fair, I'd love a feature that avoids breaking inside terms as that makes editing a whole lot easier (no need to regex search all the time)

[07:44:01.0562] <Dominic Farolino>
That does seem nice. The current tool is really simple; it doesn't do any parsing to know if you're inside a term or not etc, which is why the HTML-like formatting is easiest for it. But I do personally like not breaking inside a term. PRs welcome heh!

[07:44:28.0594] <Dominic Farolino>
But a while ago I was told to not do that in HTML, so I just assumed that WHATWG specs were like that more generally. Good to know that's not always the case

[07:50:29.0806] <jgraham>
Yeah, I think to do a really nice job you'd want to actually have some kind of parser. And since spec parsing is kind of defined as "whatever bikeshed does" (except for HTML and stuff using respec, but increasingly also those), it's not that easy to produce a high quality implementation. Although maybe it doesn't really need to be _that_ high quality.

[07:54:56.0545] <annevk>
Especially given all the Markdown that's now mixed with HTML...

[07:55:31.0355] <jgraham>
(I wonder if one could implement on top of tree-sitter or something. I suppose the dream would be an LSP server for spec documents)

[08:41:55.0179] <annevk>
I aspire to not dream of specs

[15:29:07.0606] <sideshowbarker>
https://stackoverflow.com/questions/75024554/what-javascript-dom-algorithms-behave-differently-with-an-xmldocument-than-wit


2023-01-06
[22:38:21.0061] <sideshowbarker>
https://stackoverflow.com/questions/75027584/unexpected-websocket-buffer-data-w-masked-fragmented-messages-as-data-grows-s

[05:38:28.0902] <annevk>
Arthur Hemery: missed your question yesterday somehow. The idea is that HTML pokes through to the internal response for that, but it probably does not do so today.

[05:39:54.0712] <annevk>
Arthur Hemery: Fetch doesn't remove the headers, but it does obscure them. (Given Spectre ideally we would remove most headers before handing the response to an attacker process, but that's a thing we haven't tried tackling so far.)


2023-01-07
[02:25:44.0203] <Kaiido>
https://stackoverflow.com/questions/75026200/how-can-the-global-window-object-be-created-before-there-is-a-realm-in-existance?noredirect=1#comment132404888_75026200
It's unclear how the global object Window can be created and passed to JS since WebIDL's "new" asks to check if realm.[[GlobalObject]]'s implements the interface, but at this time the realm doesn't have a [[GlobalObject]] since that would be that Window object we need to create.

[07:19:25.0314] <Domenic>
It's essentially atomic. This is what is intended by https://html.spec.whatwg.org/multipage/document-sequences.html#creating-a-new-browsing-context step 9 being a single step instead of something like "1. create the Window; 2. create the realm and supply the Window to it."


2023-01-08
[13:22:55.0092] <hacknorris>
someone know who made JS ?

[13:49:33.0356] <hacknorris>
?

[15:19:14.0218] <jub0bs>
I have a question about the original W3C Recommendation (for annevk, maybe ?). The rec was quite prescriptive about server-side processing; see https://www.w3.org/TR/2014/REC-cors-20140116/#resource-processing-model. In particular

> If the value of the Origin header is not a case-sensitive match for any of the values in list of origins, do not set any additional headers and terminate this set of steps.

I see no such prescription in the current Fetch standard. Out of curiosity, what motivated its removal? (If necessary, I can provide more context for my question.)


[15:20:57.0174] <jub0bs>
 * I have a question about the original W3C Recommendation (for annevk, maybe ?). The rec was quite prescriptive about server-side processing; see https://www.w3.org/TR/2014/REC-cors-20140116/#resource-processing-model. In particular

> If the value of the Origin header is not a case-sensitive match for any of the values in list of origins, do not set any additional headers and terminate this set of steps.

Unless I'm missing something, I see no such prescription in the current Fetch standard (which is for the best, I believe). Out of curiosity, though, what motivated that less prescriptive stance? (If necessary, I can provide more context for my question.)

[15:21:26.0939] <jub0bs>
 * I have a question about the original W3C Recommendation (for annevk, maybe ?). The rec was quite prescriptive about server-side processing. In particular

> If the value of the Origin header is not a case-sensitive match for any of the values in list of origins, do not set any additional headers and terminate this set of steps.

Unless I'm missing something, I see no such prescription in the current Fetch standard (which is for the best, I believe). Out of curiosity, though, what motivated that less prescriptive stance? (If necessary, I can provide more context for my question.)

[15:21:38.0224] <jub0bs>
 * I have a question about the original W3C Recommendation (for annevk, maybe ?). The rec was quite prescriptive about server-side processing. In particular

> If the value of the Origin header is not a case-sensitive match for any of the values in list of origins, do not set any additional headers and terminate this set of steps.

(source: https://www.w3.org/TR/2014/REC-cors-20140116/#resource-processing-model.)

Unless I'm missing something, I see no such prescription in the current Fetch standard (which is for the best, I believe). Out of curiosity, though, what motivated that less prescriptive stance? (If necessary, I can provide more context for my question.)


2023-01-09
[22:29:58.0408] <annevk>
jub0bs: there is https://fetch.spec.whatwg.org/#http-cors-protocol still

[22:31:44.0203] <annevk>
jub0bs: I think I wrote it anew because the old approach wasn't really liked by server developers, but I'm not entirely sure

[01:02:27.0764] <jub0bs>
Thanks annevk.   

[01:06:42.0185] <jub0bs>
 * Thanks annevk; that actually helps.

[05:21:17.0018] <smaug>
annevk: wasn't your test correct and then someone broke it? https://searchfox.org/mozilla-central/source/testing/web-platform/tests/html/infrastructure/safe-passing-of-structured-data/shared-array-buffers/blob-data.https.html#109 

[05:30:56.0917] <smaug>
or perhaps I'm missing something? Chrome has had issues with data: urls elsewhere, like https://github.com/w3c/webappsec-secure-contexts/issues/69#issuecomment-585780599 

[05:32:01.0916] <annevk>
smaug: the most significant change I can find is https://github.com/web-platform-tests/wpt/commit/ce281cc3f32d8e93ecbb33a51321d846ee2aae37

[05:32:40.0963] <smaug>
right. The question is how data: workers should behave

[05:34:19.0817] <smaug>
er, I was missing something

[05:34:29.0195] <smaug>
"If is shared is false and response's url's scheme is "data", then set worker global scope's cross-origin isolated capability to false."

[05:35:20.0803] <annevk>
I'm not sure if Firefox has the "capability" feature, that got added a bit later

[05:35:55.0417] <annevk>
It also had some wrinkles around shared/service workers that might not be sorted yet spec-wise

[07:14:28.0677] <jub0bs>
annevk: In connection with my earlier question: I think one reason why many people find debugging CORS issues frustrating is that CORS-middleware developers followed that resource-processing model to the letter, and never relaxed their implementation when the spec moved to the Fetch standard.

[07:19:20.0186] <jub0bs>
One example: Alice configures CORS on `https://alice.com` to allow `https://example.com` with request headers `Authorization`. However, in her client (running on `https://example.com`), she also sends some `Foo` request header: `fetch('//alice.com', {headers: {'Foo': 'Foo'}})`. Obviously, CORS preflight then fails because the `Foo` header isn't allowed in Alice's CORS config. But most middleware libraries would omit the ACAO header altogether from the response. When debugging the CORS error in the browser, Alice would be confronted with an error message saying ACAO is missing, which is true but a bit misleading about the actual reason why the server didn't respond with the required CORS headers.

[07:19:39.0957] <jub0bs>
 * One example: Alice configures CORS on `https://alice.com` to allow `https://example.com` with request headers `Authorization`. However, in her client (running on `https://example.com`), she also sends some `Foo` request header: `fetch('//alice.com', {headers: {'Foo': 'Foo'}})`. Obviously, CORS preflight then fails because the `Foo` header isn't allowed in Alice's CORS config. But most middleware libraries would omit the ACAO header altogether from the response. When debugging the CORS error in the browser, Alice would be confronted with an error message saying ACAO is missing, which is true but a bit misleading about the actual reason why the server didn't respond with the required CORS headers.

[07:20:03.0605] <jub0bs>
 * One example: Alice configures CORS on `https://alice.com` to allow `https://example.com` with request headers `Authorization`. However, in her client (running on `https://example.com`), she also sends some `Foo` request header: `fetch('//alice.com', {headers: {'Foo': 'Foo'}})`. Obviously, CORS preflight then fails because the `Foo` header isn't allowed in Alice's CORS config. But most middleware libraries, according to the resource-processing model (as I understand it) would omit the ACAO header altogether from the response. When debugging the CORS error in the browser, Alice would be confronted with an error message saying ACAO is missing, which is true but a bit misleading about the actual reason why the server didn't respond with the required CORS headers.

[07:20:37.0249] <jub0bs>
 * One example: Alice configures CORS on `https://alice.com` to allow `https://example.com` with request headers `Authorization`. However, in her client (running on `https://example.com`), she also sends some `Foo` request header: `fetch('//alice.com', {headers: {'Foo': 'Foo'}})`. Obviously, CORS preflight then fails because the `Foo` header isn't allowed in Alice's CORS config. But most middleware libraries, according to the resource-processing model (as I understand it) would omit the ACAO header altogether from the response. When debugging the CORS error in the browser, Alice would be confronted with an error message saying ACAO is missing, which is true but a bit misleading about the actual reason why the server didn't respond with the required CORS headers (i.e. that request header `Foo` is not allowed).

[07:23:36.0847] <jub0bs>
In my experience, many CORS-related questions asked on Stack Overflow stem from this design decision. But that's not inevitable. A CORS middleware library could reply with `ACAO: https://example.com` and no ACAH header (or simply `ACAH: authorization`). Then the browser's error message would be more useful for debugging purposes:
> Request header field Foo is not allowed by Access-Control-Allow-Headers in preflight response.

[07:23:44.0143] <annevk>
From a theoretical perspective it does seem better to not reveal any information though in such a scenario.

[07:24:22.0585] <jub0bs>
What are you concerned about, specifically? Some side channel?

[07:25:42.0834] <annevk>
Yeah. But you're right that it would make specialized error messages harder. Either way browsers could do more than they are doing and list all the required headers. And middleware could probably offer debug and strict modes.

[07:25:45.0316] <jub0bs>
 * One example: Alice configures CORS on `https://alice.com` to allow `https://example.com` with request headers `Authorization`. However, in her client (running on `https://example.com`), she also sends some `Foo` request header: `fetch('//alice.com', {headers: {'Foo': 'Foo'}})`. Obviously, CORS preflight then fails because the `Foo` header isn't allowed in Alice's CORS config. But most middleware libraries, according to the resource-processing model (as I understand it) would omit the ACAO header altogether from the response. When debugging the CORS error in the browser, Alice would be confronted with an error message like


which is true but a bit misleading about the actual reason why the server didn't respond with the required CORS headers (i.e. that request header `Foo` is not allowed).

[07:25:58.0300] <jub0bs>
 * One example: Alice configures CORS on `https://alice.com` to allow `https://example.com` with request headers `Authorization`. However, in her client (running on `https://example.com`), she also sends some `Foo` request header: `fetch('//alice.com', {headers: {'Foo': 'Foo'}})`. Obviously, CORS preflight then fails because the `Foo` header isn't allowed in Alice's CORS config. But most middleware libraries, according to the resource-processing model (as I understand it) would omit the ACAO header altogether from the response. When debugging the CORS error in the browser, Alice would be confronted with an error message like

> Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource.

which is true but a bit misleading about the actual reason why the server didn't respond with the required CORS headers (i.e. that request header `Foo` is not allowed).

[07:27:36.0699] <jub0bs>
I've thought about offering debug/strict modes in my CORS middleware, but I'm not 100% convinced. People would have to think about activating it and then redeploy.

[07:29:06.0764] <jub0bs>
Since nothing much happens during preflight server side (as the CORS middleware should handle the preflight request rather than passing it on to next handler in the chain), I'm wondering whether worrying about side-channel attacks is justified. Do you know of such attacks?

[07:30:01.0636] <jub0bs>
 * Since nothing much happens during preflight server side (as the CORS middleware should handle the preflight request rather than passing it on to next handler in the chain), I'm wondering whether worrying about side-channel attacks is justified. Do you know of such attacks?

[07:30:31.0673] <jub0bs>
 * Since nothing much happens during preflight on the server side (as the CORS middleware should handle the preflight request rather than passing it on to next handler in the chain), I'm wondering whether worrying about side-channel attacks is justified. Do you know of such attacks?

[07:31:07.0944] <jub0bs>
 * Since nothing much happens during preflight on the server side (as the CORS middleware should handle the preflight request rather than passing it on to next handler in the chain), I'm wondering whether worrying about side-channel attacks is justified. Do you know of such attacks? I know the Fetch standard mentions that possibility, but has it ever been an issue in practice?

[07:31:22.0133] <jub0bs>
 * Since nothing much happens during preflight on the server side (as the CORS middleware should handle the preflight request rather than passing it on to next handler in the chain), I'm wondering whether worrying about side-channel attacks during preflight is justified. Do you know of such attacks? I know the Fetch standard mentions that possibility, but has it ever been an issue in practice?

[07:33:17.0076] <jub0bs>
 * Since nothing much happens during preflight on the server side (as the CORS middleware should handle the preflight request rather than passing it on to next handler in the chain), I'm wondering whether worrying about side-channel attacks during preflight is justified. Do you know of such attacks? I know the Fetch standard mentions that possibility:

> Any other kind of HTTP response is not successful and will either end up not being shared or fail the CORS-preflight request. Be aware that any work the server performs might nonetheless leak through side channels, such as timing. If server developers wish to denote this explicitly, the 403 status can be used, coupled with omitting the relevant headers.

But has it ever been an issue in practice?

[07:35:44.0891] <jub0bs>
 * Since nothing much happens during preflight on the server side (as the CORS middleware should handle the preflight request rather than passing it on to the next handler in the chain), I'm wondering whether worrying about side-channel attacks during preflight is justified. Do you know of such attacks? I know the Fetch standard mentions that possibility:

> Any other kind of HTTP response is not successful and will either end up not being shared or fail the CORS-preflight request. Be aware that any work the server performs might nonetheless leak through side channels, such as timing. If server developers wish to denote this explicitly, the 403 status can be used, coupled with omitting the relevant headers.

But has it ever been an issue in practice?

[07:39:12.0563] <jub0bs>
 * I've thought about offering debug/strict modes in my CORS middleware, but I'm not 100% convinced. People would have to think about activating it and then redeploy. And I'm not sure whether (or how quickly) browser vendors could be convinced to produce more informative error messages, to be honest...

[07:51:23.0775] <jub0bs>
 * I've thought about offering debug/strict modes in my CORS middleware, but I'm not 100% convinced. My users would have to know the option exists, activate it, redeploy, then deactivate it and redeploy once more. And I'm not sure whether (or how quickly) browser vendors could be convinced to produce more informative error messages, to be honest...

[07:51:43.0719] <jub0bs>
 * I've thought about offering debug/strict modes in my CORS middleware, but I'm not 100% convinced. My users would have to know the option exists, activate it, redeploy, test, then deactivate it and redeploy once more. And I'm not sure whether (or how quickly) browser vendors could be convinced to produce more informative error messages, to be honest...

[08:02:33.0917] <annevk>
I'm not sure what you mean. The side channel is there whether you use a 403 or not.

[08:07:06.0796] <jub0bs>
True, the status code is irrelevant. But what kind of useful information could be gleaned by an attacker if the server included the ACAO header (and possibly ACAM and ACAH with "partial" values) in the response despite a failure of CORS preflight?

[08:16:04.0402] <jub0bs>
 * True, the status code is irrelevant. But what kind of useful information could be gleaned by an attacker if the server included the ACAO header (and possibly ACAM and ACAH with "partial" values) in the response despite a failure of CORS preflight? Or is the side-channel attack you're worried about something else entirely?

[08:33:43.0278] <annevk>
It's separate, but maybe it would be better to remove it as for preflights it doesn't matter too much as you say.

[08:48:48.0839] <jub0bs>
Thanks for clarifying. That's great.

[08:50:33.0582] <jugglinmike>
annevk: https://github.com/whatwg/infra/issues/518 -- I'm mentioning that here mostly in case other folks are following along

[08:52:00.0184] <jub0bs>
@annevk I'm currently writing a blog post about my design philosophy for my CORS middleware library. Do you mind if I mention your name (along with Jake's, who also helped me understand a few subtleties) in the acknowledgements? I intend to specify that such an acknowledgement does count as an endorsement of my library on your part ðŸ˜‡

[09:12:43.0897] <jub0bs>
 * Since nothing much happens during preflight on the server side (as the CORS middleware should handle the preflight request rather than passing it on to the next handler in the chain), I'm wondering whether worrying about side-channel attacks during preflight is justified. Do you know of such attacks? I know the Fetch standard mentions that possibility:

> Any other kind of HTTP response is not successful and will either end up not being shared or fail the CORS-preflight request. Be aware that any work the server performs might nonetheless leak through side channels, such as timing. If server developers wish to denote this explicitly, the 403 status can be used, **coupled with omitting the relevant headers**.

But has it ever been an issue in practice?

[09:31:42.0424] <jub0bs>
 * annevk:  I'm currently writing a blog post about my design philosophy for my CORS middleware library. Do you mind if I mention your name (along with Jake's, who also helped me understand a few subtleties) in the acknowledgements? I intend to specify that such an acknowledgement does count as an endorsement of my library on your part ðŸ˜‡

[09:40:41.0996] <annevk>
jub0bs: sure

[09:40:44.0514] <annevk>
jugglinmike: ta

[09:42:31.0057] <jub0bs>
Yes. I think this passage deserves at least some clarification:

> Be aware that any work the server performs might nonetheless leak through side channels, such as timing. If server developers wish to denote this explicitly, the 403 status can be used, coupled with omitting the relevant headers.

In particular, I'm not sure myself what "denote this" refers to...

[09:43:05.0766] <jub0bs>
 * annevk:  I'm currently writing a blog post about my design philosophy for my CORS middleware library. Do you mind if I mention your name (along with Jake's, who also helped me understand a few subtleties) in the acknowledgements? I intend to specify that such an acknowledgement does _not_ count as an endorsement of my library on your part ðŸ˜‡

[09:43:21.0457] <jub0bs>
 * annevk:  I'm currently writing a blog post about my design philosophy for my CORS middleware library. Do you mind if I mention your name (along with Jake's, who also helped me understand a few subtleties) in the acknowledgements? I intend to specify that such an acknowledgement does **not** count as an endorsement of my library on your part ðŸ˜‡

[09:44:04.0068] <jub0bs>
> <@annevk:matrix.org> It's separate, but maybe it would be better to remove it as for preflights it doesn't matter too much as you say.

 * Yes. I think this passage deserves at least some clarification:

> Be aware that any work the server performs might nonetheless leak through side channels, such as timing. If server developers wish to denote this explicitly, the 403 status can be used, coupled with omitting the relevant headers.

In particular, I'm not sure myself what "denote this" refers to...

[09:45:13.0063] <annevk>
jub0bs: can you file an issue?

[09:45:33.0769] <annevk>
I can fix, but not today

[10:22:11.0307] <jub0bs>
annevk: I sure can! There's no rush for you to fix it, though.

[10:22:27.0081] <jub0bs>
 * I sure can! There's no rush for you to fix it, though.

[10:22:52.0030] <jub0bs>
 * @annevk I sure can! There's no rush for you to fix it, though.

[10:23:03.0655] <jub0bs>
 * annevk: I sure can! There's no rush for you to fix it, though.

[10:54:32.0738] <jub0bs>
 * annevk: I sure can! There's no rush for you to fix it, though. Done: https://github.com/whatwg/fetch/issues/1588


2023-01-10
[00:01:28.0744] <annevk>
Domenic: you didn't hit submit for your Infra PR review (at least I'm not seeing it)

[00:04:41.0928] <Domenic>
> <@annevk:matrix.org> Domenic: you didn't hit submit for your Infra PR review (at least I'm not seeing it)

Thanks, done.

[03:43:34.0941] <jgraham>
Ran into a web compat report yesterday where apparently if a domain looks like punycode (i.e. starts `xn--`) but isn't valid punycode, Chromium will just treat it as an ascii domain, but Gecko will refuse to resolve it. That seems like the kind of thing annevk probably knows about :)

[04:05:18.0761] <annevk>
jgraham: yeah, ASCII fast paths, let me look up the issue number

[04:07:06.0166] <annevk>
jgraham: https://github.com/whatwg/url/issues/438

[04:08:43.0404] <jgraham>
Thanks!

[04:11:03.0630] <annevk>
jgraham: the last comment by timothygu can probably be turned into a WPT

[04:11:34.0962] <annevk>
Also pinged the UTS46 experts just now to see if we can move it forward a tiny bit

[04:31:26.0050] <annevk>
In case anyone is interested in some ToASCII spelunking: https://github.com/whatwg/url/issues/603#issuecomment-1377190876
I had forgotten how complicated it is (my write up skips a lot of steps)

[04:54:05.0739] <annevk>
jgraham: it might be that `toascii.window.js` covers those cases already btw

[05:05:17.0172] <annevk>
jgraham: pretty sure they do, e.g., there's `xn--a` there

[05:05:57.0204] <annevk>
jgraham: only Chromium-based browsers fail tests there

[05:22:31.0457] <jgraham>
annevk: https://github.com/webcompat/web-bugs/issues/116505 was the bug report, which is about Chrom[e|ium] allowing access to a site that Gecko does not.

[05:25:00.0284] <annevk>
Note that Safari also cannot access that domain

[05:25:38.0936] <annevk>
https://github.com/whatwg/url/issues/543 is a further subtle difference that exists between Gecko and WebKit, whereby Gecko doesn't seem to check the bidi rules, but WebKit does

[05:25:56.0270] <annevk>
I don't think that's tested currently

[05:26:37.0856] <jgraham>
Yeah, not saying it's a high priority issue; I don't recall seeing another similar bug report (and no one else did either), just that there's a non-zero number of sites relying on Chromium-specific behaviour here.

[05:27:48.0309] <jgraham>
(although it's also hard to tell how common it is because we probably get way fewer bug reports from users in regions that are likely to actually use non-ascii domains vs North America / Western Europe)

[05:48:52.0529] <annevk>
jgraham: it's part of Interop 2022 and soonish 2023 so hopefully that'll help.

[05:49:45.0842] <annevk>
jgraham: it seems there is existing test coverage, except perhaps for the bidi stuff which I just wrote a comment on. I think that's the last of the IDNA issues. Not as much as I feared really so hopefully this national nightmare will soon be over.

[07:41:37.0316] <annevk>
jgraham: I'd like to blame you for my "The Bidi Rule" day

[07:57:00.0623] <annevk>
(On the flipside, if we finally solve the ToASCII side of IDNA due to this I probably owe you something.)

[08:02:36.0701] <jgraham>
Haha. I'm going to suggest it's your own fault that you're known as "the person who will be interested in IDNA issues" ;)

[08:38:50.0019] <annevk>
api.csswg.org is down TabAtkins 

[08:59:27.0575] <Dominic Farolino>
Sanity check wanted (annevk or others). The following algorithm style feels wrong to me, do you agree?

1. <Algo steps running in DOM manipulation task source>
2. Let |returnVar| be null
3. Fetch and in the fetch callback set |returnVar|.
4. In parallel, wait for |returnVar| to become non-null, and return it.

Imagine some more rigorous wording, but it's the structure that I'm concerned with. The author is looking for a way to do something like async/await in spec prose, but I think the above is broken because you can't return something while in-parallel, from an algorithm that is not running in-parallel. The second you go off-thread you have a post a task back to the main thread, in which case you're now dealing with callbacks, not a linear return sequence from the same algorithm that returns something asyncly. Does that sound right?

[09:00:03.0848] <Dominic Farolino>
As I mentioned the motivation I'm gathering here, is that the author wanted to do something like async/await in spec, instead of having a long chain of callbacks all the time. It seems like nothing like that is actually possible though?

[09:00:52.0196] <Andreu Botella>
The various module and script fetching algorithms are written in an async/await-like style

[09:01:19.0314] <Andreu Botella>
 * The various module and script fetching algorithms are written in an async/await-like style

[09:01:26.0069] <Andreu Botella>
you could look into those

[09:05:01.0592] <jgraham>
I think a key question is whether it's actually doing something where the ordering is observable from content. If it is (and I assume something running on the DOM manipulation task source would be) it should probably explicitly use `queue a microtask` or some other integration.

[09:05:32.0996] <jgraham>
(but uh, I'm also not an expert here, and so I'd wait for an actual HTML editor to give an opinion)

[09:11:03.0309] <TabAtkins>
annevk: reported

