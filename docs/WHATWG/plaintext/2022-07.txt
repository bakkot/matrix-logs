2022-07-01
[01:39:09.0142] <sideshowbarker>
> <@zcorpan_:matrix.org> hsivonen (away from Matrix until July 11): sideshowbarker : hmm, https://validator.github.io/validator/ seems to be stuck in a reload loop

yeah I guess I introduced that problem recently. Iâ€™ll take a look

[11:42:02.0110] <seiziziziziziziziziziziziziziziziziziziziziziziziziziziziziziziziziziziziziziziz>
have any of you played the hit game roblox?


2022-07-04
[17:29:18.0405] <Nikola Abkniky>
LOGO 

[05:20:48.0201] <nicolo-ribaudo>
Hi! I recently joined a company that already signed the participation agreement - How do I make https://participate.whatwg.org/agreement-status?user=nicolo-ribaudo&repo=html pick it up, rather than being stuck on a non-verified signature I submitted last year?

[05:21:48.0926] <Luca Casonato>
nicolo-ribaudo: the reviewer of your first PR should verify it

[05:22:37.0802] <nicolo-ribaudo>
Ok thanks! I'll wait until my PR is non-draft before worrying about it

[05:22:44.0682] <nicolo-ribaudo>
 * Ok thanks! I'll wait until my PR is non-draft before worrying about it

[07:53:34.0933] <zcorpan>
annevk: is there anything in the websocket spec that still requires what this test is testing? http://wpt.live/websockets/constructor/014.html (i.e. to wait with establishing another websocket connection to the same host while the previous is still connecting, as a DOS prevention mechanism)

[07:57:05.0009] <Yutaka Hirano>
zcorpan: https://datatracker.ietf.org/doc/html/rfc6455#section-4.1 

[07:57:40.0307] <Yutaka Hirano>
If the client already has a WebSocket connection to the remote
host (IP address) identified by /host/ and port /port/ pair, even
if the remote host is known by another name, the client MUST wait
until that connection has been established or for that connection
to have failed.  There MUST be no more than one connection in a
CONNECTING state.

[07:57:44.0433] <Yutaka Hirano>
Maybe this?

[07:58:20.0905] <zcorpan>
Yutaka Hirano: Thanks! Yes. I thought it was defined in the API rather than the protocol

[07:59:25.0189] <zcorpan>
It shouldn't delay the first connection though, but maybe browsers have to wait a microtask or a task to avoid race conditions?

[07:59:40.0700] <zcorpan>
Context: https://github.com/whatwg/html/issues/8037

[08:05:20.0928] <Yutaka Hirano>
zcorpan: Interesting! As long as the connection establishment is fast enough, subsequent WebSocket connections will not be suffered, right?

[08:07:34.0880] <zcorpan>
Yutaka Hirano: The delaying while connecting applies equally for all subsequent connections

[08:09:05.0964] <zcorpan>
Yutaka Hirano: but I mean, for the first connection, there is no prior connection, so no reason for the browser to wait. But how does the browser know for sure that a connection is the first one, without incurring any delay for the first connection? The "establish a WebSocket connection" steps are defined to be in parallel

[08:09:48.0003] <zcorpan>
Also with the guarantee to never violate the requirement

[08:12:04.0790] <Yutaka Hirano>
@zcorpan: Our implementation runs all the websocket network activities on the same sequence, though It is different from the scripting sequence.

[08:13:08.0876] <Yutaka Hirano>
zcorpan: Thus it is easy for us to distinguish the "first" request (for a server).

[08:13:40.0036] <Yutaka Hirano>
 * @zcorpan: Our implementation runs all the websocket network activities on the same sequence, though It is different from the scripting sequence.

[08:15:48.0977] <zcorpan>
Yutaka Hirano: is strelec's claim "I think that the remainder of the main thread execution delays the connection to the socket (if not according to the spec, then by browser implementations)" true in chromium? That is, does the script that calls the WebSocket constructor need to complete before the network connection is started?

[08:18:54.0037] <Yutaka Hirano>
zcorpan: Sorry, what do you mean by "complete"?

[08:19:53.0597] <Yutaka Hirano>
Due to "in parallel", `new WebSocket(...)` returns immediately. The network connection will be done later.

[08:22:39.0435] <zcorpan>
Yutaka Hirano: the sync part of the script is run, e.g. in `<script>const ws = new WebSocket(url); ws.onopen = handleOpen; await new Promise(resolve => resolve())</script>` after the onopen handler is registered but before the promise has resolved

[08:23:47.0288] <zcorpan>
The question is how much later, and does it depend on when the "script" is done?

[08:25:48.0576] <Yutaka Hirano>
zcorpan: In our implentation, the script completes immediately. The WebSocket constructor kicks the connection procedure in another sequence ("the network thread"). The waiting behavior is implemented in the network thread. Does this answer your question?

[08:27:57.0333] <zcorpan>
Yutaka Hirano: I think so. It sounds like strelec's claim is then not correct (for chromium). To verify, I could do `alert(true) {}` right after the WebSocket constructor, and the browser would still open a connection from the network thread while the main thread is busy running the infinite loop?

[08:29:24.0380] <Yutaka Hirano>
zcorpan: Yes, the connection will be established, but the script wouldn't be able to know that because the `onopen` handler is blocked by the busy loop.

[08:29:55.0820] <zcorpan>
Yutaka Hirano: right. Thanks!

[08:30:33.0869] <Yutaka Hirano>
zcorpan: You're welcome!

[11:08:31.0907] <The Freelancer>
zcorpan: Hello, once again. I am here to ask you one question. 

[11:10:34.0851] <The Freelancer>
 * zcorpan: Hello, once again.

[11:11:40.0766] <The Freelancer>
I wanted to ask one question regarding the DOM, which has been confusing me for a while...

[11:15:50.0809] <The Freelancer>
Why does querySelectorAll() return a NodeList and not an HTMLCollection instance?

[11:16:48.0929] <The Freelancer>
The reasoning I have here is that querySelectorAll() is meant to select elements only, and the HTMLCollection interface suits this notion more than NodeList...

[11:17:28.0121] <The Freelancer>
NodeList, as the documentation says, is a collection of nodes. For example, for the childNodes property of an element, it makes perfect sense, as it will contain element nodes, text nodes, maybe even comment nodes.

[11:18:30.0516] <The Freelancer>
But for querySelectorAll(), using NodeList doesn't make sense, as far as I see it. Clearly, there is some story related to using NodeList for querySelectorAll()...

[14:40:10.0806] <zcorpan>
> <@bro2000:matrix.org> zcorpan: Hello, once again.

Hi! I found this thread from a decade ago where this was discussed. https://lists.w3.org/Archives/Public/www-dom/2012JanMar/thread.html#msg7 Back then some browsers returned HTMLCollection and some returned NodeList. HTMLCollection was not yet part of the DOM spec (so the spec layering  concern applied). Also, HTMLCollection has a  named getter which NodeList does not, and nobody likes  these "magic" named getters (but web  compat might  depend on them).

[14:40:46.0799] <zcorpan>
As for making sense, please  see the topic :)

[14:41:51.0945] <zcorpan>
Both kinds of collections are legacy now, see https://dom.spec.whatwg.org/#old-style-collections

[14:43:19.0728] <zcorpan>
and the note in https://dom.spec.whatwg.org/#interface-htmlcollection

[14:45:56.0865] <zcorpan>
(The thread  wasn't about querySelectorAll actually, I see now)

[14:56:01.0359] <zcorpan>
The first Working Draft of  Selectors API defined the return value to be StaticNodeList rather than NodeList because NodeLists were  defined to be  live in DOM  3  Core. https://www.w3.org/TR/2006/WD-selectors-api-20060525/#staticnodelist 


2022-07-05
[23:53:10.0764] <The Freelancer>
zcorpan: I still don't understand the intuition behind this decision. I have read the resources that you pointed out, but still things are vague. There must be some reason to use NodeList for querySelectorAll(), or otherwise it was just a bad design decision...

[00:12:52.0489] <annevk>
I'm going to let testsuite.org expire. If anyone here wants it let me know.

[01:00:48.0025] <freddy>
It's a good domain name.

[04:39:07.0776] <Noam Rosenthal>
annevk: if you're around can you review https://github.com/whatwg/xhr/pull/347 when you have time? thanks!

[11:23:26.0914] <zcorpan>
The Freelancer: I don't really know, don't recall if HTMLCollection was ever proposed for querySelectorAll. Maybe at the time, HTMLCollection was seen as a HTML-specific thing while qSA can return any element, so NodeList seemed more appropriate

[11:24:11.0995] <zcorpan>
The Freelancer: if we were to design it today, the return type would probably be `sequence<Element>`

[11:38:22.0838] <The Freelancer>
No problem ðŸ™‚. Just thought maybe you knew of it.
I don't get why browsers shifted from using NodeList for getElementsByTagName() and getElementsByClassName() to using HTMLCollection. I went through the resource that you provided from 2012. It contained a couple of chat messages related to this, but I couldn't understand its purpose still.

[11:39:57.0570] <The Freelancer>
zcorpan: I learnt that one thing that irritated browser developers was the fact that HTMLCollection had a namedItem() method. Do you have any knowledge about this?


2022-07-07
[23:41:29.0409] <annevk>
The Freelancer: `namedItem()` is not the problem, but the corresponding getter (Web IDL, special operation) is. That allows for easy confusion between elements of the collection and members of the collection object instance due to the way JavaScript works.

[01:05:19.0036] <The Freelancer>
annevk: I didn't understand what you said. If you don't mind, can you please elaborate it a bit further....

[03:15:12.0924] <annevk>
The Freelancer: say you have an element whose ID is `length` that is part of `collection`; what does `collection["length"]` return?

