2023-03-01
[18:18:42.0118] <zero-one>
this might be a dumb question, but at step 4 of https://url.spec.whatwg.org/#host-parsing , what exactly is meant by "UTF-8 decode"?

[18:18:59.0817] <zero-one>
decoded into... UTF32? i.e, the codepoint value?

[18:19:44.0728] <zero-one>
the link to the encoding spec doesn't really clear it up for me

[18:36:39.0003] <Domenic>
It means "run the algorithm given at that link"

[18:36:58.0432] <Jeremy Roman>
It's not super explicit; the algorithm at that link yields an I/O queue of scalar values

[18:37:29.0631] <zero-one>
yeah, but the algorithm just says that UTF-8 has a decoder, it doesn't explain what that means

[18:37:33.0678] <zero-one>
and to run it

[18:37:39.0995] <Domenic>
Well, if you try to implement it, I wonder where you get stuck

[18:37:44.0804] <Domenic>
You need to keep following the links

[18:38:01.0157] <Domenic>
https://encoding.spec.whatwg.org/#concept-encoding-run , https://encoding.spec.whatwg.org/#concept-encoding-process , etc.

[18:38:16.0646] <Jeremy Roman>
at no point does it ever actually construct a string though

[18:38:43.0384] <Jeremy Roman>
(that I could find)

[18:38:53.0453] <Domenic>
Eventually you end up running the UTF-8 decoder's [handler](https://encoding.spec.whatwg.org/#handler). That is defined at https://encoding.spec.whatwg.org/#ref-for-handler%E2%91%A3 .

[18:40:34.0616] <Jeremy Roman>
process an item pushes said code points into the I/O queue output, and process a queue does so until it fails or reaches the end of the input queue

[18:41:10.0265] <Jeremy Roman>
but UTF-8 decode simply returns that I/O queue of scalar values (code points)

[18:41:44.0014] <Jeremy Roman>
whereas infra describes a string as consisting of code units and then handwaves at ECMA-262 to say that if you have code units you can think of them as code points

[18:43:00.0047] <Jeremy Roman>
even though afaict the linked section of ECMA-262 only actually describes how to interpret code units as code points (and not the reverse), the intent seems to be that a conversion takes place and the URL spec is operating on infra strings

[18:43:43.0157] <Jeremy Roman>
(because nothing else would be sensible)

[18:43:53.0828] <Domenic>
The conversion is defined here: https://encoding.spec.whatwg.org/#from-i-o-queue-convert . I think it is intended to be explicit, but it used to be implicit, and maybe not all cases were updated...

[18:44:48.0171] <Domenic>
Or maybe https://github.com/whatwg/infra/issues/319 is saying that it's meant to be implicit, but not defined yet

[18:45:35.0270] <Andreu Botella>
Yeah, the idea was to have implicit conversions between I/O streams and strings/lists, but looking back at it I'm not sure that's a great idea anymore

[18:45:55.0761] <Andreu Botella>
That was my first relatively large spec contribution ðŸ˜¬

[18:48:03.0085] <Jeremy Roman>
I think there probably should be an explicit algorithm that does the UTF-16 encode on the scalar values; just kinda saying that somehow you end up with a string that UTF-16 decodes into the same scalar values feels magical to me

[18:48:08.0881] <Jeremy Roman>
though dunno if it's a big deal

[18:48:27.0204] <zero-one>
as an amateur trying to implement all these specs, i wonder why we don't just assume UTF-8-encoded input for the URL parser

[18:48:34.0480] <zero-one>
given that you have to do the conversion several times anyway

[18:49:06.0893] <zero-one>
and in 2023, i have to imagine that implementations not using UTF-8 anyway are few and far between

[18:49:43.0480] <Jeremy Roman>
afaik most implementations actually pass UTF-16 to the URL parser quite frequently

[18:49:53.0172] <Jeremy Roman>
because ECMAScript defines strings as having 16-bit code units

[18:50:00.0226] <Jeremy Roman>
even though that's now what's spoken on the wire

[18:50:26.0093] <Jeremy Roman>
 * afaik implementations actually pass UTF-16 to the URL parser quite frequently

[18:51:16.0360] <Jeremy Roman>
https://infra.spec.whatwg.org/#strings

[18:52:23.0694] <zero-one>
i guess if the URL parser is tightly coupled to a js engine, it makes more sense

[18:52:29.0516] <zero-one>
but if there's an IO boundary there, then idk

[18:55:13.0353] <Jeremy Roman>
short version is the use of UTF-8 on the wire and 16-bit code units in ECMAScript means there's nothing that doesn't end up with some amount of transcoding around the place

[18:55:31.0071] <Andreu Botella>
In the case of the URL parser, the `encoding` argument (which is the HTML page's encoding) affects how query strings are encoded, but not the rest of the URL

[18:55:33.0673] <Jeremy Roman>
at least for valid sequences of Unicode scalar values that's lossless

[18:55:45.0514] <Andreu Botella>
The reason behind this is probably historical

[18:56:07.0566] <zero-one>
> <@abotella:igalia.com> In the case of the URL parser, the `encoding` argument (which is the HTML page's encoding) affects how query strings are encoded, but not the rest of the URL

ah

[18:59:49.0941] <Jeremy Roman>
> <@abotella:igalia.com> The reason behind this is probably historical

good old hysterical raisins

[19:03:48.0662] <Andreu Botella>
I just remembered this ISO-2022-JP weirdness that affects query string percent-encoding: https://encoding.spec.whatwg.org/#pit-of-iso-2022-jp

[00:53:26.0858] <Ms2ger>
TabAtkins: 
```
WARNING: Error downloading anchors/anchors-ur.data, full error was:

WARNING: Error downloading anchors/anchors-vi.data, full error was:

Updated 2398/2400, 1 errors...
FATAL ERROR: Done, but there were 2 errors (of 2400 total) in downloading or saving. Run `bikeshed update` again to retry.

```

[06:13:32.0575] <annevk>
I think implicit conversion is still fine. Though if we wanted to avoid that we'd need a bunch of wrapper algorithms instead. Putting the burden on each caller to do the conversion seems bad.

Defining the URL parser as byte sequence -> URL is an interesting idea and it definitely makes sense for implementations. Conceptually though scalar value string -> URL seems a lot cleaner.

And as most formats tend to do a byte sequence -> scalar value string conversion early on it's probably also better for callers. Though again that might only be true in concept as implementations could certainly store those URL inputs as byte sequences too.

[06:21:45.0851] <Ms2ger>
> <@ms2ger:igalia.com> TabAtkins: 
> ```
> WARNING: Error downloading anchors/anchors-ur.data, full error was:
> 
> WARNING: Error downloading anchors/anchors-vi.data, full error was:
> 
> Updated 2398/2400, 1 errors...
> FATAL ERROR: Done, but there were 2 errors (of 2400 total) in downloading or saving. Run `bikeshed update` again to retry.
> 
> ```

Not sure what I did, but I managed an update and now everything seems to work again

