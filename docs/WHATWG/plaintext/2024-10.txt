2024-10-01
[23:15:42.0759] <annevk>
Domenic: https://github.com/whatwg/html/commit/65ef915fbfa347928d5ab946cc5df372c44262cd is missing a comma

[23:15:58.0398] <Domenic>
Oops :(

[23:18:03.0914] <annevk>
Domenic: if you're editing, https://github.com/whatwg/html/commit/5db3fd041f6afd0d6c73f0e4bba21360b59b9267 did indentation incorrectly

[23:19:59.0626] <Domenic>
Sigh, my bad...

[15:05:25.0651] <TabAtkins>
Hm, question. If I were to define a new URL format, similar in principle to data: urls but for generating a specific type of image (QR codes, in this case), would I still want to lean on the "opaque origin" concepts that data: urls use? Or is that overkill and I could rely on something simpler since it's just a raster image?


2024-10-02
[23:10:12.0201] <annevk>
Domenic: what prevents you from having a scripting relationship with a bfcache'd document? I guess there's some unspecified(?) magic that might kick it out of bfcache, but you can hold a reference just fine right?

[23:11:11.0241] <Domenic>
annevk: right, I guess it's the fact that no browser bfcaches iframes or windows with openers. (Not a matter of kicking you out; they just never get bfcached in the first place.) Allowing that would probably break tons of specs that are not prepared for it. We offered to add this to the spec in the past but I think there wasn't appetite.

[23:11:57.0385] <annevk>
Domenic: you don't need an opener to hold a reference to a nested document though

[23:12:33.0740] <Domenic>
No browser bfcaches iframes

[23:13:44.0817] <annevk>
Oh, that's new to me

[23:13:56.0939] <Domenic>
So much stuff would break

[23:14:55.0946] <annevk>
TabAtkins: why would you define them as a new URL scheme and not a particular MIME type?

[03:00:31.0644] <Luke Warlow>
Stuff like the otpauth (/apple-otpauth) scheme can already be used for generating a specific type of qr code. In case of otpauth it's a scheme so it can be used in links. I guess the design might depend on whether it makes sense to linkify this new type of data? Is that the sort of thing you were after Tab? is it something more generic?

[04:23:26.0896] <annevk>
Panos Astithas: maybe we should cancel WHATNOT tomorrow. It's a German holiday and currently only Mu-An Chiou @muan, Domenic, and you are confirmed. We also just had TPAC.

[05:45:41.0170] <annevk>
I wonder if https://x.com/Mike_DiDomizio/status/1839692898670879128 is the direct result of encoding the state in an attribute or if there would be some way to avoid this. I guess the only way would be some kind of parser hack?

[05:51:31.0113] <Luke Warlow>
> <@annevk:matrix.org> I wonder if https://x.com/Mike_DiDomizio/status/1839692898670879128 is the direct result of encoding the state in an attribute or if there would be some way to avoid this. I guess the only way would be some kind of parser hack?

Could potentially only fire the event if there's been user activation on the page? But I guess that only helps on first load not subsequently parsed details 

[06:21:48.0356] <Domenic>
I mean we could thread through "did the parser set this" to the attribute changed steps. It'd just be a lot of annoying work for unclear gain.

[06:23:37.0811] <Domenic>
A new MIME type is more elegant than a new URL scheme but it does come with extra baggage. E.g. you'd expect that if the server served an image/qr-code file then that would also work, which maybe is not what Tab is going for. Unsure.

[07:57:45.0537] <Panos Astithas>
Agreed, I will cancel it.

[08:12:12.0370] <annevk>
A new URL scheme also comes with a lot of baggage though. Is it local, when is it same origin, what if you navigate to it, etc. But yeah, I guess it depends a bit on what you want.

[08:52:19.0416] <keithamus>
I noticed someone tweeting about a pain point of custom elements; https://x.com/Rich_Harris/status/1841494391346590072. In which they point out `cloneNode()` clones the element with the `synchronous custom elements flag unset`. 

I know this was raised before in https://github.com/whatwg/dom/issues/922 where annevk said:

> We don't want to execute JavaScript during those operations as that leads to all kinds of complexity. I'm going to close this as this is working-as-designed.

While I obviously respect that position I'm wondering if there's any possibility of movement on this? It seems unfortunate that this is the only place where elements can be created without a definition, but I guess this would mean a performance hit regardless? 

[09:01:31.0479] <Ms2ger>
Probably not just perf, but masses of CVEs

[09:16:34.0838] <annevk>
keithamus: I actually forgot how cloning works. Is the main issue that it does not happen synchronously or that you do not get any information at all? CER timing could maybe allow for something here, but I don't actually know what we have today. I'm also surprised there hasn't been more noise about this since 2020, but Rich Harris usually knows what's up so it's worth looking into I think.

[09:17:45.0215] <Luke Warlow>
> <@keithamus:matrix.org> I noticed someone tweeting about a pain point of custom elements; https://x.com/Rich_Harris/status/1841494391346590072. In which they point out `cloneNode()` clones the element with the `synchronous custom elements flag unset`. 
> 
> I know this was raised before in https://github.com/whatwg/dom/issues/922 where annevk said:
> 
> > We don't want to execute JavaScript during those operations as that leads to all kinds of complexity. I'm going to close this as this is working-as-designed.
> 
> While I obviously respect that position I'm wondering if there's any possibility of movement on this? It seems unfortunate that this is the only place where elements can be created without a definition, but I guess this would mean a performance hit regardless? 

The perhaps more interesting bit to me is the alternative being so much slower?

[09:18:18.0406] <keithamus>
I was wondering if we could do something with CEReactions. The main issue is that cloneNode won't construct custom elements until they're connecting which is somewhat incongruent with the rest of the platform (importNode retains the definition for example)

[09:18:30.0043] <keithamus>
I imagine importNode is slower because it steps into scripting?

[09:19:46.0450] <keithamus>
`cloneNode` is the only method which calls `creating an element` with `synchronous custom elements flag unset AFAICT.

[09:19:54.0334] <keithamus>
 * `cloneNode` is the only method which calls `creating an element` with `synchronous custom elements flag unset` AFAICT.

[09:20:27.0879] <annevk>
Hmm, `importNode()` and `cloneNode()` are almost identical underneath. If they have serious perf differences that should be fixable.

[09:22:16.0411] <keithamus>
Yes I wonder if we should test the perf disparity claims. The vibe I get from this post was that it was a while ago and maybe that no longer holds true?

[09:23:12.0266] <annevk>
Also, "creating an element" is invoked with that flag unset from the HTML parser at times I think. HTML calls it and that flag value is a variable.

[09:23:29.0086] <keithamus>
ah apologies I missed that

[09:24:38.0622] <keithamus>
oh yeah so https://html.spec.whatwg.org/#create-an-element-for-the-token also explicitly calls out the flag which is sometimes set.

[16:37:34.0767] <TabAtkins>
> <@domenicdenicola:matrix.org> A new MIME type is more elegant than a new URL scheme but it does come with extra baggage. E.g. you'd expect that if the server served an image/qr-code file then that would also work, which maybe is not what Tab is going for. Unsure.

Yeah, y'all are right, just having a new mime type is probably the best way to go. My use-case is just to make it possible to hand-author QR codes easily, given that QRs "won" the barcode wars. They don't need to be linkable or anything, just "fetchable", and a data: URL works for that.

[16:39:44.0051] <TabAtkins>
And the ability for a server to *return* a QR code image using this MIME type wasn't in my initial use-cases, but does seem reasonable imo; the server could generate an appropriate response from cookie data, for instance, and not have to go to the effort (and additional bandwidth) of actually *generating* the QR code as a PNG or something and returning that. Seems useful.

