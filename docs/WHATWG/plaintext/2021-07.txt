2021-07-01
[01:34:35.0083] <sujaldev>
Hi, Can anyone please describe what is exact procedure to "Consume the maximum number of characters possible" mentioned here: https://html.spec.whatwg.org/#named-character-reference-state

[01:35:32.0274] <sujaldev>
 * Hi, Can anyone please describe what is the exact procedure to "Consume the maximum number of characters possible" mentioned here: https://html.spec.whatwg.org/#named-character-reference-state

[01:45:30.0344] <Andreu Botella (he/they)>
Hm, there's arguably a bug there, since the string `&centerNotDot;` should only match the charref `&center`, rather than the prefix of `&centerdot;`

[01:46:08.0081] <Andreu Botella (he/they)>
 * Hm, there's arguably a bug there, since the string `&centerd;` should only match the charref `&center`, rather than the prefix of `&centerdot;`

[01:47:44.0487] <Andreu Botella (he/they)>
 * Hm, there's arguably a bug there, since the string `&centerd;` should only match the charref `&cent`, rather than the prefix of `&centerdot;`

[01:47:55.0225] <Andreu Botella (he/they)>
 * Hm, there's arguably a bug there, since the string `&center` should only match the charref `&cent`, rather than the prefix of `&centerdot;`

[01:50:21.0827] <sujaldev>
So what's the correct way to do this?

[01:51:45.0453] <Andreu Botella (he/they)>
Keep a copy of the named character references list, and for every consumed character, remove the entries that don't match up for that character

[01:53:07.0308] <Andreu Botella (he/they)>
But keep in a variable the latest entry that you have consumed in full (that is, for which the next character would be end-of-string)

[01:54:29.0619] <Andreu Botella (he/they)>
Once the list is empty, unconsume as many characters as (number of characters you've consumed in this algorithm - length of the latest entry consumed in full or 0)

[01:54:52.0418] <Andreu Botella (he/they)>
the latest entry consumed in full is the match you've found, if there is any

[01:56:27.0036] <sujaldev>
sorry to ask a stupid question but what does it mean to "unconsume" here?

[01:59:31.0276] <Andreu Botella (he/they)>
To walk back the pointer into the input stream, such that the next input characters would be the characters after the end of the matched character reference, even if in parsing you've consumed more characters than those

[02:00:40.0500] <sujaldev>
oh ok! thank you for the help!!

[02:08:20.0816] <Andreu Botella (he/they)>
If it's not very obvious, that part of the algorithm tries to find the longest character reference that matches the input

[02:09:19.0036] <Andreu Botella (he/they)>
So both `cent` and `centerdot;` are character references, so if the next few characters are `center;`, you want to match `cent` only

[02:09:39.0867] <Andreu Botella (he/they)>
If you're reading character by character, you would have to read `center` and then backtrack when you find the semicolon

[02:10:46.0708] <Andreu Botella (he/they)>
but if you do find `centerdot;` you want to take that as the match, not `cent`

[02:24:05.0296] <sujaldev>
So from what I understand from the above explanation an html stream <p>center;</p> would be read as <p>&cent;er</p>

right?

[02:24:39.0229] <sujaldev>
displayed as:
¢er;

[02:24:57.0635] <sujaldev>
 * So from what I understand from the above explanation an html stream <p>center;</p> would be read as <p>&cent;er;</p>

right?

[02:28:39.0856] <sideshowbarker>
sujaldev: `center;` would never reach that algorithm — because `center;` doesn’t begin with an `&` ampersand 

[02:29:24.0528] <sujaldev>
sorry i mean &center;

[02:29:48.0033] <sujaldev>
let me just edit that

[02:29:55.0501] <sujaldev>
 * So from what I understand from the above explanation an html stream <p>&center;</p> would be read as <p>&cent;er;</p>

right?

[02:31:34.0810] <Andreu Botella (he/they)>
¢er; indeed

[02:32:32.0163] <sujaldev>
trying to implement it now in my project! thank you again!

[02:35:01.0390] <sideshowbarker>
sujaldev: I guess you probably already know about the html5lib test suite, but if not, you definitely want to be testing your implementation against that — https://github.com/html5lib/html5lib-tests

[02:36:37.0199] <sideshowbarker>
and not to muddy the waters, but it’s worth mentioning that you don’t need to match the steps in that part of the parsing algorithm exactly, as long as you end up with the same result

[02:37:39.0469] <sujaldev>
> <@sideshowbarker:mozilla.org> sujaldev: I guess you probably already know about the html5lib test suite, but if not, you definitely want to be testing your implementation against that — https://github.com/html5lib/html5lib-tests

I didn't know about this, real helpful.

[02:37:53.0647] <sideshowbarker>
yeah for https://github.com/validator/htmlparser we don’t match the spec steps exactly for that part of the algorithm, but do it in a different way that produces the same test results

[02:39:28.0599] <sujaldev>
does it still follow state machine concept?

[02:39:54.0295] <sideshowbarker>
yes

[02:41:52.0317] <sideshowbarker>
there are some places where it doesn’t conform to the spec, and I’ve had some pull requests open for quite a while now to fix those, but… fixing them has not been a big priority for that particular project

[02:43:49.0582] <sujaldev>
> <@sideshowbarker:mozilla.org> yeah for https://github.com/validator/htmlparser we don’t match the spec steps exactly for that part of the algorithm, but do it in a different way that produces the same test results

If I knew more about parsing and also knew java would have loved to contribute to this

[10:04:46.0615] <shu>
how do overloads work in WebIDL? specifically, for `Window.alert`, which is spec'd to have two overloads `alert()` and `alert(message)`, what's `alert.length` supposed to be?

[11:13:00.0225] <zcorpan>
shu: https://heycam.github.io/webidl/#dfn-create-operation-function

[11:13:13.0710] <zcorpan>
step 6

[13:44:26.0768] <shu>
zcorpan: thanks

[15:19:54.0928] <timothygu>
shu: what's the plan for https://github.com/heycam/webidl/pull/982? is it waiting on ES still?

[16:08:51.0806] <shu>
timothygu: resizable buffers is stage 3, so i was planning on requesting to merge that after there's at least one implementation shipping

[16:09:18.0200] <shu>
it's a fairly big proposal to implement, actually, so we might not see anything till Q4

[16:09:43.0714] <timothygu>
okay, I converted it to a draft in the meantime

[16:09:54.0783] <shu>
ah okay, is that the convention?

[16:39:50.0394] <Domenic>
We invented a "do not merge yet" convention for WHATWG repos before draft PRs existed. These days it seems like a mix.

[16:39:58.0724] <Domenic>
 * We invented a "do not merge yet" label convention for WHATWG repos before draft PRs existed. These days it seems like a mix.


2021-07-02
[17:21:15.0592] <shu>
i thought "Draft" meant something like the author was still modifying it, and it wasn't ready for review

[17:21:37.0400] <shu>
and something like "do not merge" is, its contents are ready to go, but it's gated on other things

[18:31:34.0710] <Domenic>
Yeah I think I personally prefer that taxonomy

[22:56:15.0402] <sideshowbarker>
for using Node.js in Github Actions, rather than needing specify any particular Node.js version, is there some way I can specify “just use the latest available Node.js version”?

[07:21:56.0344] <DerekNonGeneric>
sideshowbarker: looks like it uses to `nvm` (bash version) syntax https://github.com/actions/setup-node#supported-version-syntax

[07:22:19.0579] <sideshowbarker>
/me looks

[07:22:44.0738] <sideshowbarker>
so is there an `nvm` syntax for “latest”?

[07:23:27.0376] <sideshowbarker>
I know there’s `lts/*`, but that’s not latest-latest

[07:24:03.0354] <DerekNonGeneric>
might just be `node` according to the docs https://github.com/nvm-sh/nvm#usage

[07:24:31.0040] <DerekNonGeneric>
> # "node" is an alias for the latest version

[07:26:07.0647] <DerekNonGeneric>
(have not actually tested this myself)

[07:28:18.0239] <sideshowbarker>
oh cool — will try that

[07:31:42.0389] <sideshowbarker>
dang, didn’t work

[07:31:58.0361] <sideshowbarker>
https://github.com/w3c/mdn-spec-links/actions/runs/993930895
> Unable to find Node version 'node' for platform linux and architecture x64.


[07:32:48.0692] <sideshowbarker>
no big deal, though — for the specific context, any version >=15 works fine

[07:33:35.0565] <sideshowbarker>
I just need support for `.replaceAll()`, but the default node in Ubuntu latest is too old to have that

[07:33:53.0518] <sideshowbarker>
so I guess I’ll just use `16`

[07:35:46.0829] <DerekNonGeneric>
yeah, the latest-even number versions will last a while

[07:35:58.0853] <sideshowbarker>
yeah


2021-07-03
[00:18:03.0659] <Sarath kumar>
HI, can anyone tell me how to design this type of card ?


[00:26:31.0214] <DerekNonGeneric>
the "design" is self-evident in the image; how it should be coded is probably off-topic

[00:43:07.0029] <DerekNonGeneric>
Sarath kumar: i do not understand your question.. it seems to have already been designed, no?

[01:00:55.0488] <Sarath kumar>
current design is like below, i have to modify the current design to the above one


[01:01:33.0858] <Andreu Botella (he/they)>
Sarath kumar: Hi, this chatroom is for working on the web standards, or for help understanding them. It's not for general help with web development.

[01:02:30.0558] <Andreu Botella (he/they)>
You might want to try asking in #webdevelopment:matrix.org or #webdesign:matrix.org

[01:31:00.0274] <DerekNonGeneric>
> <@sideshowbarker:mozilla.org> so is there an `nvm` syntax for “latest”?

there appears to be a way to acquire the latest version of node for github actions, but you have to define it in the manifest https://github.com/actions/setup-node/blob/38d90ce44d5275ad62cc48384b3d8a58c500bb5f/src/installer.ts#L53

[01:32:05.0503] <sideshowbarker>
/me > <@dereknongeneric:mozilla.org> there appears to be a way to acquire the latest version of node for github actions, but you have to define it in the manifest https://github.com/actions/setup-node/blob/38d90ce44d5275ad62cc48384b3d8a58c500bb5f/src/installer.ts#L53

looks now

[01:33:45.0112] <DerekNonGeneric>
unclear on what is meant by "manifest" here, but it is possible that they mean in the `package.json` file (`engines.node` key)

[01:42:46.0041] <DerekNonGeneric>
we do not use the term "manifest" in node core when referring to the package.json file at all, but have seen Yarn do so in their docs

[02:05:53.0726] <DerekNonGeneric>
probably going to end up setting up a test project to get this solved for my own purposes, but am surprised that this isn't more ergonomic

[02:10:34.0383] <sideshowbarker>
I guess I rightly should be setting the `engines.node` version to `>=15.0.0` regardless — since that’s what’s required for using `.replaceAll()`

[02:12:52.0566] <DerekNonGeneric>
in reality, it should probably be `>=16` since this release line will last you longer (wonder if setting this value to `node` does anything)

[02:22:14.0336] <sideshowbarker>
I can try setting it to `node` and see

[02:23:47.0162] <DerekNonGeneric>
you would still need to figure out what the github actions yaml file would need to look like in order for it to utilize the package.json tho (i think)

[02:28:57.0700] <sideshowbarker>
ah

[03:16:25.0452] <DerekNonGeneric>
> * <@sideshowbarker:mozilla.org> looks now

this part is documented here, so it looks like it is simply determining whether the version specified in the package.json is the latest x.x.x version: https://github.com/actions/setup-node/blob/main/docs/advanced-usage.md#check-latest-version

[04:25:55.0289] <DerekNonGeneric>
sideshowbarker: here it is my friend, all that needs to be done is to specify the version as `x.x.x` and ensure `check-latest` is set to `true` -- glad we got that squared away https://github.com/DerekNonGeneric/test-repo-please-ignore/blob/main/.github/workflows/build.yml

[04:29:41.0468] <sideshowbarker>
> <@dereknongeneric:mozilla.org> sideshowbarker: here it is my friend, all that needs to be done is to specify the version as `x.x.x` and ensure `check-latest` is set to `true` -- glad we got that squared away https://github.com/DerekNonGeneric/test-repo-please-ignore/blob/main/.github/workflows/build.yml

thanks much!

[04:30:22.0047] <DerekNonGeneric>
yw


2021-07-04

2021-07-05
[07:45:20.0943] <sideshowbarker>
PSA: https://dontcallmedom.github.io/mdn-issue-by-spec/whatwg.rss

[10:35:48.0921] <smaug>
Isn't https://searchfox.org/mozilla-central/rev/b7bc94b4689a7f002c61d016c6e162e5e5708bf3/testing/web-platform/tests/shadow-dom/imperative-slot-api.html#211,216-218 buggy

[10:36:29.0686] <smaug>
That part of the test was written way before the spec

[10:41:09.0520] <smaug>
The spec allows moves and there is no "recalc"


2021-07-06
[05:13:01.0578] <sujaldev>
are you supposed to convert carriage return to newline character in the html tokenization stage?

[05:16:56.0170] <sujaldev>
https://github.com/html5lib/html5lib-tests/blob/master/tokenizer/domjs.test the first test in this file points to the above doubt...

[05:20:01.0852] <Sam Sneddon [:gsnedders]>
sujaldev: it's in the pre-processing the input stream stage; pretty sure the tokeniser tests assume the two are done together


2021-07-07
[19:30:01.0992] <sujaldev>
oki thanks!

[19:48:21.0534] <sideshowbarker>
wonderful, https://drafts.csswg.org/ completely broken again for the Nth time

[19:50:31.0658] <sideshowbarker>
after this having happened so frequently, it’s baffling that there’s not a watchdog or something set up

[19:51:07.0966] <sideshowbarker>
/me goes off to raise an https://github.com/w3c/csswg-drafts issue about it for at least the 3rd time

[05:30:45.0316] <smaug>
I have asked this before, I think. Is there some documentation for a good workflow for making spec changes? Including the usual github pr creation but also what checks people do to find if there are relevant WPTs etc.

[07:18:51.0496] <freddy>
Admittedly, you are probably not exactly the intended audience but this might help https://wpc.guide/bug-guide/ 

[07:19:20.0967] <freddy>
but TBH, I often just look at similar patches and the follow-up bugs (e.g., for WPT) they led to

[09:49:10.0242] <bakkot>
annevk: domenic suggested you might have an opinion on https://github.com/bakkot/proposal-arraybuffer-base64/issues/5. the question under consideration (as I see it; he is welcome to correct) is, must any new base64-decoding API in the web platform decline to validate the padding bytes by default (and hence match the behavior of `atob`), or can it be stricter by default in pursuit of making it harder to accidentally fall into security issues arising from the (I think fairly natural) assumption that base64 encoding is one-to-one?

[09:49:26.0961] <bakkot>
also interested in opinions from others

[09:50:38.0867] <bakkot>
Domenic seems to feel strongly that it is more important to match `atob`, I feel fairly strongly that it is more important to make the less-secure behavior opt-in, so I am hoping we can get other opinions on the matter

[09:55:31.0995] <Domenic>
Matching data: URLs and other base64 encoding behaviors in the platform (e.g. SRI digests) is more important than atob

[10:01:30.0064] <Luca Casonato>
I agree

[10:03:20.0300] <bakkot>
I understand that position even less; how many people are ever manually decoding a data: url or an SRI digest?

[10:04:15.0944] <bakkot>
(CSP, incidentally, requires padding, so the web platform is not uniform here)

[10:05:42.0564] <bakkot>
actually SRI does too, as far as I can tell from the spec

[10:06:59.0207] <Domenic>
Yeah the spec doesn't seem to match browsers there

[10:08:11.0105] <Domenic>
I can't find base64 decoding in the CSP/SRI specs, only the implementations

[10:09:53.0468] <bakkot>
that's because they don't aren't specified in terms of decoding; they compare by string equality, and assume that base64 encoding is 1-to-1, since everyone makes this assumption.

[10:09:58.0979] <bakkot>
 * that's because they aren't specified in terms of decoding; they compare by string equality, and assume that base64 encoding is 1-to-1, since everyone makes this assumption.

[10:10:10.0192] <bakkot>
 * that's because they aren't specified in terms of decoding; they compare base64-encoded strings by string equality, and assume that base64 encoding is 1-to-1, since everyone makes this assumption.

[10:17:28.0705] <bakkot>
> <@domenicdenicola:matrix.org> Yeah the spec doesn't seem to match browsers there

Browsers disagree; Firefox follows the spec, Chrome does not

[10:22:48.0863] <bakkot>
 * that's because they aren't specified in terms of decoding; they compare base64-encoded strings by string equality, and assume that base64 decoding is 1-to-1, since everyone makes this assumption.

[10:39:40.0062] <shu>
> that's because they aren't specified in terms of decoding; they compare base64-encoded strings by string equality, and assume that base64 decoding is 1-to-1, since everyone makes this assumption.

i find this footgun argument to be pretty persuasive. fwiw i feel more radicalized than before from reading those tweets, and feel like if anything we should try to change the web default

[10:52:51.0999] <sideshowbarker>
Domenic: r? https://github.com/whatwg/whatwg.org/pull/371

[10:58:26.0784] <sideshowbarker>
Domenic: also https://github.com/whatwg/html-build/pull/265

[11:00:38.0279] <Domenic>
> <@shuyuguo:matrix.org> > that's because they aren't specified in terms of decoding; they compare base64-encoded strings by string equality, and assume that base64 decoding is 1-to-1, since everyone makes this assumption.
> 
> i find this footgun argument to be pretty persuasive. fwiw i feel more radicalized than before from reading those tweets, and feel like if anything we should try to change the web default

I just don't think these people are JS practictioners. They are crypto people (?) who maybe use base64 for crypto purposes. We should not expose base64 at all if our audience is people hand-rolling crypto.

[11:00:46.0369] <Domenic>
Note also that the tweets note that Go has the same default as JS

[11:01:01.0901] <Domenic>
It feels really bad for TC39 to try to shift the web default by fiat

[11:02:49.0671] <shu>
the "we shouldn't expose this at all" is a separate argument, which i think i also disagree with, but we should table in this context

[11:03:38.0510] <Domenic>
Well it's relevant because what is our goal in exposing this

[11:03:53.0892] <Domenic>
Is it to allow people to decode base64 in a fashion they're used to from Node/Go/Deno/the web?

[11:04:08.0198] <Domenic>
Or is it to allow people to do secure crypto-adjacent stuff that assumes bijection?

[11:04:20.0170] <shu>
> <@domenicdenicola:matrix.org> It feels really bad for TC39 to try to shift the web default by fiat

i have a hard time engaging with this as well -- there are technical reasons to prefer the stricter variant, which there is disagreement with. it similarly feels bad to accuse TC39 of some kind of power grab here

[11:04:20.0398] <bakkot>
Filippo Valsorda is one of the people your employer pays to be hand-rolling crypto

[11:04:39.0055] <Domenic>
> <@bakkot:matrix.org> Filippo Valsorda is one of the people your employer pays to be hand-rolling crypto

Yes, and I don't think he's the target audience for this API.

[11:04:57.0365] <Domenic>
I don't really think pointing at someone with a different opinion and saying "you get your money from the same dude" is really that insightful

[11:05:27.0201] <shu>
yes let's... cool down on that front

[11:10:51.0800] <Luca Casonato>
Just for clarity: this is about the strictness of base64 **decoding** right? We do all agree that base64 encoding should always include padding?

[11:11:55.0395] <Domenic>
Yes

[11:12:06.0513] <shu>
i've tried to steer the conversation to something more pragmatic, but so long as we're talking about broad-scope arguments like "we shouldn't diverge at all from existing standardized web APIs" and "the current default is not great", i do find the latter more convincing because i'm not sure what group the former position helps in this particular case

[11:12:53.0381] <Luca Casonato>
In this case, what are some arguments for being strict with padding by default? What use cases would this benefit?

[11:13:02.0994] <shu>
for the concrete AMP case, it seemed like the weird Java printer was, well, regarded as weird, and an attempt was made to fix it

[11:13:59.0823] <shu>
> <@lucacasonato:matrix.org> In this case, what are some arguments for being strict with padding by default? What use cases would this benefit?

the use case that the (imo reasonable) assumption that base64 is a bijection holds, and that when it does not, it prompts the author to take a second look and figure out why

[11:16:00.0513] <Domenic>
Who is going around saying "I really want bijection"? I'm worried about people going "I want to switch from Buffer.from(x, "base64") to the new thing, but I did and now we have a production outage because I didn't know about how TC39 decided to diverge from Node semantics and data that used to work now fails"

[11:16:28.0860] <shu>
i think that's precisely the point of why it's so surprising -- nobody's going around saying that because they don't even realize it's not. i certainly didn't!

[11:16:58.0058] <Domenic>
I suspect people don't *expect* it.

[11:17:09.0559] <Luca Casonato>
> <@shuyuguo:matrix.org> the use case that the (imo reasonable) assumption that base64 is a bijection holds, and that when it does not, it prompts the author to take a second look and figure out why

shu: Many other languages and ecosystems have set the precedent that this is not the case though: Go, Python, Java, Deno, Node, Rust. I don't think it is a reasonable assumption to make.

[11:17:21.0525] <Domenic>
Bijection is just not a property one usually insists on for encoding/decoding, is my claim. Certainly not with text encodings!

[11:17:28.0353] <Luca Casonato>
https://docs.rs/base64/0.13.0/base64/ <- too little padding is ok, too much is not

[11:17:31.0981] <bakkot>
Domenic: to be clear, `Buffer.from(x, "base64")` accepts _mixed_ base64 and base64url in the same string, which I am definitely not proposing to support

[11:17:49.0891] <Domenic>
> <@bakkot:matrix.org> Domenic: to be clear, `Buffer.from(x, "base64")` accepts _mixed_ base64 and base64url in the same string, which I am definitely not proposing to support

Well OK, that's pretty bonkers, fair enough.

[11:17:54.0017] <shu>
Domenic: i'm worried about the latter too, but that's why i want more data here! it's all too easy to raise the specter of possible compat breakage

[11:18:01.0599] <bakkot>
(CSP does too, fun fact)

[11:18:21.0272] <Domenic>
Seems like *that* should be a non-default mode...

[11:18:32.0118] <shu>
and while we're here and i'm a little worked up, i really want us to stop pitting whatwg-vs-tc39, both inside and outside of tc39

[11:18:41.0393] <Domenic>
(I'll open a tracking issue)

[11:19:59.0061] <shu>
i mean, obviously JS is a stakeholder in the web platform and we want to improve it too. there are delegate who don't care about the web as much, but perpetuating that dichotomy entrenches that position which is counter-productive

[11:27:04.0717] <Domenic>
I don't think this is a very WHATWG-vs.-TC39 thing; for me at least I tried to frame all my comments as about technical/API surface concerns on each proposal. E.g. even if TC39 wants to do this then I still am unsure about putting things on the prototypes vs. a separate utility class.

At first I thought it was more a web-vs-non-web thing. But recent research showing that Deno/Node/Go/etc. all do forgiving base-64 makes it seem like it's not even that. It's apparently about whether you expect a new JS API to have some bijection property vs. whether you expect it to align with the JS ecosystem/other standard library APIs.

[11:31:13.0885] <bakkot>
> <@domenicdenicola:matrix.org> Bijection is just not a property one usually insists on for encoding/decoding, is my claim. Certainly not with text encodings!

My claim is that a great many people _assume_ it holds, for base64 in particular. Either Chrome's implementation of CSP or the CSP spec itself assumes it holds, so it's not like it's only amateurs who make this mistake. (I don't know what the intent of the CSP authors was, so I'm not saying Chrome is wrong, just that it doesn't match the spec-as-written.)

That is to say, my claim is that very few people have the correct intuition about what `atob` and friends actually do in this edge case, and in any case are unlikely to be exposed to it, and as such we should match what they expect these APIs to do, not what they actually do.

