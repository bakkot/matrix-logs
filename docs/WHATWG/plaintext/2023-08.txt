2023-08-02
[17:31:19.0890] <Dale Y Pearlman>
Do you know that you can earn $5,000 or more weekly from crypto Trading? With Just $500‚Ä¶ 100% Inbox Admin on Telegram for more details üëáüëáüëáüëáüëáüëá https://t.me/PROFITSWITHSTEVE


2023-08-05
[18:48:47.0643] <zero-one>
i'm looking at the wpt test data for URLs, and i'm a little confused by https://github.com/web-platform-tests/wpt/blob/master/url/resources/urltestdata.json#L4725

[18:49:15.0481] <zero-one>
\uD800 \uD801 isn't a valid surrogate pair, so what exactly is meant by this particular input?

[18:49:28.0165] <zero-one>
my json parser chokes on it, understandably

[23:41:23.0977] <Domenic>
What is meant is to test what the URL parser does on invalid surrogate pairs

[23:41:48.0691] <Domenic>
The algorithm handles them just fine (since it operates on strings, which are sequences of 16-bit code units, including invalid surrogates)

[00:23:59.0027] <zero-one>
I'm sure the URL parser handles it fine, but I think this is invalid JSON

[00:25:32.0474] <zero-one>
will need to dig up a parser that I can tell to ignore invalid surrogate pairs

[00:25:51.0781] <zero-one>
* will need to dig up a JSON parser that I can tell to ignore invalid surrogate pairs

[01:34:50.0074] <Domenic>
JSON.parse() works fine on it

[07:34:08.0851] <Richard Gibson>
`"\uD800\uD801"` is valid JSON but not guaranteed to be interoperable (especially if the decoder is in a language that internally uses UTF-8 for strings), cf. https://www.rfc-editor.org/rfc/rfc8259#section-8.2
> However, the ABNF in this specification allows member names and string values to contain bit sequences that cannot encode Unicode characters; for example, "\uDEAD" (a single unpaired UTF-16 surrogate)‚Ä¶ The behavior of software that receives JSON texts containing such values is unpredictable; for example, implementations might return different values for the length of a string value or even suffer fatal runtime exceptions.


2023-08-07
[22:54:02.0956] <hsivonen>
KBar, Ms2ger , Sam Sneddon [:gsnedders] , jgraham , emilio : I'm not aware of about:blank quirkiness constraints beyond: a) It's that way, because it has always been (and its logical given the lack of doctype) and b) the cases where the difference would be detectable are motivations both for and against changing it (folks who want the standards mode have a reason to change but existing content that puts stuff there could be adversely affected by a change).


2023-08-08
[02:59:18.0413] <Jake Archibald>
Let's say Origin A contains an iframe to Origin B. Is it possible for Origin A to create another Origin B iframe without requiring another main fetch to Origin B? I was hoping I could use a blob url passed back from the Origin B iframe, but that doesn't seem to work https://static-misc-2.glitch.me/iframe-host/


2023-08-09
[15:50:24.0836] <amine khadraoui>
Hey


2023-08-10
[01:24:12.0288] <Domenic>
@allstarschh: In general pinging someone less than 24 hours after you've already done so is not necessary. Especially for such a non-urgent PR. I'll try to make time for the PR next week, but it's 17:30 and tomorrow's a holiday, so please have some patience.

[01:26:05.0870] <@allstarschh>
Domenic: oh, thanks, I saw the reviewer is not set and I don't know if I should set that or someone will set it, the issue is not urgent, 

[01:46:56.0336] <freddy>
Jake Archibald: there's an (early stage) proposal for websites to mark a blob as crossOrigin accessible. https://github.com/w3c/FileAPI/issues/192. In your case, this would require Origin B to opt in.

[02:05:14.0048] <Jake Archibald>
freddy: isn't that the opposite of what I'm looking for? It seems like the resulting resource would be different-origin to Origin B.

[02:07:54.0309] <freddy>
Right. ü§¶‚Äç‚ôÇÔ∏è

[02:10:54.0475] <Jake Archibald>
I guess that confirms annevk's worry about the property name. It does initially look like it means the opposite.

[02:29:48.0230] <hsivonen>
The spec describes both classic async scripts and module async scripts as executing as soon as they are available. In reality, classic async scripts may execute a tiny bit later, but since the exact moment of network response finishing isn't exposed, the tiny bit later looks as if it was part of the network timing. However, for inline async scripts that have no external dependencies, "as soon as they are available" in principle has a well-defined point in time relative to the HTML parse. However, it seems bad to grant special guarantees to that case. Do I understand correctly that the spec doesn't mean to grant guarantees about that special case and it's OK for the parse to progress a bit before an inline async module script without external dependencies executes?

[02:30:12.0235] <hsivonen>
^ @allstarschh 

[02:30:48.0126] <hsivonen>
 * The spec describes both classic async scripts and module async scripts as executing as soon as they are available. In reality, classic async scripts may execute a tiny bit later, but since the exact moment of network response finishing isn't exposed, the tiny bit later looks as if it was part of the network timing. However, for inline async module scripts that have no external dependencies, "as soon as they are available" in principle has a well-defined point in time relative to the HTML parse. However, it seems bad to grant special guarantees to that case. Do I understand correctly that the spec doesn't mean to grant guarantees about that special case and it's OK for the parse to progress a bit before an inline async module script without external dependencies executes?

[02:32:02.0728] <hsivonen>
It would be unfortunate to have to use the `document.write` accommodating execution path in Gecko for inline async module scripts just because the spec granted that special case a special guarantee that goes away as soon as the module has an external dependency.

[02:32:38.0061] <hsivonen>
(I gather that in any case, module scripts are prohibited from using `document.write`, so the guarantee would be only about the specific observable DOM shape.)

[02:43:56.0922] <hsivonen>
Well, at least Chrome doesn't grant that guarantee. I guess I need to file a spec issue to avoid suggesting a specific execution time.

[02:46:12.0059] <hsivonen>
Demo: https://hsivonen.com/test/moz/inline-async-module-script-without-deps.html

[03:05:59.0860] <hsivonen>
Filed as https://github.com/whatwg/html/issues/9597

[10:35:03.0534] <Eric Portis (he/him)>
Noam Rosenthal: Re: https://github.com/whatwg/html/issues/9332#issuecomment-1673580721, do you have any sense of what % of sites currently render before all of the ~final/stable above-the-fold DOM nodes are in the DOM? I guess 100% of client side rendered sites -- is that the main (only?) use case here?

[10:43:14.0323] <Noam Rosenthal>
> <@etportis:matrix.org> Noam Rosenthal: Re: https://github.com/whatwg/html/issues/9332#issuecomment-1673580721, do you have any sense of what % of sites currently render before all of the ~final/stable above-the-fold DOM nodes are in the DOM? I guess 100% of client side rendered sites -- is that the main (only?) use case here?

I don‚Äôt think we can have that info, stable is subjective and dependent on content

[10:50:28.0143] <Eric Portis (he/him)>
Noam Rosenthal: That makes sense. I'm just trying to get a sense of the need, here -- what's driving this. Paving a bad cowpath (anti-flicker snippets, used for all kinds of reasons) is a cost.

[10:52:26.0446] <Eric Portis (he/him)>
 * Noam Rosenthal: That makes sense. I'm just trying to get a sense of the need, here -- what's driving this. Paving a bad cowpath (anti-flicker snippets, used for all kinds of reasons) is a cost.(

[10:52:29.0508] <Eric Portis (he/him)>
(And hunt around for a more-scoped solution for the subset of problematic cases)

[10:52:58.0828] <Eric Portis (he/him)>
 * Noam Rosenthal: That makes sense. I'm just trying to get a sense of the need, here -- what's driving this. Paving a bad cowpath (anti-flicker snippets, used for all kinds of reasons) is a cost.

[10:55:41.0378] <Noam Rosenthal>
> <@etportis:matrix.org> (And hunt around for a more-scoped solution for the subset of problematic cases)

What‚Äôs driving this is view transitions. But the use case has been around way before that, to avoid ugly layout shifts and flashes due to important elements not being parsed yet 

[10:58:51.0996] <Eric Portis (he/him)>
Right. Something slowly animating out and then popping back in, in the same spot, late is much, much worse than something just popping in late -- I get the extra need for it for View Transitions. But is there a subset of sites that this affects? It's pages that are fetching content in JS, right? I could put a view-transition-name on something at the bottom of HTML spec single-page and it won't matter that the parser has already yielded to the renderer, because that element is a mile outside of the viewport...?

[11:05:03.0360] <Noam Rosenthal>
> <@etportis:matrix.org> Right. Something slowly animating out and then popping back in, in the same spot, late is much, much worse than something just popping in late -- I get the extra need for it for View Transitions. But is there a subset of sites that this affects? It's pages that are fetching content in JS, right? I could put a view-transition-name on something at the bottom of HTML spec single-page and it won't matter that the parser has already yielded to the renderer, because that element is a mile outside of the viewport...?

It would be relevant for any page that has cross-document view transitions and its elements are chunked in slowly. It‚Äôs actually less relevant to SPA where you can do this with a render-blocking script 

[11:07:19.0388] <Eric Portis (he/him)>
> and its elements are chunked in slowly
...and those elements have view-transition-names, right?

Hypothetically, would this problem be solved if everyone ensured that everything they put a view-transition-name on was in the HTML response. (I know we can't ask authors to do that... just trying to build a mental model of the problem)

[11:07:27.0994] <Eric Portis (he/him)>
 * > and its elements are chunked in slowly

...and those elements have view-transition-names, right?

Hypothetically, would this problem be solved if everyone ensured that everything they put a view-transition-name on was in the HTML response. (I know we can't ask authors to do that... just trying to build a mental model of the problem)

[11:08:41.0089] <Noam Rosenthal>
> <@etportis:matrix.org> > and its elements are chunked in slowly
> 
> ...and those elements have view-transition-names, right?
> 
> Hypothetically, would this problem be solved if everyone ensured that everything they put a view-transition-name on was in the HTML response. (I know we can't ask authors to do that... just trying to build a mental model of the problem)

HTML responses are chunked though 

[11:09:27.0349] <Noam Rosenthal>
I don‚Äôt think you and I are talking about the same issue 

[11:11:24.0813] <Noam Rosenthal>
The issue is starting a transition from the old doc before the new one has the elements to transition to. This can happen with zero JS, given chunked HTML responses 

[11:14:27.0469] <Eric Portis (he/him)>
That makes sense, and yeah seems like a significant case I hadn't thought of. So you can't limit this to JS-fetched cases.
(Out of curiosity, if you have any data on how often Chrome paints before the last chunk is through, that seems... more attainable that understanding what DOM is "final")

[11:14:53.0779] <Eric Portis (he/him)>
 * That makes sense, and yeah seems like a significant case I hadn't thought of. So you can't limit this to JS-fetched cases.
(Out of curiosity, if you have any data on how often Chrome paints before the last chunk is through, that seems... more attainable than understanding what DOM is "final")

[11:15:04.0327] <Noam Rosenthal>
Oh that happens super often

[11:16:07.0961] <Noam Rosenthal>
FCP < domContentLoaded is very common. Not sure those numbers would tell us an important story 

[11:16:48.0134] <Eric Portis (he/him)>
Yeah, ok

[11:17:39.0584] <Eric Portis (he/him)>
Do you think it makes any kind of sense to tie this to View Transitions? So only block rendering when there's an incoming Transition?

[11:18:06.0658] <Noam Rosenthal>
No, given that this also helps simpler CLS cases

[11:18:42.0989] <Noam Rosenthal>
As in, what people do today by changing the body‚Äôs display css

[11:21:13.0504] <Noam Rosenthal>
Also we want to have less vt-specific things whenever possible 

[11:24:17.0660] <Eric Portis (he/him)>
I don't think that's a pattern we want to make more ergonomic = common, but that's just an opinion and I should back it up with something...

[11:24:34.0810] <Eric Portis (he/him)>
Thanks for the help understanding the issue and where you're coming from on it!

[11:25:21.0739] <Noam Rosenthal>
Sure! Hope we can reach a resolution 


2023-08-12
[22:46:40.0131] <Nicholas Shanks>
Hello. I guess this is the new USENET/IRC.

[22:48:10.0985] <Nicholas Shanks>
I recently discovered that there is no default value for the @scope attribute of the TH element. I always thought it was `row` for children of TBODY and `col` otherwise. Is that not how browsers behave anyway?

[22:51:29.0515] <Nicholas Shanks>
If confirmed, would it be wise to codify that behaviour in the standard? (and, is Ian Hickson still the editor?)

[23:18:09.0686] <Nicholas Shanks>
Hmm, the current developer presentation of the WHATWG edition of the standard differs from waht is published on MDN: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th#scope says "browsers automatically select the set of cells to which the header cell applies" but does not mention the `auto` state, leaving me to think it was up to browsers to create some heuristic of their own. This page https://html.spec.whatwg.org/dev/tables.html#attr-th-scope gives quite a verbose description of the expected behaviour, along with diagrams, but does not specify that succinctly in the description of the `auto` state.

[23:23:16.0008] <Nicholas Shanks>
The description explicity says both `auto` and `rowgroup` do not apply to cells preceding the TH with that scope in the current row (for TH children of TBODY) or rowgroup. It says nothing about if/how the `auto`, `col` and `colgroup` states apply headers to preceding cells.

[23:29:59.0761] <Nicholas Shanks>
Also, the described behaviour of an explicit `rowgroup` value, to not apply to cells in preceding columns, differs from what I would intuitivly have expected. In the diagram, `<th> Cats` does not apply to `<td> 93`. Is that really how browsers and accessibility agents behave?
In other words, `rowgroup` does not mean "rowgroup", it means "cells in this and following columns within this rowgroup"

[23:38:39.0951] <Nicholas Shanks>
More discrepencies:

>The row group state means the header cell applies to all the remaining cells in the row group.

This wording is incorrect according to the Cats/Legs diagram. The behaviour illustrated would correspond to:
"The row group state means the header cell applies to all cells in the current and subsequent columns, within the row group."



[23:44:03.0151] <Nicholas Shanks>
If "remaining cells" was defined to mean cells in remaining columns, would that include cells that span across from a preceding column?

[00:19:47.0407] <Nicholas Shanks>
`scope` was added between September and November 1997: https://www.w3.org/TR/PR-html40-971107/struct/tables.html#adef-scope

> `row`: The current cell provides header information for the rest of the row that contains it.

etc.
So, "the rest of" is clear for row. `rowgroup` is similarly defined, so it is not clear if it includes preceding columns in subsequent rows (as might be interpreted)

[00:24:57.0957] <Nicholas Shanks>
Also the WHATWG text "The remaining headers apply just to the cells to the right of them." should be amended to use logical directionality for RTL tables.

[00:32:12.0367] <Nicholas Shanks>
So, my findings are that the definition of `row` and `col` is consistent with the behaviour of `auto` when the TH is a child of a TBODY, or not, respectivly, though this behaviour is not explicitly defined for auto.

[00:36:22.0968] <Nicholas Shanks>
In other words, the definition of `auto` could be changed from

> The _auto_ state makes the header cell apply to a set of cells selected based on context.

to e.g. "The _auto_ state behaves as if it were set to _row_ if `tbody > tr > th:not([scope])`, and `col` otherwise."

I think this would be a more useful definition.


2023-08-15
[10:20:03.0866] <hsivonen>
Dominic Farolino: https://github.com/web-platform-tests/wpt/blob/master/html/semantics/scripting-1/the-script-element/moving-between-documents/move-back-iframe-fetch-error-external-module.html assumes that a slow stylesheet blocks module scripts from running. AFAICT, in Gecko, only the execution of a parser-blocking script can be deferred by a stylesheet. Where in the spec does it say that non-async (i.e. defer) module scripts wait on style?

[11:46:00.0695] <Dominic Farolino>
I didn't write that tests, so I'll try and reach out to the Googler that did and see if he can explain.

[11:47:25.0257] <Dominic Farolino>
 * I didn't write that test, so I'll try and reach out to the Googler that did and see if he can explain.


2023-08-16
[20:12:50.0341] <mnot>
QQ - WHATWG is listed on the TPAC agenda -- is there an agenda? Is it likely to be well-attended?

[05:24:59.0568] <Noam Rosenthal>
 smaug: question re. https://github.com/whatwg/html/issues/9315#issuecomment-1680504091
In Gecko, when there is a rAF pending, would that block the first paint when coming back from bfcache?

[05:25:41.0780] <smaug>
there shouldn't be rAF pending when coming out of bfcache

[05:26:02.0736] <Noam Rosenthal>
can't you call `requestAnimationFrame` in pagehide?

[05:26:43.0905] <smaug>
sure, but the current rendering might be cached

[05:27:03.0826] <smaug>
and shown to the user and then rAF called

[05:27:23.0302] <Noam Rosenthal>
ok, so it's sort of the same as what we're proposing with reveal

[05:28:05.0595] <smaug>
expect that reveal would force waiting for handling of reveal event before showing anything to the user

[05:28:06.0633] <Noam Rosenthal>
it's guaranteed to be called before the next rAF, and in the case of an actual view transition also guaranteed to be before the first paint - but that's because VT holds painting of the new document, not because of the reveal event itself

[05:28:22.0948] <Noam Rosenthal>
what forces waiting is the fact that there is a view transition, not the reveal event.

[05:29:05.0943] <Noam Rosenthal>
if there is a reveal event without a VT - show the cached image, fire the reveal event, fire the rAF callback if it exists, and continue your life

[05:30:26.0849] <smaug>
Isn't that quite confusing semantics?  In some case reveal would fire when the page has been already revealed to the user and in some case before

[05:31:00.0023] <Noam Rosenthal>
we could also make it wait when there is a reveal event handler, to prevent a flashing effect, if e.g. you're showing a clock

[05:32:07.0961] <Noam Rosenthal>
how does pageshow work in that regard btw? doesn't it have the same confusing aspect?

[05:32:27.0500] <smaug>
Right. I'm just worried about the misuse of the event. Right now bfcache can be really fast, no need to wait for anything.

[05:32:33.0896] <smaug>
pageshow doesn't have

[05:32:52.0188] <smaug>
it has nothing to do with rendering

[05:36:06.0233] <smaug>
if reveal does not have anything to do with rendering (in case when view transitions aren't around), then it would be just a duplicate of pageshow. Which would be a bit weird. 

[05:37:17.0594] <smaug>
Could we possible have an event specific to view transitions?

[05:37:44.0786] <smaug>
Since those anyhow slow down the process of coming out of bfcache or animate that.

[05:37:54.0770] <smaug>
 * Could we possible have an event specific to view transitions? (just a thought)

[05:37:59.0915] <Noam Rosenthal>
The problem with an event specific to view transitions, is that it can be error prone in the sense that you might be expect a VT, but perhaps something in the old document prevented a VT from happening

[05:40:18.0547] <smaug>
don't you want then some notification that VT didn't happen?

[05:40:39.0590] <Noam Rosenthal>
what would that look like? wouldn't that be the same as a reveal event with a null VT?

[05:41:14.0335] <smaug>
maybe, but it would fire only if the page was trying to use vt or something

[05:43:08.0678] <Noam Rosenthal>
yea perhaps we could fire it only when the page has opted-in to view transitions and find a VT-specific name. let me think this over

[06:07:31.0517] <Noam Rosenthal>
smaug: though I still think that `pageshow` already has this same inconsistent aspect (can be before or after first frame), and having an additional event there wouldn't make it more confusing. I don't exactly get what it means that `pageshow` has nothing to do with rendering. In the BFCache-restore case it has as much to do with rendering as `reveal`.

What we were proposing is something that matches `pageshow` exactly, except it's not gated on `load`, and instead gated on document no longer being render-blocked.

[06:08:00.0354] <smaug>
pageshow has nothing to do with rendering

[06:08:33.0544] <smaug>
it is just to tell that page came out of bfcache, or in case of initial page load, it replicated load event

[06:08:40.0184] <smaug>
 * it is just to tell that page came out of bfcache, or in case of initial page load, it replicatea load event

[06:08:45.0945] <smaug>
 * it is just to tell that page came out of bfcache, or in case of initial page load, it replicates load event

[06:18:07.0398] <smaug>
pageshow predates anything like rAF for quite a few years.

[06:19:23.0890] <Noam Rosenthal>
regardless of their purpose, in the case of VT both pageshow and rAF callback would have a different behavior based on whether there is an actual VT or not, and unlike pageshow, rAF is very related to rendering

[06:21:29.0874] <smaug>
why would the behavior of pageshow change in case there is vt around?

[06:21:42.0098] <Noam Rosenthal>
as in, if you call rAF on pagehide, and then restore from BFCache, you might or might not see the previous frame again, based on whether you have a VT

[06:22:20.0071] <Noam Rosenthal>
same with pageshow. When there is a VT, the first frame always waits for the main thread, and the first task in the main thread is to fire pageshow

[06:23:12.0424] <Noam Rosenthal>
so VT: pageshow is before first frame, no VT: pageshow is potentially after cached first frame

[06:23:16.0578] <Noam Rosenthal>
reveal is not different

[06:23:27.0828] <Noam Rosenthal>
(or it could be, but then we risk misuse as you say)

[06:24:56.0130] <hsivonen>
> <@domfarolino:matrix.org> I didn't write that test, so I'll try and reach out to the Googler that did and see if he can explain.

Thanks. And sorry for not checking blame. I saw your name in a comment that suggested perhaps even removing the test that my patch failed.

