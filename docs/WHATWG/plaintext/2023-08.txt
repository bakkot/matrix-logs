2023-08-02
[17:31:19.0890] <Dale Y Pearlman>
Do you know that you can earn $5,000 or more weekly from crypto Trading? With Just $500‚Ä¶ 100% Inbox Admin on Telegram for more details üëáüëáüëáüëáüëáüëá https://t.me/PROFITSWITHSTEVE


2023-08-05
[18:48:47.0643] <zero-one>
i'm looking at the wpt test data for URLs, and i'm a little confused by https://github.com/web-platform-tests/wpt/blob/master/url/resources/urltestdata.json#L4725

[18:49:15.0481] <zero-one>
\uD800 \uD801 isn't a valid surrogate pair, so what exactly is meant by this particular input?

[18:49:28.0165] <zero-one>
my json parser chokes on it, understandably

[23:41:23.0977] <Domenic>
What is meant is to test what the URL parser does on invalid surrogate pairs

[23:41:48.0691] <Domenic>
The algorithm handles them just fine (since it operates on strings, which are sequences of 16-bit code units, including invalid surrogates)

[00:23:59.0027] <zero-one>
I'm sure the URL parser handles it fine, but I think this is invalid JSON

[00:25:32.0474] <zero-one>
will need to dig up a parser that I can tell to ignore invalid surrogate pairs

[00:25:51.0781] <zero-one>
* will need to dig up a JSON parser that I can tell to ignore invalid surrogate pairs

[01:34:50.0074] <Domenic>
JSON.parse() works fine on it

[07:34:08.0851] <Richard Gibson>
`"\uD800\uD801"` is valid JSON but not guaranteed to be interoperable (especially if the decoder is in a language that internally uses UTF-8 for strings), cf. https://www.rfc-editor.org/rfc/rfc8259#section-8.2
> However, the ABNF in this specification allows member names and string values to contain bit sequences that cannot encode Unicode characters; for example, "\uDEAD" (a single unpaired UTF-16 surrogate)‚Ä¶ The behavior of software that receives JSON texts containing such values is unpredictable; for example, implementations might return different values for the length of a string value or even suffer fatal runtime exceptions.


2023-08-07
[22:54:02.0956] <hsivonen>
KBar, Ms2ger , Sam Sneddon [:gsnedders] , jgraham , emilio : I'm not aware of about:blank quirkiness constraints beyond: a) It's that way, because it has always been (and its logical given the lack of doctype) and b) the cases where the difference would be detectable are motivations both for and against changing it (folks who want the standards mode have a reason to change but existing content that puts stuff there could be adversely affected by a change).


2023-08-08
[02:59:18.0413] <Jake Archibald>
Let's say Origin A contains an iframe to Origin B. Is it possible for Origin A to create another Origin B iframe without requiring another main fetch to Origin B? I was hoping I could use a blob url passed back from the Origin B iframe, but that doesn't seem to work https://static-misc-2.glitch.me/iframe-host/


2023-08-09
[15:50:24.0836] <amine khadraoui>
Hey


2023-08-10
[01:24:12.0288] <Domenic>
@allstarschh: In general pinging someone less than 24 hours after you've already done so is not necessary. Especially for such a non-urgent PR. I'll try to make time for the PR next week, but it's 17:30 and tomorrow's a holiday, so please have some patience.

[01:26:05.0870] <@allstarschh>
Domenic: oh, thanks, I saw the reviewer is not set and I don't know if I should set that or someone will set it, the issue is not urgent, 

[01:46:56.0336] <freddy>
Jake Archibald: there's an (early stage) proposal for websites to mark a blob as crossOrigin accessible. https://github.com/w3c/FileAPI/issues/192. In your case, this would require Origin B to opt in.

[02:05:14.0048] <Jake Archibald>
freddy: isn't that the opposite of what I'm looking for? It seems like the resulting resource would be different-origin to Origin B.

[02:07:54.0309] <freddy>
Right. ü§¶‚Äç‚ôÇÔ∏è

[02:10:54.0475] <Jake Archibald>
I guess that confirms annevk's worry about the property name. It does initially look like it means the opposite.

[02:29:48.0230] <hsivonen>
The spec describes both classic async scripts and module async scripts as executing as soon as they are available. In reality, classic async scripts may execute a tiny bit later, but since the exact moment of network response finishing isn't exposed, the tiny bit later looks as if it was part of the network timing. However, for inline async scripts that have no external dependencies, "as soon as they are available" in principle has a well-defined point in time relative to the HTML parse. However, it seems bad to grant special guarantees to that case. Do I understand correctly that the spec doesn't mean to grant guarantees about that special case and it's OK for the parse to progress a bit before an inline async module script without external dependencies executes?

[02:30:12.0235] <hsivonen>
^ @allstarschh 

[02:30:48.0126] <hsivonen>
 * The spec describes both classic async scripts and module async scripts as executing as soon as they are available. In reality, classic async scripts may execute a tiny bit later, but since the exact moment of network response finishing isn't exposed, the tiny bit later looks as if it was part of the network timing. However, for inline async module scripts that have no external dependencies, "as soon as they are available" in principle has a well-defined point in time relative to the HTML parse. However, it seems bad to grant special guarantees to that case. Do I understand correctly that the spec doesn't mean to grant guarantees about that special case and it's OK for the parse to progress a bit before an inline async module script without external dependencies executes?

[02:32:02.0728] <hsivonen>
It would be unfortunate to have to use the `document.write` accommodating execution path in Gecko for inline async module scripts just because the spec granted that special case a special guarantee that goes away as soon as the module has an external dependency.

[02:32:38.0061] <hsivonen>
(I gather that in any case, module scripts are prohibited from using `document.write`, so the guarantee would be only about the specific observable DOM shape.)

[02:43:56.0922] <hsivonen>
Well, at least Chrome doesn't grant that guarantee. I guess I need to file a spec issue to avoid suggesting a specific execution time.

[02:46:12.0059] <hsivonen>
Demo: https://hsivonen.com/test/moz/inline-async-module-script-without-deps.html

[03:05:59.0860] <hsivonen>
Filed as https://github.com/whatwg/html/issues/9597

[10:35:03.0534] <Eric Portis (he/him)>
Noam Rosenthal: Re: https://github.com/whatwg/html/issues/9332#issuecomment-1673580721, do you have any sense of what % of sites currently render before all of the ~final/stable above-the-fold DOM nodes are in the DOM? I guess 100% of client side rendered sites -- is that the main (only?) use case here?

[10:43:14.0323] <Noam Rosenthal>
> <@etportis:matrix.org> Noam Rosenthal: Re: https://github.com/whatwg/html/issues/9332#issuecomment-1673580721, do you have any sense of what % of sites currently render before all of the ~final/stable above-the-fold DOM nodes are in the DOM? I guess 100% of client side rendered sites -- is that the main (only?) use case here?

I don‚Äôt think we can have that info, stable is subjective and dependent on content

[10:50:28.0143] <Eric Portis (he/him)>
Noam Rosenthal: That makes sense. I'm just trying to get a sense of the need, here -- what's driving this. Paving a bad cowpath (anti-flicker snippets, used for all kinds of reasons) is a cost.

[10:52:26.0446] <Eric Portis (he/him)>
 * Noam Rosenthal: That makes sense. I'm just trying to get a sense of the need, here -- what's driving this. Paving a bad cowpath (anti-flicker snippets, used for all kinds of reasons) is a cost.(

[10:52:29.0508] <Eric Portis (he/him)>
(And hunt around for a more-scoped solution for the subset of problematic cases)

[10:52:58.0828] <Eric Portis (he/him)>
 * Noam Rosenthal: That makes sense. I'm just trying to get a sense of the need, here -- what's driving this. Paving a bad cowpath (anti-flicker snippets, used for all kinds of reasons) is a cost.

[10:55:41.0378] <Noam Rosenthal>
> <@etportis:matrix.org> (And hunt around for a more-scoped solution for the subset of problematic cases)

What‚Äôs driving this is view transitions. But the use case has been around way before that, to avoid ugly layout shifts and flashes due to important elements not being parsed yet 

[10:58:51.0996] <Eric Portis (he/him)>
Right. Something slowly animating out and then popping back in, in the same spot, late is much, much worse than something just popping in late -- I get the extra need for it for View Transitions. But is there a subset of sites that this affects? It's pages that are fetching content in JS, right? I could put a view-transition-name on something at the bottom of HTML spec single-page and it won't matter that the parser has already yielded to the renderer, because that element is a mile outside of the viewport...?

