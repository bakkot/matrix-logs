2022-01-01
[19:04:44.0380] <EveryOS>
If I were in charge of the web, I'd probably tell GitHub to change GitHub pages or they'd be left behind
(It's probably a good thing I'm not in charge of the web)

[09:09:38.0243] <devsrealmguy>
Hi people, hope you are having a good day. I have a question, how would one unit test the correctness of an HTML parser, should I just find several malformed html pages and test against what Chrome or Mozilla parses in the browser, I'll also appreciate it there are links to test cases, e.g if you have so so so malformed structure, you get the following output, something like that. I have seen few but I need more to test rigorously. Thanks

[09:15:25.0029] <Alan Stearns>
devsrealmguy: you may get a better response on https://matrix.to/#/#wpt:matrix.org (though there is a lot of shared people between these rooms)

[09:16:22.0205] <devsrealmguy>
Thanks, I'll join the room now

[11:13:27.0681] <Luca Casonato>
annevk Am I correct in my interpretation that `Foo: abc, xyz\r\n` and `Foo: abc\r\nFoo: xyz\r\n` are both fetch spec compliant on the wire encodings for a request issued with `fetch` as follows?
```js
fetch(url, { headers: [["Foo", "abc"], ["Foo", "xyz"]] })
```


2022-01-02
[07:31:45.0943] <sideshowbarker>
https://stackoverflow.com/questions/70553932/fetch-api-abort-doesnt-works-after-1st-cancel

[10:26:02.0682] <sideshowbarker>
I’m trying to clone an `SVGRect` object using `structuredClone()`, but am getting _DataCloneError: The object could not be cloned` error_ — because, I guess, the `SVGRect` object isn’t serializable.

[10:26:25.0558] <sideshowbarker>
But what part of it wouldn’t be serializable?

[10:28:39.0384] <sideshowbarker>
Specifically, what I have is an SVG `marker` element with a `viewBox` attribute, and I assign that to a `marker` variable, and when I log `console.log(marker.viewBox.baseVal), the browser logs this:
```js
[object SVGRect] {
  height: 10,
  width: 10,
  x: 0,
  y: 0
```

[10:30:04.0258] <sideshowbarker>
…but if I then do this:
```js
let foo = self.structuredClone(marker.viewBox.baseVal);
```
…it fails and that browser logs that _DataCloneError: The object could not be cloned_ 

[10:30:11.0671] <sideshowbarker>
 * …but if I then do this:
```js
let foo = self.structuredClone(marker.viewBox.baseVal);
```

…it fails and that browser logs that _DataCloneError: The object could not be cloned_ error

[10:30:22.0717] <sideshowbarker>
 * …but if I then do this:
```js
let foo = self.structuredClone(marker.viewBox.baseVal);
```

…it fails, and the browser logs that _DataCloneError: The object could not be cloned_ error

[10:30:34.0791] <sideshowbarker>
 * …but if I then do this:
```js
let foo = structuredClone(marker.viewBox.baseVal);
```

…it fails, and the browser logs that _DataCloneError: The object could not be cloned_ error

[10:32:21.0213] <sideshowbarker>
 * I’m trying to clone an `SVGRect` object using `structuredClone()`, but am getting a *DataCloneError: The object could not be cloned`error* — because, I guess, the`SVGRect` object isn’t serializable.

[10:32:43.0697] <sideshowbarker>
 * I’m trying to clone an `SVGRect` object using `structuredClone()`, but am getting a _DataCloneError: The object could not be cloned_ error — because, I guess, the`SVGRect` object isn’t serializable.

[11:59:02.0426] <sideshowbarker>
* …but if I then do this:
```js
let foo = structuredClone(marker.viewBox.baseVal);
```

…it fails, and the browser logs that *DataCloneError: The object could not be cloned* error

[12:46:49.0240] <Andreu Botella (he/they)>
Web APIs are by default not serializable, even with `DOMRect`, which is as close to a plain object as it gets

[12:47:29.0258] <Andreu Botella (he/they)>
Maybe it'd be worth it to try and identify such interfaces

[12:55:26.0084] <sideshowbarker>
I see


2022-01-03
[16:17:11.0133] <Domenic>
It is kind of understandable that SVGRect is not serializable though. It is not a plain object; it has an inner connection to a SVG element. And serializing that across realm boundaries is tricky.

[16:17:23.0319] <Domenic>
DOMRect is very simple though and could be made serializable.

[16:17:51.0184] <Domenic>
I believe the spec still says SVGRect is simple but this was a misstep in the spec and they need to change it back to match implementations https://github.com/w3c/svgwg/issues/706

[16:17:54.0714] <Domenic>
We ran into this in jsdom

[16:18:35.0701] <Andreu Botella (he/they)>
TIL

[00:12:02.0920] <annevk>
Luca Casonato: I guess it's strictly speaking not defined, yeah

[01:26:47.0804] <annevk>
Luca Casonato: given that people notice it we might still want to define it though

[01:29:31.0544] <Luca Casonato>
I guess we could. The current spec language makes what Deno does the most obvious thing to do I think, as headers in the inner header list are not concatenated. Chrome and FF both concatenate the headers on the wire it seems. I didn’t check Safari or Cloudflare Workers

[01:36:51.0738] <Luca Casonato>
And annevk, as for who noticed that: the author of node-fetch. Have received no reports from “regular” users who are not intimately familiar with the fetch spec.

[01:39:57.0596] <annevk>
Yeah fair

[01:40:25.0401] <annevk>
Combining is also tricky for Set-Cookie, though that's tricky anyway atm

[03:26:30.0518] <csarven>
Is it possible to request target in `asterisk-form` (`OPTIONS *`) with the fetch (or another) API? Any pointers on history/discussion would be great.

[03:33:08.0954] <csarven>
 * Is it possible to request target in `asterisk-form` (`OPTIONS *`) with fetch, xhr (or another)? Any pointers on history/discussion would be great.

[04:35:46.0278] <annevk>
csarven: it's not possible, don't recall discussion

[12:47:46.0417] <sideshowbarker>
Would it be inaccurate to describe the WebIDL `readonly` keyword as essentially meaning “not assignable”?

[15:24:43.0021] <EveryOS>
sideshowbarker: It's accurate 


2022-01-04
[16:21:21.0605] <sideshowbarker>
EveryOS: thanks

[16:21:41.0078] <EveryOS>
You're welcome

[16:24:41.0236] <sideshowbarker>
looking now at https://github.com/mdn/content/issues/11697 I find that the CSP spec no browsers seem to conform to the CSP spec requirement to block `element.style.cssText = 'display:none'` in the same way they block `element.setAttribute('style', 'display:none;')`

[16:25:11.0672] <sideshowbarker>
and looking at WPT, I find we have no tests for it https://wpt.fyi/results/content-security-policy/style-src?label=experimental&label=master&aligned

[16:27:07.0381] <sideshowbarker>
step 4 at https://w3c.github.io/webappsec-csp/#directive-style-src is where the relevant requirement is defined, and it even explicitly mentions:
> This would include, for example, all invocations of CSSOM’s various `cssText` setters and `insertRule` methods

[16:27:38.0826] <sideshowbarker>
 * step 4 at https://w3c.github.io/webappsec-csp/#directive-style-src is where the relevant requirement is defined, and it even explicitly mentions, <i>This would include, for example, all invocations of CSSOM’s various <code>cssText</code> setters and <code>insertRule</code> methods</i>

[16:28:15.0608] <sideshowbarker>
 * step 4 at https://w3c.github.io/webappsec-csp/#directive-style-src is where the relevant requirement is defined, and it even explicitly mentions, *This would include, for example, all invocations of CSSOM’s various `cssText` setters and `insertRule` methods*

[16:28:27.0456] <sideshowbarker>
 * step 4 at https://w3c.github.io/webappsec-csp/#directive-style-src is where the relevant requirement is defined, and it even explicitly mentions, This would include, for example, all invocations of CSSOM’s various `cssText` setters and `insertRule` methods

[16:28:37.0917] <sideshowbarker>
 * step 4 at https://w3c.github.io/webappsec-csp/#directive-style-src is where the relevant requirement is defined, and it even explicitly mentions
> This would include, for example, all invocations of CSSOM’s various `cssText` setters and `insertRule` methods

[16:28:48.0025] <sideshowbarker>
 * step 4 at https://w3c.github.io/webappsec-csp/#directive-style-src is where the relevant requirement is defined, and it even explicitly mentions:
> This would include, for example, all invocations of CSSOM’s various `cssText` setters and `insertRule` methods

[16:29:29.0068] <sideshowbarker>
 * looking now at https://github.com/mdn/content/issues/11697 I find that no browsers seem to conform to the CSP spec requirement to block `element.style.cssText = 'display:none'` in the same way they block `element.setAttribute('style', 'display:none;')`


2022-01-05
[08:40:46.0490] <annevk>
sideshowbarker: there are some existing CSP + CSS issues, not sure if they cover this

[08:42:05.0697] <annevk>
Oh right, the spec even links https://github.com/w3c/webappsec-csp/issues/212

[11:06:34.0650] <sideshowbarker>
annevk: thanks

[12:04:02.0755] <bakkot>
I've just learned that `postMessage` is async, such that if you do `worker.postMessage(); while (true) {}` the message will never actually fire. Is there a reason for this? If no, could it be changed, possibly as an opt-in option? This comes up in the context of emscripten.

[12:09:29.0250] <Andreu Botella (he/they)>
I don't think that's true per the spec

[12:09:30.0043] <Andreu Botella (he/they)>
https://html.spec.whatwg.org/multipage/workers.html#dom-worker-postmessage

[12:10:25.0841] <Andreu Botella (he/they)>
The only task or microtask queued in that algorithm is the one that is actually queued on the worker's event loop

[12:12:14.0827] <Andreu Botella (he/they)>
But I guess it comes down to the notion of observability, since you can't observe the result of a task in a worker thread if the main thread is stuck in a loop

[12:13:34.0204] <bakkot>
you can with a SAB

[12:13:46.0792] <Andreu Botella (he/they)>
True. Then this is a bug

[12:25:56.0599] <bakkot>
MDN has it documented:

> After postMessage() is called, the MessageEvent will be dispatched only after all pending execution contexts have finished. For example, if postMessage() is invoked in an event handler, that event handler will run to completion, as will any remaining handlers for that same event, before the MessageEvent is dispatched.

[12:28:02.0789] <bakkot>
I can't actually tell from reading the spec if the "add a task" implies adding it on the current thread or the worker's, but I'll take your word for it.

[12:30:32.0783] <Andreu Botella (he/they)>
That task fires the `message` event, and event firing is synchronous, so it must be on the worker's thread

[12:47:33.0759] <Domenic>
I think this is related to https://github.com/whatwg/html/issues/3691 . Basically, postMessage() infrastructure assumes the target could be cross-process. Although this is not true for dedicated workers it could be for iframes or shared/service workers. The spec as-written doesn't really acknowledge this so it acts as if you can get synchronous access to the target's message queue. But, in general, you cannot; if your process is busy-looping you're gonna have a hard time pushing messages across process boundaries, I believe.

[12:48:21.0468] <Domenic>
So in theory implementations could maybe special-case dedicatedWorker.postMessage() to make that work even in the presence of busy loops. In practice that'd probably be quite involved as they'd essentially have to create a parallel message-queuing infrastructure for dedicated workers only.

[12:54:06.0434] <bakkot>
huh, ok, it looks like I was actually wrong (I wrote a test case but it was bugged) and the MDN page is are also wrong

[12:54:21.0188] <bakkot>
here's my test case (now that I've fixed it)

```
let workerSrc = `
let arr;
self.addEventListener('message', e => {
  switch (e.data.message) {
    case 'init': {
      console.log('worker: got init');
      arr = new Int32Array(e.data.buf);
      Atomics.notify(arr, 0);
      break;
    }
    case 'next': {
      console.log('worker: got next');
      arr[1] = 1;
      break;
    }
  }
});
`;
let blob = new Blob([workerSrc], {type: 'application/javascript'});
let worker = new Worker(URL.createObjectURL(blob));

(async () => {
  let buf = new SharedArrayBuffer(16);
  let arr = new Int32Array(buf);
  worker.postMessage({ message: 'init', buf });

  if (typeof Atomics.waitAsync === 'function') {
    await Atomics.waitAsync(arr, 0, 0).value;
  } else {
    // give the worker time to start
    await new Promise(res => setTimeout(res, 1000));
  }

  console.log('init');
  worker.postMessage({ message: 'next' });

  console.log('now we busy-wait, with arr[1] initially =', arr[1]);
  for (let i = 0; i < 1e8; ++i) {
    if (arr[1] === 1) {
      console.log('done! took until i =', i);
      return;
    }
  }
  console.log('never initialized');
})().catch(e => console.error('error', e));
```

[12:54:47.0964] <bakkot>
in chrome and FF this does actually finish; FF seems to take literally no iterations of the loop, where chrome takes a couple hundred

[12:54:56.0127] <bakkot>
apologies for the confusion

[12:57:22.0464] <bakkot>
 * huh, ok, it looks like I was actually wrong (I wrote a test case but it was bugged) and the MDN page is also wrong

[13:38:49.0121] <aliray>
Hi, could someone explain main what is the purpose of this line? https://github.com/html5lib/html5lib-python/blob/master/html5lib/_inputstream.py#L141

