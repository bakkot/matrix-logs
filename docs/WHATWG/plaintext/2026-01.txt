2026-01-02
[09:54:55.0846] <Cheri Goldfinch>
Hu

[10:43:16.0211] <jmdyck>
hu?


2026-01-04
[09:40:28.0260] <nektro>
In https://url.spec.whatwg.org/#pointer it says "When the pointer points to nowhere c cannot be used." Does this mean in https://url.spec.whatwg.org/#concept-basic-url-parser that when pointer is -1 and c is used, returning a failure is inferred or that it's a bug?

[09:42:00.0117] <nektro>
step 9 says what to do if pointer is eof but not nowhere

[09:46:04.0340] <nektro>
should there be an item after step 5 checking that input is valid in encoding ?

[09:48:57.0901] <nektro>
should step 5 be moved up since step 1 is already querying the contents of input ?

[12:27:18.0447] <nektro>
or does c pointing nowhere mean "If c is" simply yields false


2026-01-05
[23:51:34.0764] <annevk>
nektro: step 5 doesn't impact _input_ so I don't think anything is wrong there. You might be right that the scheme start state should only decrease pointer when it's not pointing to the start of _input_.

[23:54:28.0708] <nektro>
scheme start state is always at the start of input

[23:55:24.0874] <nektro>
* scheme start state is always at the start of *input*

[23:56:13.0901] <nektro>
if *encoding* doesn't affect *input* then where is *input* validated as utf-8, or is it not?

[00:03:01.0392] <annevk>
nektro: _input_ is a scalar value string, it's not a byte sequence.

[00:07:49.0286] <annevk>
I think the reason the pointer logic works in scheme start state is because after the state is over pointer gets incremented by 1 so it'll be 0 again. I agree it's not great, but reworking all that is involved.

[00:09:21.0018] <nektro>
thanks :)

[01:28:10.0274] <Jake Archibald>
annevk: https://github.com/whatwg/html/pull/12021 should be good to land now. I got the ipr stuff sorted

[14:49:15.0279] <mfreed>
Hi all, just a friendly reminder to post any discussion topics for this Thursday's joint CSSWG/WHATWG/OpenUI task force meeting to the meeting agenda issue: https://github.com/whatwg/html/issues/12012


2026-01-07
[07:35:01.0526] <krosylight (they/them)>
annevk: Regarding https://wpt.fyi/results/html/semantics/forms/the-input-element?label=master&label=experimental&aligned&q=color.window.html's "Testing '#ffffff08' with color space 'limited-srgb' and with alpha (setAttribute("value"))", the test does:

1. `setAttribute("value", color)`
2. Expects value is set as alpha-less hex
3. Set `.alpha = true`
4. Expect the alpha value revives

Where does alpha revive from? "update a color well color" overwrites element's value and doesn't seem to do `getAttribute("value")`-equivalent thing. Am I missing something again?

[07:38:23.0142] <krosylight (they/them)>
* annevk: Regarding https://wpt.fyi/results/html/semantics/forms/the-input-element?label=master&label=experimental&aligned&q=color.window.html 's "Testing '#ffffff08' with color space 'limited-srgb' and with alpha (setAttribute("value"))", the test does:

1. `setAttribute("value", color)`
2. Expects value is set as alpha-less hex
3. Set `.alpha = true`
4. Expect the alpha value revives

Where does alpha revive from? "update a color well color" overwrites element's value and doesn't seem to do `getAttribute("value")`-equivalent thing. Am I missing something again?

[07:38:49.0681] <krosylight (they/them)>
* annevk: Regarding https://wpt.fyi/results/html/semantics/forms/the-input-element/color.window.html?label=master&label=experimental&aligned&q=color.window.html 's "Testing '#ffffff08' with color space 'limited-srgb' and with alpha (setAttribute("value"))", the test does:

1. `setAttribute("value", color)`
2. Expects value is set as alpha-less hex
3. Set `.alpha = true`
4. Expect the alpha value revives

Where does alpha revive from? "update a color well color" overwrites element's value and doesn't seem to do `getAttribute("value")`-equivalent thing. Am I missing something again?

[08:05:36.0687] <annevk>
krosylight (they/them): it's been quite a while since I worked on this, but it's possible that step 2 of https://html.spec.whatwg.org/multipage/input.html#update-a-color-well-control-color should look at the value attribute and not the value concept. Because you do want to be able to set these attributes in a somewhat arbitrary order.

[08:07:30.0969] <annevk>
Although not sure how to match that up with what WebKit is doing.

[08:07:31.0772] <krosylight (they/them)>
but that way it's more complex about what value is used...

[08:09:12.0170] <krosylight (they/them)>
* but that way it's more complex about which value is used...

[08:09:21.0731] <krosylight (they/them)>
Anyway I'll file a bug, we can talk there

[08:09:41.0304] <krosylight (they/them)>
(happy that I didn't miss details this time üôÇ)

[08:12:36.0845] <annevk>
Sounds good. Please explain there how it's way more complex as I'm not immediately seeing it. I do think what that test expects is probably desirable for web developers.

[08:12:47.0625] <annevk>
* Sounds good. Please explain there how it's way more complex as I'm not immediately seeing it. I do think what that test expects is desirable for web developers.

[08:27:15.0143] <krosylight (they/them)>
(me now thinks it's just a matter of checking dirty flag)

[08:27:19.0298] <krosylight (they/them)>
https://github.com/whatwg/html/issues/12057


2026-01-08
[00:04:17.0975] <annevk>
AI comments are annoying. They're verbose and usually not very useful. Latest I suspect: https://github.com/whatwg/html/issues/5867#issuecomment-3720854771

[00:14:25.0196] <sideshowbarker>
Footnotes! We finally have a use case~ Wake up Jake!

[07:44:47.0884] <sb3nder>
Does anybody know why firefox do a sort of implicit pointer-capture for text controls?

[07:47:24.0104] <sb3nder>
* Does anybody know why firefox do a sort of implicit pointer-capture for text controls?
Edit: never mind, I get it now.

[10:51:31.0250] <Luke Warlow>
So til that for html `<a> or <area>` if you toString() them you get their href value. Is that considered esoteric legacy stuff or fair game to copy elsewhere?

[10:56:31.0298] <bkardell>
TIL too

[10:58:53.0775] <bkardell>
that has to be weird/esoteric - I kind of get it in a few cases in HTML, but even there it feels like it would be worse a lot of time.


2026-01-09
[06:03:28.0606] <annevk>
zcorpan: tests for https://github.com/whatwg/html/pull/12021 are not merged yet

[06:04:50.0557] <zcorpan>
annevk: Yep, looks like they're ready except for a nit

[06:46:29.0737] <Luke Warlow>
I'm afk but happy either way so if someone wants to push the nit change, go for it.


2026-01-10
[23:17:25.0838] <nektro>
should the "Otherwise"s in https://url.spec.whatwg.org/#concept-ipv6-parser under step 6.5.5.4.2 be step 3 and 4 respectively?

[23:18:08.0310] <nektro>
* should the "Otherwise"s in https://url.spec.whatwg.org/#concept-ipv6-parser under step 6.5.5.4.2 be step 3 and 4 respectively? (with 3 and 4 becoming 5 and 6)

[00:31:40.0937] <annevk>
nektro: that seems like it would be a useful change, yeah. Are you willing to make it?

[00:44:20.0992] <nektro>
sure thing üëçÔ∏è

[00:54:55.0777] <nektro>
https://github.com/whatwg/url/pull/894


2026-01-11
[17:35:48.0921] <nektro>
for https://url.spec.whatwg.org/#ipv4-number-parser would it make sense to have *output* not fitting a u8 be an explicit failure condition, rather than only catching it in https://url.spec.whatwg.org/#concept-ipv4-parser step 6 ?

[17:38:43.0199] <nektro>
hm thatd be tricky because itd mess up https://url.spec.whatwg.org/#ends-in-a-number-checker

[17:42:37.0167] <nektro>
i see what i need to do

[00:10:39.0830] <annevk>
Yeah, there's also a step a bit beyond 6 that allows it to be quite a bit bigger. üòä (Now if you only care about valid IPv4 addresses, you might be able to make certain optimizations.)


2026-01-12
[04:26:20.0232] <smaug>
/me cries a little bit. Yet [another](https://html.spec.whatwg.org/#:~:text=Prepare%20to%20run%20script%20given%20document%27s%20relevant%20settings%20object%2E) "let's break how microtasks work" special case.

[04:26:55.0106] <smaug>
/me * cries a little bit. Yet [another](https://html.spec.whatwg.org/#:~:text=Prepare%20to%20run%20script%20given%20document%27s%20relevant%20settings%20object%2E) "let's break how microtasks work" special case. (but maybe he did review that change? Hard to get back to the spec issue from the commit message)

[04:30:08.0989] <Noam Rosenthal>
This was me and it was thoroughly reviewed.

[04:31:02.0908] <Ms2ger>
https://github.com/whatwg/html/pull/10284

[04:32:40.0271] <Noam Rosenthal>
Yea I think we had the discussion about this with Domenic elsewhere... 

[04:33:13.0781] <smaug>
Looks like google only patch and review

[04:33:21.0567] <Noam Rosenthal>
the problem with microtasks in the rendering loop is that they might be postponed until the end of the rendering task and that's a no-man's land

[04:33:54.0786] <smaug>
Oh, I do understand how microtasks work and what their limitations are üòõ 

[04:34:38.0442] <smaug>
but it is getting really hard to explain how microtasks work given the special cases. Navigation API has similar weird special case

[04:34:54.0270] <Noam Rosenthal>
yea agreed, there are a few of those

[04:35:03.0730] <Noam Rosenthal>
but really I think those special cases can be counted on one hand

[04:36:26.0901] <sideshowbarker>
so we have enough to start a Quirks spec for microtasks

[04:36:29.0678] <Noam Rosenthal>
I suggested before to have something like an isolated promise resolver algorithm that does this... it's probably easier to explain then wrapping each of these separately

[04:36:37.0408] <Ms2ger>
Does it need to be an AI-generated hand? üòá

[04:40:10.0273] <Noam Rosenthal>
The quirky things about microtasks is when they need to fire before of other things in the same task... then you need to wrap them with this prepare/cleanup thingy. I think the right way to explain it is to have some sort of isolated wrapper for this but it wouldn't look much different from those prepare/cleanup pairs

The latter one is really confusing 


[04:40:17.0104] <Noam Rosenthal>
* The quirky things about microtasks is when they need to fire before of other things in the same task... then you need to wrap them with this prepare/cleanup thingy. I think the right way to explain it is to have some sort of isolated wrapper for this but it wouldn't look much different from those prepare/cleanup pairs


[04:40:55.0264] <Noam Rosenthal>
* The quirky things about microtasks is when they need to fire before other things in the same task... then you need to wrap them with this prepare/cleanup thingy. I think the right way to explain it is to have some sort of isolated wrapper for this but it wouldn't look much different from those prepare/cleanup pairs


[04:41:49.0181] <Noam Rosenthal>
(though so far this sounds like more like a group rant than an attempt to fix things, so perhaps I'd leave it to that)

[04:46:03.0525] <smaug>
I guess we'd need conceptual MilliTasks, and Microtasks would run then at  the end of outermost script execution or end of millitask or task.

[04:46:46.0742] <Noam Rosenthal>
we kind of have that. you can call script execution blocks millitasks

[04:46:59.0825] <Noam Rosenthal>
(I wouldn't use the term, but the concept exist)

[04:49:09.0410] <Noam Rosenthal>
but really what I found myself looking for a few times is more like "when you resolve this promise, if there is no active script, also perform a microtask checkpoint and flush the world". the default behavior of delaying that to the end of the task is what's quirky

[04:50:19.0207] <smaug>
yeah, that largely comes from the fact that microtasks weren't designed for promises

[04:50:54.0309] <Noam Rosenthal>
(end of the task or an event handler or callback that might happen to run)

[04:51:42.0998] <Noam Rosenthal>
sure, but that's why a wrapper to "resolve a promise" or to wrap a prepare/cleanup pair for promise resolution and expose that in an algo is not a bad solution

[04:53:07.0411] <smaug>
it makes explaining microtasks hard. "usually microtasks run at this time, but then we have these special cases"

[04:53:59.0229] <Noam Rosenthal>
they run when the JS stack is emptied from running scripts or at the end of the task. We can say that these promise-based entry points create a JS Stack

[04:55:02.0094] <Noam Rosenthal>
it's not a "special case" per se, it creates JS stacks/scopes whatever when there is a promise-based API callback

[05:19:04.0310] <Noam Rosenthal>
The alternative way to explain this is by having these sub-tasks be tasks and manage the order via task queues... I'm pretty sure that would be more cumbersome and won't solve anything.


2026-01-13
[20:43:38.0877] <aresuii>
@sideshowbarker:matrix.org who was that guy

[20:44:02.0951] <sideshowbarker>
no idea

[20:57:30.0936] <aresuii>
ok but what is "Guest Standard"

[01:44:00.0860] <smaug>
We can do something like that yes, and have consistent behavior for all Promise APIs. It does change the meaning of microtasks though, a bit, if JS doesn't really run. But anyhow, that would be better than having the current ad-hoc "let's run microtasks here".

[02:56:05.0398] <Noam Rosenthal>
Does something like "Perform a promise entry point with the following step: activate view transition" sound right?

[03:02:37.0245] <Noam Rosenthal>
There are a few promise entry points which don't work like this, e.g. ones that fire multiple promises and events as part of one stack and rely on the behavior of the microtask queue firing at the end of the stack. but I think probably that should be the exception

[03:05:35.0082] <annevk>
zcorpan: rs? https://github.com/whatwg/html/pull/12060

[03:07:45.0023] <Noam Rosenthal>
Approved, but I now see you asked specifically from zcorpan 

[03:12:52.0316] <zcorpan>
annevk: reviewed and merged

