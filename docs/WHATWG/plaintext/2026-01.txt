2026-01-02
[09:54:55.0846] <Cheri Goldfinch>
Hu

[10:43:16.0211] <jmdyck>
hu?


2026-01-04
[09:40:28.0260] <nektro>
In https://url.spec.whatwg.org/#pointer it says "When the pointer points to nowhere c cannot be used." Does this mean in https://url.spec.whatwg.org/#concept-basic-url-parser that when pointer is -1 and c is used, returning a failure is inferred or that it's a bug?

[09:42:00.0117] <nektro>
step 9 says what to do if pointer is eof but not nowhere

[09:46:04.0340] <nektro>
should there be an item after step 5 checking that input is valid in encoding ?

[09:48:57.0901] <nektro>
should step 5 be moved up since step 1 is already querying the contents of input ?

[12:27:18.0447] <nektro>
or does c pointing nowhere mean "If c is" simply yields false


2026-01-05
[23:51:34.0764] <annevk>
nektro: step 5 doesn't impact _input_ so I don't think anything is wrong there. You might be right that the scheme start state should only decrease pointer when it's not pointing to the start of _input_.

[23:54:28.0708] <nektro>
scheme start state is always at the start of input

[23:55:24.0874] <nektro>
* scheme start state is always at the start of *input*

[23:56:13.0901] <nektro>
if *encoding* doesn't affect *input* then where is *input* validated as utf-8, or is it not?

[00:03:01.0392] <annevk>
nektro: _input_ is a scalar value string, it's not a byte sequence.

[00:07:49.0286] <annevk>
I think the reason the pointer logic works in scheme start state is because after the state is over pointer gets incremented by 1 so it'll be 0 again. I agree it's not great, but reworking all that is involved.

[00:09:21.0018] <nektro>
thanks :)

[01:28:10.0274] <Jake Archibald>
annevk: https://github.com/whatwg/html/pull/12021 should be good to land now. I got the ipr stuff sorted

[14:49:15.0279] <mfreed>
Hi all, just a friendly reminder to post any discussion topics for this Thursday's joint CSSWG/WHATWG/OpenUI task force meeting to the meeting agenda issue: https://github.com/whatwg/html/issues/12012


2026-01-07
[07:35:01.0526] <krosylight (they/them)>
annevk: Regarding https://wpt.fyi/results/html/semantics/forms/the-input-element?label=master&label=experimental&aligned&q=color.window.html's "Testing '#ffffff08' with color space 'limited-srgb' and with alpha (setAttribute("value"))", the test does:

1. `setAttribute("value", color)`
2. Expects value is set as alpha-less hex
3. Set `.alpha = true`
4. Expect the alpha value revives

Where does alpha revive from? "update a color well color" overwrites element's value and doesn't seem to do `getAttribute("value")`-equivalent thing. Am I missing something again?

[07:38:23.0142] <krosylight (they/them)>
* annevk: Regarding https://wpt.fyi/results/html/semantics/forms/the-input-element?label=master&label=experimental&aligned&q=color.window.html 's "Testing '#ffffff08' with color space 'limited-srgb' and with alpha (setAttribute("value"))", the test does:

1. `setAttribute("value", color)`
2. Expects value is set as alpha-less hex
3. Set `.alpha = true`
4. Expect the alpha value revives

Where does alpha revive from? "update a color well color" overwrites element's value and doesn't seem to do `getAttribute("value")`-equivalent thing. Am I missing something again?

[07:38:49.0681] <krosylight (they/them)>
* annevk: Regarding https://wpt.fyi/results/html/semantics/forms/the-input-element/color.window.html?label=master&label=experimental&aligned&q=color.window.html 's "Testing '#ffffff08' with color space 'limited-srgb' and with alpha (setAttribute("value"))", the test does:

1. `setAttribute("value", color)`
2. Expects value is set as alpha-less hex
3. Set `.alpha = true`
4. Expect the alpha value revives

Where does alpha revive from? "update a color well color" overwrites element's value and doesn't seem to do `getAttribute("value")`-equivalent thing. Am I missing something again?

[08:05:36.0687] <annevk>
krosylight (they/them): it's been quite a while since I worked on this, but it's possible that step 2 of https://html.spec.whatwg.org/multipage/input.html#update-a-color-well-control-color should look at the value attribute and not the value concept. Because you do want to be able to set these attributes in a somewhat arbitrary order.

[08:07:30.0969] <annevk>
Although not sure how to match that up with what WebKit is doing.

[08:07:31.0772] <krosylight (they/them)>
but that way it's more complex about what value is used...

[08:09:12.0170] <krosylight (they/them)>
* but that way it's more complex about which value is used...

[08:09:21.0731] <krosylight (they/them)>
Anyway I'll file a bug, we can talk there

[08:09:41.0304] <krosylight (they/them)>
(happy that I didn't miss details this time üôÇ)

[08:12:36.0845] <annevk>
Sounds good. Please explain there how it's way more complex as I'm not immediately seeing it. I do think what that test expects is probably desirable for web developers.

[08:12:47.0625] <annevk>
* Sounds good. Please explain there how it's way more complex as I'm not immediately seeing it. I do think what that test expects is desirable for web developers.

[08:27:15.0143] <krosylight (they/them)>
(me now thinks it's just a matter of checking dirty flag)

[08:27:19.0298] <krosylight (they/them)>
https://github.com/whatwg/html/issues/12057


2026-01-08
[00:04:17.0975] <annevk>
AI comments are annoying. They're verbose and usually not very useful. Latest I suspect: https://github.com/whatwg/html/issues/5867#issuecomment-3720854771

[00:14:25.0196] <sideshowbarker>
Footnotes! We finally have a use case~ Wake up Jake!

[07:44:47.0884] <sb3nder>
Does anybody know why firefox do a sort of implicit pointer-capture for text controls?

[07:47:24.0104] <sb3nder>
* Does anybody know why firefox do a sort of implicit pointer-capture for text controls?
Edit: never mind, I get it now.

[10:51:31.0250] <Luke Warlow>
So til that for html `<a> or <area>` if you toString() them you get their href value. Is that considered esoteric legacy stuff or fair game to copy elsewhere?

[10:56:31.0298] <bkardell>
TIL too

[10:58:53.0775] <bkardell>
that has to be weird/esoteric - I kind of get it in a few cases in HTML, but even there it feels like it would be worse a lot of time.


2026-01-09
[06:03:28.0606] <annevk>
zcorpan: tests for https://github.com/whatwg/html/pull/12021 are not merged yet

[06:04:50.0557] <zcorpan>
annevk: Yep, looks like they're ready except for a nit

[06:46:29.0737] <Luke Warlow>
I'm afk but happy either way so if someone wants to push the nit change, go for it.


2026-01-10
[23:17:25.0838] <nektro>
should the "Otherwise"s in https://url.spec.whatwg.org/#concept-ipv6-parser under step 6.5.5.4.2 be step 3 and 4 respectively?

[23:18:08.0310] <nektro>
* should the "Otherwise"s in https://url.spec.whatwg.org/#concept-ipv6-parser under step 6.5.5.4.2 be step 3 and 4 respectively? (with 3 and 4 becoming 5 and 6)

[00:31:40.0937] <annevk>
nektro: that seems like it would be a useful change, yeah. Are you willing to make it?

[00:44:20.0992] <nektro>
sure thing üëçÔ∏è

[00:54:55.0777] <nektro>
https://github.com/whatwg/url/pull/894


2026-01-11
[17:35:48.0921] <nektro>
for https://url.spec.whatwg.org/#ipv4-number-parser would it make sense to have *output* not fitting a u8 be an explicit failure condition, rather than only catching it in https://url.spec.whatwg.org/#concept-ipv4-parser step 6 ?

[17:38:43.0199] <nektro>
hm thatd be tricky because itd mess up https://url.spec.whatwg.org/#ends-in-a-number-checker

[17:42:37.0167] <nektro>
i see what i need to do

[00:10:39.0830] <annevk>
Yeah, there's also a step a bit beyond 6 that allows it to be quite a bit bigger. üòä (Now if you only care about valid IPv4 addresses, you might be able to make certain optimizations.)


2026-01-12
[04:26:20.0232] <smaug>
/me cries a little bit. Yet [another](https://html.spec.whatwg.org/#:~:text=Prepare%20to%20run%20script%20given%20document%27s%20relevant%20settings%20object%2E) "let's break how microtasks work" special case.

[04:26:55.0106] <smaug>
/me * cries a little bit. Yet [another](https://html.spec.whatwg.org/#:~:text=Prepare%20to%20run%20script%20given%20document%27s%20relevant%20settings%20object%2E) "let's break how microtasks work" special case. (but maybe he did review that change? Hard to get back to the spec issue from the commit message)

[04:30:08.0989] <Noam Rosenthal>
This was me and it was thoroughly reviewed.

[04:31:02.0908] <Ms2ger>
https://github.com/whatwg/html/pull/10284

[04:32:40.0271] <Noam Rosenthal>
Yea I think we had the discussion about this with Domenic elsewhere... 

[04:33:13.0781] <smaug>
Looks like google only patch and review

[04:33:21.0567] <Noam Rosenthal>
the problem with microtasks in the rendering loop is that they might be postponed until the end of the rendering task and that's a no-man's land

[04:33:54.0786] <smaug>
Oh, I do understand how microtasks work and what their limitations are üòõ 

[04:34:38.0442] <smaug>
but it is getting really hard to explain how microtasks work given the special cases. Navigation API has similar weird special case

[04:34:54.0270] <Noam Rosenthal>
yea agreed, there are a few of those

[04:35:03.0730] <Noam Rosenthal>
but really I think those special cases can be counted on one hand

[04:36:26.0901] <sideshowbarker>
so we have enough to start a Quirks spec for microtasks

[04:36:29.0678] <Noam Rosenthal>
I suggested before to have something like an isolated promise resolver algorithm that does this... it's probably easier to explain then wrapping each of these separately

[04:36:37.0408] <Ms2ger>
Does it need to be an AI-generated hand? üòá

[04:40:10.0273] <Noam Rosenthal>
The quirky things about microtasks is when they need to fire before of other things in the same task... then you need to wrap them with this prepare/cleanup thingy. I think the right way to explain it is to have some sort of isolated wrapper for this but it wouldn't look much different from those prepare/cleanup pairs

The latter one is really confusing 


[04:40:17.0104] <Noam Rosenthal>
* The quirky things about microtasks is when they need to fire before of other things in the same task... then you need to wrap them with this prepare/cleanup thingy. I think the right way to explain it is to have some sort of isolated wrapper for this but it wouldn't look much different from those prepare/cleanup pairs


[04:40:55.0264] <Noam Rosenthal>
* The quirky things about microtasks is when they need to fire before other things in the same task... then you need to wrap them with this prepare/cleanup thingy. I think the right way to explain it is to have some sort of isolated wrapper for this but it wouldn't look much different from those prepare/cleanup pairs


[04:41:49.0181] <Noam Rosenthal>
(though so far this sounds like more like a group rant than an attempt to fix things, so perhaps I'd leave it to that)

[04:46:03.0525] <smaug>
I guess we'd need conceptual MilliTasks, and Microtasks would run then at  the end of outermost script execution or end of millitask or task.

[04:46:46.0742] <Noam Rosenthal>
we kind of have that. you can call script execution blocks millitasks

[04:46:59.0825] <Noam Rosenthal>
(I wouldn't use the term, but the concept exist)

[04:49:09.0410] <Noam Rosenthal>
but really what I found myself looking for a few times is more like "when you resolve this promise, if there is no active script, also perform a microtask checkpoint and flush the world". the default behavior of delaying that to the end of the task is what's quirky

[04:50:19.0207] <smaug>
yeah, that largely comes from the fact that microtasks weren't designed for promises

[04:50:54.0309] <Noam Rosenthal>
(end of the task or an event handler or callback that might happen to run)

[04:51:42.0998] <Noam Rosenthal>
sure, but that's why a wrapper to "resolve a promise" or to wrap a prepare/cleanup pair for promise resolution and expose that in an algo is not a bad solution

[04:53:07.0411] <smaug>
it makes explaining microtasks hard. "usually microtasks run at this time, but then we have these special cases"

[04:53:59.0229] <Noam Rosenthal>
they run when the JS stack is emptied from running scripts or at the end of the task. We can say that these promise-based entry points create a JS Stack

[04:55:02.0094] <Noam Rosenthal>
it's not a "special case" per se, it creates JS stacks/scopes whatever when there is a promise-based API callback

[05:19:04.0310] <Noam Rosenthal>
The alternative way to explain this is by having these sub-tasks be tasks and manage the order via task queues... I'm pretty sure that would be more cumbersome and won't solve anything.


2026-01-13
[20:43:38.0877] <aresuii>
@sideshowbarker:matrix.org who was that guy

[20:44:02.0951] <sideshowbarker>
no idea

[20:57:30.0936] <aresuii>
ok but what is "Guest Standard"

[01:44:00.0860] <smaug>
We can do something like that yes, and have consistent behavior for all Promise APIs. It does change the meaning of microtasks though, a bit, if JS doesn't really run. But anyhow, that would be better than having the current ad-hoc "let's run microtasks here".

[02:56:05.0398] <Noam Rosenthal>
Does something like "Perform a promise entry point with the following step: activate view transition" sound right?

[03:02:37.0245] <Noam Rosenthal>
There are a few promise entry points which don't work like this, e.g. ones that fire multiple promises and events as part of one stack and rely on the behavior of the microtask queue firing at the end of the stack. but I think probably that should be the exception

[03:05:35.0082] <annevk>
zcorpan: rs? https://github.com/whatwg/html/pull/12060

[03:07:45.0023] <Noam Rosenthal>
Approved, but I now see you asked specifically from zcorpan 

[03:12:52.0316] <zcorpan>
annevk: reviewed and merged

[04:00:34.0383] <Noam Rosenthal>
I've added a comment to out-of-order streaming with the thinking around markers after the last WHATNOT. https://github.com/whatwg/html/issues/11542#issuecomment-3743936051

zcorpan keithamus Jake Archibald it attempts to answer some of your questions about processing instructions, polyfills, and developer ergonomics.

[04:10:27.0916] <Noam Rosenthal>
https://github.com/whatwg/html/issues/12080

[04:16:52.0656] <zcorpan>
Noam Rosenthal: Can marker-start and marker-end be anywhere (in normal elements), or do they need to be siblings?

[04:17:58.0668] <Noam Rosenthal>
If they're not siblings they don't match each other because you'd hit the end of the marker's parent before hitting the matching marker-end

[04:18:31.0700] <Noam Rosenthal>
IOW only sibling marker-start/marker-end pairs create an automatic range for <template contentfor>

[04:19:49.0067] <zcorpan>
What if you have `<div><?marker-start name=x ?><span><?marker-end name=x ?></span></div>`

[04:21:09.0662] <Noam Rosenthal>
it's a good case, but it would resolve to siblings in some way or another. probably the ancestor of the span that's a sibling of marker-start

[04:22:02.0083] <Noam Rosenthal>
though by how I put it in the comment it only iterates on the siblings, so it would simply ignore marker-end and reach the end of the DIV. Perhaps that's better

[04:22:51.0378] <Noam Rosenthal>
(less recursive iteration)

[04:23:02.0737] <zcorpan>
I was thinking it might be better to require an attribute on the element, and allow marker-start and marker-end PIs (without name pseudo attribute) as direct children

[04:23:24.0819] <zcorpan>
But doesn't support multiple marker-starts with different names in one element

[04:23:27.0433] <Noam Rosenthal>
yea but that would make it so that you can only have one marker-pair per element

[04:23:30.0860] <Noam Rosenthal>
exactly

[04:26:21.0726] <zcorpan>
Or we can have `markers="results more-results"`

[04:27:04.0589] <Noam Rosenthal>
instead of attributes on the markers? seems a bit less ergonomic though no? What's the rationale?

[04:29:46.0758] <zcorpan>
Yes. Seems more ergonomic if you have one marker and both start and end, but can be less for other cases. Or hard to follow which marker is which if the names depend on ordering. Rationale is attributes on elements are better understood and supported in various tooling

[04:30:21.0573] <zcorpan>
Easy to query for an element with an attribute, then iterate children to find markers

[04:31:34.0262] <Noam Rosenthal>
Gotcha. It also works nicely when you want the simple case of replacing everything (just don't have marker PIs), and works nicer for polyfills. I can see the appeal given that multiple marker-pairs inside the same element is probably more rare to beginwith

[04:32:31.0567] <zcorpan>
Yeah. Also makes for one way to do things

[04:32:57.0718] <Noam Rosenthal>
I'd use `marker` rather than `markers` though (I don't think we tend to use plural in attribute names?)

[04:37:53.0660] <zcorpan>
We have `headers` but also `class` 

[04:56:59.0377] <Noam Rosenthal>
And `srcset` :)

[04:58:13.0620] <Noam Rosenthal>
what this doesn't allow doing is complex overlaps, but perhaps it's OK. e.g.:

<?marker-start name=a?>

Content
<?marker-start name=b?>
Content
<?marker-end name=a?>
Content
<?marker-end name=b?>

[04:59:29.0755] <zcorpan>
Yeah, though we can allow `name` pseudoatt to override implicit name assignment

[05:00:18.0733] <Noam Rosenthal>
yea sure. so use the DOMTokenList thingy as a default index, and then those PI attributes for complex things

[05:01:06.0657] <zcorpan>
Yep

[05:02:33.0765] <zcorpan>
I want to find out if it's compatible to change from comment to ProcessingInstruction generally for <?foo > in HTML, and also whether we want the trailing "?"

[05:07:29.0022] <Noam Rosenthal>
It's probably safer to start with just <?marker-start and <?marker-end... We can run an HA query with a RegExp for the general case but I'm sure we'll find stuff. the only way to really test for web-compat is to run a trial and see if people scream I think

[05:08:02.0632] <Noam Rosenthal>
I think we don't need the ending ?, <?marker-start> is perhaps OK?

[05:11:04.0664] <zcorpan>
Yep. I suppose we can support (trim) a trailing ? in the same way we ignore trailing slash on start tags

[05:29:02.0890] <zcorpan>
https://docs.google.com/spreadsheets/d/1o04eP_BwH1u7X8CyyLUvxOsntZNmfrDalfhU7ldVqlU/edit?usp=sharing is for 1% of HA. Mostly <?xml and PHP

[05:48:56.0069] <Noam Rosenthal>
I think I'm cautiously optimistic about it being safe web-compat wise. the only use case for this is PHP/HTML editors that use the DOM to update these comments and check for node type explicitly

[05:50:36.0315] <annevk>
Consider shortening things to <?start ...?> and <?end ...?>

[05:51:38.0396] <annevk>
Or <?marker ...?> and <?/marker ...?>?

[05:53:11.0663] <zcorpan>
<?/marker ?> is not well-formed XML

[05:54:22.0741] <Noam Rosenthal>
Note that <?marker-end> can live without <?marker-start> (replace everything from the start of the element until that marker),
Perhaps <?mark> and <?mark-end?>

[05:54:28.0760] <Noam Rosenthal>
* Note that \<?marker-end> can live without \<?marker-start> (replace everything from the start of the element until that marker),
Perhaps \<?mark> and \<?mark-end>

[05:55:37.0027] <annevk>
Just have to be mindful that there might be a lot of these so you want them to be easy to scan and ignore and not add a lot of noise.

[05:55:52.0174] <Noam Rosenthal>
Though I'm also OK with <?start> and <?end> 

[05:56:22.0386] <Noam Rosenthal>
Sure, though I think <?mark{something}> connects it back to the marker attribute 

[05:56:53.0077] <annevk>
To be clear <?mark[-end]> seems like an improvement to me. I wonder how much we care about XML since I like the slash even better, but maybe that's just me.

[06:01:04.0923] <Luke Warlow>
I like the / too fwiw. Would these be aimed at working in an XHTML document? If not I think XML well formedness is meh.

[06:01:29.0605] <Luke Warlow>
* I like the / too fwiw. Would these be aimed at working in an XHTML document? If not I think XML well formedness is meh.

Then again I think XML and XHTML are pretty meh anyway.

[06:02:03.0236] <Noam Rosenthal>
it would feel surprising that you have a <?/mark> without a <?mark> and it would somehow work. though we can also disable that concept

[06:02:25.0920] <Noam Rosenthal>
* it would feel surprising that you have a \<?/mark> without a \<?mark> and it would somehow work. though we can also disable that concept and force having a start marker

[06:02:32.0038] <zcorpan>
DOM createProcessingInstruction will also throw

[06:02:49.0027] <annevk>
That seems okay to me actually, if a bit novel. But then all of this is novel so we get to decide.

[06:04:33.0382] <annevk>
We should figure out if we want correspondence with PIs, and if so, what kind. Would be nice if these didn't have all the mutability of CharacterData for instance.

[06:05:36.0602] <Noam Rosenthal>
I think it's nice that `document.evaluate("/processing-instruction('marker')")`. XPath is a bit niche at this point but having some way to select these is nice

[06:05:53.0810] <Noam Rosenthal>
* I think it's nice that `document.evaluate("/processing-instruction('marker')")` works. XPath is a bit niche at this point but having some way to select these is nice given that querySelector wouldn't

[06:12:59.0752] <Noam Rosenthal>
That mutability is not very useful here, but since it's also there for comments perhaps it's harmless?

[06:33:19.0181] <zcorpan>
If names are implied by order they need to be recomputed on mutations (not just to target, data but also node insertion, removal, move)

[06:41:27.0071] <Noam Rosenthal>
yes sure but supposedly since targeting is done using the parent element when the template is parsed, we don't need to keep this information cahced/alive/up-to-date anywhere

[07:06:35.0000] <Noam Rosenthal>
btw I think it might be easy to get confused if it's `<?/mark>` or `</?mark>`. I'm tending to like mark and mark-end better

[07:07:52.0342] <Noam Rosenthal>
* btw I think it might be easy to get confused if it's `<?/mark>` or `</?mark>`. I'm tending to like `<?mark>` and `<?mark-end>` better

[10:20:05.0627] <Noam Rosenthal>
I guess that `DocumentType` is a precedence where the node type is an immutable special-case of bogus comments. Maybe it's a good precedence for having a `Marker` as a narrowly defined immutable node type that is a direct subclass of `Node`


2026-01-14
[01:37:04.0594] <annevk>
I remember we had a discussion about "then" following "Otherwise". I vaguely recall we wanted to change towards including it. Does anyone else have a recollection of this and maybe a pointer? jmdyck?

[03:42:55.0287] <hsivonen>
sideshowbarker: I don't see anything about `selectedcontent` handling in the Tree Construction part of the spec. Is there an in-flight spec PR that I should be looking at, or have the cloning effects of parsing been specced in a way that's not visible in the parsing spec?

[03:54:25.0523] <sideshowbarker>
See the hook to the _‚Äúmaybe clone an option into selectedcontent‚Äù_ algorithm here: https://html.spec.whatwg.org/multipage/form-elements.html#the-option-element:maybe-clone-an-option-into-selectedcontent

And see the _‚Äúmaybe clone an option into selectedcontent‚Äù_ algorithm itself here: https://html.spec.whatwg.org/multipage/form-elements.html#maybe-clone-an-option-into-selectedcontent

[03:57:05.0989] <hsivonen>
sideshowbarker: Thanks. I can see why the text would end up there in order to cover XML, but it's not good that the HTML parsing algorithm is silent about this.

[04:00:59.0408] <sideshowbarker>
Yeah, I vaguely recall a mention of that having come up during review of the PR. Regardless, I feel the same as you and I probably should have chimed in to say so myself on the PR review at the time. But I had no intention of implementing it myself. I only took a shot at implementing it for Gecko because nobody else had yet, and I wanted it part so that I could resolve the open checker issue at https://github.com/validator/validator/issues/1854

[04:04:45.0792] <hsivonen>
sideshowbarker: It seems to me that the spec expects cloning to happen on what's in the DOM at cloning time and not on what the parser has seen. Am I missing something?

[04:04:52.0586] <sideshowbarker>
hsivonen:  And also on that subject, I have some reservations about what implementing the _‚ÄúOut of order HTML streaming ("patching")‚Äù_ is going to be like, and I guess I should probably speak up about those. But I hope to god I don‚Äôt end up needing to try to implement that one. It‚Äôd be much better if you did¬†‚Äî or at least somebody else with more chops than me.

[04:05:29.0969] <sideshowbarker>
* hsivonen:  And also on that subject, I have some reservations about what implementing the whole _‚ÄúOut of order HTML streaming ("patching")‚Äù_ thing is going to be like, and I guess I should probably speak up about those. But I hope to god I don‚Äôt end up needing to try to implement that one. It‚Äôd be much better if you did¬†‚Äî or at least somebody else with more chops than me.

[04:06:29.0162] <sideshowbarker>
(not that it‚Äôs even been written up yet ‚Äî I‚Äôm just anticipating the shape)

[04:07:43.0553] <sideshowbarker>
* Yeah, I vaguely recall a mention of that having come up during review of the PR. Regardless, I feel the same as you and I probably should have chimed in to say so myself on the PR review at the time. But at that point, I had no intention of implementing it myself. I only took a shot at implementing it for Gecko because nobody else had yet, and I wanted it part so that I could resolve the open checker issue at https://github.com/validator/validator/issues/1854

[04:07:56.0306] <sideshowbarker>
* Yeah, I vaguely recall a mention of that having come up during review of the PR. Regardless, I feel the same as you and I probably should have chimed in to say so myself on the PR review at the time. But at that point, I had no intention of implementing it myself. I only took a shot at implementing it for Gecko because nobody else had yet, and I wanted it in part so that I could resolve the open checker issue at https://github.com/validator/validator/issues/1854

[04:11:38.0570] <sideshowbarker>
I think you‚Äôre not missing something. I‚Äôd need to go back and look. But I will confess that in part what I did there was, implement against the tests. And I think I did get all the WPT tests for this fully passing.

In other words, I did the bad thing of not raising some spec issues that I probably should have when I was implementing¬†‚Äî I mean, about possible gaps in the spec relative to getting what the expected results for the tests seemed to require.

[04:12:35.0518] <hsivonen>
sideshowbarker: The difference would be visible only with a network stall and setTimeout, right?

[04:14:10.0957] <sideshowbarker>
Yeah, I reckon so. And so we should rightly have a WPT test for that ‚Äî¬†for the setTimeout case at least.

[04:14:41.0840] <sideshowbarker>
I will also confess that I didn‚Äôt not try to audit the tests for coverage against the spec requirements.

[04:14:49.0980] <sideshowbarker>
* I will also confess that I didn‚Äôt try to audit the tests for coverage against the spec requirements.

[04:44:43.0967] <annevk>
hsivonen: there's quite a few unresolved issues with `selectedcontent` still: https://github.com/whatwg/html/issues?q=state%3Aopen%20selectedcontent

[04:45:17.0896] <annevk>
Not really sure why the parser should say something about it though. I kinda like that it's all handled at the node tree layer.

[04:46:42.0742] <hsivonen>
annevk: It's pretty unfriendly to have an action triggered when a node is popped off the parser's stack without any hint in the parsing algorithm that popping `option` off the stack is connected to further action.

[04:49:52.0758] <annevk>
hsivonen: oh that bit. That's a pre-existing issue. I agree we should refactor that. https://github.com/whatwg/html/issues/11781 tracks that.

[04:52:24.0402] <hsivonen>
annevk: Thanks

[04:53:43.0471] <jmdyck>
You mean following *immediately*, like "If [condition], then [do thing 1], otherwise then [do thing 2]." ?

[04:58:31.0319] <annevk>
jmdyck: 1. If X, then Y. \n 2. Otherwise, then Z.

[05:21:06.0681] <jmdyck>
Hm, you might be thinking of https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$Uyrjmx4h9XHM_gqQug19615xegSjjwzkaBN5-NLoeY0 almost a year ago.

[05:21:31.0637] <jmdyck>
To me, "otherwise, then" sounds ungrammatical.

[05:52:54.0426] <annevk>
I don't think that's it, but maybe it's just "Otherwise, if X," where we considered using "then" as well. I agree that for a lone "Otherwise" it looks weird.

[06:09:35.0441] <Luke Warlow>
https://html.spec.whatwg.org/multipage/links.html#dom-hyperlink-href

For something like step 4 here I think putting a then before "return this's href"... is fine. Not sure it's needed. But yeah just "otherwise, then" seems wrong to me.

[06:26:04.0054] <jgraham>
So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.

So API-wise the way this will work is that some operation that exposes a stream will return an object with a UUID to that stream and you'll get protocol operations like `io.readStream({stream: <id>})` and `io.closeStream({stream: id})`.

My question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for `readStream` we could pretty much call `[=read request=]` with something like:
```
1. Let readRequest be a new read request with the following items:
  1. [=chunk steps=] given |chunk|:
    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to [=serialize protocol bytes=] given |chunk| and the <code>done</code> field set to false.
    1. Return [=success=] with data |response|.

  1. [=close steps=]:
    1. Let Let |response| be a new `io.ReadResult` with the <code>value</code> field set to <code>""</code> and the <code>done</code> field set to true.

 1. [=error steps=] given |e|:
    1. Return [=error=] with [=error code=] [=stream read error=].
```
And then it needs the equivalent of `ReadableStreamDefaultReaderRead` to eventually call `stream.[[controller]].[[PullSteps]](readRequest)` and actually invoke the steps. 

This is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual `ReadableStreamDefaultReader` object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects. 

[06:29:20.0084] <jgraham>
* So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.

So API-wise the way this will work is that some operation that exposes a stream will return a WebDriver protocol message with a UUID to that stream and you'll get protocol operations like `io.readStream({stream: <id>})` and `io.closeStream({stream: id})`.

My question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for `readStream` we could pretty much call `[=read request=]` with something like:

```
1. Let readRequest be a new read request with the following items:
  1. [=chunk steps=] given |chunk|:
    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to [=serialize protocol bytes=] given |chunk| and the <code>done</code> field set to false.
    1. Return [=success=] with data |response|.

  1. [=close steps=]:
    1. Let Let |response| be a new `io.ReadResult` with the <code>value</code> field set to <code>""</code> and the <code>done</code> field set to true.

 1. [=error steps=] given |e|:
    1. Return [=error=] with [=error code=] [=stream read error=].
```

And then it needs the equivalent of `ReadableStreamDefaultReaderRead` to eventually call `stream.[[controller]].[[PullSteps]](readRequest)` and actually invoke the steps.

This is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual `ReadableStreamDefaultReader` object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.

[06:29:59.0171] <jgraham>
* So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.

So API-wise the way this will work is that some WebDriver operation that exposes a stream will return a message with a UUID to that stream and you'll get protocol operations like `io.readStream({stream: <id>})` and `io.closeStream({stream: id})`.

My question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for `readStream` we could pretty much call `[=read request=]` with something like:

```
1. Let readRequest be a new read request with the following items:
  1. [=chunk steps=] given |chunk|:
    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to [=serialize protocol bytes=] given |chunk| and the <code>done</code> field set to false.
    1. Return [=success=] with data |response|.

  1. [=close steps=]:
    1. Let Let |response| be a new `io.ReadResult` with the <code>value</code> field set to <code>""</code> and the <code>done</code> field set to true.

 1. [=error steps=] given |e|:
    1. Return [=error=] with [=error code=] [=stream read error=].
```

And then it needs the equivalent of `ReadableStreamDefaultReaderRead` to eventually call `stream.[[controller]].[[PullSteps]](readRequest)` and actually invoke the steps.

This is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual `ReadableStreamDefaultReader` object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.

[06:30:27.0566] <jgraham>
* So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.

So API-wise the way this will work is that some WebDriver operation that exposes a stream will return a WebDriver message with a UUID to that stream and you'll get protocol operations like `io.readStream({stream: <id>})` and `io.closeStream({stream: id})`.

My question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for `readStream` we could pretty much call `[=read request=]` with something like:

```
1. Let readRequest be a new read request with the following items:
  1. [=chunk steps=] given |chunk|:
    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to [=serialize protocol bytes=] given |chunk| and the <code>done</code> field set to false.
    1. Return [=success=] with data |response|.

  1. [=close steps=]:
    1. Let Let |response| be a new `io.ReadResult` with the <code>value</code> field set to <code>""</code> and the <code>done</code> field set to true.

 1. [=error steps=] given |e|:
    1. Return [=error=] with [=error code=] [=stream read error=].
```

And then it needs the equivalent of `ReadableStreamDefaultReaderRead` to eventually call `stream.[[controller]].[[PullSteps]](readRequest)` and actually invoke the steps.

This is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual `ReadableStreamDefaultReader` object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.

[06:31:40.0182] <jgraham>
* So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.

So API-wise the way this will work is that some WebDriver operation that exposes a stream will return a WebDriver message with a UUID to that stream and you'll get protocol operations like `io.readStream({stream: <id>})` and `io.closeStream({stream: id})`.

My question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for `readStream` we could pretty much call `[=read request=]` with something like:

```
1. Let readRequest be a new read request with the following items:
  1. [=chunk steps=] given |chunk|:
    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to [=serialize protocol bytes=] given |chunk| and the <code>done</code> field set to false.
    1. Return [=success=] with data |response|.

  1. [=close steps=]:
    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to <code>""</code> and the <code>done</code> field set to true.
    1. Return [=success=] with data |response|.

 1. [=error steps=] given |e|:
    1. Return [=error=] with [=error code=] [=stream read error=].
```

And then it needs the equivalent of `ReadableStreamDefaultReaderRead` to eventually call `stream.[[controller]].[[PullSteps]](readRequest)` and actually invoke the steps.

This is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual `ReadableStreamDefaultReader` object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.

[09:24:32.0079] <cateru>
hi

[09:25:50.0409] <cateru>
is it possible to let form autosubmit on change without js ?

[09:27:50.0871] <cateru>
i know i can do it js. but shouldn't be possible without js

[09:30:02.0985] <cateru>
<form autosubmit></form>

[09:31:55.0943] <cateru>
im using it to filter products it opens another page but with view transitions looks like its the same page 

[09:33:17.0145] <cateru>
is this something that could be added. considering the move to use as less of js as possible?

[09:38:05.0604] <annevk>
jgraham: I recommend trying to get Mattias Buelens involved somehow.

[09:39:00.0387] <annevk>
cateru: with a lot more context it'd at least be something that could be considered. See the new feature template for GitHub whatwg/html.

[09:41:43.0274] <Noam Rosenthal>
cateru: incubating something like this at https://github.com/WICG/declarative-partial-updates/issues/32

[09:42:37.0934] <cateru>
thank you so much


2026-01-15
[23:08:58.0812] <annevk>
Does anyone here know what is happening with uievents and pointerevents? I see a bunch of issues moving?

[23:24:13.0274] <sideshowbarker>
Yeah, we‚Äôre moving whole chunks of the UI Events spec into the Pointer Events spec

[23:24:35.0518] <sideshowbarker>
Where the ‚Äúwe‚Äù actually doing the work of it is plh

[23:24:56.0891] <sideshowbarker>
* Where the specific ‚Äúwe‚Äù actually doing the work of it is plh

[23:27:20.0025] <sideshowbarker>
but the broader ‚Äúwe‚Äù is, a group of implementors and editors ‚Äî plus me and Xiaoqian and plh ‚Äî¬†who have been meeting to do stuff to get the UI Events to be actually implementable 

[23:29:53.0806] <sideshowbarker>
https://docs.google.com/document/d/1iRFgqtReyomoCwZFEdRUdoW1ManD5t656CVUGJm7Xos

[23:35:22.0471] <sideshowbarker>
You‚Äôre welcome to join the meeting üòÄ Next one is Feb 10, at 4pm CET

[05:37:27.0456] <Dominic Farolino>
When A.com requests a B.com subresource, only A.com service workers can intercept. Are there SOP/security concerns for that, or is it more about predictability or other concerns? I ask because foreign fetch was before my time and I can't tell how much of its dismissal was security-based, and also intuitively, B.com's server ultimately gets to respond to its subresources, so it doesn't seem wrong security-wise if its service worker were first involved.

[05:41:11.0879] <annevk>
Dominic Farolino: with double/triple/quadruple-keyed storage it becomes very heavy-weight.

[05:41:38.0192] <annevk>
Dominic Farolino: https://github.com/w3c/ServiceWorker/issues/1188 has some breadcrumbs from a quick search.

[07:35:09.0228] <julienw>
Hey folks!
by chance, would you know why `event.target` is null _after_ dispatching the event to an element inside a shadow dom, when it has `bubbles: false, composed: false` (esp `composed: false` I believe)? While it has a target when `bubbles: true, composed: true`
(this is in chrome and firefox so I believe this is spec-ed and not a bug)
I use this to know if an event has ever been dispatched before -- but maybe there's a better way?

[08:26:41.0816] <Dominic Farolino>
So the complexity is based on how we'd partition the service worker in a double+ keyed world? E.g., if two different sites both make requests for destination.com, we'd need *two* destination.com SWs running, each keyed under their respective initiators?

[08:31:13.0064] <annevk>
julienw: with bubbling we can retarget. Without bubbling there's nothing to retarget too and we can't reveal shadow tree nodes. I think we end up resetting all state at the end of dispatch, except for targets when _clearTargets_ is false.

[08:32:35.0640] <annevk>
Dominic Farolino: that sounds right. There's the additional privacy and security concern that now destination.com gets to execute script with the blame going to whatever was in the address bar, despite the address bar party thinking it only embedded a harmless image.

[08:59:34.0292] <cwilso>
Doh.  Github is currently experiencing issues, which may make our WHATNOT meeting challenging.

[09:51:51.0127] <Noam Rosenthal>
Lea Verou: the explainer for out of order streaming is here: https://github.com/WICG/declarative-partial-updates/blob/main/patching-explainer.md
But we haven't updated it with the latest proposal (which is best shown in this example: https://gist.github.com/noamr/b50b56ca75dfdddfb243507078758618)

[11:34:36.0864] <Dominic Farolino>
For A.com requesting B.com/img as a subresource, I'd expect https://fetch.spec.whatwg.org/#determine-the-same-site-mode to compute a same-site mode of "unset-or-less", but I don't see any step that would yield that. Where am I wrong? I'm getting "strict-or-less" which has to be wrong.


2026-01-16
[00:41:38.0735] <annevk>
zcorpan Noam Rosenthal  can either of you r/rs https://github.com/whatwg/html/pull/11878?


2026-01-17
[10:11:26.0927] <JLov>
I'm trying to track down who took over my company's website domain and is now trying to sale it. I've been directed to here. Can anyone help?

[10:16:04.0595] <Colin Alworth>
[JLov](https://matrix.to/#/@jlouv:matrix.org)I think either you misunderstood, or the person who directed you was confused. 

[10:19:02.0011] <JLov>
Possibly. Can you explain what goes on here?

[10:20:42.0696] <Colin Alworth>
Discussion on the html5 specification. You want something related to dns, possibly start with icann.org

[10:23:19.0317] <jmdyck>
I'd suggest contacting the registrar that the domain is/was registered with.

[10:25:30.0798] <JLov>
I have tried this and its a run around. There was lapse in payment and someone picked it up and I've tried fallowing the WHOIS leads and nothing. It just brings me back to NetWork Solutions.

[10:26:39.0730] <JLov>
This place may be helpful for other things in my future, as I will be working on our website. Hopefully.


2026-01-19
[03:15:46.0106] <zcorpan>
foolip: Noam Rosenthal : No wide usage of <!marker> in httparchive https://docs.google.com/spreadsheets/d/1JRDf0k6ZYNa_2UZH5QuQuuTs3tjzOVsmqfz53g1ssKU/edit?usp=sharing

[03:16:25.0090] <Noam Rosenthal>
zcorpan: also seems like most downstream parser can handle bogus comments

[03:16:48.0640] <Noam Rosenthal>
zcorpan: main webcompat issue might be with scripts not expecting a new node type after all these years

[03:17:08.0781] <zcorpan>
Yeah

[03:18:11.0064] <zcorpan>
From this search I noticed that some people use <!link ...> as a way to comment it out. SVG has a <marker> element. But I think it's not common enough to be an issue

[03:21:20.0796] <Noam Rosenthal>
zcorpan: I think the main open issue is how to deal with "end" markers. Are they allowed to be orphaned or does DOM deal with disposing them

[03:21:57.0417] <Noam Rosenthal>
(or something in between, where they are parsed as bogus comments when not in the right place, but DOM can move them)

[03:22:51.0609] <Noam Rosenthal>
keeping them atomic seems compelling for simplicity but perhaps moves some of the complexity to the author

[03:24:44.0532] <zcorpan>
I discussed with foolip an idea of yanking both the start and end markers and storing either offsets (like a range) or pointers to the node before start and after end on the container element

[03:25:36.0893] <Noam Rosenthal>
yea but then it can lose the state when serializing

[03:25:52.0956] <Noam Rosenthal>
or if you add elements in between

[03:26:30.0237] <zcorpan>
The serializer can write the markers again though?

[03:29:19.0468] <Noam Rosenthal>
It breaks the mapping... e.g. if you later prepend HTML to the element with markers you have to recompute what's going on and it's easy to lose track

[03:31:05.0883] <Noam Rosenthal>
(especially if you have more than one range)

[03:31:30.0962] <Luke Warlow>
Do these markers work when within embedded svg or MathML contexts? I'm guessing yes?

[03:32:48.0716] <Noam Rosenthal>
Probably yes. As long as it's a normal container element (not self-closing, not script/style/title/textarea / iframe etc)

[03:40:45.0048] <Noam Rosenthal>
zcorpan: e.g. problematic issue:
```
Before
<!start>
<div id=first></div>
<!end>

<script>
first.after("second")
</script>
```

If the range state is part of the element it would create an unexpected thing because the new contents would be outside the range

[03:45:30.0771] <zcorpan>
Noam Rosenthal: With the model of storing pointers, the node before start is "Before", the node after end is a whitespace text node. Inserting nodes between would be part of the range.

[03:47:15.0077] <Noam Rosenthal>
yea but then it gets weird if `Before` gets moved. maybe we can still parse these as bogus comments and the element keeps the range as a pair of pointers to these comments, serializing them with <! if they match the range

[03:59:35.0348] <zcorpan>
I guess that works, yeah

[04:00:49.0792] <zcorpan>
Should it be possible to set markers with DOM API?

[04:11:08.0088] <Noam Rosenthal>
Probably with an API on the element rather than manipulating them directly? Note that anyway you'd have to name those ranges in the `sink` attribute or whatnot
I wonder though if this adds much because you can still end up with junk bogus comments if you move them around yourself

[05:18:18.0133] <Noam Rosenthal>
... Perhaps this is getting too complicated, and we should keep markers atomic+generic and keep the relationship between markers and patching as an attribute-like thing

```
<div sink="title search-results">
   <!marker start=title>Current title<!marker end=title>
   <!marker name="search-results">
</div>
```

This way it's clear that markers are atomic things that DOM doesn't "manage" and error handling is done when patching

[08:48:24.0346] <Noam Rosenthal>
zcorpan, foolip I think this is a lot simpler, jotted it down on gist: https://gist.github.com/noamr/4c8b4972d717816f3e8a0dc4c3e3c907

Basically markers are atomic and unopinionated. not opinionated about patches/ranges. Instead, they provide metadata for patches/ranges as attributes. It allows us to extend markers to other uses in the future or to let frameworks be opinionated about them in other ways

[08:48:37.0117] <Noam Rosenthal>
* zcorpan, foolip I think this is a lot simpler, jotted it down on gist: https://gist.github.com/noamr/4c8b4972d717816f3e8a0dc4c3e3c907

Basically markers are atomic and unopinionated about patches/ranges. Instead, they provide metadata for patches/ranges as attributes. It allows us to extend markers to other uses in the future or to let frameworks be opinionated about them in other ways

[15:44:02.0766] <Fernando Fiori>
Why is entry global object use discouraged? cc annevk because you mentioned this in a [comment](https://github.com/whatwg/html/pull/11519#discussion_r2410613201) (or anyone who could comment on this is also welcomed as the only info I found is this old issue but )

For context, I'm working on this PR where I was using entry global object to reference the frame that initiated an action (calling focus) but seems like using it is discouraged in general in new specs https://github.com/whatwg/html/pull/11519

[15:44:36.0217] <Fernando Fiori>
* Why is entry global object use discouraged? cc annevk because you mentioned this in a [comment](https://github.com/whatwg/html/pull/11519#discussion_r2410613201) (or anyone who could comment on this is also welcomed as the only info I found is this old issue but I didn't see the reasons https://github.com/whatwg/html/issues/1431)

For context, I'm working on this PR where I was using entry global object to reference the frame that initiated an action (calling focus) but using it is discouraged in general in new specs https://github.com/whatwg/html/pull/11519


2026-01-20
[21:51:04.0233] <nektro>
is there a matrix/slack/etc like this community but for unicode?

[23:39:48.0691] <annevk>
Fernando Fiori: I think what you want to be able to defend is why entry here is correct. Note that I gave some a reason in that discussion as to why it is not (you end up looking at the wrong ancestor chain).

[23:40:00.0996] <annevk>
* Fernando Fiori: I think what you want to be able to defend is why entry here is correct. Note that I gave a reason in that discussion as to why it is not (you end up looking at the wrong ancestor chain).

[23:41:05.0438] <annevk>
nektro: I think Unicode is fairly closed, but if you find something that contradicts that, please let me know. (There might still be a public mailing list though.)

[03:10:59.0294] <eemeli>
Unicode has a slack instance, though it's not well advertised. Here's a joining link: https://join.slack.com/t/unicode-org/shared_invite/zt-3ntrn2geu-i81l1gMJGnYZ33TayeZXXQ

[03:28:05.0560] <sideshowbarker>
IMHO having eemeli around with his ears on here may be more useful than what could be got from discussion wherever else it might be taking place (including that dedicated Slack instance for Unicode he mentioned)

[07:33:15.0890] <mfreed>
Hi all, just a friendly reminder to post any discussion topics for this Thursday's joint CSSWG/WHATWG/OpenUI task force meeting to the meeting agenda issue: https://github.com/whatwg/html/issues/12064

[12:01:10.0820] <Fernando Fiori>
Thanks Anne, yes I was just curious as to why entry is discouraged in general, separate from the PR intention itself.

But regards the PR, if we want to look at the document that initiated the action of calling x.focus(), wouldn't entry be the right choice? Sorry if I'm wrong or missing something, I'm not sure why that wouldn't be the right ancestor chain. Olli suggested using incumbent instead at WHATNOT but I understand that would refer to the realm where the call is being executed, which wouldn't match the PR's intentions.

[12:12:41.0991] <Noam Rosenthal>
https://www.w3.org/Bugs/Public/show_bug.cgi?id=27196 has an interesting conversation about it from 11~ years ago

[12:40:00.0615] <Noam Rosenthal>
Fernando Fiori: See also this warning and the text underneath: https://html.spec.whatwg.org/multipage/webappapis.html#topmost-script-having-execution-context:~:text=concepts%20should%20not%20be%20used%20by%20new%20specifications%2C%20as%20they%20are%20excessively%20complicated%20and%20unintuitive%20to%20work%20with.%20We%20are%20working%20to%20remove%20almost%20all%20existing%20uses%20from%20the%20platform

I think the recommendation there to go with "relevant" is something to consider

[13:12:24.0147] <Fernando Fiori>
I see! Ok got it. Thanks :)


2026-01-21
[22:20:50.0427] <annevk>
Anyone know the details about the `unload` event fire in Gecko? Per https://software.hixie.ch/utilities/js/live-dom-viewer/saved/14453 it looks like it fires after removal somehow?

[23:53:04.0150] <nektro>
ended up answering my unicode question and finished my Zig IDNA implementation https://github.com/nektro/zig-unicode-idna :)

[23:53:32.0277] <nektro>
now to get back to url hehe

[00:22:33.0079] <sideshowbarker>
So everybody else fires it after?

[00:23:30.0115] <sideshowbarker>
per spec, is the removal sync? And is the firing of the event async?

[00:24:12.0216] <sideshowbarker>
I‚Äôm trying to do some code inspection, looking at the code locally ‚Äî but‚Ä¶¬†it‚Äôs pretty hairy

[00:24:54.0844] <sideshowbarker>
I kind of feel like nobody might know what the code is doing ‚Äî except whoever wrote it or last had to touch it

[00:25:04.0731] <sideshowbarker>
and probably they don‚Äôt even remember by now

[00:25:30.0910] <sideshowbarker>
but then I guess there‚Äôs a high change ‚Äúthey‚Äù = smaug anyway

[00:29:05.0680] <sideshowbarker>
anyway, in other news, since I‚Äôm going to be the W3C staff contact for the Web Extensions WG, I figured I should actually try to write a cross-browser extension ‚Äî in order to fully participate in the pain of trying to do that ‚Äî¬†and I managed to come up with an actually-pretty-useful extension:

[00:29:12.0915] <sideshowbarker>
https://github.com/sideshowbarker/social-media-cleanser

[00:29:24.0917] <sideshowbarker>
* ‚Ä¶
anyway, in other news, since I‚Äôm going to be the W3C staff contact for the Web Extensions WG, I figured I should actually try to write a cross-browser extension ‚Äî in order to fully participate in the pain of trying to do that ‚Äî¬†and I managed to come up with an actually-pretty-useful extension:

[00:30:21.0090] <sideshowbarker>
I encourage any and all try to it, and specifically lemme know if you run into any install problems. And otherwise of course, does it actually work for you.

[00:38:38.0659] <annevk>
In https://github.com/whatwg/html/issues/4611#issuecomment-1960779830 Dominic Farolino claimed all browsers are aligned, but my trivial example from above shows that's not the case.

[00:42:28.0704] <sideshowbarker>
seems like it‚Äôs async in gecko at least

[00:42:52.0724] <sideshowbarker>
* seems like it‚Äôs actually async in gecko at least

[00:50:43.0623] <annevk>
I don't think so. At least per https://software.hixie.ch/utilities/js/live-dom-viewer/saved/14454 it seems like they might just clear `frameElement` earlier, but if you cache it in some other way you still get to make changes around the same time. But perhaps maybe it's slightly delayed?

[01:11:37.0482] <annevk>
I'm looking at this since rniwa is saying `selectedcontent` is unsafe as specified because of the `unload` event. I'm curious how jarhar dealt with this as I don't really see anything obvious in the Chromium code. I did notice Chromium doesn't appear to clear all non-primary `selectedcontent` elements when testing.

[03:09:58.0822] <smaug>
We were looking into something similar very recently on Gecko side and selectedcontent. I thought it was safe after all, but just possibly a bit weird

[03:10:02.0919] <smaug>
jjaschke might recall

[03:10:23.0587] <smaug>
Something about remove all the child nodes

[03:13:08.0574] <smaug>
And yes, I couldn't immediately find the code in Chromium doing what the spec says, but didn't spend much time on that

[03:14:11.0060] <jjaschke>
Selectedcontent calls [replace all with](https://dom.spec.whatwg.org/#concept-node-replace-all) when cloning stuff into it or removing its contents

[03:31:13.0578] <smaug>
(and similar-ish weirdness may happen for example when using range.deleteContents())

[03:31:56.0507] <smaug>
* (and similar-ish weirdness may happen for example when using range.deleteContents(), so nothing new there)

[03:33:34.0160] <Noam Rosenthal>
so the unsafe thing here is that an <iframe> inside a <selectedcontent> can trigger a `pagehide` that would observe some mid-algorithm state, or some such?

[03:34:22.0496] <smaug>
yeah, pagehide or unload. That was the worry I had. Not sure if annevk is talking about something else

[03:34:52.0213] <Noam Rosenthal>
(note that while `unload` is deprecated and has weird cross-browser issues, `pagehide` is relatively interoperable I think and potentially has the same issue so it's easier to reason about)

[03:35:16.0273] <smaug>
sure

[05:20:33.0426] <annevk>
Noam Rosenthal: is `pagehide` synchronous as well? If so, yes. I think we need post-removing steps, maybe?

[05:21:33.0457] <Noam Rosenthal>
> <@annevk:matrix.org> Noam Rosenthal: is `pagehide` synchronous as well? If so, yes. I think we need post-removing steps, maybe?

It is. It is the only synchronous removal step that can run scripts (though blink still has blur events)

[05:23:12.0104] <annevk>
I'll just make the issue about pagehide then.

[05:25:21.0867] <annevk>
https://github.com/whatwg/html/issues/12096

[05:30:21.0543] <annevk>
smaug: yeah rniwa was a bit stricter than you I suppose and just said no. üòä

[05:30:58.0684] <Noam Rosenthal>
annevk: not sure if post removal steps would help. It's a really tricky one. We explored it when dealing with moveBefore though it ended up not being an issue there because moveBefore surpresses iframe removal. Will comment on the issue 

[05:31:29.0732] <Noam Rosenthal>
The safest thing would be to disallow subframes in selectedcontent but I don't know if it breaks use cases or not 

[05:33:36.0710] <annevk>
If we remove the nesting by postponing the removal I'm not sure what issue would remain? It does seem possible someone can think of use cases for selecting between nested documents, even if a bit absurd.

[05:34:23.0438] <Noam Rosenthal>
Oh postponing the removal specifically in selectedcontent? That would also work.

[05:34:47.0476] <annevk>
Right, specifically in the case where removal would otherwise end up nesting.

[07:13:26.0921] <Dominic Farolino>
annevk: I'm not sure what "remove the nesting by postponing the removal" means? Do you mean run the pagehide first, and postpone the actual DOM removal until after that event has fired?

[07:21:51.0715] <annevk>
Dominic Farolino: we try to do removal during the removal of the `selectedcontent` itself. That's nesting. If we postpone that removal we can avoid the nesting. I'd be interested to learn more about smaug's `deleteContents()` case as I guess that can do something similar due to it performing multiple tree operations. We might actually have to define some of the mutation event defenses because of `pagehide`.

[07:48:43.0301] <Dominic Farolino>
annevk: Didn't know what you meant by nesting, gotcha. Is "nesting" removing steps any worse than the general problem with removal steps, namely that iframes fire `pagehide` syncly on removal when the spec says it doesn't? If a selected content is cleared and an iframe's `pagehide` fires, can it observe state that's any less consistent than if an ordinary iframe's parent div gets removed? There, the child iframe's removing steps are still called, and observe inconsistent state wrt its siblings' removing steps side-effects.

[07:49:44.0354] <Dominic Farolino>
Of course, it's unfortunate that selected content APIs bake this in *natively* which is a shame. I'm annoyed I missed this in review.

[07:57:29.0987] <annevk>
I don't know how this works in other implementations and the specification is definitely wrong on this, but WebKit has a very specific path for "disconnectSubframesIfNeeded" that's called during node removal at a particular point in time. With this nesting it can also be called at other points in time, which is what makes this risky. I'm also not an expert on this. rniwa is, but he has limited bandwidth.

[08:01:07.0840] <annevk>
And come to think of it, maybe that is also why `deleteContents()` is not problematic, because we complete each removal before starting the next one.

[08:19:07.0359] <Dominic Farolino>
I suppose... Still, when deleteContents() runs the removing steps for a doomed iframe, its `pagehide` handler can easily remove another iframe¬†elsewhere, thus nesting removing steps. I wonder if that imposes the same risk in WebKit as the native selected content nesting. (Neither is acceptable, FWIW... all of it is bad)

[08:26:19.0626] <annevk>
No, `pagehide` running remove during remove is expected. What is unexpected is an arbitrary element running remove (during remove).

[08:26:57.0746] <annevk>
Because the latter means script can now run at a new point in time that is not guarded against whatsoever.

[11:33:39.0696] <Dominic Farolino>
annevk: We discussed this today and I think we have a path for removing the selected content's removing steps altogether

[12:57:28.0743] <smaug>
annevk: about deleteContents. I think that algorithm is actually broken. The last [step](https://dom.spec.whatwg.org/#dom-range-deletecontents:~:text=Set%20start%20and%20end%20to%20%28newNode%2C%20newOffset%29%2E) may set the start and end boundary points pointing to an invalid place in DOM if remove step above modifies DOM and for example removes all the children from newNode before newOffset. It should likely use "set the start or end" algorithm, not just explicitly set the boundary points.

[13:10:32.0819] <smaug>
* annevk: about deleteContents. I think that algorithm is actually broken. The last [step](https://dom.spec.whatwg.org/#dom-range-deletecontents:~:text=Set%20start%20and%20end%20to%20%28newNode%2C%20newOffset%29%2E) may set the start and end boundary points pointing to an invalid place in DOM if remove step above modifies DOM and for example removes all the children from newNode before newOffset. <del>It should likely use "set the start or end" algorithm, not just explicitly set the boundary points. </del> It should find a valid place where to collapse the range.

[13:16:24.0936] <smaug>
* annevk: about deleteContents. I think that algorithm is actually broken. The last [step](https://dom.spec.whatwg.org/#dom-range-deletecontents:~:text=Set%20start%20and%20end%20to%20%28newNode%2C%20newOffset%29%2E) may set the start and end boundary points pointing to an invalid place in DOM if remove step above modifies DOM and for example removes all the children from newNode before newOffset. <del>It should likely use "set the start or end" algorithm, not just explicitly set the boundary points. </del> It should find a valid place where to collapse the range. Or collapse before any mutations.


2026-01-22
[21:50:27.0832] <annevk>
smaug: file an issue?

[00:00:47.0492] <smaug>
yup, did

[02:04:01.0105] <smaug>
sideshowbarker: is there something like searchfox for ladybird?

[02:04:55.0196] <sideshowbarker>
Not that I know of ‚Äî unless somebody has set up the wubfox thing (or whatever it‚Äôs called)

[02:05:21.0550] <sideshowbarker>
Sam Atkins is one person who would know

[02:07:21.0887] <smaug>
oh, ladybird doesn't follow the spec with deleteContents. It calls into "set the start or end" algorithm, which makes this then safe there

[02:08:40.0400] <sideshowbarker>
If Ladybird is not following the spec on something, and there‚Äôs no comment in the code saying why, then per the project policies, that is an unintended bug.

[02:12:01.0423] <smaug>
sideshowbarker: FWIW, I was looking at https://github.com/LadybirdBrowser/ladybird/blob/master/Libraries/LibWeb/DOM/Range.cpp#L1135 And assuming I'm reading that correctly, it ends up calling "set the start or end" algorithm.

[02:12:13.0185] <sideshowbarker>
/me looks

[02:12:42.0670] <sideshowbarker>
yeah

[02:13:57.0809] <sideshowbarker>
so, exactly what would it do there instead, in order to strictly conform to the spec?

[02:16:11.0654] <smaug>
The spec says just to set the start and end boundary points. The spec doesn't link to "set the start or end" algorithm

[02:16:15.0248] <smaug>
And the spec is broken

[02:16:27.0602] <sideshowbarker>
I see

[02:16:36.0757] <smaug>
https://github.com/whatwg/dom/issues/1446

[02:19:21.0155] <smaug>
(I think Servo does the same as LadyBird)

[02:25:00.0467] <smaug>
(And gecko does something which someone decided to do in 2002. In normal cases it does what one expects)


2026-01-23
[01:43:12.0731] <nicolo-ribaudo>
Why does the HTML spec link to https://drafts.fxtf.org rather than to the specs on w3.org?

[01:44:05.0868] <nicolo-ribaudo>
The `<filtervalue-list>` definition we link to is giving me an error 500, but _probably_ the canonical one should be https://www.w3.org/TR/filter-effects-1/#typedef-filter-value-list rather than https://drafts.fxtf.org/filter-effects/#typedef-filter-value-list

[01:44:12.0542] <nicolo-ribaudo>
* The `<filter-value-list>` definition we link to is giving me an error 500, but _probably_ the canonical one should be https://www.w3.org/TR/filter-effects-1/#typedef-filter-value-list rather than https://drafts.fxtf.org/filter-effects/#typedef-filter-value-list

[01:44:48.0837] <sideshowbarker>
We can‚Äôt trust the W3C /TR versions to be up to date

[01:45:11.0924] <sideshowbarker>
but hang on

[01:46:46.0996] <sideshowbarker>
the canonical versions (latest versions) should rightly just be getting served from https://w3c.github.io/fxtf-drafts

[01:47:12.0587] <sideshowbarker>
I think Andreu Botella may have a back-burner thing going to make that happen

[01:48:05.0407] <sideshowbarker>
the problem is basically that some W3C groups thought it would be a fun good idea to mint their own vanity domains

[01:48:08.0355] <nicolo-ribaudo>
Oh actually for this one specifically it's probably https://drafts.csswg.org/filter-effects-1/

[01:48:41.0882] <sideshowbarker>
ah yeah maybe problem solved then, in this particular case

[01:50:07.0337] <sideshowbarker>
but in the general case, they‚Äôve kind of made of made it confusing as hell for any implementors to clearly figure out which spec/version/level they‚Äôre supposed to be implementing from

[01:50:24.0572] <sideshowbarker>
so I hope we unwind this all eventually

[01:51:39.0571] <nicolo-ribaudo>
Ok it seems like for _all_ fxtf drafts the canonical URL is on the csswg.org website

[01:52:00.0872] <nicolo-ribaudo>
At list according to the link in the metadata of their repo

[01:52:07.0845] <sideshowbarker>
well we really need to just EOL that entire domain

[01:52:51.0520] <sideshowbarker>
well maybe it‚Äôs clear enough now for you at least to move on with what you were trying to do

[01:53:37.0673] <sideshowbarker>
but we still have a chronic problem that newer implementors have to go through this idiot dance every single time, N times

[03:19:30.0082] <nektro>
is https://github.com/web-platform-tests/wpt/blob/master/url/resources/IdnaTestV2.json#L168-L172 being used per https://github.com/web-platform-tests/wpt/blob/master/url/IdnaTestV2.window.js#L8-L10 ?

[04:53:52.0391] <annevk>
nektro: not for that particular test runner. But you could imagine hooking this JSON resource directly to your C++ implementation in some manner instead of going through JavaScript.

[05:22:03.0210] <Andreu Botella>
they were moved to drafts.csswg.org last month or so

[05:23:05.0770] <Andreu Botella>
after drafts.fxtf.org being broken for a while

[05:23:49.0182] <Andreu Botella>
I need to get around to that at some point, yeah...

[09:19:37.0064] <smaug>
Stephen Chenney: You might recall something about https://issues.chromium.org/issues/404183708. Chrome seems to behave differently to others when it comes to ::selection in light DOM and selection happening in light DOM. Is there perhaps some background spec issue about this?

[09:21:08.0597] <smaug>
* Stephen Chenney: You might recall something about https://issues.chromium.org/issues/404183708. Chrome seems to behave differently to others when it comes to ::selection in light DOM and selection happening in shadow DOM. Is there perhaps some background spec issue about this?

[09:21:21.0312] <smaug>
* Stephen Chenney: You might recall something about https://issues.chromium.org/issues/404183708. Chrome seems to behave differently to others when it comes to ::selection in light DOM and selection happening in shadow DOM. Is there perhaps some spec issue about this?

[09:25:24.0670] <smaug>
Looks like there is at least this https://github.com/w3c/csswg-drafts/issues/12497

[09:34:07.0011] <smaug>
(ok, I was told elsewhere that something might have changed in some spec at some point but I can't quite find a proper spec for this)

[10:11:13.0810] <Noam Rosenthal>
https://drafts.csswg.org/css-pseudo-4/#highlight-pseudo-element:~:text=The%20highlight%20pseudo%2Delements%20do%20not%20necessarily%20fit%20into%20the%20element%20tree%2C%20and%20can%20arbitrarily%20cross%20element%20boundaries%20without%20honoring%20its%20nesting%20structure. seems relevant

[10:11:28.0278] <Noam Rosenthal>
... though a bit handwavy

[13:21:40.0955] <smaug>
"a bit" üòõ 

[13:32:31.0109] <smaug>
ChatGPT nor Claude seem to find the answer either. It is quite well hidden.


2026-01-24
[01:13:57.0951] <Noam Rosenthal>

Well it's the spirit of the link I sent. Highlights are not tied to elements so they are also not tied to shadow scopes. It's a document-level thing

[02:05:15.0550] <Noam Rosenthal>
(not claiming that the spec wording is sufficient in any way)

[02:10:58.0474] <emilio>
This is the whole highlight inheritance business 

[08:16:45.0033] <smaug>
I guess [this](https://drafts.csswg.org/css-pseudo-4/#highlight-cascade:~:text=Each%20element%20draws%20its%20own%20active%20portions&text=that%20element%20is%20the%20originating%20element&text=its%20originating%20element%E2%80%99s%20parent%20element) stuff is relevant. I can't quite understand that parent element part. Should that perhaps look into host when parent is a ShadowRoot.

[08:24:16.0131] <smaug>
Or maybe it is talking in terms of flat tree, it doesn't really say.

[13:44:25.0137] <nektro>
is `file:////foo` canonical because its supposed to have a non-null empty string host?

[13:56:08.0817] <nektro>
oh yep thats exactly what it is

[14:10:10.0530] <nektro>
that was the last one for that section so https://github.com/nektro/zig-whatwg-url now passes all non-base tests :)


2026-01-26
[06:26:18.0907] <Stephen Chenney>
Coming in late, sorry. I think we should discuss this at the spec level. I would expect differing opinions on how highlight inheritance across shadow boundaries should work. Agenda+ I guess.

[09:57:25.0307] <smaug>
(I may not have strong opinions. Background is that a bug was filed on Firefox, and it isn't clear if that is an invalid bug or not, since the specs aren't clear)


2026-01-27
[21:59:52.0866] <annevk>
nicolo-ribaudo: do you know why step 7.1 of https://html.spec.whatwg.org/multipage/webappapis.html#hostloadimportedmodule never does anything with _requested_?

[23:17:58.0500] <annevk>
Anyone interested in being the second reviewer of a percent-encoding refactoring? https://github.com/whatwg/url/pull/896

[23:28:12.0357] <nicolo-ribaudo>
Inside the loop it should use requested instead of moduleRequest.

The goal there is "when loading the first moduleRequest of a module, validate all of them first".

[23:43:58.0626] <annevk>
nicolo-ribaudo: are you going to PR or shall I?

[23:48:48.0256] <nicolo-ribaudo>
I can open  a PR this afternoon 

[05:54:38.0467] <Luke Warlow>
Bit of a random one, but WebIDL currently forbids a trailing comma in extended attribute lists, but WebKit uses this pattern quite extensively. Should we just update the spec to allow that grammar?

Servo also seems to support the trailing comma (not sure if it's used), chromium seems to forbid it and I'm not sure about Firefox but I think it forbids it too.

[05:56:11.0837] <Ms2ger>
The WebIDL parsers in Firefox and Servo have a common source, but might have diverged at some point, I suppose

[13:01:38.0855] <sideshowbarker>
Linkedin says Alex Mogilevsky is back at Google now. Would be wonderful if he‚Äôs on the Chrome team, but it looks more likely that he might be working on AI stuff. And unsurprising, if so.

*‚ÄúRenowned engineer joins AI team at company X‚Äù* is more of  ‚ÄúDog bites man‚Äù story these days.
*‚ÄúRenowned engineer joins browser-engine project‚Äù* would be more of the ‚Äú[Man bites dog](https://en.wikipedia.org/wiki/Man_bites_dog)‚Äù story.

[13:02:05.0886] <sideshowbarker>
* Linkedin says Alex Mogilevsky is back at Google now. Would be wonderful if he‚Äôs on the Chrome team, but it looks more likely that he might be working on AI stuff. And unsurprising, if so.

_‚ÄúRenowned engineer joins AI team at company X‚Äù_ is more of a ‚ÄúDog bites man‚Äù story these days.
_‚ÄúRenowned engineer joins browser-engine project‚Äù_ would be more of the ‚Äú[Man bites dog](https://en.wikipedia.org/wiki/Man_bites_dog)‚Äù story.

[13:02:41.0140] <sideshowbarker>
* Linkedin says Alex Mogilevsky is back at Google now. Would be wonderful if he‚Äôs on the Chrome team, but it looks more likely that he might be working on AI stuff. And unsurprising, if so.

_‚ÄúRenowned engineer joins AI team at company X‚Äù_ is more of a *‚ÄúDog bites man‚Äù* story these days.
_‚ÄúRenowned engineer joins browser-engine project‚Äù_ would be more of the ‚Äú[Man bites dog](https://en.wikipedia.org/wiki/Man_bites_dog)‚Äù story.

[13:03:06.0560] <sideshowbarker>
* Linkedin says Alex Mogilevsky is back at Google now. Would be wonderful if he‚Äôs on the Chrome team, but it looks more likely that he might be working on AI stuff. And unsurprising, if so.

_‚ÄúRenowned engineer joins AI team at company X‚Äù_ is more of a _‚ÄúDog bites man‚Äù_ story these days.
_‚ÄúRenowned engineer joins browser-engine project‚Äù_ would be more of the *‚Äú[Man bites dog](https://en.wikipedia.org/wiki/Man_bites_dog)‚Äù* story.

[13:16:30.0658] <sideshowbarker>
‚Ä¶
Some good questions at https://github.com/w3c/webcrypto/issues/167#issuecomment-3807539931 for somebody knowledgeable to chime in and answer ‚Äî
> What happens if the algorithm object has a custom property that, on access, [transfers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects) the underlying buffer to a message port. Does that put the object in some kind of bad state? Or if it [messes with the prototype](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf)?)

[13:16:45.0966] <sideshowbarker>
* ‚Ä¶
Some good questions at https://github.com/w3c/webcrypto/issues/167#issuecomment-3807539931 for somebody knowledgeable to chime in and answer ‚Äî

> *What happens if the algorithm object has a custom property that, on access, [transfers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects) the underlying buffer to a message port. Does that put the object in some kind of bad state? Or if it [messes with the prototype](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf)?)*

[13:16:59.0977] <sideshowbarker>
* ‚Ä¶
Some good questions at https://github.com/w3c/webcrypto/issues/167#issuecomment-3807539931 for somebody knowledgeable to chime in and answer ‚Äî

> _What happens if the algorithm object has a custom property that, on access, [transfers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects) the underlying buffer to a message port. Does that put the object in some kind of bad state? Or if it [messes with the prototype](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf)?_

[13:33:06.0147] <Noam Rosenthal>
Yea I agree with most of the thread that the async wrapping for crypto didn't end up making much sense, especially when in workers. David Benjamin already gave a more thorough answer from Google

[13:37:19.0747] <sideshowbarker>
https://github.com/w3c/webcrypto/issues/167#issuecomment-3807081223 is encouraging, though ‚Äî
> _That's not to say I don't agree that we could have (had) a better API, but I'm tempted to think that if we could more or less copy+paste the existing API (without the asyncness and with minor improvements) we could have something useful much faster than having to design & discuss a new API for every primitive individually._
It‚Äôs nice to now have an editor for that spec who‚Äôs pragmatic and really focused on problem solving¬†‚Äî and happy to work with others who have that same point of view.


[13:37:28.0931] <sideshowbarker>
* https://github.com/w3c/webcrypto/issues/167#issuecomment-3807081223 is encouraging, though ‚Äî

> _That's not to say I don't agree that we could have (had) a better API, but I'm tempted to think that if we could more or less copy+paste the existing API (without the asyncness and with minor improvements) we could have something useful much faster than having to design & discuss a new API for every primitive individually._

It‚Äôs nice to now have an editor for that spec who‚Äôs pragmatic and really focused on problem solving¬†‚Äî and happy to work with others who have that same point of view.

[13:39:01.0069] <Noam Rosenthal>
Yep, let's ship it


2026-01-28
[16:46:21.0929] <sideshowbarker>
* Linkedin says Alex Mogilevsky is back at Google now. Would be wonderful if he‚Äôs on the Chrome team, but it looks more likely that he might be working on AI stuff. And unsurprising, if so.

_‚ÄúRenowned engineer joins AI team at company X‚Äù_ ‚Üí more of a _‚ÄúDog bites man‚Äù_ story these days.
_‚ÄúRenowned engineer joins browser-engine project‚Äù_ ‚Üí more of a _‚Äú[Man bites dog](https://en.wikipedia.org/wiki/Man_bites_dog)‚Äù_ story.

[16:46:55.0975] <sideshowbarker>
* Linkedin says Alex Mogilevsky is back at Google now. Would be wonderful if he‚Äôs on the Chrome team, but it looks more likely that he might be working on AI stuff. And unsurprising, if so. These days:

_‚ÄúRenowned engineer joins AI team at company X‚Äù_ ‚Üí more of a _‚ÄúDog bites man‚Äù_ story
_‚ÄúRenowned engineer joins browser-engine project‚Äù_ ‚Üí more of a _‚Äú[Man bites dog](https://en.wikipedia.org/wiki/Man_bites_dog)‚Äù_ story.

[16:47:14.0662] <sideshowbarker>
* Linkedin says Alex Mogilevsky is back at Google now. Would be wonderful if he‚Äôs on the Chrome team, but it looks more likely that he might be working on AI stuff. And unsurprising, if so. These days:

_‚ÄúRenowned engineer joins AI team at company X‚Äù_ ‚Üí more of a _‚ÄúDog bites man‚Äù_ story
_‚ÄúRenowned engineer joins browser-engine project‚Äù_ ‚Üí more of a _‚Äú[Man bites dog](https://en.wikipedia.org/wiki/Man_bites_dog)‚Äù_ story

[16:47:27.0754] <sideshowbarker>
* Linkedin says Alex Mogilevsky is back at Google now. Would be wonderful if he‚Äôs on the Chrome team, but it looks more likely that he might be working on AI stuff. And unsurprising, if so. These days:

_‚ÄúRenowned engineer joins AI team at company X‚Äù_ ‚Üí more of a _‚ÄúDog bites man‚Äù_ news story
_‚ÄúRenowned engineer joins browser-engine project‚Äù_ ‚Üí more of a _‚Äú[Man bites dog](https://en.wikipedia.org/wiki/Man_bites_dog)‚Äù_ news story

[16:47:54.0683] <sideshowbarker>
* Linkedin says Alex Mogilevsky is back at Google now. Would be wonderful if he‚Äôs on the Chrome team, but it looks more likely that he might be working on AI stuff. And unsurprising, if so. These days:

_‚ÄúRenowned engineer joins AI team at company X‚Äù_ ‚Üí more of a _‚ÄúDog bites man!‚Äù_ news story
_‚ÄúRenowned engineer joins browser-engine project‚Äù_ ‚Üí more of a _‚Äú[Man bites dog!](https://en.wikipedia.org/wiki/Man_bites_dog)‚Äù_ news story

[22:11:40.0654] <annevk>
Luke Warlow: it might be nice to allow for cleaner diffs, but also remember that implementation IDL is allowed to diverge. What's important is that the observable behavior of the APIs matches. Whether that happens through IDL or something else is completely up to the implementation. Now having written that I think it might be better to not allow it as specifications don't really need cleaner diffs or extended attributes all that much.

[03:06:17.0324] <Luke Warlow>
I guess my only counter to that is if you're building certain WebIDL tooling (e.g. IDE plugins) you can't rely on the specs grammar to do processing, I know browsers expand the extended attribute list syntax *but* I've yet to find any the permissive grammar didn't account for. Where as with this trailing comma you do have to make a change not in the spec to support it.

Idm too much either way just thought I'd raise query it. I agree it's not going to be useful for actual specification text.

[06:17:50.0839] <annevk>
Luke Warlow: I guess I wouldn't mind allowing it, but I'd want specifications to use some sort of canonical style

[06:17:59.0536] <annevk>
Luke Warlow: unrelated, where's type=image in https://drafts.csswg.org/css-forms-1/ ?

[06:18:31.0171] <Luke Warlow>
https://github.com/w3c/csswg-drafts/issues/12910 - in an issue.

[06:19:40.0521] <Luke Warlow>
Need someone to propose what styles it should get. I don't know the uses of it well enough to meaningfully propose anything (like I said on the issue I'd be just as happy with display: none; üòÖ)

[06:21:06.0822] <annevk>
Yeah, maybe it should just say a replaced element like it is today and only get fairly minimal styling.

[06:25:40.0228] <Luke Warlow>
Like it gets cursor: pointer which surprised me. Maybe we just need to give it that + some of the other very minimal button styles (maybe we can still ensure a minimum size?)

We probably could standardise it's shadow dom to contain an img element that gets it's src and alt set from the input?

[06:25:58.0738] <Luke Warlow>
Probably the sort of control that will benefit from implementation experience.

[06:27:28.0113] <Luke Warlow>
If we allow styling the failed load state of an img element I suspect we probably want to do the same for the image input? But maybe not if its barely used in modern sites.

[07:39:01.0914] <cwilso>
Hey, gang - I'm out on vacation still.  Is anyone available to chair tomorrow's meeting?

[10:18:22.0044] <annevk>
Luke Warlow: I think we'd just want implementations to treat it like `<img>` maybe? `return createRenderer<RenderImage>` suggests to me that's what WebKit does anyway. And yeah, some similar API surface could be nice, but doesn't have to be v1. Just need something minimal.

[10:18:55.0583] <annevk>
* Luke Warlow: I think we'd just want implementations to treat it like `<img>` maybe? `return createRenderer<RenderImage>` suggests to me that's what WebKit does anyway and in this case I don't really see a point in letting people override the renderer. And yeah, some similar API surface could be nice, but doesn't have to be v1. Just need something minimal.

[10:19:54.0114] <Noam Rosenthal>
I think I'll be able to do that

[14:01:47.0033] <sideshowbarker>
https://github.com/w3c/pointerevents/issues/636 ‚Üê Pointer Events working group looking for feedback


2026-01-29
[02:05:52.0221] <Tyler Morgan>
Hey y‚Äôall! It‚Äôs been a second since I‚Äôve been on here. I have a question. `<time datetime="hh:mm¬±hh:mm‚Äù></time>` I know HTML spec says it‚Äôs more useful basing dateless time on geography rather than offset. But is this something the spec should have a stance on? From what I can find, it doesn‚Äôt necessarily say whether it‚Äôs valid or not, just omitted from the examples.
https://html.spec.whatwg.org/multipage/text-level-semantics.html#the-time-element

[02:16:29.0386] <annevk>
Tyler Morgan: the examples are not the normative requirements... When it says "The `datetime` value of a time element must match one of the following syntaxes." it's followed by a list where the links identify the valid syntax. And that's not valid. Though you could express it with two `time` elements at the moment. (Perhaps it's something that should be added though, but that's a different matter.)

[02:21:04.0663] <Tyler Morgan>
Perfect! Thank you annevk!

[04:30:08.0979] <smaug>
annevk: can we clear agenda+ from https://github.com/whatwg/html/issues/12096 ?

[04:40:51.0538] <Noam Rosenthal>
Same q to Luke Warlow re https://github.com/whatwg/html/issues/12063

[04:43:33.0538] <Luke Warlow>
Yes, just waiting on reviews for the initial PR atm

[04:56:40.0314] <Noam Rosenthal>
OK we have a few issues on the agenda. hsivonen were you going to participate? I wanted to flesh out https://github.com/whatwg/html/issues/11542#issuecomment-3811080310 but we can also do that here if you're around :)

[07:38:18.0032] <hsivonen>
Noam Rosenthal: I'll call into today's WHATNOT.

[07:48:12.0528] <zcorpan>
annevk: Is https://github.com/w3c/picture-in-picture/issues/162 wrong? I don't see an "on" vs "at" distinction in fire an event

[08:03:23.0077] <smaug>
Huh, that is so weird. 

[08:07:10.0478] <smaug>
DOM is quite [clear](https://dom.spec.whatwg.org/#:~:text=Let%20targetOverride%20be%20target%2C%20if%20legacy%20target%20override%20flag%20is%20not%20given%2C%20and%20target%E2%80%99s%20associated%20Document%20otherwise%2E).

[08:16:30.0486] <sfarre>
I can't parse what is being said in that link.

Does Chrome have some internal idea of what firing an event "at something foo, on something bar" means?

[09:42:46.0361] <annevk>
Yeah same. That doesn't make sense.

[10:06:02.0373] <Benjamin Beaudry>
Hi all, I was hoping to call out this issue today but we ran out of time: https://github.com/whatwg/html/issues/11040. I‚Äôd really appreciate folks taking a look and sharing any thoughts. I‚Äôm hoping to discuss it in next week‚Äôs meeting.


2026-01-30
[21:20:01.0698] <sideshowbarker>
https://x.com/filpizlo/status/2017074082249048347

[23:14:21.0715] <zcorpan>
Commented. Thanks

