2026-01-02
[09:54:55.0846] <Cheri Goldfinch>
Hu

[10:43:16.0211] <jmdyck>
hu?


2026-01-04
[09:40:28.0260] <nektro>
In https://url.spec.whatwg.org/#pointer it says "When the pointer points to nowhere c cannot be used." Does this mean in https://url.spec.whatwg.org/#concept-basic-url-parser that when pointer is -1 and c is used, returning a failure is inferred or that it's a bug?

[09:42:00.0117] <nektro>
step 9 says what to do if pointer is eof but not nowhere

[09:46:04.0340] <nektro>
should there be an item after step 5 checking that input is valid in encoding ?

[09:48:57.0901] <nektro>
should step 5 be moved up since step 1 is already querying the contents of input ?

[12:27:18.0447] <nektro>
or does c pointing nowhere mean "If c is" simply yields false


2026-01-05
[23:51:34.0764] <annevk>
nektro: step 5 doesn't impact _input_ so I don't think anything is wrong there. You might be right that the scheme start state should only decrease pointer when it's not pointing to the start of _input_.

[23:54:28.0708] <nektro>
scheme start state is always at the start of input

[23:55:24.0874] <nektro>
* scheme start state is always at the start of *input*

[23:56:13.0901] <nektro>
if *encoding* doesn't affect *input* then where is *input* validated as utf-8, or is it not?

[00:03:01.0392] <annevk>
nektro: _input_ is a scalar value string, it's not a byte sequence.

[00:07:49.0286] <annevk>
I think the reason the pointer logic works in scheme start state is because after the state is over pointer gets incremented by 1 so it'll be 0 again. I agree it's not great, but reworking all that is involved.

[00:09:21.0018] <nektro>
thanks :)

[01:28:10.0274] <Jake Archibald>
annevk: https://github.com/whatwg/html/pull/12021 should be good to land now. I got the ipr stuff sorted

[14:49:15.0279] <mfreed>
Hi all, just a friendly reminder to post any discussion topics for this Thursday's joint CSSWG/WHATWG/OpenUI task force meeting to the meeting agenda issue: https://github.com/whatwg/html/issues/12012


2026-01-07
[07:35:01.0526] <krosylight (they/them)>
annevk: Regarding https://wpt.fyi/results/html/semantics/forms/the-input-element?label=master&label=experimental&aligned&q=color.window.html's "Testing '#ffffff08' with color space 'limited-srgb' and with alpha (setAttribute("value"))", the test does:

1. `setAttribute("value", color)`
2. Expects value is set as alpha-less hex
3. Set `.alpha = true`
4. Expect the alpha value revives

Where does alpha revive from? "update a color well color" overwrites element's value and doesn't seem to do `getAttribute("value")`-equivalent thing. Am I missing something again?

[07:38:23.0142] <krosylight (they/them)>
* annevk: Regarding https://wpt.fyi/results/html/semantics/forms/the-input-element?label=master&label=experimental&aligned&q=color.window.html 's "Testing '#ffffff08' with color space 'limited-srgb' and with alpha (setAttribute("value"))", the test does:

1. `setAttribute("value", color)`
2. Expects value is set as alpha-less hex
3. Set `.alpha = true`
4. Expect the alpha value revives

Where does alpha revive from? "update a color well color" overwrites element's value and doesn't seem to do `getAttribute("value")`-equivalent thing. Am I missing something again?

[07:38:49.0681] <krosylight (they/them)>
* annevk: Regarding https://wpt.fyi/results/html/semantics/forms/the-input-element/color.window.html?label=master&label=experimental&aligned&q=color.window.html 's "Testing '#ffffff08' with color space 'limited-srgb' and with alpha (setAttribute("value"))", the test does:

1. `setAttribute("value", color)`
2. Expects value is set as alpha-less hex
3. Set `.alpha = true`
4. Expect the alpha value revives

Where does alpha revive from? "update a color well color" overwrites element's value and doesn't seem to do `getAttribute("value")`-equivalent thing. Am I missing something again?

[08:05:36.0687] <annevk>
krosylight (they/them): it's been quite a while since I worked on this, but it's possible that step 2 of https://html.spec.whatwg.org/multipage/input.html#update-a-color-well-control-color should look at the value attribute and not the value concept. Because you do want to be able to set these attributes in a somewhat arbitrary order.

[08:07:30.0969] <annevk>
Although not sure how to match that up with what WebKit is doing.

[08:07:31.0772] <krosylight (they/them)>
but that way it's more complex about what value is used...

[08:09:12.0170] <krosylight (they/them)>
* but that way it's more complex about which value is used...

[08:09:21.0731] <krosylight (they/them)>
Anyway I'll file a bug, we can talk there

[08:09:41.0304] <krosylight (they/them)>
(happy that I didn't miss details this time üôÇ)

[08:12:36.0845] <annevk>
Sounds good. Please explain there how it's way more complex as I'm not immediately seeing it. I do think what that test expects is probably desirable for web developers.

[08:12:47.0625] <annevk>
* Sounds good. Please explain there how it's way more complex as I'm not immediately seeing it. I do think what that test expects is desirable for web developers.

[08:27:15.0143] <krosylight (they/them)>
(me now thinks it's just a matter of checking dirty flag)

[08:27:19.0298] <krosylight (they/them)>
https://github.com/whatwg/html/issues/12057


2026-01-08
[00:04:17.0975] <annevk>
AI comments are annoying. They're verbose and usually not very useful. Latest I suspect: https://github.com/whatwg/html/issues/5867#issuecomment-3720854771

[00:14:25.0196] <sideshowbarker>
Footnotes! We finally have a use case~ Wake up Jake!

[07:44:47.0884] <sb3nder>
Does anybody know why firefox do a sort of implicit pointer-capture for text controls?

[07:47:24.0104] <sb3nder>
* Does anybody know why firefox do a sort of implicit pointer-capture for text controls?
Edit: never mind, I get it now.

[10:51:31.0250] <Luke Warlow>
So til that for html `<a> or <area>` if you toString() them you get their href value. Is that considered esoteric legacy stuff or fair game to copy elsewhere?

[10:56:31.0298] <bkardell>
TIL too

[10:58:53.0775] <bkardell>
that has to be weird/esoteric - I kind of get it in a few cases in HTML, but even there it feels like it would be worse a lot of time.


2026-01-09
[06:03:28.0606] <annevk>
zcorpan: tests for https://github.com/whatwg/html/pull/12021 are not merged yet

[06:04:50.0557] <zcorpan>
annevk: Yep, looks like they're ready except for a nit

[06:46:29.0737] <Luke Warlow>
I'm afk but happy either way so if someone wants to push the nit change, go for it.


2026-01-10
[23:17:25.0838] <nektro>
should the "Otherwise"s in https://url.spec.whatwg.org/#concept-ipv6-parser under step 6.5.5.4.2 be step 3 and 4 respectively?

[23:18:08.0310] <nektro>
* should the "Otherwise"s in https://url.spec.whatwg.org/#concept-ipv6-parser under step 6.5.5.4.2 be step 3 and 4 respectively? (with 3 and 4 becoming 5 and 6)

[00:31:40.0937] <annevk>
nektro: that seems like it would be a useful change, yeah. Are you willing to make it?

[00:44:20.0992] <nektro>
sure thing üëçÔ∏è

[00:54:55.0777] <nektro>
https://github.com/whatwg/url/pull/894


2026-01-11
[17:35:48.0921] <nektro>
for https://url.spec.whatwg.org/#ipv4-number-parser would it make sense to have *output* not fitting a u8 be an explicit failure condition, rather than only catching it in https://url.spec.whatwg.org/#concept-ipv4-parser step 6 ?

[17:38:43.0199] <nektro>
hm thatd be tricky because itd mess up https://url.spec.whatwg.org/#ends-in-a-number-checker

[17:42:37.0167] <nektro>
i see what i need to do

[00:10:39.0830] <annevk>
Yeah, there's also a step a bit beyond 6 that allows it to be quite a bit bigger. üòä (Now if you only care about valid IPv4 addresses, you might be able to make certain optimizations.)


2026-01-12
[04:26:20.0232] <smaug>
/me cries a little bit. Yet [another](https://html.spec.whatwg.org/#:~:text=Prepare%20to%20run%20script%20given%20document%27s%20relevant%20settings%20object%2E) "let's break how microtasks work" special case.

[04:26:55.0106] <smaug>
/me * cries a little bit. Yet [another](https://html.spec.whatwg.org/#:~:text=Prepare%20to%20run%20script%20given%20document%27s%20relevant%20settings%20object%2E) "let's break how microtasks work" special case. (but maybe he did review that change? Hard to get back to the spec issue from the commit message)

[04:30:08.0989] <Noam Rosenthal>
This was me and it was thoroughly reviewed.

[04:31:02.0908] <Ms2ger>
https://github.com/whatwg/html/pull/10284

[04:32:40.0271] <Noam Rosenthal>
Yea I think we had the discussion about this with Domenic elsewhere... 

[04:33:13.0781] <smaug>
Looks like google only patch and review

[04:33:21.0567] <Noam Rosenthal>
the problem with microtasks in the rendering loop is that they might be postponed until the end of the rendering task and that's a no-man's land

[04:33:54.0786] <smaug>
Oh, I do understand how microtasks work and what their limitations are üòõ 

[04:34:38.0442] <smaug>
but it is getting really hard to explain how microtasks work given the special cases. Navigation API has similar weird special case

[04:34:54.0270] <Noam Rosenthal>
yea agreed, there are a few of those

[04:35:03.0730] <Noam Rosenthal>
but really I think those special cases can be counted on one hand

[04:36:26.0901] <sideshowbarker>
so we have enough to start a Quirks spec for microtasks

[04:36:29.0678] <Noam Rosenthal>
I suggested before to have something like an isolated promise resolver algorithm that does this... it's probably easier to explain then wrapping each of these separately

[04:36:37.0408] <Ms2ger>
Does it need to be an AI-generated hand? üòá

[04:40:10.0273] <Noam Rosenthal>
The quirky things about microtasks is when they need to fire before of other things in the same task... then you need to wrap them with this prepare/cleanup thingy. I think the right way to explain it is to have some sort of isolated wrapper for this but it wouldn't look much different from those prepare/cleanup pairs

The latter one is really confusing 


[04:40:17.0104] <Noam Rosenthal>
* The quirky things about microtasks is when they need to fire before of other things in the same task... then you need to wrap them with this prepare/cleanup thingy. I think the right way to explain it is to have some sort of isolated wrapper for this but it wouldn't look much different from those prepare/cleanup pairs


[04:40:55.0264] <Noam Rosenthal>
* The quirky things about microtasks is when they need to fire before other things in the same task... then you need to wrap them with this prepare/cleanup thingy. I think the right way to explain it is to have some sort of isolated wrapper for this but it wouldn't look much different from those prepare/cleanup pairs


[04:41:49.0181] <Noam Rosenthal>
(though so far this sounds like more like a group rant than an attempt to fix things, so perhaps I'd leave it to that)

[04:46:03.0525] <smaug>
I guess we'd need conceptual MilliTasks, and Microtasks would run then at  the end of outermost script execution or end of millitask or task.

[04:46:46.0742] <Noam Rosenthal>
we kind of have that. you can call script execution blocks millitasks

[04:46:59.0825] <Noam Rosenthal>
(I wouldn't use the term, but the concept exist)

[04:49:09.0410] <Noam Rosenthal>
but really what I found myself looking for a few times is more like "when you resolve this promise, if there is no active script, also perform a microtask checkpoint and flush the world". the default behavior of delaying that to the end of the task is what's quirky

[04:50:19.0207] <smaug>
yeah, that largely comes from the fact that microtasks weren't designed for promises

[04:50:54.0309] <Noam Rosenthal>
(end of the task or an event handler or callback that might happen to run)

[04:51:42.0998] <Noam Rosenthal>
sure, but that's why a wrapper to "resolve a promise" or to wrap a prepare/cleanup pair for promise resolution and expose that in an algo is not a bad solution

[04:53:07.0411] <smaug>
it makes explaining microtasks hard. "usually microtasks run at this time, but then we have these special cases"

[04:53:59.0229] <Noam Rosenthal>
they run when the JS stack is emptied from running scripts or at the end of the task. We can say that these promise-based entry points create a JS Stack

[04:55:02.0094] <Noam Rosenthal>
it's not a "special case" per se, it creates JS stacks/scopes whatever when there is a promise-based API callback

[05:19:04.0310] <Noam Rosenthal>
The alternative way to explain this is by having these sub-tasks be tasks and manage the order via task queues... I'm pretty sure that would be more cumbersome and won't solve anything.


2026-01-13
[20:43:38.0877] <aresuii>
@sideshowbarker:matrix.org who was that guy

[20:44:02.0951] <sideshowbarker>
no idea

[20:57:30.0936] <aresuii>
ok but what is "Guest Standard"

[01:44:00.0860] <smaug>
We can do something like that yes, and have consistent behavior for all Promise APIs. It does change the meaning of microtasks though, a bit, if JS doesn't really run. But anyhow, that would be better than having the current ad-hoc "let's run microtasks here".

[02:56:05.0398] <Noam Rosenthal>
Does something like "Perform a promise entry point with the following step: activate view transition" sound right?

[03:02:37.0245] <Noam Rosenthal>
There are a few promise entry points which don't work like this, e.g. ones that fire multiple promises and events as part of one stack and rely on the behavior of the microtask queue firing at the end of the stack. but I think probably that should be the exception

[03:05:35.0082] <annevk>
zcorpan: rs? https://github.com/whatwg/html/pull/12060

[03:07:45.0023] <Noam Rosenthal>
Approved, but I now see you asked specifically from zcorpan 

[03:12:52.0316] <zcorpan>
annevk: reviewed and merged

[04:00:34.0383] <Noam Rosenthal>
I've added a comment to out-of-order streaming with the thinking around markers after the last WHATNOT. https://github.com/whatwg/html/issues/11542#issuecomment-3743936051

zcorpan keithamus Jake Archibald it attempts to answer some of your questions about processing instructions, polyfills, and developer ergonomics.

[04:10:27.0916] <Noam Rosenthal>
https://github.com/whatwg/html/issues/12080

[04:16:52.0656] <zcorpan>
Noam Rosenthal: Can marker-start and marker-end be anywhere (in normal elements), or do they need to be siblings?

[04:17:58.0668] <Noam Rosenthal>
If they're not siblings they don't match each other because you'd hit the end of the marker's parent before hitting the matching marker-end

[04:18:31.0700] <Noam Rosenthal>
IOW only sibling marker-start/marker-end pairs create an automatic range for <template contentfor>

[04:19:49.0067] <zcorpan>
What if you have `<div><?marker-start name=x ?><span><?marker-end name=x ?></span></div>`

[04:21:09.0662] <Noam Rosenthal>
it's a good case, but it would resolve to siblings in some way or another. probably the ancestor of the span that's a sibling of marker-start

[04:22:02.0083] <Noam Rosenthal>
though by how I put it in the comment it only iterates on the siblings, so it would simply ignore marker-end and reach the end of the DIV. Perhaps that's better

[04:22:51.0378] <Noam Rosenthal>
(less recursive iteration)

[04:23:02.0737] <zcorpan>
I was thinking it might be better to require an attribute on the element, and allow marker-start and marker-end PIs (without name pseudo attribute) as direct children

[04:23:24.0819] <zcorpan>
But doesn't support multiple marker-starts with different names in one element

[04:23:27.0433] <Noam Rosenthal>
yea but that would make it so that you can only have one marker-pair per element

[04:23:30.0860] <Noam Rosenthal>
exactly

[04:26:21.0726] <zcorpan>
Or we can have `markers="results more-results"`

[04:27:04.0589] <Noam Rosenthal>
instead of attributes on the markers? seems a bit less ergonomic though no? What's the rationale?

[04:29:46.0758] <zcorpan>
Yes. Seems more ergonomic if you have one marker and both start and end, but can be less for other cases. Or hard to follow which marker is which if the names depend on ordering. Rationale is attributes on elements are better understood and supported in various tooling

[04:30:21.0573] <zcorpan>
Easy to query for an element with an attribute, then iterate children to find markers

[04:31:34.0262] <Noam Rosenthal>
Gotcha. It also works nicely when you want the simple case of replacing everything (just don't have marker PIs), and works nicer for polyfills. I can see the appeal given that multiple marker-pairs inside the same element is probably more rare to beginwith

[04:32:31.0567] <zcorpan>
Yeah. Also makes for one way to do things

[04:32:57.0718] <Noam Rosenthal>
I'd use `marker` rather than `markers` though (I don't think we tend to use plural in attribute names?)

[04:37:53.0660] <zcorpan>
We have `headers` but also `class` 

[04:56:59.0377] <Noam Rosenthal>
And `srcset` :)

[04:58:13.0620] <Noam Rosenthal>
what this doesn't allow doing is complex overlaps, but perhaps it's OK. e.g.:

<?marker-start name=a?>

Content
<?marker-start name=b?>
Content
<?marker-end name=a?>
Content
<?marker-end name=b?>

[04:59:29.0755] <zcorpan>
Yeah, though we can allow `name` pseudoatt to override implicit name assignment

[05:00:18.0733] <Noam Rosenthal>
yea sure. so use the DOMTokenList thingy as a default index, and then those PI attributes for complex things

[05:01:06.0657] <zcorpan>
Yep

[05:02:33.0765] <zcorpan>
I want to find out if it's compatible to change from comment to ProcessingInstruction generally for <?foo > in HTML, and also whether we want the trailing "?"

[05:07:29.0022] <Noam Rosenthal>
It's probably safer to start with just <?marker-start and <?marker-end... We can run an HA query with a RegExp for the general case but I'm sure we'll find stuff. the only way to really test for web-compat is to run a trial and see if people scream I think

[05:08:02.0632] <Noam Rosenthal>
I think we don't need the ending ?, <?marker-start> is perhaps OK?

[05:11:04.0664] <zcorpan>
Yep. I suppose we can support (trim) a trailing ? in the same way we ignore trailing slash on start tags

[05:29:02.0890] <zcorpan>
https://docs.google.com/spreadsheets/d/1o04eP_BwH1u7X8CyyLUvxOsntZNmfrDalfhU7ldVqlU/edit?usp=sharing is for 1% of HA. Mostly <?xml and PHP

[05:48:56.0069] <Noam Rosenthal>
I think I'm cautiously optimistic about it being safe web-compat wise. the only use case for this is PHP/HTML editors that use the DOM to update these comments and check for node type explicitly

[05:50:36.0315] <annevk>
Consider shortening things to <?start ...?> and <?end ...?>

[05:51:38.0396] <annevk>
Or <?marker ...?> and <?/marker ...?>?

[05:53:11.0663] <zcorpan>
<?/marker ?> is not well-formed XML

[05:54:22.0741] <Noam Rosenthal>
Note that <?marker-end> can live without <?marker-start> (replace everything from the start of the element until that marker),
Perhaps <?mark> and <?mark-end?>

[05:54:28.0760] <Noam Rosenthal>
* Note that \<?marker-end> can live without \<?marker-start> (replace everything from the start of the element until that marker),
Perhaps \<?mark> and \<?mark-end>

[05:55:37.0027] <annevk>
Just have to be mindful that there might be a lot of these so you want them to be easy to scan and ignore and not add a lot of noise.

[05:55:52.0174] <Noam Rosenthal>
Though I'm also OK with <?start> and <?end> 

[05:56:22.0386] <Noam Rosenthal>
Sure, though I think <?mark{something}> connects it back to the marker attribute 

[05:56:53.0077] <annevk>
To be clear <?mark[-end]> seems like an improvement to me. I wonder how much we care about XML since I like the slash even better, but maybe that's just me.

[06:01:04.0923] <Luke Warlow>
I like the / too fwiw. Would these be aimed at working in an XHTML document? If not I think XML well formedness is meh.

[06:01:29.0605] <Luke Warlow>
* I like the / too fwiw. Would these be aimed at working in an XHTML document? If not I think XML well formedness is meh.

Then again I think XML and XHTML are pretty meh anyway.

[06:02:03.0236] <Noam Rosenthal>
it would feel surprising that you have a <?/mark> without a <?mark> and it would somehow work. though we can also disable that concept

[06:02:25.0920] <Noam Rosenthal>
* it would feel surprising that you have a \<?/mark> without a \<?mark> and it would somehow work. though we can also disable that concept and force having a start marker

[06:02:32.0038] <zcorpan>
DOM createProcessingInstruction will also throw

[06:02:49.0027] <annevk>
That seems okay to me actually, if a bit novel. But then all of this is novel so we get to decide.

[06:04:33.0382] <annevk>
We should figure out if we want correspondence with PIs, and if so, what kind. Would be nice if these didn't have all the mutability of CharacterData for instance.

[06:05:36.0602] <Noam Rosenthal>
I think it's nice that `document.evaluate("/processing-instruction('marker')")`. XPath is a bit niche at this point but having some way to select these is nice

[06:05:53.0810] <Noam Rosenthal>
* I think it's nice that `document.evaluate("/processing-instruction('marker')")` works. XPath is a bit niche at this point but having some way to select these is nice given that querySelector wouldn't

[06:12:59.0752] <Noam Rosenthal>
That mutability is not very useful here, but since it's also there for comments perhaps it's harmless?

[06:33:19.0181] <zcorpan>
If names are implied by order they need to be recomputed on mutations (not just to target, data but also node insertion, removal, move)

[06:41:27.0071] <Noam Rosenthal>
yes sure but supposedly since targeting is done using the parent element when the template is parsed, we don't need to keep this information cahced/alive/up-to-date anywhere

[07:06:35.0000] <Noam Rosenthal>
btw I think it might be easy to get confused if it's `<?/mark>` or `</?mark>`. I'm tending to like mark and mark-end better

[07:07:52.0342] <Noam Rosenthal>
* btw I think it might be easy to get confused if it's `<?/mark>` or `</?mark>`. I'm tending to like `<?mark>` and `<?mark-end>` better

[10:20:05.0627] <Noam Rosenthal>
I guess that `DocumentType` is a precedence where the node type is an immutable special-case of bogus comments. Maybe it's a good precedence for having a `Marker` as a narrowly defined immutable node type that is a direct subclass of `Node`


2026-01-14
[01:37:04.0594] <annevk>
I remember we had a discussion about "then" following "Otherwise". I vaguely recall we wanted to change towards including it. Does anyone else have a recollection of this and maybe a pointer? jmdyck?

[03:42:55.0287] <hsivonen>
sideshowbarker: I don't see anything about `selectedcontent` handling in the Tree Construction part of the spec. Is there an in-flight spec PR that I should be looking at, or have the cloning effects of parsing been specced in a way that's not visible in the parsing spec?

[03:54:25.0523] <sideshowbarker>
See the hook to the _‚Äúmaybe clone an option into selectedcontent‚Äù_ algorithm here: https://html.spec.whatwg.org/multipage/form-elements.html#the-option-element:maybe-clone-an-option-into-selectedcontent

And see the _‚Äúmaybe clone an option into selectedcontent‚Äù_ algorithm itself here: https://html.spec.whatwg.org/multipage/form-elements.html#maybe-clone-an-option-into-selectedcontent

[03:57:05.0989] <hsivonen>
sideshowbarker: Thanks. I can see why the text would end up there in order to cover XML, but it's not good that the HTML parsing algorithm is silent about this.

[04:00:59.0408] <sideshowbarker>
Yeah, I vaguely recall a mention of that having come up during review of the PR. Regardless, I feel the same as you and I probably should have chimed in to say so myself on the PR review at the time. But I had no intention of implementing it myself. I only took a shot at implementing it for Gecko because nobody else had yet, and I wanted it part so that I could resolve the open checker issue at https://github.com/validator/validator/issues/1854

[04:04:45.0792] <hsivonen>
sideshowbarker: It seems to me that the spec expects cloning to happen on what's in the DOM at cloning time and not on what the parser has seen. Am I missing something?

[04:04:52.0586] <sideshowbarker>
hsivonen:  And also on that subject, I have some reservations about what implementing the _‚ÄúOut of order HTML streaming ("patching")‚Äù_ is going to be like, and I guess I should probably speak up about those. But I hope to god I don‚Äôt end up needing to try to implement that one. It‚Äôd be much better if you did¬†‚Äî or at least somebody else with more chops than me.

[04:05:29.0969] <sideshowbarker>
* hsivonen:  And also on that subject, I have some reservations about what implementing the whole _‚ÄúOut of order HTML streaming ("patching")‚Äù_ thing is going to be like, and I guess I should probably speak up about those. But I hope to god I don‚Äôt end up needing to try to implement that one. It‚Äôd be much better if you did¬†‚Äî or at least somebody else with more chops than me.

[04:06:29.0162] <sideshowbarker>
(not that it‚Äôs even been written up yet ‚Äî I‚Äôm just anticipating the shape)

[04:07:43.0553] <sideshowbarker>
* Yeah, I vaguely recall a mention of that having come up during review of the PR. Regardless, I feel the same as you and I probably should have chimed in to say so myself on the PR review at the time. But at that point, I had no intention of implementing it myself. I only took a shot at implementing it for Gecko because nobody else had yet, and I wanted it part so that I could resolve the open checker issue at https://github.com/validator/validator/issues/1854

[04:07:56.0306] <sideshowbarker>
* Yeah, I vaguely recall a mention of that having come up during review of the PR. Regardless, I feel the same as you and I probably should have chimed in to say so myself on the PR review at the time. But at that point, I had no intention of implementing it myself. I only took a shot at implementing it for Gecko because nobody else had yet, and I wanted it in part so that I could resolve the open checker issue at https://github.com/validator/validator/issues/1854

[04:11:38.0570] <sideshowbarker>
I think you‚Äôre not missing something. I‚Äôd need to go back and look. But I will confess that in part what I did there was, implement against the tests. And I think I did get all the WPT tests for this fully passing.

In other words, I did the bad thing of not raising some spec issues that I probably should have when I was implementing¬†‚Äî I mean, about possible gaps in the spec relative to getting what the expected results for the tests seemed to require.

[04:12:35.0518] <hsivonen>
sideshowbarker: The difference would be visible only with a network stall and setTimeout, right?

[04:14:10.0957] <sideshowbarker>
Yeah, I reckon so. And so we should rightly have a WPT test for that ‚Äî¬†for the setTimeout case at least.

[04:14:41.0840] <sideshowbarker>
I will also confess that I didn‚Äôt not try to audit the tests for coverage against the spec requirements.

[04:14:49.0980] <sideshowbarker>
* I will also confess that I didn‚Äôt try to audit the tests for coverage against the spec requirements.

[04:44:43.0967] <annevk>
hsivonen: there's quite a few unresolved issues with `selectedcontent` still: https://github.com/whatwg/html/issues?q=state%3Aopen%20selectedcontent

[04:45:17.0896] <annevk>
Not really sure why the parser should say something about it though. I kinda like that it's all handled at the node tree layer.

[04:46:42.0742] <hsivonen>
annevk: It's pretty unfriendly to have an action triggered when a node is popped off the parser's stack without any hint in the parsing algorithm that popping `option` off the stack is connected to further action.

[04:49:52.0758] <annevk>
hsivonen: oh that bit. That's a pre-existing issue. I agree we should refactor that. https://github.com/whatwg/html/issues/11781 tracks that.

[04:52:24.0402] <hsivonen>
annevk: Thanks

[04:53:43.0471] <jmdyck>
You mean following *immediately*, like "If [condition], then [do thing 1], otherwise then [do thing 2]." ?

[04:58:31.0319] <annevk>
jmdyck: 1. If X, then Y. \n 2. Otherwise, then Z.

[05:21:06.0681] <jmdyck>
Hm, you might be thinking of https://matrix.to/#/!AGetWbsMpFPdSgUrbs:matrix.org/$Uyrjmx4h9XHM_gqQug19615xegSjjwzkaBN5-NLoeY0 almost a year ago.

[05:21:31.0637] <jmdyck>
To me, "otherwise, then" sounds ungrammatical.

[05:52:54.0426] <annevk>
I don't think that's it, but maybe it's just "Otherwise, if X," where we considered using "then" as well. I agree that for a lone "Otherwise" it looks weird.

[06:09:35.0441] <Luke Warlow>
https://html.spec.whatwg.org/multipage/links.html#dom-hyperlink-href

For something like step 4 here I think putting a then before "return this's href"... is fine. Not sure it's needed. But yeah just "otherwise, then" seems wrong to me.

[06:26:04.0054] <jgraham>
So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.

So API-wise the way this will work is that some operation that exposes a stream will return an object with a UUID to that stream and you'll get protocol operations like `io.readStream({stream: <id>})` and `io.closeStream({stream: id})`.

My question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for `readStream` we could pretty much call `[=read request=]` with something like:
```
1. Let readRequest be a new read request with the following items:
  1. [=chunk steps=] given |chunk|:
    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to [=serialize protocol bytes=] given |chunk| and the <code>done</code> field set to false.
    1. Return [=success=] with data |response|.

  1. [=close steps=]:
    1. Let Let |response| be a new `io.ReadResult` with the <code>value</code> field set to <code>""</code> and the <code>done</code> field set to true.

 1. [=error steps=] given |e|:
    1. Return [=error=] with [=error code=] [=stream read error=].
```
And then it needs the equivalent of `ReadableStreamDefaultReaderRead` to eventually call `stream.[[controller]].[[PullSteps]](readRequest)` and actually invoke the steps. 

This is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual `ReadableStreamDefaultReader` object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects. 

[06:29:20.0084] <jgraham>
* So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.

So API-wise the way this will work is that some operation that exposes a stream will return a WebDriver protocol message with a UUID to that stream and you'll get protocol operations like `io.readStream({stream: <id>})` and `io.closeStream({stream: id})`.

My question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for `readStream` we could pretty much call `[=read request=]` with something like:

```
1. Let readRequest be a new read request with the following items:
  1. [=chunk steps=] given |chunk|:
    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to [=serialize protocol bytes=] given |chunk| and the <code>done</code> field set to false.
    1. Return [=success=] with data |response|.

  1. [=close steps=]:
    1. Let Let |response| be a new `io.ReadResult` with the <code>value</code> field set to <code>""</code> and the <code>done</code> field set to true.

 1. [=error steps=] given |e|:
    1. Return [=error=] with [=error code=] [=stream read error=].
```

And then it needs the equivalent of `ReadableStreamDefaultReaderRead` to eventually call `stream.[[controller]].[[PullSteps]](readRequest)` and actually invoke the steps.

This is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual `ReadableStreamDefaultReader` object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.

[06:29:59.0171] <jgraham>
* So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.

So API-wise the way this will work is that some WebDriver operation that exposes a stream will return a message with a UUID to that stream and you'll get protocol operations like `io.readStream({stream: <id>})` and `io.closeStream({stream: id})`.

My question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for `readStream` we could pretty much call `[=read request=]` with something like:

```
1. Let readRequest be a new read request with the following items:
  1. [=chunk steps=] given |chunk|:
    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to [=serialize protocol bytes=] given |chunk| and the <code>done</code> field set to false.
    1. Return [=success=] with data |response|.

  1. [=close steps=]:
    1. Let Let |response| be a new `io.ReadResult` with the <code>value</code> field set to <code>""</code> and the <code>done</code> field set to true.

 1. [=error steps=] given |e|:
    1. Return [=error=] with [=error code=] [=stream read error=].
```

And then it needs the equivalent of `ReadableStreamDefaultReaderRead` to eventually call `stream.[[controller]].[[PullSteps]](readRequest)` and actually invoke the steps.

This is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual `ReadableStreamDefaultReader` object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.

[06:30:27.0566] <jgraham>
* So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.

So API-wise the way this will work is that some WebDriver operation that exposes a stream will return a WebDriver message with a UUID to that stream and you'll get protocol operations like `io.readStream({stream: <id>})` and `io.closeStream({stream: id})`.

My question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for `readStream` we could pretty much call `[=read request=]` with something like:

```
1. Let readRequest be a new read request with the following items:
  1. [=chunk steps=] given |chunk|:
    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to [=serialize protocol bytes=] given |chunk| and the <code>done</code> field set to false.
    1. Return [=success=] with data |response|.

  1. [=close steps=]:
    1. Let Let |response| be a new `io.ReadResult` with the <code>value</code> field set to <code>""</code> and the <code>done</code> field set to true.

 1. [=error steps=] given |e|:
    1. Return [=error=] with [=error code=] [=stream read error=].
```

And then it needs the equivalent of `ReadableStreamDefaultReaderRead` to eventually call `stream.[[controller]].[[PullSteps]](readRequest)` and actually invoke the steps.

This is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual `ReadableStreamDefaultReader` object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.

[06:31:40.0182] <jgraham>
* So we want to add stream support in WebDriver BiDi so that e.g. you can access large network responses without having to buffer the entire response and pass in in a single message.

So API-wise the way this will work is that some WebDriver operation that exposes a stream will return a WebDriver message with a UUID to that stream and you'll get protocol operations like `io.readStream({stream: <id>})` and `io.closeStream({stream: id})`.

My question is: what's the best way to specify that? From a WebDriver point of view there isn't really a JS reader object involved; for `readStream` we could pretty much call `[=read request=]` with something like:

```
1. Let readRequest be a new read request with the following items:
  1. [=chunk steps=] given |chunk|:
    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to [=serialize protocol bytes=] given |chunk| and the <code>done</code> field set to false.
    1. Return [=success=] with data |response|.

  1. [=close steps=]:
    1. Let |response| be a new `io.ReadResult` with the <code>value</code> field set to <code>""</code> and the <code>done</code> field set to true.
    1. Return [=success=] with data |response|.

 1. [=error steps=] given |e|:
    1. Return [=error=] with [=error code=] [=stream read error=].
```

And then it needs the equivalent of `ReadableStreamDefaultReaderRead` to eventually call `stream.[[controller]].[[PullSteps]](readRequest)` and actually invoke the steps.

This is all doable, and honestly seems fairly easy to follow, but I'm somewhat worried that the Streams spec is going to turn out to depend on the assumption that all readers are actually IDL objects, and we're going to end up violating some invariants. The other option is to write the WebDriver spec to obtain an actual `ReadableStreamDefaultReader` object and work out how to write spec prose that manipulates DOM promises. I think that's going to be harder to follow from the WebDriver side, but avoids recreating a lot of the internal mechanics of the reader objects.

