<!DOCTYPE html><html><head>
  <title>TC39 Async Context on 2024-05-27</title>
  <link rel="stylesheet" href="../style.css">
  <script>window.room = "TC39 Async Context";</script><script src="../render-roomlist.js"></script>
  <script src="../logs.js"></script>
</head>
<body><div class="wrapper">
<div class="sidebar">
<div class="title">TC39 Async Context<br>2024-05-27<br><a href="plaintext/">plaintext logs</a></div>
<div class="nav">
<a href="2024-05-24" class="nav-link"><span>prev</span></a>
<span style="float:right">next</span>
</div>
    <div class="all-rooms"><noscript>JavaScript is required to load the channel index, but you can go to <a href="../..">the static index</a> directly.</noscript></div>
<div class="footer"><a href="https://github.com/bakkot/matrix-archive-bot">source on github</a></div>
</div>
<div class="rhs">
<div class="rhs-header">
<span id="error" style="color: red; display:none">error</span>

<input type="text" id="query" size="25" placeholder="Search TC39 Async Context">
<a id="search-submit" class="button icon-link" title="Search">
  <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg>
</a>
</div>

<div class="log"><table id="log-table"><tbody id="log-tbody">

  <tr class="msg" id="L0"><td class="ts-cell"><a class="ts" href="#L0" alt="Mon May 27 2024 10:56:52 GMT-0700 (Pacific Daylight Time)">17:56</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">I think we have more <code>unhandledrejection</code> bugs that we haven't caught yet</td></tr>
  <tr class="msg" id="L1"><td class="ts-cell"><a class="ts" href="#L1" alt="Mon May 27 2024 10:57:17 GMT-0700 (Pacific Daylight Time)">17:57</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">this was in part because <code>unhandledrejection</code> is tested with WPT, not test262, and I haven't gotten around to writing WPT tests yet</td></tr>
  <tr class="msg" id="L2"><td class="ts-cell"><a class="ts" href="#L2" alt="Mon May 27 2024 10:58:15 GMT-0700 (Pacific Daylight Time)">17:58</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">but it's looking like with the current spec, <code>someAsyncApi().then()</code> would lose track of the rejection context</td></tr>
  <tr class="msg" id="L3"><td class="ts-cell"><a class="ts" href="#L3" alt="Mon May 27 2024 10:59:04 GMT-0700 (Pacific Daylight Time)">17:59</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">in Stephen's proposal of preserving the resolution context, this would just work I think</td></tr>
  <tr class="msg" id="L4"><td class="ts-cell"><a class="ts" href="#L4" alt="Mon May 27 2024 11:02:47 GMT-0700 (Pacific Daylight Time)">18:02</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> This seems funcionally equivalent to <a href="https://github.com/tc39/proposal-async-context/issues/60#issuecomment-2050457550">https://github.com/tc39/proposal-async-context/issues/60#issuecomment-2050457550</a>, which solves the global leak issue by having a wrapping try-catch reset the vaules after exiting the closure. It‚Äôs still not my favorite implementation becuase of mutability and odering of async functions causing unrelated breakages, eg if <a data-md="" href="https://gist.github.com/jridgewell/4aa2d6458f41d4574d6aeb580dc80d5d">main</a> started with an <code data-md="`">await 0</code> before entering <code data-md="`">‚Äôbar‚Äô</code>, the outside caller sees different behavior. It feels like Zalgo-lite.</blockquote></mx-reply><p>Similar, but the intent is that the <em>runtime</em> would generally be defining those scopes rather than only ever being handled by a user-facing API. We have a bunch of discrete execution concepts which can be used as boundaries for these scopes such as a promise continuation or a callback. We could also probably extend the Function type with something like a <code>func.bindToContext(value)</code> which could be similar to having that function call <code>run(...)</code> internally.</p>
<p>My point is, we can have the nice DX of the set/get interface without too heavily exposing the scoping problem to users. Decoupling the scoping also makes it potentially reusable, which would be beneficial if we <em>do</em> decide to make separate types for the two around and through flows. It would simplify things for users if they can describes scopes with a single API and have both flow systems just make different decisions about how to link the scopes together in the graph.</p>
</td></tr>
  <tr class="msg" id="L5"><td class="ts-cell"><a class="ts" href="#L5" alt="Mon May 27 2024 11:03:47 GMT-0700 (Pacific Daylight Time)">18:03</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Everywhere except if it‚Äôs set within the global context, which persists beyond just the current sync execution. Your above <code data-md="`">defineScope(() =&gt; {})</code> solves this by definining an exit point that cleans the global context.</blockquote></mx-reply>If you mean the top-level of the file/module, it'd just live as long as that script/module does, which seems to make sense to me.</td></tr>
  <tr class="msg" id="L6"><td class="ts-cell"><a class="ts" href="#L6" alt="Mon May 27 2024 11:04:56 GMT-0700 (Pacific Daylight Time)">18:04</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> <blockquote data-md=">">The risk of things living super long though is also easily mitigated by just emptying the context in some way, such as setting it to undefined when you've decided you're done with it.<br></blockquote><br>In a flows-through system, I think you also need to free every cached promise that holds that context? They would strongly hold their resolution context. The engine wouldn‚Äôt mutate user‚Äôs context automatically, and without a library API to know when the current exeuction is finalized, you‚Äôre left guessing when you can mutate the context or drop all promises.</blockquote></mx-reply>Yes, promises suck a little bit in that they would need to hold the reference alive as long as the promise remains alive. This <em>could</em> increase memory pressure, but is also the <em>expected</em> behaviour as any future continuation attached to that promise <em>should</em> restore that context value.</td></tr>
  <tr class="msg" id="L7"><td class="ts-cell"><a class="ts" href="#L7" alt="Mon May 27 2024 11:14:01 GMT-0700 (Pacific Daylight Time)">18:14</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> in Stephen's proposal of preserving the resolution context, this would just work I think</blockquote></mx-reply><p>Yes, <code>unhandledrejection</code> is one particular case where the desired context is <em>always</em> the flows-through context. You want to capture the context as it was when the rejection <em>happened</em>, even if it flows through a bunch of intermediate layers.</p>
<p>The difference between through and around flows is basically the same conceptually as subject and predicate. The <em>through</em> path gives you the subject of the failure so you can actually <em>see</em> what's going on. Whereas the <em>around</em> path gives you the predicate which is only describing what is being <em>done</em> with that subject, but that's not relevant in the case of a failure as it's what <em>would have</em> been done but will not be <em>because</em> of the failure.</p>
<p>This also matches that prior description of around flow being like parameter flow. It describes where execution is <em>going</em> and not so much where it <em>came from</em>, which is a bit counter-intuitive from the flow users have generally expected from AsyncLocalStorage where they want to know where something <em>came from</em> so they can acquired stored information about that originating execution.</p>
</td></tr>
  <tr class="msg" id="L8"><td class="ts-cell"><a class="ts" href="#L8" alt="Mon May 27 2024 11:15:59 GMT-0700 (Pacific Daylight Time)">18:15</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">so if we have both types of async context variables, then the only one that would have a relevant context for unhandledrejection would be the get/set one?</td></tr>
  <tr class="msg" id="L9"><td class="ts-cell"><a class="ts" href="#L9" alt="Mon May 27 2024 11:16:32 GMT-0700 (Pacific Daylight Time)">18:16</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">no, you still need some value for the other variables</td></tr>
  <tr class="msg" id="L10"><td class="ts-cell"><a class="ts" href="#L10" alt="Mon May 27 2024 11:16:38 GMT-0700 (Pacific Daylight Time)">18:16</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">get/set is a separate thing.</td></tr>
  <tr class="msg" id="L11"><td class="ts-cell"><a class="ts" href="#L11" alt="Mon May 27 2024 11:16:56 GMT-0700 (Pacific Daylight Time)">18:16</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">oh, I might have been conflating both proposals</td></tr>
  <tr class="msg" id="L12"><td class="ts-cell"><a class="ts" href="#L12" alt="Mon May 27 2024 11:17:27 GMT-0700 (Pacific Daylight Time)">18:17</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">The get/set thing is just about that you don't actually <em>need</em> the <code><a href="http://store.run">store.run</a>(...)</code> if you have the <em>runtime</em> provide scopes.</td></tr>
  <tr class="msg" id="L13"><td class="ts-cell"><a class="ts" href="#L13" alt="Mon May 27 2024 11:18:23 GMT-0700 (Pacific Daylight Time)">18:18</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">Well, you still might <em>want</em> to have <code>run(..)</code> sometimes, but it becomes less important if the context flow model is clear and correct from the core.</td></tr>
  <tr class="msg" id="L14"><td class="ts-cell"><a class="ts" href="#L14" alt="Mon May 27 2024 11:18:50 GMT-0700 (Pacific Daylight Time)">18:18</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">Which is where integration with things like promises comes in.</td></tr>
  <tr class="msg" id="L15"><td class="ts-cell"><a class="ts" href="#L15" alt="Mon May 27 2024 11:19:03 GMT-0700 (Pacific Daylight Time)">18:19</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">well, I think the idea I had was James Snell's distinction between a run API that flows around and a set API that flows through</td></tr>
  <tr class="msg" id="L16"><td class="ts-cell"><a class="ts" href="#L16" alt="Mon May 27 2024 11:19:28 GMT-0700 (Pacific Daylight Time)">18:19</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">I might have missed some of the intervening discussion because I was sick</td></tr>
  <tr class="msg" id="L17"><td class="ts-cell"><a class="ts" href="#L17" alt="Mon May 27 2024 11:19:41 GMT-0700 (Pacific Daylight Time)">18:19</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">So it's a little weird to me that we're pursuing <em>both</em> defining the correct flow model <em>and</em> still using the <code>run(...)</code> scoping when we could just safely modify the <em>current</em> scope if we actually <em>have</em> a clearly defined "current scope" to be modifying.</td></tr>
  <tr class="msg" id="L18"><td class="ts-cell"><a class="ts" href="#L18" alt="Mon May 27 2024 11:20:22 GMT-0700 (Pacific Daylight Time)">18:20</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">I may have missed that too. ü§î</td></tr>
  <tr class="msg" id="L19"><td class="ts-cell"><a class="ts" href="#L19" alt="Mon May 27 2024 11:21:31 GMT-0700 (Pacific Daylight Time)">18:21</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">would sync function boundaries be part of that scope?</td></tr>
  <tr class="msg" id="L20"><td class="ts-cell"><a class="ts" href="#L20" alt="Mon May 27 2024 11:22:06 GMT-0700 (Pacific Daylight Time)">18:22</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">Yes, it should be only sync segments of execution.</td></tr>
  <tr class="msg" id="L21"><td class="ts-cell"><a class="ts" href="#L21" alt="Mon May 27 2024 11:22:28 GMT-0700 (Pacific Daylight Time)">18:22</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><p>And then the <code>run</code> function would essentially just be:</p>
<pre><code class="language-js">run(value, scope) {
  const prev = this.get()
  this.set(value)
  try {
    return scope()
  } finally {
    this.set(prev)
  }
}
</code></pre>
</td></tr>
  <tr class="msg" id="L22"><td class="ts-cell"><a class="ts" href="#L22" alt="Mon May 27 2024 11:25:13 GMT-0700 (Pacific Daylight Time)">18:25</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">I think one of the hurdles we have at the implementor level is that we <em>really</em> want to think about async functions and generators as singular functions and not chains of segments of synchronous execution managed by a scheduler.</td></tr>
  <tr class="msg" id="L23"><td class="ts-cell"><a class="ts" href="#L23" alt="Mon May 27 2024 11:25:17 GMT-0700 (Pacific Daylight Time)">18:25</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell"><p>so IIUC:</p>
<pre><code class="language-js">asyncVar.set("foo");

await (async () =&gt; {
	asyncVar.set("bar");
})();

console.log(asyncVar.get());  // bar
</code></pre>
<p>but</p>
<pre><code class="language-js">asyncVar.set("foo");

// No await!
(async () =&gt; {
	asyncVar.set("bar");
})();

console.log(asyncVar.get());  // foo
</code></pre>
</td></tr>
  <tr class="msg" id="L24"><td class="ts-cell"><a class="ts" href="#L24" alt="Mon May 27 2024 11:25:49 GMT-0700 (Pacific Daylight Time)">18:25</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">wait</td></tr>
  <tr class="msg" id="L25"><td class="ts-cell"><a class="ts" href="#L25" alt="Mon May 27 2024 11:26:03 GMT-0700 (Pacific Daylight Time)">18:26</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">Both would actually be bar.</td></tr>
  <tr class="msg" id="L26"><td class="ts-cell"><a class="ts" href="#L26" alt="Mon May 27 2024 11:26:16 GMT-0700 (Pacific Daylight Time)">18:26</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">do things change if there's some await inside the async function, before the set?\</td></tr>
  <tr class="msg" id="L27"><td class="ts-cell"><a class="ts" href="#L27" alt="Mon May 27 2024 11:26:20 GMT-0700 (Pacific Daylight Time)">18:26</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">And the first is bar <em>now</em> because that first segment of the inner async function is sync.</td></tr>
  <tr class="msg" id="L28"><td class="ts-cell"><a class="ts" href="#L28" alt="Mon May 27 2024 11:27:01 GMT-0700 (Pacific Daylight Time)">18:27</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">Yes, so currently a <em>huge</em> source of confusion in Node.js is that <code>store.enterWith(...)</code> <em>before</em> the first await behaves very differently from <code>store.enterWith(...)</code> <em>after</em> the first await.</td></tr>
  <tr class="msg" id="L29"><td class="ts-cell"><a class="ts" href="#L29" alt="Mon May 27 2024 11:27:22 GMT-0700 (Pacific Daylight Time)">18:27</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">Because that first segment of an async function is actually executed synchronously rather than lazily.</td></tr>
  <tr class="msg" id="L30"><td class="ts-cell"><a class="ts" href="#L30" alt="Mon May 27 2024 11:28:35 GMT-0700 (Pacific Daylight Time)">18:28</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">I think that's more a problem with how async functions are defined than with AsyncLocalStorage though. You can get the same unexpected behaviour just modifying globals in an async function.</td></tr>
  <tr class="msg" id="L31"><td class="ts-cell"><a class="ts" href="#L31" alt="Mon May 27 2024 11:29:42 GMT-0700 (Pacific Daylight Time)">18:29</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">I really wish async functions were actually lazy started and would not run anything until they are awaited or a continuation is attached. A bit late to change the past though. üòêÔ∏è</td></tr>
  <tr class="msg" id="L32"><td class="ts-cell"><a class="ts" href="#L32" alt="Mon May 27 2024 11:35:54 GMT-0700 (Pacific Daylight Time)">18:35</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><p>To distill things down to the essence of context management, all that is actually required to fully implement context flow is to capture three points:</p>
<ul>
<li>When a call schedules an async task the current context needs to be captured.</li>
<li>When top-level or any nested continuations of async tasks would begin sync execution the context needs to be restored.</li>
<li>And if context is not flowed <em>completely</em> into all paths then the <em>end</em> of sync execution may also be required as the next sync execution to begin may not apply a context swap before it runs if it is not something which context normally flows into. This point is why I think it's generally best to consider <em>all</em> execution as logically descending from the runtime starting and branch contexts off from that accordingly.</li>
</ul>
</td></tr>

</tbody></table></div></div></div>
</body></html>