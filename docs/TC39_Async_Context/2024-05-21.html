<!DOCTYPE html><html><head>
  <title>TC39 Async Context on 2024-05-21</title>
  <link rel="stylesheet" href="../style.css">
  <script>window.room = "TC39 Async Context";</script><script src="../render-roomlist.js"></script>
  <script src="../logs.js"></script>
</head>
<body><div class="wrapper">
<div class="sidebar">
<div class="title">TC39 Async Context<br>2024-05-21<br><a href="plaintext/">plaintext logs</a></div>
<div class="nav">
<a href="2024-05-20" class="nav-link"><span>prev</span></a>
<span style="float:right">next</span>
</div>
    <div class="all-rooms"><noscript>JavaScript is required to load the channel index, but you can go to <a href="../..">the static index</a> directly.</noscript></div>
<div class="footer"><a href="https://github.com/bakkot/matrix-archive-bot">source on github</a></div>
</div>
<div class="rhs">
<div class="rhs-header">
<span id="error" style="color: red; display:none">error</span>

<input type="text" id="query" size="25" placeholder="Search TC39 Async Context">
<a id="search-submit" class="button icon-link" title="Search">
  <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg>
</a>
</div>

<div class="log"><table id="log-table"><tbody id="log-tbody">

  <tr class="msg" id="L0"><td class="ts-cell"><a class="ts" href="#L0" alt="Mon May 20 2024 19:10:31 GMT-0700 (Pacific Daylight Time)">02:10</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">* I'm not even sure if per-store configurability (if it's a global default to push things in the call/resolve-time vs registration-time direction in the cases where both are available) will be a solution; sometimes you want the registration-time ancestor of the call-time ancestor</td></tr>
  <tr class="msg" id="L1"><td class="ts-cell"><a class="ts" href="#L1" alt="Mon May 20 2024 21:32:20 GMT-0700 (Pacific Daylight Time)">04:32</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-1" title="@jridgewell:matrix.org">Justin Ridgewell</span>&gt;</div></td><td class="msg-cell">Wow, this really blew up over the last few days</td></tr>
  <tr class="msg" id="L2"><td class="ts-cell"><a class="ts" href="#L2" alt="Mon May 20 2024 21:34:08 GMT-0700 (Pacific Daylight Time)">04:34</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-1" title="@jridgewell:matrix.org">Justin Ridgewell</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote>It's not <em>just</em> the timing of enabling PromiseHook. It is that the portion of an async function <em>before</em> the first await behaves differently from the rest of the function because the context capture will have already happened around the outer await before passing over the inner awaits. It's confusing to users that the context is not flowing out.</blockquote></mx-reply>I donâ€™t understand this. What are the inner and outer awaits? In my mind, the async context is bound when we enter the function, it doesnâ€™t matter where the awaits are.</td></tr>
  <tr class="msg" id="L3"><td class="ts-cell"><a class="ts" href="#L3" alt="Mon May 20 2024 21:34:35 GMT-0700 (Pacific Daylight Time)">04:34</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-1" title="@jridgewell:matrix.org">Justin Ridgewell</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote>The proposal as it current stands is maintaining the lexical consistent value inside a async function body across <code>await</code> for <code>AsyncContext.Variable</code>, which is part of the approach aiming to address the dynamic scope concerns from the previous meeting's feedback.</blockquote></mx-reply>Exactly.</td></tr>
  <tr class="msg" id="L4"><td class="ts-cell"><a class="ts" href="#L4" alt="Mon May 20 2024 21:35:39 GMT-0700 (Pacific Daylight Time)">04:35</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-1" title="@jridgewell:matrix.org">Justin Ridgewell</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote>Yes. That is actually what users keep telling me they are <em>expecting</em>.</blockquote></mx-reply>Are there links to issue reports for this?</td></tr>
  <tr class="msg" id="L5"><td class="ts-cell"><a class="ts" href="#L5" alt="Mon May 20 2024 21:37:03 GMT-0700 (Pacific Daylight Time)">04:37</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-1" title="@jridgewell:matrix.org">Justin Ridgewell</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote>(See the warnings about rust <code>tracing::Span</code> in async code <a href="https://docs.rs/tracing/latest/tracing/span/struct.Span.html#in-asynchronous-code">https://docs.rs/tracing/latest/tracing/span/struct.Span.html#in-asynchronous-code</a> for some consequences of this sort of design in the wild -- but they're better off because Futures are expressive enough to write <code>Future::instrument</code> without needing built-in help)</blockquote></mx-reply>This example doesnâ€™t apply in our case, since any cooperate threading (another promise resuming in JS) would have restored its own context.</td></tr>
  <tr class="msg" id="L6"><td class="ts-cell"><a class="ts" href="#L6" alt="Mon May 20 2024 21:44:05 GMT-0700 (Pacific Daylight Time)">04:44</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-1" title="@jridgewell:matrix.org">Justin Ridgewell</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote>sure, people rewriting code from callbacks to promises might prefer resolution time, but what about people writing async/await code from scratch? Do we know what they need? Would we be breaking them?</blockquote></mx-reply>And itâ€™s not just web APIs, anything trying to cache fetches or other async behavior, any module level initializion using a promise, will break any user.</td></tr>
  <tr class="msg" id="L7"><td class="ts-cell"><a class="ts" href="#L7" alt="Mon May 20 2024 21:47:23 GMT-0700 (Pacific Daylight Time)">04:47</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-1" title="@jridgewell:matrix.org">Justin Ridgewell</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote>Flowing <em>around</em> is essentially just local variable scope which, to me, doesn't really seem to have much value. I've asked a few times for an explanation or some use case <em>why</em> anyone would want that flow but have not yet got any answer on that. ðŸ¤”</blockquote></mx-reply>Itâ€™s a local variable scope that propagates to child calls automatically. I explicitly want this becasue itâ€™s understandable, and easy to debug.</td></tr>
  <tr class="msg" id="L8"><td class="ts-cell"><a class="ts" href="#L8" alt="Mon May 20 2024 21:49:46 GMT-0700 (Pacific Daylight Time)">04:49</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-1" title="@jridgewell:matrix.org">Justin Ridgewell</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote>even with <code>.set()</code>, I don't think this would be dynamic scoping, at least not in the sense that <a href="https://github.com/tc39/proposal-async-context/blob/master/SCOPING.md">https://github.com/tc39/proposal-async-context/blob/master/SCOPING.md</a> discusses</blockquote></mx-reply>Unfortunately it is a form of dynamic scoping, but from callee to caller. This was another one of the points I had to discuss with the SES folks to get them on board with the proposal. The way they <a data-md="" href="https://github.com/endojs/endo/pull/1424">reasoned</a> about it is complicated, but essentially boils down to an implicit param to every function that is the async context mapping.</td></tr>
  <tr class="msg" id="L9"><td class="ts-cell"><a class="ts" href="#L9" alt="Mon May 20 2024 21:51:56 GMT-0700 (Pacific Daylight Time)">04:51</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-1" title="@jridgewell:matrix.org">Justin Ridgewell</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote>One concern I have with the mutable variable idea is how one is supposed to bound the mutation - I think it's common to make a change with a lifetime, which is why we've gravitated toward the <code>run()</code> encapsulation.  As you've pointed out, with the flow-through semantics, <code>run</code> is very clearly the wrong name, and <code>set</code> is much more appropriate.  But your example also hints at some mechanism whereby changes to the variable would still somehow go out of scope?  I think that's important, but it seems like it would lead to lots of confusion.  If some other scope is entered internally, would that inner scope accidentally prune off a branch of var mutations?  That also doesn't seem right.</blockquote></mx-reply>I think allowing unbounded <code data-md="`">set</code>s opens up the same problems as scoping, and introduces a global leak that is unfixable (how do you ever know when the last set value is not needed anymore?).</td></tr>
  <tr class="msg" id="L10"><td class="ts-cell"><a class="ts" href="#L10" alt="Mon May 20 2024 21:57:09 GMT-0700 (Pacific Daylight Time)">04:57</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-1" title="@jridgewell:matrix.org">Justin Ridgewell</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote>There's not really any writing on it presently, but basically because we don't flow into promise continuations we need to keep an object at the top-level of the request which we push spans into and basically <em>guess</em> what the parent is because, unlike with callbacks, the parent does not flow into the continuation. This means we have to look at what has been pushed into that list in the past and try to guess what the parent would be. Sometimes it's simply the last span in the list, but not always, so we need to do some additional analysis to figure out what was the last span which <em>could</em> be a realistic parent, which requires we also hold a bunch of the span metadata. Holding all this metadata is expensive given that we could have hundreds of thousands of concurrent spans. What we <em>want</em> is for the <em>correct</em> context to just be able to flow through the resolve path so we only need to store the IDs and can entirely eliminate that big bag of data which lives for the whole life of the request.</blockquote></mx-reply>I think this is what Iâ€™m missing. I donâ€™t understand why could would need to guess, Iâ€™m naively assuming its always follows-from the last child and child-of the current parent. Whatâ€™s a case where this isnâ€™t correct? How does the flows-through solve holding holding the hundreds of thousands of concurrent spans?</td></tr>
  <tr class="msg" id="L11"><td class="ts-cell"><a class="ts" href="#L11" alt="Mon May 20 2024 21:57:55 GMT-0700 (Pacific Daylight Time)">04:57</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-1" title="@jridgewell:matrix.org">Justin Ridgewell</span>&gt;</div></td><td class="msg-cell">(Also, sorry for not respondning a whole lot, normal coprorate BS is taking up all my free time)</td></tr>
  <tr class="msg" id="L12"><td class="ts-cell"><a class="ts" href="#L12" alt="Tue May 21 2024 01:49:37 GMT-0700 (Pacific Daylight Time)">08:49</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Unfortunately it is a form of dynamic scoping, but from callee to caller. This was another one of the points I had to discuss with the SES folks to get them on board with the proposal. The way they <a data-md="" href="https://github.com/endojs/endo/pull/1424">reasoned</a> about it is complicated, but essentially boils down to an implicit param to every function that is the async context mapping.</blockquote></mx-reply>is there any documentation anywhere about what SES needs from new proposals?</td></tr>
  <tr class="msg" id="L13"><td class="ts-cell"><a class="ts" href="#L13" alt="Tue May 21 2024 02:01:17 GMT-0700 (Pacific Daylight Time)">09:01</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Honestly I have to agree with others who pointed out that some in TC39 will see this version to be "not well behaved"</blockquote></mx-reply>In my view, considering in-place mutation as "not well behaved" because of unintended flow consequences just says to me that the flow model is not clearly defined and <em>correct</em> enough to be <em>certain</em> of what the behaviour will be. If the model is actually <em>correct</em> and <em>consistent</em> then there should be no reason that setting partway through a scope should produce any sort of unexpected behaviour.</td></tr>
  <tr class="msg" id="L14"><td class="ts-cell"><a class="ts" href="#L14" alt="Tue May 21 2024 02:03:04 GMT-0700 (Pacific Daylight Time)">09:03</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> I just have to admit the use cases are valid and there are many places where We Need Both .... makes things way more complicated tho</blockquote></mx-reply>Yes, particularly with async/await the callback-scoped version starts to make less and less sense. This was the whole reason that way back <em>before</em> we settled on <code>AsyncLocalStorage</code> I was backing the <code>AsyncLocal</code> proposal which <em>only</em> did the set/get style and left the flow scoping semantics up to the runtime to get right.</td></tr>
  <tr class="msg" id="L15"><td class="ts-cell"><a class="ts" href="#L15" alt="Tue May 21 2024 02:06:30 GMT-0700 (Pacific Daylight Time)">09:06</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">I'm not actually sure I understand this. As with the current proposal, you would still need to have access to an object in order to set or get, so isn't it exactly parallel to setting a variable defined in an outer scope?</td></tr>
  <tr class="msg" id="L16"><td class="ts-cell"><a class="ts" href="#L16" alt="Tue May 21 2024 02:08:01 GMT-0700 (Pacific Daylight Time)">09:08</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> my experience with mutable dynamically bound variables in Factor was negative. It can be surprising how much or little the write to the variable is propagated up/backwards and then read by someone else. <code>.run</code> has a simple answer to this question: it isn't propagated up/backwards.</blockquote></mx-reply>It doesn't mutate the slot, but if you store an object in it you can propagate mutations up the tree. I think all we can really do is make captures be a copy of what the reference points to at the time and not be the same binding, so at least that top-level mapping of store to value doesn't propagate upward. This is also partly <em>why</em> I think it's important that it be treated as a <em>variable</em> and not a <em>bag of data</em>, because data bags are problematic when it comes to leaking mutations.</td></tr>
  <tr class="msg" id="L17"><td class="ts-cell"><a class="ts" href="#L17" alt="Tue May 21 2024 02:10:24 GMT-0700 (Pacific Daylight Time)">09:10</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> so we ended up rediscovering that setting a dynamically scoped variable was an anti-pattern, and we moved towards doing .run instead</blockquote></mx-reply>This is what I lean toward at this point, personally. Though I <em>do</em> see that there are a few scenarios where it doesn't <em>quite</em> work the way you want it unless you do things like breaking out of awaits. Unfortunately this is how the OTel context works--you can activate a context within the <em>current</em> scope.</td></tr>
  <tr class="msg" id="L18"><td class="ts-cell"><a class="ts" href="#L18" alt="Tue May 21 2024 02:11:21 GMT-0700 (Pacific Daylight Time)">09:11</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">What do you mean by breaking out of awaits?</td></tr>
  <tr class="msg" id="L19"><td class="ts-cell"><a class="ts" href="#L19" alt="Tue May 21 2024 02:17:48 GMT-0700 (Pacific Daylight Time)">09:17</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Yes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's <em>able</em> to do this externally. With Node.js there is no solution.</blockquote></mx-reply>Comparison with other languages would be really useful if we can figure out where to look</td></tr>
  <tr class="msg" id="L20"><td class="ts-cell"><a class="ts" href="#L20" alt="Tue May 21 2024 02:22:11 GMT-0700 (Pacific Daylight Time)">09:22</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> I donâ€™t understand this. What are the inner and outer awaits? In my mind, the async context is bound when we enter the function, it doesnâ€™t matter where the awaits are.</blockquote></mx-reply><p>The spec, as it is presently, calls for capturing the context at the point where an await happens, not where the promise being awaited resolves. The context flows <em>into</em> that promise, and it <em>would</em> flow all the way to the point of resolving, but then we orphan that branch and return the context back to the captured value of that outer await.</p>
<p>In this particular example though, it's using <code>store.enterWith(...)</code> which effectively sets the value in the <em>current</em> scope without creating a new scope first. Because the initial segment of an async function executes synchronously, if that occurs <em>before</em> the first await of that <em>internal</em> function then the point at which the outer function captures its await will have already change <em>its</em> context and so will adopt that inner context. Whereas if that inner function modifies the current context <em>after</em> the first await within that inner function it will have already passed the point where the outer function captured the await context and so it would <em>not</em> use that value. The fact this sometimes changes the outer function context and sometimes doesn't is extremely confusing. Users are expecting it to <em>always</em> change the outer context, as indicated in the issue, because it is logically a continuation and should therefore behave the same as it would were it written with callbacks instead.</p>
</td></tr>
  <tr class="msg" id="L21"><td class="ts-cell"><a class="ts" href="#L21" alt="Tue May 21 2024 02:26:03 GMT-0700 (Pacific Daylight Time)">09:26</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Are there links to issue reports for this?</blockquote></mx-reply>The issue I just posted yesterday was exactly this, and we get <em>numerous</em> reports expecting this behaviour in Datadog support escalations. I've seen it come up many times before in many places too--Slack conversations, conversations at collab summits...I've never seen anyone that <em>expected</em> the behaviour as it is presently. It's possible that no one talks about it because people don't complain about what they think is already working, but given that the vast majority of context management usage is APMs and all the APM devs I've talked to have complained about these context flows as problematic I feel like there's a pretty good chance we're getting it wrong.</td></tr>
  <tr class="msg" id="L22"><td class="ts-cell"><a class="ts" href="#L22" alt="Tue May 21 2024 02:27:58 GMT-0700 (Pacific Daylight Time)">09:27</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Itâ€™s a local variable scope that propagates to child calls automatically. I explicitly want this becasue itâ€™s understandable, and easy to debug.</blockquote></mx-reply>Yes, I get that people want this "around" flow. I'm fine with people wanting it. I'm just not clear what exactly the <em>reason</em> is why they want it. What <em>specifically</em> is the use case for that flow?</td></tr>
  <tr class="msg" id="L23"><td class="ts-cell"><a class="ts" href="#L23" alt="Tue May 21 2024 02:36:03 GMT-0700 (Pacific Daylight Time)">09:36</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> I think this is what Iâ€™m missing. I donâ€™t understand why could would need to guess, Iâ€™m naively assuming its always follows-from the last child and child-of the current parent. Whatâ€™s a case where this isnâ€™t correct? How does the flows-through solve holding holding the hundreds of thousands of concurrent spans?</blockquote></mx-reply><p>Consider this code:</p>
<pre><code class="language-js">async function doSomething() {
  await doAThing() // first span
  await doAnotherThing() // no span
  await doYetAnotherThing() // second span should be follows-from first
}
</code></pre>
<p>If we have call <code>doSomething()</code> twice in a <code>Promise.all(...)</code>, which we do not instrument or have any particular awareness of--maybe it's user code--then we'll get two spans being created for the first awaits of each, then when the second spans come in they will no have a way to differentiate because the <code>doSomething()</code> itself would have the same context when it runs both times and would be restoring that over the awaits, blowing away the context we had from the inner function calls which we otherwise <em>could</em> associate with if we had flow-through semantics.</p>
</td></tr>
  <tr class="msg" id="L24"><td class="ts-cell"><a class="ts" href="#L24" alt="Tue May 21 2024 02:39:03 GMT-0700 (Pacific Daylight Time)">09:39</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> I'm not actually sure I understand this. As with the current proposal, you would still need to have access to an object in order to set or get, so isn't it exactly parallel to setting a variable defined in an outer scope?</blockquote></mx-reply>Yeah, I really don't get what the security concerns are here. You need access to the variable instance to retrieve the data. Sharing any <em>normal</em> variable would have the same security implications.</td></tr>
  <tr class="msg" id="L25"><td class="ts-cell"><a class="ts" href="#L25" alt="Tue May 21 2024 02:41:44 GMT-0700 (Pacific Daylight Time)">09:41</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> What do you mean by breaking out of awaits?</blockquote></mx-reply>I mean the flow-through semantics. The <code><a href="http://store.run">store.run</a>(...)</code> form is not particularly usable in async functions, having an in-scope mutation would make more sense, or <em>at least</em> some way to inform the context to <em>not</em> bind around the await when what you actually <em>want</em> is the flow-through semantics.</td></tr>
  <tr class="msg" id="L26"><td class="ts-cell"><a class="ts" href="#L26" alt="Tue May 21 2024 02:43:10 GMT-0700 (Pacific Daylight Time)">09:43</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">Most other languages I've seen don't have a user-provided scoping mechanism for context, the runtime decides it themselves.</td></tr>
  <tr class="msg" id="L27"><td class="ts-cell"><a class="ts" href="#L27" alt="Tue May 21 2024 02:43:34 GMT-0700 (Pacific Daylight Time)">09:43</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">Like Ruby does that with fiber locals as just a simple map that it manages on its own without any user-provided scopes.</td></tr>
  <tr class="msg" id="L28"><td class="ts-cell"><a class="ts" href="#L28" alt="Tue May 21 2024 02:44:00 GMT-0700 (Pacific Daylight Time)">09:44</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><a href="https://docs.ruby-lang.org/en/master/Fiber.html#method-i-storage">https://docs.ruby-lang.org/en/master/Fiber.html#method-i-storage</a></td></tr>
  <tr class="msg" id="L29"><td class="ts-cell"><a class="ts" href="#L29" alt="Tue May 21 2024 02:45:26 GMT-0700 (Pacific Daylight Time)">09:45</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">And go has its explicit <code>Context</code> object which you have to pass through manually, but you basically do clones every time you want to modify it and it flows downward through the calls you make passing in the modified version.</td></tr>
  <tr class="msg" id="L30"><td class="ts-cell"><a class="ts" href="#L30" alt="Tue May 21 2024 02:46:41 GMT-0700 (Pacific Daylight Time)">09:46</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">.NET also has AsyncLocal, which is basically exactly what was originally proposed in Node.js <em>before</em> AsyncLocalStorage was chosen instead, because people didn't trust the Node.js runtime to manage scopes correctly. <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.asynclocal-1?view=net-8.0">https://learn.microsoft.com/en-us/dotnet/api/system.threading.asynclocal-1?view=net-8.0</a></td></tr>
  <tr class="msg" id="L31"><td class="ts-cell"><a class="ts" href="#L31" alt="Tue May 21 2024 02:47:16 GMT-0700 (Pacific Daylight Time)">09:47</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">Again, doing the simple key/value hash map type structure with no user-supplied scoping mechanism.</td></tr>
  <tr class="msg" id="L32"><td class="ts-cell"><a class="ts" href="#L32" alt="Tue May 21 2024 02:47:28 GMT-0700 (Pacific Daylight Time)">09:47</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-7" title="@legendecas:matrix.org">Chengzhong Wu</span>&gt;</div></td><td class="msg-cell">The issue was confusing for it's use on <code>enterWith</code> and performance optimization that make an <code>AsyncLocalStorage</code> behaves differently when modification of <code>AsyncLocalStorage</code> was performed at different positions in an async function body. Let's wait to see if Matteo wants to expand on his original requirement on the issue.</td></tr>
  <tr class="msg" id="L33"><td class="ts-cell"><a class="ts" href="#L33" alt="Tue May 21 2024 02:50:50 GMT-0700 (Pacific Daylight Time)">09:50</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">Python also does the plain map with a set/get and manages context scopes on its own. <a href="https://docs.python.org/3/library/contextvars.html">https://docs.python.org/3/library/contextvars.html</a></td></tr>
  <tr class="msg" id="L34"><td class="ts-cell"><a class="ts" href="#L34" alt="Tue May 21 2024 02:51:40 GMT-0700 (Pacific Daylight Time)">09:51</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">As far as I'm aware, JavaScript is the <em>only</em> language that thinks (for some reason) that this needs to be handed over to the user rather than just letting them modify the <em>current</em> scope.</td></tr>
  <tr class="msg" id="L35"><td class="ts-cell"><a class="ts" href="#L35" alt="Tue May 21 2024 02:52:31 GMT-0700 (Pacific Daylight Time)">09:52</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">Probably because we had bad experiences with domains in Node.js. But I think that's less a problem of set/get and more that domains itself was just bad. ðŸ˜¬</td></tr>
  <tr class="msg" id="L36"><td class="ts-cell"><a class="ts" href="#L36" alt="Tue May 21 2024 02:52:46 GMT-0700 (Pacific Daylight Time)">09:52</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> As far as I'm aware, JavaScript is the <em>only</em> language that thinks (for some reason) that this needs to be handed over to the user rather than just letting them modify the <em>current</em> scope.</blockquote></mx-reply>in Rust, there's tokio's <code>task_local!</code> / <code>LocalKey</code></td></tr>
  <tr class="msg" id="L37"><td class="ts-cell"><a class="ts" href="#L37" alt="Tue May 21 2024 02:52:56 GMT-0700 (Pacific Daylight Time)">09:52</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">which doesn't let you modify the current scope</td></tr>
  <tr class="msg" id="L38"><td class="ts-cell"><a class="ts" href="#L38" alt="Tue May 21 2024 02:53:32 GMT-0700 (Pacific Daylight Time)">09:53</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-7" title="@legendecas:matrix.org">Chengzhong Wu</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> .NET also has AsyncLocal, which is basically exactly what was originally proposed in Node.js <em>before</em> AsyncLocalStorage was chosen instead, because people didn't trust the Node.js runtime to manage scopes correctly. <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.asynclocal-1?view=net-8.0">https://learn.microsoft.com/en-us/dotnet/api/system.threading.asynclocal-1?view=net-8.0</a></blockquote></mx-reply><a href="https://dotnetfiddle.net/7ulHg0">https://dotnetfiddle.net/7ulHg0</a> AFAICT dotnet doesn't flow-through values even it allows <code>.set</code> pattern</td></tr>
  <tr class="msg" id="L39"><td class="ts-cell"><a class="ts" href="#L39" alt="Tue May 21 2024 02:54:54 GMT-0700 (Pacific Daylight Time)">09:54</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">Yep, flow-through is a different issue from the matter of if set/get are reasonable. I mostly brought that up because of James talking about that split idea.</td></tr>
  <tr class="msg" id="L40"><td class="ts-cell"><a class="ts" href="#L40" alt="Tue May 21 2024 02:55:22 GMT-0700 (Pacific Daylight Time)">09:55</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-7" title="@legendecas:matrix.org">Chengzhong Wu</span>&gt;</div></td><td class="msg-cell">That's great. I really appreciate distinguishing the two topics</td></tr>
  <tr class="msg" id="L41"><td class="ts-cell"><a class="ts" href="#L41" alt="Tue May 21 2024 02:55:38 GMT-0700 (Pacific Daylight Time)">09:55</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">But I think what would probably actually <em>make sense</em> is to just have multiple context types which work in the set/get mode and use the two types to differentiate the flows.</td></tr>
  <tr class="msg" id="L42"><td class="ts-cell"><a class="ts" href="#L42" alt="Tue May 21 2024 02:56:23 GMT-0700 (Pacific Daylight Time)">09:56</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">One can be a "modify current context and flow into children only" type while the other can be "modify for any logically following execution" type.</td></tr>
  <tr class="msg" id="L43"><td class="ts-cell"><a class="ts" href="#L43" alt="Tue May 21 2024 03:28:06 GMT-0700 (Pacific Daylight Time)">10:28</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">I think <code>ContinuationContext</code> clearly describes the logical execution flow style. I feel like the <code>AsyncContext</code> name is a bit vague about exactly <em>how</em> it flows through async behaviour though. I wonder if we should consider a name which more clearly communicates exactly <em>how</em> it flows through async code so we aren't creating confusion?</td></tr>
  <tr class="msg" id="L44"><td class="ts-cell"><a class="ts" href="#L44" alt="Tue May 21 2024 03:31:49 GMT-0700 (Pacific Daylight Time)">10:31</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">I wonder if we need the "async" in the name at all. <code>CallContext</code> might communicate the flow semantics better? Or even <code>ImplicitCallContext</code> to make it even <em>more</em> clear that this is data which gets passed around without needing to do so explicitly? ðŸ¤”</td></tr>

</tbody></table></div></div></div>
</body></html>