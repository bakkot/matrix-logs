<!DOCTYPE html><html><head>
  <title>TC39 Async Context on 2024-05-17</title>
  <link rel="stylesheet" href="../style.css">
  <script>window.room = "TC39 Async Context";</script><script src="../render-roomlist.js"></script>
  <script src="../logs.js"></script>
</head>
<body><div class="wrapper">
<div class="sidebar">
<div class="title">TC39 Async Context<br>2024-05-17<br><a href="plaintext/">plaintext logs</a></div>
<div class="nav">
<a href="2024-05-16" class="nav-link"><span>prev</span></a>
<span style="float:right">next</span>
</div>
    <div class="all-rooms"><noscript>JavaScript is required to load the channel index, but you can go to <a href="../..">the static index</a> directly.</noscript></div>
<div class="footer"><a href="https://github.com/bakkot/matrix-archive-bot">source on github</a></div>
</div>
<div class="rhs">
<div class="rhs-header">
<span id="error" style="color: red; display:none">error</span>

<input type="text" id="query" size="25" placeholder="Search TC39 Async Context">
<a id="search-submit" class="button icon-link" title="Search">
  <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg>
</a>
</div>

<div class="log"><table id="log-table"><tbody id="log-tbody">

  <tr class="msg" id="L0"><td class="ts-cell"><a class="ts" href="#L0" alt="Thu May 16 2024 17:53:40 GMT-0700 (Pacific Daylight Time)">00:53</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Now, the fact that this wrapping would make a handful of existing use cases impossible is clearly a problem, and points to why we need some way to access the causing context, rather than just the registration context.  This could be as simple as a AsyncContext.Snapshot.noWrap that would prevent any automatic wrapping (or other implicit snapshot restoration that the VM would do via abstract operations), though it's not clear to me whether this would (or should!) provide the non-restoring async/await behavior (vs. just affecting what context callbacks are entered with the first time).</blockquote></mx-reply>How would noWrap work?</td></tr>
  <tr class="msg" id="L1"><td class="ts-cell"><a class="ts" href="#L1" alt="Thu May 16 2024 17:54:52 GMT-0700 (Pacific Daylight Time)">00:54</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">Like it cancels out a wrap that happens around it?</td></tr>
  <tr class="msg" id="L2"><td class="ts-cell"><a class="ts" href="#L2" alt="Thu May 16 2024 18:42:18 GMT-0700 (Pacific Daylight Time)">01:42</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@stephenhicks:matrix.org">Steve Hicks</span>&gt;</div></td><td class="msg-cell">yes, something like that - aside from being able to observe callingContext, wrapping is idempotent, so nowrap would maybe cancel <em>all</em> wraps that happen around it?  not quite clear - it's just one option.</td></tr>
  <tr class="msg" id="L3"><td class="ts-cell"><a class="ts" href="#L3" alt="Thu May 16 2024 19:26:13 GMT-0700 (Pacific Daylight Time)">02:26</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">It feels kinda vaguely non-compositional to cancel out wrap; maybe better to avoid wrapping in the first place. Weren’t we discussing options for that? (But then you run into the “no null context” issue also)</td></tr>
  <tr class="msg" id="L4"><td class="ts-cell"><a class="ts" href="#L4" alt="Thu May 16 2024 19:27:10 GMT-0700 (Pacific Daylight Time)">02:27</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">I am not being very clear with noncompositional… I guess I mean, if you replace f with n =&gt; f(n), then noWrap stops working</td></tr>
  <tr class="msg" id="L5"><td class="ts-cell"><a class="ts" href="#L5" alt="Thu May 16 2024 19:27:41 GMT-0700 (Pacific Daylight Time)">02:27</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@stephenhicks:matrix.org">Steve Hicks</span>&gt;</div></td><td class="msg-cell">not necessarily - it depends on how it's implemented.</td></tr>
  <tr class="msg" id="L6"><td class="ts-cell"><a class="ts" href="#L6" alt="Thu May 16 2024 19:29:33 GMT-0700 (Pacific Daylight Time)">02:29</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@stephenhicks:matrix.org">Steve Hicks</span>&gt;</div></td><td class="msg-cell">If the implementation is to explicitly restore the previous snapshot, then it's robust to <code>n =&gt; f(n)</code>, though it makes <code>wrap</code> no longer idempotent (i.e. <code>wrap(wrap(unwrap(f))) == wrap(f)</code>) and there's potentially weirdness around <code>unwrap(unwrap(f)) == f</code> or some such...</td></tr>
  <tr class="msg" id="L7"><td class="ts-cell"><a class="ts" href="#L7" alt="Thu May 16 2024 19:30:11 GMT-0700 (Pacific Daylight Time)">02:30</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@stephenhicks:matrix.org">Steve Hicks</span>&gt;</div></td><td class="msg-cell">or if it popped off a stack instead of just swapping in the previous then it really would undo one layer for each</td></tr>
  <tr class="msg" id="L8"><td class="ts-cell"><a class="ts" href="#L8" alt="Thu May 16 2024 19:30:56 GMT-0700 (Pacific Daylight Time)">02:30</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@stephenhicks:matrix.org">Steve Hicks</span>&gt;</div></td><td class="msg-cell">but it would only work from the <em>inside</em> - <code>unwrap(wrap(f)) == wrap(f)</code>, which is surprising</td></tr>
  <tr class="msg" id="L9"><td class="ts-cell"><a class="ts" href="#L9" alt="Thu May 16 2024 19:32:42 GMT-0700 (Pacific Daylight Time)">02:32</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@stephenhicks:matrix.org">Steve Hicks</span>&gt;</div></td><td class="msg-cell">I don't love those properties... but I think any observability of <code>callingContext</code> probably breaks idempotency of <code>wrap</code>, so maybe there's no way to keep that one?</td></tr>
  <tr class="msg" id="L10"><td class="ts-cell"><a class="ts" href="#L10" alt="Fri May 17 2024 01:07:44 GMT-0700 (Pacific Daylight Time)">08:07</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">Huh, how would it figure out the previous one at runtime? Currently you can just use a single global variable for the current snapshot.</td></tr>
  <tr class="msg" id="L11"><td class="ts-cell"><a class="ts" href="#L11" alt="Fri May 17 2024 01:36:07 GMT-0700 (Pacific Daylight Time)">08:36</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Whould you mind expanding on the distinguishing of child-of and follow-from? All promise resolutions are scheduled asynchronously, it seems to me that in this case "child-of" would be meaning-less in promise's case</blockquote></mx-reply><p>The resolution is async, but we create a span around the thing that <em>created</em> the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.</p>
<pre><code class="language-js">async function foo() {
  console.log('1')
  await Promise.resolve()
  console.log('3')
}
foo()
console.log('2')
</code></pre>
</td></tr>
  <tr class="msg" id="L12"><td class="ts-cell"><a class="ts" href="#L12" alt="Fri May 17 2024 01:42:10 GMT-0700 (Pacific Daylight Time)">08:42</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">Do OTel implementations in any other language with async/await make this distinction properly? If so it would be great to be able to refer to their implementation strategies.</td></tr>
  <tr class="msg" id="L13"><td class="ts-cell"><a class="ts" href="#L13" alt="Fri May 17 2024 01:42:41 GMT-0700 (Pacific Daylight Time)">08:42</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> where can I read more about that pile of hacks? (maybe you already wrote about it somewhere?)</blockquote></mx-reply>There's not really any writing on it presently, but basically because we don't flow into promise continuations we need to keep an object at the top-level of the request which we push spans into and basically <em>guess</em> what the parent is because, unlike with callbacks, the parent does not flow into the continuation. This means we have to look at what has been pushed into that list in the past and try to guess what the parent would be. Sometimes it's simply the last span in the list, but not always, so we need to do some additional analysis to figure out what was the last span which <em>could</em> be a realistic parent, which requires we also hold a bunch of the span metadata. Holding all this metadata is expensive given that we could have hundreds of thousands of concurrent spans. What we <em>want</em> is for the <em>correct</em> context to just be able to flow through the resolve path so we only need to store the IDs and can entirely eliminate that big bag of data which lives for the whole life of the request.</td></tr>
  <tr class="msg" id="L14"><td class="ts-cell"><a class="ts" href="#L14" alt="Fri May 17 2024 01:45:51 GMT-0700 (Pacific Daylight Time)">08:45</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> I hope it's not necessary either, but I can see how Ste{v,ph}en's points argue for it to be necessary. (I'm having trouble understanding what you're supposed to do with currentContext besides reconstruct this array)</blockquote></mx-reply>We don't need the list of all context historically, only a way at any given snapshot restore to elect to keep the prior value which already flowed in and additionally to be able to have a way to configure stores to capture resolve time of promises rather than register time.</td></tr>
  <tr class="msg" id="L15"><td class="ts-cell"><a class="ts" href="#L15" alt="Fri May 17 2024 01:51:57 GMT-0700 (Pacific Daylight Time)">08:51</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> The "don't bind around await" case feels a lot like "just use a global variable" to me.  To my mind, automatic binding around await is basically one of the main purposes of AC, so if you're not doing that, what are you gaining?  Is it just the question of restoring context after awaiting an already-done promise?  Assuming all awaited promises were pending when the await kicked off, then a simple model seems like doing nothing would "just work" since the continuation would follow immediately afterwards, so the global value would be correct.  Of course this breaks down when the await doesn't actually have to wait - and maybe also when two independent jobs are running interleaved?<br><br>So a global variable is obviously a bit too naive to work, but where I'm struggling is to understand how an AC.Variable with mutable state falls short?  That seems like it would address the issue of interleaved independent tasks, at least, and since (within the same task) you're presumably not clobbering the actual container variable, then that part shouldn't need to change after an await (and if it did, it could presumably be communicated back upstream).  ISTR Stephen mentioning performance concerns, but it's important to compare this against the performance cost of additional overhead needed to maintain a more complex graph, or more different kinds of state that need extra work to fork/join.</blockquote></mx-reply>It's not that we need <em>no</em> binds for async/await, it's that we want it to bind at the resolve point of the promise being awaited rather than at registration time directly at the point the await occurs. This would mean context would flow <em>through</em> promises rather than <em>around</em> them. It would <em>also</em> mean the restore which occurs <em>after</em> the await resumes would be that resolve point value rather than what the value was before the await occurred.</td></tr>
  <tr class="msg" id="L16"><td class="ts-cell"><a class="ts" href="#L16" alt="Fri May 17 2024 01:53:57 GMT-0700 (Pacific Daylight Time)">08:53</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> To Stephen's point about rewriting code from callbacks to promise/await, I agree that they should be consistent, but I'd argue that it's a transient issue.  Callback-based code should be updated to wrap the callbacks so that the behavior is the same.  I understand that the fact that ALS has existed for a while with the other behavior makes this a bit of a problem...  Ideally the standard Node APIs would have all been updated to wrap/bind when ALS first came out, before anyone began depending on the non-wrapping behavior.</blockquote></mx-reply>It's <em>intentional</em> that it behaves that way with callbacks. That's how context management is <em>supposed</em> to work as it's not useful for most cases if it doesn't flow into continuations. That's literally the <em>point</em> of the "async" in AsyncLocalStorage.</td></tr>
  <tr class="msg" id="L17"><td class="ts-cell"><a class="ts" href="#L17" alt="Fri May 17 2024 01:54:45 GMT-0700 (Pacific Daylight Time)">08:54</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">I'm not even sure what use there <em>would</em> be for the other way with callbacks. I don't see any use case for that flow. 🤔</td></tr>
  <tr class="msg" id="L18"><td class="ts-cell"><a class="ts" href="#L18" alt="Fri May 17 2024 01:58:05 GMT-0700 (Pacific Daylight Time)">08:58</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Do OTel implementations in any other language with async/await make this distinction properly? If so it would be great to be able to refer to their implementation strategies.</blockquote></mx-reply>Yes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's <em>able</em> to do this externally. With Node.js there is no solution.</td></tr>
  <tr class="msg" id="L19"><td class="ts-cell"><a class="ts" href="#L19" alt="Fri May 17 2024 01:58:47 GMT-0700 (Pacific Daylight Time)">08:58</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Yes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's <em>able</em> to do this externally. With Node.js there is no solution.</blockquote></mx-reply>Other languages work the way you are proposing we adopt for JS? That is great to know. Can you suggest a concrete one for us to look into?</td></tr>
  <tr class="msg" id="L20"><td class="ts-cell"><a class="ts" href="#L20" alt="Fri May 17 2024 01:59:25 GMT-0700 (Pacific Daylight Time)">08:59</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">Bytecode manipulation isn’t magic; I would be surprised if we can’t do what’s achieved with it</td></tr>
  <tr class="msg" id="L21"><td class="ts-cell"><a class="ts" href="#L21" alt="Fri May 17 2024 02:00:02 GMT-0700 (Pacific Daylight Time)">09:00</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">Not sure. Like I said, most do this externally to the runtime itself so I'm unsure if any particular language is a good example of it.</td></tr>
  <tr class="msg" id="L22"><td class="ts-cell"><a class="ts" href="#L22" alt="Fri May 17 2024 02:02:12 GMT-0700 (Pacific Daylight Time)">09:02</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-7" title="@legendecas:matrix.org">Chengzhong Wu</span>&gt;</div></td><td class="msg-cell"><pre><code>handleRequest((req, res) =&gt; {
  // ROOT SPAN0
  connection.query('SELECT 1 + 1 AS two') // SPAN1
    .then(a =&gt; {
      // PROPOSED CONTEXT: SPAN1.2
      // If the context.variable at this point is SPAN1.2, how do we determine
      // child-of or follow-from?
      // As proposed this should be a follow-from SPAN1.3 instead of SPAN2
      return connection.query('SELECT 2 + 2 AS four') // SPAN2
    })
    .then(b =&gt; {
      // PROPOSED CONTEXT: SPAN3.2
      res.writeHead(200, { 'Content-Type': 'text/plain' })
      res.end(a[0].two + b[0].four)
    })
})

function connectionQuery(query) {
  // Current Context: SPANx
  return makeFirstRequest() // SPANx.1
    .then(() =&gt; {
      makeSecondRequest() // SPANx.2
    })
}
</code></pre>
<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>
</td></tr>
  <tr class="msg" id="L23"><td class="ts-cell"><a class="ts" href="#L23" alt="Fri May 17 2024 02:02:25 GMT-0700 (Pacific Daylight Time)">09:02</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">That’s OK if it’s external, if it implements the right semantics I am still happy to have that as the reference point</td></tr>
  <tr class="msg" id="L24"><td class="ts-cell"><a class="ts" href="#L24" alt="Fri May 17 2024 02:02:32 GMT-0700 (Pacific Daylight Time)">09:02</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Bytecode manipulation isn’t magic; I would be surprised if we can’t do what’s achieved with it</blockquote></mx-reply>Much of the code we need to patch to do that in JS is not reachable at runtime. With bytecode you can manipulate everything, even private things.</td></tr>
  <tr class="msg" id="L25"><td class="ts-cell"><a class="ts" href="#L25" alt="Fri May 17 2024 02:03:33 GMT-0700 (Pacific Daylight Time)">09:03</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Much of the code we need to patch to do that in JS is not reachable at runtime. With bytecode you can manipulate everything, even private things.</blockquote></mx-reply>Sounds good, so can a language runtime, which is what we are talking about changing. It would help us to have a concrete reference point even if it is external/messy</td></tr>
  <tr class="msg" id="L26"><td class="ts-cell"><a class="ts" href="#L26" alt="Fri May 17 2024 02:04:41 GMT-0700 (Pacific Daylight Time)">09:04</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> <pre><code>handleRequest((req, res) =&gt; {
  // ROOT SPAN0
  connection.query('SELECT 1 + 1 AS two') // SPAN1
    .then(a =&gt; {
      // PROPOSED CONTEXT: SPAN1.2
      // If the context.variable at this point is SPAN1.2, how do we determine
      // child-of or follow-from?
      // As proposed this should be a follow-from SPAN1.3 instead of SPAN2
      return connection.query('SELECT 2 + 2 AS four') // SPAN2
    })
    .then(b =&gt; {
      // PROPOSED CONTEXT: SPAN3.2
      res.writeHead(200, { 'Content-Type': 'text/plain' })
      res.end(a[0].two + b[0].four)
    })
})

function connectionQuery(query) {
  // Current Context: SPANx
  return makeFirstRequest() // SPANx.1
    .then(() =&gt; {
      makeSecondRequest() // SPANx.2
    })
}
</code></pre>
<p>In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now</p>
</blockquote></mx-reply>What do you mean by <code>PROPOSED CONTEXT: SPAN1.2</code>? What I'm expecting is for the context there to be a continuation of <code>SPAN1</code>.</td></tr>

</tbody></table></div></div></div>
</body></html>