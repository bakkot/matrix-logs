2024-01-12
[21:10:34.0455] <Andreu Botella>
Hey, I was looking for some issue in the repo about why we made AsyncContext per-agent rather than per-realm, and I remember some SES concern playing into that, but there doesn't seem to be any issue on the AsyncContext repo about that

[21:10:45.0101] <Andreu Botella>
is that discussion logged somewhere?

[22:17:03.0970] <Chengzhong Wu>
https://github.com/tc39/notes/blob/main/meetings/2023-01/feb-01.md#:~:text=cross%2Drealm%20per%2Dagent

[22:18:20.0670] <Chengzhong Wu>
 * https://github.com/tc39/notes/blob/main/meetings/2023-01/feb-01.md#:~:text=inherently%20cross%2Drealm%2C%20and%20per%2Dagent.

[22:18:59.0418] <Chengzhong Wu>
 * https://github.com/tc39/notes/blob/main/meetings/2023-01/feb-01.md#conclusion

[22:19:18.0860] <Chengzhong Wu>
The conclusion was captured back in notes of 2023-01

[00:45:22.0722] <Mathieu Hofman>
My understanding is that, thanks to the transform into continuation passing style to explain why async context is not really introducing observable global mutable state, it also shows that the context info is shared any time a call is made. Since calls can happen cross realm, it means that when modeling async context as a global state, that has to be shared for the whole agent.

[00:50:32.0031] <Mathieu Hofman>
Looking at the notes, Mark actually was/is concerned about speccing AsyncContext in terms of global mutable state, but that's a general concern, and making it cross realm is even scarier. I suspect however that speccing it in terms of continuation passing would be too large of a change in the spec.

[09:30:05.0410] <littledan>
Maybe we can specify AsyncContext without global mutable state when anything else about JS execution is specified that way…

[10:44:36.0539] <Mathieu Hofman>
I'm confused. What is currently specified as global mutable state besides the symbol registry?

[10:51:35.0977] <littledan>
The execution context?

[10:52:05.0665] <littledan>
AsyncContext would attach to that

[10:53:07.0249] <littledan>
The important thing is that it is used in a structured way; the editorial point is unactionable unless we change a lot more stuff

[10:54:55.0317] <littledan>
we push things onto the execution context stack... that is a mutation


2024-01-18
[04:33:35.0036] <Andreu Botella>
I wonder if it makes sense to add a method to the C++ embedder API for `AsyncContext.Snapshot` to tell whether two objects represent the same underlying map

[04:40:44.0155] <Andreu Botella>
also to create an `AsyncContext.Snapshot` with an empty map (well, with the map being `undefined` in my V8 implementation)

[05:05:55.0485] <littledan>
Do you have use cases for those in mind?

[05:06:21.0053] <littledan>
For the latter, I really don’t want to expose that to JS, and I wonder why it would ever be valid to do 

[05:17:28.0973] <Andreu Botella>
not to JS, to embedders

[05:31:27.0120] <Andreu Botella>
because of reasons involving the architecture of Blink, task attribution is using a `std::unique_ptr<Scope>` as an RAII scope for the equivalent of `snapshot.run()`

[05:33:07.0221] <Andreu Botella>
it has to be an allocation because users of this scope can't depend on the actual C++ files calling into V8, so `Scope` there has to be an abstract class that is implemented elsewhere

[05:33:47.0715] <Andreu Botella>
you can save the allocation if you can be sure that the snapshot you'd be running is the same as the current one, and if there's nothing new to set task allocation-wise that wasn't there before

[05:34:21.0423] <Andreu Botella>
by returning a null `unique_ptr`

