2024-06-03
[15:16:28.0016] <Steve Hicks>
I was thinking a bit more about this.  In my diagrams, merge points generally have a solid line and a dashed line going into them.  The solid line represents the causal (or "flow") context, while the dashed like is what I'd call the lexical context.  For an `await`, flow context is "flow-through", while lexical context is "flow-around".  For a callback, flow context is "call-time", while lexical context is "registration-time".  The current proposed semantics are heavily tilted toward merging into the lexical context, while Stephen is advocating for merging into the flow context.  Is there _any way_ we can put these two contexts on more equal footing?  I think the one obvious option to me would be to define two types of async variables: `LexicalVariable` and `FlowVariable`, and at any given merge point, we copy the flow context from the flow side and the lexical context from the lexical side.  I'm not seeing any other way to unite these two defaults... does anyone else?

[15:23:48.0466] <littledan>
Here in A Coruña at the Igalia Web Engines hackfest, we got a chance to talk with Anne van Kesteren, who continues to have the (personal, not necessarily Apple) position that we should consistently run all callbacks at registration time, unless we can explain a very strong reason, because this will be the most regular guarantee for developers and simplest to specify and implement. Flow variables require a lot of bookkeeping at a lot of points scattered through the specs, and it is unclear how js devs should even build a mental model around them, it could be argued

[15:25:05.0704] <littledan>
> <@stephenhicks:matrix.org> I was thinking a bit more about this.  In my diagrams, merge points generally have a solid line and a dashed line going into them.  The solid line represents the causal (or "flow") context, while the dashed like is what I'd call the lexical context.  For an `await`, flow context is "flow-through", while lexical context is "flow-around".  For a callback, flow context is "call-time", while lexical context is "registration-time".  The current proposed semantics are heavily tilted toward merging into the lexical context, while Stephen is advocating for merging into the flow context.  Is there _any way_ we can put these two contexts on more equal footing?  I think the one obvious option to me would be to define two types of async variables: `LexicalVariable` and `FlowVariable`, and at any given merge point, we copy the flow context from the flow side and the lexical context from the lexical side.  I'm not seeing any other way to unite these two defaults... does anyone else?

Yeah I don’t have a better solution. For flow advocates: how bad would it be if we called LexicalVariable “Variable” and did FlowVariable in a follow-on proposal?

[15:27:10.0433] <littledan>
Anne was also not 100% on the motivation for the whole feature, so that may point to room for improvement in documentation 

[15:37:42.0732] <Chengzhong Wu>
Yeah, agreed that two type of variables could be a solution. Have you talked about  `run(value, fn)` vs `set(value)` styles? Would it be too conservative to have strong scope guarantee in Web API designs?

[15:38:07.0078] <Chengzhong Wu>
 * Yeah, agreed that two type of variables could be a solution. Did you have a chance talking about  `run(value, fn)` vs `set(value)` styles? Would it be too conservative to have strong scope guarantee in Web API designs?


2024-06-04
[18:50:02.0565] <Steve Hicks>
> <@littledan:matrix.org> Yeah I don’t have a better solution. For flow advocates: how bad would it be if we called LexicalVariable “Variable” and did FlowVariable in a follow-on proposal?

Would we expose any way to access the flow context from a callback?  It may not be particularly relevant from most DOM APIs, but `Promise`'s resolution context is quite relevant, and I worry about userland APIs from a consistency standpoint (either they'll use `Snapshot.wrap` for consistency's sake with all the builtins, or else they cause a lot of confusion).  And many users of userland APIs (signals, etc) _will_ want to expose the flow context.  If all we have is lexical context for everything, it's not particularly useful for us, nor for APM - I'm not sure who the user would be at that point.

[18:50:34.0971] <Steve Hicks>
> <@littledan:matrix.org> Yeah I don’t have a better solution. For flow advocates: how bad would it be if we called LexicalVariable “Variable” and did FlowVariable in a follow-on proposal?

 * Would we expose any way to access the flow context from a callback?  It may not be particularly relevant from most DOM APIs, but `Promise`'s resolution context is quite relevant, and I worry about userland APIs from a consistency standpoint (either they'll use `Snapshot.wrap` for consistency's sake with all the builtins, or else they cause a lot of confusion).  And many users of userland APIs (signals, etc) _will_ want access to the flow context.  If all we have is lexical context for everything, it's not particularly useful for us, nor for APM - I'm not sure who the user would be at that point.

[23:55:58.0161] <littledan>
> <@stephenhicks:matrix.org> Would we expose any way to access the flow context from a callback?  It may not be particularly relevant from most DOM APIs, but `Promise`'s resolution context is quite relevant, and I worry about userland APIs from a consistency standpoint (either they'll use `Snapshot.wrap` for consistency's sake with all the builtins, or else they cause a lot of confusion).  And many users of userland APIs (signals, etc) _will_ want access to the flow context.  If all we have is lexical context for everything, it's not particularly useful for us, nor for APM - I'm not sure who the user would be at that point.

Yes, I think (at a minimum) we should do this for a number of Events, make an extra property which is an AsyncContext.Snapshot taken from when it was resolved. So this would be for "lexical" variables as well.

[23:56:25.0870] <littledan>
then APMs can patch all entry points to set event listeners to watch for a particular variable on that other snapshot and do something with it

[00:22:27.0196] <littledan>
> <@legendecas:matrix.org> Yeah, agreed that two type of variables could be a solution. Did you have a chance talking about  `run(value, fn)` vs `set(value)` styles? Would it be too conservative to have strong scope guarantee in Web API designs?

We didn’t discuss this; I will mention it. But I don’t know if I can represent the arguments for set() well, and I am pretty sure this all would not form much of an interesting argument in favor of flow-through.

[10:16:10.0775] <Steve Hicks>
> <@littledan:matrix.org> Yes, I think (at a minimum) we should do this for a number of Events, make an extra property which is an AsyncContext.Snapshot taken from when it was resolved. So this would be for "lexical" variables as well.

I really dislike finding heterogeneous places to put the flow snapshot for each different system.  What about promises?  Assuming `await` and `Promise.then` are both lexically bound (which I mostly agree with - the former somewhat moreso than the latter, but overall I think it makes sense), there's no way to get at the promise's resolution context, and that's very relevant for understanding "follows from".  Would we expose some sort of static function to grab it?  `Promise.resolutionSnapshot(promise)`?  `Snapshot.fromPromise(promise)`?  Could something like that work more generally for other cases like events?

[10:20:41.0848] <Steve Hicks>
Assuming promises store their resolution context somewhere, is there a reasonable way to preserve it when operating on the promise?  I'm imagining wanting to wrap a function `fn` such that `Snapshot.from(p1.then(fn)) === Snapshot.from(p1)` and `Snapshot.from(p2.then(fn)) === Snapshot.from(p2)`... but without having access to the promise itself (just the resolved value), I don't see any way to write such a function.

[10:21:50.0016] <Steve Hicks>
This seems to still argue for something more general, like `Snapshot.cause` or something

[10:22:05.0523] <Steve Hicks>
 * This seems to still argue for something more general, like a nullary `Snapshot.cause()` or something

[10:22:49.0392] <Steve Hicks>
(which then sends us back down the rabbit-hole of whether this is a stack of contexts or just a back-and-forth previous context, etc)

[10:27:40.0887] <Steve Hicks>
Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding `wrap()` calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as Stephen Belanger points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked.

[10:27:57.0528] <Steve Hicks>
 * Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding `wrap()` calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as Stephen Belanger points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked by intermediate calls.

[10:28:08.0516] <Steve Hicks>
 * Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding `wrap()` calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as Stephen Belanger points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked by intermediate subtask calls.

[14:16:19.0031] <littledan>
I suggest we come up with a common name to use for the instance method/getter where the originating context is

[14:18:46.0533] <littledan>
My preference is that promises, in particular, would *not* maintain this information, at least at first. We could consider adding it later, but it might be more burden to implement than its value

[14:19:24.0365] <littledan>
There are a few cases where it is very important to present this information, eg unhandled rejections

[14:19:54.0371] <littledan>
> <@stephenhicks:matrix.org> Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding `wrap()` calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as Stephen Belanger points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked by intermediate subtask calls.

Yes, it is important to analyze this. How should we do so?

[14:21:07.0020] <Steve Hicks>
Right, so we already need to keep track of resolution context for rejected promises - do you anticipate it's much harder to keep for all promises?

[14:23:56.0067] <Steve Hicks>
I don't know how far a common name will get us.  It only makes sense when you've got an object to look it up on.  What about mutation observers?  Its callback is passed an array and the observer itself, neither of which has a convenient place to hang a flow snapshot.

