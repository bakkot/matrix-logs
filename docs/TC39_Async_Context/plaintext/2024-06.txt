2024-06-03
[15:16:28.0016] <Steve Hicks>
I was thinking a bit more about this.  In my diagrams, merge points generally have a solid line and a dashed line going into them.  The solid line represents the causal (or "flow") context, while the dashed like is what I'd call the lexical context.  For an `await`, flow context is "flow-through", while lexical context is "flow-around".  For a callback, flow context is "call-time", while lexical context is "registration-time".  The current proposed semantics are heavily tilted toward merging into the lexical context, while Stephen is advocating for merging into the flow context.  Is there _any way_ we can put these two contexts on more equal footing?  I think the one obvious option to me would be to define two types of async variables: `LexicalVariable` and `FlowVariable`, and at any given merge point, we copy the flow context from the flow side and the lexical context from the lexical side.  I'm not seeing any other way to unite these two defaults... does anyone else?

[15:23:48.0466] <littledan>
Here in A Coruña at the Igalia Web Engines hackfest, we got a chance to talk with Anne van Kesteren, who continues to have the (personal, not necessarily Apple) position that we should consistently run all callbacks at registration time, unless we can explain a very strong reason, because this will be the most regular guarantee for developers and simplest to specify and implement. Flow variables require a lot of bookkeeping at a lot of points scattered through the specs, and it is unclear how js devs should even build a mental model around them, it could be argued

[15:25:05.0704] <littledan>
> <@stephenhicks:matrix.org> I was thinking a bit more about this.  In my diagrams, merge points generally have a solid line and a dashed line going into them.  The solid line represents the causal (or "flow") context, while the dashed like is what I'd call the lexical context.  For an `await`, flow context is "flow-through", while lexical context is "flow-around".  For a callback, flow context is "call-time", while lexical context is "registration-time".  The current proposed semantics are heavily tilted toward merging into the lexical context, while Stephen is advocating for merging into the flow context.  Is there _any way_ we can put these two contexts on more equal footing?  I think the one obvious option to me would be to define two types of async variables: `LexicalVariable` and `FlowVariable`, and at any given merge point, we copy the flow context from the flow side and the lexical context from the lexical side.  I'm not seeing any other way to unite these two defaults... does anyone else?

Yeah I don’t have a better solution. For flow advocates: how bad would it be if we called LexicalVariable “Variable” and did FlowVariable in a follow-on proposal?

[15:27:10.0433] <littledan>
Anne was also not 100% on the motivation for the whole feature, so that may point to room for improvement in documentation 

[15:37:42.0732] <Chengzhong Wu>
Yeah, agreed that two type of variables could be a solution. Have you talked about  `run(value, fn)` vs `set(value)` styles? Would it be too conservative to have strong scope guarantee in Web API designs?

[15:38:07.0078] <Chengzhong Wu>
 * Yeah, agreed that two type of variables could be a solution. Did you have a chance talking about  `run(value, fn)` vs `set(value)` styles? Would it be too conservative to have strong scope guarantee in Web API designs?


2024-06-04
[18:50:02.0565] <Steve Hicks>
> <@littledan:matrix.org> Yeah I don’t have a better solution. For flow advocates: how bad would it be if we called LexicalVariable “Variable” and did FlowVariable in a follow-on proposal?

Would we expose any way to access the flow context from a callback?  It may not be particularly relevant from most DOM APIs, but `Promise`'s resolution context is quite relevant, and I worry about userland APIs from a consistency standpoint (either they'll use `Snapshot.wrap` for consistency's sake with all the builtins, or else they cause a lot of confusion).  And many users of userland APIs (signals, etc) _will_ want to expose the flow context.  If all we have is lexical context for everything, it's not particularly useful for us, nor for APM - I'm not sure who the user would be at that point.

[18:50:34.0971] <Steve Hicks>
> <@littledan:matrix.org> Yeah I don’t have a better solution. For flow advocates: how bad would it be if we called LexicalVariable “Variable” and did FlowVariable in a follow-on proposal?

 * Would we expose any way to access the flow context from a callback?  It may not be particularly relevant from most DOM APIs, but `Promise`'s resolution context is quite relevant, and I worry about userland APIs from a consistency standpoint (either they'll use `Snapshot.wrap` for consistency's sake with all the builtins, or else they cause a lot of confusion).  And many users of userland APIs (signals, etc) _will_ want access to the flow context.  If all we have is lexical context for everything, it's not particularly useful for us, nor for APM - I'm not sure who the user would be at that point.

[23:55:58.0161] <littledan>
> <@stephenhicks:matrix.org> Would we expose any way to access the flow context from a callback?  It may not be particularly relevant from most DOM APIs, but `Promise`'s resolution context is quite relevant, and I worry about userland APIs from a consistency standpoint (either they'll use `Snapshot.wrap` for consistency's sake with all the builtins, or else they cause a lot of confusion).  And many users of userland APIs (signals, etc) _will_ want access to the flow context.  If all we have is lexical context for everything, it's not particularly useful for us, nor for APM - I'm not sure who the user would be at that point.

Yes, I think (at a minimum) we should do this for a number of Events, make an extra property which is an AsyncContext.Snapshot taken from when it was resolved. So this would be for "lexical" variables as well.

[23:56:25.0870] <littledan>
then APMs can patch all entry points to set event listeners to watch for a particular variable on that other snapshot and do something with it

[00:22:27.0196] <littledan>
> <@legendecas:matrix.org> Yeah, agreed that two type of variables could be a solution. Did you have a chance talking about  `run(value, fn)` vs `set(value)` styles? Would it be too conservative to have strong scope guarantee in Web API designs?

We didn’t discuss this; I will mention it. But I don’t know if I can represent the arguments for set() well, and I am pretty sure this all would not form much of an interesting argument in favor of flow-through.

[10:16:10.0775] <Steve Hicks>
> <@littledan:matrix.org> Yes, I think (at a minimum) we should do this for a number of Events, make an extra property which is an AsyncContext.Snapshot taken from when it was resolved. So this would be for "lexical" variables as well.

I really dislike finding heterogeneous places to put the flow snapshot for each different system.  What about promises?  Assuming `await` and `Promise.then` are both lexically bound (which I mostly agree with - the former somewhat moreso than the latter, but overall I think it makes sense), there's no way to get at the promise's resolution context, and that's very relevant for understanding "follows from".  Would we expose some sort of static function to grab it?  `Promise.resolutionSnapshot(promise)`?  `Snapshot.fromPromise(promise)`?  Could something like that work more generally for other cases like events?

[10:20:41.0848] <Steve Hicks>
Assuming promises store their resolution context somewhere, is there a reasonable way to preserve it when operating on the promise?  I'm imagining wanting to wrap a function `fn` such that `Snapshot.from(p1.then(fn)) === Snapshot.from(p1)` and `Snapshot.from(p2.then(fn)) === Snapshot.from(p2)`... but without having access to the promise itself (just the resolved value), I don't see any way to write such a function.

[10:21:50.0016] <Steve Hicks>
This seems to still argue for something more general, like `Snapshot.cause` or something

[10:22:05.0523] <Steve Hicks>
 * This seems to still argue for something more general, like a nullary `Snapshot.cause()` or something

[10:22:49.0392] <Steve Hicks>
(which then sends us back down the rabbit-hole of whether this is a stack of contexts or just a back-and-forth previous context, etc)

[10:27:40.0887] <Steve Hicks>
Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding `wrap()` calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as Stephen Belanger points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked.

[10:27:57.0528] <Steve Hicks>
 * Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding `wrap()` calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as Stephen Belanger points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked by intermediate calls.

[10:28:08.0516] <Steve Hicks>
 * Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding `wrap()` calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as Stephen Belanger points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked by intermediate subtask calls.

[14:16:19.0031] <littledan>
I suggest we come up with a common name to use for the instance method/getter where the originating context is

[14:18:46.0533] <littledan>
My preference is that promises, in particular, would *not* maintain this information, at least at first. We could consider adding it later, but it might be more burden to implement than its value

[14:19:24.0365] <littledan>
There are a few cases where it is very important to present this information, eg unhandled rejections

[14:19:54.0371] <littledan>
> <@stephenhicks:matrix.org> Finally, I do think it's worth seriously considering the likely real-world ramifications of the default-lexical decision in terms of what concrete code will be written in the 1-2 years after the standard lands.  Where will pepole be adding `wrap()` calls, and where will people be digging up causal snapshots, etc?  Would having rolled all that out cause undue problems in the future if we decided to make a FlowVariable, since now everybody is mucking with these global snapshots everywhere, which (as Stephen Belanger points out) is the thing you shouldn't be doing in order for the flow context to actually do the right thing and not get wrecked by intermediate subtask calls.

Yes, it is important to analyze this. How should we do so?

[14:21:07.0020] <Steve Hicks>
Right, so we already need to keep track of resolution context for rejected promises - do you anticipate it's much harder to keep for all promises?

[14:23:56.0067] <Steve Hicks>
I don't know how far a common name will get us.  It only makes sense when you've got an object to look it up on.  What about mutation observers?  Its callback is passed an array and the observer itself, neither of which has a convenient place to hang a flow snapshot.

[14:25:42.0630] <Steve Hicks>
The underlying concept of "what was the context before this callback was run?" is pretty general and has no specificity to events (though it's not quite the right concept for restoring the resolution context of promises...) - so it seems a bit unnatural to tie it to that.

[14:27:48.0707] <littledan>
> <@stephenhicks:matrix.org> I don't know how far a common name will get us.  It only makes sense when you've got an object to look it up on.  What about mutation observers?  Its callback is passed an array and the observer itself, neither of which has a convenient place to hang a flow snapshot.

Isn’t it an array of objects? Each of these objects could have the property

[14:29:12.0071] <Andreu Botella>
> <@stephenhicks:matrix.org> Right, so we already need to keep track of resolution context for rejected promises - do you anticipate it's much harder to keep for all promises?

the way this currently works in the spec and in V8 is that an embedder function is called *synchronously* when the unhandled rejection happens

[14:29:24.0155] <Andreu Botella>
and that function then enqueues a task on the event loop that fires the event

[14:29:32.0266] <Andreu Botella>
so it happens outside of the JS engine

[14:30:04.0402] <littledan>
> <@stephenhicks:matrix.org> Right, so we already need to keep track of resolution context for rejected promises - do you anticipate it's much harder to keep for all promises?

I would sort of assume that, for built-in methods, we would generally use the “registration-time” context for that. But then this makes me wonder if we should generally return to the Node.js ALS semantics where rejection is always reported to the allocation-time context…. Now I confused myself 

[14:30:53.0314] <littledan>
> <@abotella:igalia.com> the way this currently works in the spec and in V8 is that an embedder function is called *synchronously* when the unhandled rejection happens

How does this collect the right context? What if no JS is on the stack?

[14:31:45.0966] <Andreu Botella>
for a promise-returning web API, you mean?

[14:32:00.0878] <Andreu Botella>
the context would be set when rejecting the promise

[14:56:10.0938] <littledan>
> <@abotella:igalia.com> the context would be set when rejecting the promise

Sure but there might not be JS on the stack when rejecting the promise, so at some point earlier you need to save off the context

[16:05:30.0131] <Steve Hicks>
You lost me with the bit about allocation-time.  I think polyfilling the causal snapshots is going to be a nightmare, but I guess I can _maybe_ see an argument for exposing these different causal snapshots in different ways if they end up meaning different things.  That said, I know for sure that signals will want access to causal context and there's no event object there - we should consider what precedent this sets and what options would be open to that proposal to be consistent.


2024-06-05
[22:43:40.0317] <littledan>
Who is advocating for “in different ways”?

[22:45:01.0944] <littledan>
Oh I guess you mean, there are different base objects to look it up off of, and signals don’t have any base object at all (unlike the AsyncContext.currentContext API)

[22:47:07.0079] <littledan>
For Signals: is there any way we could take advantage of the fact that you’re trying to trace something which happens completely synchronously when reconstructing the “what access caused which computeds to be synchronously evaluated” relation (which I take it was the reason for the non-registration-time semantics)?

[09:46:08.0191] <Steve Hicks>
Yah, "in different ways" is an automatic result of piggybacking off of the Event object - it shifts the question down to the underlying scheduling API, since each such API will necessarily have a different shape and thus a different way to access the causal context.

[09:47:42.0802] <Steve Hicks>
Many/most/(all?) userland schedulers will be synchronous, so the casual context would generally be the immediately previous one.  That said, if one were to double-wrap a callback, then it wouldn't be quite as "immediate" anymore, and I assume we'd like `wrap` to really be idempotent.

[15:09:29.0037] <ljharb>
do you want me to cancel yalls meeting next week, since it's plenary week?

[15:25:30.0601] <littledan>
> <@ljharb:matrix.org> do you want me to cancel yalls meeting next week, since it's plenary week?

Yes, thanks, we were discussing in our previous meeting how this one would be cancelled 


2024-06-10
[22:09:14.0317] <littledan>
Can we land this PR? https://github.com/tc39/proposal-async-context/pull/87#pullrequestreview-2106646155

[22:33:56.0462] <Andreu Botella>
> <@littledan:matrix.org> Can we land this PR? https://github.com/tc39/proposal-async-context/pull/87#pullrequestreview-2106646155

I don't know if we decided in the end to have the meetings in the public calendar

[22:34:10.0188] <Andreu Botella>
if you go to the link in that PR, there are no AsyncContext meetings

[22:36:33.0776] <Andreu Botella>
I guess I haven't considered enough the context of module evaluations

[22:37:21.0005] <Andreu Botella>
I've mostly been looking at APIs in the web integration

[00:22:21.0821] <nicolo-ribaudo>
> <@abotella:igalia.com> I guess I haven't considered enough the context of module evaluations

Is there any option other than "the same as async functions"?

[01:01:57.0216] <Andreu Botella>
> <@nicolo-ribaudo:matrix.org> Is there any option other than "the same as async functions"?

I suspect not, but haven't looked at it enough

[01:06:45.0980] <Steve Hicks>
I've been researching past discussions and dug up this one (which Qard participated in many years ago): https://github.com/othiym23/node-continuation-local-storage/issues/64

Some interesting and relevant perspectives.

[02:20:57.0317] <littledan>
> <@abotella:igalia.com> if you go to the link in that PR, there are no AsyncContext meetings

OK, let’s land a version of this patch that omits the meetings but includes the other parts 

[02:21:17.0801] <littledan>
I think we decided to tell people, there are regular meetings at these times, join the chat to get the zoom link

[02:21:35.0867] <littledan>
So let’s make that be reflected in both the PR and calendar

[02:21:38.0528] <Chengzhong Wu>
yeah, the calendar item was not added yet. I'll move that part out

[02:23:15.0741] <littledan>
> <@abotella:igalia.com> I guess I haven't considered enough the context of module evaluations

You’re thinking about https://github.com/tc39/proposal-async-context/issues/93 ?

[02:31:06.0214] <Andreu Botella>
> <@littledan:matrix.org> You’re thinking about https://github.com/tc39/proposal-async-context/issues/93 ?

yeah

[02:33:13.0564] <littledan>
What do you think of my suggestion there, that we make modules always run in an “original” (empty) context associated with the realm? (And this should apply for import defer as well)

[10:14:42.0854] <Stephen Belanger>
> <@littledan:matrix.org> Yeah I don’t have a better solution. For flow advocates: how bad would it be if we called LexicalVariable “Variable” and did FlowVariable in a follow-on proposal?

I'm fine with through flow being a follow-on, so long as what lands _first_ is very clearly communicated as _not_ providing that flow type. I feel the naming should more clearly communicate the flow type as `AsyncContext.Variable` alone does not communicate how it flows _at all_.

