2023-03-08
[10:20:35.0419] <Justin Ridgewell>
We have spec text! https://tc39.es/proposal-async-context/

[10:21:55.0814] <Justin Ridgewell>
I think the only surprising change is the addition of `[[Construct]]` on wrapped callbacks:
```
const Foo = AsyncContext.wrap(class Foo {});

// The wrapper will invoke construct on the wrapped function
new Foo();
```


[10:22:15.0862] <Justin Ridgewell>
This comes from the behavior of `Function.p.bind`

[12:25:31.0724] <littledan>
yeah I am OK with including or omitting the [[Construct]] behavior

[12:42:18.0394] <littledan>
the spec would probably be clearer if we could use whatwg infra algorithms

[12:42:28.0516] <littledan>
(for the mapping)

[12:43:39.0074] <littledan>
we should probably think about exposing reusable algorithms (for web specs) for get and run, but this is an editorial thing

[12:44:08.0692] <littledan>
it might be nicer editorially if we avoided SameValueZero; SameValue or simply = is enough. (But the nicest would be to say that it's a mapping...)

[12:44:31.0584] <littledan>
anyway I don't see any bugs in the spec; looks good for Stage 2 to me

[12:48:11.0181] <Andreu Botella>
IIRC the `setTimeout` infrastructure in HTML jumps off-thread to sleep, and then queues a task on the event loop

[12:48:31.0000] <Andreu Botella>
a wrapped `setTimeout` would have to "send" a snapshot off-thread

[12:48:36.0678] <Andreu Botella>
is that fine, as long as the values are not read?

[12:49:05.0180] <littledan>
I'm not sure if it should be phrased like that

[12:49:23.0828] <littledan>
I hope that you can work with ms2ger and Yoav on a proposed wording here

[12:50:01.0165] <littledan>
I think queued tasks would often carry asynccontext snapshots with them, but that snapshot shouldn't ever logically leave the main thread

[12:50:35.0272] <Andreu Botella>
 * a `setTimeout` that wraps the callback would have to "send" a snapshot off-thread

[12:51:04.0549] <littledan>
in any case, you'll want to have clean abstract algorithms for creating an AsyncContext, and get and run, so that the embedding spec doesn't need to call the actual JS functions


2023-03-09
[11:49:40.0549] <littledan>
We really need to execute on improving the motivation section of the async context readme, especially for the web use cases. Here's a summary of use cases I have in mind:

- Prioritizing threads of control, along the lines of https://github.com/WICG/scheduling-apis , and inheriting these priorities across callbacks and async/await (both the built-in mechanism and JS-level mechanisms)
- Collecting performance information across logical asynchronous threads of control, including both timings and with OpenTelemetry. See this project which can only work with async/await if you use a custom transpiler: https://open-telemetry.github.io/opentelemetry-js/classes/_opentelemetry_context_zone_peer_dep.ZoneContextManager.html
- There's some other use case with React Cache but I don't fully understand it.
- We have other use cases within Bloomberg in the Terminal to track different logical "applications" which run in the same JS heap, but I'm not sure if anyone else runs into these issues. (We also want to make more use of OpenTelemetry)

[11:49:51.0437] <littledan>
Every time I talk with a web person about this proposal, they are confused for this exact reason

[11:50:22.0838] <littledan>
Can someone take the action to make a PR to the async context readme on this topic? If not, please let me know and I'll try to eventually do it (but might not have time before this meeting)

[11:51:31.0492] <littledan>
 * We really need to execute on improving the motivation section of the async context readme, especially for the web use cases. Here's a summary of use cases I have in mind:

- Prioritizing threads of control, along the lines of https://github.com/WICG/scheduling-apis , and inheriting these priorities across callbacks and async/await (both the built-in mechanism and JS-level mechanisms)
- Collecting performance information across logical asynchronous threads of control, including both timings and with OpenTelemetry. See this project which can only work with async/await if you use a custom transpiler: https://open-telemetry.github.io/opentelemetry-js/classes/\_opentelemetry\_context\_zone\_peer\_dep.ZoneContextManager.html
- Yoav's various use cases [as a consistent mechanism which works within browsers and fundamentally needs the same mechanics]
- There's some other use case with React Cache but I don't fully understand it.
- We have other use cases within Bloomberg in the Terminal to track different logical "applications" which run in the same JS heap, but I'm not sure if anyone else runs into these issues. (We also want to make more use of OpenTelemetry)

[11:51:45.0779] <littledan>
also: Are we putting AsyncContext on the agenda for this TC39 meeting? We need to decide by tomorrow and add it if so.

[11:52:55.0989] <Andreu Botella>
Chengzhong mentioned in the WinterCG meeting that the idea was to propose it for stage 2 for this TC39 plenary


[11:53:43.0367] <littledan>
Good, let's put it on the agenda then

[11:54:05.0972] <littledan>
it will need to have this web motivation better documented for this plenary

[11:54:49.0766] <littledan>
This will also be important to have written down significantly before the March 16th WebPerf WG call which will discuss AsyncContext

[11:56:51.0465] <Andreu Botella>
is there some link for the react use case?

[11:57:19.0461] <littledan>
(I only know of the description in Justin's slides... IMO the others are sufficient to start with)

[11:57:55.0101] <Andreu Botella>
ok, I'll make a PR for that

[11:58:16.0750] <littledan>
Thanks!

[13:31:16.0431] <Justin Ridgewell>
Whatâ€™s WebPerf WG?

[14:05:26.0961] <littledan>
https://www.w3.org/webperf/

[14:05:46.0221] <littledan>
I think a lot of the strongest use cases for AsyncContext in the web are around performance metrics, so we're going to discuss this there.

