2023-03-08
[10:20:35.0419] <Justin Ridgewell>
We have spec text! https://tc39.es/proposal-async-context/

[10:21:55.0814] <Justin Ridgewell>
I think the only surprising change is the addition of `[[Construct]]` on wrapped callbacks:
```
const Foo = AsyncContext.wrap(class Foo {});

// The wrapper will invoke construct on the wrapped function
new Foo();
```


[10:22:15.0862] <Justin Ridgewell>
This comes from the behavior of `Function.p.bind`

[12:25:31.0724] <littledan>
yeah I am OK with including or omitting the [[Construct]] behavior

[12:42:18.0394] <littledan>
the spec would probably be clearer if we could use whatwg infra algorithms

[12:42:28.0516] <littledan>
(for the mapping)

[12:43:39.0074] <littledan>
we should probably think about exposing reusable algorithms (for web specs) for get and run, but this is an editorial thing

[12:44:08.0692] <littledan>
it might be nicer editorially if we avoided SameValueZero; SameValue or simply = is enough. (But the nicest would be to say that it's a mapping...)

[12:44:31.0584] <littledan>
anyway I don't see any bugs in the spec; looks good for Stage 2 to me

[12:48:11.0181] <Andreu Botella>
IIRC the `setTimeout` infrastructure in HTML jumps off-thread to sleep, and then queues a task on the event loop

[12:48:31.0000] <Andreu Botella>
a wrapped `setTimeout` would have to "send" a snapshot off-thread

[12:48:36.0678] <Andreu Botella>
is that fine, as long as the values are not read?

[12:49:05.0180] <littledan>
I'm not sure if it should be phrased like that

[12:49:23.0828] <littledan>
I hope that you can work with ms2ger and Yoav on a proposed wording here

[12:50:01.0165] <littledan>
I think queued tasks would often carry asynccontext snapshots with them, but that snapshot shouldn't ever logically leave the main thread

[12:50:35.0272] <Andreu Botella>
 * a `setTimeout` that wraps the callback would have to "send" a snapshot off-thread

[12:51:04.0549] <littledan>
in any case, you'll want to have clean abstract algorithms for creating an AsyncContext, and get and run, so that the embedding spec doesn't need to call the actual JS functions


2023-03-09
[11:49:40.0549] <littledan>
We really need to execute on improving the motivation section of the async context readme, especially for the web use cases. Here's a summary of use cases I have in mind:

- Prioritizing threads of control, along the lines of https://github.com/WICG/scheduling-apis , and inheriting these priorities across callbacks and async/await (both the built-in mechanism and JS-level mechanisms)
- Collecting performance information across logical asynchronous threads of control, including both timings and with OpenTelemetry. See this project which can only work with async/await if you use a custom transpiler: https://open-telemetry.github.io/opentelemetry-js/classes/_opentelemetry_context_zone_peer_dep.ZoneContextManager.html
- There's some other use case with React Cache but I don't fully understand it.
- We have other use cases within Bloomberg in the Terminal to track different logical "applications" which run in the same JS heap, but I'm not sure if anyone else runs into these issues. (We also want to make more use of OpenTelemetry)

[11:49:51.0437] <littledan>
Every time I talk with a web person about this proposal, they are confused for this exact reason

[11:50:22.0838] <littledan>
Can someone take the action to make a PR to the async context readme on this topic? If not, please let me know and I'll try to eventually do it (but might not have time before this meeting)

[11:51:31.0492] <littledan>
 * We really need to execute on improving the motivation section of the async context readme, especially for the web use cases. Here's a summary of use cases I have in mind:

- Prioritizing threads of control, along the lines of https://github.com/WICG/scheduling-apis , and inheriting these priorities across callbacks and async/await (both the built-in mechanism and JS-level mechanisms)
- Collecting performance information across logical asynchronous threads of control, including both timings and with OpenTelemetry. See this project which can only work with async/await if you use a custom transpiler: https://open-telemetry.github.io/opentelemetry-js/classes/\_opentelemetry\_context\_zone\_peer\_dep.ZoneContextManager.html
- Yoav's various use cases [as a consistent mechanism which works within browsers and fundamentally needs the same mechanics]
- There's some other use case with React Cache but I don't fully understand it.
- We have other use cases within Bloomberg in the Terminal to track different logical "applications" which run in the same JS heap, but I'm not sure if anyone else runs into these issues. (We also want to make more use of OpenTelemetry)

[11:51:45.0779] <littledan>
also: Are we putting AsyncContext on the agenda for this TC39 meeting? We need to decide by tomorrow and add it if so.

[11:52:55.0989] <Andreu Botella>
Chengzhong mentioned in the WinterCG meeting that the idea was to propose it for stage 2 for this TC39 plenary


[11:53:43.0367] <littledan>
Good, let's put it on the agenda then

[11:54:05.0972] <littledan>
it will need to have this web motivation better documented for this plenary

[11:54:49.0766] <littledan>
This will also be important to have written down significantly before the March 16th WebPerf WG call which will discuss AsyncContext

[11:56:51.0465] <Andreu Botella>
is there some link for the react use case?

[11:57:19.0461] <littledan>
(I only know of the description in Justin's slides... IMO the others are sufficient to start with)

[11:57:55.0101] <Andreu Botella>
ok, I'll make a PR for that

[11:58:16.0750] <littledan>
Thanks!

[13:31:16.0431] <Justin Ridgewell>
What’s WebPerf WG?

[14:05:26.0961] <littledan>
https://www.w3.org/webperf/

[14:05:46.0221] <littledan>
I think a lot of the strongest use cases for AsyncContext in the web are around performance metrics, so we're going to discuss this there.

[15:08:00.0698] <Ben Newman (Apollo, @benjamn on GH)>
If we (non-champions) have additional use cases to suggest, should we open issues on the proposal repo? Or sketch them here?

[15:19:38.0577] <littledan>
Either an issue, here, or an explainer PR would all be good and helpful!

[15:19:47.0850] <littledan>
Whatever works for you


2023-03-10
[18:59:21.0489] <Chengzhong Wu>
> <@littledan:matrix.org> also: Are we putting AsyncContext on the agenda for this TC39 meeting? We need to decide by tomorrow and add it if so.

Thanks for the reminder! Agenda item submitted: https://github.com/tc39/agendas/pull/1334

[19:01:20.0946] <Chengzhong Wu>
> <@benjamn:matrix.org> If we (non-champions) have additional use cases to suggest, should we open issues on the proposal repo? Or sketch them here?

whatever works for you is welcomed!

[21:53:02.0070] <Justin Ridgewell>
Working on slides now

[23:26:27.0911] <Justin Ridgewell>
https://docs.google.com/presentation/d/1LLcZxYyuQ1DhBH1htvEFp95PkeYM5nLSrlQoOmWpYEI/edit#slide=id.p

[06:31:43.0567] <littledan>
Great, thanks for writing slides, Justin, these look really good! Some notes:
- IMPORTANT: right before Slide 2, insert a slide which quickly lists some use cases (including at least 2 client-side use cases, plus a third thing which is internal infrastructure within web standards [Yoav's thing]); hopefully this can also link to Andreu's more detailed description at the top of the README [The rest of these comments are nits, but the motivation is key.]
- In Slide 4, note explicitly that this is what Promise .then, setTimeout, etc would do. [Or: Consider consolidating slides 3 and 4 into something which just shows the interface, saving the pseudocode implementation for a bonus slide. I am undecided on whether we should do this]
- Write somewhere on the slides that we consider all of the questions raised to be things that we aim to resolve between Stage 2 and Stage 3. Emphasize this especially for the web platform integration and unhandled rejection context--these must be spelled out, and we plan to work with Yoav Weiss on this, who was already thinking in this direction for the previously mentioned internal use case.
- The constructor parameters idea is really superficial; should it really be the first slide? Maybe we should start with the important issues. [Also IMO the parameter order should be reversed but that's a comment I should make in the issue]
- The web platform doesn't have a lot of cases to consider because it's weird--this is just an inherent difficulty with AsyncContext wherever it's done. I think "case by case" might make it sound too bad--we'll have some organizing principles, we just don't have a proposal yet. The proposal here will be a precondition for Stage 3. (BTW: Avoid saying "a Stage $n question" because people use this term both to mean, a precondition to enter $n or something to discuss during $n)
- Focus on explaining next steps towards resolution when presenting each of these slides.
[More notes to come, have to go]

[08:24:06.0825] <Ben Newman (Apollo, @benjamn on GH)>
speaking of constructor parameters, I really like the `defaultValue` idea, though I suppose you could subclass `AsyncContext` to add functionality like that if you wanted it

[08:24:56.0847] <Andreu Botella>
could you? since you'd need to wrap all uses of the `AsyncContext` in a `run`, I think

[08:25:25.0719] <Andreu Botella>
oh, by overriding `get` I guess

[08:28:01.0561] <James M Snell>
I've also been asked about the possibility of setting up a construction-time default value but really don't think it's a good idea. I imagine that it would have the same basic effect as `asyncLocalStorage.enterWith(...)`, modifying the state of the current async context unless it is defined as "use this value as the default if the current storage for this is undefined"

[08:29:40.0661] <James M Snell>
if that's the semantic, then I can get on board with it, but if setting the value on the constructor actually modifies the async context, definitely not

[08:35:04.0504] <Andreu Botella>
I'm not familiar with the `AsyncLocalStorage` API, but I don't think I understand the difference between those two options

[08:35:10.0229] <Andreu Botella>
would it lead to any observable difference?

[08:35:39.0615] <Andreu Botella>
oh, is this about snapshot?

[08:35:56.0518] <Andreu Botella>
 * oh, is this about wrap?

[08:36:57.0377] <Justin Ridgewell>
The default value would only be returned if the mapping can’t be found in the global state

[08:37:17.0588] <Justin Ridgewell>
You wouldn’t be able to modify the context instance after the fact

[08:37:32.0511] <Justin Ridgewell>
So just modifying the get method’s last step

[08:38:49.0939] <James M Snell>
So I guess the key question then is what happens in the `AsyncLocalStorage.exit(...)` case, which Node.js defines as exiting the context scope but we've implemented as being equivalent to `als.run(undefined, () => {})`

[08:39:42.0930] <Justin Ridgewell>
Setting to an explicit undefined isn’t the same as no found mapping, so you’d get undefined

[08:40:07.0987] <James M Snell>
e.g. what would you expect in the following:

```
const als = new AsyncLocalStorage({ defaultValue: 'foo' });
als.run(123, () => {
  als.exit(() => {
    console.log(als.getStore()); // undefined or foo?
  }
})
```

[08:41:42.0488] <Justin Ridgewell>
Undefined, but it could really be either. AsyncContext doesn’t have an exit method, so this is really just Node

[08:42:24.0627] <Andreu Botella>
if this is only something that is a concern when implementing `AsyncLocalStorage` in terms of `AsyncContext`, I'm not sure that's enough to block this addition

[08:42:40.0310] <Andreu Botella>
it can surely be implemented anyway with an additional layer of indirection, right?

[08:43:10.0374] <James M Snell>
yeah, I think I just wanted to make sure that adding the default value does not actually modify the current storage context

[08:43:23.0307] <James M Snell>
if it's local to the `AsyncContext` instance itself, then +1

[09:24:32.0511] <Andreu Botella>
> <@abotella:igalia.com> is there some link for the react use case?

If we don't include the React or Bloomberg Terminal use cases, it seems like the only non-browser-internal use cases we have logging, timing and OpenTelemetry

[09:25:55.0755] <Andreu Botella>
the browser-internal use cases are relevant, of course, but it'd be great to have more use cases for having `AsyncContext` as an actual JS built-in

[10:00:40.0253] <Andreu Botella>
https://github.com/tc39/proposal-async-context/pull/30

[12:32:33.0693] <Ben Newman (Apollo, @benjamn on GH)>
here are a dozen use cases (some overlapping) I pulled from some old notes: https://gist.github.com/benjamn/f901cdc634a2d6e29542c32330208a87

[12:34:20.0254] <Ben Newman (Apollo, @benjamn on GH)>
I'd love some guidance on which of those sound more/less interesting, or need clarification/elaboration, so I can prioritize which ones I turn into issues

[13:06:31.0659] <Ben Newman (Apollo, @benjamn on GH)>
fwiw, the use case I care most about is https://gist.github.com/benjamn/f901cdc634a2d6e29542c32330208a87#file-topological_dependency_tracking-md

[13:17:10.0945] <Ben Newman (Apollo, @benjamn on GH)>
I will add much more explanatory text to any public issues


2023-03-13
[04:04:53.0654] <Andreu Botella>
Aren't the snapshot requirements on `HostMakeJobCallback` and `HostCallJobCallback` a bit too loose?

[04:05:15.0254] <Andreu Botella>
we don't want hosts to populate `[[AsyncContextSnapshot]]` with any snapshot whatsoever

[04:42:39.0205] <Andreu Botella>
I opened https://github.com/tc39/proposal-async-context/pull/31 to tighten those requirements

[04:52:20.0744] <littledan>
> <@abotella:igalia.com> I opened https://github.com/tc39/proposal-async-context/pull/31 to tighten those requirements

This PR LGTM but I think we should really refactor the PR to make abstract operations for run and get. Then, this PR would say, the AsyncContext must be created by run

[04:52:20.0994] <littledan>
(This implies a tighter host limitation, otherwise hosts could do anything run does)

[04:52:21.0164] <littledan>
I would also mention JS-implemented scheduling and, delete the last bullet point (access limitation) as I think a lot of people will be skeptical of it and it will throw off the discussion 

[04:52:21.0337] <littledan>
Sorry I didn’t review Andreu’s PR earlier. Let’s avoid the term “asynchronous callstack” as it is confusing and misleading (doesn’t make it clear that run has to be explicit). Instead, we are talking about the asynchronous flow of control.

[04:58:14.0203] <littledan>
Also would be good if the spec had a sort of introduction that linked to the readme

[04:58:35.0858] <littledan>
Maybe it should begin with the definition of the AsyncContext class and then go into how it works

[04:58:46.0877] <littledan>
(Again, apologies for the delayed review )

[05:14:22.0423] <Andreu Botella>
Huh, it looks like `Atomics.waitAsync`'s `HostResolveInAgent` leaves *everything* to the host, rather than using `HostMakeJobCallback` and `HostCallJobCallback`

[05:15:59.0429] <Andreu Botella>
should it be up to the host whether the callback gets wrapped there?

[05:17:38.0915] <littledan>
Let’s leave any proposed refactorings there for later (since we will learn what html wants as this proposal evolves, and no need to duplicate the debate)

[05:18:13.0158] <Andreu Botella>
sure

[05:18:55.0733] <littledan>
We can just note that this state of the spec might mean that TC39 might not hold us to a very meaningful layering

[05:18:56.0567] <Andreu Botella>
I just have been learning a bit about low-level concurrency and was trying to make sense of the atomics and memory model parts of the spec, and I noticed this slightly intersected with AsyncContext

[05:19:15.0834] <littledan>
Hopefully the layering can be expressed more by the structure of the spec and less by requirements 

[05:19:33.0690] <littledan>
Requirements end up being really unclear 

[05:25:13.0732] <littledan>
It is great that you noticed this connection btw, even if it is not actionable right now 

[07:10:55.0615] <Andreu Botella>
the way the spec is written right now, `AsyncContext.wrap` doesn't check if the argument is a function, but it does check if it's a constructor

[07:11:13.0528] <Andreu Botella>
in order to figure out whether to make the wrapped function a constructor or not

[07:11:26.0114] <Andreu Botella>
do we want this behavior?

[07:12:40.0654] <Andreu Botella>
also, `AsyncContextWrappedFunctionCreate` is defined to take a function object as its first argument, which isn't the case since `AsyncContext.wrap` doesn't check that

[07:13:02.0862] <littledan>
I guess we should eagerly check for callability, as this is what .bind does

[07:13:37.0555] <littledan>
btw if Function.prototype.bind doesn't work for class declarations (just old-style classes), does that mean its [[Construct]] behavior is thought of as "legacy"? In this case, should we not bother replicating it?

[08:55:41.0991] <rbuckton>
> <@littledan:matrix.org> btw if Function.prototype.bind doesn't work for class declarations (just old-style classes), does that mean its [[Construct]] behavior is thought of as "legacy"? In this case, should we not bother replicating it?

How does `Function.prototype.bind` not work? You can `new` the result, but you can't subclass it without fixing `.prototype` first:
```js
class C {}
let C1 = C.bind(null);
new C1() instanceof C; // true

class D extends C1 {} // TypeError: Class extends vlaue does not have a valid prototype property
C1.prototype; // undefined

C1.prototype = C.prototype;
class D1 extends C1 {} // ok
```

[08:55:56.0128] <rbuckton>
> <@littledan:matrix.org> btw if Function.prototype.bind doesn't work for class declarations (just old-style classes), does that mean its [[Construct]] behavior is thought of as "legacy"? In this case, should we not bother replicating it?

 * How does `Function.prototype.bind` not work? You can `new` the result, but you can't subclass it without fixing `.prototype` first:

```js
class C {}
let C1 = C.bind(null);
new C1() instanceof C; // true

class D extends C1 {} // TypeError: Class extends value does not have a valid prototype property
C1.prototype; // undefined

C1.prototype = C.prototype;
class D1 extends C1 {} // ok
```

[11:48:42.0905] <littledan>
oh well Function.prototype.bind throws on things which are not callable. I forgot about how classes are callable and they just throw.

[12:01:33.0943] <ljharb>
it's so baffling to me that the call/construct slots were basically made useless with things like that

[12:08:33.0557] <littledan>
yes, it makes me feel like it was a mistake to have a [[Construct]] hook in the first place

[12:19:33.0380] <ljharb>
i mean it'd be super useful to have both slots actually mean what they're called, but short of that having two is silly

[12:51:46.0829] <rbuckton>
I'd love for a "call constructor" to be valid in the language. It'll be possible to write a user-space `@Callable` decorator, I think, but you would have to replace the constructor with a regular `function` to do so. A native `@Callable` that does the same thing could just replace the `[[Construct]]` slot.

[12:54:49.0046] <rbuckton>
What's weird to me is that `class` has a `[[Call]]` that throws, but `() => {}` doesn't have a `[[Construct]]` at all (even one that throws).


2023-03-14
[19:59:16.0276] <Chengzhong Wu>
> <@abotella:igalia.com> the way the spec is written right now, `AsyncContext.wrap` doesn't check if the argument is a function, but it does check if it's a constructor

Fixing this in https://github.com/tc39/proposal-async-context/pull/32. Thanks for catching this!

[04:02:46.0454] <Andreu Botella>
Do we want values in the async context mapping to be ECMAScript language values?

[04:03:30.0390] <Andreu Botella>
I was thinking that maybe Yoav Weiss's task attribution could be defined in terms of storing an HTML spec-level value on the mapping for a symbol that's not associated to any `AsyncContext` instance

[04:03:38.0569] <Andreu Botella>
 * I was thinking that maybe Yoav Weiss's task attribution handling could be defined in terms of storing an HTML spec-level value on the mapping for a symbol that's not associated to any `AsyncContext` instance

[04:04:23.0216] <Andreu Botella>
`AsyncContext.prototype.get` could then assert that the gotten value is an ECMAScript language value

[04:07:01.0121] <Andreu Botella>
 * I was thinking that maybe Yoav Weiss's work on task attribution handling could be defined in terms of storing an HTML spec-level value on the mapping for a symbol that's not associated to any `AsyncContext` instance

[05:26:43.0282] <littledan>
yes, I think this would be a good direction for part of the refactoring patch which also exposes abstract operations for get, run, and the AsyncContext constructor.

