2024-05-01
[17:33:10.0504] <shaylew>
I think `Variable.wrap` ends up being a very different thing from delimited snapshots -- delimited snapshots operate on sections of the stack that contain (possibly) multiple variables, without the caller needing to know which variables are involved, whereas `Variable.wrap` is a convenience method for something you can already do without any kind of snapshots (global or delimited) as long as you know the variable(s) you want to operate on

[17:49:41.0850] <Justin Ridgewell>
Can you write example code of how delimited stacks would work?

[18:02:14.0630] <shaylew>
So, the system from the paper has "stack marks" as a different thing from "variables" because it already has the marks as part of delimited control... but in JS, without delimited continuations, I think you can just use a variable as a stack mark and get away with it. So it ends up looking something like...
```
Snapshot.partial<T>(v: Variable<T>): Snapshot
```
with the only difference being that when you capture a partial snapshot it captures all variables inside the most recent `v.run` (including `v`), and when you `run` a partial snapshot it instates that sequence of bindings on top of whatever variables are already in scope (perhaps shadowing some if they're in the current scope and also in the partial snapshot, but not clobbering anything that wasn't mentioned in the snapshot).

[18:06:16.0091] <shaylew>
You're probably going to ask "why would someone want this?" and one answer is: I went rifling through the literature for this because of Signals, which really seem like they want to capture and restore the _signal-related_ suffix of the context when running a memoized Computed... but where it doesn't seem to be helpful (and might cause problems) for this to capture or clobber the parts of the async context that were set up completely outside of any Computed

[18:15:46.0387] <shaylew>
There are a bunch of framework features in reactivity systems that all boil down to "save this when you create a Computed and restore it when you start rerunning it later on", and -- because Computeds are memoized -- it seems like it's basically always a bug for some sort of dynamic context (be it AsyncContext or manually managed with try/finally) to pass into a computed that's rerunning. When multiple callers all call `computed.get()` in some order, we want to be sure that the answer we saved into the computed didn't depend on which caller was first. If you have multiple frameworks doing their own extensions, they can save/restore their _own_ dynamic context using try/finally... but you run into problems if two frameworks have different extensions and don't know how to properly mask off each others'. Delimited snapshots nail this use case so well that I thought I'd try to float them and see if they seemed to help with any of the other ongoing AsyncContext mysteries

[18:32:21.0490] <shaylew>
(the signals framework features in question are stuff like... "ownership tree to implement hierarchical cleanup", "scoped error handlers to implement ErrorBoundary", "suspense context", "Context/Provider pattern for implicit parameters")

[15:59:10.0795] <Justin Ridgewell>
@stephenbelanger:matrix.org Please message me with your email so that I can add you to the meetings!

[15:59:43.0644] <Justin Ridgewell>
You were always meant to be invited, and I thought you were 😄


2024-05-02
[07:33:31.0454] <Yagiz Nizipli>
Hey Justin Ridgewell, can you invite me to the meeting as well? Sentry just recently joined TC39, and it will be finalized by the June meeting (I believe so) 

[09:51:07.0374] <Justin Ridgewell>
Sure, just gotta send me your email

[10:36:59.0582] <Justin Ridgewell>
@shaylew:matrix.org What's your GitHub handle?

[11:07:44.0459] <shaylew>
> <@jridgewell:matrix.org> @shaylew:matrix.org What's your GitHub handle?

also shaylew there

[13:22:32.0521] <littledan>
> <@yagiznizipli:matrix.org> Hey Justin Ridgewell, can you invite me to the meeting as well? Sentry just recently joined TC39, and it will be finalized by the June meeting (I believe so)

As a provisional member, Sentry can participate like all other members in Ecma groups (just not the theoretical case of voting, which never comes up). If you've received a communication from Ecma which led you to believe otherwise, please let me know so that we can make the right edits to reduce this confusion.

[13:23:46.0567] <Andreu Botella>
Also, regardless of that, I think we don't limit the AsyncContext meeting to delegates only – it's just that the invite is not public (not sure why though).

[13:24:33.0632] <Andreu Botella>
there was talk of having a public calendar, but I don't know what happened with that

[13:24:39.0760] <Andreu Botella>
 * there was talk of having a public TC39 calendar, but I don't know what happened with that

[13:31:39.0708] <littledan>
> <@abotella:igalia.com> there was talk of having a public TC39 calendar, but I don't know what happened with that

To make a meeting public, we just have to ask for it to be made public on the Reflector

[13:31:45.0625] <littledan>
do we all agree on that change?

[13:32:48.0840] <Justin Ridgewell>
Honestly I’d prefer a permissive invite-only structure

[13:32:58.0242] <Justin Ridgewell>
Everyone’s welcome, they just need to ask

[13:33:26.0502] <littledan>
we could put the existence and time of the meeting on the public calendar, and direct people to join this channel and ask for call-in instructions

[13:33:43.0683] <littledan>
Bryan English told me he spent 10 minutes trying to search for any evidence of the existence of this meeting and couldn't find ny

[13:33:47.0635] <littledan>
 * Bryan English told me he spent 10 minutes trying to search for any evidence of the existence of this meeting and couldn't find any

[13:34:48.0550] <Chengzhong Wu>
Can they access reflector?

[13:35:17.0419] <littledan>
no, since they're not Ecma members

[13:35:26.0443] <littledan>
but even for Ecma members, the Reflector often isn't discoverable enough

[13:36:48.0575] <Justin Ridgewell>
> <@littledan:matrix.org> we could put the existence and time of the meeting on the public calendar, and direct people to join this channel and ask for call-in instructions

Let’s do that

[13:39:06.0114] <Justin Ridgewell>
Or we could add it to the proposal README

[13:40:58.0587] <littledan>
> <@jridgewell:matrix.org> Or we could add it to the proposal README

why not both .gif

[13:41:12.0702] <Justin Ridgewell>
Both

[13:41:30.0260] <Chengzhong Wu>
A link to this matrix room in the readme (afaik this room is public) could be good. The agenda and notes are in the room description as well


2024-05-06
[04:54:07.0602] <Stephen Belanger>
Apologies for the delay in sharing these docs. I needed to prune some company-specific bits and navigate our convoluted process for making Google Docs actually public. 😅

The first doc is a bunch of explanation on the problems we have with existing attempts at context management and some possible solutions we're iterating on to solve these problems in a more flexible way. https://docs.google.com/document/d/1v8tMzV51Cuz32-60dhopoIMIxWfy_epOIRwoL5LmKVc/edit?usp=sharing

The second doc is partly relevant in that it describes an integration between the Diagnostics Channel concept and context management for the purpose of providing control to users to decide in which ways they want to propagate context for their specific store around particular points defined by library code as possibly interesting. https://docs.google.com/document/d/1DTZ2C5BKsoVRnU_ihyi93blF3cxXIbqqcIaSYurhBRk/edit?usp=sharing

I additionally have some slides from a recent internal talk I can also share which covers this overlap more briefly, and with specific examples. https://docs.google.com/presentation/d/1jYO45MudKGPOtir5hK0_wB7XS0D_ksLe4j5NvC8YfTc/edit?usp=sharing

[04:59:57.0810] <Stephen Belanger>
Keep in mind these are written from the perspective of defining a generalized context management system which could exist in _many_ languages, so it doesn't get too deep into JS specifics. It also has some spots I still would like to improve, but what is shared is a snapshot-in-time copy of what the _current_ state is, so I will have to replicate future changes into these docs as it is deemed relevant. The main one is that I'm trying to think of a better expression of the context management part of the Window Channel concept in Diagnostics Channel to put more of the logic and explanation of its use into the context management space. I'm not yet sure if that involves having some additional ContextWindow construct or something like that...still thinking on that one. 🤔

[05:00:15.0586] <Stephen Belanger>
 * Keep in mind these are written from the perspective of defining a generalized context management system which could exist in _many_ languages, so it doesn't get too deep into JS specifics. It also has some spots I still would like to improve, but what is shared is a snapshot-in-time copy of what the _current_ state is, so I will have to replicate future changes into these docs as it is deemed relevant.

The main one is that I'm trying to think of a better expression of the context management part of the Window Channel concept in Diagnostics Channel to put more of the logic and explanation of its use into the context management space. I'm not yet sure if that involves having some additional ContextWindow construct or something like that...still thinking on that one. 🤔

[05:00:37.0933] <Stephen Belanger>
 * Keep in mind these are written from the perspective of defining a generalized context management system which could exist in _many_ languages, so it doesn't get too deep into JS specifics. It also has some spots I still would like to improve, but what is shared is a snapshot-in-time copy of what the _current_ state is, so I will have to replicate future changes into these docs as it is deemed relevant.

The main change I'm considering is thinking of a better expression of the context management part of the Window Channel concept in Diagnostics Channel to put more of the logic and explanation of its use into the context management space. I'm not yet sure if that involves having some additional ContextWindow construct or something like that...still thinking on that one. 🤔

[05:04:45.0389] <Andreu Botella>
Hey, thanks for taking the time and trouble to make these docs public! I'll try to take a look, at least at the context management one, sometime this week

[05:50:26.0136] <Yagiz Nizipli>
> <@littledan:matrix.org> As a provisional member, Sentry can participate like all other members in Ecma groups (just not the theoretical case of voting, which never comes up). If you've received a communication from Ecma which led you to believe otherwise, please let me know so that we can make the right edits to reduce this confusion.

Afaik, we didn't receive anything from Ecma. 

[05:53:11.0155] <littledan>
> <@yagiznizipli:matrix.org> Afaik, we didn't receive anything from Ecma.

OK, good, so welcome!

[05:59:14.0480] <littledan>
Welcome Steven E !

[05:59:21.0668] <littledan>
we are now up to 3 Stevens

[06:00:07.0160] <Steven E>
Any of them ph's? 

[06:00:23.0075] <Stephen Belanger>
/me raises hand

[06:00:27.0042] <Steven E>
Us v's are a good group

[06:01:02.0205] <Stephen Belanger>
Welcome! 😄

[06:04:00.0962] <Steven Eubank (sentry.io)>
I can be less anonymous now! Happy to join

[10:59:19.0633] <Chris de Almeida>
Hi All.  Chengzhong reached out to me to add the AsyncContext meeting to the public calendar.

[10:59:22.0896] <Chris de Almeida>
https://github.com/tc39/Reflector/issues/491

[11:00:51.0243] <Chris de Almeida>
this is the issue to address that (though the invite list there is likely out-of-date. something to keep in mind, is that it is not a distinct meeting from the private calendar -- it is the same meeting shared across calendars (and this is an important feature)

the meeting is always invite-based by nature -- the question is whether the invite list can be public, with the specific concern being to not release individuals' email addresses publicly without their consent

as long as the meeting notes link can be public, then there is nothing in the meeting description that needs to change, as there is no information that _can't_ be public there

I suggest that that the invite list is made private initially, so that the meeting can be added to the public calendar immediately.  the question of the invite list being public has been the blocking issue for other meetings, and they continue to not get added to the public calendar because it goes unresolved. the invite list can be made public later, once everyone has approved (or removed) their email address for/from the invite

if there are no objections, I am going to proceed with this

[11:03:10.0970] <Andreu Botella>
I think the meeting in the private calendar has the Zoom link, and Justin Ridgewell mentioned he'd rather have the calendar entry be public but not the link, and to invite people as needed

[11:03:23.0738] <Andreu Botella>
I don't have an opinion on that though

[11:11:05.0788] <Chris de Almeida>
> <@abotella:igalia.com> I think the meeting in the private calendar has the Zoom link, and Justin Ridgewell mentioned he'd rather have the calendar entry be public but not the link, and to invite people as needed

hmm, this seems to defeat the purpose of having it on the public calendar

[11:34:10.0408] <Andreu Botella>
I'm looking at the web integration of the `error` event on `window` (which is fired from JS execution errors), and I just noticed that we might need some extra work to make FinalizationRegistry work with that

[11:34:51.0948] <Andreu Botella>
the way the FR cleanup job is spec'd, if any callback throws, it's up to the host to deal with that

[11:35:28.0954] <Andreu Botella>
but after `CleanupFinalizationRegistry` returns, the host doesn't have access to the context

[11:35:34.0336] <Andreu Botella>
 * but after `CleanupFinalizationRegistry` returns, the host doesn't have access to the FR context

[11:37:43.0664] <Andreu Botella>
and we probably want to make `error` work the same as `unhandledrejection`

[11:37:58.0170] <Andreu Botella>
 * and we probably want to make `error` work the same as `unhandledrejection`, so it'd have to store that context

[15:10:37.0470] <littledan>
Chris de Almeida: the idea is that the meeting is public and open to join, and the process to get the link is to come in and ask us. No need to make the attendee list public—this can be a separate calendar invite which lacks the zoom link, the notes link and attendees, and only says the time and gives instructions to join this channel and ask for more information 

[15:18:21.0615] <Chris de Almeida>
> <@littledan:matrix.org> Chris de Almeida: the idea is that the meeting is public and open to join, and the process to get the link is to come in and ask us. No need to make the attendee list public—this can be a separate calendar invite which lacks the zoom link, the notes link and attendees, and only says the time and gives instructions to join this channel and ask for more information

it would be ideal if it were not two separate meetings, but that's alright. please provide the text for the new/public meeting description

[15:19:24.0705] <Justin Ridgewell>
The notes are also publicly editable, which means they shouldn’t be shared to everyone

[15:19:53.0799] <Justin Ridgewell>
(The notes are tied to my deactived Vercel account, so I can’t change the permissions)

[15:23:42.0258] <Andreu Botella>
Can we create a new notes document and copy the contents?

[15:24:52.0324] <Andreu Botella>
 * Can we create a new notes document and copy the contents there?

[15:25:20.0171] <Justin Ridgewell>
Someone else could, but I can’t as a Googler (our docs cannot be made publicly visible)

[15:41:51.0045] <Chengzhong Wu>
Created a new one: https://docs.google.com/document/d/1pi-NMbqVhg2UuxQAZ4jOGDeHLlZGD_DJ7fyxHt_C2hs/edit

[15:42:40.0173] <Chengzhong Wu>
Access granted to people that I have ail address in mind, please don’t be hesitant to ask for editor access by message me your address 

[15:42:53.0261] <Chengzhong Wu>
* Access granted to people that I have email address in mind, please don’t be hesitant to ask for editor access by message me your address

[15:45:13.0770] <Chengzhong Wu>
* Access granted to people that I have email address in mind, please don’t be hesitant to ask for editor access by message me your address (still publicly viewable)


2024-05-07
[20:52:15.0250] <Justin Ridgewell>
Updated the calendar invite’s doc to that one

[20:53:27.0125] <Justin Ridgewell>
@softwarechris:matrix.org Can you give me moderator access to the invite’s meet? That way we can publicize the link and still have it be invite-only (people can just ask to join during the meeting if they’re not on the invite yet)

[21:31:11.0805] <Chris de Almeida>
you already have calendar permission and are the organizer of the meeting.  the web/video call settings are currently set to open access.  keep in mind if you change it from `Open` to `Trusted`, even if people are on the invite, they can only join automatically if their email on the invite is associated with a google account.  otherwise, they still need to be let in.  and the only person that can let anyone in is you

[21:32:12.0605] <Chris de Almeida>
I recall that being a problem, and the reason why the web meeting settings were changed to `Open`

[21:32:45.0607] <Justin Ridgewell>
Can only one person have that power?

[21:36:50.0114] <Chris de Almeida>
> <@jridgewell:matrix.org> Can only one person have that power?

unfortunately, yes. the meeting organizer.  you could use an alternate service that allows you to use cohosts or utilize a host key (which potentially anyone could use if they have the key).  but I don't know of any workaround for google

[21:36:53.0745] <Chris de Almeida>
> <@jridgewell:matrix.org> Can only one person have that power?

 * unfortunately, yes. the meeting organizer.  you could use an alternate service that allows you to use cohosts or utilize a host key (which potentially anyone could use if they have the key).  but I don't know of any workaround for google meet

[21:37:05.0408] <Chris de Almeida>
 * unfortunately, yes. the meeting organizer.  you could use an alternate meeting platform that allows you to use cohosts or utilize a host key (which potentially anyone could use if they have the key).  but I don't know of any workaround for google meet


2024-05-09
[09:27:53.0627] <Andreu Botella>
I'm wondering if we should have an AO that creates an AsyncContext.Variable object?

[09:29:12.0168] <Andreu Botella>
I'm thinking about web specs that might use AsyncContext by creating a spec-internal variable

[09:29:26.0212] <Andreu Botella>
and currently we restrict the keys of a mapping to be Variable instances

[09:31:06.0832] <Andreu Botella>
it's not like those specs can't call the AsyncContext.Variable constructor, but they'd have to deal with abrupt completions and so on

[09:32:17.0951] <Andreu Botella>
though I guess that would be fine if there are only a few specs doing something like that, and it can always be revisited later

[09:38:06.0587] <Chengzhong Wu>
I think it's good to have, as like `AsyncContextSnapshot` and `AsyncContextSwap`


2024-05-13
[10:37:34.0525] <littledan>
Where are we in understanding https://github.com/tc39/proposal-async-context/issues/83 ?

[11:42:13.0150] <Mathieu Hofman>
I talked with Dean Tribble on Friday, picking his brain from his Midori experience. I think the conclusion is that there is no way to abstract "calling" context in an API shape like AsyncContext. The biggest problem is that the most recent calling context may not be the one you really need, that providing more than one would result in unbounded calling context history, and that it would expose some implementation details about the execution order of the "callers". For telemetry / debugging use cases, one approach is to gather points at certain key times. For promises for example, you can give them an ID and "log" when they are resolved (potentially to another promise), when reactions are added and executed, etc.. Then you can correlate all this and recompose your execution graph. this of course sounds very similar to async_hooks, and is too powerful of an API to expose to "unprivileged" code.

[12:03:27.0968] <littledan>
> <@mhofman:matrix.org> I talked with Dean Tribble on Friday, picking his brain from his Midori experience. I think the conclusion is that there is no way to abstract "calling" context in an API shape like AsyncContext. The biggest problem is that the most recent calling context may not be the one you really need, that providing more than one would result in unbounded calling context history, and that it would expose some implementation details about the execution order of the "callers". For telemetry / debugging use cases, one approach is to gather points at certain key times. For promises for example, you can give them an ID and "log" when they are resolved (potentially to another promise), when reactions are added and executed, etc.. Then you can correlate all this and recompose your execution graph. this of course sounds very similar to async_hooks, and is too powerful of an API to expose to "unprivileged" code.

This makes sense; thanks for the summary. What does Dean recommend that we do for AsyncContext?

[12:04:01.0285] <littledan>
"just choose something for each case" is the strategy that I was imagining; maybe too naive but it sounds like this is maybe what Dean is saying?

[12:06:07.0309] <littledan>
I'm wondering if there's any way we could expose "just" the necessary information to hook up the extra follows-from links, or distinguish child vs following links. I think Stephen Belanger may have been asking for one of these, though I'm not sure. Did you discuss this topic with Dean?

[12:12:54.0867] <Mathieu Hofman>
Yeah having a default of "snapshoting" at registration makes sense for AsyncContext. It's just that AsyncContext might not be the right API shape for telemetry use cases. And yes we tried to figure out how the necessary info could be exposed through AsyncContext, but couldn't find a way.

[12:14:25.0008] <littledan>
I think the current shape of AsyncContext has a "good enough in practice" shape for telemetry since it matches what's done in Node.js today. Maybe something better is possible; certainly telemetry infrastructure can be trusted.

[12:15:01.0185] <littledan>
Mathieu Hofman: Do you think we should continue with AsyncContext as currently proposed, without changes like #83?

[12:32:19.0123] <Steve Hicks>
Are we also considering taking the smaller-scoped `callingContext` API off the table?

[12:33:34.0532] <Steve Hicks>
#83 has made me pretty concerned about scope creep.  But I'm also obviously concerned about my own pet use cases.  I've got a meeting with Jatin this evening to hopefully nail down exactly what kind of registration- vs. call-time semantics we will need.


2024-05-14
[01:25:31.0956] <Stephen Belanger>
So if context _always_ flows into _all_ branches, all we _actually_ need is the context as it was when it reached a merge barrier. For example, context flows into each of the promise-returning functions passed into a `Promise.all(...)`. Each of these branches can change their context along the path but will only ever have one value. When the value eventually reaches the merge barrier where it would get placed in the array the `Promise.all(...)` call resolves to it would capture the single context value in that branch and store it in a merge context array of equal length to the `Promise.all(...)` input and output size.

The resulting merge context makes the most sense though if the resolve path is followed rather than the register path. If the register path is followed it just flattens same as the async/await issue I brought up, which means none of that merge context would reach anywhere useful if the register on the `Promise.all(...)` discards all that inner behaviour by binding around it. This is the sort of scenario why I want to have a way to get at calling context whenever a snapshot is restored. Either that or have a way to, on a per-store basis, reject the snapshot restore decision and keep using the value that propagated through the internal branch.

Merge contexts are a bit weird though as it transforms a single value into an array of values, so I think it still makes sense to "pick a winner" for the default behaviour and just provide power users an additional power tool there, which might require a bit more manual intervention, to get at the full merge context list.

[04:29:47.0480] <Andreu Botella>
While thinking about the rejection context of web APIs that take async callbacks, I realized that if you do something like this, there's no way to preserve the rejection context even if you explicitly want to:
```js
asyncCb().catch(err => {
    if (something(err)) {
        return someValue;
    } else {
        throw err;
    }
});
```

[04:30:10.0897] <Andreu Botella>
at least that would be in the current spec text

[04:30:22.0563] <Andreu Botella>
in Stephen's version it would work as expected

[04:30:43.0910] <Andreu Botella>
 * While thinking about the rejection context of web APIs that take async callbacks, I realized that if you do something like this, there's no way to preserve the original rejection context even if you explicitly want to:

```js
asyncCb().catch(err => {
    if (something(err)) {
        return someValue;
    } else {
        throw err;
    }
});
```

[04:31:48.0717] <Andreu Botella>
fulfillment contexts aren't observable, but rejection contexts are with `unhandledrejection`

[10:08:10.0040] <Chengzhong Wu>
ICYMI notes are here https://docs.google.com/document/d/1pi-NMbqVhg2UuxQAZ4jOGDeHLlZGD_DJ7fyxHt_C2hs/edit and please feel free to correct it

[15:11:40.0056] <littledan>
> <@stephenhicks:matrix.org> #83 has made me pretty concerned about scope creep.  But I'm also obviously concerned about my own pet use cases.  I've got a meeting with Jatin this evening to hopefully nail down exactly what kind of registration- vs. call-time semantics we will need.

I am curious what you found in that discussion 

[16:42:39.0618] <littledan>
Does anyone have a consolidated description of what “Stephen’s version” is?

[16:43:14.0137] <littledan>
I mean in particular what the diff would be vs the current proposal (without the other superficial changes)

[16:49:26.0563] <littledan>
Per-instance wrap is a convenience function, in my understanding. Did you get a chance to discuss that? I don’t see notes about it 

[16:50:21.0773] <littledan>
Did we ever get an answer on how callingContext would relate to Promise.all?


2024-05-15
[21:28:51.0748] <Steve Hicks>
One of my AI's was to go through Stephen's docs and try to figure out what the gist of it was.  I think Stephen was also going to try to distill it down a bit further, though it was late for him by the end of the meeting.  Variable.prototype.wrap is a convenience function and I think we agreed to more or less table it for now.  But there's also a question of per-instance propagation configuration that is impossible to do in userland (i.e. some vars propagate via init/registration context, while others propagate via causal/calling context).  Per a discussion today with Scott Haseley, it sounds like there's already some precedent for this in how v8 handles yield vs. normal CPED/attribution, in that the latter propagates over setTimeout while the former is dropped.  In the case of multiple variable configs, I think it would boil down to having effectively two separate variable linked lists instead of one, and they're treated differently by snapshot swapping.  This may not be infeasible, so it's maybe worth considering whether it leads to a good solution.

We didn't get a chance to discuss callingContext, though (tbh) it's still my preferred option for ensuring the APM use case is viable - but we still need to figure out Promise.all.  One (totally off-the-cuff) possibility would be to just stack up all the causal contexts, first-to-last.  You know how many promises were merged, so you can pop that many contexts off the stack if you need them all.

Upshot from discussion with Jatin was that he agreed that calling context is crucial, and figured that most userland schedulers (at least the ones he owns) would probably need to go with that default.  Registration context is useless for our use of computed signals and effects (and he was particularly concerned about losing the ability to see causal context if/when Signals land in the standard), and we'd need to propagate causal context throughout all the stages of (user interaction) -> (lazy load, controller instantiation) -> (rpc fetch) -> (model cache update) -> (component rerender) in order to ensure tracing works correctly.  These are all (currently) userland schedulers, at least, so it's possible, but ultimately the hope is to replace the model cache with signals.

[21:30:46.0510] <Steve Hicks>
 * One of my AI's was to go through Stephen's docs and try to figure out what the gist of it was.  I think Stephen was also going to try to distill it down a bit further, though it was late for him by the end of the meeting.  Variable.prototype.wrap is a convenience function and I think we agreed to more or less table it for now.  But there's also a question of per-instance propagation configuration that is impossible to do in userland (i.e. some vars propagate via init/registration context, while others propagate via causal/calling context).  Per a discussion today with Scott Haseley, it sounds like there's already some precedent for this in how v8 handles yield vs. normal CPED/attribution, in that the latter propagates over setTimeout while the former is dropped.  In the case of multiple variable configs, I think it would boil down to having effectively two separate variable linked lists instead of one, and they're treated differently by snapshot swapping.  This may not be infeasible, so it's maybe worth considering whether it leads to a good solution.

We didn't get a chance to discuss callingContext, though (tbh) it's still my preferred option for ensuring the APM use case is viable, due to balancing the extra complexity and feasibility of ever actually landing this proposal, vs stalling out from trying to do too much - but we do still need to figure out Promise.all.  One (totally off-the-cuff) possibility would be to just stack up all the causal contexts, first-to-last.  You know how many promises were merged, so you can pop that many contexts off the stack if you need them all.

Upshot from discussion with Jatin was that he agreed that calling context is crucial, and figured that most userland schedulers (at least the ones he owns) would probably need to go with that default.  Registration context is useless for our use of computed signals and effects (and he was particularly concerned about losing the ability to see causal context if/when Signals land in the standard), and we'd need to propagate causal context throughout all the stages of (user interaction) -> (lazy load, controller instantiation) -> (rpc fetch) -> (model cache update) -> (component rerender) in order to ensure tracing works correctly.  These are all (currently) userland schedulers, at least, so it's possible, but ultimately the hope is to replace the model cache with signals.

[21:48:43.0463] <Steve Hicks>
I took a stap at implementing the stack-based Promise.all in userland with callingContext, and I ran into a brick wall because there's no way to actually stack multiple top-level frames: https://www.typescriptlang.org/play/?#code/CYUwxgNghgTiAEA7KBbEBnADlMCCC6AnomAMID2iALiAB5XwDeAUPPHZuTA5FOuvADKyTOgAW5BizZsYAV0QAeACoA+ABQAzRAC546gJTwAvKvjKDe5axnoqUKgEsw8AO4womRQDF29EIjAAt4KYE6UGtp63pbw3gDcNgC+NhxcDJqh4YjwYFAQEI6IAOYU1HRUKpG6+kam5rHKiSnMmSTZ8Jgw5CiO6CB4BSp+NIECAArdvf2KCgDWiOSuiKoA2gC6Gl09fRhWsZM7M4yrANLwRfBzIITkmubreniuUI40wCpnm0lm0vAQIAY6BE4kkTyIJDKNHoADphJ5QVQAD4KUCaIogYCJNhgSh2eBwdByCBUdB6eaLZYbEydKa7dAwlCedSGExmVEgdGITEGbH-QG5cgKBjGWlHDAwgElKhiPlwKhyGA5bmueCHaYgFmE8gQABuIAANASQAArcBUOq-GxsTRcfQAhiOGkABniF3gijFGoZUuKMrdjgA1IGjH8ZF76atHOsYTKAizdflLUxreHjUSSego+saYmIHy0xd7uoAITAhESC0pwvh8uiSs0gjEMiUaFUGF5ApFUqtios5Mq+BNyG92Hw+uSQy81PhpLsCD9as1th1xE01eVmHyRD9tlL5dsAD0h-gADkAPLKACiehlfXgwHIGCQkngAEc5G8EK4uHN4AAjcAoDkRc41yfJChKKEKjcRwClyCByH-QCYBnGtj3gMCN1fMQ+ioLhCCNKBAngXVnAQfUYHQKAYTYAB1BB-z4ZwIMIJAQExeAoDcKA2PwzpiQgNDCwwoUGG49BuwBeBNA8NAjVcXCwDEeB+hAFABHUBwZMcKiGGKaASENTDyHgNAjFxagPGAZx8JgQhhLTDDXDeFTAO7Lj-2k-icFwfhwK7EpBXKegBFgBBYH-N4PHsh8QEwGUjQUAF+Ec8MMKZQhAMwsQEE7SCexChg8HGABJTCoGuMK4oSlTsDkwEQBgWihwXcgFJAAByfV-nIOw0pkDCwNxGA4DCAKCug+h4FyuAuJIuM5sfDBEE6oEOJQEyAIini+PIAajxPYoBW0t4YQO40FSVIcIRbIqOwg7spqoXd6kHYc7rbOEQUrKcCxrJJp2XFJl0cYsAFpwdxYV4DMZ0jHlRVEH+2sfskLcFFesxtT1TVCWJUkuLCxBCAMIG0ySI11CamBkzDNM4DNMJqdG8nZwMVMQfgQHmmYIA

[21:49:12.0666] <Steve Hicks>
 * I took a stap at implementing the stack-based Promise.all in userland with callingContext, and I ran into a brick wall because there's no way to actually stack multiple top-level frames: [playground](https://www.typescriptlang.org/play/?#code/CYUwxgNghgTiAEA7KBbEBnADlMCCC6AnomAMID2iALiAB5XwDeAUPPHZuTA5FOuvADKyTOgAW5BizZsYAV0QAeACoA+ABQAzRAC546gJTwAvKvjKDe5axnoqUKgEsw8AO4womRQDF29EIjAAt4KYE6UGtp63pbw3gDcNgC+NhxcDJqh4YjwYFAQEI6IAOYU1HRUKpG6+kam5rHKiSnMmSTZ8Jgw5CiO6CB4BSp+NIECAArdvf2KCgDWiOSuiKoA2gC6Gl09fRhWsZM7M4yrANLwRfBzIITkmubreniuUI40wCpnm0lm0vAQIAY6BE4kkTyIJDKNHoADphJ5QVQAD4KUCaIogYCJNhgSh2eBwdByCBUdB6eaLZYbEydKa7dAwlCedSGExmVEgdGITEGbH-QG5cgKBjGWlHDAwgElKhiPlwKhyGA5bmueCHaYgFmE8gQABuIAANASQAArcBUOq-GxsTRcfQAhiOGkABniF3gijFGoZUuKMrdjgA1IGjH8ZF76atHOsYTKAizdflLUxreHjUSSego+saYmIHy0xd7uoAITAhESC0pwvh8uiSs0gjEMiUaFUGF5ApFUqtios5Mq+BNyG92Hw+uSQy81PhpLsCD9as1th1xE01eVmHyRD9tlL5dsAD0h-gADkAPLKACiehlfXgwHIGCQkngAEc5G8EK4uHN4AAjcAoDkRc41yfJChKKEKjcRwClyCByH-QCYBnGtj3gMCN1fMQ+ioLhCCNKBAngXVnAQfUYHQKAYTYAB1BB-z4ZwIMIJAQExeAoDcKA2PwzpiQgNDCwwoUGG49BuwBeBNA8NAjVcXCwDEeB+hAFABHUBwZMcKiGGKaASENTDyHgNAjFxagPGAZx8JgQhhLTDDXDeFTAO7Lj-2k-icFwfhwK7EpBXKegBFgBBYH-N4PHsh8QEwGUjQUAF+Ec8MMKZQhAMwsQEE7SCexChg8HGABJTCoGuMK4oSlTsDkwEQBgWihwXcgFJAAByfV-nIOw0pkDCwNxGA4DCAKCug+h4FyuAuJIuM5sfDBEE6oEOJQEyAIini+PIAajxPYoBW0t4YQO40FSVIcIRbIqOwg7spqoXd6kHYc7rbOEQUrKcCxrJJp2XFJl0cYsAFpwdxYV4DMZ0jHlRVEH+2sfskLcFFesxtT1TVCWJUkuLCxBCAMIG0ySI11CamBkzDNM4DNMJqdG8nZwMVMQfgQHmmYIA)

[21:49:25.0424] <Steve Hicks>
 * I took a stab at implementing the stack-based Promise.all in userland with callingContext, and I ran into a brick wall because there's no way to actually stack multiple top-level frames: [playground](https://www.typescriptlang.org/play/?#code/CYUwxgNghgTiAEA7KBbEBnADlMCCC6AnomAMID2iALiAB5XwDeAUPPHZuTA5FOuvADKyTOgAW5BizZsYAV0QAeACoA+ABQAzRAC546gJTwAvKvjKDe5axnoqUKgEsw8AO4womRQDF29EIjAAt4KYE6UGtp63pbw3gDcNgC+NhxcDJqh4YjwYFAQEI6IAOYU1HRUKpG6+kam5rHKiSnMmSTZ8Jgw5CiO6CB4BSp+NIECAArdvf2KCgDWiOSuiKoA2gC6Gl09fRhWsZM7M4yrANLwRfBzIITkmubreniuUI40wCpnm0lm0vAQIAY6BE4kkTyIJDKNHoADphJ5QVQAD4KUCaIogYCJNhgSh2eBwdByCBUdB6eaLZYbEydKa7dAwlCedSGExmVEgdGITEGbH-QG5cgKBjGWlHDAwgElKhiPlwKhyGA5bmueCHaYgFmE8gQABuIAANASQAArcBUOq-GxsTRcfQAhiOGkABniF3gijFGoZUuKMrdjgA1IGjH8ZF76atHOsYTKAizdflLUxreHjUSSego+saYmIHy0xd7uoAITAhESC0pwvh8uiSs0gjEMiUaFUGF5ApFUqtios5Mq+BNyG92Hw+uSQy81PhpLsCD9as1th1xE01eVmHyRD9tlL5dsAD0h-gADkAPLKACiehlfXgwHIGCQkngAEc5G8EK4uHN4AAjcAoDkRc41yfJChKKEKjcRwClyCByH-QCYBnGtj3gMCN1fMQ+ioLhCCNKBAngXVnAQfUYHQKAYTYAB1BB-z4ZwIMIJAQExeAoDcKA2PwzpiQgNDCwwoUGG49BuwBeBNA8NAjVcXCwDEeB+hAFABHUBwZMcKiGGKaASENTDyHgNAjFxagPGAZx8JgQhhLTDDXDeFTAO7Lj-2k-icFwfhwK7EpBXKegBFgBBYH-N4PHsh8QEwGUjQUAF+Ec8MMKZQhAMwsQEE7SCexChg8HGABJTCoGuMK4oSlTsDkwEQBgWihwXcgFJAAByfV-nIOw0pkDCwNxGA4DCAKCug+h4FyuAuJIuM5sfDBEE6oEOJQEyAIini+PIAajxPYoBW0t4YQO40FSVIcIRbIqOwg7spqoXd6kHYc7rbOEQUrKcCxrJJp2XFJl0cYsAFpwdxYV4DMZ0jHlRVEH+2sfskLcFFesxtT1TVCWJUkuLCxBCAMIG0ySI11CamBkzDNM4DNMJqdG8nZwMVMQfgQHmmYIA)

[21:53:22.0968] <Steve Hicks>
I can see a few variants on callingContext: (1) it just puts the previous frame directly on top of the current one (i.e. behaves identical to Snapshot.run) - in this case, one could just _make_ it a snapshot?  This makes it impossible to access deeper-nested ones, since `callingContext()` will just get you back to the previous (registration?) context.  Unless maybe it takes a depth argument.  In that case, the stacking might _just_ be possible.  Or (2) it restores the entire context stack to whatever it looked like in the calling environment, such that a second `callingContext`would go back further in causation history.

[04:07:39.0392] <Stephen Belanger>
I made this small (-ish) example of how we're doing that differentiation between child-of and follows-from relationships and what we're trying to do with holding the minimum possible data in the store (just the ID). https://gist.github.com/Qard/6ceaca8bb792679e82c7693513baee0e

[04:37:17.0878] <Stephen Belanger>
In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not _too_ terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not _too_ terribly important as we at least get _one_ of the branches so we can still _mostly_ understand the execution structure. But we _do_ need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The example above are meant to show that we are expecting something which logically _continues_ from a particular point is expected to be able to attribute itself from that. Whereas what we get _currently_ with both async/await and promises is a flat structure where all the `mysql.query` spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.

[04:37:42.0630] <Stephen Belanger>
 * In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not _too_ terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not _too_ terribly important as we at least get _one_ of the branches so we can still _mostly_ understand the execution structure.

But we _do_ need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The example above are meant to show that we are expecting something which logically _continues_ from a particular point is expected to be able to attribute itself from that. Whereas what we get _currently_ with both async/await and promises is a flat structure where all the `mysql.query` spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.

[04:37:58.0257] <Stephen Belanger>
 * In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not _too_ terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not _too_ terribly important as we at least get _one_ of the branches so we can still _mostly_ understand the execution structure.

But we _do_ need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The examples above are meant to show that we are expecting something which logically _continues_ from a particular point is expected to be able to attribute itself from that. Whereas what we get _currently_ with both async/await and promises is a flat structure where all the `mysql.query` spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.

[04:38:14.0551] <Stephen Belanger>
 * In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not _too_ terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not _too_ terribly important as we at least get _one_ of the branches so we can still _mostly_ understand the execution structure.

But we _do_ need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The examples above are meant to show that we are expecting something which logically _continues_ from a particular point is expected to be able to attribute itself to that. Whereas what we get _currently_ with both async/await and promises is a flat structure where all the `mysql.query` spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.

[07:37:17.0513] <littledan>
I am confused by general comments on registration time vs call time. Can we do more to dig into the detailed cases? (Am chatting with Jatin about this now too)

[07:38:02.0412] <littledan>
Andreu had some sort of point by point analysis. What if we made that a Google Doc and then we could comment together on which things could/should be different for which use cases?

[07:49:04.0939] <littledan>
In reality there will be a mix of both registration time and call time, so I have trouble understanding conversations which are phrases like “vs”

[08:27:53.0387] <Steve Hicks>
A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. <button on click="..."> with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need _some_ option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.

[08:50:04.0717] <Steve Hicks>
 * A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. \<buttonon click="..."> with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need \_some\_ option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.

[08:50:17.0220] <Steve Hicks>
 * A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. \<buttonon click="..."> with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need _some_ option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.

[08:50:35.0814] <Steve Hicks>
 * A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. \<button onclick="..."> with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need _some_ option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.

[08:58:49.0527] <Stephen Belanger>
I'm wondering if await/yield/then binding should just be a config per-store and we can just hold two sets of stores so ones that _do_ have that turned on do those binds and ones that have it turned off don't get tracked in that list at all. Just a random idea. And to be clear, I don't care which way is the default. If we have the capability to switch to the other on our stores then that's basically the one single major blocker for APM vendors right now, as far as I can tell. 🤔

[09:22:42.0347] <Steve Hicks>
I think if we had that option then it would end up needing to be _three_ different sets in the long run, since `scheduler.yield` (and/or `scheduler.currentTaskSignal`) would need yet a different propagation, where it _does_ propagate across `await`, but +not_ through `setTimeout`.

[09:22:59.0662] <Steve Hicks>
 * I think if we had that option then it would end up needing to be _three_ different sets in the long run, since `scheduler.yield` (and/or `scheduler.currentTaskSignal`) would need yet a different propagation, where it _does_ propagate across `await`, but _not_ through `setTimeout`.

[12:13:09.0256] <littledan>
> <@stephenhicks:matrix.org> A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. \<button onclick="..."> with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need _some_ option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.

Can you say more about how you imagine that option being used? One possible default could be “use the originating/call context where available, otherwise fall back to registration if it doesn’t exist” and you could override that to “always registration time” by wrapping your callback yourself.

[12:13:28.0674] <littledan>
In that case, no options bag needed

[12:14:40.0654] <littledan>
Another is “always registration time, and you get passed the originating snapshot in a property of the event, which you can then .run within if you want” (again, you could choose the opposite default by wrapping the callback, this time in something that got the snapshot out and applied it)

[12:15:05.0724] <littledan>
In either case it would be OK to include an option as an ergonomic niceity but it seems optional to me

[12:15:48.0092] <littledan>
> <@stephenhicks:matrix.org> I think if we had that option then it would end up needing to be _three_ different sets in the long run, since `scheduler.yield` (and/or `scheduler.currentTaskSignal`) would need yet a different propagation, where it _does_ propagate across `await`, but _not_ through `setTimeout`.

Why were these semantics chosen for priority, btw?

[12:16:47.0572] <littledan>
> <@stephenbelanger:matrix.org> I'm wondering if await/yield/then binding should just be a config per-store and we can just hold two sets of stores so ones that _do_ have that turned on do those binds and ones that have it turned off don't get tracked in that list at all. Just a random idea. And to be clear, I don't care which way is the default. If we have the capability to switch to the other on our stores then that's basically the one single major blocker for APM vendors right now, as far as I can tell. 🤔

Yeah I could see the “two types of variables” idea but I don’t see how it solves the “maintain follows-from links” problem

[12:18:29.0841] <littledan>
Also I don’t really know how we would make the call-biased variables work

[12:19:16.0860] <Steve Hicks>
> <@littledan:matrix.org> Another is “always registration time, and you get passed the originating snapshot in a property of the event, which you can then .run within if you want” (again, you could choose the opposite default by wrapping the callback, this time in something that got the snapshot out and applied it)

I think this approach is problematic because it only really works for events.  But there's a handful of other APIs (e.g. IntersectionObserver and MutationObserver, various Promise APIs, hypothetical future signals, etc) that don't have any events and you'd need a different custom solution for each to solve effectively the same problem.

[12:19:49.0352] <Andreu Botella>
> <@stephenhicks:matrix.org> I think this approach is problematic because it only really works for events.  But there's a handful of other APIs (e.g. IntersectionObserver and MutationObserver, various Promise APIs, hypothetical future signals, etc) that don't have any events and you'd need a different custom solution for each to solve effectively the same problem.

for observers you could have a property of the observer entry

[12:20:16.0242] <littledan>
Yeah I think this works *better* for observers than other options since they have a single callback for multiple things

[12:21:18.0355] <Andreu Botella>
> <@littledan:matrix.org> Why were these semantics chosen for priority, btw?

I think because `scheduler.yield()` wants to distinguish between a continuation of the current task and a subtask

[12:21:23.0183] <littledan>
For promise-based APIs: I am having trouble picturing what we would want and how; maybe you could give a concrete example of where you don’t want the restore-around-await semantics (“registration time”) and what you want instead?

[12:21:41.0153] <littledan>
> <@abotella:igalia.com> I think because `scheduler.yield()` wants to distinguish between a continuation of the current task and a subtask

What does that have to do with setTimeout?

[12:21:52.0562] <Steve Hicks>
> <@littledan:matrix.org> Why were these semantics chosen for priority, btw?

I don't know the background there.  I scanned through https://github.com/WICG/scheduling-apis/blob/main/explainers/yield-and-continuation.md but don't see anything specifically about this choice.

[12:22:00.0667] <Andreu Botella>
> <@littledan:matrix.org> What does that have to do with setTimeout?

`setTimeout` would be a subtask

[12:22:33.0403] <littledan>
> <@stephenhicks:matrix.org> I don't know the background there.  I scanned through https://github.com/WICG/scheduling-apis/blob/main/explainers/yield-and-continuation.md but don't see anything specifically about this choice.

I guess you are relaying this case based on personal communication with Scott? Maybe he can clarify (or join here)?

[12:23:21.0321] <Steve Hicks>
> <@littledan:matrix.org> I guess you are relaying this case based on personal communication with Scott? Maybe he can clarify (or join here)?

Yes, I can ask.

[12:23:46.0963] <littledan>
> <@littledan:matrix.org> Can you say more about how you imagine that option being used? One possible default could be “use the originating/call context where available, otherwise fall back to registration if it doesn’t exist” and you could override that to “always registration time” by wrapping your callback yourself.

What do you think of this option Steve Hicks ?

[12:24:22.0322] <Andreu Botella>
> <@littledan:matrix.org> I guess you are relaying this case based on personal communication with Scott? Maybe he can clarify (or join here)?

from a conversation I had with him:
> It's important (as of now, subject to change) that those [yield-related CPED state fields] are not propagated to subtasks and events. The idea is that yield() can inherit the priority of the current task, but the current task and subtasks are not necessarily related (i.e. breaking up the current task by yielding in a loop does not imply other work spawned should have the same priority). It's possible this will change, but as of now we need to keep that behavior.

[12:24:42.0046] <Steve Hicks>
> <@littledan:matrix.org> For promise-based APIs: I am having trouble picturing what we would want and how; maybe you could give a concrete example of where you don’t want the restore-around-await semantics (“registration time”) and what you want instead?

My understanding is that this is what Stephen is asking for.  I don't have quite as good a sense of the use case, but from the examples I've seen, he wants to `await openFile()` and have a trace span opened in `openFile` still be present on the outside.

[12:25:01.0268] <Andreu Botella>
> <@littledan:matrix.org> I guess you are relaying this case based on personal communication with Scott? Maybe he can clarify (or join here)?

 * from a conversation I had with him:

> It's important (as of now, subject to change) that those \[yield-related fields of the object propagated through CPED\] are not propagated to subtasks and events. The idea is that yield() can inherit the priority of the current task, but the current task and subtasks are not necessarily related (i.e. breaking up the current task by yielding in a loop does not imply other work spawned should have the same priority). It's possible this will change, but as of now we need to keep that behavior.

[12:25:33.0243] <littledan>
Do *you* run into cases where you want this behavior with promises?

[12:26:43.0981] <Steve Hicks>
> <@littledan:matrix.org> Yeah I think this works *better* for observers than other options since they have a single callback for multiple things

That may be so on an individual level, but it's still a different solution for each situation, which I see as a big problem since it leads to everyone having to figure out for every given situation "how do I do this thing?".  Also, it's ideal when userland APIs can have analogous behavior to builtins, and so every userland scheduler would also need to come up with their own custom solution.

[12:29:14.0427] <Steve Hicks>
> <@littledan:matrix.org> What do you think of this option Steve Hicks ?

I don't love the "where available" framing - it feels very "zalgo-adjacent" where you can never really be sure what context something will run in because it depends on external factors (e.g. for a click handler, it could run in either, depending on if it's dispatched programmatically or by user action).  As a result, you just can't really rely on anything.

[12:29:24.0573] <littledan>
Do you have another idea for how we should handle observers?

[12:30:02.0758] <Steve Hicks>
I favor a general solution that doesn't rely on details of the scheduling API.

[12:30:20.0230] <Steve Hicks>
something more like AsyncContext.callingContext where it works in all cases

[12:30:45.0663] <Steve Hicks>
 * I favor a general solution that doesn't rely on details of the scheduling API's shape.

[12:31:00.0481] <littledan>
> <@stephenhicks:matrix.org> I favor a general solution that doesn't rely on details of the scheduling API's shape.

Of course, but I guess the scheduling API assumes it can be based on a primitive with certain properties, and we are trying to understand what that primitive is…

[12:31:52.0874] <littledan>
If the decision was not made for a very strong reason and turns out to be kinda irregular compared to other needs, we shouldn’t necessarily turn ourselves inside out trying to solve for it. But if it’s a good reason, that is different 

[12:32:37.0646] <littledan>
I don’t understand how callingContext would relate to dropping things on setTimeout

[12:33:44.0657] <Steve Hicks>
sorry, my statement about dropping on setTimeout was just about how (as currently spec'd) neither of the two default-propagation behaviors we're considering would actually work to enable replacing the current yield propagation with AsyncContext

[12:34:17.0877] <Steve Hicks>
 * sorry, my statement about dropping on setTimeout was just about how neither of the two default-propagation behaviors we're considering would actually work to enable replacing the current yield propagation (as currently spec'd) with AsyncContext

[12:34:18.0117] <littledan>
> <@stephenhicks:matrix.org> I don't love the "where available" framing - it feels very "zalgo-adjacent" where you can never really be sure what context something will run in because it depends on external factors (e.g. for a click handler, it could run in either, depending on if it's dispatched programmatically or by user action).  As a result, you just can't really rely on anything.

Yeah, I share the Zalgo concern, but maybe a bit more broadly. With signals, for example, it feels kinda Zalgo to me if we propagate in things about where the computed was read from (since that is a race in itself). But from taking with Jatin, I understand that he wants to see what triggers what in responding to a user gesture, so it’s kinda needed. An unfortunate contradiction 

[12:35:02.0507] <Steve Hicks>
I'll go back to the doc idea you had - we need to get more known use cases and situations documented, I think, in order to get more insight into the downstream ramifications on application code, etc

[12:35:10.0921] <littledan>
> <@stephenhicks:matrix.org> sorry, my statement about dropping on setTimeout was just about how neither of the two default-propagation behaviors we're considering would actually work to enable replacing the current yield propagation (as currently spec'd) with AsyncContext

Yeah, I agree; do you have an idea for an alternative that would handle this?

[12:35:44.0898] <Steve Hicks>
> <@littledan:matrix.org> Yeah, I agree; do you have an idea for an alternative that would handle this?

Sadly no.  Change the scheduler spec?

[12:36:34.0545] <Steve Hicks>
(to allow propagating across child tasks like an ordinary async var)

[12:37:36.0326] <littledan>
That is my first intuition but it’s because I don’t understand the motivation for the current design 

[12:38:19.0806] <littledan>
What would be unscalable is for each variable to have custom logic at each point where it might be propagated. I guess APMs have this power today though.

[12:39:43.0344] <Steve Hicks>
In terms of downstream repercussions, I'm thinking about app developers writing their handlers, middleware, signals, etc.  I believe a fundamental axiom here is (or at least, I'd like it to be) that frameworks can put vars in place and app developers don't need to be aware of what those vars are - so needing to explicitly do anything with callingContext in their own callbacks would be a problem, and if there's a few layers of application code in the way such that the framework can't just pull their variable off the "top" callingContext, then that approach probably wouldn't work.

[12:41:10.0900] <littledan>
Agreed. And in general you can have lots of merges that look like that, I think (so Promise.all integration isn’t quite enough)

[12:41:24.0292] <littledan>
This is why the “two classes of variables” idea appeals to me somewhat (but I still don’t know how it would work)

[12:43:28.0291] <Steve Hicks>
> <@littledan:matrix.org> This is why the “two classes of variables” idea appeals to me somewhat (but I still don’t know how it would work)

agreed - especially if the "calling context" flavor means that it doesn't propagate across an `await`, then I'm not sure it's viable, though (IIUC) that would be more consistent with how then() would behave?

[12:45:45.0438] <Andreu Botella>
On an unrelated note, what do you expect this to print?
```js
function cb() {
  asyncVar.run("foo", () => {
    throw new Error();
  });
}

asyncVar.run("bar", cb);

window.addEventListener("error", () => {
  console.log(asyncVar.get());
}, {useOriginatingContext: true});
```

[12:46:05.0812] <Andreu Botella>
with the current spec, the only thing this could print is `bar`, but I'd expect that's not the expected behavior

[12:48:07.0326] <Steve Hicks>
> <@abotella:igalia.com> with the current spec, the only thing this could print is `bar`, but I'd expect that's not the expected behavior

I find that incredibly surprising.  My mental model is that `v.run(a, () => v.run(b, f))` is equivalent to `v.run(b, f)`.

[12:48:20.0675] <Andreu Botella>
ohw ait

[12:48:23.0163] <Steve Hicks>
though obviously that would change w/ callingContext

[12:48:25.0148] <Andreu Botella>
 * oh wait

[12:48:29.0978] <Andreu Botella>
my bad

[12:48:45.0639] <Andreu Botella>
 * On an unrelated note, what do you expect this to print?

```js
function cb() {
  asyncVar.run("foo", () => {
    throw new Error();
  });
}

asyncVar.run("bar", => {
  setTimeout(cb, 0);
});

window.addEventListener("error", () => {
  console.log(asyncVar.get());
}, {useOriginatingContext: true});
```

[12:48:51.0021] <Andreu Botella>
I meant to have `setTimeout` there

[12:50:39.0829] <Steve Hicks>
I'm still lacking some intuition here... how is this different from running `cb` directly in bar?

[12:51:13.0976] <Andreu Botella>
I guess it's not

[12:51:44.0917] <Andreu Botella>
the thing is, when `.run()` returns it will always restore the previous context, even if the callback threw

[12:51:50.0192] <Steve Hicks>
other than i guess that the error is async

[12:52:08.0103] <Andreu Botella>
so when the execution gets back to `setTimeout`, the current context is `bar`

[12:52:26.0605] <Andreu Botella>
the context active at throw time isn't preserveed

[12:52:30.0203] <Andreu Botella>
 * the context active at throw time isn't preserved

[12:53:23.0517] <Steve Hicks>
I thought it was? Isn't that the point of useOriginatingContext?

[12:53:53.0524] <Steve Hicks>
so yah, I'd still expect either undefined or foo

[12:54:19.0089] <Andreu Botella>
> <@stephenhicks:matrix.org> I thought it was? Isn't that the point of useOriginatingContext?

`useOriginatingContext` is there so the registration time isn't used

[12:55:42.0312] <Andreu Botella>
run is basically implemented like:
```js
function run(value, cb) {
  const previousContext = changeContext(updateContext(value));
  try {
    return cb();
  } finally {
    changeContext(previousContext);  // this loses track of foo and restores bar
  }
}
```

[12:56:00.0204] <Andreu Botella>
there's currently nothing in the spec text that preserves the context in which an exception is thrown

[12:56:23.0995] <Andreu Botella>
because the caller context is switched in the finally

[12:57:13.0919] <Andreu Botella>
 * because the current context is switched back to the previous one in the finally

[12:57:32.0384] <Steve Hicks>
ah, my understanding was that unhandled rejections (at least) would hold onto the rejection context.  I'd assumed that this extended to "error" as well, though that's not an API I'm familiar with

[12:58:13.0610] <Andreu Botella>
yeah, I think no one considered error until I started looking into it last week

[12:58:53.0224] <Andreu Botella>
I suspect that making that work would mean patching how completions work in the spec 😰

[12:59:35.0331] <Andreu Botella>
though I guess you could also have a `lastThrowContext` global state

[12:59:50.0283] <Andreu Botella>
that would only be used if `cb()` threw

[13:00:16.0952] <Andreu Botella>
that's a much less invasive change

[13:20:29.0295] <Andreu Botella>
Do we want to exposed the last thrown context to userland? Are there userland implementations of something like the error event?

[13:20:52.0447] <Andreu Botella>
Something like that in V8 would definitely be needed for JS runtimes like Node.js and Deno, since they implement the error event in JS

[13:22:21.0222] <Steve Hicks>
Does this require instrumenting every `throw` in order to polyfill?

[13:22:46.0729] <Andreu Botella>
> <@stephenhicks:matrix.org> Does this require instrumenting every `throw` in order to polyfill?

no, I think it would only require changing the `run` implementation

[13:23:19.0824] <Steve Hicks>
ah, so if you catch in a run, then you know it was a throw-context

[13:23:32.0459] <Steve Hicks>
what about await-resumptions?

[13:24:25.0952] <Steve Hicks>
probably would be handled by the async function instrumentation, i guess

[13:25:09.0778] <Andreu Botella>
> <@stephenhicks:matrix.org> what about await-resumptions?

I'll have to think about that

[13:25:31.0904] <Andreu Botella>
for the JS runtime use case, I think you only need sync throw handling

[13:26:06.0310] <Andreu Botella>
since anything else would use unhandledrejection rather than error


2024-05-16
[05:47:07.0194] <Stephen Belanger>
> <@littledan:matrix.org> For promise-based APIs: I am having trouble picturing what we would want and how; maybe you could give a concrete example of where you don’t want the restore-around-await semantics (“registration time”) and what you want instead?

We basically _never_ want to restore around await. We want context changes to flow through the resolve path and back to the continuation of that resolve after the await. It would do that automatically if we had that separate set that does resolve path flow rather than register path flow. Any then and await binds would just get skipped and instead the context value at the resolve point would be what gets propagated into the continuation.

[05:53:19.0842] <Stephen Belanger>
So our main concern for APM uses is that code which is functionally equivalent from the user perspective should produce an equivalent context graph. In the example I posted yesterday (https://gist.github.com/Qard/6ceaca8bb792679e82c7693513baee0e) I have three examples of an http request using async/await, raw promises, and callbacks respectively. All three examples are functionally identical from user-facing execution flow perspective, yet they produce _very_ different context graphs from AsyncContext because promises and async/await follow registration path rather than resolve path.

[05:54:09.0407] <Stephen Belanger>
It's very confusing to users when they rewrite their code from callbacks to promises and suddenly their traces look very different because the flow of the context graph is so different.

[07:10:53.0539] <littledan>
It is hard to square wanting to never restore around await with what you wrote in the doc about how AsyncLocalStorage mostly does what you want (when it restores around await)

[07:11:40.0644] <littledan>
I was persuaded by your doc that both paths are meaningful but now it seems like you are saying only one of them is, which is surprising

[07:14:01.0376] <littledan>
One suboptimal way to implement promise.all is to go for-of through the array and await each element. In this case, we would care about establishing links both from the context before the await, and from the thing we are awaiting 

[07:14:29.0497] <littledan>
(Assuming the context before the await somehow inherits the previous thing being awaited)

[07:16:00.0998] <littledan>
I see how, in our web integration, we could/should adopt the “prefer originating context when present” semantics. But it is still hard for me to understand this await argument.

[07:19:45.0216] <Andreu Botella>
> <@littledan:matrix.org> (Assuming the context before the await somehow inherits the previous thing being awaited)

This wouldn't be the case, unless we somehow make the calling context be an array of all promises that led to this point, which seems like clear overkill

[07:20:05.0125] <Andreu Botella>
> <@littledan:matrix.org> (Assuming the context before the await somehow inherits the previous thing being awaited)

 * This wouldn't be the case, unless we somehow make the calling context be an array of the contexts of all promises that led to this point, which seems like clear overkill

[08:07:01.0001] <Stephen Belanger>
> <@littledan:matrix.org> It is hard to square wanting to never restore around await with what you wrote in the doc about how AsyncLocalStorage mostly does what you want (when it restores around await)

By "mostly works" I mean it propagates correctly in most cases (callbacks), but async/await is not one of them. We have a pile of hacks to work around that currently lacking capability.

[08:07:50.0214] <Stephen Belanger>
ALS is "good enough" that we can provide a product that "works" but is _not_ good enough to provide something that works _well_.

[08:08:12.0537] <Stephen Belanger>
This is the whole reason _why_ we've been designing an entirely new thing.

[08:10:27.0434] <Andreu Botella>
I opened https://github.com/tc39/proposal-async-context/issues/90 to discuss the `error` event

[09:31:55.0921] <littledan>
> <@stephenbelanger:matrix.org> By "mostly works" I mean it propagates correctly in most cases (callbacks), but async/await is not one of them. We have a pile of hacks to work around that currently lacking capability.

where can I read more about that pile of hacks? (maybe you already wrote about it somewhere?)

[09:32:58.0102] <littledan>
> <@abotella:igalia.com> This wouldn't be the case, unless we somehow make the calling context be an array of the contexts of all promises that led to this point, which seems like clear overkill

I hope it's not necessary either, but I can see how Ste{v,ph}en's points argue for it to be necessary. (I'm having trouble understanding what you're supposed to do with currentContext besides reconstruct this array)

[09:41:14.0513] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> So our main concern for APM uses is that code which is functionally equivalent from the user perspective should produce an equivalent context graph. In the example I posted yesterday (https://gist.github.com/Qard/6ceaca8bb792679e82c7693513baee0e) I have three examples of an http request using async/await, raw promises, and callbacks respectively. All three examples are functionally identical from user-facing execution flow perspective, yet they produce _very_ different context graphs from AsyncContext because promises and async/await follow registration path rather than resolve path.

Whould you mind expanding on the distinguishing of child-of and follow-from? All promise resolutions are scheduled asynchronously, it seems to me that in this case "child-of" would be meaning-less in promise's case

[10:11:43.0878] <Andreu Botella>
> <@littledan:matrix.org> I hope it's not necessary either, but I can see how Ste{v,ph}en's points argue for it to be necessary. (I'm having trouble understanding what you're supposed to do with currentContext besides reconstruct this array)

I imagine that APMs could patch every built-in promise-returning API to get the span in the calling context, and then they could call the built-in inside `.run()` to start a new span – but that would only work as long as you never await a promise that was created before the last await

[10:12:00.0583] <Andreu Botella>
so yeah, I also want to know what exactly Stephen had in mind there

[10:51:16.0516] <littledan>
> <@abotella:igalia.com> I imagine that APMs could patch every built-in promise-returning API to get the span in the calling context, and then they could call the built-in inside `.run()` to start a new span – but that would only work as long as you never await a promise that was created before the last await

"awaiting a promise which was created before the last await" is exactly the Promise.all case, I think. It keeps being the "two contexts is not enough" problem.

[15:17:39.0176] <Steve Hicks>
The "don't bind around await" case feels a lot like "just use a global variable" to me.  To my mind, automatic binding around await is basically one of the main purposes of AC, so if you're not doing that, what are you gaining?  Is it just the question of restoring context after awaiting an already-done promise?  Assuming all awaited promises were pending when the await kicked off, then a simple model seems like doing nothing would "just work" since the continuation would follow immediately afterwards, so the global value would be correct.  Of course this breaks down when the await doesn't actually have to wait - and maybe also when two independent jobs are running interleaved?

So a global variable is obviously a bit too naive to work, but where I'm struggling is to understand how an AC.Variable with mutable state falls short?  That seems like it would address the issue of interleaved independent tasks, at least, and since (within the same task) you're presumably not clobbering the actual container variable, then that part shouldn't need to change after an await (and if it did, it could presumably be communicated back upstream).  ISTR Stephen mentioning performance concerns, but it's important to compare this against the performance cost of additional overhead needed to maintain a more complex graph, or more different kinds of state that need extra work to fork/join.

[15:23:20.0803] <Steve Hicks>
To Stephen's point about rewriting code from callbacks to promise/await, I agree that they should be consistent, but I'd argue that it's a transient issue.  Callback-based code should be updated to wrap the callbacks so that the behavior is the same.  I understand that the fact that ALS has existed for a while with the other behavior makes this a bit of a problem...  Ideally the standard Node APIs would have all been updated to wrap/bind when ALS first came out, before anyone began depending on the non-wrapping behavior.

[15:26:09.0827] <Steve Hicks>
Now, the fact that this wrapping would make a handful of existing use cases impossible is clearly a problem, and points to why we need some way to access the causing context, rather than just the registration context.  This could be as simple as a AsyncContext.Snapshot.noWrap that would prevent any automatic wrapping (or other implicit snapshot restoration that the VM would do via abstract operations), though it's not clear to me whether this would (or should!) provide the non-restoring async/await behavior?

[15:26:59.0482] <Steve Hicks>
 * Now, the fact that this wrapping would make a handful of existing use cases impossible is clearly a problem, and points to why we need some way to access the causing context, rather than just the registration context.  This could be as simple as a AsyncContext.Snapshot.noWrap that would prevent any automatic wrapping (or other implicit snapshot restoration that the VM would do via abstract operations), though it's not clear to me whether this would (or should!) provide the non-restoring async/await behavior (vs. just affecting what context callbacks are entered with the first time).


2024-05-17
[17:53:40.0800] <littledan>
> <@stephenhicks:matrix.org> Now, the fact that this wrapping would make a handful of existing use cases impossible is clearly a problem, and points to why we need some way to access the causing context, rather than just the registration context.  This could be as simple as a AsyncContext.Snapshot.noWrap that would prevent any automatic wrapping (or other implicit snapshot restoration that the VM would do via abstract operations), though it's not clear to me whether this would (or should!) provide the non-restoring async/await behavior (vs. just affecting what context callbacks are entered with the first time).

How would noWrap work?

[17:54:52.0752] <littledan>
Like it cancels out a wrap that happens around it?

[18:42:18.0145] <Steve Hicks>
yes, something like that - aside from being able to observe callingContext, wrapping is idempotent, so nowrap would maybe cancel _all_ wraps that happen around it?  not quite clear - it's just one option.

[19:26:13.0343] <littledan>
It feels kinda vaguely non-compositional to cancel out wrap; maybe better to avoid wrapping in the first place. Weren’t we discussing options for that? (But then you run into the “no null context” issue also)

[19:27:10.0280] <littledan>
I am not being very clear with noncompositional… I guess I mean, if you replace f with n => f(n), then noWrap stops working

[19:27:41.0651] <Steve Hicks>
not necessarily - it depends on how it's implemente.d

[19:27:49.0320] <Steve Hicks>
 * not necessarily - it depends on how it's implemented.

[19:29:33.0250] <Steve Hicks>
If the implementation is to explicitly restore the previous snapshot, then it's robust to `n => f(n)`, though it makes `wrap` no longer idempotent (i.e. `wrap(wrap(unwrap(f))) == wrap(f)`) and there's potentially weirdness around `unwrap(unwrap(f)) == f` or some such...

[19:30:11.0588] <Steve Hicks>
or if it popped off a stack instead of just swapping in the previous then it really would undo one layer

[19:30:20.0611] <Steve Hicks>
 * or if it popped off a stack instead of just swapping in the previous then it really would undo one layer for each

[19:30:56.0643] <Steve Hicks>
but it would only work from the _inside_ - `unwrap(wrap(f)) == wrap(f)`, which is surprising

[19:32:42.0489] <Steve Hicks>
I don't love those properties... but I think any observability of `callingContext` probably breaks idempotency of `wrap`, so maybe there's no way to keep that one?

[01:07:44.0279] <littledan>
Huh, how would it figure out the previous one at runtime? Currently you can just use a single global variable for the current snapshot.

[01:36:07.0864] <Stephen Belanger>
> <@legendecas:matrix.org> Whould you mind expanding on the distinguishing of child-of and follow-from? All promise resolutions are scheduled asynchronously, it seems to me that in this case "child-of" would be meaning-less in promise's case

The resolution is async, but we create a span around the thing that _created_ the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.

```js
async function foo() {
  console.log('1')
  await Promise.resolve()
  console.log('3')
}
foo()
console.log('2')
```

[01:42:10.0060] <littledan>
Do OTel implementations in any other language with async/await make this distinction properly? If so it would be great to be able to refer to their implementation strategies.

[01:42:41.0677] <Stephen Belanger>
> <@littledan:matrix.org> where can I read more about that pile of hacks? (maybe you already wrote about it somewhere?)

There's not really any writing on it presently, but basically because we don't flow into promise continuations we need to keep an object at the top-level of the request which we push spans into and basically _guess_ what the parent is because, unlike with callbacks, the parent does not flow into the continuation. This means we have to look at what has been pushed into that list in the past and try to guess what the parent would be. Sometimes it's simply the last span in the list, but not always, so we need to do some additional analysis to figure out what was the last span which _could_ be a realistic parent, which requires we also hold a bunch of the span metadata. Holding all this metadata is expensive given that we could have hundreds of thousands of concurrent spans. What we _want_ is for the _correct_ context to just be able to flow through the resolve path so we only need to store the IDs and can entirely eliminate that big bag of data which lives for the whole life of the request.

[01:45:51.0918] <Stephen Belanger>
> <@littledan:matrix.org> I hope it's not necessary either, but I can see how Ste{v,ph}en's points argue for it to be necessary. (I'm having trouble understanding what you're supposed to do with currentContext besides reconstruct this array)

We don't need the list of all context historically, only a way at any given snapshot restore to elect to keep the prior value which already flowed in and additionally to be able to have a way to configure stores to capture resolve time of promises rather than register time.

[01:51:57.0954] <Stephen Belanger>
> <@stephenhicks:matrix.org> The "don't bind around await" case feels a lot like "just use a global variable" to me.  To my mind, automatic binding around await is basically one of the main purposes of AC, so if you're not doing that, what are you gaining?  Is it just the question of restoring context after awaiting an already-done promise?  Assuming all awaited promises were pending when the await kicked off, then a simple model seems like doing nothing would "just work" since the continuation would follow immediately afterwards, so the global value would be correct.  Of course this breaks down when the await doesn't actually have to wait - and maybe also when two independent jobs are running interleaved?
> 
> So a global variable is obviously a bit too naive to work, but where I'm struggling is to understand how an AC.Variable with mutable state falls short?  That seems like it would address the issue of interleaved independent tasks, at least, and since (within the same task) you're presumably not clobbering the actual container variable, then that part shouldn't need to change after an await (and if it did, it could presumably be communicated back upstream).  ISTR Stephen mentioning performance concerns, but it's important to compare this against the performance cost of additional overhead needed to maintain a more complex graph, or more different kinds of state that need extra work to fork/join.

It's not that we need _no_ binds for async/await, it's that we want it to bind at the resolve point of the promise being awaited rather than at registration time directly at the point the await occurs. This would mean context would flow _through_ promises rather than _around_ them. It would _also_ mean the restore which occurs _after_ the await resumes would be that resolve point value rather than what the value was before the await occurred.

[01:53:57.0976] <Stephen Belanger>
> <@stephenhicks:matrix.org> To Stephen's point about rewriting code from callbacks to promise/await, I agree that they should be consistent, but I'd argue that it's a transient issue.  Callback-based code should be updated to wrap the callbacks so that the behavior is the same.  I understand that the fact that ALS has existed for a while with the other behavior makes this a bit of a problem...  Ideally the standard Node APIs would have all been updated to wrap/bind when ALS first came out, before anyone began depending on the non-wrapping behavior.

It's _intentional_ that it behaves that way with callbacks. That's how context management is _supposed_ to work as it's not useful for most cases if it doesn't flow into continuations. That's literally the _point_ of the "async" in AsyncLocalStorage.

[01:54:45.0906] <Stephen Belanger>
I'm not even sure what use there _would_ be for the other way with callbacks. I don't see any use case for that flow. 🤔

[01:58:05.0980] <Stephen Belanger>
> <@littledan:matrix.org> Do OTel implementations in any other language with async/await make this distinction properly? If so it would be great to be able to refer to their implementation strategies.

Yes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's _able_ to do this externally. With Node.js there is no solution.

[01:58:47.0882] <littledan>
> <@stephenbelanger:matrix.org> Yes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's _able_ to do this externally. With Node.js there is no solution.

Other languages work the way you are proposing we adopt for JS? That is great to know. Can you suggest a concrete one for us to look into?

[01:59:25.0166] <littledan>
Bytecode manipulation isn’t magic; I would be surprised if we can’t do what’s achieved with it

[02:00:02.0350] <Stephen Belanger>
Not sure. Like I said, most do this externally to the runtime itself so I'm unsure if any particular language is a good example of it.

[02:02:12.0623] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> The resolution is async, but we create a span around the thing that _created_ the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.
> 
> ```js
> async function foo() {
>   console.log('1')
>   await Promise.resolve()
>   console.log('3')
> }
> foo()
> console.log('2')
> ```

```
handleRequest((req, res) => {
  // ROOT SPAN0
  // child-of context.variable: SPAN0
  // await connection.query() SPAN1
  connection.query('SELECT 1 + 1 AS two') // SPAN1
    .then(a => {
      // PROPOSED CONTEXT: SPAN1.2
      return connection.query('SELECT 2 + 2 AS four') // SPAN2
    })
    .then(a => {
      // PROPOSED CONTEXT: SPAN2.2
      // If the context.variable at this point is SPAN2, how do we determine
      // child-of or follow-from?
      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3
      return connection.query('SELECT 3 + 3 AS four') // SPAN3
    })
    .then(b => {
      // PROPOSED CONTEXT: SPAN3.2
      res.writeHead(200, { 'Content-Type': 'text/plain' })
      res.end(a[0].two + b[0].four)
    })
})

function connectionQuery(query) {
  // Current Context: SPANx
  return makeFirstRequest() // SPANx.1
    .then(() => {
      makeSecondRequest() // SPANx.2
    })
}
```
In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now

[02:02:25.0021] <littledan>
That’s OK if it’s external, if it implements the right semantics I am still happy to have that as the reference point

[02:02:32.0024] <Stephen Belanger>
> <@littledan:matrix.org> Bytecode manipulation isn’t magic; I would be surprised if we can’t do what’s achieved with it

Much of the code we need to patch to do that in JS is not reachable at runtime. With bytecode you can manipulate everything, even private things.

[02:03:10.0168] <Chengzhong Wu>
 * ```
handleRequest((req, res) => {
  // ROOT SPAN0
  // child-of context.variable: SPAN0
  // await connection.query() SPAN1
  connection.query('SELECT 1 + 1 AS two') // SPAN1
    .then(a => {
      // PROPOSED CONTEXT: SPAN1.2
      return connection.query('SELECT 2 + 2 AS four') // SPAN2
    })
    .then(a => {
      // PROPOSED CONTEXT: SPAN2.2
      // If the context.variable at this point is SPAN2.2, how do we determine
      // child-of or follow-from?
      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3
      return connection.query('SELECT 3 + 3 AS four') // SPAN3
    })
    .then(b => {
      // PROPOSED CONTEXT: SPAN3.2
      res.writeHead(200, { 'Content-Type': 'text/plain' })
      res.end(a[0].two + b[0].four)
    })
})

function connectionQuery(query) {
  // Current Context: SPANx
  return makeFirstRequest() // SPANx.1
    .then(() => {
      makeSecondRequest() // SPANx.2
    })
}
```

In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now

[02:03:33.0179] <littledan>
> <@stephenbelanger:matrix.org> Much of the code we need to patch to do that in JS is not reachable at runtime. With bytecode you can manipulate everything, even private things.

Sounds good, so can a language runtime, which is what we are talking about changing. It would help us to have a concrete reference point even if it is external/messy

[02:04:21.0970] <Chengzhong Wu>
 * ```
handleRequest((req, res) => {
  // ROOT SPAN0
  connection.query('SELECT 1 + 1 AS two') // SPAN1
    .then(a => {
      // PROPOSED CONTEXT: SPAN1.2
      // If the context.variable at this point is SPAN1.2, how do we determine
      // child-of or follow-from?
      // As proposed this should be a follow-from SPAN1.3 instead of SPAN2
      return connection.query('SELECT 2 + 2 AS four') // SPAN2
    })
    .then(b => {
      // PROPOSED CONTEXT: SPAN3.2
      res.writeHead(200, { 'Content-Type': 'text/plain' })
      res.end(a[0].two + b[0].four)
    })
})

function connectionQuery(query) {
  // Current Context: SPANx
  return makeFirstRequest() // SPANx.1
    .then(() => {
      makeSecondRequest() // SPANx.2
    })
}
```

In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now

[02:04:41.0373] <Stephen Belanger>
> <@legendecas:matrix.org> ```
> handleRequest((req, res) => {
>   // ROOT SPAN0
>   connection.query('SELECT 1 + 1 AS two') // SPAN1
>     .then(a => {
>       // PROPOSED CONTEXT: SPAN1.2
>       // If the context.variable at this point is SPAN1.2, how do we determine
>       // child-of or follow-from?
>       // As proposed this should be a follow-from SPAN1.3 instead of SPAN2
>       return connection.query('SELECT 2 + 2 AS four') // SPAN2
>     })
>     .then(b => {
>       // PROPOSED CONTEXT: SPAN3.2
>       res.writeHead(200, { 'Content-Type': 'text/plain' })
>       res.end(a[0].two + b[0].four)
>     })
> })
> 
> function connectionQuery(query) {
>   // Current Context: SPANx
>   return makeFirstRequest() // SPANx.1
>     .then(() => {
>       makeSecondRequest() // SPANx.2
>     })
> }
> ```
> 
> In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now

What do you mean by `PROPOSED CONTEXT: SPAN1.2`? What I'm expecting is for the context there to be a continuation of `SPAN1`.

[02:05:45.0440] <Stephen Belanger>
> <@littledan:matrix.org> Sounds good, so can a language runtime, which is what we are talking about changing. It would help us to have a concrete reference point even if it is external/messy

I'll have to talk to my team about that and see what examples I can get from them as I'm really not he expert on _other_ languages. 😅

[02:07:14.0491] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> What do you mean by `PROPOSED CONTEXT: SPAN1.2`? What I'm expecting is for the context there to be a continuation of `SPAN1`.

The example is equivalent to async-await as:
```

handleRequest(async (req, res) => {
  // ROOT SPAN0
  await connection.query('SELECT 1 + 1 AS two') // SPAN1
  // PROPOSED CONTEXT: SPAN1.2
  await connection.query('SELECT 2 + 2 AS four') // SPAN2
  // PROPOSED CONTEXT: SPAN2.2
  res.writeHead(200, { 'Content-Type': 'text/plain' })
  res.end(a[0].two + b[0].four)
})
```
Is this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?

[02:07:21.0304] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> What do you mean by `PROPOSED CONTEXT: SPAN1.2`? What I'm expecting is for the context there to be a continuation of `SPAN1`.

 * The example is equivalent to async-await as:

```
handleRequest(async (req, res) => {
  // ROOT SPAN0
  await connection.query('SELECT 1 + 1 AS two') // SPAN1
  // PROPOSED CONTEXT: SPAN1.2
  await connection.query('SELECT 2 + 2 AS four') // SPAN2
  // PROPOSED CONTEXT: SPAN2.2
  res.writeHead(200, { 'Content-Type': 'text/plain' })
  res.end(a[0].two + b[0].four)
})
```

Is this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?

[02:12:24.0538] <Stephen Belanger>
Again, I'm unclear what the decimal point thing is about here?

[02:13:58.0954] <littledan>
> <@stephenbelanger:matrix.org> I'll have to talk to my team about that and see what examples I can get from them as I'm really not he expert on _other_ languages. 😅

Sounds good, maybe we can all learn from this then

[02:14:48.0057] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> Again, I'm unclear what the decimal point thing is about here?

Decimal points represent child-of relations, increased number represets a follow-of relation.

[02:16:44.0326] <Stephen Belanger>
Ah, no. Only the first is a child-of because it occurs within the sync initial part of the async function.

[02:16:56.0623] <Stephen Belanger>
The second should be follows-from.

[02:18:06.0350] <Stephen Belanger>
The `connection.query(...)` expression is called before its result is awaited, and it's the calling of that which produces a span. That span is therefore within the synchronous scope of the http server request span.

[02:18:35.0450] <Stephen Belanger>
If there was some _other_ await before it, even one which did not produce a span, then it would be considered follows-from.

[02:19:37.0968] <Chengzhong Wu>
yeah, so in a promise chain, child-of is no longer effective and I'm curious about how you curate a graph with nesting semantics.

[02:20:11.0114] <Chengzhong Wu>
 * yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you curate a graph with nesting semantics.

[02:20:52.0437] <Chengzhong Wu>
 * yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you crate a graph with nesting semantics.

[02:20:56.0569] <Chengzhong Wu>
 * yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you create a graph with nesting semantics.

[02:21:23.0707] <Stephen Belanger>
That would look the same. The creation of that initial promise produces a sync/child-of span, and then anything in following `then(...)` continuations would be follows-from of whichever thing in the chain last produced a span.

[02:22:14.0625] <Stephen Belanger>
So from a user code behaviour perspective, callbacks, promises, and async/await would all produce the same graph.

[02:23:14.0618] <Stephen Belanger>
And in the less common case where a continuation is attached far away from where the promise is created, a manual bind could be used where necessary to express that further away logical path, if it makes sense.

[02:23:30.0365] <Stephen Belanger>
But generally from APM perspective we basically _never_ want that further away path.

[02:23:54.0218] <Stephen Belanger>
Meaning register time of a promise continuation.

[02:24:06.0140] <Stephen Belanger>
We want resolve time basically universally.

[02:24:41.0715] <Stephen Belanger>
As do basically all userland context flow use cases I'm aware of. I'm very unclear what the actual use case is for register time binding. 😕

[02:25:34.0703] <littledan>
Sometimes there is no particular resolve time context to apply, and we just need to fall back to register time

[02:25:59.0306] <littledan>
If it goes to a browser/os primitive

[02:27:01.0556] <littledan>
There’s the general connection pooling case, which generalizes this

[02:28:56.0391] <littledan>
Generally to get child-of edges, don’t you want restore after await? Sync is not enough.

[02:29:16.0851] <Stephen Belanger>
Resolve time naturally flows out to eventually promise-creation time--the thing you called which created a promise.

[02:29:37.0829] <littledan>
What do you mean “flows out to”?

[02:30:13.0748] <Stephen Belanger>
> <@littledan:matrix.org> Generally to get child-of edges, don’t you want restore after await? Sync is not enough.

Child-of edges are easy. They are just things happening synchronously within the current scope, so we don't need anything for that. Not sure why restoring matters here? 🤔

[02:32:05.0532] <Stephen Belanger>
> <@littledan:matrix.org> What do you mean “flows out to”?

I mean the context flows up to some execution barrier where the JS-side work to be done on the scheduling side is _done_. With a promise, this is generally when the resolve happens. But if it's a native promise or something like that then none of the resolving stage happens within JS so you just follow the flow back upward until you get to a point in the causal that _was_ in JS, which is when the original call happened.

[02:33:12.0618] <littledan>
> <@legendecas:matrix.org> yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you create a graph with nesting semantics.

So it seems like we have a disagreement in this chat about this statement. How can we look into it further? Maybe analyzing some concrete cases?

[02:33:26.0949] <Stephen Belanger>
Creation of a promise is just an allocation. It's not controlling flow at that point. The actual _scheduling_ of a promise is the providing of a value to resolve it with.

[02:36:09.0883] <Andreu Botella>
> <@stephenbelanger:matrix.org> I mean the context flows up to some execution barrier where the JS-side work to be done on the scheduling side is _done_. With a promise, this is generally when the resolve happens. But if it's a native promise or something like that then none of the resolving stage happens within JS so you just follow the flow back upward until you get to a point in the causal that _was_ in JS, which is when the original call happened.

in JS code that creates a promise and then resolves it, wouldn't this only be the case if there are no `AsyncContext.Snapshot.p.run` along the promise resolution path?

[02:37:36.0873] <Stephen Belanger>
> <@abotella:igalia.com> in JS code that creates a promise and then resolves it, wouldn't this only be the case if there are no `AsyncContext.Snapshot.p.run` along the promise resolution path?

Not sure what you mean by that. Do you have an example?

[02:39:46.0689] <Stephen Belanger>
From _my_ perspective: context flows into the promise executor, it flows into anything that happens _within_ that executor, it then captures whenever the `resolve(...)` is called as _that_ is what actually schedules passing the value to continuations. If the context value is set outside the promise constructor it will use that context. If it gets set somewhere within the executor leading up to when it calls `resolve(...)` it will use that. It all flows naturally toward the resolve point where it schedules the value to pass to continuations.

[02:40:49.0340] <Andreu Botella>
so IIUC, you're saying that in cases like `await someAPI()`, the resolve time is a child of the context before the await

[02:40:50.0769] <Andreu Botella>
but that is not the case with things like
```js
const somePreviousSnapshot = new AsyncContext.Snapshot();

function someAPI() {
  return new Promise(resolve => {
    // I don't know why someone might do this, but they *can* do it.
    somePreviousSnapshot.run(resolve);
  });
}
```

[02:41:36.0787] <Stephen Belanger>
Now you _could_ look at it the other way of _attaching a continuation_ is the scheduling and the resolve is a fulfillment of that scheduling, but the fulfillment is not _triggered_ by that attaching of a continuation so I don't really feel like that's actually correct. Possibly a _useful_ path to follow in some cases, though I'm unclear _when_.

[02:43:53.0634] <Stephen Belanger>
> <@abotella:igalia.com> so IIUC, you're saying that in cases like `await someAPI()`, the resolve time is a child of the context before the await

Yeah, so the expression which produces the promises which _will_ be awaited occurs within that context, so the context flows into it naturally. The context of that outer function should reach into the promise and flow all the way to its resolve, unless some other context is set along that path. When the promise _resolves_ the following execution is then a _continuation_ of that resolution and should therefore flow the context which was captured at the point that path resolved.

[02:44:04.0674] <Stephen Belanger>
> <@abotella:igalia.com> so IIUC, you're saying that in cases like `await someAPI()`, the resolve time is a child of the context before the await

 * Yeah, so the expression which produces the promise which _will_ be awaited occurs within that context, so the context flows into it naturally. The context of that outer function should reach into the promise and flow all the way to its resolve, unless some other context is set along that path. When the promise _resolves_ the following execution is then a _continuation_ of that resolution and should therefore flow the context which was captured at the point that path resolved.

[02:44:59.0255] <Stephen Belanger>
In your example there, you captured a snapshot and ran that around the resolve, so that changes the context which should come out of the await.

[02:47:34.0479] <Stephen Belanger>
This is why I feel flowing up to the resolve barrier makes a lot more sense, and then not binding around awaits at all, or maybe having some _secondary_ flow that could be captured for those. If you follow the resolve path you will naturally have the context from the start of the async function flow through all the awaits and continue to be available, only changing if something in that causal path changed the context around what led to their resolve.

[02:48:45.0066] <Stephen Belanger>
Binding around awaits is chopping off branches of the execution graph, which I'm unclear why anyone would want to do that by default. 🤔

[02:49:44.0174] <Andreu Botella>
but in cases like this, wouldn't this mess up tracing?
```js
async function someFunctionYouCareAboutTracing() {
	const response1 = await fetch(...);
	await someAPI();  // this empties out the context after the await!
	const response2 = await fetch(...);
	return await doSomethingWith(response1, response2);
}
```

[02:49:50.0237] <Stephen Belanger>
Like I get that there seems to be some use case people have in mind for _why_ it makes sense _for them_ to bind and restore around awaits, but I _still_ have not seen any adequate explanation on _why_ anyone would ever want that. 😕

[02:50:41.0584] <Stephen Belanger>
> <@abotella:igalia.com> but in cases like this, wouldn't this mess up tracing?
> ```js
> async function someFunctionYouCareAboutTracing() {
> 	const response1 = await fetch(...);
> 	await someAPI();  // this empties out the context after the await!
> 	const response2 = await fetch(...);
> 	return await doSomethingWith(response1, response2);
> }
> ```

What about that would mess it up? Is `someApi()` _explicitly_ emptying the context for some reason?

[02:51:23.0931] <Andreu Botella>
I meant the definition of `someApi()` above, which *is*

[02:51:54.0499] <Stephen Belanger>
Ah, you mean it's restoring the snapshot captured previously?

[02:52:17.0557] <Stephen Belanger>
Yeah, that would return to whatever the context was which was captured in that snapshot.

[02:52:30.0650] <Stephen Belanger>
So if you're using a snapshot in that way then that is _expected_.

[02:53:18.0005] <Stephen Belanger>
And this is also why I would like to have per-instance bind because sometimes it makes sense globally like connection pools, but sometimes opinions may vary.

[02:53:21.0929] <Andreu Botella>
maybe this isn't something worth worrying about, but someone might be using snapshots to do things around their `AsyncContext.Variable`s not realizing that that might affect the context in which their promise gets resolved, which would affect other use libraries that use AsyncContext

[02:54:10.0271] <Andreu Botella>
also, if you have an interaction of various libraries that use AsyncContext for their separate goals, they might interact in unforeseen ways

[02:54:12.0401] <Stephen Belanger>
But yes, I believe it is "correct" for that to break context. Or rather, it might be _incorrect_ that it is _doing_ that snapshot restore.

[02:54:46.0296] <Stephen Belanger>
> <@abotella:igalia.com> maybe this isn't something worth worrying about, but someone might be using snapshots to do things around their `AsyncContext.Variable`s not realizing that that might affect the context in which their promise gets resolved, which would affect other use libraries that use AsyncContext

Yep, this is why Node.js hates `AsyncResource`. 🙈

[02:56:42.0544] <Stephen Belanger>
So in Node.js, async_hooks made the mistake of producing a _singular_ execution graph which is grafted with `AsyncResource` binds. AsyncLocalStorage is layered over it so it inherits that mistake. We want it to _not_ be layered over that so we can _fix_ that problem.

[02:57:42.0009] <Andreu Botella>
I'm not sure I understand. Even if we do have per-instance wrap, you would still need global wraps, right?

[02:57:58.0592] <Stephen Belanger>
APMs (unfortunately) fairly often use `AsyncResource` to "fix" context management flows, but then we break other vendors because we change the graph _they_ were expecting. 😬

[02:58:12.0324] <Stephen Belanger>
Yes, global is still needed.

[02:58:18.0625] <Stephen Belanger>
Just not _always_.

[02:58:58.0651] <Stephen Belanger>
And this is specifically why I created the WindowChannel concept. So different consumers could make different decisions in a reasonably user-friendly way.

[02:59:59.0376] <Andreu Botella>
So my worry is about a (maybe small) library that might not realize they're supposed to be doing per-instance wrap rather than global wrap, since it works fine in their tests

[03:00:13.0224] <Andreu Botella>
Or cases where a library might have multiple variables and they use global wrap to handle all of them at once

[03:00:47.0863] <Stephen Belanger>
I mean, that _will_ be a problem. But _without_ instance-scoped bind it's _still_ a problem, just without a solution.

[03:01:25.0300] <Andreu Botella>
right, I thought making it part of the API was a convenience thing, or perhaps a worry about performance, but it's part of the affordance of the API

[03:01:38.0524] <Andreu Botella>
 * right, I thought making per-instance wrap part of the API was a convenience thing, or perhaps a worry about performance, but it's part of the affordance of the API

[03:01:38.0591] <Stephen Belanger>
People are _going_ to use APIs wrong. We can't stop that. At best we can _try_ to make it _clear_ when they're doing it wrong.

[03:01:55.0113] <Andreu Botella>
 * right, I thought making per-instance wrap part of the API was a convenience thing, or perhaps a worry about performance, but it's part of the affordance of the API design

[03:02:38.0480] <Stephen Belanger>
I mean, you _can_ just do it with a `store.get()` and a closure that does `store.run(...)` around the orignal function. So it's _easy enough_ to do externally. But I _personally_ feel it should be part of the actual API, for clarity.

[03:02:50.0651] <Andreu Botella>
yeah, I see that now

[03:03:25.0965] <Stephen Belanger>
Well, that's not _completely_ true if we have the sync vs continuation differentiation, but that's another thing.

[03:04:01.0599] <Stephen Belanger>
That's also why in my RFC I was explicitly defining separate windows.

[03:07:07.0468] <Stephen Belanger>
With separate windows you could make the `store.run(...)` be a `continuationWindow.run(...)` instead and key the child-of versus follows-from decision off that.

[03:10:13.0860] <Stephen Belanger>
I think separating those concepts from user perspective might be a bit too much complication though. I'm definitely one that would advocate for making it actively _difficult_ to use APIs wrong. It can be challenging to do, but given a large enough pool of users you will _for sure_ encounter a bunch which find some way to use it wrong. 😅

[03:11:10.0047] <Stephen Belanger>
The less footguns we can give users the better. 🙈

[05:26:43.0742] <Stephen Belanger>
If we have instance-scoped bind, should we give the instance and global versions different but related names to make the intent a bit more clear? Something like `instance.bind(...)` and `Variable.bindAllVariables(...)` or something like that?

[06:04:57.0955] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> And this is also why I would like to have per-instance bind because sometimes it makes sense globally like connection pools, but sometimes opinions may vary.

This per-instance bind sounds like a requirement after the behavior is defined as flowing out to the outer scope. In the current form, this example would not be a problem:
```js
async function someFunctionYouCareAboutTracing() {
	const response1 = await fetch(...);
	await someAPI();  // this scope can not be modified by this call
	const response2 = await fetch(...);
	return await doSomethingWith(response1, response2);
}
```

[06:05:33.0635] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> And this is also why I would like to have per-instance bind because sometimes it makes sense globally like connection pools, but sometimes opinions may vary.

 * This per-instance bind sounds like a requirement after the behavior is defined as flowing out to the outer scope. In the current form, this example would not be a problem:

```js
async function someFunctionYouCareAboutTracing() {
	const response1 = await fetch(...);
	await someAPI();  // the current context will not be modified by this call
	const response2 = await fetch(...);
	return await doSomethingWith(response1, response2);
}
```

[06:06:12.0325] <Chengzhong Wu>
which is what we want to avoid as dynamic scope

[06:08:33.0433] <Chengzhong Wu>
 * the problem also seems to be what we want to avoid as dynamic scope

[06:23:36.0051] <littledan>
> <@stephenbelanger:matrix.org> APMs (unfortunately) fairly often use `AsyncResource` to "fix" context management flows, but then we break other vendors because we change the graph _they_ were expecting. 😬

Do you have an example of this sort of fix, and the costs and benefits of it, that we can look into?


2024-05-18
[22:16:48.0443] <Steve Hicks>
Catching up on a lot here. I think I'm starting to come around a bit more to Stephen's perspective w.r.t. context flowing out from resolves.  I think he's right that, in general (when people do the right thing) it ends up maintaining the same root for the context tree, since the resolved promise generally comes from earlier in the same scope, and I like the fact that it aligns the opt-in for registration time with something that's actually quite reasonable to implement. I believe it's also pretty trivial to do a paranoid await-wrapping: `await bindTask(() => untrustedApi())` which would guarantee the untrustedApi can't change the context on you. Where it still feels wrong to me is Andreu's concern. The really nice property in the current proposal is that it's really well encapsulated. Context variable behave just like lexical consts, where you have guarantees that anything you can't see can never change them out from under you, and that's a _very attractive_ guarantee. Whereas the flows-out approach seems very brittle if any single bad/careless actor anywhere in your downstream call chain is able to irretrievably break the flow. I think that's where this disconnect is coming from - the encapsulation purists in the group are very hesitant to give up that guarantee.

I wonder if there's some middle ground where you could at least detect when an abrupt context change has occurred? For instance, I could imagine something along the lines of `using _ = contextMonitor();` at the top of the function.  It could install a new variable and if it detected that the variable has changed at the end of the scope, it knows something fishy has happened. And if we're giving up the encapsulation, I suspect mutating variables with `using` might actually be reasonable as well...

[14:25:44.0623] <littledan>
If you are coming around to this point, do you have ideas about answers to the questions I was asking? Namely, what do we hope to get from merge points, which happen all the time?

[14:26:49.0727] <littledan>
Restoring around awaits isn’t purely losing information; it also maintains half of it which is also relevant 

[14:37:22.0881] <littledan>
I’d kinda suspect that application code would have pretty low uptake of things like bindTarget and contextMonitor. It’s hard for me to understand how an application developer should decide which of the two options is appropriate.


2024-05-19
[06:07:31.0520] <Stephen Belanger>
Here's a new issue from Matteo about the exact issue I'm talking about with await binding. I've seen this user confusion come up _a lot_. https://github.com/nodejs/node/issues/53037

[06:08:11.0396] <Stephen Belanger>
It happens to use `enterWith(...)` rather than `run(...)`, but the confusion around expected slow is effectively the same.

[06:26:33.0251] <Stephen Belanger>
> <@littledan:matrix.org> Do you have an example of this sort of fix, and the costs and benefits of it, that we can look into?

We use it all over the place in the Datadog tracer, though we've been gradually migrating away to doing context recovery using TracingChannel instead as we don't break other users and tracing products that way. The cost is not really much, and like I said _will_ happen whether we provide fast-paths for it or not--you can just do `store.get()` and `store.run(...)` in a closure, but then you're making a closure and doing some extra steps which could _probably_ be more optimizable as an instance-scoped bind method of some sort.

[06:28:42.0229] <Stephen Belanger>
> <@stephenhicks:matrix.org> Catching up on a lot here. I think I'm starting to come around a bit more to Stephen's perspective w.r.t. context flowing out from resolves.  I think he's right that, in general (when people do the right thing) it ends up maintaining the same root for the context tree, since the resolved promise generally comes from earlier in the same scope, and I like the fact that it aligns the opt-in for registration time with something that's actually quite reasonable to implement. I believe it's also pretty trivial to do a paranoid await-wrapping: `await bindTask(() => untrustedApi())` which would guarantee the untrustedApi can't change the context on you. Where it still feels wrong to me is Andreu's concern. The really nice property in the current proposal is that it's really well encapsulated. Context variable behave just like lexical consts, where you have guarantees that anything you can't see can never change them out from under you, and that's a _very attractive_ guarantee. Whereas the flows-out approach seems very brittle if any single bad/careless actor anywhere in your downstream call chain is able to irretrievably break the flow. I think that's where this disconnect is coming from - the encapsulation purists in the group are very hesitant to give up that guarantee.
> 
> I wonder if there's some middle ground where you could at least detect when an abrupt context change has occurred? For instance, I could imagine something along the lines of `using _ = contextMonitor();` at the top of the function.  It could install a new variable and if it detected that the variable has changed at the end of the scope, it knows something fishy has happened. And if we're giving up the encapsulation, I suspect mutating variables with `using` might actually be reasonable as well...

The bad actor changing your value is only a problem if you explicitly give them the store and let them _do_ that. If you just keep your stores private this is not a real problem.

[06:33:49.0639] <Stephen Belanger>
Also, the `using` syntax doesn't play particularly nice with async context as it not only crosses _over_ async barriers, but _also_ (as far as I'm aware) does nothing to signal any sort of change of state around awaits in its scope so if you, for example, mutate a global in whatever the `using` is doing and then expect it to restore the value when the use expires it may _also_ be required that the value is altered to match the appropriate value between async code, so I expect that is going to be a bit of a footgun when combined with async code.

[06:36:16.0661] <Stephen Belanger>
> <@littledan:matrix.org> If you are coming around to this point, do you have ideas about answers to the questions I was asking? Namely, what do we hope to get from merge points, which happen all the time?

I have less of a specific intuition on what to do about merge points, though as I have expressed previously I care a lot less about what merges look like as that just produces a _mildly_ incorrect execution flow graph while the await binding produces a _very_ incorrect flow graph which we have to do a bunch of work to patch around, which I described earlier with needing to store everything in a whole request trace and essentially _guess_ from which thing the current path is a continuation.

[06:36:42.0794] <Stephen Belanger>
 * It happens to use `enterWith(...)` rather than `run(...)`, but the confusion around expected flow is effectively the same.

[06:47:49.0415] <Stephen Belanger>
> <@legendecas:matrix.org> This per-instance bind sounds like a requirement after the behavior is defined as flowing out to the outer scope. In the current form, this example would not be a problem:
> 
> ```js
> async function someFunctionYouCareAboutTracing() {
> 	const response1 = await fetch(...);
> 	await someAPI();  // the current context will not be modified by this call
> 	const response2 = await fetch(...);
> 	return await doSomethingWith(response1, response2);
> }
> ```

So I would say the generally _encouraged_ way to do binds should be instance-scoped by default and global bind should only ever be a "Are you _sure_ you know what you're doing?" type of API for the power-user cases like module authors making sure their resource pool will not leak implementation details that would never be relevant to user code execution flow. Pool mechanisms I would say are almost universally okay to bind globally, but almost _every_ other scenario is a matter of opinion and should (at least in my opinion) probably not bind at all by default and always follow that path through internals because otherwise you end up with these strange flows like with async/await not flowing _through_ awaits the way most users seem to expect.

[07:10:57.0643] <Stephen Belanger>
Also, I'd _really_ appreciate if people reconsidered much of what James M Snell was was saying in https://github.com/nodejs/node/issues/46262. As far as people that understand the issues of context flow, he's one of very few others I'd trust to understand this stuff, having done a _bunch_ of work on the Cloudflare equivalent of AsyncLocalStorage.


2024-05-20
[22:14:33.0062] <Steve Hicks>
> <@stephenbelanger:matrix.org> The bad actor changing your value is only a problem if you explicitly give them the store and let them _do_ that. If you just keep your stores private this is not a real problem.

I don't think that's right. Simply restoring a global snapshot is enough. If the subtask you're awaiting resolves its promise in a context that didn't derive from the one that was active when you called it, then you've lost your state even though it didn't have access to your variable.

[22:24:14.0023] <Steve Hicks>
> <@stephenbelanger:matrix.org> So I would say the generally _encouraged_ way to do binds should be instance-scoped by default and global bind should only ever be a "Are you _sure_ you know what you're doing?" type of API for the power-user cases like module authors making sure their resource pool will not leak implementation details that would never be relevant to user code execution flow. Pool mechanisms I would say are almost universally okay to bind globally, but almost _every_ other scenario is a matter of opinion and should (at least in my opinion) probably not bind at all by default and always follow that path through internals because otherwise you end up with these strange flows like with async/await not flowing _through_ awaits the way most users seem to expect.

I found this initially surprising, but I'm wondering if this actually makes more sense under the "flow through await" scenario. With preserve-around-await semantics and default registration-time binding, you end up needing a bunch of global binds just to get reasonable behavior. Again, my axiom here is that application code and library/framework code shouldn't need to be aware of each other's variables in order to do the right thing. With preserve-around-await, global binds seems like generally the thing you need to uphold that axiom. But with flow-through-await, I can imagine that maybe that's no longer required, provided you're not somehow picking up promises that came from vastly different contexts, which seems generally unlikely to happen in most common situations.

[01:15:04.0735] <Stephen Belanger>
> <@stephenhicks:matrix.org> I don't think that's right. Simply restoring a global snapshot is enough. If the subtask you're awaiting resolves its promise in a context that didn't derive from the one that was active when you called it, then you've lost your state even though it didn't have access to your variable.

Well, yes, global snapshots are bad, which is why they should be discouraged except when absolutely necessary. If you flow _through_ rather than _around_ things then it's _generally_ most advisable to actually bind-per store to only do graph reductions where needed whereas trying to bind _around_ things all over the place takes way more binds and is often inescapable.

It's a lot better to just let things flow _through_ by default and then provide some additional tools to reduce the graph where necessary. In general cases this is just the bind method, but for awaits it might make sense to have a store option to make it auto-bind on awaits or something like that. I _personally_ feel it makes a lot more sense for await binds to be an option rather than a default we need to find a way out of, but I don't care _too_ much either way, so long as the tools can do what is needed in a reasonable way.

[03:58:41.0788] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> Here's a new issue from Matteo about the exact issue I'm talking about with await binding. I've seen this user confusion come up _a lot_. https://github.com/nodejs/node/issues/53037

I think the confusion in the issue was caused by the difference of AsyncLocalStorage behavior around the timing of enabling promise hooks.

[03:59:59.0592] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> Here's a new issue from Matteo about the exact issue I'm talking about with await binding. I've seen this user confusion come up _a lot_. https://github.com/nodejs/node/issues/53037

 * I think the confusion in the issue was caused by the difference of AsyncLocalStorage behavior around the timing of enabling promise hooks. Enabling promise hooks before and after a promise creation/resolution would change how AsyncLocalStorage propagates a value is a problem.

[04:00:20.0115] <Chengzhong Wu>
 * I think the confusion in the issue was caused by the difference of AsyncLocalStorage behavior around the timing of enabling promise hooks. Enabling promise hooks before and after a promise creation/resolution would change how AsyncLocalStorage propagates a value is a problem on either semantics.

[04:28:28.0964] <Stephen Belanger>
It's not _just_ the timing of enabling PromiseHook. It is that the portion of an async function _before_ the first await behaves differently from the rest of the function because the context capture will have already happened around the outer await before passing over the inner awaits. It's confusing to users that the context is not flowing out.

[04:29:12.0223] <Stephen Belanger>
Regardless of timing inconsistencies, the user is clearly _expecting_ that they should be able to retrieve the context set after an await within the async function.

[04:29:35.0571] <Stephen Belanger>
 * Regardless of timing inconsistencies, the user is clearly _expecting_ that they should be able to retrieve the context set after an await within the inner async function from the outer async function.

[04:29:46.0420] <Stephen Belanger>
 * Regardless of timing inconsistencies, the user is clearly _expecting_ that they should be able to retrieve the context set after an await within the inner async function from the outer async function (or module scope, in this case).

[04:44:54.0998] <littledan>
Wait, the init hook isn’t flowing out, it  is a third thing

[05:06:53.0609] <littledan>
why are global snapshots bad?

[05:06:58.0230] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> It's not _just_ the timing of enabling PromiseHook. It is that the portion of an async function _before_ the first await behaves differently from the rest of the function because the context capture will have already happened around the outer await before passing over the inner awaits. It's confusing to users that the context is not flowing out.

The proposal as it current stands is maintaining the lexical consistent value inside a async function body across `await` for `AsyncContext.Variable`, which is part of the approach aiming to address the dynamic scope concerns from the previous meeting's feedback.

[05:10:18.0862] <littledan>
> <@stephenbelanger:matrix.org> It happens to use `enterWith(...)` rather than `run(...)`, but the confusion around expected flow is effectively the same.

What? I think "restore after await" would equally fix that bug (though agree that flows-out works here as well)

[05:10:30.0202] <Stephen Belanger>
> <@littledan:matrix.org> why are global snapshots bad?

They're not _bad_ exactly, just should not be the _default_ tool people reach for as it means they are influencing the graphs of _every_ store which, more often than not (in my experience with ALS users), is not actually what you want.

[05:11:49.0608] <Stephen Belanger>
There should be clearly communicated difference between "This is a universally applicable binding point." and "I want _my_ context to flow in this way."

[05:13:05.0227] <Stephen Belanger>
> <@legendecas:matrix.org> The proposal as it current stands is maintaining the lexical consistent value inside a async function body across `await` for `AsyncContext.Variable`, which is part of the approach aiming to address the dynamic scope concerns from the previous meeting's feedback.

Yes, and I still don't understand why we are going for lexical scope given that, as far as I've seen, everyone is expecting it to follow execution flow.

[05:13:56.0978] <Stephen Belanger>
I don't know what the concerns were with dynamic scope. Is information that captured somewhere?

[05:14:52.0494] <littledan>
> <@stephenbelanger:matrix.org> Also, I'd _really_ appreciate if people reconsidered much of what James M Snell was was saying in https://github.com/nodejs/node/issues/46262. As far as people that understand the issues of context flow, he's one of very few others I'd trust to understand this stuff, having done a _bunch_ of work on the Cloudflare equivalent of AsyncLocalStorage.

Yeah, James was working closely with us when he filed that issue, and the current spec reflects what he is proposing with respect to rejection. I may have misunderstood his comments on resolving (as you can see in the thread); I guess we should get back in touch to understand his point of view better.

[05:15:02.0600] <Stephen Belanger>
> <@littledan:matrix.org> What? I think "restore after await" would equally fix that bug (though agree that flows-out works here as well)

It _is_ doing "restore after await" as that is how PromiseHook _works_. That's precisely the _problem_ here is that the user is assuming the context value will flow out of the awaited promises into the scope in which it was awaited.

[05:15:30.0809] <littledan>
we are definitely not doing lexical scope in general. There are definitely cases where some other relevant snapshot is used.

[05:15:56.0666] <littledan>
people have suggested things like "how about all callbacks just automatically close over the context" and this is broken and not what is proposed.

[05:16:22.0298] <Stephen Belanger>
Yeah, it seems like the flow is entirely reasonable with callbacks. I just don't understand why logically equivalent flows with promises and async/await don't flow in the same way. That seems extremely confusing to me.

[05:16:44.0894] <Stephen Belanger>
> <@littledan:matrix.org> people have suggested things like "how about all callbacks just automatically close over the context" and this is broken and not what is proposed.

Broken in what way?

[05:17:06.0600] <littledan>
well, as you've been saying, sometimes it loses important information

[05:17:30.0809] <Stephen Belanger>
Any callback for an async task _should_ flow context through it.

[05:17:47.0805] <littledan>
but also sometimes the registration context *is* the most relevant one (often it's the only possible one)

[05:18:17.0100] <Stephen Belanger>
But to be clear I mean _through_ and not _around_, which is what binding does rather than just capturing at the edges.

[05:19:07.0472] <Stephen Belanger>
In Node.js we intentionally push capturing to as _close_ to the edges as possible, meaning binding on the internal AsyncWrap type callbacks, so context flows through all the internals to get there.

[05:19:32.0375] <Stephen Belanger>
We could have bound the user callbacks directly instead, but then we would miss all that internal behaviour which may be relevant.

[05:20:44.0145] <littledan>
I've asked two questions that I don't yet know the answer to:
- How are we handling merges, given that both contexts are often relevant (and in general this forms a big tree--there are more than two relevant things)?
- How could per-variable handling scale, when you have a lot of different libraries and a lot of different variables and they're all supposed to fit together? It's easier for me to understand "two classes of variables".

[05:20:55.0600] <Stephen Belanger>
> <@littledan:matrix.org> but also sometimes the registration context *is* the most relevant one (often it's the only possible one)

I have never found that with ALS. The appropriate place to do "resolve" path _does_ get pushed a bit out sometimes though. Like if the resolve is in C++ internals somewhere then it gets pushed back to whatever call ran the C++ code which _led_ to that resolve.

[05:21:30.0374] <littledan>
> <@stephenbelanger:matrix.org> I have never found that with ALS. The appropriate place to do "resolve" path _does_ get pushed a bit out sometimes though. Like if the resolve is in C++ internals somewhere then it gets pushed back to whatever call ran the C++ code which _led_ to that resolve.

For example, in setTimeout, there's nothing to do but restore the snapshot from when it was previously called

[05:21:53.0352] <Stephen Belanger>
Everything _always_ has some cause _somewhere_.

[05:22:07.0778] <littledan>
sure, the cause is often the registration time

[05:22:17.0221] <littledan>
so we're not necessarily disagreeing on the semantics

[05:22:43.0193] <littledan>
you wouldn't want internals of the scheduler to be understood as the cause, though--that would scramble information

[05:22:52.0672] <Stephen Belanger>
It's not that `setTimeout` needs to be registration time. It's that registration and scheduling time happen at the same time in some case. But it's not the registering of a callback which you actually _care_ about, it's the path that led to it being _called_.

[05:23:46.0166] <littledan>
> <@stephenbelanger:matrix.org> It's not that `setTimeout` needs to be registration time. It's that registration and scheduling time happen at the same time in some case. But it's not the registering of a callback which you actually _care_ about, it's the path that led to it being _called_.

sure, yes I agree these are the semantics we are going for. As I've been saying, the "registration time vs call time" framing is not helpful. Instead, it's more like the organizing principle is, "preserve relevant information".

[05:24:04.0177] <littledan>
which sometimes means "registration time" in the terms we've been using

[05:24:33.0252] <littledan>
let's think about better ways to call this; there's just no debate about what setTimeout does

[05:25:20.0424] <Andreu Botella>
the cases where this distinction matters are cases where the "scheduling time" is at the start of the agent before any JS code can run – in which case the agent is necessarily empty, and necessarily preserves *no* relevant information

[05:25:49.0012] <littledan>
we should not be in the business of running anything with an empty context ever IMO. That would preclude many important context use cases.

[05:26:53.0011] <Stephen Belanger>
Yep, so I've found the way to do that effectively is to look _specifically_ at where synchronous execution _stops_ and tasks are stored to return to later in some way. In Node.js we create handle objects and, generally, the creation of those objects captures context and the callback is registered at that same point.

The reason we capture at _this_ specific point though is because we don't have _native_ context. If we _did_ then the _actual_ correct point would be where it queues the kernel task and should flow all the way up to that point and then capture context to restore when the kernel task comes back. For _complete_ context flow you want to be as close to those edges as possible.

[05:27:08.0815] <Andreu Botella>
> <@littledan:matrix.org> we should not be in the business of running anything with an empty context ever IMO. That would preclude many important context use cases.

I assume you mean we shouldn't be running anything that could not possibly have any data flow from the initial execution of the script or later, right?

[05:27:30.0505] <Andreu Botella>
because the initial execution will have an empty context, and that context might flow to places

[05:28:34.0666] <Stephen Belanger>
Everything in the process has a _cause_ and therefore should always have a parent to flow from. The top-level flows from the fact of the process starting, which maybe doesn't have a "value" per-se, but I think that is probably the clearest expression of never having an "empty" context.

[05:28:38.0874] <littledan>
> <@abotella:igalia.com> because the initial execution will have an empty context, and that context might flow to places

oh, sure. to make what I'm saying concrete, I mean: the host should be able to put some internal variables in that initial context, and then be able to rely on their presence; JS itself should never be creating an empty context.

[05:29:34.0312] <littledan>
> <@stephenbelanger:matrix.org> Everything in the process has a _cause_ and therefore should always have a parent to flow from. The top-level flows from the fact of the process starting, which maybe doesn't have a "value" per-se, but I think that is probably the clearest expression of never having an "empty" context.

cool, sounds like we're all agreeing, "JS shouldn't create empty contexts". This doesn't resolve the "two causes" point which your document so clearly lays out.

[05:31:29.0008] <Stephen Belanger>
Context is basically just a mirror of the directed acyclic graph expressing the flow of the code of the entire process. That then has reductions applied to carve paths around any irrelevant implementation details. Some things are _universally_ irrelevant, like you'll want microtasks to flow context in a fairly universal way, but as things get to higher levels of abstraction from the instructions running on the cpu the more path decisions become subjective.

[05:32:09.0775] <littledan>
> <@littledan:matrix.org> I've asked two questions that I don't yet know the answer to:
> - How are we handling merges, given that both contexts are often relevant (and in general this forms a big tree--there are more than two relevant things)?
> - How could per-variable handling scale, when you have a lot of different libraries and a lot of different variables and they're all supposed to fit together? It's easier for me to understand "two classes of variables".

still looking forward to answers to these questions

[05:32:12.0390] <Stephen Belanger>
> <@littledan:matrix.org> cool, sounds like we're all agreeing, "JS shouldn't create empty contexts". This doesn't resolve the "two causes" point which your document so clearly lays out.

Are you referring to call versus continuation context in my doc?

[05:32:25.0318] <littledan>
yes

[05:32:34.0458] <littledan>
(I think)

[05:32:47.0473] <Stephen Belanger>
Ah, I've said a few times that particular point is far less critical than the ability to flow through awaits.

[05:33:17.0713] <Stephen Belanger>
The call versus continuation context thing is basically just differentiating between the sync code within a `store.run(...)` from anything it has propagated that context into.

[05:33:35.0396] <littledan>
in the terms you set up, it sounds like you're saying, "we should switch from call to continuation when it comes to await"

[05:34:15.0470] <littledan>
and what I'm missing is the understanding of why that's not a meaningful loss of information (given that it's useful for establishing a certain sense of parentage)

[05:34:53.0403] <Stephen Belanger>
We create a span and store it in the context with `store.run(span, ...)`. If inside the function given to that we then _immediately_ create another span because some _other_ instrumented function was called synchronously, we would consider that a child-of relationship and link that accordingly. But if it happened within an async continuation then it is a follows-from relationship. So we differentiate the sync code from the continuations.

[05:35:57.0579] <Stephen Belanger>
We can do that easily enough by just wrapping the store runs with a global flag like this: https://gist.github.com/Qard/6ceaca8bb792679e82c7693513baee0e/#file-span-js-L66-L70

[05:36:33.0340] <Andreu Botella>
wait, if we go with resolution context, and we don't change how the current API works otherwise, we'd run into this. Is this what we want?
```js
await asyncVar.run("foo", async () => {
    await doSomethingHere();
});

console.log(asyncVar.get()) // "foo"
```

[05:37:54.0474] <Stephen Belanger>
So it's not _critical_ that the API does the whole two paths thing. Like I've said before, what is in my doc is essentially the ideal from APM perspective, but quite possibly has things which shouldn't actually exist at language level and should just be done externally. But we're aiming for a balance that anything we need to do externally is as low-cost as possible, because what we have _right now_ is _very_ expensive.

[05:38:27.0038] <Stephen Belanger>
> <@abotella:igalia.com> wait, if we go with resolution context, and we don't change how the current API works otherwise, we'd run into this. Is this what we want?
> ```js
> await asyncVar.run("foo", async () => {
>     await doSomethingHere();
> });
> 
> console.log(asyncVar.get()) // "foo"
> ```

Yes. That is actually what users keep telling me they are _expecting_.

[05:38:41.0847] <Andreu Botella>
> <@stephenbelanger:matrix.org> Yes. That is actually what users keep telling me they are _expecting_.

that is a very different behavior from the sync case

[05:38:57.0901] <littledan>
I know about the expense of PromiseHooks and patching all the libraries (which we all definitely want to resolve); what kind of expense is related to this issue that you're talking about now?

[05:39:01.0638] <Stephen Belanger>
The issue posted earlier is a user expecting that, and I get people making the same complaint about ALS someone or other every other week or so.

[05:39:37.0426] <littledan>
I'm pretty sure if we'll get a bunch of complaints in the other direction if you change it; this is just a difficult feature to have any intuition for

[05:39:50.0156] <littledan>
(that's not an argument one way or another0

[05:40:07.0000] <Stephen Belanger>
> <@littledan:matrix.org> I know about the expense of PromiseHooks and patching all the libraries (which we all definitely want to resolve); what kind of expense is related to this issue that you're talking about now?

Just the general expense of _all_ the stuff we have to do. Like I pointed out before that we presently need to keep a list of all spans in-memory from the lifetime of the whole request as we don't know how to do follows-from relationships otherwise.

[05:40:34.0012] <Andreu Botella>
```js
function syncCase() {
    asyncVar.run("foo", () => {
        doSomethingHere()
    });

    console.log(asyncVar.get());  // undefined
}

async function asyncCase() {
    await asyncVar.run("foo", async () => {
        await doSomethingHere()
    });

    console.log(asyncVar.get());  // "foo"
}
```

[05:41:14.0981] <Stephen Belanger>
> <@abotella:igalia.com> that is a very different behavior from the sync case

It is, but it's _identical_ to how the same code rewritten with callbacks flows, and that's the confusion users are running into. We keep seeing people rewriting their apps with promises and then being confused when the context doesn't flow the way they're used to anymore.

[05:41:21.0355] <littledan>
> <@stephenbelanger:matrix.org> Just the general expense of _all_ the stuff we have to do. Like I pointed out before that we presently need to keep a list of all spans in-memory from the lifetime of the whole request as we don't know how to do follows-from relationships otherwise.

oh right, this part. I don't get it, can't you offload that processing to happen later? or this would require a change in the Otel protocol?

[05:42:30.0523] <Stephen Belanger>
It would require a change in the OTel spec which they've basically said _unequivocally no_ to ever changing. 😐️

[05:42:35.0687] <Andreu Botella>
> <@stephenbelanger:matrix.org> It is, but it's _identical_ to how the same code rewritten with callbacks flows, and that's the confusion users are running into. We keep seeing people rewriting their apps with promises and then being confused when the context doesn't flow the way they're used to anymore.

sure, people rewriting code from callbacks to promises might prefer resolution time, but what about people writing async/await code from scratch? Do we know what they need? Would we be breaking them?

[05:43:17.0802] <littledan>
> <@stephenbelanger:matrix.org> It is, but it's _identical_ to how the same code rewritten with callbacks flows, and that's the confusion users are running into. We keep seeing people rewriting their apps with promises and then being confused when the context doesn't flow the way they're used to anymore.

is this always the form of this sort of migration, or do people also have this confusion with greenfield promise apps?

[05:43:40.0533] <Stephen Belanger>
Well, as I said the other day, if we follow resolution path that follows a causation path from the creation of the promise so we still actually get the same context flow unless someone goes and changes the context in the middle.

[05:43:45.0461] <littledan>
> <@stephenbelanger:matrix.org> It would require a change in the OTel spec which they've basically said _unequivocally no_ to ever changing. 😐️

Can you say more about the interactions with upstream OTel folks? Has anyone offered to make an efficient open-source collector to actually take advantage of this protocol improvement?

[05:44:52.0853] <Andreu Botella>
> <@stephenbelanger:matrix.org> Well, as I said the other day, if we follow resolution path that follows a causation path from the creation of the promise so we still actually get the same context flow unless someone goes and changes the context in the middle.

in the web specs there are cases where you can get a promise from somewhere else, that wasn't created in a data flow starting from the current function

[05:45:00.0411] <Andreu Botella>
> <@stephenbelanger:matrix.org> Well, as I said the other day, if we follow resolution path that follows a causation path from the creation of the promise so we still actually get the same context flow unless someone goes and changes the context in the middle.

 * in web APIs there are cases where you can get a promise from somewhere else, that wasn't created in a data flow starting from the current function

[05:45:09.0720] <Stephen Belanger>
> <@littledan:matrix.org> is this always the form of this sort of migration, or do people also have this confusion with greenfield promise apps?

I see the same confusion with people doing this with new projects too. Moreso from conversions, but also our customers tend to be enterprises that have ancient codebases they've been maintaining forever, so there's a clear bias to who we're talking to regularly.

[05:45:36.0594] <littledan>
and all customer complaints are private? Can you talk with any of them and ask them if they'd be willing to be in touch with us?

[05:46:10.0136] <Stephen Belanger>
> <@littledan:matrix.org> Can you say more about the interactions with upstream OTel folks? Has anyone offered to make an efficient open-source collector to actually take advantage of this protocol improvement?

Can't be done in the collector because the data is needed in-process for distributed tracing headers wherever outgoing activity may occur.

[05:48:01.0907] <Stephen Belanger>
> <@abotella:igalia.com> in web APIs there are cases where you can get a promise from somewhere else, that wasn't created in a data flow starting from the current function

True, but then it wasn't _caused_ by that function so probably should still be keeping the registration context. And in any case this is what bind is for--in exceptional cases a user (or possibly even the runtime sometimes) can decide to apply a bind to capture the context at a _different_ point.

[05:48:51.0887] <littledan>
> <@stephenbelanger:matrix.org> Can't be done in the collector because the data is needed in-process for distributed tracing headers wherever outgoing activity may occur.

maybe I'm using the wrong terms, but it sounds like you had some idea for an improvement which was rejected. What was the idea, and how was it proposed?

[05:49:02.0097] <Andreu Botella>
how would you bind a promise?

[05:49:18.0151] <Stephen Belanger>
> <@littledan:matrix.org> and all customer complaints are private? Can you talk with any of them and ask them if they'd be willing to be in touch with us?

Yes, I'm trying to talk with some of them right now. Getting time from enterprises to talk about things like this can be a bit time-consuming so we'll see how that goes...

[05:49:35.0756] <littledan>
> <@stephenbelanger:matrix.org> Yes, I'm trying to talk with some of them right now. Getting time from enterprises to talk about things like this can be a bit time-consuming so we'll see how that goes...

thanks, I appreciate that

[05:51:30.0609] <Stephen Belanger>
> <@littledan:matrix.org> maybe I'm using the wrong terms, but it sounds like you had some idea for an improvement which was rejected. What was the idea, and how was it proposed?

I've had some conversations with them about the current shape of _their_ context management system. It's _not_ multi-tenant and instead carries everything in one big immutably-cloned map tree thing, which adapts very poorly to AsyncLocalStorage, but they refuse to change it because spec says it should work this certain way and seem to believe they got everything right on the first try so nothing can ever change. 😐️

[05:51:40.0141] <Stephen Belanger>
The API is _super_ convoluted.

[05:52:47.0017] <Stephen Belanger>
The context is a map, which you make clones of every time you attempt to modify it, but modifying it doesn't change what the _active_ value is, it just changes what's in your copy. Then you can eventually _activate_ it and it will give you a token to deactivate it at some later point.

[05:53:42.0663] <littledan>
...that sounds analogous semantically to what we have

[05:53:57.0281] <Stephen Belanger>
_Sort of_...but inside out.

[05:54:01.0256] <littledan>
where can I learn more about their context system and the discussion around changing it?

[05:54:13.0437] <Stephen Belanger>
You pass around the contexts yourself rather than the system managing it for you.

[05:54:20.0469] <Andreu Botella>
> <@stephenbelanger:matrix.org> True, but then it wasn't _caused_ by that function so probably should still be keeping the registration context. And in any case this is what bind is for--in exceptional cases a user (or possibly even the runtime sometimes) can decide to apply a bind to capture the context at a _different_ point.

The APIs I'm thinking of are things like https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultReader/closed, or https://developer.mozilla.org/en-US/docs/Web/API/FontFaceSet/ready. I don't see how those could possibly made to work with resolution time, unless every user knows to work around them

[05:57:53.0680] <Stephen Belanger>
The ReadableStream `closed` thing seems like it would flow from whatever caused the close. Likely the final interaction, or if none is visible than just the creation of the stream itself.

The second seems to me like clearly the context would just be the root context as it causally flows from the document loading, as far as I can tell?

[05:58:41.0507] <Andreu Botella>
regardless of where they flow from, it's almost certainly not from the function in which they're awaited

[05:58:51.0632] <Andreu Botella>
so wouldn't that lose the context before the await?

[05:59:53.0103] <Stephen Belanger>
Probably, but that's what bind is for. 🤷

[06:00:13.0917] <littledan>
> <@stephenbelanger:matrix.org> You pass around the contexts yourself rather than the system managing it for you.

sure, so, what's the problem in practice with this? does it actually differ in what can be expressed?

[06:00:38.0089] <Stephen Belanger>
Could also possibly do some kind of special-casing that things which _would_ flow from somewhere that doesn't _have_ a context value could auto-bind differently or something like that.

[06:00:44.0149] <littledan>
> <@stephenbelanger:matrix.org> Probably, but that's what bind is for. 🤷

we should anticipate that most people don't know how to use bind most of the time and just won't use it, IMO.

[06:01:26.0091] <Stephen Belanger>
It's single-tenant and you pass the entire map around. It's basically like if only `AsyncContext.Snapshot` existed and `AsyncContext.Variable` did not.

[06:01:53.0593] <littledan>
OK, so OTel just uses one variable, that seems fine to me

[06:02:05.0915] <littledan>
I'm not yet understanding where things mismatch

[06:02:20.0904] <littledan>
did you ever explain this mismatch to them in writing?

[06:02:37.0336] <Stephen Belanger>
It's not that it's just one variable. It's _multiple_ variables, but they're all living in a single map you have to pass around yourself.

[06:03:04.0607] <Stephen Belanger>
> <@littledan:matrix.org> did you ever explain this mismatch to them in writing?

In Slack conversations.

[06:04:42.0798] <Stephen Belanger>
The problem is in the mutable cloning thing. You're basically passing around many clones and you "activate" a particular clone at some point in time, so it's essentially like you're manually passing around a bunch of these snapshots all over the place manually, but still doing the same step of making it the "active" value it has stored globally.

[06:04:59.0297] <Stephen Belanger>
 * The problem is in the mutable cloning thing. You're basically passing around many clones and you "activate" a particular clone at some point in time, so it's essentially like you're passing around a bunch of these snapshots all over the place manually, but still doing the same step of making it the "active" value it has stored globally.

[06:06:53.0076] <littledan>
> <@stephenbelanger:matrix.org> The problem is in the mutable cloning thing. You're basically passing around many clones and you "activate" a particular clone at some point in time, so it's essentially like you're passing around a bunch of these snapshots all over the place manually, but still doing the same step of making it the "active" value it has stored globally.

I don't see how that differs meaningfully from what we have

[06:06:53.0700] <Stephen Belanger>
Rather than holding values separately it stores them all together in this giant map and then lets you pass it around yourself, which means you have to be sure the flow is correct for _all_ the types of data within the store or you can cause problems.

[06:07:00.0359] <shaylew>
> <@littledan:matrix.org> we should anticipate that most people don't know how to use bind most of the time and just won't use it, IMO.

(that or only kind of know how to use bind, and end up using it defensively because they don't know which promises they can't await without breaking their context... meaning they break anything that relies on the causal-but-not-scoped propagation out of an `await`)

[06:07:29.0395] <littledan>
> <@shaylew:matrix.org> (that or only kind of know how to use bind, and end up using it defensively because they don't know which promises they can't await without breaking their context... meaning they break anything that relies on the causal-but-not-scoped propagation out of an `await`)

yes it would be horrible if people felt like they had to use bind defensively everywhere... what would the point be

[06:09:30.0548] <Stephen Belanger>
> <@littledan:matrix.org> I don't see how that differs meaningfully from what we have

The main difference is the activation token thing. You don't _replace_ the context, you activate any given context and get a token back when you do which you can call another API at some later point to deactivate it.

[06:10:19.0378] <Stephen Belanger>
It doesn't have any sort of `store.run(...)` scope, it just sets it for linear time and you manage it yourself.

[06:10:50.0802] <littledan>
so are there any usages of this API which are not "well-balanced"?

[06:11:15.0996] <littledan>
also at what level does this API exist? Is it just conceptual, or is it an actual thing in code which must be implemented per spec?

[06:11:50.0895] <Stephen Belanger>
It's an actual thing in code, and it's left to the user so there is most certainly misuses of it in the wild.

[06:14:00.0964] <littledan>
I see. Where is this implemented?

[06:20:37.0979] <James M Snell>
Sorry I missed a large chunk of this conversation but I can expand a bit more on the await/resolve/reject issue. The key problem is sometimes what you really want is *both*. That is, sometimes after a promise settles, what you want is whatever the context was before you started waiting for it (resolve or reject), and sometimes what you want is whatever the context was when it was settled (resolve or reject). And sometimes you might actually want both at the same time

[06:21:38.0158] <littledan>
> <@jasnell:matrix.org> Sorry I missed a large chunk of this conversation but I can expand a bit more on the await/resolve/reject issue. The key problem is sometimes what you really want is *both*. That is, sometimes after a promise settles, what you want is whatever the context was before you started waiting for it (resolve or reject), and sometimes what you want is whatever the context was when it was settled (resolve or reject). And sometimes you might actually want both at the same time

Yeah, I can see how both are relevant. But also, you need to be right there to "catch" both of them before the next context inheritance happens (and presumably you'd choose one of them at that point), right?

[06:24:20.0403] <Stephen Belanger>
> <@littledan:matrix.org> I see. Where is this implemented?

All over the place, sadly. It starts [here](https://github.com/open-telemetry/opentelemetry-js/blob/main/api/src/context/context.ts) and then gets "activated" all over the place in instrumentation code or user code in various ways.

[06:25:40.0121] <Stephen Belanger>
It's concept of "multi-tenancy" is just using symbol keys into the one big map.

[06:25:44.0109] <James M Snell>
Well, the choosing bit is difficult. Users don't always have the info the decide which to choose

[06:26:28.0011] <Stephen Belanger>
Yeah, the _choosing_ part is specifically why I created the diagnostics channel integration.

[06:26:59.0454] <Stephen Belanger>
And have been pushing for something similar with my universal context management RFC.

[06:27:06.0501] <Stephen Belanger>
With WindowChannel.

[06:28:23.0984] <Stephen Belanger>
> <@stephenbelanger:matrix.org> Apologies for the delay in sharing these docs. I needed to prune some company-specific bits and navigate our convoluted process for making Google Docs actually public. 😅
> 
> The first doc is a bunch of explanation on the problems we have with existing attempts at context management and some possible solutions we're iterating on to solve these problems in a more flexible way. https://docs.google.com/document/d/1v8tMzV51Cuz32-60dhopoIMIxWfy_epOIRwoL5LmKVc/edit?usp=sharing
> 
> The second doc is partly relevant in that it describes an integration between the Diagnostics Channel concept and context management for the purpose of providing control to users to decide in which ways they want to propagate context for their specific store around particular points defined by library code as possibly interesting. https://docs.google.com/document/d/1DTZ2C5BKsoVRnU_ihyi93blF3cxXIbqqcIaSYurhBRk/edit?usp=sharing
> 
> I additionally have some slides from a recent internal talk I can also share which covers this overlap more briefly, and with specific examples. https://docs.google.com/presentation/d/1jYO45MudKGPOtir5hK0_wB7XS0D_ksLe4j5NvC8YfTc/edit?usp=sharing

I'm referring to the docs in the this comment specifically.

[06:28:38.0899] <Stephen Belanger>
 * I'm referring to the docs in this comment specifically.

[06:29:29.0935] <littledan>
> <@stephenbelanger:matrix.org> So it's not _critical_ that the API does the whole two paths thing. Like I've said before, what is in my doc is essentially the ideal from APM perspective, but quite possibly has things which shouldn't actually exist at language level and should just be done externally. But we're aiming for a balance that anything we need to do externally is as low-cost as possible, because what we have _right now_ is _very_ expensive.

James M Snell: would be great to get your take on this comment, outlining a possible policy to deal with the two contexts

[06:30:26.0033] <shaylew>
> <@littledan:matrix.org> so are there any usages of this API which are not "well-balanced"?

(See the warnings about rust `tracing::Span` in async code https://docs.rs/tracing/latest/tracing/span/struct.Span.html#in-asynchronous-code for some consequences of this sort of design in the wild -- but they're better off because Futures are expressive enough to write `Future::instrument` without needing built-in help)

[06:33:13.0399] <Stephen Belanger>
> <@littledan:matrix.org> James M Snell: would be great to get your take on this comment, outlining a possible policy to deal with the two contexts

These are two different issues. What James was referring to is the difference between register versus resolve path. What _I_ was referring to was not a _path_ thing _at all_ but rather just the different _points_ in context flow of the sync function a value is initially _set_ for and the continuations that value flows into.

[06:35:24.0761] <Stephen Belanger>
There is a function given to `store.run(...)` which runs synchronously. Any async tasks scheduled _within_ that function capture the value, but it's a different form of the value in that it was explicitly _set_ for that scope not _propagated_ to that scope.

[06:38:35.0952] <James M Snell>
I think I'll have to digest the conversation here a bit more to comment adequately. Give me a bit of time as my morning is just starting here and I'm finishing up a fairly busy on call week with a few remaining tasks. Should be able to jump in again later this morning

[07:10:03.0561] <James M Snell>
There's a lot in this thread to catch up on. Stephen Belanger can you indulge me with a bit of a tl;dr on your second issue here... the "What I was referring to..." part. Just want to make sure I'm groking what you're saying before I respond

[07:17:12.0779] <Stephen Belanger>
So I've been working on a plan for Tracing Channel splitting it internally into two separate "WindowChannel" types. One represents the call and the other represents the continuation. The same concept seemed at least _relevant_ here so I wanted to share the doc.

From OpenTelemetry perspective we have two types of span relationships: child-of and follows-from for sync and async children respectively. To tell when the span in a context is sync or async we can split the `store.run(...)` into a "call window" around the sync phase of running the function given to it and the then separate "continuation windows" around each continuation. This describes the context behaviour at the two points a bit differently so "call window" describes it as a _currently_ executing context to express that the wrapped function is still executing and should treat nested things as child-of related, and a "continuation window" describes it as a _propagated_ context to express that the original task function ran at some point in the past and the value for it in the context is now representing that the task is done and things may now want to link to it as a follows-from relationship.

[07:20:34.0566] <Stephen Belanger>
This could easily enough be done by just wrapping the `store.run(...)` to set a global flag around the given function to tell it if its currently running or not, but it keeps getting brought up for some reason even though I've been trying to explain a few times now that I'm not really concerned about that particular design idea but rather about the flowing _around_ awaits rather than _through_ them issue.

[07:21:26.0983] <Stephen Belanger>
Intuitively people are expecting context of promise code to flow similarly to equivalent callback code, but this is not the case as we bind to register time rather than resolve.

[07:23:41.0759] <James M Snell>
I want to make sure I'm understanding the distinction correctly between "flowing around" vs "flowing through" awaits. Do you have a quick code example to illustrate it. I think I know what you're saying just need to make sure

[07:24:03.0402] <James M Snell>
even if just pseudocode

[07:33:26.0204] <James M Snell>
And I'm sorry if you aleady did provide that example earlier... there's a lot of convo ^^ previously so difficult to find what was already discussed

[07:49:15.0763] <Stephen Belanger>
```js
const store = new AsyncLocalStorage()

async function foo() {
  store.getStore() // 2
}

async function main() {
  await store.run(2, foo)
  store.getStore() // 1 or 2?
}

store.run(1, main)
```

[07:49:37.0849] <Stephen Belanger>
So in this example, 1 is flowing _around_ and 2 is flowing _through_.

[07:51:27.0108] <Stephen Belanger>
Comparatively, here's the equivalent with callbacks:

```js
const store = new AsyncLocalStorage()

function foo(cb) {
  store.getStore() // 2
}

function main() {
  await store.run(2, foo, () => {
    store.getStore() // clearly should be 2
  })
}

store.run(1, main)
```

[07:51:42.0379] <Stephen Belanger>
 * Comparatively, here's the equivalent with callbacks:

```js
const store = new AsyncLocalStorage()

function foo(cb) {
  store.getStore() // 2
  cb()
}

function main() {
  await store.run(2, foo, () => {
    store.getStore() // clearly should be 2
  })
}

store.run(1, main)
```

[07:52:05.0570] <Stephen Belanger>
 * Comparatively, here's the equivalent with callbacks:

```js
const store = new AsyncLocalStorage()

function foo(cb) {
  store.getStore() // 2
  setImmediate(cb)
}

function main() {
  await store.run(2, foo, () => {
    store.getStore() // clearly should be 2
  })
}

store.run(1, main)
```

[07:53:05.0866] <Stephen Belanger>
 * Comparatively, here's the equivalent with callbacks:

```js
const store = new AsyncLocalStorage()

function foo(cb) {
  store.getStore() // 2
  setImmediate(cb)
}

function main() {
  store.run(2, foo, () => {
    store.getStore() // clearly should be 2
  })
}

store.run(1, main)
```

[07:54:40.0305] <Stephen Belanger>
Flowing _around_ is essentially just lexical scope which, to me, doesn't really seem to have much value. I've asked a few times for an explanation or some use case _why_ anyone would want that flow but have not yet got any answer on that. 🤔

[07:55:10.0930] <Stephen Belanger>
 * Flowing _around_ is essentially just local variable scope which, to me, doesn't really seem to have much value. I've asked a few times for an explanation or some use case _why_ anyone would want that flow but have not yet got any answer on that. 🤔

[07:55:31.0773] <Andreu Botella>
> <@stephenbelanger:matrix.org> Flowing _around_ is essentially just local variable scope which, to me, doesn't really seem to have much value. I've asked a few times for an explanation or some use case _why_ anyone would want that flow but have not yet got any answer on that. 🤔

it would be lexical scope *within a function*, but it propagates across function calls in a way that lexical scope doesn't

[07:55:51.0038] <littledan>
> <@stephenbelanger:matrix.org> Flowing _around_ is essentially just local variable scope which, to me, doesn't really seem to have much value. I've asked a few times for an explanation or some use case _why_ anyone would want that flow but have not yet got any answer on that. 🤔

this is a straw man, no one is proposing fully lexically scoped semantics, but rather sticking with how AsyncLocalStorage currently works

[07:57:17.0841] <Stephen Belanger>
> <@littledan:matrix.org> this is a straw man, no one is proposing fully lexically scoped semantics, but rather sticking with how AsyncLocalStorage currently works

I'm aware this is how AsyncLocalStorage presently works, and I have also stated that a bunch of times that how it works now should not be taken as any suggestion of _correctness_ as it mostly certainly _is not_ and has numerous well-known issues which have been discussed at length in the past.

[07:58:14.0307] <Stephen Belanger>
> <@abotella:igalia.com> it would be lexical scope *within a function*, but it propagates across function calls in a way that lexical scope doesn't

Yep, I understand how it flows, I just don't understand _why_ anyone would ever want it to flow in that particular way. As I said, I still have not had any specific use case explained to me for _why_ we elected to flow it in that way.

[07:58:19.0843] <James M Snell>
Got it. and yeah, that's what I suspected you meant :-) ... the answer is: whether it should be 1 or 2 depends on the storage cell is being used for. That is, In some cases what you want is `1` and others what you want is `2` . Even in your second example there using the callback, there are use cases where `store.getStore()` within the callback should not "clearly be 2".

[07:58:49.0915] <Stephen Belanger>
In the case of AsyncLocalStorage, it just flows that way because that's just what we were actually _able_ to do with the limited tools and resources we had available when building it.

[07:59:01.0655] <Stephen Belanger>
But it's _most certainly_ an imperfect API.

[07:59:03.0437] <littledan>
> <@jasnell:matrix.org> Got it. and yeah, that's what I suspected you meant :-) ... the answer is: whether it should be 1 or 2 depends on the storage cell is being used for. That is, In some cases what you want is `1` and others what you want is `2` . Even in your second example there using the callback, there are use cases where `store.getStore()` within the callback should not "clearly be 2".

One vague idea I've had is, should there be two kinds of variables, one which leans in one direction and one in the other? (sometimes there is only one choice though)

[08:00:00.0949] <littledan>
don't you think it's kinda curious that, after ALS was implemented, the V8 team separately made CPED for another couple use cases that Chrome had, and the semantics basically coincide?

[08:00:25.0466] <Stephen Belanger>
Yeah, I don't have a specific answer on what such a thing should look like, but there have been discussions like the parameter versus return flow thing, but I don't think that's quite right as we need it to flow _through_ which means _both_ ways. (At least for the tracing use case)

[08:00:27.0935] <James M Snell>
I've been stewing over that also... whether there should be two types of variables... haven't landed on anything concrete yet. Alternatively one variable with two storage cells is an option. Unfortunately the DX gets a bit muddled and complicated 

[08:01:12.0715] <Stephen Belanger>
My thinking was a per-store configuration or something to select which types of flows you want in a few specific cases.

[08:01:32.0549] <James M Snell>
by two storage cells I mean something like... (a) is the context value going in, (b) is the context value going out, both are accessible

[08:02:02.0710] <littledan>
> <@jasnell:matrix.org> by two storage cells I mean something like... (a) is the context value going in, (b) is the context value going out, both are accessible

that only works if you can run code in enough places (e.g., you'd want to inject logic into Promise.all, I think)

[08:02:42.0546] <Stephen Belanger>
That or just building out the tools so we can not only _reduce_ the graph with binds but _expand_ the graph back to the original paths with the inverse. (We've called that callingContext so far, but it's still very much up for debate.)

[08:05:00.0772] <James M Snell>
> <@littledan:matrix.org> that only works if you can run code in enough places (e.g., you'd want to inject logic into Promise.all, I think)

Yep. gets complicated very quickly

[08:05:37.0792] <littledan>
> <@stephenbelanger:matrix.org> That or just building out the tools so we can not only _reduce_ the graph with binds but _expand_ the graph back to the original paths with the inverse. (We've called that callingContext so far, but it's still very much up for debate.)

I don't get it, where does the logic live to enable that?

[08:05:44.0540] <Stephen Belanger>
The ideal _I've_ been aiming for separately is having _both_ context management _and_ diagnostics channel landing together with integration between the two and using the WindowChannel concept to handle the multiple paths problem, but clearly that's not really an option here where we have AsyncContext already at Stage 2 and _nothing_ for diagnostics channel yet in TC39. (or Web Perf, as Dan had suggested previously.)

[08:07:30.0556] <Stephen Belanger>
> <@littledan:matrix.org> I don't get it, where does the logic live to enable that?

Where the context is swapped by a `snapshot.run(...)`, we can just capture the context that had already flowed to that point and make that accessible in some way.

[08:08:21.0491] <Andreu Botella>
> <@stephenbelanger:matrix.org> In the case of AsyncLocalStorage, it just flows that way because that's just what we were actually _able_ to do with the limited tools and resources we had available when building it.

I'm surely missing some stuff here, but V8 gives you a `kResolve` promise hook, so wouldn't that give you the tools to flow the context through promise resolution?

[08:12:37.0109] <Stephen Belanger>
It's been a bit, but there was some complications with it being layered over async_hooks and async_hooks _not_ flowing that way.

[08:13:19.0932] <littledan>
> <@stephenbelanger:matrix.org> Where the context is swapped by a `snapshot.run(...)`, we can just capture the context that had already flowed to that point and make that accessible in some way.

yeah so this "just" part is a little vague for me. I guess Zones let you have a callback run at this point, and we've very deliberately avoided that.

[08:13:46.0537] <littledan>
> <@stephenbelanger:matrix.org> It's been a bit, but there was some complications with it being layered over async_hooks and async_hooks _not_ flowing that way.

it'd be interesting to go into the history of async_hooks to understand *why* they made that decision (which matches CPED)

[08:14:19.0052] <Stephen Belanger>
Because async_hooks is not about flow, it's about resource lifetimes.

[08:14:54.0562] <Stephen Belanger>
It just _happened_ to be that you could hack together a context manager of sorts on top of its events.

[08:15:21.0689] <littledan>
I thought context managers were always a primary use case of async_hooks

[08:16:54.0453] <Stephen Belanger>
Definitely not, no.

[08:17:32.0056] <Stephen Belanger>
Some adjustments were made to make it a bit less _crashy_ when trying to do that, but it was very much about resource tracking.

[08:19:11.0581] <Stephen Belanger>
async_hooks was created and then _years_ later core finally accepted that context management was actually a reasonable thing to want.

[08:36:21.0800] <James M Snell>
I think the two types of variables makes sense... but maybe with two distinct behaviors.. For this example I'm going to change up the terms a bit from what is currently spec'd and known. What the spec currently calls `AsyncContext.Variable`, I'm going to call `AsyncContext.Scope` instead... it's a thing that can be entered with a specific value. Then, what I'm calling `AsyncContext.Variable` in this example is a thing whose value can be set (similar to `enterWith` but that cannot be explicitly entered... the value is just retained as the context is propagated.

```
const store1 = new AsyncContext.Scope
const store2 = new AsyncContext.Variable

async function doSomething() {
  store2.set(`abc${store1.get()}`);
}

await Promise.all([
  store1.run(1, async () => { await doSomething(); console.log(store2.get()); // 'abc1' }),
  store1.run(2, async () => { await doSomething(); console.log(store2.get()); // 'abc2' }),
]);
console.log(store2.get()); // undefined ?
```

The key point is `store2` here is ot a context that can be entered but only a value that can be set at any point during a flow such that the value propagates through the flow


[08:36:37.0422] <James M Snell>
 * I think the two types of variables makes sense... but maybe with two distinct behaviors.. For this example I'm going to change up the terms a bit from what is currently spec'd and known. What the spec currently calls `AsyncContext.Variable`, I'm going to call `AsyncContext.Scope` instead... it's a thing that can be entered with a specific value. Then, what I'm calling `AsyncContext.Variable` in this example is a thing whose value can be set (similar to `enterWith` but that cannot be explicitly entered... the value is just retained as the context is propagated.

```
const store1 = new AsyncContext.Scope
const store2 = new AsyncContext.Variable

async function doSomething() {
  store2.set(`abc${store1.get()}`);
}

await Promise.all([
  store1.run(1, async () => { await doSomething(); console.log(store2.get()); // 'abc1' }),
  store1.run(2, async () => { await doSomething(); console.log(store2.get()); // 'abc2' }),
]);
console.log(store2.get()); // undefined ?
```

The key point is `store2` here is not a context that can be entered but only a value that can be set at any point during a flow such that the value propagates through the flow

[09:01:05.0316] <James M Snell>
With such an approach, an `AsyncContext.Scope` is really just a wrapper around `AsyncContext.Variable` that sets the value on enter and unsets it on exit, while the `AsyncContext.Variable` is just the actual stored value and caries it through the async flow. In this example, `store1` would have a `.run(...)` and a `.get()` but no `.set(...)` ... while `store2` would have a `.get()` and `.set(...)` but no `.run(...)`

[09:07:36.0076] <James M Snell>
or put another way, calling `.run(...)` on a `AsyncContext.Scope` creates and enters a new async context scope by copying the current map and setting the new value for the specific cell... while calling `.set()` on the `AsyncContext.Variable` only modifies the value for that cell in the current context scope map (basically splitting out ALS's concept of `enterWith()` ... which I'm not super excited about but ....)

[09:08:01.0244] <littledan>
I imagine that tracing would want to have one Variable and one Scope, right?

[09:08:13.0684] <littledan>
both are useful

[09:08:56.0932] <littledan>
actually I'm confused, I don't really understand why Variable is based on .set and not also .run

[09:09:09.0203] <littledan>
wouldn't .run be sufficient?

[09:10:49.0112] <James M Snell>
It could be... I think the difference comes down to being when I call `run(123, () => {})`, I expect the value `123` to only be accessible from within that callback passed and anything subordinate to that... not necessarily preserved once that scope exits

[09:11:56.0930] <James M Snell>
where `set(...)` mutates the value in place without creating that subordinate scope at all..... I guess this is me just admitting to myself finally that there are valid use cases for ALS `enterWith(...)`

[09:17:49.0595] <littledan>
oh I see, set makes more sense semantically

[09:18:38.0736] <littledan>
Honestly I have to agree with others who pointed out that some in TC39 will see this version to be "not well behaved"

[09:19:04.0416] <James M Snell>
I don't disagree

[09:19:26.0739] <littledan>
then we get into a sort of political cost/benefit analysis... not where I'd like to be with language design

[09:19:56.0419] <James M Snell>
I just have to admit the use cases are valid and there are many places where We Need Both .... makes things way more complicated tho

[09:24:01.0711] <James M Snell>
this *is* why I think having two separate types makes sense tho, rather than the ALS way of smooshing things together. Having a distinct type of storage cell that explicitly mutates the *current* context makes the semantics quite a bit cleaner

[09:25:21.0921] <littledan>
what if we designed both of these, but could be OK with them achieving different levels/timelines of standardization?

[09:25:36.0797] <James M Snell>
I'd be good with that

[09:25:58.0343] <littledan>
I want to encourage you to not use AsyncContext.Variable for something different, though; let's choose a different name, just to keep the discussions less confusing

[09:26:07.0194] <littledan>
at least as a working title

[09:26:17.0827] <James M Snell>
heh, noted :-)

[09:27:10.0274] <James M Snell>
I'm not just sure `Variable` is the right term to use semantically for something that can't be mutated in place once set ;-) ... so it's a bit weird to use that for the "entering a scope with this value" case

[09:27:22.0384] <James M Snell>
but definitely important not to add even more confusion ;-)

[09:27:26.0397] <littledan>
sure, but that's a separate argument

[09:27:53.0066] <littledan>
and we had a sort of extensive bikeshed there, so to reopen it, you'd first want to understand the matrix of everyone else's opinions...

[09:28:51.0418] <Chengzhong Wu>
Yes, name bikeshed could be re-opened if there is an extension to the proposal

[10:29:29.0020] <James M Snell>
> <@stephenbelanger:matrix.org> async_hooks was created and then _years_ later core finally accepted that context management was actually a reasonable thing to want.

... and at the time async_hooks and promise_hooks were the only option to implementing something reasonable... despite the numerous obvious warts 

[12:01:18.0143] <shaylew>
> <@jasnell:matrix.org> I think the two types of variables makes sense... but maybe with two distinct behaviors.. For this example I'm going to change up the terms a bit from what is currently spec'd and known. What the spec currently calls `AsyncContext.Variable`, I'm going to call `AsyncContext.Scope` instead... it's a thing that can be entered with a specific value. Then, what I'm calling `AsyncContext.Variable` in this example is a thing whose value can be set (similar to `enterWith` but that cannot be explicitly entered... the value is just retained as the context is propagated.
> 
> ```
> const store1 = new AsyncContext.Scope
> const store2 = new AsyncContext.Variable
> 
> async function doSomething() {
>   store2.set(`abc${store1.get()}`);
> }
> 
> await Promise.all([
>   store1.run(1, async () => { await doSomething(); console.log(store2.get()); // 'abc1' }),
>   store1.run(2, async () => { await doSomething(); console.log(store2.get()); // 'abc2' }),
> ]);
> console.log(store2.get()); // undefined ?
> ```
> 
> The key point is `store2` here is not a context that can be entered but only a value that can be set at any point during a flow such that the value propagates through the flow

I haven't really looked at what languages with _mutable_ dynamically bound variables do (I was mostly on the pure-ish functional side of PLT) but this looks an awful lot like something that would have been invented before under that name and if you're lucky the design space has been explored a nonzero amount 

[12:24:39.0188] <littledan>
my experience with mutable dynamically bound variables in Factor was negative. It can be surprising how much or little the write to the variable is propagated up/backwards and then read by someone else. `.run` has a simple answer to this question: it isn't propagated up/backwards.

[12:31:54.0248] <James M Snell>
Yeah, I really wanted us to be able to get rid of the enterwith API pattern as it's not great at all

[12:41:14.0154] <littledan>
like we would have issues where a scope was introduced with a different variable in mind, and then it made an unrelated set act differently

[12:41:44.0250] <littledan>
so we ended up rediscovering that setting a dynamically scoped variable was an anti-pattern, and we moved towards doing .run instead

[12:57:37.0157] <Andreu Botella>
> <@littledan:matrix.org> so we ended up rediscovering that setting a dynamically scoped variable was an anti-pattern, and we moved towards doing .run instead

even with `.set()`, I don't think this would be dynamic scoping, at least not in the sense that https://github.com/tc39/proposal-async-context/blob/master/SCOPING.md discusses

[12:57:46.0982] <Andreu Botella>
since you would still need to have access to the object in order to call `.set()`

[12:58:45.0965] <Andreu Botella>
but I don't have a background in PLT

[12:59:07.0713] <Andreu Botella>
so I might be missing stuff

[13:04:52.0060] <Andreu Botella>
also, how would this interact with events? Should `Scope` (i.e. the current `Variable`) always use the registration context and `Variable` (the one with `.set()`) always the originating context?

[13:05:26.0036] <Andreu Botella>
(does that even make sense)

[13:44:50.0875] <James M Snell>
good question... I don't know yet. going to have to stew on the semantics for a bit

[13:50:35.0087] <littledan>
btw Factor dynamic scope was definitely "restore after await" -- the language actually uses cooperatively scheduled coroutines, and it just felt natural to restore all the dynamically scoped variables after returning from yield. We didn't have anything for observability, though.

[13:50:48.0307] <littledan>
(Factor was a toy, no need to take real lessons from it)

[14:29:29.0618] <Steve Hicks>
> <@littledan:matrix.org> I've asked two questions that I don't yet know the answer to:
> - How are we handling merges, given that both contexts are often relevant (and in general this forms a big tree--there are more than two relevant things)?
> - How could per-variable handling scale, when you have a lot of different libraries and a lot of different variables and they're all supposed to fit together? It's easier for me to understand "two classes of variables".

For merges, I think the flow-around branch is available (if you want it) via Snapshot.wrap() (or Variable.wrap, etc).  If the flow-through branch is the default then we can allow the caller to opt into flow-around with wrap, then that seems pretty reasonable.  For octopus merges (e.g. Promise.all) you should have access to the individual promises, so you can dig them up to `await` them individually if you want to examine their resolution contexts (assuming those resolutoin contexts are still tied to the promises).  As a default, I think the `all` promise should maintain the most-recently-resolved parent promise context.

I have similar concerns as you do with per-variable handling.  I'm really big on my ZK axiom: different components need to be able to do the right thing with Zero Knowledge of the vars used by any other components.  I think the only way for this to be tenable is if the default flow just does the right thing - the instant anyone needs to manually bind anything, you're already in danger.

[14:55:52.0704] <Steve Hicks>
> <@abotella:igalia.com> The APIs I'm thinking of are things like https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultReader/closed, or https://developer.mozilla.org/en-US/docs/Web/API/FontFaceSet/ready. I don't see how those could possibly made to work with resolution time, unless every user knows to work around them

Thinking outside the box, I wonder if there's any reasonable way to spec these as somehow "transparent", so that awaiting them wouldn't impact the current environment?  This seems somewhat related in my mind to the case of a shared cache.  If you've got an initial request that kicks off a computation it may make sense to include the whole computation time in the tracing, but if a different request joins the ongoing computation, it shouldn't be traced as a normal complete operation, and it certainly shouldn't clobber the second request's context.

[15:02:52.0294] <Steve Hicks>
> <@littledan:matrix.org> what if we designed both of these, but could be OK with them achieving different levels/timelines of standardization?

I want to add a word of caution about polyfillability - even if we standardize incrementally, we should have this in mind such that a polyfill for the second feature could hopefully be built using native versions of the first, rather than starting from scratch a second time.  There's some brainstorming about having some built-in standard async vars, e.g. for cancellation (which, incidentally, probably wants flow-around "scope" semantics, rather than the flow-throw "mutable variable" semantics) - depending on how these would work, it could actually be _really bad_ to have to wipe out the native implementation to polyfill additional features on it if there might be builtins that would do unspoofable brand checks on something being a _real var_ vs a polyfill imitation.

[15:08:17.0357] <Andreu Botella>
I'm not sure that one of the features would be polyfillable based on the other, brand checks or no

[15:11:11.0867] <Steve Hicks>
I'm very intrigued by the Scope/Variable idea and need to think through the question of how they interact - it seems a little bit odd that entering/exiting one Scope X would somehow affect the lifetime of an unrelated Variable Y.

[15:12:06.0369] <Steve Hicks>
(reminds me a bit of how `\let` and `\global\let` interact in TeX, which is pretty confusing)

[15:12:11.0443] <littledan>
yeah I think these are each fundamentally different and currently inexpressible primitives

[15:12:23.0333] <littledan>
I was not imagining that they would be polyfillable

[15:13:06.0600] <littledan>
I'm still having trouble understanding the "flow-around semantics are available if you want it" argument--do we actually expect people to use these APIs that way?

[15:13:37.0742] <littledan>
what should the thought process of a normal developer be, when they are trying to decide whether to Snapshot.wrap a promise that they're awaiting?

[15:13:59.0481] <littledan>
I was imagining that it's just expert library authors who maintain connection pools and such who would use these APIs

[15:14:31.0442] <littledan>
this is not an argument that we must use flow-around semantics, I'm just talking about that one part of the story

[15:15:02.0599] <Steve Hicks>
I think the answer is that we really can't rely on any "normal" developers having any idea how to wrap things correctly, so we need to design it to "do the right thing" as much as possible

[15:19:07.0985] <Steve Hicks>
and i worry that either default (flow-around vs flow-through) is going to require opt-outs in normal code... so maybe per-store configurability is the only viable option

[15:20:17.0311] <littledan>
> <@stephenhicks:matrix.org> and i worry that either default (flow-around vs flow-through) is going to require opt-outs in normal code... so maybe per-store configurability is the only viable option

maybe if we could somehow survey existing code and figure out when it does or should do an opt out, for which variables, and we can derive patterns for this?

[15:21:12.0863] <littledan>
I'm not even if per-store configurability (if it's a global default to push things in the call/resolve-time vs registration-time direction in the cases where both are available) will be a solution; sometimes you want the registration-time ancestor of the call-time ancestor

[15:55:47.0520] <Steve Hicks>
> <@jasnell:matrix.org> I think the two types of variables makes sense... but maybe with two distinct behaviors.. For this example I'm going to change up the terms a bit from what is currently spec'd and known. What the spec currently calls `AsyncContext.Variable`, I'm going to call `AsyncContext.Scope` instead... it's a thing that can be entered with a specific value. Then, what I'm calling `AsyncContext.Variable` in this example is a thing whose value can be set (similar to `enterWith` but that cannot be explicitly entered... the value is just retained as the context is propagated.
> 
> ```
> const store1 = new AsyncContext.Scope
> const store2 = new AsyncContext.Variable
> 
> async function doSomething() {
>   store2.set(`abc${store1.get()}`);
> }
> 
> await Promise.all([
>   store1.run(1, async () => { await doSomething(); console.log(store2.get()); // 'abc1' }),
>   store1.run(2, async () => { await doSomething(); console.log(store2.get()); // 'abc2' }),
> ]);
> console.log(store2.get()); // undefined ?
> ```
> 
> The key point is `store2` here is not a context that can be entered but only a value that can be set at any point during a flow such that the value propagates through the flow

One concern I have with the mutable variable idea is how one is supposed to bound the mutation - I think it's common to make a change with a lifetime, which is why we've gravitated toward the `run()` encapsulation.  As you've pointed out, with the flow-through semantics, `run` is very clearly the wrong name, and `set` is much more appropriate.  But your example also hints at some mechanism whereby changes to the variable would still somehow go out of scope?  I think that's important, but it seems like it would lead to lots of confusion.  If some other scope is entered internally, would that inner scope accidentally prune off a branch of var mutations?  That also doesn't seem right.


2024-05-21
[19:10:31.0037] <littledan>
* I'm not even sure if per-store configurability (if it's a global default to push things in the call/resolve-time vs registration-time direction in the cases where both are available) will be a solution; sometimes you want the registration-time ancestor of the call-time ancestor

[21:32:20.0824] <Justin Ridgewell>
Wow, this really blew up over the last few days

[21:34:08.0689] <Justin Ridgewell>
> <@stephenbelanger:matrix.org> It's not _just_ the timing of enabling PromiseHook. It is that the portion of an async function _before_ the first await behaves differently from the rest of the function because the context capture will have already happened around the outer await before passing over the inner awaits. It's confusing to users that the context is not flowing out.

I don’t understand this. What are the inner and outer awaits? In my mind, the async context is bound when we enter the function, it doesn’t matter where the awaits are.

[21:34:35.0911] <Justin Ridgewell>
> <@legendecas:matrix.org> The proposal as it current stands is maintaining the lexical consistent value inside a async function body across `await` for `AsyncContext.Variable`, which is part of the approach aiming to address the dynamic scope concerns from the previous meeting's feedback.

Exactly.

[21:35:39.0959] <Justin Ridgewell>
> <@stephenbelanger:matrix.org> Yes. That is actually what users keep telling me they are _expecting_.

Are there links to issue reports for this?

[21:37:03.0363] <Justin Ridgewell>
> <@shaylew:matrix.org> (See the warnings about rust `tracing::Span` in async code https://docs.rs/tracing/latest/tracing/span/struct.Span.html#in-asynchronous-code for some consequences of this sort of design in the wild -- but they're better off because Futures are expressive enough to write `Future::instrument` without needing built-in help)

This example doesn’t apply in our case, since any cooperate threading (another promise resuming in JS) would have restored its own context.

[21:44:05.0909] <Justin Ridgewell>
> <@abotella:igalia.com> sure, people rewriting code from callbacks to promises might prefer resolution time, but what about people writing async/await code from scratch? Do we know what they need? Would we be breaking them?

And it’s not just web APIs, anything trying to cache fetches or other async behavior, any module level initializion using a promise, will break any user.

[21:47:23.0961] <Justin Ridgewell>
> <@stephenbelanger:matrix.org> Flowing _around_ is essentially just local variable scope which, to me, doesn't really seem to have much value. I've asked a few times for an explanation or some use case _why_ anyone would want that flow but have not yet got any answer on that. 🤔

It’s a local variable scope that propagates to child calls automatically. I explicitly want this becasue it’s understandable, and easy to debug.

[21:49:46.0399] <Justin Ridgewell>
> <@abotella:igalia.com> even with `.set()`, I don't think this would be dynamic scoping, at least not in the sense that https://github.com/tc39/proposal-async-context/blob/master/SCOPING.md discusses

Unfortunately it is a form of dynamic scoping, but from callee to caller. This was another one of the points I had to discuss with the SES folks to get them on board with the proposal. The way they [reasoned](https://github.com/endojs/endo/pull/1424) about it is complicated, but essentially boils down to an implicit param to every function that is the async context mapping.

[21:51:56.0361] <Justin Ridgewell>
> <@stephenhicks:matrix.org> One concern I have with the mutable variable idea is how one is supposed to bound the mutation - I think it's common to make a change with a lifetime, which is why we've gravitated toward the `run()` encapsulation.  As you've pointed out, with the flow-through semantics, `run` is very clearly the wrong name, and `set` is much more appropriate.  But your example also hints at some mechanism whereby changes to the variable would still somehow go out of scope?  I think that's important, but it seems like it would lead to lots of confusion.  If some other scope is entered internally, would that inner scope accidentally prune off a branch of var mutations?  That also doesn't seem right.

I think allowing unbounded `set`s opens up the same problems as scoping, and introduces a global leak that is unfixable (how do you ever know when the last set value is not needed anymore?).

[21:57:09.0723] <Justin Ridgewell>
> <@stephenbelanger:matrix.org> There's not really any writing on it presently, but basically because we don't flow into promise continuations we need to keep an object at the top-level of the request which we push spans into and basically _guess_ what the parent is because, unlike with callbacks, the parent does not flow into the continuation. This means we have to look at what has been pushed into that list in the past and try to guess what the parent would be. Sometimes it's simply the last span in the list, but not always, so we need to do some additional analysis to figure out what was the last span which _could_ be a realistic parent, which requires we also hold a bunch of the span metadata. Holding all this metadata is expensive given that we could have hundreds of thousands of concurrent spans. What we _want_ is for the _correct_ context to just be able to flow through the resolve path so we only need to store the IDs and can entirely eliminate that big bag of data which lives for the whole life of the request.

I think this is what I’m missing. I don’t understand why could would need to guess, I’m naively assuming its always follows-from the last child and child-of the current parent. What’s a case where this isn’t correct? How does the flows-through solve holding holding the hundreds of thousands of concurrent spans?

[21:57:55.0614] <Justin Ridgewell>
(Also, sorry for not respondning a whole lot, normal coprorate BS is taking up all my free time)

[01:49:37.0801] <Andreu Botella>
> <@jridgewell:matrix.org> Unfortunately it is a form of dynamic scoping, but from callee to caller. This was another one of the points I had to discuss with the SES folks to get them on board with the proposal. The way they [reasoned](https://github.com/endojs/endo/pull/1424) about it is complicated, but essentially boils down to an implicit param to every function that is the async context mapping.

is there any documentation anywhere about what SES needs from new proposals?

[02:01:17.0088] <Stephen Belanger>
> <@littledan:matrix.org> Honestly I have to agree with others who pointed out that some in TC39 will see this version to be "not well behaved"

In my view, considering in-place mutation as "not well behaved" because of unintended flow consequences just says to me that the flow model is not clearly defined and _correct_ enough to be _certain_ of what the behaviour will be. If the model is actually _correct_ and _consistent_ then there should be no reason that setting partway through a scope should produce any sort of unexpected behaviour.

[02:03:04.0849] <Stephen Belanger>
> <@jasnell:matrix.org> I just have to admit the use cases are valid and there are many places where We Need Both .... makes things way more complicated tho

Yes, particularly with async/await the callback-scoped version starts to make less and less sense. This was the whole reason that way back _before_ we settled on `AsyncLocalStorage` I was backing the `AsyncLocal` proposal which _only_ did the set/get style and left the flow scoping semantics up to the runtime to get right.

[02:06:30.0182] <Andreu Botella>
> <@jridgewell:matrix.org> Unfortunately it is a form of dynamic scoping, but from callee to caller. This was another one of the points I had to discuss with the SES folks to get them on board with the proposal. The way they [reasoned](https://github.com/endojs/endo/pull/1424) about it is complicated, but essentially boils down to an implicit param to every function that is the async context mapping.

I'm not actually sure I understand this. As with the current proposal, you would still need to have access to an object in order to set or get, so isn't it exactly parallel to setting a variable from an outer scope?

[02:06:46.0814] <Andreu Botella>
> <@jridgewell:matrix.org> Unfortunately it is a form of dynamic scoping, but from callee to caller. This was another one of the points I had to discuss with the SES folks to get them on board with the proposal. The way they [reasoned](https://github.com/endojs/endo/pull/1424) about it is complicated, but essentially boils down to an implicit param to every function that is the async context mapping.

 * I'm not actually sure I understand this. As with the current proposal, you would still need to have access to an object in order to set or get, so isn't it exactly parallel to setting a variable defined in an outer scope?

[02:08:01.0258] <Stephen Belanger>
> <@littledan:matrix.org> my experience with mutable dynamically bound variables in Factor was negative. It can be surprising how much or little the write to the variable is propagated up/backwards and then read by someone else. `.run` has a simple answer to this question: it isn't propagated up/backwards.

It doesn't mutate the slot, but if you store an object in it you can propagate mutations up the tree. I think all we can really do is make captures be a copy of what the reference points to at the time and not be the same binding, so at least that top-level mapping of store to value doesn't propagate upward. This is also partly _why_ I think it's important that it be treated as a _variable_ and not a _bag of data_, because data bags are problematic when it comes to leaking mutations.

[02:10:24.0371] <Stephen Belanger>
> <@littledan:matrix.org> so we ended up rediscovering that setting a dynamically scoped variable was an anti-pattern, and we moved towards doing .run instead

This is what I lean toward at this point, personally. Though I _do_ see that there are a few scenarios where it doesn't _quite_ work the way you want it unless you do things like breaking out of awaits. Unfortunately this is how the OTel context works--you can activate a context within the _current_ scope.

[02:11:21.0684] <littledan>
What do you mean by breaking out of awaits?

[02:17:48.0949] <littledan>
> <@stephenbelanger:matrix.org> Yes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's _able_ to do this externally. With Node.js there is no solution.

Comparison with other languages would be really useful if we can figure out where to look 

[02:22:11.0772] <Stephen Belanger>
> <@jridgewell:matrix.org> I don’t understand this. What are the inner and outer awaits? In my mind, the async context is bound when we enter the function, it doesn’t matter where the awaits are.

The spec, as it is presently, calls for capturing the context at the point where an await happens, not where the promise being awaited resolves. The context flows _into_ that promise, and it _would_ flow all the way to the point of resolving, but then we orphan that branch and return the context back to the captured value of that outer await.

In this particular example though, it's using `store.enterWith(...)` which effectively sets the value in the _current_ scope without creating a new scope first. Because the initial segment of an async function executes synchronously, if that occurs _before_ the first await of that _internal_ function then the point at which the outer function captures its await will have already change _its_ context and so will adopt that inner context. Whereas if that inner function modifies the current context _after_ the first await within that inner function it will have already passed the point where the outer function captured the await context and so it would _not_ use that value. The fact this sometimes changes the outer function context and sometimes doesn't is extremely confusing. Users are expecting it to _always_ change the outer context, as indicated in the issue, because it is logically a continuation and should therefore behave the same as it would were it written with callbacks instead.

[02:26:03.0875] <Stephen Belanger>
> <@jridgewell:matrix.org> Are there links to issue reports for this?

The issue I just posted yesterday was exactly this, and we get _numerous_ reports expecting this behaviour in Datadog support escalations. I've seen it come up many times before in many places too--Slack conversations, conversations at collab summits...I've never seen anyone that _expected_ the behaviour as it is presently. It's possible that no one talks about it because people don't complain about what they think is already working, but given that the vast majority of context management usage is APMs and all the APM devs I've talked to have complained about these context flows as problematic I feel like there's a pretty good chance we're getting it wrong.

[02:27:58.0998] <Stephen Belanger>
> <@jridgewell:matrix.org> It’s a local variable scope that propagates to child calls automatically. I explicitly want this becasue it’s understandable, and easy to debug.

Yes, I get that people want this "around" flow. I'm fine with people wanting it. I'm just not clear what exactly the _reason_ is why they want it. What _specifically_ is the use case for that flow?

[02:36:03.0933] <Stephen Belanger>
> <@jridgewell:matrix.org> I think this is what I’m missing. I don’t understand why could would need to guess, I’m naively assuming its always follows-from the last child and child-of the current parent. What’s a case where this isn’t correct? How does the flows-through solve holding holding the hundreds of thousands of concurrent spans?

Consider this code:

```js
async function doSomething() {
  await doAThing() // first span
  await doAnotherThing() // no span
  await doYetAnotherThing() // second span should be follows-from first
}
```

If we have call `doSomething()` twice in a `Promise.all(...)`, which we do not instrument or have any particular awareness of--maybe it's user code--then we'll get two spans being created for the first awaits of each, then when the second spans come in they will no have a way to differentiate because the `doSomething()` itself would have the same context when it runs both times and would be restoring that over the awaits, blowing away the context we had from the inner function calls which we otherwise _could_ associate with if we had flow-through semantics.

[02:39:03.0655] <Stephen Belanger>
> <@abotella:igalia.com> I'm not actually sure I understand this. As with the current proposal, you would still need to have access to an object in order to set or get, so isn't it exactly parallel to setting a variable defined in an outer scope?

Yeah, I really don't get what the security concerns are here. You need access to the variable instance to retrieve the data. Sharing any _normal_ variable would have the same security implications.

[02:41:44.0210] <Stephen Belanger>
> <@littledan:matrix.org> What do you mean by breaking out of awaits?

I mean the flow-through semantics. The `store.run(...)` form is not particularly usable in async functions, having an in-scope mutation would make more sense, or _at least_ some way to inform the context to _not_ bind around the await when what you actually _want_ is the flow-through semantics.

[02:43:10.0330] <Stephen Belanger>
Most other languages I've seen don't have a user-provided scoping mechanism for context, the runtime decides it themselves.

[02:43:34.0840] <Stephen Belanger>
Like Ruby does that with fiber locals as just a simple map that it manages on its own without any user-provided scopes.

[02:44:00.0706] <Stephen Belanger>
https://docs.ruby-lang.org/en/master/Fiber.html#method-i-storage

[02:45:26.0850] <Stephen Belanger>
And go has its explicit `Context` object which you have to pass through manually, but you basically do clones every time you want to modify it and it flows downward through the calls you make passing in the modified version.

[02:46:41.0805] <Stephen Belanger>
.NET also has AsyncLocal, which is basically exactly what was originally proposed in Node.js _before_ AsyncLocalStorage was chosen instead, because people didn't trust the Node.js runtime to manage scopes correctly. https://learn.microsoft.com/en-us/dotnet/api/system.threading.asynclocal-1?view=net-8.0

[02:47:16.0876] <Stephen Belanger>
Again, doing the simple key/value hash map type structure with no user-supplied scoping mechanism.

[02:47:28.0957] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> The issue I just posted yesterday was exactly this, and we get _numerous_ reports expecting this behaviour in Datadog support escalations. I've seen it come up many times before in many places too--Slack conversations, conversations at collab summits...I've never seen anyone that _expected_ the behaviour as it is presently. It's possible that no one talks about it because people don't complain about what they think is already working, but given that the vast majority of context management usage is APMs and all the APM devs I've talked to have complained about these context flows as problematic I feel like there's a pretty good chance we're getting it wrong.

The issue was confusing for it's use on `enterWith` and performance optimization that make an `AsyncLocalStorage` behaves differently when modification of `AsyncLocalStorage` was performed at different positions in an async function body. Matteo could expand in detail about his original use case but as I talked to him in private I think `AsyncLocalStorage.run` could satisfy his needs.

[02:48:23.0757] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> The issue I just posted yesterday was exactly this, and we get _numerous_ reports expecting this behaviour in Datadog support escalations. I've seen it come up many times before in many places too--Slack conversations, conversations at collab summits...I've never seen anyone that _expected_ the behaviour as it is presently. It's possible that no one talks about it because people don't complain about what they think is already working, but given that the vast majority of context management usage is APMs and all the APM devs I've talked to have complained about these context flows as problematic I feel like there's a pretty good chance we're getting it wrong.

 * The issue was confusing for it's use on `enterWith` and performance optimization that make an `AsyncLocalStorage` behaves differently when modification of `AsyncLocalStorage` was performed at different positions in an async function body. Matteo could expand in detail about his original use case but as I talked to him in private I think `AsyncLocalStorage.run` could satisfy his needs. Let's wait if he wants to expand on it on the issue.

[02:49:50.0888] <Chengzhong Wu>
 * The issue was confusing for it's use on `enterWith` and performance optimization that make an `AsyncLocalStorage` behaves differently when modification of `AsyncLocalStorage` was performed at different positions in an async function body. Let's wait to see if Matteo wants to expand on his original requirement on the issue.

[02:50:50.0980] <Stephen Belanger>
Python also does the plain map with a set/get and manages context scopes on its own. https://docs.python.org/3/library/contextvars.html

[02:51:40.0135] <Stephen Belanger>
As far as I'm aware, JavaScript is the _only_ language that thinks (for some reason) that this needs to be handed over to the user rather than just letting them modify the _current_ scope.

[02:52:31.0215] <Stephen Belanger>
Probably because we had bad experiences with domains in Node.js. But I think that's less a problem of set/get and more that domains itself was just bad. 😬

[02:52:46.0918] <Andreu Botella>
> <@stephenbelanger:matrix.org> As far as I'm aware, JavaScript is the _only_ language that thinks (for some reason) that this needs to be handed over to the user rather than just letting them modify the _current_ scope.

in Rust, there's tokio's `task_local!` / `LocalKey`

[02:52:56.0660] <Andreu Botella>
which doesn't let you modify the current scope

[02:53:32.0579] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> .NET also has AsyncLocal, which is basically exactly what was originally proposed in Node.js _before_ AsyncLocalStorage was chosen instead, because people didn't trust the Node.js runtime to manage scopes correctly. https://learn.microsoft.com/en-us/dotnet/api/system.threading.asynclocal-1?view=net-8.0

https://dotnetfiddle.net/7ulHg0 AFAICT dotnet doesn't flow-through values even it allows `.set` pattern

[02:54:54.0692] <Stephen Belanger>
Yep, flow-through is a different issue from the matter of if set/get are reasonable. I mostly brought that up because of James talking about that split idea.

[02:55:22.0934] <Chengzhong Wu>
That's great. I really appreciate distinguishing the two topics

[02:55:38.0682] <Stephen Belanger>
But I think what would probably actually _make sense_ is to just have multiple context types which work in the set/get mode and use the two types to differentiate the flows.

[02:56:23.0557] <Stephen Belanger>
One can be a "modify current context and flow into children only" type while the other can be "modify for any logically following execution" type.

[03:28:06.0331] <Stephen Belanger>
I think `ContinuationLocal` clear describes the logical execution flow style. I feel like the `AsyncLocal` name is a bit vague about exactly _how_ it flows through async behaviour though. I wonder if we should consider a name which more clearly communicates exactly _how_ it flows so we aren't creating confusion?

[03:28:59.0940] <Stephen Belanger>
 * I think `ContinuationContext` clear describes the logical execution flow style. I feel like the `AsyncContext` name is a bit vague about exactly _how_ it flows through async behaviour though. I wonder if we should consider a name which more clearly communicates exactly _how_ it flows so we aren't creating confusion?

[03:29:07.0439] <Stephen Belanger>
 * I think `ContinuationContext` clearly describes the logical execution flow style. I feel like the `AsyncContext` name is a bit vague about exactly _how_ it flows through async behaviour though. I wonder if we should consider a name which more clearly communicates exactly _how_ it flows so we aren't creating confusion?

[03:29:29.0856] <Stephen Belanger>
 * I think `ContinuationContext` clearly describes the logical execution flow style. I feel like the `AsyncContext` name is a bit vague about exactly _how_ it flows through async behaviour though. I wonder if we should consider a name which more clearly communicates exactly _how_ it flows through async code so we aren't creating confusion?

[03:31:49.0558] <Stephen Belanger>
I wonder if we need the "async" in the name at all. `CallContext` might communicate the flow semantics better? Or even `ImplicitCallContext` to make it even _more_ clear that this is data which gets passed around without needing to do so explicitly? 🤔

[03:44:28.0639] <Stephen Belanger>
Another reason the set/get model kind of makes more sense is you can build the `store.run(...)` model on top of it whereas the reverse is _not_ possible.

```js
run(value, scope) {
  const previous = this.get()
  try {
    this.set(value)
    return scope()
  } finally {
    this.set(previous)
  }
}
```

[04:02:16.0946] <Andreu Botella>
I've been looking through https://github.com/endojs/endo/blob/markm-fluid-scopes/packages/eventual-send/src/async-contexts/README.md and I think I more or less understand the security concerns, and `set()` definitely violates the "unobservable to anything that cannot run in the spawned turn" condition

[04:03:44.0575] <Andreu Botella>
I'm not yet sure whether the resolution context behavior of promises would, though

[04:04:56.0915] <Andreu Botella>
I think it would as well

[04:05:10.0740] <Andreu Botella>
so either of those behaviors would probably get strong opposition from the SES folks

[04:06:08.0359] <Andreu Botella>
the thing that breaks confidentiality is global wrap, though

[04:06:35.0269] <Andreu Botella>
but we can't remove it (in favor of instance wrap) without making a bunch of use cases impossible or impractical

[04:13:07.0728] <Andreu Botella>
no, wait, even the behavior of `then` would allow that kind of leaks

[04:13:12.0232] <Andreu Botella>
 * no, wait, even the behavior of `then` would allow that kind of information leaks

[04:13:33.0887] <Andreu Botella>
 * actually, no, even the behavior of `then` would allow that kind of information leaks

