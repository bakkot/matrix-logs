2024-05-01
[17:33:10.0504] <shaylew>
I think `Variable.wrap` ends up being a very different thing from delimited snapshots -- delimited snapshots operate on sections of the stack that contain (possibly) multiple variables, without the caller needing to know which variables are involved, whereas `Variable.wrap` is a convenience method for something you can already do without any kind of snapshots (global or delimited) as long as you know the variable(s) you want to operate on

[17:49:41.0850] <Justin Ridgewell>
Can you write example code of how delimited stacks would work?

[18:02:14.0630] <shaylew>
So, the system from the paper has "stack marks" as a different thing from "variables" because it already has the marks as part of delimited control... but in JS, without delimited continuations, I think you can just use a variable as a stack mark and get away with it. So it ends up looking something like...
```
Snapshot.partial<T>(v: Variable<T>): Snapshot
```
with the only difference being that when you capture a partial snapshot it captures all variables inside the most recent `v.run` (including `v`), and when you `run` a partial snapshot it instates that sequence of bindings on top of whatever variables are already in scope (perhaps shadowing some if they're in the current scope and also in the partial snapshot, but not clobbering anything that wasn't mentioned in the snapshot).

[18:06:16.0091] <shaylew>
You're probably going to ask "why would someone want this?" and one answer is: I went rifling through the literature for this because of Signals, which really seem like they want to capture and restore the _signal-related_ suffix of the context when running a memoized Computed... but where it doesn't seem to be helpful (and might cause problems) for this to capture or clobber the parts of the async context that were set up completely outside of any Computed

[18:15:46.0387] <shaylew>
There are a bunch of framework features in reactivity systems that all boil down to "save this when you create a Computed and restore it when you start rerunning it later on", and -- because Computeds are memoized -- it seems like it's basically always a bug for some sort of dynamic context (be it AsyncContext or manually managed with try/finally) to pass into a computed that's rerunning. When multiple callers all call `computed.get()` in some order, we want to be sure that the answer we saved into the computed didn't depend on which caller was first. If you have multiple frameworks doing their own extensions, they can save/restore their _own_ dynamic context using try/finally... but you run into problems if two frameworks have different extensions and don't know how to properly mask off each others'. Delimited snapshots nail this use case so well that I thought I'd try to float them and see if they seemed to help with any of the other ongoing AsyncContext mysteries

[18:32:21.0490] <shaylew>
(the signals framework features in question are stuff like... "ownership tree to implement hierarchical cleanup", "scoped error handlers to implement ErrorBoundary", "suspense context", "Context/Provider pattern for implicit parameters")

[15:59:10.0795] <Justin Ridgewell>
@stephenbelanger:matrix.org Please message me with your email so that I can add you to the meetings!

[15:59:43.0644] <Justin Ridgewell>
You were always meant to be invited, and I thought you were 😄


2024-05-02
[07:33:31.0454] <Yagiz Nizipli>
Hey Justin Ridgewell, can you invite me to the meeting as well? Sentry just recently joined TC39, and it will be finalized by the June meeting (I believe so) 

[09:51:07.0374] <Justin Ridgewell>
Sure, just gotta send me your email

[10:36:59.0582] <Justin Ridgewell>
@shaylew:matrix.org What's your GitHub handle?

[11:07:44.0459] <shaylew>
> <@jridgewell:matrix.org> @shaylew:matrix.org What's your GitHub handle?

also shaylew there

[13:22:32.0521] <littledan>
> <@yagiznizipli:matrix.org> Hey Justin Ridgewell, can you invite me to the meeting as well? Sentry just recently joined TC39, and it will be finalized by the June meeting (I believe so)

As a provisional member, Sentry can participate like all other members in Ecma groups (just not the theoretical case of voting, which never comes up). If you've received a communication from Ecma which led you to believe otherwise, please let me know so that we can make the right edits to reduce this confusion.

[13:23:46.0567] <Andreu Botella>
Also, regardless of that, I think we don't limit the AsyncContext meeting to delegates only – it's just that the invite is not public (not sure why though).

[13:24:33.0632] <Andreu Botella>
there was talk of having a public calendar, but I don't know what happened with that

[13:24:39.0760] <Andreu Botella>
 * there was talk of having a public TC39 calendar, but I don't know what happened with that

[13:31:39.0708] <littledan>
> <@abotella:igalia.com> there was talk of having a public TC39 calendar, but I don't know what happened with that

To make a meeting public, we just have to ask for it to be made public on the Reflector

[13:31:45.0625] <littledan>
do we all agree on that change?

[13:32:48.0840] <Justin Ridgewell>
Honestly I’d prefer a permissive invite-only structure

[13:32:58.0242] <Justin Ridgewell>
Everyone’s welcome, they just need to ask

[13:33:26.0502] <littledan>
we could put the existence and time of the meeting on the public calendar, and direct people to join this channel and ask for call-in instructions

[13:33:43.0683] <littledan>
Bryan English told me he spent 10 minutes trying to search for any evidence of the existence of this meeting and couldn't find ny

[13:33:47.0635] <littledan>
 * Bryan English told me he spent 10 minutes trying to search for any evidence of the existence of this meeting and couldn't find any

[13:34:48.0550] <Chengzhong Wu>
Can they access reflector?

[13:35:17.0419] <littledan>
no, since they're not Ecma members

[13:35:26.0443] <littledan>
but even for Ecma members, the Reflector often isn't discoverable enough

[13:36:48.0575] <Justin Ridgewell>
> <@littledan:matrix.org> we could put the existence and time of the meeting on the public calendar, and direct people to join this channel and ask for call-in instructions

Let’s do that

[13:39:06.0114] <Justin Ridgewell>
Or we could add it to the proposal README

[13:40:58.0587] <littledan>
> <@jridgewell:matrix.org> Or we could add it to the proposal README

why not both .gif

[13:41:12.0702] <Justin Ridgewell>
Both

[13:41:30.0260] <Chengzhong Wu>
A link to this matrix room in the readme (afaik this room is public) could be good. The agenda and notes are in the room description as well


2024-05-06
[04:54:07.0602] <Stephen Belanger>
Apologies for the delay in sharing these docs. I needed to prune some company-specific bits and navigate our convoluted process for making Google Docs actually public. 😅

The first doc is a bunch of explanation on the problems we have with existing attempts at context management and some possible solutions we're iterating on to solve these problems in a more flexible way. https://docs.google.com/document/d/1v8tMzV51Cuz32-60dhopoIMIxWfy_epOIRwoL5LmKVc/edit?usp=sharing

The second doc is partly relevant in that it describes an integration between the Diagnostics Channel concept and context management for the purpose of providing control to users to decide in which ways they want to propagate context for their specific store around particular points defined by library code as possibly interesting. https://docs.google.com/document/d/1DTZ2C5BKsoVRnU_ihyi93blF3cxXIbqqcIaSYurhBRk/edit?usp=sharing

I additionally have some slides from a recent internal talk I can also share which covers this overlap more briefly, and with specific examples. https://docs.google.com/presentation/d/1jYO45MudKGPOtir5hK0_wB7XS0D_ksLe4j5NvC8YfTc/edit?usp=sharing

[04:59:57.0810] <Stephen Belanger>
Keep in mind these are written from the perspective of defining a generalized context management system which could exist in _many_ languages, so it doesn't get too deep into JS specifics. It also has some spots I still would like to improve, but what is shared is a snapshot-in-time copy of what the _current_ state is, so I will have to replicate future changes into these docs as it is deemed relevant. The main one is that I'm trying to think of a better expression of the context management part of the Window Channel concept in Diagnostics Channel to put more of the logic and explanation of its use into the context management space. I'm not yet sure if that involves having some additional ContextWindow construct or something like that...still thinking on that one. 🤔

[05:00:15.0586] <Stephen Belanger>
 * Keep in mind these are written from the perspective of defining a generalized context management system which could exist in _many_ languages, so it doesn't get too deep into JS specifics. It also has some spots I still would like to improve, but what is shared is a snapshot-in-time copy of what the _current_ state is, so I will have to replicate future changes into these docs as it is deemed relevant.

The main one is that I'm trying to think of a better expression of the context management part of the Window Channel concept in Diagnostics Channel to put more of the logic and explanation of its use into the context management space. I'm not yet sure if that involves having some additional ContextWindow construct or something like that...still thinking on that one. 🤔

[05:00:37.0933] <Stephen Belanger>
 * Keep in mind these are written from the perspective of defining a generalized context management system which could exist in _many_ languages, so it doesn't get too deep into JS specifics. It also has some spots I still would like to improve, but what is shared is a snapshot-in-time copy of what the _current_ state is, so I will have to replicate future changes into these docs as it is deemed relevant.

The main change I'm considering is thinking of a better expression of the context management part of the Window Channel concept in Diagnostics Channel to put more of the logic and explanation of its use into the context management space. I'm not yet sure if that involves having some additional ContextWindow construct or something like that...still thinking on that one. 🤔

[05:04:45.0389] <Andreu Botella>
Hey, thanks for taking the time and trouble to make these docs public! I'll try to take a look, at least at the context management one, sometime this week

[05:50:26.0136] <Yagiz Nizipli>
> <@littledan:matrix.org> As a provisional member, Sentry can participate like all other members in Ecma groups (just not the theoretical case of voting, which never comes up). If you've received a communication from Ecma which led you to believe otherwise, please let me know so that we can make the right edits to reduce this confusion.

Afaik, we didn't receive anything from Ecma. 

[05:53:11.0155] <littledan>
> <@yagiznizipli:matrix.org> Afaik, we didn't receive anything from Ecma.

OK, good, so welcome!

[05:59:14.0480] <littledan>
Welcome Steven E !

[05:59:21.0668] <littledan>
we are now up to 3 Stevens

[06:00:07.0160] <Steven E>
Any of them ph's? 

[06:00:23.0075] <Stephen Belanger>
/me raises hand

[06:00:27.0042] <Steven E>
Us v's are a good group

[06:01:02.0205] <Stephen Belanger>
Welcome! 😄

[06:04:00.0962] <Steven Eubank (sentry.io)>
I can be less anonymous now! Happy to join

[10:59:19.0633] <Chris de Almeida>
Hi All.  Chengzhong reached out to me to add the AsyncContext meeting to the public calendar.

[10:59:22.0896] <Chris de Almeida>
https://github.com/tc39/Reflector/issues/491

[11:00:51.0243] <Chris de Almeida>
this is the issue to address that (though the invite list there is likely out-of-date. something to keep in mind, is that it is not a distinct meeting from the private calendar -- it is the same meeting shared across calendars (and this is an important feature)

the meeting is always invite-based by nature -- the question is whether the invite list can be public, with the specific concern being to not release individuals' email addresses publicly without their consent

as long as the meeting notes link can be public, then there is nothing in the meeting description that needs to change, as there is no information that _can't_ be public there

I suggest that that the invite list is made private initially, so that the meeting can be added to the public calendar immediately.  the question of the invite list being public has been the blocking issue for other meetings, and they continue to not get added to the public calendar because it goes unresolved. the invite list can be made public later, once everyone has approved (or removed) their email address for/from the invite

if there are no objections, I am going to proceed with this

[11:03:10.0970] <Andreu Botella>
I think the meeting in the private calendar has the Zoom link, and Justin Ridgewell mentioned he'd rather have the calendar entry be public but not the link, and to invite people as needed

[11:03:23.0738] <Andreu Botella>
I don't have an opinion on that though

[11:11:05.0788] <Chris de Almeida>
> <@abotella:igalia.com> I think the meeting in the private calendar has the Zoom link, and Justin Ridgewell mentioned he'd rather have the calendar entry be public but not the link, and to invite people as needed

hmm, this seems to defeat the purpose of having it on the public calendar

[11:34:10.0408] <Andreu Botella>
I'm looking at the web integration of the `error` event on `window` (which is fired from JS execution errors), and I just noticed that we might need some extra work to make FinalizationRegistry work with that

[11:34:51.0948] <Andreu Botella>
the way the FR cleanup job is spec'd, if any callback throws, it's up to the host to deal with that

[11:35:28.0954] <Andreu Botella>
but after `CleanupFinalizationRegistry` returns, the host doesn't have access to the context

[11:35:34.0336] <Andreu Botella>
 * but after `CleanupFinalizationRegistry` returns, the host doesn't have access to the FR context

[11:37:43.0664] <Andreu Botella>
and we probably want to make `error` work the same as `unhandledrejection`

[11:37:58.0170] <Andreu Botella>
 * and we probably want to make `error` work the same as `unhandledrejection`, so it'd have to store that context

[15:10:37.0470] <littledan>
Chris de Almeida: the idea is that the meeting is public and open to join, and the process to get the link is to come in and ask us. No need to make the attendee list public—this can be a separate calendar invite which lacks the zoom link, the notes link and attendees, and only says the time and gives instructions to join this channel and ask for more information 

[15:18:21.0615] <Chris de Almeida>
> <@littledan:matrix.org> Chris de Almeida: the idea is that the meeting is public and open to join, and the process to get the link is to come in and ask us. No need to make the attendee list public—this can be a separate calendar invite which lacks the zoom link, the notes link and attendees, and only says the time and gives instructions to join this channel and ask for more information

it would be ideal if it were not two separate meetings, but that's alright. please provide the text for the new/public meeting description

[15:19:24.0705] <Justin Ridgewell>
The notes are also publicly editable, which means they shouldn’t be shared to everyone

[15:19:53.0799] <Justin Ridgewell>
(The notes are tied to my deactived Vercel account, so I can’t change the permissions)

[15:23:42.0258] <Andreu Botella>
Can we create a new notes document and copy the contents?

[15:24:52.0324] <Andreu Botella>
 * Can we create a new notes document and copy the contents there?

[15:25:20.0171] <Justin Ridgewell>
Someone else could, but I can’t as a Googler (our docs cannot be made publicly visible)

[15:41:51.0045] <Chengzhong Wu>
Created a new one: https://docs.google.com/document/d/1pi-NMbqVhg2UuxQAZ4jOGDeHLlZGD_DJ7fyxHt_C2hs/edit

[15:42:40.0173] <Chengzhong Wu>
Access granted to people that I have ail address in mind, please don’t be hesitant to ask for editor access by message me your address 

[15:42:53.0261] <Chengzhong Wu>
* Access granted to people that I have email address in mind, please don’t be hesitant to ask for editor access by message me your address

[15:45:13.0770] <Chengzhong Wu>
* Access granted to people that I have email address in mind, please don’t be hesitant to ask for editor access by message me your address (still publicly viewable)


2024-05-07
[20:52:15.0250] <Justin Ridgewell>
Updated the calendar invite’s doc to that one

[20:53:27.0125] <Justin Ridgewell>
@softwarechris:matrix.org Can you give me moderator access to the invite’s meet? That way we can publicize the link and still have it be invite-only (people can just ask to join during the meeting if they’re not on the invite yet)

[21:31:11.0805] <Chris de Almeida>
you already have calendar permission and are the organizer of the meeting.  the web/video call settings are currently set to open access.  keep in mind if you change it from `Open` to `Trusted`, even if people are on the invite, they can only join automatically if their email on the invite is associated with a google account.  otherwise, they still need to be let in.  and the only person that can let anyone in is you

[21:32:12.0605] <Chris de Almeida>
I recall that being a problem, and the reason why the web meeting settings were changed to `Open`

[21:32:45.0607] <Justin Ridgewell>
Can only one person have that power?

[21:36:50.0114] <Chris de Almeida>
> <@jridgewell:matrix.org> Can only one person have that power?

unfortunately, yes. the meeting organizer.  you could use an alternate service that allows you to use cohosts or utilize a host key (which potentially anyone could use if they have the key).  but I don't know of any workaround for google

[21:36:53.0745] <Chris de Almeida>
> <@jridgewell:matrix.org> Can only one person have that power?

 * unfortunately, yes. the meeting organizer.  you could use an alternate service that allows you to use cohosts or utilize a host key (which potentially anyone could use if they have the key).  but I don't know of any workaround for google meet

[21:37:05.0408] <Chris de Almeida>
 * unfortunately, yes. the meeting organizer.  you could use an alternate meeting platform that allows you to use cohosts or utilize a host key (which potentially anyone could use if they have the key).  but I don't know of any workaround for google meet


2024-05-09
[09:27:53.0627] <Andreu Botella>
I'm wondering if we should have an AO that creates an AsyncContext.Variable object?

[09:29:12.0168] <Andreu Botella>
I'm thinking about web specs that might use AsyncContext by creating a spec-internal variable

[09:29:26.0212] <Andreu Botella>
and currently we restrict the keys of a mapping to be Variable instances

[09:31:06.0832] <Andreu Botella>
it's not like those specs can't call the AsyncContext.Variable constructor, but they'd have to deal with abrupt completions and so on

[09:32:17.0951] <Andreu Botella>
though I guess that would be fine if there are only a few specs doing something like that, and it can always be revisited later

[09:38:06.0587] <Chengzhong Wu>
I think it's good to have, as like `AsyncContextSnapshot` and `AsyncContextSwap`


2024-05-13
[10:37:34.0525] <littledan>
Where are we in understanding https://github.com/tc39/proposal-async-context/issues/83 ?

[11:42:13.0150] <Mathieu Hofman>
I talked with Dean Tribble on Friday, picking his brain from his Midori experience. I think the conclusion is that there is no way to abstract "calling" context in an API shape like AsyncContext. The biggest problem is that the most recent calling context may not be the one you really need, that providing more than one would result in unbounded calling context history, and that it would expose some implementation details about the execution order of the "callers". For telemetry / debugging use cases, one approach is to gather points at certain key times. For promises for example, you can give them an ID and "log" when they are resolved (potentially to another promise), when reactions are added and executed, etc.. Then you can correlate all this and recompose your execution graph. this of course sounds very similar to async_hooks, and is too powerful of an API to expose to "unprivileged" code.

[12:03:27.0968] <littledan>
> <@mhofman:matrix.org> I talked with Dean Tribble on Friday, picking his brain from his Midori experience. I think the conclusion is that there is no way to abstract "calling" context in an API shape like AsyncContext. The biggest problem is that the most recent calling context may not be the one you really need, that providing more than one would result in unbounded calling context history, and that it would expose some implementation details about the execution order of the "callers". For telemetry / debugging use cases, one approach is to gather points at certain key times. For promises for example, you can give them an ID and "log" when they are resolved (potentially to another promise), when reactions are added and executed, etc.. Then you can correlate all this and recompose your execution graph. this of course sounds very similar to async_hooks, and is too powerful of an API to expose to "unprivileged" code.

This makes sense; thanks for the summary. What does Dean recommend that we do for AsyncContext?

[12:04:01.0285] <littledan>
"just choose something for each case" is the strategy that I was imagining; maybe too naive but it sounds like this is maybe what Dean is saying?

[12:06:07.0309] <littledan>
I'm wondering if there's any way we could expose "just" the necessary information to hook up the extra follows-from links, or distinguish child vs following links. I think Stephen Belanger may have been asking for one of these, though I'm not sure. Did you discuss this topic with Dean?

[12:12:54.0867] <Mathieu Hofman>
Yeah having a default of "snapshoting" at registration makes sense for AsyncContext. It's just that AsyncContext might not be the right API shape for telemetry use cases. And yes we tried to figure out how the necessary info could be exposed through AsyncContext, but couldn't find a way.

[12:14:25.0008] <littledan>
I think the current shape of AsyncContext has a "good enough in practice" shape for telemetry since it matches what's done in Node.js today. Maybe something better is possible; certainly telemetry infrastructure can be trusted.

[12:15:01.0185] <littledan>
Mathieu Hofman: Do you think we should continue with AsyncContext as currently proposed, without changes like #83?

[12:32:19.0123] <Steve Hicks>
Are we also considering taking the smaller-scoped `callingContext` API off the table?

[12:33:34.0532] <Steve Hicks>
#83 has made me pretty concerned about scope creep.  But I'm also obviously concerned about my own pet use cases.  I've got a meeting with Jatin this evening to hopefully nail down exactly what kind of registration- vs. call-time semantics we will need.


2024-05-14
[01:25:31.0956] <Stephen Belanger>
So if context _always_ flows into _all_ branches, all we _actually_ need is the context as it was when it reached a merge barrier. For example, context flows into each of the promise-returning functions passed into a `Promise.all(...)`. Each of these branches can change their context along the path but will only ever have one value. When the value eventually reaches the merge barrier where it would get placed in the array the `Promise.all(...)` call resolves to it would capture the single context value in that branch and store it in a merge context array of equal length to the `Promise.all(...)` input and output size.

The resulting merge context makes the most sense though if the resolve path is followed rather than the register path. If the register path is followed it just flattens same as the async/await issue I brought up, which means none of that merge context would reach anywhere useful if the register on the `Promise.all(...)` discards all that inner behaviour by binding around it. This is the sort of scenario why I want to have a way to get at calling context whenever a snapshot is restored. Either that or have a way to, on a per-store basis, reject the snapshot restore decision and keep using the value that propagated through the internal branch.

Merge contexts are a bit weird though as it transforms a single value into an array of values, so I think it still makes sense to "pick a winner" for the default behaviour and just provide power users an additional power tool there, which might require a bit more manual intervention, to get at the full merge context list.

[04:29:47.0480] <Andreu Botella>
While thinking about the rejection context of web APIs that take async callbacks, I realized that if you do something like this, there's no way to preserve the rejection context even if you explicitly want to:
```js
asyncCb().catch(err => {
    if (something(err)) {
        return someValue;
    } else {
        throw err;
    }
});
```

[04:30:10.0897] <Andreu Botella>
at least that would be in the current spec text

[04:30:22.0563] <Andreu Botella>
in Stephen's version it would work as expected

[04:30:43.0910] <Andreu Botella>
 * While thinking about the rejection context of web APIs that take async callbacks, I realized that if you do something like this, there's no way to preserve the original rejection context even if you explicitly want to:

```js
asyncCb().catch(err => {
    if (something(err)) {
        return someValue;
    } else {
        throw err;
    }
});
```

[04:31:48.0717] <Andreu Botella>
fulfillment contexts aren't observable, but rejection contexts are with `unhandledrejection`

[10:08:10.0040] <Chengzhong Wu>
ICYMI notes are here https://docs.google.com/document/d/1pi-NMbqVhg2UuxQAZ4jOGDeHLlZGD_DJ7fyxHt_C2hs/edit and please feel free to correct it

[15:11:40.0056] <littledan>
> <@stephenhicks:matrix.org> #83 has made me pretty concerned about scope creep.  But I'm also obviously concerned about my own pet use cases.  I've got a meeting with Jatin this evening to hopefully nail down exactly what kind of registration- vs. call-time semantics we will need.

I am curious what you found in that discussion 

[16:42:39.0618] <littledan>
Does anyone have a consolidated description of what “Stephen’s version” is?

[16:43:14.0137] <littledan>
I mean in particular what the diff would be vs the current proposal (without the other superficial changes)

[16:49:26.0563] <littledan>
Per-instance wrap is a convenience function, in my understanding. Did you get a chance to discuss that? I don’t see notes about it 

[16:50:21.0773] <littledan>
Did we ever get an answer on how callingContext would relate to Promise.all?


2024-05-15
[21:28:51.0748] <Steve Hicks>
One of my AI's was to go through Stephen's docs and try to figure out what the gist of it was.  I think Stephen was also going to try to distill it down a bit further, though it was late for him by the end of the meeting.  Variable.prototype.wrap is a convenience function and I think we agreed to more or less table it for now.  But there's also a question of per-instance propagation configuration that is impossible to do in userland (i.e. some vars propagate via init/registration context, while others propagate via causal/calling context).  Per a discussion today with Scott Haseley, it sounds like there's already some precedent for this in how v8 handles yield vs. normal CPED/attribution, in that the latter propagates over setTimeout while the former is dropped.  In the case of multiple variable configs, I think it would boil down to having effectively two separate variable linked lists instead of one, and they're treated differently by snapshot swapping.  This may not be infeasible, so it's maybe worth considering whether it leads to a good solution.

We didn't get a chance to discuss callingContext, though (tbh) it's still my preferred option for ensuring the APM use case is viable - but we still need to figure out Promise.all.  One (totally off-the-cuff) possibility would be to just stack up all the causal contexts, first-to-last.  You know how many promises were merged, so you can pop that many contexts off the stack if you need them all.

Upshot from discussion with Jatin was that he agreed that calling context is crucial, and figured that most userland schedulers (at least the ones he owns) would probably need to go with that default.  Registration context is useless for our use of computed signals and effects (and he was particularly concerned about losing the ability to see causal context if/when Signals land in the standard), and we'd need to propagate causal context throughout all the stages of (user interaction) -> (lazy load, controller instantiation) -> (rpc fetch) -> (model cache update) -> (component rerender) in order to ensure tracing works correctly.  These are all (currently) userland schedulers, at least, so it's possible, but ultimately the hope is to replace the model cache with signals.

[21:30:46.0510] <Steve Hicks>
 * One of my AI's was to go through Stephen's docs and try to figure out what the gist of it was.  I think Stephen was also going to try to distill it down a bit further, though it was late for him by the end of the meeting.  Variable.prototype.wrap is a convenience function and I think we agreed to more or less table it for now.  But there's also a question of per-instance propagation configuration that is impossible to do in userland (i.e. some vars propagate via init/registration context, while others propagate via causal/calling context).  Per a discussion today with Scott Haseley, it sounds like there's already some precedent for this in how v8 handles yield vs. normal CPED/attribution, in that the latter propagates over setTimeout while the former is dropped.  In the case of multiple variable configs, I think it would boil down to having effectively two separate variable linked lists instead of one, and they're treated differently by snapshot swapping.  This may not be infeasible, so it's maybe worth considering whether it leads to a good solution.

We didn't get a chance to discuss callingContext, though (tbh) it's still my preferred option for ensuring the APM use case is viable, due to balancing the extra complexity and feasibility of ever actually landing this proposal, vs stalling out from trying to do too much - but we do still need to figure out Promise.all.  One (totally off-the-cuff) possibility would be to just stack up all the causal contexts, first-to-last.  You know how many promises were merged, so you can pop that many contexts off the stack if you need them all.

Upshot from discussion with Jatin was that he agreed that calling context is crucial, and figured that most userland schedulers (at least the ones he owns) would probably need to go with that default.  Registration context is useless for our use of computed signals and effects (and he was particularly concerned about losing the ability to see causal context if/when Signals land in the standard), and we'd need to propagate causal context throughout all the stages of (user interaction) -> (lazy load, controller instantiation) -> (rpc fetch) -> (model cache update) -> (component rerender) in order to ensure tracing works correctly.  These are all (currently) userland schedulers, at least, so it's possible, but ultimately the hope is to replace the model cache with signals.

[21:48:43.0463] <Steve Hicks>
I took a stap at implementing the stack-based Promise.all in userland with callingContext, and I ran into a brick wall because there's no way to actually stack multiple top-level frames: https://www.typescriptlang.org/play/?#code/CYUwxgNghgTiAEA7KBbEBnADlMCCC6AnomAMID2iALiAB5XwDeAUPPHZuTA5FOuvADKyTOgAW5BizZsYAV0QAeACoA+ABQAzRAC546gJTwAvKvjKDe5axnoqUKgEsw8AO4womRQDF29EIjAAt4KYE6UGtp63pbw3gDcNgC+NhxcDJqh4YjwYFAQEI6IAOYU1HRUKpG6+kam5rHKiSnMmSTZ8Jgw5CiO6CB4BSp+NIECAArdvf2KCgDWiOSuiKoA2gC6Gl09fRhWsZM7M4yrANLwRfBzIITkmubreniuUI40wCpnm0lm0vAQIAY6BE4kkTyIJDKNHoADphJ5QVQAD4KUCaIogYCJNhgSh2eBwdByCBUdB6eaLZYbEydKa7dAwlCedSGExmVEgdGITEGbH-QG5cgKBjGWlHDAwgElKhiPlwKhyGA5bmueCHaYgFmE8gQABuIAANASQAArcBUOq-GxsTRcfQAhiOGkABniF3gijFGoZUuKMrdjgA1IGjH8ZF76atHOsYTKAizdflLUxreHjUSSego+saYmIHy0xd7uoAITAhESC0pwvh8uiSs0gjEMiUaFUGF5ApFUqtios5Mq+BNyG92Hw+uSQy81PhpLsCD9as1th1xE01eVmHyRD9tlL5dsAD0h-gADkAPLKACiehlfXgwHIGCQkngAEc5G8EK4uHN4AAjcAoDkRc41yfJChKKEKjcRwClyCByH-QCYBnGtj3gMCN1fMQ+ioLhCCNKBAngXVnAQfUYHQKAYTYAB1BB-z4ZwIMIJAQExeAoDcKA2PwzpiQgNDCwwoUGG49BuwBeBNA8NAjVcXCwDEeB+hAFABHUBwZMcKiGGKaASENTDyHgNAjFxagPGAZx8JgQhhLTDDXDeFTAO7Lj-2k-icFwfhwK7EpBXKegBFgBBYH-N4PHsh8QEwGUjQUAF+Ec8MMKZQhAMwsQEE7SCexChg8HGABJTCoGuMK4oSlTsDkwEQBgWihwXcgFJAAByfV-nIOw0pkDCwNxGA4DCAKCug+h4FyuAuJIuM5sfDBEE6oEOJQEyAIini+PIAajxPYoBW0t4YQO40FSVIcIRbIqOwg7spqoXd6kHYc7rbOEQUrKcCxrJJp2XFJl0cYsAFpwdxYV4DMZ0jHlRVEH+2sfskLcFFesxtT1TVCWJUkuLCxBCAMIG0ySI11CamBkzDNM4DNMJqdG8nZwMVMQfgQHmmYIA

[21:49:12.0666] <Steve Hicks>
 * I took a stap at implementing the stack-based Promise.all in userland with callingContext, and I ran into a brick wall because there's no way to actually stack multiple top-level frames: [playground](https://www.typescriptlang.org/play/?#code/CYUwxgNghgTiAEA7KBbEBnADlMCCC6AnomAMID2iALiAB5XwDeAUPPHZuTA5FOuvADKyTOgAW5BizZsYAV0QAeACoA+ABQAzRAC546gJTwAvKvjKDe5axnoqUKgEsw8AO4womRQDF29EIjAAt4KYE6UGtp63pbw3gDcNgC+NhxcDJqh4YjwYFAQEI6IAOYU1HRUKpG6+kam5rHKiSnMmSTZ8Jgw5CiO6CB4BSp+NIECAArdvf2KCgDWiOSuiKoA2gC6Gl09fRhWsZM7M4yrANLwRfBzIITkmubreniuUI40wCpnm0lm0vAQIAY6BE4kkTyIJDKNHoADphJ5QVQAD4KUCaIogYCJNhgSh2eBwdByCBUdB6eaLZYbEydKa7dAwlCedSGExmVEgdGITEGbH-QG5cgKBjGWlHDAwgElKhiPlwKhyGA5bmueCHaYgFmE8gQABuIAANASQAArcBUOq-GxsTRcfQAhiOGkABniF3gijFGoZUuKMrdjgA1IGjH8ZF76atHOsYTKAizdflLUxreHjUSSego+saYmIHy0xd7uoAITAhESC0pwvh8uiSs0gjEMiUaFUGF5ApFUqtios5Mq+BNyG92Hw+uSQy81PhpLsCD9as1th1xE01eVmHyRD9tlL5dsAD0h-gADkAPLKACiehlfXgwHIGCQkngAEc5G8EK4uHN4AAjcAoDkRc41yfJChKKEKjcRwClyCByH-QCYBnGtj3gMCN1fMQ+ioLhCCNKBAngXVnAQfUYHQKAYTYAB1BB-z4ZwIMIJAQExeAoDcKA2PwzpiQgNDCwwoUGG49BuwBeBNA8NAjVcXCwDEeB+hAFABHUBwZMcKiGGKaASENTDyHgNAjFxagPGAZx8JgQhhLTDDXDeFTAO7Lj-2k-icFwfhwK7EpBXKegBFgBBYH-N4PHsh8QEwGUjQUAF+Ec8MMKZQhAMwsQEE7SCexChg8HGABJTCoGuMK4oSlTsDkwEQBgWihwXcgFJAAByfV-nIOw0pkDCwNxGA4DCAKCug+h4FyuAuJIuM5sfDBEE6oEOJQEyAIini+PIAajxPYoBW0t4YQO40FSVIcIRbIqOwg7spqoXd6kHYc7rbOEQUrKcCxrJJp2XFJl0cYsAFpwdxYV4DMZ0jHlRVEH+2sfskLcFFesxtT1TVCWJUkuLCxBCAMIG0ySI11CamBkzDNM4DNMJqdG8nZwMVMQfgQHmmYIA)

[21:49:25.0424] <Steve Hicks>
 * I took a stab at implementing the stack-based Promise.all in userland with callingContext, and I ran into a brick wall because there's no way to actually stack multiple top-level frames: [playground](https://www.typescriptlang.org/play/?#code/CYUwxgNghgTiAEA7KBbEBnADlMCCC6AnomAMID2iALiAB5XwDeAUPPHZuTA5FOuvADKyTOgAW5BizZsYAV0QAeACoA+ABQAzRAC546gJTwAvKvjKDe5axnoqUKgEsw8AO4womRQDF29EIjAAt4KYE6UGtp63pbw3gDcNgC+NhxcDJqh4YjwYFAQEI6IAOYU1HRUKpG6+kam5rHKiSnMmSTZ8Jgw5CiO6CB4BSp+NIECAArdvf2KCgDWiOSuiKoA2gC6Gl09fRhWsZM7M4yrANLwRfBzIITkmubreniuUI40wCpnm0lm0vAQIAY6BE4kkTyIJDKNHoADphJ5QVQAD4KUCaIogYCJNhgSh2eBwdByCBUdB6eaLZYbEydKa7dAwlCedSGExmVEgdGITEGbH-QG5cgKBjGWlHDAwgElKhiPlwKhyGA5bmueCHaYgFmE8gQABuIAANASQAArcBUOq-GxsTRcfQAhiOGkABniF3gijFGoZUuKMrdjgA1IGjH8ZF76atHOsYTKAizdflLUxreHjUSSego+saYmIHy0xd7uoAITAhESC0pwvh8uiSs0gjEMiUaFUGF5ApFUqtios5Mq+BNyG92Hw+uSQy81PhpLsCD9as1th1xE01eVmHyRD9tlL5dsAD0h-gADkAPLKACiehlfXgwHIGCQkngAEc5G8EK4uHN4AAjcAoDkRc41yfJChKKEKjcRwClyCByH-QCYBnGtj3gMCN1fMQ+ioLhCCNKBAngXVnAQfUYHQKAYTYAB1BB-z4ZwIMIJAQExeAoDcKA2PwzpiQgNDCwwoUGG49BuwBeBNA8NAjVcXCwDEeB+hAFABHUBwZMcKiGGKaASENTDyHgNAjFxagPGAZx8JgQhhLTDDXDeFTAO7Lj-2k-icFwfhwK7EpBXKegBFgBBYH-N4PHsh8QEwGUjQUAF+Ec8MMKZQhAMwsQEE7SCexChg8HGABJTCoGuMK4oSlTsDkwEQBgWihwXcgFJAAByfV-nIOw0pkDCwNxGA4DCAKCug+h4FyuAuJIuM5sfDBEE6oEOJQEyAIini+PIAajxPYoBW0t4YQO40FSVIcIRbIqOwg7spqoXd6kHYc7rbOEQUrKcCxrJJp2XFJl0cYsAFpwdxYV4DMZ0jHlRVEH+2sfskLcFFesxtT1TVCWJUkuLCxBCAMIG0ySI11CamBkzDNM4DNMJqdG8nZwMVMQfgQHmmYIA)

[21:53:22.0968] <Steve Hicks>
I can see a few variants on callingContext: (1) it just puts the previous frame directly on top of the current one (i.e. behaves identical to Snapshot.run) - in this case, one could just _make_ it a snapshot?  This makes it impossible to access deeper-nested ones, since `callingContext()` will just get you back to the previous (registration?) context.  Unless maybe it takes a depth argument.  In that case, the stacking might _just_ be possible.  Or (2) it restores the entire context stack to whatever it looked like in the calling environment, such that a second `callingContext`would go back further in causation history.

[04:07:39.0392] <Stephen Belanger>
I made this small (-ish) example of how we're doing that differentiation between child-of and follows-from relationships and what we're trying to do with holding the minimum possible data in the store (just the ID). https://gist.github.com/Qard/6ceaca8bb792679e82c7693513baee0e

[04:37:17.0878] <Stephen Belanger>
In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not _too_ terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not _too_ terribly important as we at least get _one_ of the branches so we can still _mostly_ understand the execution structure. But we _do_ need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The example above are meant to show that we are expecting something which logically _continues_ from a particular point is expected to be able to attribute itself from that. Whereas what we get _currently_ with both async/await and promises is a flat structure where all the `mysql.query` spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.

[04:37:42.0630] <Stephen Belanger>
 * In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not _too_ terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not _too_ terribly important as we at least get _one_ of the branches so we can still _mostly_ understand the execution structure.

But we _do_ need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The example above are meant to show that we are expecting something which logically _continues_ from a particular point is expected to be able to attribute itself from that. Whereas what we get _currently_ with both async/await and promises is a flat structure where all the `mysql.query` spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.

[04:37:58.0257] <Stephen Belanger>
 * In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not _too_ terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not _too_ terribly important as we at least get _one_ of the branches so we can still _mostly_ understand the execution structure.

But we _do_ need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The examples above are meant to show that we are expecting something which logically _continues_ from a particular point is expected to be able to attribute itself from that. Whereas what we get _currently_ with both async/await and promises is a flat structure where all the `mysql.query` spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.

[04:38:14.0551] <Stephen Belanger>
 * In those examples we have a solution to the need to separate child-of and follows-from relationships, which is not _too_ terribly complicated, so we can live with that. And as I expressed previously the multiple follows-from thing is not _too_ terribly important as we at least get _one_ of the branches so we can still _mostly_ understand the execution structure.

But we _do_ need to be able to flow through at least singular pathed merges like an await or then continuation of a single promise. The examples above are meant to show that we are expecting something which logically _continues_ from a particular point is expected to be able to attribute itself to that. Whereas what we get _currently_ with both async/await and promises is a flat structure where all the `mysql.query` spans within those examples would get flattened up to linking with the http.server span, even if the second query has another query between it and the http handler starting.

[07:37:17.0513] <littledan>
I am confused by general comments on registration time vs call time. Can we do more to dig into the detailed cases? (Am chatting with Jatin about this now too)

[07:38:02.0412] <littledan>
Andreu had some sort of point by point analysis. What if we made that a Google Doc and then we could comment together on which things could/should be different for which use cases?

[07:49:04.0939] <littledan>
In reality there will be a mix of both registration time and call time, so I have trouble understanding conversations which are phrases like “vs”

[08:27:53.0387] <Steve Hicks>
A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. <button on click="..."> with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need _some_ option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.

[08:50:04.0717] <Steve Hicks>
 * A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. \<buttonon click="..."> with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need \_some\_ option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.

[08:50:17.0220] <Steve Hicks>
 * A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. \<buttonon click="..."> with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need _some_ option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.

[08:50:35.0814] <Steve Hicks>
 * A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. \<button onclick="..."> with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need _some_ option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.

[08:58:49.0527] <Stephen Belanger>
I'm wondering if await/yield/then binding should just be a config per-store and we can just hold two sets of stores so ones that _do_ have that turned on do those binds and ones that have it turned off don't get tracked in that list at all. Just a random idea. And to be clear, I don't care which way is the default. If we have the capability to switch to the other on our stores then that's basically the one single major blocker for APM vendors right now, as far as I can tell. 🤔

[09:22:42.0347] <Steve Hicks>
I think if we had that option then it would end up needing to be _three_ different sets in the long run, since `scheduler.yield` (and/or `scheduler.currentTaskSignal`) would need yet a different propagation, where it _does_ propagate across `await`, but +not_ through `setTimeout`.

[09:22:59.0662] <Steve Hicks>
 * I think if we had that option then it would end up needing to be _three_ different sets in the long run, since `scheduler.yield` (and/or `scheduler.currentTaskSignal`) would need yet a different propagation, where it _does_ propagate across `await`, but _not_ through `setTimeout`.

[12:13:09.0256] <littledan>
> <@stephenhicks:matrix.org> A doc sounds like a good idea. Yes, there will be a mix, but there's more nuance than that. There's questions of consistency (e.g. button.addEventListener with a UI click vs. \<button onclick="..."> with programmatic button.click() - do these behave the same? My opinion is no) and expressivity (I think it's clear we need _some_ option to override the default in either direction). As long as there's an override to fix any mismatched default, I think we're in pretty good shape.

Can you say more about how you imagine that option being used? One possible default could be “use the originating/call context where available, otherwise fall back to registration if it doesn’t exist” and you could override that to “always registration time” by wrapping your callback yourself.

[12:13:28.0674] <littledan>
In that case, no options bag needed

[12:14:40.0654] <littledan>
Another is “always registration time, and you get passed the originating snapshot in a property of the event, which you can then .run within if you want” (again, you could choose the opposite default by wrapping the callback, this time in something that got the snapshot out and applied it)

[12:15:05.0724] <littledan>
In either case it would be OK to include an option as an ergonomic niceity but it seems optional to me

[12:15:48.0092] <littledan>
> <@stephenhicks:matrix.org> I think if we had that option then it would end up needing to be _three_ different sets in the long run, since `scheduler.yield` (and/or `scheduler.currentTaskSignal`) would need yet a different propagation, where it _does_ propagate across `await`, but _not_ through `setTimeout`.

Why were these semantics chosen for priority, btw?

[12:16:47.0572] <littledan>
> <@stephenbelanger:matrix.org> I'm wondering if await/yield/then binding should just be a config per-store and we can just hold two sets of stores so ones that _do_ have that turned on do those binds and ones that have it turned off don't get tracked in that list at all. Just a random idea. And to be clear, I don't care which way is the default. If we have the capability to switch to the other on our stores then that's basically the one single major blocker for APM vendors right now, as far as I can tell. 🤔

Yeah I could see the “two types of variables” idea but I don’t see how it solves the “maintain follows-from links” problem

[12:18:29.0841] <littledan>
Also I don’t really know how we would make the call-biased variables work

[12:19:16.0860] <Steve Hicks>
> <@littledan:matrix.org> Another is “always registration time, and you get passed the originating snapshot in a property of the event, which you can then .run within if you want” (again, you could choose the opposite default by wrapping the callback, this time in something that got the snapshot out and applied it)

I think this approach is problematic because it only really works for events.  But there's a handful of other APIs (e.g. IntersectionObserver and MutationObserver, various Promise APIs, hypothetical future signals, etc) that don't have any events and you'd need a different custom solution for each to solve effectively the same problem.

[12:19:49.0352] <Andreu Botella>
> <@stephenhicks:matrix.org> I think this approach is problematic because it only really works for events.  But there's a handful of other APIs (e.g. IntersectionObserver and MutationObserver, various Promise APIs, hypothetical future signals, etc) that don't have any events and you'd need a different custom solution for each to solve effectively the same problem.

for observers you could have a property of the observer entry

[12:20:16.0242] <littledan>
Yeah I think this works *better* for observers than other options since they have a single callback for multiple things

[12:21:18.0355] <Andreu Botella>
> <@littledan:matrix.org> Why were these semantics chosen for priority, btw?

I think because `scheduler.yield()` wants to distinguish between a continuation of the current task and a subtask

[12:21:23.0183] <littledan>
For promise-based APIs: I am having trouble picturing what we would want and how; maybe you could give a concrete example of where you don’t want the restore-around-await semantics (“registration time”) and what you want instead?

[12:21:41.0153] <littledan>
> <@abotella:igalia.com> I think because `scheduler.yield()` wants to distinguish between a continuation of the current task and a subtask

What does that have to do with setTimeout?

[12:21:52.0562] <Steve Hicks>
> <@littledan:matrix.org> Why were these semantics chosen for priority, btw?

I don't know the background there.  I scanned through https://github.com/WICG/scheduling-apis/blob/main/explainers/yield-and-continuation.md but don't see anything specifically about this choice.

[12:22:00.0667] <Andreu Botella>
> <@littledan:matrix.org> What does that have to do with setTimeout?

`setTimeout` would be a subtask

[12:22:33.0403] <littledan>
> <@stephenhicks:matrix.org> I don't know the background there.  I scanned through https://github.com/WICG/scheduling-apis/blob/main/explainers/yield-and-continuation.md but don't see anything specifically about this choice.

I guess you are relaying this case based on personal communication with Scott? Maybe he can clarify (or join here)?

[12:23:21.0321] <Steve Hicks>
> <@littledan:matrix.org> I guess you are relaying this case based on personal communication with Scott? Maybe he can clarify (or join here)?

Yes, I can ask.

[12:23:46.0963] <littledan>
> <@littledan:matrix.org> Can you say more about how you imagine that option being used? One possible default could be “use the originating/call context where available, otherwise fall back to registration if it doesn’t exist” and you could override that to “always registration time” by wrapping your callback yourself.

What do you think of this option Steve Hicks ?

[12:24:22.0322] <Andreu Botella>
> <@littledan:matrix.org> I guess you are relaying this case based on personal communication with Scott? Maybe he can clarify (or join here)?

from a conversation I had with him:
> It's important (as of now, subject to change) that those [yield-related CPED state fields] are not propagated to subtasks and events. The idea is that yield() can inherit the priority of the current task, but the current task and subtasks are not necessarily related (i.e. breaking up the current task by yielding in a loop does not imply other work spawned should have the same priority). It's possible this will change, but as of now we need to keep that behavior.

[12:24:42.0046] <Steve Hicks>
> <@littledan:matrix.org> For promise-based APIs: I am having trouble picturing what we would want and how; maybe you could give a concrete example of where you don’t want the restore-around-await semantics (“registration time”) and what you want instead?

My understanding is that this is what Stephen is asking for.  I don't have quite as good a sense of the use case, but from the examples I've seen, he wants to `await openFile()` and have a trace span opened in `openFile` still be present on the outside.

[12:25:01.0268] <Andreu Botella>
> <@littledan:matrix.org> I guess you are relaying this case based on personal communication with Scott? Maybe he can clarify (or join here)?

 * from a conversation I had with him:

> It's important (as of now, subject to change) that those \[yield-related fields of the object propagated through CPED\] are not propagated to subtasks and events. The idea is that yield() can inherit the priority of the current task, but the current task and subtasks are not necessarily related (i.e. breaking up the current task by yielding in a loop does not imply other work spawned should have the same priority). It's possible this will change, but as of now we need to keep that behavior.

[12:25:33.0243] <littledan>
Do *you* run into cases where you want this behavior with promises?

[12:26:43.0981] <Steve Hicks>
> <@littledan:matrix.org> Yeah I think this works *better* for observers than other options since they have a single callback for multiple things

That may be so on an individual level, but it's still a different solution for each situation, which I see as a big problem since it leads to everyone having to figure out for every given situation "how do I do this thing?".  Also, it's ideal when userland APIs can have analogous behavior to builtins, and so every userland scheduler would also need to come up with their own custom solution.

[12:29:14.0427] <Steve Hicks>
> <@littledan:matrix.org> What do you think of this option Steve Hicks ?

I don't love the "where available" framing - it feels very "zalgo-adjacent" where you can never really be sure what context something will run in because it depends on external factors (e.g. for a click handler, it could run in either, depending on if it's dispatched programmatically or by user action).  As a result, you just can't really rely on anything.

[12:29:24.0573] <littledan>
Do you have another idea for how we should handle observers?

[12:30:02.0758] <Steve Hicks>
I favor a general solution that doesn't rely on details of the scheduling API.

[12:30:20.0230] <Steve Hicks>
something more like AsyncContext.callingContext where it works in all cases

[12:30:45.0663] <Steve Hicks>
 * I favor a general solution that doesn't rely on details of the scheduling API's shape.

[12:31:00.0481] <littledan>
> <@stephenhicks:matrix.org> I favor a general solution that doesn't rely on details of the scheduling API's shape.

Of course, but I guess the scheduling API assumes it can be based on a primitive with certain properties, and we are trying to understand what that primitive is…

[12:31:52.0874] <littledan>
If the decision was not made for a very strong reason and turns out to be kinda irregular compared to other needs, we shouldn’t necessarily turn ourselves inside out trying to solve for it. But if it’s a good reason, that is different 

[12:32:37.0646] <littledan>
I don’t understand how callingContext would relate to dropping things on setTimeout

[12:33:44.0657] <Steve Hicks>
sorry, my statement about dropping on setTimeout was just about how (as currently spec'd) neither of the two default-propagation behaviors we're considering would actually work to enable replacing the current yield propagation with AsyncContext

[12:34:17.0877] <Steve Hicks>
 * sorry, my statement about dropping on setTimeout was just about how neither of the two default-propagation behaviors we're considering would actually work to enable replacing the current yield propagation (as currently spec'd) with AsyncContext

[12:34:18.0117] <littledan>
> <@stephenhicks:matrix.org> I don't love the "where available" framing - it feels very "zalgo-adjacent" where you can never really be sure what context something will run in because it depends on external factors (e.g. for a click handler, it could run in either, depending on if it's dispatched programmatically or by user action).  As a result, you just can't really rely on anything.

Yeah, I share the Zalgo concern, but maybe a bit more broadly. With signals, for example, it feels kinda Zalgo to me if we propagate in things about where the computed was read from (since that is a race in itself). But from taking with Jatin, I understand that he wants to see what triggers what in responding to a user gesture, so it’s kinda needed. An unfortunate contradiction 

[12:35:02.0507] <Steve Hicks>
I'll go back to the doc idea you had - we need to get more known use cases and situations documented, I think, in order to get more insight into the downstream ramifications on application code, etc

[12:35:10.0921] <littledan>
> <@stephenhicks:matrix.org> sorry, my statement about dropping on setTimeout was just about how neither of the two default-propagation behaviors we're considering would actually work to enable replacing the current yield propagation (as currently spec'd) with AsyncContext

Yeah, I agree; do you have an idea for an alternative that would handle this?

[12:35:44.0898] <Steve Hicks>
> <@littledan:matrix.org> Yeah, I agree; do you have an idea for an alternative that would handle this?

Sadly no.  Change the scheduler spec?

[12:36:34.0545] <Steve Hicks>
(to allow propagating across child tasks like an ordinary async var)

[12:37:36.0326] <littledan>
That is my first intuition but it’s because I don’t understand the motivation for the current design 

[12:38:19.0806] <littledan>
What would be unscalable is for each variable to have custom logic at each point where it might be propagated. I guess APMs have this power today though.

[12:39:43.0344] <Steve Hicks>
In terms of downstream repercussions, I'm thinking about app developers writing their handlers, middleware, signals, etc.  I believe a fundamental axiom here is (or at least, I'd like it to be) that frameworks can put vars in place and app developers don't need to be aware of what those vars are - so needing to explicitly do anything with callingContext in their own callbacks would be a problem, and if there's a few layers of application code in the way such that the framework can't just pull their variable off the "top" callingContext, then that approach probably wouldn't work.

[12:41:10.0900] <littledan>
Agreed. And in general you can have lots of merges that look like that, I think (so Promise.all integration isn’t quite enough)

[12:41:24.0292] <littledan>
This is why the “two classes of variables” idea appeals to me somewhat (but I still don’t know how it would work)

[12:43:28.0291] <Steve Hicks>
> <@littledan:matrix.org> This is why the “two classes of variables” idea appeals to me somewhat (but I still don’t know how it would work)

agreed - especially if the "calling context" flavor means that it doesn't propagate across an `await`, then I'm not sure it's viable, though (IIUC) that would be more consistent with how then() would behave?

[12:45:45.0438] <Andreu Botella>
On an unrelated note, what do you expect this to print?
```js
function cb() {
  asyncVar.run("foo", () => {
    throw new Error();
  });
}

asyncVar.run("bar", cb);

window.addEventListener("error", () => {
  console.log(asyncVar.get());
}, {useOriginatingContext: true});
```

[12:46:05.0812] <Andreu Botella>
with the current spec, the only thing this could print is `bar`, but I'd expect that's not the expected behavior

[12:48:07.0326] <Steve Hicks>
> <@abotella:igalia.com> with the current spec, the only thing this could print is `bar`, but I'd expect that's not the expected behavior

I find that incredibly surprising.  My mental model is that `v.run(a, () => v.run(b, f))` is equivalent to `v.run(b, f)`.

[12:48:20.0675] <Andreu Botella>
ohw ait

[12:48:23.0163] <Steve Hicks>
though obviously that would change w/ callingContext

[12:48:25.0148] <Andreu Botella>
 * oh wait

[12:48:29.0978] <Andreu Botella>
my bad

[12:48:45.0639] <Andreu Botella>
 * On an unrelated note, what do you expect this to print?

```js
function cb() {
  asyncVar.run("foo", () => {
    throw new Error();
  });
}

asyncVar.run("bar", => {
  setTimeout(cb, 0);
});

window.addEventListener("error", () => {
  console.log(asyncVar.get());
}, {useOriginatingContext: true});
```

[12:48:51.0021] <Andreu Botella>
I meant to have `setTimeout` there

[12:50:39.0829] <Steve Hicks>
I'm still lacking some intuition here... how is this different from running `cb` directly in bar?

[12:51:13.0976] <Andreu Botella>
I guess it's not

[12:51:44.0917] <Andreu Botella>
the thing is, when `.run()` returns it will always restore the previous context, even if the callback threw

[12:51:50.0192] <Steve Hicks>
other than i guess that the error is async

[12:52:08.0103] <Andreu Botella>
so when the execution gets back to `setTimeout`, the current context is `bar`

[12:52:26.0605] <Andreu Botella>
the context active at throw time isn't preserveed

[12:52:30.0203] <Andreu Botella>
 * the context active at throw time isn't preserved

[12:53:23.0517] <Steve Hicks>
I thought it was? Isn't that the point of useOriginatingContext?

[12:53:53.0524] <Steve Hicks>
so yah, I'd still expect either undefined or foo

[12:54:19.0089] <Andreu Botella>
> <@stephenhicks:matrix.org> I thought it was? Isn't that the point of useOriginatingContext?

`useOriginatingContext` is there so the registration time isn't used

[12:55:42.0312] <Andreu Botella>
run is basically implemented like:
```js
function run(value, cb) {
  const previousContext = changeContext(updateContext(value));
  try {
    return cb();
  } finally {
    changeContext(previousContext);  // this loses track of foo and restores bar
  }
}
```

[12:56:00.0204] <Andreu Botella>
there's currently nothing in the spec text that preserves the context in which an exception is thrown

[12:56:23.0995] <Andreu Botella>
because the caller context is switched in the finally

[12:57:13.0919] <Andreu Botella>
 * because the current context is switched back to the previous one in the finally

[12:57:32.0384] <Steve Hicks>
ah, my understanding was that unhandled rejections (at least) would hold onto the rejection context.  I'd assumed that this extended to "error" as well, though that's not an API I'm familiar with

[12:58:13.0610] <Andreu Botella>
yeah, I think no one considered error until I started looking into it last week

[12:58:53.0224] <Andreu Botella>
I suspect that making that work would mean patching how completions work in the spec 😰

[12:59:35.0331] <Andreu Botella>
though I guess you could also have a `lastThrowContext` global state

[12:59:50.0283] <Andreu Botella>
that would only be used if `cb()` threw

[13:00:16.0952] <Andreu Botella>
that's a much less invasive change

[13:20:29.0295] <Andreu Botella>
Do we want to exposed the last thrown context to userland? Are there userland implementations of something like the error event?

[13:20:52.0447] <Andreu Botella>
Something like that in V8 would definitely be needed for JS runtimes like Node.js and Deno, since they implement the error event in JS

[13:22:21.0222] <Steve Hicks>
Does this require instrumenting every `throw` in order to polyfill?

[13:22:46.0729] <Andreu Botella>
> <@stephenhicks:matrix.org> Does this require instrumenting every `throw` in order to polyfill?

no, I think it would only require changing the `run` implementation

[13:23:19.0824] <Steve Hicks>
ah, so if you catch in a run, then you know it was a throw-context

[13:23:32.0459] <Steve Hicks>
what about await-resumptions?

[13:24:25.0952] <Steve Hicks>
probably would be handled by the async function instrumentation, i guess

[13:25:09.0778] <Andreu Botella>
> <@stephenhicks:matrix.org> what about await-resumptions?

I'll have to think about that

[13:25:31.0904] <Andreu Botella>
for the JS runtime use case, I think you only need sync throw handling

[13:26:06.0310] <Andreu Botella>
since anything else would use unhandledrejection rather than error


2024-05-16
[05:47:07.0194] <Stephen Belanger>
> <@littledan:matrix.org> For promise-based APIs: I am having trouble picturing what we would want and how; maybe you could give a concrete example of where you don’t want the restore-around-await semantics (“registration time”) and what you want instead?

We basically _never_ want to restore around await. We want context changes to flow through the resolve path and back to the continuation of that resolve after the await. It would do that automatically if we had that separate set that does resolve path flow rather than register path flow. Any then and await binds would just get skipped and instead the context value at the resolve point would be what gets propagated into the continuation.

[05:53:19.0842] <Stephen Belanger>
So our main concern for APM uses is that code which is functionally equivalent from the user perspective should produce an equivalent context graph. In the example I posted yesterday (https://gist.github.com/Qard/6ceaca8bb792679e82c7693513baee0e) I have three examples of an http request using async/await, raw promises, and callbacks respectively. All three examples are functionally identical from user-facing execution flow perspective, yet they produce _very_ different context graphs from AsyncContext because promises and async/await follow registration path rather than resolve path.

[05:54:09.0407] <Stephen Belanger>
It's very confusing to users when they rewrite their code from callbacks to promises and suddenly their traces look very different because the flow of the context graph is so different.

[07:10:53.0539] <littledan>
It is hard to square wanting to never restore around await with what you wrote in the doc about how AsyncLocalStorage mostly does what you want (when it restores around await)

[07:11:40.0644] <littledan>
I was persuaded by your doc that both paths are meaningful but now it seems like you are saying only one of them is, which is surprising

[07:14:01.0376] <littledan>
One suboptimal way to implement promise.all is to go for-of through the array and await each element. In this case, we would care about establishing links both from the context before the await, and from the thing we are awaiting 

[07:14:29.0497] <littledan>
(Assuming the context before the await somehow inherits the previous thing being awaited)

[07:16:00.0998] <littledan>
I see how, in our web integration, we could/should adopt the “prefer originating context when present” semantics. But it is still hard for me to understand this await argument.

[07:19:45.0216] <Andreu Botella>
> <@littledan:matrix.org> (Assuming the context before the await somehow inherits the previous thing being awaited)

This wouldn't be the case, unless we somehow make the calling context be an array of all promises that led to this point, which seems like clear overkill

[07:20:05.0125] <Andreu Botella>
> <@littledan:matrix.org> (Assuming the context before the await somehow inherits the previous thing being awaited)

 * This wouldn't be the case, unless we somehow make the calling context be an array of the contexts of all promises that led to this point, which seems like clear overkill

[08:07:01.0001] <Stephen Belanger>
> <@littledan:matrix.org> It is hard to square wanting to never restore around await with what you wrote in the doc about how AsyncLocalStorage mostly does what you want (when it restores around await)

By "mostly works" I mean it propagates correctly in most cases (callbacks), but async/await is not one of them. We have a pile of hacks to work around that currently lacking capability.

[08:07:50.0214] <Stephen Belanger>
ALS is "good enough" that we can provide a product that "works" but is _not_ good enough to provide something that works _well_.

[08:08:12.0537] <Stephen Belanger>
This is the whole reason _why_ we've been designing an entirely new thing.

[08:10:27.0434] <Andreu Botella>
I opened https://github.com/tc39/proposal-async-context/issues/90 to discuss the `error` event

[09:31:55.0921] <littledan>
> <@stephenbelanger:matrix.org> By "mostly works" I mean it propagates correctly in most cases (callbacks), but async/await is not one of them. We have a pile of hacks to work around that currently lacking capability.

where can I read more about that pile of hacks? (maybe you already wrote about it somewhere?)

[09:32:58.0102] <littledan>
> <@abotella:igalia.com> This wouldn't be the case, unless we somehow make the calling context be an array of the contexts of all promises that led to this point, which seems like clear overkill

I hope it's not necessary either, but I can see how Ste{v,ph}en's points argue for it to be necessary. (I'm having trouble understanding what you're supposed to do with currentContext besides reconstruct this array)

[09:41:14.0513] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> So our main concern for APM uses is that code which is functionally equivalent from the user perspective should produce an equivalent context graph. In the example I posted yesterday (https://gist.github.com/Qard/6ceaca8bb792679e82c7693513baee0e) I have three examples of an http request using async/await, raw promises, and callbacks respectively. All three examples are functionally identical from user-facing execution flow perspective, yet they produce _very_ different context graphs from AsyncContext because promises and async/await follow registration path rather than resolve path.

Whould you mind expanding on the distinguishing of child-of and follow-from? All promise resolutions are scheduled asynchronously, it seems to me that in this case "child-of" would be meaning-less in promise's case

[10:11:43.0878] <Andreu Botella>
> <@littledan:matrix.org> I hope it's not necessary either, but I can see how Ste{v,ph}en's points argue for it to be necessary. (I'm having trouble understanding what you're supposed to do with currentContext besides reconstruct this array)

I imagine that APMs could patch every built-in promise-returning API to get the span in the calling context, and then they could call the built-in inside `.run()` to start a new span – but that would only work as long as you never await a promise that was created before the last await

[10:12:00.0583] <Andreu Botella>
so yeah, I also want to know what exactly Stephen had in mind there

[10:51:16.0516] <littledan>
> <@abotella:igalia.com> I imagine that APMs could patch every built-in promise-returning API to get the span in the calling context, and then they could call the built-in inside `.run()` to start a new span – but that would only work as long as you never await a promise that was created before the last await

"awaiting a promise which was created before the last await" is exactly the Promise.all case, I think. It keeps being the "two contexts is not enough" problem.

[15:17:39.0176] <Steve Hicks>
The "don't bind around await" case feels a lot like "just use a global variable" to me.  To my mind, automatic binding around await is basically one of the main purposes of AC, so if you're not doing that, what are you gaining?  Is it just the question of restoring context after awaiting an already-done promise?  Assuming all awaited promises were pending when the await kicked off, then a simple model seems like doing nothing would "just work" since the continuation would follow immediately afterwards, so the global value would be correct.  Of course this breaks down when the await doesn't actually have to wait - and maybe also when two independent jobs are running interleaved?

So a global variable is obviously a bit too naive to work, but where I'm struggling is to understand how an AC.Variable with mutable state falls short?  That seems like it would address the issue of interleaved independent tasks, at least, and since (within the same task) you're presumably not clobbering the actual container variable, then that part shouldn't need to change after an await (and if it did, it could presumably be communicated back upstream).  ISTR Stephen mentioning performance concerns, but it's important to compare this against the performance cost of additional overhead needed to maintain a more complex graph, or more different kinds of state that need extra work to fork/join.

[15:23:20.0803] <Steve Hicks>
To Stephen's point about rewriting code from callbacks to promise/await, I agree that they should be consistent, but I'd argue that it's a transient issue.  Callback-based code should be updated to wrap the callbacks so that the behavior is the same.  I understand that the fact that ALS has existed for a while with the other behavior makes this a bit of a problem...  Ideally the standard Node APIs would have all been updated to wrap/bind when ALS first came out, before anyone began depending on the non-wrapping behavior.

[15:26:09.0827] <Steve Hicks>
Now, the fact that this wrapping would make a handful of existing use cases impossible is clearly a problem, and points to why we need some way to access the causing context, rather than just the registration context.  This could be as simple as a AsyncContext.Snapshot.noWrap that would prevent any automatic wrapping (or other implicit snapshot restoration that the VM would do via abstract operations), though it's not clear to me whether this would (or should!) provide the non-restoring async/await behavior?

[15:26:59.0482] <Steve Hicks>
 * Now, the fact that this wrapping would make a handful of existing use cases impossible is clearly a problem, and points to why we need some way to access the causing context, rather than just the registration context.  This could be as simple as a AsyncContext.Snapshot.noWrap that would prevent any automatic wrapping (or other implicit snapshot restoration that the VM would do via abstract operations), though it's not clear to me whether this would (or should!) provide the non-restoring async/await behavior (vs. just affecting what context callbacks are entered with the first time).


2024-05-17
[17:53:40.0800] <littledan>
> <@stephenhicks:matrix.org> Now, the fact that this wrapping would make a handful of existing use cases impossible is clearly a problem, and points to why we need some way to access the causing context, rather than just the registration context.  This could be as simple as a AsyncContext.Snapshot.noWrap that would prevent any automatic wrapping (or other implicit snapshot restoration that the VM would do via abstract operations), though it's not clear to me whether this would (or should!) provide the non-restoring async/await behavior (vs. just affecting what context callbacks are entered with the first time).

How would noWrap work?

[17:54:52.0752] <littledan>
Like it cancels out a wrap that happens around it?

[18:42:18.0145] <Steve Hicks>
yes, something like that - aside from being able to observe callingContext, wrapping is idempotent, so nowrap would maybe cancel _all_ wraps that happen around it?  not quite clear - it's just one option.

[19:26:13.0343] <littledan>
It feels kinda vaguely non-compositional to cancel out wrap; maybe better to avoid wrapping in the first place. Weren’t we discussing options for that? (But then you run into the “no null context” issue also)

[19:27:10.0280] <littledan>
I am not being very clear with noncompositional… I guess I mean, if you replace f with n => f(n), then noWrap stops working

[19:27:41.0651] <Steve Hicks>
not necessarily - it depends on how it's implemente.d

[19:27:49.0320] <Steve Hicks>
 * not necessarily - it depends on how it's implemented.

[19:29:33.0250] <Steve Hicks>
If the implementation is to explicitly restore the previous snapshot, then it's robust to `n => f(n)`, though it makes `wrap` no longer idempotent (i.e. `wrap(wrap(unwrap(f))) == wrap(f)`) and there's potentially weirdness around `unwrap(unwrap(f)) == f` or some such...

[19:30:11.0588] <Steve Hicks>
or if it popped off a stack instead of just swapping in the previous then it really would undo one layer

[19:30:20.0611] <Steve Hicks>
 * or if it popped off a stack instead of just swapping in the previous then it really would undo one layer for each

[19:30:56.0643] <Steve Hicks>
but it would only work from the _inside_ - `unwrap(wrap(f)) == wrap(f)`, which is surprising

[19:32:42.0489] <Steve Hicks>
I don't love those properties... but I think any observability of `callingContext` probably breaks idempotency of `wrap`, so maybe there's no way to keep that one?

[01:07:44.0279] <littledan>
Huh, how would it figure out the previous one at runtime? Currently you can just use a single global variable for the current snapshot.

[01:36:07.0864] <Stephen Belanger>
> <@legendecas:matrix.org> Whould you mind expanding on the distinguishing of child-of and follow-from? All promise resolutions are scheduled asynchronously, it seems to me that in this case "child-of" would be meaning-less in promise's case

The resolution is async, but we create a span around the thing that _created_ the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.

```js
async function foo() {
  console.log('1')
  await Promise.resolve()
  console.log('3')
}
foo()
console.log('2')
```

[01:42:10.0060] <littledan>
Do OTel implementations in any other language with async/await make this distinction properly? If so it would be great to be able to refer to their implementation strategies.

[01:42:41.0677] <Stephen Belanger>
> <@littledan:matrix.org> where can I read more about that pile of hacks? (maybe you already wrote about it somewhere?)

There's not really any writing on it presently, but basically because we don't flow into promise continuations we need to keep an object at the top-level of the request which we push spans into and basically _guess_ what the parent is because, unlike with callbacks, the parent does not flow into the continuation. This means we have to look at what has been pushed into that list in the past and try to guess what the parent would be. Sometimes it's simply the last span in the list, but not always, so we need to do some additional analysis to figure out what was the last span which _could_ be a realistic parent, which requires we also hold a bunch of the span metadata. Holding all this metadata is expensive given that we could have hundreds of thousands of concurrent spans. What we _want_ is for the _correct_ context to just be able to flow through the resolve path so we only need to store the IDs and can entirely eliminate that big bag of data which lives for the whole life of the request.

[01:45:51.0918] <Stephen Belanger>
> <@littledan:matrix.org> I hope it's not necessary either, but I can see how Ste{v,ph}en's points argue for it to be necessary. (I'm having trouble understanding what you're supposed to do with currentContext besides reconstruct this array)

We don't need the list of all context historically, only a way at any given snapshot restore to elect to keep the prior value which already flowed in and additionally to be able to have a way to configure stores to capture resolve time of promises rather than register time.

[01:51:57.0954] <Stephen Belanger>
> <@stephenhicks:matrix.org> The "don't bind around await" case feels a lot like "just use a global variable" to me.  To my mind, automatic binding around await is basically one of the main purposes of AC, so if you're not doing that, what are you gaining?  Is it just the question of restoring context after awaiting an already-done promise?  Assuming all awaited promises were pending when the await kicked off, then a simple model seems like doing nothing would "just work" since the continuation would follow immediately afterwards, so the global value would be correct.  Of course this breaks down when the await doesn't actually have to wait - and maybe also when two independent jobs are running interleaved?
> 
> So a global variable is obviously a bit too naive to work, but where I'm struggling is to understand how an AC.Variable with mutable state falls short?  That seems like it would address the issue of interleaved independent tasks, at least, and since (within the same task) you're presumably not clobbering the actual container variable, then that part shouldn't need to change after an await (and if it did, it could presumably be communicated back upstream).  ISTR Stephen mentioning performance concerns, but it's important to compare this against the performance cost of additional overhead needed to maintain a more complex graph, or more different kinds of state that need extra work to fork/join.

It's not that we need _no_ binds for async/await, it's that we want it to bind at the resolve point of the promise being awaited rather than at registration time directly at the point the await occurs. This would mean context would flow _through_ promises rather than _around_ them. It would _also_ mean the restore which occurs _after_ the await resumes would be that resolve point value rather than what the value was before the await occurred.

[01:53:57.0976] <Stephen Belanger>
> <@stephenhicks:matrix.org> To Stephen's point about rewriting code from callbacks to promise/await, I agree that they should be consistent, but I'd argue that it's a transient issue.  Callback-based code should be updated to wrap the callbacks so that the behavior is the same.  I understand that the fact that ALS has existed for a while with the other behavior makes this a bit of a problem...  Ideally the standard Node APIs would have all been updated to wrap/bind when ALS first came out, before anyone began depending on the non-wrapping behavior.

It's _intentional_ that it behaves that way with callbacks. That's how context management is _supposed_ to work as it's not useful for most cases if it doesn't flow into continuations. That's literally the _point_ of the "async" in AsyncLocalStorage.

[01:54:45.0906] <Stephen Belanger>
I'm not even sure what use there _would_ be for the other way with callbacks. I don't see any use case for that flow. 🤔

[01:58:05.0980] <Stephen Belanger>
> <@littledan:matrix.org> Do OTel implementations in any other language with async/await make this distinction properly? If so it would be great to be able to refer to their implementation strategies.

Yes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's _able_ to do this externally. With Node.js there is no solution.

[01:58:47.0882] <littledan>
> <@stephenbelanger:matrix.org> Yes, basically every other language flows this way with OTel, but other languages also provide things like bytecode manipulation so it's _able_ to do this externally. With Node.js there is no solution.

Other languages work the way you are proposing we adopt for JS? That is great to know. Can you suggest a concrete one for us to look into?

[01:59:25.0166] <littledan>
Bytecode manipulation isn’t magic; I would be surprised if we can’t do what’s achieved with it

[02:00:02.0350] <Stephen Belanger>
Not sure. Like I said, most do this externally to the runtime itself so I'm unsure if any particular language is a good example of it.

[02:02:12.0623] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> The resolution is async, but we create a span around the thing that _created_ the promise, so the child-of or follows-from relationship should already have been established at this point. When calling an async function, the portion up to the first await is called synchronously, so if we choose to wrap that part in a span then that activity should be considered a child-of relationship. However, anything after the first await is schedule asynchronously and so should be considered a continuation and therefore a follows-from relationship.
> 
> ```js
> async function foo() {
>   console.log('1')
>   await Promise.resolve()
>   console.log('3')
> }
> foo()
> console.log('2')
> ```

```
handleRequest((req, res) => {
  // ROOT SPAN0
  // child-of context.variable: SPAN0
  // await connection.query() SPAN1
  connection.query('SELECT 1 + 1 AS two') // SPAN1
    .then(a => {
      // PROPOSED CONTEXT: SPAN1.2
      return connection.query('SELECT 2 + 2 AS four') // SPAN2
    })
    .then(a => {
      // PROPOSED CONTEXT: SPAN2.2
      // If the context.variable at this point is SPAN2, how do we determine
      // child-of or follow-from?
      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3
      return connection.query('SELECT 3 + 3 AS four') // SPAN3
    })
    .then(b => {
      // PROPOSED CONTEXT: SPAN3.2
      res.writeHead(200, { 'Content-Type': 'text/plain' })
      res.end(a[0].two + b[0].four)
    })
})

function connectionQuery(query) {
  // Current Context: SPANx
  return makeFirstRequest() // SPANx.1
    .then(() => {
      makeSecondRequest() // SPANx.2
    })
}
```
In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now

[02:02:25.0021] <littledan>
That’s OK if it’s external, if it implements the right semantics I am still happy to have that as the reference point

[02:02:32.0024] <Stephen Belanger>
> <@littledan:matrix.org> Bytecode manipulation isn’t magic; I would be surprised if we can’t do what’s achieved with it

Much of the code we need to patch to do that in JS is not reachable at runtime. With bytecode you can manipulate everything, even private things.

[02:03:10.0168] <Chengzhong Wu>
 * ```
handleRequest((req, res) => {
  // ROOT SPAN0
  // child-of context.variable: SPAN0
  // await connection.query() SPAN1
  connection.query('SELECT 1 + 1 AS two') // SPAN1
    .then(a => {
      // PROPOSED CONTEXT: SPAN1.2
      return connection.query('SELECT 2 + 2 AS four') // SPAN2
    })
    .then(a => {
      // PROPOSED CONTEXT: SPAN2.2
      // If the context.variable at this point is SPAN2.2, how do we determine
      // child-of or follow-from?
      // As proposed this should be a follow-from SPAN2.3 instead of SPAN3
      return connection.query('SELECT 3 + 3 AS four') // SPAN3
    })
    .then(b => {
      // PROPOSED CONTEXT: SPAN3.2
      res.writeHead(200, { 'Content-Type': 'text/plain' })
      res.end(a[0].two + b[0].four)
    })
})

function connectionQuery(query) {
  // Current Context: SPANx
  return makeFirstRequest() // SPANx.1
    .then(() => {
      makeSecondRequest() // SPANx.2
    })
}
```

In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now

[02:03:33.0179] <littledan>
> <@stephenbelanger:matrix.org> Much of the code we need to patch to do that in JS is not reachable at runtime. With bytecode you can manipulate everything, even private things.

Sounds good, so can a language runtime, which is what we are talking about changing. It would help us to have a concrete reference point even if it is external/messy

[02:04:21.0970] <Chengzhong Wu>
 * ```
handleRequest((req, res) => {
  // ROOT SPAN0
  connection.query('SELECT 1 + 1 AS two') // SPAN1
    .then(a => {
      // PROPOSED CONTEXT: SPAN1.2
      // If the context.variable at this point is SPAN1.2, how do we determine
      // child-of or follow-from?
      // As proposed this should be a follow-from SPAN1.3 instead of SPAN2
      return connection.query('SELECT 2 + 2 AS four') // SPAN2
    })
    .then(b => {
      // PROPOSED CONTEXT: SPAN3.2
      res.writeHead(200, { 'Content-Type': 'text/plain' })
      res.end(a[0].two + b[0].four)
    })
})

function connectionQuery(query) {
  // Current Context: SPANx
  return makeFirstRequest() // SPANx.1
    .then(() => {
      makeSecondRequest() // SPANx.2
    })
}
```

In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now

[02:04:41.0373] <Stephen Belanger>
> <@legendecas:matrix.org> ```
> handleRequest((req, res) => {
>   // ROOT SPAN0
>   connection.query('SELECT 1 + 1 AS two') // SPAN1
>     .then(a => {
>       // PROPOSED CONTEXT: SPAN1.2
>       // If the context.variable at this point is SPAN1.2, how do we determine
>       // child-of or follow-from?
>       // As proposed this should be a follow-from SPAN1.3 instead of SPAN2
>       return connection.query('SELECT 2 + 2 AS four') // SPAN2
>     })
>     .then(b => {
>       // PROPOSED CONTEXT: SPAN3.2
>       res.writeHead(200, { 'Content-Type': 'text/plain' })
>       res.end(a[0].two + b[0].four)
>     })
> })
> 
> function connectionQuery(query) {
>   // Current Context: SPANx
>   return makeFirstRequest() // SPANx.1
>     .then(() => {
>       makeSecondRequest() // SPANx.2
>     })
> }
> ```
> 
> In the middle of a promise chain, it reads to me that the proposed solution needs to depends on additional cost to determine a child-of relationship now

What do you mean by `PROPOSED CONTEXT: SPAN1.2`? What I'm expecting is for the context there to be a continuation of `SPAN1`.

[02:05:45.0440] <Stephen Belanger>
> <@littledan:matrix.org> Sounds good, so can a language runtime, which is what we are talking about changing. It would help us to have a concrete reference point even if it is external/messy

I'll have to talk to my team about that and see what examples I can get from them as I'm really not he expert on _other_ languages. 😅

[02:07:14.0491] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> What do you mean by `PROPOSED CONTEXT: SPAN1.2`? What I'm expecting is for the context there to be a continuation of `SPAN1`.

The example is equivalent to async-await as:
```

handleRequest(async (req, res) => {
  // ROOT SPAN0
  await connection.query('SELECT 1 + 1 AS two') // SPAN1
  // PROPOSED CONTEXT: SPAN1.2
  await connection.query('SELECT 2 + 2 AS four') // SPAN2
  // PROPOSED CONTEXT: SPAN2.2
  res.writeHead(200, { 'Content-Type': 'text/plain' })
  res.end(a[0].two + b[0].four)
})
```
Is this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?

[02:07:21.0304] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> What do you mean by `PROPOSED CONTEXT: SPAN1.2`? What I'm expecting is for the context there to be a continuation of `SPAN1`.

 * The example is equivalent to async-await as:

```
handleRequest(async (req, res) => {
  // ROOT SPAN0
  await connection.query('SELECT 1 + 1 AS two') // SPAN1
  // PROPOSED CONTEXT: SPAN1.2
  await connection.query('SELECT 2 + 2 AS four') // SPAN2
  // PROPOSED CONTEXT: SPAN2.2
  res.writeHead(200, { 'Content-Type': 'text/plain' })
  res.end(a[0].two + b[0].four)
})
```

Is this the proposed behavior in https://github.com/tc39/proposal-async-context/issues/83?

[02:12:24.0538] <Stephen Belanger>
Again, I'm unclear what the decimal point thing is about here?

[02:13:58.0954] <littledan>
> <@stephenbelanger:matrix.org> I'll have to talk to my team about that and see what examples I can get from them as I'm really not he expert on _other_ languages. 😅

Sounds good, maybe we can all learn from this then

[02:14:48.0057] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> Again, I'm unclear what the decimal point thing is about here?

Decimal points represent child-of relations, increased number represets a follow-of relation.

[02:16:44.0326] <Stephen Belanger>
Ah, no. Only the first is a child-of because it occurs within the sync initial part of the async function.

[02:16:56.0623] <Stephen Belanger>
The second should be follows-from.

[02:18:06.0350] <Stephen Belanger>
The `connection.query(...)` expression is called before its result is awaited, and it's the calling of that which produces a span. That span is therefore within the synchronous scope of the http server request span.

[02:18:35.0450] <Stephen Belanger>
If there was some _other_ await before it, even one which did not produce a span, then it would be considered follows-from.

[02:19:37.0968] <Chengzhong Wu>
yeah, so in a promise chain, child-of is no longer effective and I'm curious about how you curate a graph with nesting semantics.

[02:20:11.0114] <Chengzhong Wu>
 * yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you curate a graph with nesting semantics.

[02:20:52.0437] <Chengzhong Wu>
 * yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you crate a graph with nesting semantics.

[02:20:56.0569] <Chengzhong Wu>
 * yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you create a graph with nesting semantics.

[02:21:23.0707] <Stephen Belanger>
That would look the same. The creation of that initial promise produces a sync/child-of span, and then anything in following `then(...)` continuations would be follows-from of whichever thing in the chain last produced a span.

[02:22:14.0625] <Stephen Belanger>
So from a user code behaviour perspective, callbacks, promises, and async/await would all produce the same graph.

[02:23:14.0618] <Stephen Belanger>
And in the less common case where a continuation is attached far away from where the promise is created, a manual bind could be used where necessary to express that further away logical path, if it makes sense.

[02:23:30.0365] <Stephen Belanger>
But generally from APM perspective we basically _never_ want that further away path.

[02:23:54.0218] <Stephen Belanger>
Meaning register time of a promise continuation.

[02:24:06.0140] <Stephen Belanger>
We want resolve time basically universally.

[02:24:41.0715] <Stephen Belanger>
As do basically all userland context flow use cases I'm aware of. I'm very unclear what the actual use case is for register time binding. 😕

[02:25:34.0703] <littledan>
Sometimes there is no particular resolve time context to apply, and we just need to fall back to register time

[02:25:59.0306] <littledan>
If it goes to a browser/os primitive

[02:27:01.0556] <littledan>
There’s the general connection pooling case, which generalizes this

[02:28:56.0391] <littledan>
Generally to get child-of edges, don’t you want restore after await? Sync is not enough.

[02:29:16.0851] <Stephen Belanger>
Resolve time naturally flows out to eventually promise-creation time--the thing you called which created a promise.

[02:29:37.0829] <littledan>
What do you mean “flows out to”?

[02:30:13.0748] <Stephen Belanger>
> <@littledan:matrix.org> Generally to get child-of edges, don’t you want restore after await? Sync is not enough.

Child-of edges are easy. They are just things happening synchronously within the current scope, so we don't need anything for that. Not sure why restoring matters here? 🤔

[02:32:05.0532] <Stephen Belanger>
> <@littledan:matrix.org> What do you mean “flows out to”?

I mean the context flows up to some execution barrier where the JS-side work to be done on the scheduling side is _done_. With a promise, this is generally when the resolve happens. But if it's a native promise or something like that then none of the resolving stage happens within JS so you just follow the flow back upward until you get to a point in the causal that _was_ in JS, which is when the original call happened.

[02:33:12.0618] <littledan>
> <@legendecas:matrix.org> yeah, so in a promise chain, child-of is no longer effective (only the first of a promise chain is sync) and I'm curious about how you create a graph with nesting semantics.

So it seems like we have a disagreement in this chat about this statement. How can we look into it further? Maybe analyzing some concrete cases?

[02:33:26.0949] <Stephen Belanger>
Creation of a promise is just an allocation. It's not controlling flow at that point. The actual _scheduling_ of a promise is the providing of a value to resolve it with.

[02:36:09.0883] <Andreu Botella>
> <@stephenbelanger:matrix.org> I mean the context flows up to some execution barrier where the JS-side work to be done on the scheduling side is _done_. With a promise, this is generally when the resolve happens. But if it's a native promise or something like that then none of the resolving stage happens within JS so you just follow the flow back upward until you get to a point in the causal that _was_ in JS, which is when the original call happened.

in JS code that creates a promise and then resolves it, wouldn't this only be the case if there are no `AsyncContext.Snapshot.p.run` along the promise resolution path?

[02:37:36.0873] <Stephen Belanger>
> <@abotella:igalia.com> in JS code that creates a promise and then resolves it, wouldn't this only be the case if there are no `AsyncContext.Snapshot.p.run` along the promise resolution path?

Not sure what you mean by that. Do you have an example?

[02:39:46.0689] <Stephen Belanger>
From _my_ perspective: context flows into the promise executor, it flows into anything that happens _within_ that executor, it then captures whenever the `resolve(...)` is called as _that_ is what actually schedules passing the value to continuations. If the context value is set outside the promise constructor it will use that context. If it gets set somewhere within the executor leading up to when it calls `resolve(...)` it will use that. It all flows naturally toward the resolve point where it schedules the value to pass to continuations.

[02:40:49.0340] <Andreu Botella>
so IIUC, you're saying that in cases like `await someAPI()`, the resolve time is a child of the context before the await

[02:40:50.0769] <Andreu Botella>
but that is not the case with things like
```js
const somePreviousSnapshot = new AsyncContext.Snapshot();

function someAPI() {
  return new Promise(resolve => {
    // I don't know why someone might do this, but they *can* do it.
    somePreviousSnapshot.run(resolve);
  });
}
```

[02:41:36.0787] <Stephen Belanger>
Now you _could_ look at it the other way of _attaching a continuation_ is the scheduling and the resolve is a fulfillment of that scheduling, but the fulfillment is not _triggered_ by that attaching of a continuation so I don't really feel like that's actually correct. Possibly a _useful_ path to follow in some cases, though I'm unclear _when_.

[02:43:53.0634] <Stephen Belanger>
> <@abotella:igalia.com> so IIUC, you're saying that in cases like `await someAPI()`, the resolve time is a child of the context before the await

Yeah, so the expression which produces the promises which _will_ be awaited occurs within that context, so the context flows into it naturally. The context of that outer function should reach into the promise and flow all the way to its resolve, unless some other context is set along that path. When the promise _resolves_ the following execution is then a _continuation_ of that resolution and should therefore flow the context which was captured at the point that path resolved.

[02:44:04.0674] <Stephen Belanger>
> <@abotella:igalia.com> so IIUC, you're saying that in cases like `await someAPI()`, the resolve time is a child of the context before the await

 * Yeah, so the expression which produces the promise which _will_ be awaited occurs within that context, so the context flows into it naturally. The context of that outer function should reach into the promise and flow all the way to its resolve, unless some other context is set along that path. When the promise _resolves_ the following execution is then a _continuation_ of that resolution and should therefore flow the context which was captured at the point that path resolved.

[02:44:59.0255] <Stephen Belanger>
In your example there, you captured a snapshot and ran that around the resolve, so that changes the context which should come out of the await.

[02:47:34.0479] <Stephen Belanger>
This is why I feel flowing up to the resolve barrier makes a lot more sense, and then not binding around awaits at all, or maybe having some _secondary_ flow that could be captured for those. If you follow the resolve path you will naturally have the context from the start of the async function flow through all the awaits and continue to be available, only changing if something in that causal path changed the context around what led to their resolve.

[02:48:45.0066] <Stephen Belanger>
Binding around awaits is chopping off branches of the execution graph, which I'm unclear why anyone would want to do that by default. 🤔

[02:49:44.0174] <Andreu Botella>
but in cases like this, wouldn't this mess up tracing?
```js
async function someFunctionYouCareAboutTracing() {
	const response1 = await fetch(...);
	await someAPI();  // this empties out the context after the await!
	const response2 = await fetch(...);
	return await doSomethingWith(response1, response2);
}
```

[02:49:50.0237] <Stephen Belanger>
Like I get that there seems to be some use case people have in mind for _why_ it makes sense _for them_ to bind and restore around awaits, but I _still_ have not seen any adequate explanation on _why_ anyone would ever want that. 😕

[02:50:41.0584] <Stephen Belanger>
> <@abotella:igalia.com> but in cases like this, wouldn't this mess up tracing?
> ```js
> async function someFunctionYouCareAboutTracing() {
> 	const response1 = await fetch(...);
> 	await someAPI();  // this empties out the context after the await!
> 	const response2 = await fetch(...);
> 	return await doSomethingWith(response1, response2);
> }
> ```

What about that would mess it up? Is `someApi()` _explicitly_ emptying the context for some reason?

[02:51:23.0931] <Andreu Botella>
I meant the definition of `someApi()` above, which *is*

[02:51:54.0499] <Stephen Belanger>
Ah, you mean it's restoring the snapshot captured previously?

[02:52:17.0557] <Stephen Belanger>
Yeah, that would return to whatever the context was which was captured in that snapshot.

[02:52:30.0650] <Stephen Belanger>
So if you're using a snapshot in that way then that is _expected_.

[02:53:18.0005] <Stephen Belanger>
And this is also why I would like to have per-instance bind because sometimes it makes sense globally like connection pools, but sometimes opinions may vary.

[02:53:21.0929] <Andreu Botella>
maybe this isn't something worth worrying about, but someone might be using snapshots to do things around their `AsyncContext.Variable`s not realizing that that might affect the context in which their promise gets resolved, which would affect other use libraries that use AsyncContext

[02:54:10.0271] <Andreu Botella>
also, if you have an interaction of various libraries that use AsyncContext for their separate goals, they might interact in unforeseen ways

[02:54:12.0401] <Stephen Belanger>
But yes, I believe it is "correct" for that to break context. Or rather, it might be _incorrect_ that it is _doing_ that snapshot restore.

[02:54:46.0296] <Stephen Belanger>
> <@abotella:igalia.com> maybe this isn't something worth worrying about, but someone might be using snapshots to do things around their `AsyncContext.Variable`s not realizing that that might affect the context in which their promise gets resolved, which would affect other use libraries that use AsyncContext

Yep, this is why Node.js hates `AsyncResource`. 🙈

[02:56:42.0544] <Stephen Belanger>
So in Node.js, async_hooks made the mistake of producing a _singular_ execution graph which is grafted with `AsyncResource` binds. AsyncLocalStorage is layered over it so it inherits that mistake. We want it to _not_ be layered over that so we can _fix_ that problem.

[02:57:42.0009] <Andreu Botella>
I'm not sure I understand. Even if we do have per-instance wrap, you would still need global wraps, right?

[02:57:58.0592] <Stephen Belanger>
APMs (unfortunately) fairly often use `AsyncResource` to "fix" context management flows, but then we break other vendors because we change the graph _they_ were expecting. 😬

[02:58:12.0324] <Stephen Belanger>
Yes, global is still needed.

[02:58:18.0625] <Stephen Belanger>
Just not _always_.

[02:58:58.0651] <Stephen Belanger>
And this is specifically why I created the WindowChannel concept. So different consumers could make different decisions in a reasonably user-friendly way.

[02:59:59.0376] <Andreu Botella>
So my worry is about a (maybe small) library that might not realize they're supposed to be doing per-instance wrap rather than global wrap, since it works fine in their tests

[03:00:13.0224] <Andreu Botella>
Or cases where a library might have multiple variables and they use global wrap to handle all of them at once

[03:00:47.0863] <Stephen Belanger>
I mean, that _will_ be a problem. But _without_ instance-scoped bind it's _still_ a problem, just without a solution.

[03:01:25.0300] <Andreu Botella>
right, I thought making it part of the API was a convenience thing, or perhaps a worry about performance, but it's part of the affordance of the API

[03:01:38.0524] <Andreu Botella>
 * right, I thought making per-instance wrap part of the API was a convenience thing, or perhaps a worry about performance, but it's part of the affordance of the API

[03:01:38.0591] <Stephen Belanger>
People are _going_ to use APIs wrong. We can't stop that. At best we can _try_ to make it _clear_ when they're doing it wrong.

[03:01:55.0113] <Andreu Botella>
 * right, I thought making per-instance wrap part of the API was a convenience thing, or perhaps a worry about performance, but it's part of the affordance of the API design

[03:02:38.0480] <Stephen Belanger>
I mean, you _can_ just do it with a `store.get()` and a closure that does `store.run(...)` around the orignal function. So it's _easy enough_ to do externally. But I _personally_ feel it should be part of the actual API, for clarity.

[03:02:50.0651] <Andreu Botella>
yeah, I see that now

[03:03:25.0965] <Stephen Belanger>
Well, that's not _completely_ true if we have the sync vs continuation differentiation, but that's another thing.

[03:04:01.0599] <Stephen Belanger>
That's also why in my RFC I was explicitly defining separate windows.

[03:07:07.0468] <Stephen Belanger>
With separate windows you could make the `store.run(...)` be a `continuationWindow.run(...)` instead and key the child-of versus follows-from decision off that.

[03:10:13.0860] <Stephen Belanger>
I think separating those concepts from user perspective might be a bit too much complication though. I'm definitely one that would advocate for making it actively _difficult_ to use APIs wrong. It can be challenging to do, but given a large enough pool of users you will _for sure_ encounter a bunch which find some way to use it wrong. 😅

[03:11:10.0047] <Stephen Belanger>
The less footguns we can give users the better. 🙈

[05:26:43.0742] <Stephen Belanger>
If we have instance-scoped bind, should we give the instance and global versions different but related names to make the intent a bit more clear? Something like `instance.bind(...)` and `Variable.bindAllVariables(...)` or something like that?

[06:04:57.0955] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> And this is also why I would like to have per-instance bind because sometimes it makes sense globally like connection pools, but sometimes opinions may vary.

This per-instance bind sounds like a requirement after the behavior is defined as flowing out to the outer scope. In the current form, this example would not be a problem:
```js
async function someFunctionYouCareAboutTracing() {
	const response1 = await fetch(...);
	await someAPI();  // this scope can not be modified by this call
	const response2 = await fetch(...);
	return await doSomethingWith(response1, response2);
}
```

[06:05:33.0635] <Chengzhong Wu>
> <@stephenbelanger:matrix.org> And this is also why I would like to have per-instance bind because sometimes it makes sense globally like connection pools, but sometimes opinions may vary.

 * This per-instance bind sounds like a requirement after the behavior is defined as flowing out to the outer scope. In the current form, this example would not be a problem:

```js
async function someFunctionYouCareAboutTracing() {
	const response1 = await fetch(...);
	await someAPI();  // the current context will not be modified by this call
	const response2 = await fetch(...);
	return await doSomethingWith(response1, response2);
}
```

[06:06:12.0325] <Chengzhong Wu>
which is what we want to avoid as dynamic scope

[06:08:33.0433] <Chengzhong Wu>
 * the problem also seems to be what we want to avoid as dynamic scope

[06:23:36.0051] <littledan>
> <@stephenbelanger:matrix.org> APMs (unfortunately) fairly often use `AsyncResource` to "fix" context management flows, but then we break other vendors because we change the graph _they_ were expecting. 😬

Do you have an example of this sort of fix, and the costs and benefits of it, that we can look into?

