2024-04-02
[17:10:49.0615] <Steve Hicks>
I'm a bit wary of overlooking the expressiveness argument.  It's really easy to miss important cases and then those use cases end up high and dry with a non-solution.  As an example, I'm working on a use case right now where registration context would be a huge problem - it's (again) a tracing use case: our data service allows registering interceptors for incoming data and the interceptors are what actually trigger the UI update (possibly via a signal reaction, which is another callback registration that would need to preserve call-time semantics instead of registration semantics for this all to work).  If _either_ the RPC interceptors _or_ the signal reactions use registration context, we're sunk and there's no way to trace an interaction from the initiating event all the way to the UI update, given how loosely-coupled all the reactions in the framework are.

[18:57:49.0223] <Justin Ridgewell>
> <@stephenhicks:matrix.org> I'm a bit wary of overlooking the expressiveness argument.  It's really easy to miss important cases and then those use cases end up high and dry with a non-solution.  As an example, I'm working on a use case right now where registration context would be a huge problem - it's (again) a tracing use case: our data service allows registering interceptors for incoming data and the interceptors are what actually trigger the UI update (possibly via a signal reaction, which is another callback registration that would need to preserve call-time semantics instead of registration semantics for this all to work).  If _either_ the RPC interceptors _or_ the signal reactions use registration context, we're sunk and there's no way to trace an interaction from the initiating event all the way to the UI update, given how loosely-coupled all the reactions in the framework are.

Can you make an example case in code?

[19:17:07.0405] <littledan>
Yeah sorry I don’t mean that I disagree with the expressiveness argument everywhere, just more like I would want to hear about concrete applications like what you are raising, rather than just the abstract form. Thanks for bringing this up.

[00:49:55.0633] <Chengzhong Wu>
What is the context of the call-time of `MessagePort.p.onmessage`? Is it an empty context?

[00:50:28.0614] <Andreu Botella>
yeah

[00:51:25.0053] <Chengzhong Wu>
Hmm, how is it useful if it is an empty context? Or, this is a case of inconsistency in zone.js, I assume

[00:52:31.0925] <Andreu Botella>
I'm not sure why they do this, but I think zone.js does give you a way to make `onmessage` be registration-time, it's just not enabled by default

[00:52:42.0221] <Andreu Botella>
I'm not sure why that is though

[07:31:00.0601] <Chengzhong Wu>
I am on the trip and will not be able to join the call today

[09:05:12.0675] <Justin Ridgewell>
Ping!

[10:27:25.0799] <Justin Ridgewell>
Interesting discussion about retrieving the call-time context today. Will post a GH issue later today.

[16:43:01.0757] <littledan>
I had a nice chat with Qard here in London about the generator concerns. Ultimately this relates to Koa’s use of generators, but that makes me think that our save-and-restore-across-yield semantics would actually be *better*. We were unable to come to a concrete case which is made worse by the semantics, though there will be some differences vs today’s Node AsyncLocalStorage. IMO, until I hear further evidence, I think this is a good tradeoff and we should stick with the current generator design.


2024-04-03
[06:57:35.0840] <littledan>
I'm very skeptical of the callingContext direction. I'm sorry that I missed the last AsyncContext call, but I think we should discuss this further among ourselves before making it the focus of the presentation next week. Let's focus on the things that are settled. We can briefly mention that we're working on the HTML integration, and this is one idea that's been floated, but it's still very early and we're just beginning to consider it.

[06:58:44.0562] <littledan>
One piece of complexity is that there are actually more than two plausibly relevant snapshots, as this comment alluded to: https://github.com/tc39/proposal-async-context/pull/77#issuecomment-2034251830

[06:59:27.0044] <littledan>
another issue is that it doesn't remove the need for us to develop opinions about how HTML integration works--we still need to figure out the default semantics, which is what most people will be using most of the time.

[07:00:02.0526] <littledan>
If this is presented in committee, we'll end up spending a bunch of time arguing among ourselves. But that would be a disservice to the proposal--we've made so much progress, and we should be focusing on explaining that.

[07:03:30.0911] <littledan>
 * If this the focus of the presentation in committee, we'll end up spending a bunch of time arguing among ourselves. But that would be a disservice to the proposal--we've made so much progress, and we should be focusing on explaining that.

[07:04:01.0515] <littledan>
fine to mention it a bit (I wouldn't if I were presenting, but it's fine for us to disagree), but it would be premature to focus on it IMO

[07:20:22.0879] <littledan>
Events dispatched from JS seem to be a very special case. What if we ran almost all events in registration snapshot, but for events dispatched from JS, sent the snapshot from that point in JS as a property on the event?

[08:40:04.0939] <littledan>
I chatted with Matteo Collina about the feature and he shared my skepticism of the multiple-context approach

[08:40:24.0615] <littledan>
he suggested focusing on thinking through concrete examples

[10:57:11.0241] <Steve Hicks>
As an example of where a third context may be relevant: XHR's `send()` context is neither the registration context nor the (null) calling context, and I don't see a good way to push that into the listener.  I think it only matters in cases where the XHR is being reused - one listener with multiple `send()`s.  Between that condition and XHR being somewhat obsolete, this ay not be a very big deal.  Can someone lay out other examples where it's relevant?

[10:57:23.0151] <Steve Hicks>
 * As an example of where a third context may be relevant: XHR's `send()` context is neither the registration context nor the (null) calling context, and I don't see a good way to push that into the listener.  I think it only matters in cases where the XHR is being reused - one listener with multiple `send()`s.  Between that condition and XHR being somewhat obsolete, this ay not be a very big deal.  Can someone lay out other examples where there's a third relevant context?

[10:58:24.0053] <Andreu Botella>
As far as I'm aware, every time that a third context is relevant, it's because the (synchronous) call-time context would be empty

[10:59:30.0862] <Andreu Botella>
So it could still be (call-time or async relevant context) vs registration-time

[11:00:13.0382] <Steve Hicks>
Thinking a little more about `callingContext`, I'm not sure it actually addresses the generator issue all that much better than the hacky wrapper I suggested in https://github.com/tc39/proposal-async-context/issues/18#issuecomment-2015669860

[11:01:09.0241] <Steve Hicks>
I.e. I don't think it's actually possible to write a wrapper that would "just work" without having to bend over backwards within the generator body to access the calling context instead

[11:06:13.0954] <Steve Hicks>
That said, my main motivating use case for calling context is tracing with multi-use callbacks.  Any time you're registering a multi-use callback, it's very likely that you care more about the calling context than the registration context.  I don't have much in the way of builtin API examples, though if https://github.com/proposal-signals/proposal-signals were to move forward and ended up using registration context for effects, then that would certainly end up being an adoption blocker if we couldn't access the calling context.

[11:06:43.0028] <Steve Hicks>
 * That said, my main motivating use case for calling context is tracing with multi-use callbacks (i.e. expected to be run multiple times).  Any time you're registering a multi-use callback, it's very likely that you care more about the calling context than the registration context.  I don't have much in the way of builtin API examples, though if https://github.com/proposal-signals/proposal-signals were to move forward and ended up using registration context for effects, then that would certainly end up being an adoption blocker if we couldn't access the calling context.

[11:10:00.0420] <Steve Hicks>
I'm a little dubious about exposing the calling context as an event property - it seems like a more "invasive" change and it only handles one (though, admittedly, the biggest) API rather than providing something that could be used more generally.

[11:14:15.0759] <Justin Ridgewell>
> <@littledan:matrix.org> another issue is that it doesn't remove the need for us to develop opinions about how HTML integration works--we still need to figure out the default semantics, which is what most people will be using most of the time.

No, but it  means that HTML is free to choose registration as the default choice even where there are 2 possible choices

[11:16:59.0024] <Justin Ridgewell>
> <@stephenhicks:matrix.org> Thinking a little more about `callingContext`, I'm not sure it actually addresses the generator issue all that much better than the hacky wrapper I suggested in https://github.com/tc39/proposal-async-context/issues/18#issuecomment-2015669860

It doesn’t improve the ergonomics, generators are still favoring init-time, but it _allows_ access in case it’s necessary. The same way snapshot’s ergonomics aren’t great. Maybe `using` declarations with the new enter proposal will help here.

[11:18:25.0967] <Justin Ridgewell>
> <@stephenhicks:matrix.org> As an example of where a third context may be relevant: XHR's `send()` context is neither the registration context nor the (null) calling context, and I don't see a good way to push that into the listener.  I think it only matters in cases where the XHR is being reused - one listener with multiple `send()`s.  Between that condition and XHR being somewhat obsolete, this ay not be a very big deal.  Can someone lay out other examples where there's a third relevant context?

As it stands today, it’d be the empty context. But we could spec it so that the `send()` context is used as the calling by propagating that forward.

[11:18:50.0906] <Justin Ridgewell>
* As it stands today, it’d be the empty context. But we could spec it so that the `send()` context is used as the call-time context by propagating that forward.

[11:21:04.0676] <Justin Ridgewell>
> <@stephenhicks:matrix.org> I'm a little dubious about exposing the calling context as an event property - it seems like a more "invasive" change and it only handles one (though, admittedly, the biggest) API rather than providing something that could be used more generally.

Agreed. This requires any API that might be ambiguous to update, and we don’t control 3rd party library code. `callingContext()` allows us to support some of these cases without the library code changing.

[13:15:12.0704] <bakkot>
not sure if this thread was prompted by the discussion here, but if not it's a funny coincidence https://github.com/nodejs/node/issues/52317

[13:18:48.0497] <Justin Ridgewell>
No,

[13:19:01.0452] <Justin Ridgewell>
* No, looks like that was posted before us

[16:20:23.0976] <littledan>
> <@stephenhicks:matrix.org> That said, my main motivating use case for calling context is tracing with multi-use callbacks.  Any time you're registering a multi-use callback, it's very likely that you care more about the calling context than the registration context.  I don't have much in the way of builtin API examples, though if https://github.com/proposal-signals/proposal-signals were to move forward and ended up using registration context for effects, then that would certainly end up being an adoption blocker if we couldn't access the calling context.

Huh, could you elaborate on this? I thought computeds would store their registration context. If you want to traverse the dependency graph to determine causation, there is an introspection API for that

[16:20:55.0187] <littledan>
> <@bakkot:matrix.org> not sure if this thread was prompted by the discussion here, but if not it's a funny coincidence https://github.com/nodejs/node/issues/52317

Seems like a good endorsement of our current semantics, which Matteo and Qard seem to agree with

[16:21:33.0287] <littledan>
> <@jridgewell:matrix.org> Agreed. This requires any API that might be ambiguous to update, and we don’t control 3rd party library code. `callingContext()` allows us to support some of these cases without the library code changing.

Yeah my suggestion here was not very well thought through. I still don’t understand how callingContext would work though.


2024-04-04
[00:56:12.0641] <Steve Hicks>
> <@littledan:matrix.org> Huh, could you elaborate on this? I thought computeds would store their registration context. If you want to traverse the dependency graph to determine causation, there is an introspection API for that

A computed signal running in the registration context is problematic. Our UI framework registers the computed signals and effects at app initialization time - so the context would be disconnected from any user-initiated event. Then the event handlers typically set a signal and rely on the signal graph to propagate through to an effect. To add teaching to this, the plan is to start the trace in the event handler, storing it in an async var, and then pick it up from the effect when the UI is eventually updated to finish the trace as completed. If the computeds/effects run in the registration context then there is no way to propagate the trace through this graph (even explicitly, since there's no parameter that can be passed through it like an old-fashioned function-based approach would allow).

[00:56:53.0809] <Steve Hicks>
* A computed signal running in the registration context is problematic. Our UI framework registers the computed signals and effects at app initialization time - so the context would be disconnected from any user-initiated event. Then the event handlers typically set a signal and rely on the signal graph to propagate through to an effect. To add tracing to this, the plan is to start the trace in the event handler, storing it in an async var, and then pick it up from the effect when the UI is eventually updated to finish the trace as completed. If the computeds/effects run in the registration context then there is no way to propagate the trace through this graph (even explicitly, since there's no parameter that can be passed through it like an old-fashioned function-based approach would allow).

[00:57:18.0641] <Steve Hicks>
* A computed signal running in the registration context is problematic. Our UI framework registers the computed signals and effects at app initialization time - so the context would be disconnected from any user-initiated event. Then the event handlers typically set a signal and rely on the signal graph to propagate through to an effect. To add tracing to this, the plan is to start the trace in the event handler, storing it in an async var, and then pick it up in the effect where the UI is eventually updated to finish the trace as completed. If the computeds/effects run in the registration context then there is no way to propagate the trace through this graph (even explicitly, since there's no parameter that can be passed through it like an old-fashioned function-based approach would allow).

[04:40:28.0136] <littledan>
Thanks for the context, Steve. This is really interesting. Would you be interested in joining the signals discord to discuss this further with others in the area? (Or if not, mind if I copy-paste this comment to trigger discussion there?)

[04:41:29.0540] <littledan>
If we wanted AsyncContext to be suitable for something like React Context, then registration time would be really helpful… so I want to think through all sides of this case to understand whether there is a unified answer.

[04:45:05.0229] <Andreu Botella>
Hey, we still haven't added the updates to AsyncContext to the agenda for next week

[04:45:30.0425] <Andreu Botella>
should I open a PR?

[06:25:42.0811] <Andreu Botella>
how much time do we expect the updates to take?

[06:28:52.0963] <Andreu Botella>
Justin Ridgewell: 

[08:29:06.0687] <Justin Ridgewell>
Yes please.

[08:29:34.0572] <Justin Ridgewell>
Maybe 15 min if we don’t discus calling context at all?

[08:32:49.0369] <Andreu Botella>
that sounds good

[08:33:23.0376] <Andreu Botella>
Justin Ridgewell: Since I'm opening the PR, I'll add constraints as well. You were unavailable on the 8th, right?

[08:33:35.0722] <Justin Ridgewell>
Yes

[08:34:45.0635] <Andreu Botella>
https://github.com/tc39/agendas/pull/1586

[08:35:20.0424] <Andreu Botella>
whoops, I added it at the end with stage 0 proposals

[08:35:46.0952] <Andreu Botella>
fixed

[08:36:08.0776] <Steve Hicks>
> <@littledan:matrix.org> Thanks for the context, Steve. This is really interesting. Would you be interested in joining the signals discord to discuss this further with others in the area? (Or if not, mind if I copy-paste this comment to trigger discussion there?)

Sure, I'd be happy to join the discord, but also feel free to copy-paste the comment.


2024-04-08
[06:03:51.0052] <littledan>
@room Hey, do we have the slides for the presentation tomorrow? It would be good to be able to review them and give feedback before the actual presentation happens

[07:15:21.0066] <Justin Ridgewell>
I haven’t written them yet

[07:23:26.0879] <littledan>
> <@jridgewell:matrix.org> I haven’t written them yet

thanks for letting us know; enjoy your eclipse day

[09:47:53.0356] <Justin Ridgewell>
https://docs.google.com/presentation/d/1ok6fX9PN3XEv9ZwffrDzJX24uuiNrkGDZN-KgGwGkc0/edit?usp=sharing

[09:48:05.0142] <Justin Ridgewell>
You all have edit access, feel free to update

[09:48:12.0762] <Justin Ridgewell>
I’m going to walk around before the eclipse

[09:48:37.0323] <Justin Ridgewell>
Feel free to add them to the plenary agenda whenever

[10:16:00.0375] <littledan>
wait did we end up with AsyncContext.wrap or AsyncContext.Snapshot.wrap?

[10:16:50.0025] <littledan>
for slide 7, should we link to the i2i?

[10:17:31.0448] <littledan>
Should we make it clear that the issue described on slide 3 is the main thing we need to get to stage 2.7, that we see zero other open issues?

[10:17:40.0063] <littledan>
also maybe mentioning our plan for sync iterator helpers?

[10:25:05.0287] <Andreu Botella>
> <@littledan:matrix.org> wait did we end up with AsyncContext.wrap or AsyncContext.Snapshot.wrap?

AsyncContext.Snapshot.wrap indeed

[10:29:56.0576] <Andreu Botella>
> The integration spec will be opened before we ask for Stage 2.7

There might be a lot of work needed to update all the specs. I think we should definitely have a document describing when an API or event should use which context, and have at least the basic PRs for DOM, HTML and WebIDL if needed.

[10:30:37.0562] <Andreu Botella>
but not necessarily PRs for every single spec

[10:30:59.0903] <Andreu Botella>
although a list of *which* APIs and events should be updated would probably be in scope

[10:33:16.0013] <Andreu Botella>
or maybe all non-experimental specs?

[10:33:25.0413] <Andreu Botella>
not sure

[10:41:19.0698] <littledan>
> Makes it much easier for users to pass callbacks to libraries
> Snapshot was introduced to make it easier for libraries to accept multiple callbacks

I'm not sure if I agree with this... I think AsyncContext.Shapshot.wrap will be frequently used by libraries, just like AsyncResource.wrap is in Node-land

[10:41:49.0333] <littledan>
> <@abotella:igalia.com> or maybe all non-experimental specs?

definitely experimental specs are out of scope, yes

[10:42:38.0801] <Andreu Botella>
in the analysis of non-event web APIs that I'm currently doing, I'm considering everything implemented by at least one major browser, including things in WICG specs

[10:42:49.0542] <littledan>
> <@abotella:igalia.com> > The integration spec will be opened before we ask for Stage 2.7
> 
> There might be a lot of work needed to update all the specs. I think we should definitely have a document describing when an API or event should use which context, and have at least the basic PRs for DOM, HTML and WebIDL if needed.

Yeah I agree, the goal should be to define things and have some rough consensus around it, not get all the editorial work perfectly lined up and almost landed

[10:43:13.0292] <littledan>
> <@abotella:igalia.com> in the analysis of non-event web APIs that I'm currently doing, I'm considering everything implemented by at least one major browser, including things in WICG specs

IMO it's enough to stick to things that are implemented by multiple browsers

[14:26:29.0777] <littledan>
BTW I added a "Next Steps" slide, would be great to have reviews to make sure I'm not misrepresenting things

[14:29:41.0493] <littledan>
Do we agree on "Plan: Propose for Stage 2.7 some time soon in 2024" ?


2024-04-09
[20:08:55.0690] <Justin Ridgewell>
Ok, finally home

[20:09:34.0233] <Justin Ridgewell>
Reviewing, I think Slide 4 (Generators) slides needs to mention that we removed snapshotting behavior for spec generators

[20:15:00.0444] <Justin Ridgewell>
Oh, we should also mention that test262 is already done?

