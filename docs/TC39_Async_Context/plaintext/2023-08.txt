2023-08-03
[04:40:30.0862] <Andreu Botella>
I just realized that V8 implements async functions as generators

[04:42:47.0396] <Andreu Botella>
I wonder if making generators work with AsyncContext would have any effect on async functions

[07:50:13.0403] <shu>
doesn't... everyone implement async functions as generators?

[07:50:25.0033] <shu>
even transpilers do i thought

[07:51:44.0930] <Andreu Botella>
implementing AsyncContext in V8 is my first time working on a JS engine

[07:51:59.0114] <Andreu Botella>
 * implementing AsyncContext in V8 is my first time implementing something on a JS engine

[07:52:09.0171] <Andreu Botella>
so this is new to me

[07:55:47.0537] <shu>
ah

[07:56:07.0964] <shu>
basically the suspend/resumption mechanism you need for generators and async functions are the same, so you just build it once

[07:56:32.0802] <shu>
regardless whether a resume point is a yield or an await, still a resume point

[07:58:04.0451] <Andreu Botella>
yeah, I get that

[07:58:29.0201] <Andreu Botella>
actually I watched a livestream Yulia did implementing async functions in SM a number of years ago, so it didn't quite come as a shock that this worked that way

[07:59:01.0507] <Andreu Botella>
I just hadn't realized that that would be the case when starting to think about changing generators here

[08:03:19.0099] <littledan>
Yeah, I'm pretty sure the redundancy here is unobservable (the promise reaction will "already" queue up the right AsyncContext)

[09:58:11.0988] <Andreu Botella>
 * I think I might have watched a livestream Yulia did implementing async functions in SM years ago, so it didn't quite come as a shock that this worked that way

[14:46:52.0596] <ljharb>
There’s a great babel transform that implements them as purely promises, but only for a lintable subset that excludes some loop patterns. It never got to Babel core tho, sadly.


2023-08-16
[03:40:48.0109] <Andreu Botella>
I opened an issue for the TPAC breakout session:
https://github.com/w3c/tpac2023-breakouts/issues/39

[04:26:27.0915] <littledan>
Looks great, thanks!


2023-08-17
[02:47:23.0870] <Andreu Botella>
In the last call I mentioned I had an engine262 implementation that I was using to write the tests. I've now opened a PR for it:
https://github.com/engine262/engine262/pull/227

[05:36:13.0149] <littledan>
You’re on fire, Andreu!


2023-08-22
[10:28:27.0771] <littledan>
https://github.com/tc39/proposal-async-context/pull/53/files

[11:01:02.0661] <Andreu Botella>
I just realized that making `HostCallJobCallback` not swap the snapshot makes it so we'd need to swap it in `CleanupFinalizationRegistry` to preserve the behavior in the current spec

[11:01:51.0685] <Andreu Botella>
and with Justin's suggestion in https://github.com/tc39/proposal-async-context/pull/41#pullrequestreview-1348745850 to store the snapshot in the PromiseCapability, we'd need to add a slot to `FinalizationRegistry` for the snapshot

[11:02:19.0041] <Andreu Botella>
so maybe we should discuss if that is needed/expected, since it doesn't fall naturally out of how `HostCallJobCallback` works

[11:02:30.0019] <Andreu Botella>
 * so maybe we should discuss if that is needed/expected, since it wouldn't fall naturally out of how `HostCallJobCallback` works anymore

[13:45:57.0684] <Mathieu Hofman>
Oh interesting, I hadn't realized that `FinalizationRegistry` is the only case of a TC39 "event callback". I would definitely expect the context of that callback to be the one that created the `FinalizationRegistry`

[13:52:11.0094] <Andreu Botella>
yeah, that makes sense

[14:30:06.0976] <Mathieu Hofman>
arguably there is another context that would make sense here: the context at the time of the `finalizationRegistry.register` call

[14:30:54.0226] <Mathieu Hofman>
in which case the context would be stored on the FinalizationRegistry cell instead of the FinalizationRegistry instance. what would make the most sense ?

[14:32:37.0324] <Mathieu Hofman>
I personally think that causing an AsyncContext's lifetime to depend on some value getting collected is a source of issues

[14:33:07.0149] <Mathieu Hofman>
and if programs want to do that, they can create a snapshot and use it as FinalizationRegistry held value

