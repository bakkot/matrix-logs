2024-07-01
[06:11:12.0632] <Andreu Botella>
I was thinking that the unhandled rejection context here is `"foo"`, not `"baz"`:
```js
asyncVar.run("foo", main);

async function main() {
	await asyncVar.run("bar", async () => {
		await asyncVar.run("baz", async () => {
			throw new Error();
		});
	});
}
```

[06:11:25.0492] <Andreu Botella>
so shouldn't it be the same for sync errors?

[06:11:30.0581] <Andreu Botella>
 * so shouldn't it be the same for sync unhandled errors?

[06:29:00.0985] <littledan>
I don't understand what you're getting at; the async/await case is different since it corresponds to a bunch of nested try/catch/rethrow patterns.

[06:30:51.0055] <Andreu Botella>
will that be obvious to developers?

[06:31:28.0305] <littledan>
no, developers will expect that the inner place where the error inside the async/await is the source. But making it "also broken" for sync exceptions won't fix that expectation.

[13:29:35.0348] <Steve Hicks>
Are we talking about the callback's context or the one that's hung on the `unhandledrejection`/`error` event?  If the former, I'm arguing it should always be registration context.  Would it be possible for `event.errorSnapshot` to be `"baz"` even for the `unhandledrejection` case?

[13:32:37.0245] <Steve Hicks>
I've come around to the view that one of the advantages of heterogeneous access to causal contexts (which I was arguing against a few weeks ago) is that you can target more clearly exactly which context you get.

[13:32:38.0071] <littledan>
I think we're talking about the supplemental context that exists as a property

[13:32:57.0470] <littledan>
even for that there's a lot of decisions to make!

[13:33:07.0685] <Steve Hicks>
yes there are

[13:33:30.0695] <littledan>
we *could* expose a whole bunch of them, but IMO one of them will probably be good enough to start, and people won't really be so great at choosing between a bunch of them anyway

[13:33:50.0641] <Steve Hicks>
so i guess i'm asking, is there a reasonable way to spec it so that the unhandled rejection is _also_ baz?

[13:34:05.0267] <Steve Hicks>
right, I don't think we should expose a ton

[13:34:47.0900] <littledan>
> <@stephenhicks:matrix.org> so i guess i'm asking, is there a reasonable way to spec it so that the unhandled rejection is _also_ baz?

I have a huge amount of trouble understanding how that'd work. BUT we could make it so that error objects have a causal context when they're allocated or thrown for the first time, and maybe that'd solve most of the problem.

[13:35:00.0275] <Stephen Belanger>
IMO error construction should capture a context snapshot and you can read out of that later by accessing some property on that error.

