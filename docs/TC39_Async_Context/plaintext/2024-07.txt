2024-07-01
[06:11:12.0632] <Andreu Botella>
I was thinking that the unhandled rejection context here is `"foo"`, not `"baz"`:
```js
asyncVar.run("foo", main);

async function main() {
	await asyncVar.run("bar", async () => {
		await asyncVar.run("baz", async () => {
			throw new Error();
		});
	});
}
```

[06:11:25.0492] <Andreu Botella>
so shouldn't it be the same for sync errors?

[06:11:30.0581] <Andreu Botella>
 * so shouldn't it be the same for sync unhandled errors?

[06:29:00.0985] <littledan>
I don't understand what you're getting at; the async/await case is different since it corresponds to a bunch of nested try/catch/rethrow patterns.

[06:30:51.0055] <Andreu Botella>
will that be obvious to developers?

[06:31:28.0305] <littledan>
no, developers will expect that the inner place where the error inside the async/await is the source. But making it "also broken" for sync exceptions won't fix that expectation.

[13:29:35.0348] <Steve Hicks>
Are we talking about the callback's context or the one that's hung on the `unhandledrejection`/`error` event?  If the former, I'm arguing it should always be registration context.  Would it be possible for `event.errorSnapshot` to be `"baz"` even for the `unhandledrejection` case?

[13:32:37.0245] <Steve Hicks>
I've come around to the view that one of the advantages of heterogeneous access to causal contexts (which I was arguing against a few weeks ago) is that you can target more clearly exactly which context you get.

[13:32:38.0071] <littledan>
I think we're talking about the supplemental context that exists as a property

[13:32:57.0470] <littledan>
even for that there's a lot of decisions to make!

[13:33:07.0685] <Steve Hicks>
yes there are

[13:33:30.0695] <littledan>
we *could* expose a whole bunch of them, but IMO one of them will probably be good enough to start, and people won't really be so great at choosing between a bunch of them anyway

[13:33:50.0641] <Steve Hicks>
so i guess i'm asking, is there a reasonable way to spec it so that the unhandled rejection is _also_ baz?

[13:34:05.0267] <Steve Hicks>
right, I don't think we should expose a ton

[13:34:47.0900] <littledan>
> <@stephenhicks:matrix.org> so i guess i'm asking, is there a reasonable way to spec it so that the unhandled rejection is _also_ baz?

I have a huge amount of trouble understanding how that'd work. BUT we could make it so that error objects have a causal context when they're allocated or thrown for the first time, and maybe that'd solve most of the problem.

[13:35:00.0275] <Stephen Belanger>
IMO error construction should capture a context snapshot and you can read out of that later by accessing some property on that error.

[13:35:10.0582] <littledan>
jinx

[13:35:25.0876] <Stephen Belanger>
Yeah.

[13:35:28.0026] <littledan>
(I prefer allocated better than first thrown too)

[13:35:43.0444] <Steve Hicks>
i think that's a good balance

[13:36:16.0217] <Stephen Belanger>
First thrown is a bit mysterious but possibly more correct. You need extra logic to detect if it already HAS a context on a rethrow though.

[13:36:52.0379] <littledan>
first thrown is sad-feeling because it means mutating an object. what if the same thing is thrown twice? anyway that is not very pragmatic knowledge, it's my theorist side talking

[13:37:00.0970] <littledan>
 * first thrown is sad-feeling because it means mutating an object. what if the same thing is thrown twice? anyway that is not very pragmatic motivation, it's my theorist side talking

[13:37:49.0990] <Stephen Belanger>
Yeah. Almost makes more sense to not be attached to the Error object, but then where would you put it?

[13:37:50.0577] <littledan>
but we might still need a causative context for unhandled rejections in case they aren't error objects

[13:38:04.0627] <Stephen Belanger>
True.

[13:38:09.0280] <littledan>
> <@stephenbelanger:matrix.org> Yeah. Almost makes more sense to not be attached to the Error object, but then where would you put it?

it could be on the event (but still, requires extra machinery in implementations)

[13:38:49.0832] <Stephen Belanger>
For unhandledRejection we probably _would_ need the point it throws and not an Error property given you _can_ throw non-errors and unfortunately sometimes people do. üòê

[13:39:03.0264] <Steve Hicks>
unhandledrejection isn't dispatched synchronously, so it's a little more awkward

[13:39:29.0808] <Steve Hicks>
ideally it could reuse the same mechanism for synchronous events (i.e. dispatchEvent captures the snapshot)

[13:40:22.0246] <littledan>
as we've previously reasoned, we could either store the context when the Promise is allocated (as in Node) or rejected (as in the current spec). I guess in either case, it could be in the Promise itself, and then it's only read by the unhandled rejection thing.

[13:41:16.0861] <Stephen Belanger>
Capturing on dispatchEvent also means we could have _anything_ be able to access both register time _and_ call time contexts. ü§î

[13:41:20.0821] <littledan>
I previously convinced myself that the rejected-time context is definitely way better, but now, with distance, I could see that either could be OK...

[13:41:38.0037] <littledan>
> <@stephenbelanger:matrix.org> Capturing on dispatchEvent also means we could have _anything_ be able to access both register time _and_ call time contexts. ü§î

lots of stuff isn't dispatchEvent...

[13:41:44.0945] <littledan>
unless you mean the internal equivalent

[13:41:55.0627] <Stephen Belanger>
Yes, internal equivalent.

[13:42:00.0217] <Steve Hicks>
reject-time means you're not making as many unused snapshots

[13:42:33.0598] <littledan>
> <@stephenbelanger:matrix.org> Yes, internal equivalent.

yeah so conversations with DOM people like Anne seemed to point to, we'd only get this little by little, for particular things where it made sense, since it's complicated and depends on that particular API's details

[13:42:46.0476] <littledan>
> <@stephenhicks:matrix.org> reject-time means you're not making as many unused snapshots

but "making a snapshot" is copying a pointer

[13:43:02.0838] <littledan>
we're *not* doing an allocation, in particular

[13:43:08.0714] <Steve Hicks>
is there a concern about lifetime management?

[13:43:31.0951] <littledan>
> <@stephenhicks:matrix.org> is there a concern about lifetime management?

well, IMO we should give a fresh object identity for the snapshot each time you use it, so we don't have to worry about that

[13:43:47.0404] <littledan>
via the getter

[13:43:47.0976] <Stephen Belanger>
> <@littledan:matrix.org> yeah so conversations with DOM people like Anne seemed to point to, we'd only get this little by little, for particular things where it made sense, since it's complicated and depends on that particular API's details

I mean‚Ä¶that‚Äôs possibly fine? We just need to make a bunch of individual cases for each API, which it seemed like Andreu was already doing the research work for?

[13:43:57.0816] <littledan>
or maybe that's too weird and un-getter-like?

[13:44:37.0878] <littledan>
the alternative is, you eagerly stash a pointer to the underlying data structure, but somehow you can dynamically type check that, and on first access, you replace it with a snapshot in place, and subsequent accesses notice that it's already a snapshot

[13:45:01.0687] <Steve Hicks>
> <@littledan:matrix.org> well, IMO we should give a fresh object identity for the snapshot each time you use it, so we don't have to worry about that

Not sure we're talking about the same thing?  IIUC there was concern about when a snapshot was no longer reachable (hence all the explicit resource management discussions) and if we've got a never-will-be-used snapshot hanging on a long-lived promise, that could confuse it

[13:45:50.0463] <littledan>
> <@stephenbelanger:matrix.org> I mean‚Ä¶that‚Äôs possibly fine? We just need to make a bunch of individual cases for each API, which it seemed like Andreu was already doing the research work for?

yes, though there's still the question of, "are we doing this now or 'later'". IMO we should identify the cases where we believe it's needed *now* (e.g., some of this error stuff) and document why it's needed, and expect that the initially shipped version doesn't include so many of these

[13:46:24.0810] <littledan>
> <@stephenhicks:matrix.org> Not sure we're talking about the same thing?  IIUC there was concern about when a snapshot was no longer reachable (hence all the explicit resource management discussions) and if we've got a never-will-be-used snapshot hanging on a long-lived promise, that could confuse it

oh oops I was talking about a superficial object identity issue, totally separate. For lifetime.... yeah just leak?

[13:46:34.0680] <littledan>
I don't see a solution to this lifetime question

[13:46:55.0726] <Stephen Belanger>
Selfishly, APM‚Äôs probably won‚Äôt care as we‚Äôre focused on servers where most of those APIs don‚Äôt exist anyway. üòÖ

[13:47:33.0257] <littledan>
well, some people care about client-side performance monitoring, but I take it that's not your team

[13:47:57.0653] <littledan>
I guess the lifetime thing might be especially bad for something like Error objects, where it might be really non-obvious what you're keeping around

[13:48:02.0726] <Steve Hicks>
you could have HostPromiseRejectionHandler add/remove it?

[13:48:05.0848] <littledan>
and you can imagine keeping errors around

[13:48:16.0820] <littledan>
> <@stephenhicks:matrix.org> you could have HostPromiseRejectionHandler add/remove it?

it would modify the error?

[13:48:37.0602] <Steve Hicks>
> <@littledan:matrix.org> well, some people care about client-side performance monitoring, but I take it that's not your team

this is our use case

[13:49:20.0500] <Steve Hicks>
> <@littledan:matrix.org> it would modify the error?

no, the promise

[13:50:13.0722] <littledan>
> <@stephenhicks:matrix.org> no, the promise

oh, right... yeah that makes sense, the unhandled rejection can only happen once. (In fact, maybe the spec doesn't even say any of this.) But this doesn't handle the error issue.

[13:50:19.0719] <Justin Ridgewell>
> <@stephenbelanger:matrix.org> For unhandledRejection we probably _would_ need the point it throws and not an Error property given you _can_ throw non-errors and unfortunately sometimes people do. üòê

I‚Äôd honestly be happy saying that‚Äôs an anti-pattern and you don‚Äôt get the correct context in this case.

[13:50:27.0921] <littledan>
> <@stephenhicks:matrix.org> no, the promise

 * oh, right... yeah that makes sense, the unhandled rejection can only happen once. (In fact, maybe the spec doesn't even say any of this, since it's implied by unreachability.) But this doesn't handle the error issue.

[13:50:56.0132] <Justin Ridgewell>
> <@littledan:matrix.org> as we've previously reasoned, we could either store the context when the Promise is allocated (as in Node) or rejected (as in the current spec). I guess in either case, it could be in the Promise itself, and then it's only read by the unhandled rejection thing.

I don‚Äôt think this helps in Andreu‚Äôs code sample, unless we‚Äôre expecting the `‚Äùfoo‚Äù` context

[13:50:57.0957] <littledan>
> <@jridgewell:matrix.org> I‚Äôd honestly be happy saying that‚Äôs an anti-pattern and you don‚Äôt get the correct context in this case.

actually we care a lot about this case at Bloomberg, but maybe for reasons which don't deserve to be prioritized

[13:51:23.0217] <littledan>
> <@jridgewell:matrix.org> I don‚Äôt think this helps in Andreu‚Äôs code sample, unless we‚Äôre expecting the `‚Äùfoo‚Äù` context

that's right, I'm discussing strategies for getting "foo"

[13:51:32.0696] <Steve Hicks>
Google also cares about throwing non-errors, but we believe the solution is "Don't do that" rather than bloating the standards to account for it

[13:52:06.0461] <littledan>
well, maybe we can look into the "don't do that" path... maybe Chengzhong can follow up on this?

[13:52:10.0625] <littledan>
Chengzhong Wu: ^

[13:53:55.0953] <Steve Hicks>
> <@littledan:matrix.org> well, maybe we can look into the "don't do that" path... maybe Chengzhong can follow up on this?

(aside) in particular, one strategy we're consider is to transpile all `throw x`s to `throw trackNonError(x)` that throws a real error with a stack trace asynchronously so as to at least get some logging in place to identify all the offenders

[13:54:25.0584] <Justin Ridgewell>
Are you suggesting we attach the context onto the error instead of just running the `unhandledRejectionHandler` in the correct context?

[13:54:52.0443] <Steve Hicks>
> <@jridgewell:matrix.org> Are you suggesting we attach the context onto the error instead of just running the `unhandledRejectionHandler` in the correct context?

Yes?

[13:55:28.0157] <Steve Hicks>
at that point, maybe there's not as much of a reason to even attach a context to `unhandledrejection`?

[13:55:28.0402] <littledan>
> <@jridgewell:matrix.org> Are you suggesting we attach the context onto the error instead of just running the `unhandledRejectionHandler` in the correct context?

well, we're somewhat deep into this thread of "run everything in registration context, and the 'correct' context is off to the side somewhere", and so we're trying to reason about whether the error's context is enough, or if we also need the rejection's context

[13:55:41.0581] <littledan>
if we get the rejection's context, it could be exposed in the event

[13:57:00.0576] <Steve Hicks>
I'm still hopeful that maybe we can get a more general resolution context for promises, but my understanding is that littledan has reason to think that's not feasible

[13:58:34.0663] <littledan>
I think a general resolution context for all promises would be seen as an information leak, but again that's not a very pragmatic reason for anything. Definitely it's easier to *just* capture the context where resolve()/reject() was done, rather than have that somehow be propagated across .then() as we've previously discussed.

[14:02:40.0135] <littledan>
with the semantics I'm picturing for capturing causal contexts for all Promises, for async functions, the resolve/reject context would be boring: it would be the context when the async function was called

[14:03:31.0930] <littledan>
it would only be something different if you call the promise constructor/withResolvers

[14:06:54.0639] <Chengzhong Wu>
> <@littledan:matrix.org> well, maybe we can look into the "don't do that" path... maybe Chengzhong can follow up on this?

I am not a fan of granting "throw" super power in spec to recover stacks and contexts either. Definitely, people can throw primitive values, just don't do that

[14:07:24.0570] <littledan>
> <@legendecas:matrix.org> I am not a fan of granting "throw" super power in spec to recover stacks and contexts either. Definitely, people can throw primitive values, just don't do that

OK, but how does this apply to unhandled rejections?

[14:08:38.0166] <Chengzhong Wu>
I think it could be a property of PromiseRejectionEvent/ErrorEvent, as documented in https://github.com/tc39/proposal-async-context/pull/94/files#diff-85367a6a792209cf5826726990ddd1f0fd7a572bac4162097bc5e7e192aa625cR295, updated today

[14:09:18.0877] <Chengzhong Wu>
Well, I think this could be definitely in its own piece of document expansion.

[14:09:36.0788] <littledan>
isn't putting it in ErrorEvent giving those superpowers?

[14:09:45.0474] <littledan>
 * isn't putting a context in ErrorEvent giving those superpowers?

[14:10:14.0561] <Chengzhong Wu>
ErrorEvents are errors captured at the top level

[14:10:23.0356] <Chengzhong Wu>
"throw" itself doesn't have this superpower

[14:10:36.0444] <Chengzhong Wu>
so this won't have a re-throw problem

[14:10:53.0190] <Chengzhong Wu>
 * ErrorEvents are errors captured at the host level

[14:38:53.0069] <Steve Hicks>
Hosts already compute stack traces at error construction time, so it seems pretty reasonable to also copy the context pointer at the same time.  But I'm a little fuzzy on how this proposal interacts with that, since EcmaScript doesn't even mention `stack` anywhere, even non-normatively.

[14:39:21.0802] <Steve Hicks>
Where are we planning on documenting the various DOM interactions?

[14:39:48.0996] <Chengzhong Wu>
> <@stephenhicks:matrix.org> Hosts already compute stack traces at error construction time, so it seems pretty reasonable to also copy the context pointer at the same time.  But I'm a little fuzzy on how this proposal interacts with that, since EcmaScript doesn't even mention `stack` anywhere, even non-normatively.

it's being worked at https://github.com/tc39/proposal-error-stacks.

[14:40:16.0488] <littledan>
> <@stephenhicks:matrix.org> Where are we planning on documenting the various DOM interactions?

we'll need to do so in places linked from https://github.com/whatwg/html/issues/10432 . I believe Andreu Botella is working on a document for this.

[14:42:05.0389] <littledan>
> <@legendecas:matrix.org> it's being worked at https://github.com/tc39/proposal-error-stacks.

"Being worked on" is generous for this proposal; the champions do not plan to work in a way that meets the (reasonable, IMO) requirements of browsers for spec work in this area. So we should definitely not depend on it.

[14:42:24.0567] <littledan>
I don't think there's active work in that repo either, given that browsers expressed requirements and that was demotivating

[14:43:04.0814] <Chengzhong Wu>
üòÖ "stalled for years"

[14:48:03.0750] <littledan>
yeah I think if you don't really get to make a big point about this happening "for years" when it's a reasonable thing requested and you just decided to not do it. "stalled for years" implies that something is actually happening.

[15:03:42.0676] <Stephen Belanger>
> <@littledan:matrix.org> well, some people care about client-side performance monitoring, but I take it that's not your team

Not my team, but also client monitoring has not generally had that level of capability yet, so it‚Äôs still a feature add even without all the things covered. Of course completeness is the ideal, but it‚Äôs a difficult spec so I can see it being hard to cover everything at once.

[15:35:41.0208] <littledan>
client monitoring in general? I'm curious whether Steve Hicks 's effort is for refining present monitoring, or making a new system that doesn't exist yet.

[15:38:11.0554] <littledan>
My goal is to build a reasonable basis for client-side monitoring, not reaching either extreme of "focus on server side now, do client side later" or "expose everything interesting that goes on in the client"


2024-07-02
[17:13:39.0180] <Stephen Belanger>
> <@littledan:matrix.org> client monitoring in general? I'm curious whether Steve Hicks 's effort is for refining present monitoring, or making a new system that doesn't exist yet.

In general. There‚Äôs some degree of browser tracing presently, but not nearly the maturity of servers. I agree that considering all runtime types is best though. Just pointing out server tracers won‚Äôt care so much about some of these concerns at they will not impact us.

[17:14:09.0550] <Stephen Belanger>
> <@littledan:matrix.org> client monitoring in general? I'm curious whether Steve Hicks 's effort is for refining present monitoring, or making a new system that doesn't exist yet.

 * In general. There‚Äôs some degree of browser tracing presently, but not nearly the maturity of servers. I agree that considering all runtime types is best though. Just pointing out server tracers won‚Äôt care so much about some of these concerns as they will not impact us.

[05:32:53.0805] <Andreu Botella>
I have a PR for the spec infra for the `error` event, PTAL: https://github.com/tc39/proposal-async-context/pull/95

[05:54:50.0006] <littledan>
> <@abotella:igalia.com> I have a PR for the spec infra for the `error` event, PTAL: https://github.com/tc39/proposal-async-context/pull/95

did we decide what the semantics would be at runtime for the error event on the web? Is that documented somewhere?

[05:56:51.0579] <Andreu Botella>
I don't think we reached a decision, but that PR does what you would expect, even for primitive exceptions


2024-07-03
[18:54:28.0096] <Steve Hicks>
> <@littledan:matrix.org> client monitoring in general? I'm curious whether Steve Hicks 's effort is for refining present monitoring, or making a new system that doesn't exist yet.

It's mostly the latter - we have some very limited client-side monitoring via explicit tracer propagation, but we've found it to be difficult for a few reasons: it's easy to forget to pass the tracer along, or to use it improperly, and it's viral, requiring every function signature to adapt to pass it along, so it's impractical to adopt in products that aren't already using it.  Our experience with server languages is that it really needs to be implicit, so that's why we're really interested in AsyncContext, and are experimenting with building out some new reporting systems based on that approach.  To that end, we're certainly not looking for "exposing everything that goes on" - but we _do_ need to make sure that we can integrate the tracing system into the framework at all, which we know is going to require avoiding registration-time snapshotting in at least some userland APIs, and possibly also some builtins.

[18:54:40.0924] <Steve Hicks>
> <@littledan:matrix.org> client monitoring in general? I'm curious whether Steve Hicks 's effort is for refining present monitoring, or making a new system that doesn't exist yet.

 * It's mostly the latter - we have some very limited client-side monitoring today via explicit tracer propagation, but we've found it to be difficult for a few reasons: it's easy to forget to pass the tracer along, or to use it improperly, and it's viral, requiring every function signature to adapt to pass it along, so it's impractical to adopt in products that aren't already using it.  Our experience with server languages is that it really needs to be implicit, so that's why we're really interested in AsyncContext, and are experimenting with building out some new reporting systems based on that approach.  To that end, we're certainly not looking for "exposing everything that goes on" - but we _do_ need to make sure that we can integrate the tracing system into the framework at all, which we know is going to require avoiding registration-time snapshotting in at least some userland APIs, and possibly also some builtins.

[18:58:55.0197] <Steve Hicks>
> <@abotella:igalia.com> I have a PR for the spec infra for the `error` event, PTAL: https://github.com/tc39/proposal-async-context/pull/95

I'm confused - it looks like that PR is adding a whole new runtime semantics section for try statements, but shouldn't it be modifying the existing one?

[19:00:10.0103] <Steve Hicks>
oh wait, I think I see - it's modifying the version that's already in the proposal...

[19:00:17.0810] <Steve Hicks>
which doesn't have that section at all yet

[19:00:33.0209] <Steve Hicks>
Is there an easy way to see it as a diff from the current standard?

[19:01:57.0799] <Andreu Botella>
the rendered spec has the differences as red and green `<ins>` and `<del>` sections

[19:02:06.0189] <Andreu Botella>
you can check out the PR and do `npm run build`

[19:02:21.0315] <Andreu Botella>
 * the rendered spec has the differences with the current standard as red and green `<ins>` and `<del>` sections

[19:05:58.0798] <Steve Hicks>
Does anything else AsyncContext-related live in the Agent Record at this point?  I don't think it's a problem, but I've been casually implementing the spec in my spare time and so far haven't touched the Agent Record yet (and at this point I've got almost the entire core language done, with just most of the runtime libraries missing).

[19:07:50.0740] <Steve Hicks>
(and to answer my own question - yes... AsyncContextMapping lives there)

[22:24:20.0550] <snek>
does anyone have info on how many ALS variables tend to be in use in applications that make do use of them? my assumption atm is not very many but I'd love hard data.

[22:24:38.0976] <snek>
* does anyone have info on how many ALS variables tend to be in use in applications that do make use of them? my assumption atm is not very many but I'd love hard data.

[04:13:14.0494] <littledan>
oh yeah I thought we'd use the execution context to hold this kind of thing

[04:14:12.0505] <littledan>
> <@devsnek:matrix.org> does anyone have info on how many ALS variables tend to be in use in applications that do make use of them? my assumption atm is not very many but I'd love hard data.

Yeah, I hope people use tens to hundreds at most (I don't have data)

[09:10:40.0894] <Stephen Belanger>
10+ is not uncommon, but more than 100 would be very rare. For the most part there‚Äôs a single store for each observability project, which often people have a couple installed, and then one in most routing frameworks, which there‚Äôs generally not more than one or two of installed. Sometimes companies build their own internally, which I don‚Äôt have numbers for how many instances they use internally there, but would assume similarly using a single store for their purpose.

[09:11:27.0092] <littledan>
I agree that >100 should be rare--it'd generally be a bug. I want to make sure we're considering React Context-type stuff in our analyses though.

[09:39:17.0895] <Andreu Botella>
Since we're thinking of exposing the causal/originating context as a nullable property on event objects, we should pick a property name


2024-07-04
[18:17:22.0960] <snek>
> <@littledan:matrix.org> oh yeah I thought we'd use the execution context to hold this kind of thing

wouldn't that mean every time the execution context changes we need to copy the value over

[18:21:34.0794] <snek>
wrt number of variables... should we put bounds on the algorithmic complexity of variable.run/get like we do for Map/Set? 

[19:40:05.0555] <littledan>
> <@devsnek:matrix.org> wrt number of variables... should we put bounds on the algorithmic complexity of variable.run/get like we do for Map/Set? 

You mean, tell everyone they are expected to optimize for >100 variables? I am not sure; maybe it is OK for people to decide that they are slow. We don‚Äôt do this for objects.

[19:40:47.0714] <snek>
well specifically just because we specify them with lists

[19:40:55.0237] <littledan>
> <@devsnek:matrix.org> wouldn't that mean every time the execution context changes we need to copy the value over

I think in this throw case you don‚Äôt want to copy

[19:41:25.0840] <littledan>
> <@devsnek:matrix.org> well specifically just because we specify them with lists

What if we include a note saying ‚Äúbtw you can implement this with a hamt‚Äù

[19:45:42.0402] <snek>
> Maps must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection. The data structure used in this specification is only intended to describe the required observable semantics of Maps. It is not intended to be a viable implementation model.

[19:46:41.0056] <snek>
something like this could be reasonable i think

[19:46:43.0589] <snek>
i guess i can open an issue

[20:02:10.0476] <Steve Hicks>
> <@devsnek:matrix.org> wrt number of variables... should we put bounds on the algorithmic complexity of variable.run/get like we do for Map/Set?

My understanding is that v8 is intending to actually use a linked list, under the assumption that the number will be pretty small, so requiring sublinear complexity may be a (bit of a) nonstarter for them.

[20:02:44.0459] <snek>
they're planning to start with a linked list but they've outlined a few other implementation strategies to try next

[20:03:01.0562] <snek>
either way, if we expect react apps to have 100 of these, O(n) might not be great

[20:04:11.0719] <Steve Hicks>
> <@devsnek:matrix.org> wouldn't that mean every time the execution context changes we need to copy the value over

IIUC, it would make function calls slightly more expensive (one more pointer to copy) but async context switches less expensive.  But since function calls are likely more common, it seems like the right trade-off to put it on the agent record.

[20:07:07.0391] <Steve Hicks>
> <@devsnek:matrix.org> either way, if we expect react apps to have 100 of these, O(n) might not be great

Even if there's 100s, if they're not all active at once it may not matter.  I'd expect any variables involved in rendering one component shouldn't escape into unrelated calls (under the current flow-around semantics).

[20:07:50.0604] <Steve Hicks>
But I'm not against speccing defensively here

[04:01:26.0822] <littledan>
I think we should not spec asymptotic behavior here. First priority for engines should be to optimize the <100 common case. Better to just make a suggestion in a note.

[04:01:58.0559] <littledan>
> <@devsnek:matrix.org> they're planning to start with a linked list but they've outlined a few other implementation strategies to try next

Note that they = Andreu and Chengzhong ;)


2024-07-08
[12:04:27.0649] <Justin Ridgewell>
> <@devsnek:matrix.org> either way, if we expect react apps to have 100 of these, O(n) might not be great

React Contexts do not need AC, and I don‚Äôt think they‚Äôre even compatible beacuse of React‚Äôs fiber batching mechanism.

[12:06:02.0477] <Justin Ridgewell>
> <@stephenhicks:matrix.org> IIUC, it would make function calls slightly more expensive (one more pointer to copy) but async context switches less expensive.  But since function calls are likely more common, it seems like the right trade-off to put it on the agent record.

Sorry, what new thing are we putting on the agent record?

[12:26:36.0173] <Steve Hicks>
The proposal as written puts `[[AsyncContextMapping]]` on the agent record, and #95 also adds `[[ThrowAsyncContextMapping]]`.

[12:27:43.0101] <Steve Hicks>
to what extent that's just an implementation detail is unclear to me - if an engine wanted to hold it on the execution context, that might be just as feasible?

[12:46:00.0340] <Andreu Botella>
I think for `[[AsyncContextMapping]]`, it'd be implementable as a property of the execution context

[12:47:18.0694] <Andreu Botella>
for `[[ThrowAsyncContextMapping]]` too I think (or I hope)

[12:48:18.0544] <Andreu Botella>
HTML needs abrupt completions to hold information related to when the exception was thrown, that currently isn't passed along in the spec

[12:48:41.0871] <Andreu Botella>
the idea would be that in a future where that is added to the JS spec, the throw context would be part of that data

[12:49:49.0169] <Andreu Botella>
I haven't fully checked whether the behavior with #95 would be equivalent to that, but ideally it would be

[12:54:12.0685] <littledan>
> <@jridgewell:matrix.org> React Contexts do not need AC, and I don‚Äôt think they‚Äôre even compatible beacuse of React‚Äôs fiber batching mechanism.

Can you elaborate on this? I know it doesn‚Äôt *need* it, but I thought it might be a good fit if async await were to ever be enabled on the client side in conjunction with hooks

[13:04:22.0748] <Justin Ridgewell>
Component functiosn aren‚Äôt executed recusively, they‚Äôre pushed into a stack to be processed later on. When you return the `<Ctx.Provider value=‚Ä¶><Foo /></Ctx.Provider>` VDOM, that `Foo` component won‚Äôt be executed within the sync execution of `Ctx.Provider`. If `Foo` were to `useContext(Ctx)`, that would be tracked as part of the component‚Äôs internal state (which itself is stored in a AC), it woulnd‚Äôt store the context on its own AC variable.

[13:07:02.0751] <Justin Ridgewell>
[Searching React‚Äôs codebase](https://github.com/search?q=repo%3Afacebook%2Freact+%22AsyncLocalStorage%3C%22&type=code) leads me to think there‚Äôll be a single AC/ALS for the VDOM (and another specifically for Server request state)

[13:07:30.0336] <Justin Ridgewell>
Which is exactly how I would implement this.

[13:35:35.0024] <snek>
that's good to hear


2024-07-09
[00:21:16.0417] <littledan>
> <@jridgewell:matrix.org> Component functiosn aren‚Äôt executed recusively, they‚Äôre pushed into a stack to be processed later on. When you return the `<Ctx.Provider value=‚Ä¶><Foo /></Ctx.Provider>` VDOM, that `Foo` component won‚Äôt be executed within the sync execution of `Ctx.Provider`. If `Foo` were to `useContext(Ctx)`, that would be tracked as part of the component‚Äôs internal state (which itself is stored in a AC), it woulnd‚Äôt store the context on its own AC variable.

I don‚Äôt get it; isn‚Äôt this what AsyncContext.Snapshot is for?

[00:22:14.0315] <littledan>
I thought, in the server, an AsyncContext variable for the hooks state

[00:27:57.0138] <littledan>
In general, I think conceptually, React Context is doing the same thing as AsyncContext. It just depends on the framework saving and restoring snapshots all over the place 

[00:30:34.0410] <littledan>
This is an important question because if we wanted to use AsyncContext variables for other things, like having an ambient AbortSignal, we would be depending on frameworks doing this snapshotting. Otherwise it wouldn‚Äôt work.

[09:00:53.0115] <Steve Hicks>
right, this is basically "the ecosystem adoption problem".

[09:03:34.0894] <Chengzhong Wu>
We are on the call now

[10:23:11.0769] <littledan>
How did the call go? I am having some trouble understanding the strength of the requirement that Matteo and Stephen were talking about in the notes

[10:23:44.0968] <littledan>
I couldn‚Äôt really understand why taking a callback as a parameter wouldn‚Äôt work for those cases

[10:23:50.0541] <littledan>
Sorry I missed it

[10:25:12.0349] <Andreu Botella>
it's not that it wouldn't work, but that it wouldn't be idiomatic, or it'd take a lot more boilerplate than the alternative

[10:25:15.0732] <littledan>
I actually don‚Äôt understand what is being asked for. How broad should the .set take effect?

[10:25:28.0600] <Andreu Botella>
for tests, if you have set/enterWith, you could set the context in `beforeEach`

[10:25:54.0296] <littledan>
Sure, I can see that, I guess what I don‚Äôt understand is *how* bad it is

[10:26:14.0002] <littledan>
How bad would it be if we deferred enterWith/set for ‚Äúlater‚Äù?

[10:28:23.0586] <littledan>
In general, there is an idiom where you store a mutable object in the asynccontext variable, and accessing the variable gets that object and then gets what it is wrapping. Every time you are tempted to do .set, you .get the variable and then set what it is wrapping. Are these semantics what we want for enterWith, or is it supposed to take effect within a more narrow scope?

[10:29:23.0976] <littledan>
This is the difference between ‚Äútrivial‚Äù and ‚Äúa massive design change‚Äù

[10:29:43.0179] <Andreu Botella>
I think Stephen was arguing for a more narrow scope

[10:29:58.0444] <littledan>
(Because we could make some sugar for the idiom I described, if desired)

[10:30:33.0890] <littledan>
> <@abotella:igalia.com> I think Stephen was arguing for a more narrow scope

It would be good to hear from both Stephen Belanger and Matteo Collina here

[10:30:59.0841] <littledan>
If you do want a narrower scope: how would you like to define that scope?

[10:33:47.0534] <littledan>
(In case I wasn‚Äôt clear: the broad scoped version is easier)

[10:34:02.0755] <Stephen Belanger>
> <@abotella:igalia.com> it's not that it wouldn't work, but that it wouldn't be idiomatic, or it'd take a lot more boilerplate than the alternative

No, there‚Äôs a lot of cases where taking a callback just doesn‚Äôt work. The example of storing a database connection in the top-level of one file and then trying to use it in another, for example. A common bootstrapping practice with top-level await.

There are also quite a few cases where APMs need to use enterWith because we just don‚Äôt have the ability to wrap a desired scope in any sort of callback‚Äîwe can‚Äôt change how user code behaves yet need to be able to flow context around it.

[10:35:16.0799] <littledan>
> <@stephenbelanger:matrix.org> No, there‚Äôs a lot of cases where taking a callback just doesn‚Äôt work. The example of storing a database connection in the top-level of one file and then trying to use it in another, for example. A common bootstrapping practice with top-level await.
> 
> There are also quite a few cases where APMs need to use enterWith because we just don‚Äôt have the ability to wrap a desired scope in any sort of callback‚Äîwe can‚Äôt change how user code behaves yet need to be able to flow context around it.

Great, do you think you could reference a case where DataDog needs to do this? I had trouble tracing through what it was used for in the open source code

[10:35:52.0489] <littledan>
 it definitely is used there, I just don‚Äôt understand the usage 

[10:35:53.0495] <Stephen Belanger>
As I described in the call, the semantics are essentially the same‚Äîthe scopes still exist‚Äîjust decoupling the changing of the value from the providing of a scope means the scope can be raised upward or made implicit in many cases. An implicit scope around the execution of the application, for example, would solve the database connection sharing problem.

[10:36:36.0311] <littledan>
‚ÄúThe scopes still exist‚Äù when is a scope created?

[10:36:55.0589] <Stephen Belanger>
I need to find time to write up a proper explanation of exactly how and why this works‚Ä¶hopefully I can find some time for that at some point‚Ä¶

[10:37:28.0337] <littledan>
Maybe you can fill in parts of the notes if you said something that wasn‚Äôt captured

[10:38:41.0473] <littledan>
I don‚Äôt understand what an implicit scope around the application means‚Ä¶ doesn‚Äôt the default value handle that?

[10:40:58.0981] <Andreu Botella>
not if the `AsyncContext.Variable` is created by a tracing library rather than by user code

[10:42:09.0351] <littledan>
What is the difference in what the tracing library does, in this case?

[10:42:16.0708] <littledan>
Is it one variable shared for many things?

[10:43:14.0467] <littledan>
I mean, are we running multiple applications in the same process? 

[10:44:08.0862] <Stephen Belanger>
Imagine a variable is created in fastify for it to manage its context. A user then wants to store their database connection in that after the fastify app has already been constructed and therefore already has its variable set up. They then expect that database connection to be readable in the top-level of another file that runs after that point.

[10:44:52.0242] <Stephen Belanger>
You can‚Äôt do that without an implicit scope, and default values don‚Äôt work either because the variable already exists.

[10:48:06.0337] <littledan>
Is the scope narrower than global here? Is this per request/response? Just trying to understand the scenario 

[10:48:43.0214] <littledan>
Is Fastify in a position to say, ‚Äúthis is the outer bounds, so future set calls apply only here‚Äù?

[10:49:01.0646] <littledan>
What I don‚Äôt understand is where implicit scope bounds need to be set

[15:00:19.0094] <snek>
this is about whether the proposal should support an api like AsyncLocalStorage#enterWith? What's the reason to not support it?

[15:16:49.0626] <Steve Hicks>
For the `beforeEach` case, I expect test runners could adapt pretty easily by providing a wrapping adapter - something like
```
aroundEach((test) => {
  v.run(value, test);
});
```
would get the job done.

[15:17:09.0515] <Steve Hicks>
 * For the `beforeEach` case, I expect test runners could adapt pretty easily by providing a wrapping adapter - something like

```
aroundEach((test) => v.run(value, test));
```

would get the job done.

[15:32:10.0938] <Steve Hicks>
> <@devsnek:matrix.org> this is about whether the proposal should support an api like AsyncLocalStorage#enterWith? What's the reason to not support it?

The reason is that it breaks encapsulation.  The current proposal means that you have strong guarantees that a variable won't change during the course of a function, but if a child task can `enterWith` a new value, then it can affect the parent task in unexpected ways.  It also runs afoul of the requirements imposed by SES, and is unlikely to be accepted by the committee.

That said, if you want to make your own `enterWith`able variable, it's easy enough:

```
class EnterableVar<T> {
  private readonly internal: AsyncContext.Variable<[T]>;
  constructor(opts = {}) {
    this.internal = new AsyncContext.Variable({...opts, defaultValue: [opts.defaultValue]});
  }
  run(val, fn) {
    return this.internal.run([val], fn);
  }
  get() {
    return this.internal.get()[0];
  }
  enterWith(val) {
    this.internal.get()[0] = val;
  }
}
```

