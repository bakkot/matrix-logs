<!DOCTYPE html><html><head>
  <title>TC39 Async Context on 2024-05-22</title>
  <link rel="stylesheet" href="../style.css">
  <script>window.room = "TC39 Async Context";</script><script src="../render-roomlist.js"></script>
  <script src="../logs.js"></script>
</head>
<body><div class="wrapper">
<div class="sidebar">
<div class="title">TC39 Async Context<br>2024-05-22<br><a href="plaintext/">plaintext logs</a></div>
<div class="nav">
<a href="2024-05-21" class="nav-link"><span>prev</span></a>
<span style="float:right">next</span>
</div>
    <div class="all-rooms"><noscript>JavaScript is required to load the channel index, but you can go to <a href="../..">the static index</a> directly.</noscript></div>
<div class="footer"><a href="https://github.com/bakkot/matrix-archive-bot">source on github</a></div>
</div>
<div class="rhs">
<div class="rhs-header">
<span id="error" style="color: red; display:none">error</span>

<input type="text" id="query" size="25" placeholder="Search TC39 Async Context">
<a id="search-submit" class="button icon-link" title="Search">
  <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg>
</a>
</div>

<div class="log"><table id="log-table"><tbody id="log-tbody">

  <tr class="msg" id="L0"><td class="ts-cell"><a class="ts" href="#L0" alt="Tue May 21 2024 17:01:27 GMT-0700 (Pacific Daylight Time)">00:01</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">I was kinda thinking out loud, and the fact that zone.js was probably the main reason why we were going with registration-time by default is something I noticed just now</td></tr>
  <tr class="msg" id="L1"><td class="ts-cell"><a class="ts" href="#L1" alt="Tue May 21 2024 17:01:29 GMT-0700 (Pacific Daylight Time)">00:01</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">but I will</td></tr>
  <tr class="msg" id="L2"><td class="ts-cell"><a class="ts" href="#L2" alt="Tue May 21 2024 17:04:36 GMT-0700 (Pacific Daylight Time)">00:04</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">I think Jia Li is the person, but I didnâ€™t manage to reach him through Twitter DMs <a href="https://x.com/Jialipassion">https://x.com/Jialipassion</a></td></tr>
  <tr class="msg" id="L3"><td class="ts-cell"><a class="ts" href="#L3" alt="Tue May 21 2024 17:05:46 GMT-0700 (Pacific Daylight Time)">00:05</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">We can work with other Angular devs to get his attention if we have trouble</td></tr>
  <tr class="msg" id="L4"><td class="ts-cell"><a class="ts" href="#L4" alt="Tue May 21 2024 17:06:20 GMT-0700 (Pacific Daylight Time)">00:06</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">Or meet him in Tokyo for TC39 this October! He showed up at last yearâ€™s community event</td></tr>
  <tr class="msg" id="L5"><td class="ts-cell"><a class="ts" href="#L5" alt="Tue May 21 2024 17:10:22 GMT-0700 (Pacific Daylight Time)">00:10</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">hm, I can't going to Finland, but I'd love to have a business reason to go to Tokyo ðŸ˜…</td></tr>
  <tr class="msg" id="L6"><td class="ts-cell"><a class="ts" href="#L6" alt="Tue May 21 2024 17:25:01 GMT-0700 (Pacific Daylight Time)">00:25</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@stephenhicks:matrix.org">Steve Hicks</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> I think that maybe the only cases where events should be registration time are the ones where there isn't any possible JS origin for the event</blockquote></mx-reply>An argument could be made that if there is no other JS origin, then registration time <em>is</em> the origin.  That said, I'm a little horrified by what this will mean for polyfills...</td></tr>
  <tr class="msg" id="L7"><td class="ts-cell"><a class="ts" href="#L7" alt="Tue May 21 2024 18:02:05 GMT-0700 (Pacific Daylight Time)">01:02</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">The implementation (and specification) of this version will certainly be more complex, including for browsers. So it is important that we consolidate documentation for exactly why this design is useful and provides better context.</td></tr>
  <tr class="msg" id="L8"><td class="ts-cell"><a class="ts" href="#L8" alt="Tue May 21 2024 18:03:15 GMT-0700 (Pacific Daylight Time)">01:03</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">Sometimes the most relevant context isnâ€™t there exactly synchronously and needs to be saved and restored (unhandled rejection is an example of this)</td></tr>
  <tr class="msg" id="L9"><td class="ts-cell"><a class="ts" href="#L9" alt="Wed May 22 2024 02:22:42 GMT-0700 (Pacific Daylight Time)">09:22</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> What is the example code? What is the indicated issue URL? Weâ€™d previosuly discussed why we donâ€™t have an <code data-md="`">enterWith</code> API because of cases like this, it needs to properly restore the context after the execution of the inner async function pauses its await. Part of the reason we discussed <code data-md="`">using</code> declarations with modifications to <code data-md="`">await</code> keyword to restore the previous context at the suspend point.</blockquote></mx-reply><p>This is exactly what I'm talking about. You seem to be explicitly aiming for binding <em>around</em> awaits, cutting off the branched execution merging back. This is explicitly what most users have told me they <em>don't</em> want. The code coming <em>out</em> of that await is a continuation, so it's essentially the same as if the remaining code was passed into that call as a callback, which <em>does</em> propagate context through. The fact that promises and async/await <em>will not</em> flow context through to continuations is extremely confusing to literally every user I've talked to about this. The whole <em>point</em> of context management to everyone I have talked to is to be able to set a value at some point in a branch of async execution and to be able to retrieve that same value <em>anywhere</em> in logically continuing execution, which <em>any</em> merge point like awaits, promise continuations, or callbacks all <em>are</em>.</p>
<p>The fact we are specifying a behaviour which seemingly no one outside of this group is asking for is very strange to me.</p>
</td></tr>
  <tr class="msg" id="L10"><td class="ts-cell"><a class="ts" href="#L10" alt="Wed May 22 2024 02:23:28 GMT-0700 (Pacific Daylight Time)">09:23</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> What issue? There were like 400 messages in this channel over the last week.</blockquote></mx-reply><a href="https://github.com/nodejs/node/issues/53037">https://github.com/nodejs/node/issues/53037</a></td></tr>
  <tr class="msg" id="L11"><td class="ts-cell"><a class="ts" href="#L11" alt="Wed May 22 2024 02:28:13 GMT-0700 (Pacific Daylight Time)">09:28</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> So itâ€™s the case where <code data-md="`">doSomething</code> doesnâ€™t create a parent span for its children? And we have to infer order of sibilngs when two <code data-md="`">doSomething</code> calls are interleaved. Is this not just user error?</blockquote></mx-reply><p>No, this is not user error. This is a common execution pattern which auto-instrumentation needs to be able to resolve, and it can't be done unless we flow context <em>through</em> merging branches.</p>
<p>This is user code which <em>we do not control</em> but are expected to be able to trace through correctly. There is no user error here because the user expects to not have to modify their code for it to be traceable, and there's no error in how APM vendors are handling these situations because we simply lack the tools for it to be <em>possible</em> to track directly. This was the entire point of creating AsyncLocalStorage in the <em>first</em> place, but it sadly only got <em>part</em> of the way to correctness due to resource constraints and lacking runtime capabilities.</p>
</td></tr>
  <tr class="msg" id="L12"><td class="ts-cell"><a class="ts" href="#L12" alt="Wed May 22 2024 02:35:48 GMT-0700 (Pacific Daylight Time)">09:35</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> <p>I spoke with the tracing experts I'm working with and they strongly prefer "flow around" semantics over "flow through" await (with a caveat that their primary experience is in other languages).  In particular, the concern is that the ability to do an unbounded <code>set()</code> isn't a good situation.  Further, they weren't at all concerned with the visibility issues from pruning off subtasks by binding around them, for two reasons: (1) exact follows-from relationships are primarily relevant for critical path analysis, which already has numerous other issues making it intractable, and (2) we can get a reasonable enough picture with the mutable trace objects referenced in a "lexically scoped" async store (i.e. what's currently proposed here).  The rough structure we use (IIUC) is that the async-local variables are trivially cheap span IDs and the global store is a log of events that includes those IDs.  When a span begins/ends, it gets a new ID the start/end times and parents are appended to the log (along with any additional metadata).  The graph can then be reconstructed later from that log.</p>
<p>I agree completely with Justin's assessment of the <code>doSomething()</code> example - it wouldn't be an issue if <code>doSomething</code> were properly instrumented.  If you branch into two parallel subtasks without making a child span, you're asking for a bad time.</p>
</blockquote></mx-reply><p>For the first part:</p>
<ul>
<li>In what way is critical path analysis intractable? This is literally what tracing products are <em>for</em>.</li>
<li>Mutable trace objects are what the entire industry does <em>presently</em> for Node.js. Every tracing product also has at least 30%+ CPU overhead and 50%+ memory overhead as a result. <em>All</em> tracing products are completely unusable at massive scale, which is why most FAANG is either flying practically <em>blind</em> with Node.js (Netflix), or doesn't use it in production <em>at all</em> because the tooling insufficient</li>
</ul>
<p>As for the second part:</p>
<ul>
<li>The <code>doSomething()</code> function here is user code calling into some <em>other</em> things we instrument. We have no awareness of this code as it's not part of any userland module, therefore it is impossible for us to instrument. This is an <em>extremely common</em> scenario which tracing products are <em>expected</em> to be able to trace. APM vendors are <em>constantly</em> losing deals because we are unable to product correct traces for many prospective customers.</li>
</ul>
</td></tr>
  <tr class="msg" id="L13"><td class="ts-cell"><a class="ts" href="#L13" alt="Wed May 22 2024 02:39:57 GMT-0700 (Pacific Daylight Time)">09:39</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> I was kinda thinking out loud, and the fact that zone.js was probably the main reason why we were going with registration-time by default is something I noticed just now</blockquote></mx-reply>Node.js defaults to running everything in the scope where the emit happened, but <a href="https://nodejs.org/api/events.html#class-eventseventemitterasyncresource-extends-eventemitter">EventEmitterAsyncResource</a> exists to chose register time for an entire event emitter as-needed.</td></tr>
  <tr class="msg" id="L14"><td class="ts-cell"><a class="ts" href="#L14" alt="Wed May 22 2024 07:27:12 GMT-0700 (Pacific Daylight Time)">14:27</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">How about an option on <code>dispatchEvent</code> to fire the event with the registration context, rather than the current one?</td></tr>
  <tr class="msg" id="L15"><td class="ts-cell"><a class="ts" href="#L15" alt="Wed May 22 2024 08:04:23 GMT-0700 (Pacific Daylight Time)">15:04</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Node.js defaults to running everything in the scope where the emit happened, but <a href="https://nodejs.org/api/events.html#class-eventseventemitterasyncresource-extends-eventemitter">EventEmitterAsyncResource</a> exists to chose register time for an entire event emitter as-needed.</blockquote></mx-reply>it seems like that is meant for user-defined emitters, and can't be used for built-ins</td></tr>
  <tr class="msg" id="L16"><td class="ts-cell"><a class="ts" href="#L16" alt="Wed May 22 2024 08:05:15 GMT-0700 (Pacific Daylight Time)">15:05</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">do you ever use that to monkeypatch built-ins? is it better than just monkeypatching the <code>EventEmitter</code> methods on the object itself?</td></tr>
  <tr class="msg" id="L17"><td class="ts-cell"><a class="ts" href="#L17" alt="Wed May 22 2024 09:10:27 GMT-0700 (Pacific Daylight Time)">16:10</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@stephenhicks:matrix.org">Steve Hicks</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> How about an option on <code>dispatchEvent</code> to fire the event with the registration context, rather than the current one?</blockquote></mx-reply>I'm not quite sure how to think about that one... my initial reaction is that I still don't like touching specific scheduling APIs because it sets a weird precedent that every scheduling API needs to change to account for this.  But maybe this is a "you can't keep your cake and eat it" situation where we're saying that we need to provide this control.  Overall, I don't think the one who calls dispatchEvent is the one who knows which context it should be in.</td></tr>
  <tr class="msg" id="L18"><td class="ts-cell"><a class="ts" href="#L18" alt="Wed May 22 2024 09:28:30 GMT-0700 (Pacific Daylight Time)">16:28</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@stephenhicks:matrix.org">Steve Hicks</span>&gt;</div></td><td class="msg-cell"><p>Honestly I find the flow-through behavior to be much more confusing.  I suspect this has to do with my starting point.  I (and I think others here) come from a perspective where this is an implicit version of what golang does explicitly with their Context object.  When you pass a Context into a subtask, that task is free to make its own child Contexts with different mappings, but because Context is itself immutable, there's no way for those changes to be visible to the caller.  So from the point of view of seeing this as just a bag for passing implicit parameters, there's no expectation that a callee could change one for a caller (unless the passed object is itself mutable).</p>
<p>If you are instead coming from a perspective where the purpose of this is to provide a mechanism to track execution flow, then I suspect the surprise goes in the opposite direction.  So the question is (1) which of these is AsyncContext intended to be, and (2) is there any reasonable way for it to do both?  Is "context" even the right concept for tracking execution flow, or is there something else that could do it more naturally?</p>
</td></tr>
  <tr class="msg" id="L19"><td class="ts-cell"><a class="ts" href="#L19" alt="Wed May 22 2024 09:51:53 GMT-0700 (Pacific Daylight Time)">16:51</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@stephenhicks:matrix.org">Steve Hicks</span>&gt;</div></td><td class="msg-cell">Cancellation is an example of a use case where bind-around is what we want.  Suppose we have a "globally well-known" <code>abort: AsyncContext.Variable&lt;AbortSignal&gt;</code> for the current task.  Well-behaved jobs can inspect it and <code>throwIfAborted</code>, pass it along to things like <code>fetch</code> (or even have <code>fetch</code> use it implicitly), etc.  Suppose you want to do something that can be cancelled independently of the upstream abort - you can <code>const c = new AbortController()</code> and then <code><a href="http://abort.run">abort.run</a>(AbortSignal.any(abort.get(), c.signal), ...)</code>, and the child task can be cancelled by either the parent or the new child controller.  Now imagine you've just programmatically added 5 cards to a view, which each need to fetch data and render themselves.  You might kick off 5 fetches, each with its own child signal.  If the user dismisses one of those cards while it was still loading, we can abort that one child controller individually.  But it would clearly be a mistake to end up with one of those child signals as the current signal after <code>await Promise.all(childCards)</code>.</td></tr>
  <tr class="msg" id="L20"><td class="ts-cell"><a class="ts" href="#L20" alt="Wed May 22 2024 10:02:39 GMT-0700 (Pacific Daylight Time)">17:02</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-1" title="@jridgewell:matrix.org">Justin Ridgewell</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote><p>This is exactly what I'm talking about. You seem to be explicitly aiming for binding <em>around</em> awaits, cutting off the branched execution merging back. This is explicitly what most users have told me they <em>don't</em> want. The code coming <em>out</em> of that await is a continuation, so it's essentially the same as if the remaining code was passed into that call as a callback, which <em>does</em> propagate context through. The fact that promises and async/await <em>will not</em> flow context through to continuations is extremely confusing to literally every user I've talked to about this. The whole <em>point</em> of context management to everyone I have talked to is to be able to set a value at some point in a branch of async execution and to be able to retrieve that same value <em>anywhere</em> in logically continuing execution, which <em>any</em> merge point like awaits, promise continuations, or callbacks all <em>are</em>.</p>
<p>The fact we are specifying a behaviour which seemingly no one outside of this group is asking for is very strange to me.</p>
</blockquote></mx-reply>I think youâ€™re misinterpreting my statement. We can have flow-through semantics without <code data-md="`">enterWith</code>. <code data-md="`">enterWith</code> is a foot-gun that exposes an unfixable memory leak, and I specifically opose that. I will not accept a design that has an unparied enter/exit.</td></tr>
  <tr class="msg" id="L21"><td class="ts-cell"><a class="ts" href="#L21" alt="Wed May 22 2024 10:05:28 GMT-0700 (Pacific Daylight Time)">17:05</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> I think that maybe the only cases where events should be registration time are the ones where there isn't any possible JS origin for the event</blockquote></mx-reply><span class="nick-1">Justin Ridgewell</span>: I was wondering about your thoughts on this ^ , since you suggested that the behavior for events should probably follow zone.js, and this does the opposite</td></tr>
  <tr class="msg" id="L22"><td class="ts-cell"><a class="ts" href="#L22" alt="Wed May 22 2024 10:06:58 GMT-0700 (Pacific Daylight Time)">17:06</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-1" title="@jridgewell:matrix.org">Justin Ridgewell</span>&gt;</div></td><td class="msg-cell">What APIs would that include? I think that means all click listeners are call-time, but what context is that for a userâ€™s click vs a programatic click?</td></tr>
  <tr class="msg" id="L23"><td class="ts-cell"><a class="ts" href="#L23" alt="Wed May 22 2024 10:07:48 GMT-0700 (Pacific Daylight Time)">17:07</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">For a user's click, it would be registration time, and for a programatic click, it would be call time on the call to <code>.click()</code></td></tr>
  <tr class="msg" id="L24"><td class="ts-cell"><a class="ts" href="#L24" alt="Wed May 22 2024 10:08:08 GMT-0700 (Pacific Daylight Time)">17:08</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-1" title="@jridgewell:matrix.org">Justin Ridgewell</span>&gt;</div></td><td class="msg-cell">Iâ€™d prefer registration-time for both cases for consistentcy, but Iâ€™d see both options being acceptable.</td></tr>
  <tr class="msg" id="L25"><td class="ts-cell"><a class="ts" href="#L25" alt="Wed May 22 2024 10:09:37 GMT-0700 (Pacific Daylight Time)">17:09</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-1" title="@jridgewell:matrix.org">Justin Ridgewell</span>&gt;</div></td><td class="msg-cell">Was the <code data-md="`">unwrap()</code> API discussed?</td></tr>
  <tr class="msg" id="L26"><td class="ts-cell"><a class="ts" href="#L26" alt="Wed May 22 2024 10:10:11 GMT-0700 (Pacific Daylight Time)">17:10</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">no</td></tr>
  <tr class="msg" id="L27"><td class="ts-cell"><a class="ts" href="#L27" alt="Wed May 22 2024 10:11:31 GMT-0700 (Pacific Daylight Time)">17:11</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">I'm not too much of a fan of <code>unwrap()</code>, but it is an option we could use</td></tr>
  <tr class="msg" id="L28"><td class="ts-cell"><a class="ts" href="#L28" alt="Wed May 22 2024 10:13:23 GMT-0700 (Pacific Daylight Time)">17:13</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell">btw, I think at some point Jatin said he had a use case for detecting the null context (the difference between user's click and programmatic click in this case)</td></tr>
  <tr class="msg" id="L29"><td class="ts-cell"><a class="ts" href="#L29" alt="Wed May 22 2024 10:13:41 GMT-0700 (Pacific Daylight Time)">17:13</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@abotella:igalia.com">Andreu Botella</span>&gt;</div></td><td class="msg-cell"><span class="nick-2">Steve Hicks</span>: do you know anything about that?</td></tr>
  <tr class="msg" id="L30"><td class="ts-cell"><a class="ts" href="#L30" alt="Wed May 22 2024 10:18:19 GMT-0700 (Pacific Daylight Time)">17:18</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> do you ever use that to monkeypatch built-ins? is it better than just monkeypatching the <code>EventEmitter</code> methods on the object itself?</blockquote></mx-reply>Nope, it's for a user of EventEmitter to explicitly opt-in to that flow. APMs need to go for direct patching though.</td></tr>
  <tr class="msg" id="L31"><td class="ts-cell"><a class="ts" href="#L31" alt="Wed May 22 2024 10:21:17 GMT-0700 (Pacific Daylight Time)">17:21</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-7" title="@legendecas:matrix.org">Chengzhong Wu</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> do you ever use that to monkeypatch built-ins? is it better than just monkeypatching the <code>EventEmitter</code> methods on the object itself?</blockquote></mx-reply>Node.js builtins have async hooks built-in support so it is not necessary to patch built-ins to avoid empty context</td></tr>
  <tr class="msg" id="L32"><td class="ts-cell"><a class="ts" href="#L32" alt="Wed May 22 2024 10:22:23 GMT-0700 (Pacific Daylight Time)">17:22</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-7" title="@legendecas:matrix.org">Chengzhong Wu</span>&gt;</div></td><td class="msg-cell">However, this support is not defined in web platform yet</td></tr>
  <tr class="msg" id="L33"><td class="ts-cell"><a class="ts" href="#L33" alt="Wed May 22 2024 10:27:50 GMT-0700 (Pacific Daylight Time)">17:27</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> <p>Honestly I find the flow-through behavior to be much more confusing.  I suspect this has to do with my starting point.  I (and I think others here) come from a perspective where this is an implicit version of what golang does explicitly with their Context object.  When you pass a Context into a subtask, that task is free to make its own child Contexts with different mappings, but because Context is itself immutable, there's no way for those changes to be visible to the caller.  So from the point of view of seeing this as just a bag for passing implicit parameters, there's no expectation that a callee could change one for a caller (unless the passed object is itself mutable).</p>
<p>If you are instead coming from a perspective where the purpose of this is to provide a mechanism to track execution flow, then I suspect the surprise goes in the opposite direction.  So the question is (1) which of these is AsyncContext intended to be, and (2) is there any reasonable way for it to do both?  Is "context" even the right concept for tracking execution flow, or is there something else that could do it more naturally?</p>
</blockquote></mx-reply><p>Yep, I get that you have different use cases, and I <em>assume</em> with this much energy pushing in that direction there must be some <em>valid</em> reasons for aiming for these semantics. However, in Node.js most users are coming from the space of having a bunch of historically callback-oriented code taking advantage of context flowing to logically continuing execution so they can flow data between their components without needing to get teams owning intermediary components to explicitly pass along their bits of data. In more <em>recent</em> history they are starting to adapt that callback code to promise code and then being confused/angry/disappointed that their data no longer flows into that later code.</p>
<p>I suggested yesterday that it might make sense to have a separate equivalent to AsyncContext called something like ContinuationContext which more semantically matches the downstream availability semantics these users are expecting. I also commented that I think the naming of AsyncContext could maybe be more illustrative of exactly <em>what</em> the flow is to not confuse users into thinking this thing has the flow they are expecting.</p>
</td></tr>
  <tr class="msg" id="L34"><td class="ts-cell"><a class="ts" href="#L34" alt="Wed May 22 2024 10:33:29 GMT-0700 (Pacific Daylight Time)">17:33</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Cancellation is an example of a use case where bind-around is what we want.  Suppose we have a "globally well-known" <code>abort: AsyncContext.Variable&lt;AbortSignal&gt;</code> for the current task.  Well-behaved jobs can inspect it and <code>throwIfAborted</code>, pass it along to things like <code>fetch</code> (or even have <code>fetch</code> use it implicitly), etc.  Suppose you want to do something that can be cancelled independently of the upstream abort - you can <code>const c = new AbortController()</code> and then <code><a href="http://abort.run">abort.run</a>(AbortSignal.any(abort.get(), c.signal), ...)</code>, and the child task can be cancelled by either the parent or the new child controller.  Now imagine you've just programmatically added 5 cards to a view, which each need to fetch data and render themselves.  You might kick off 5 fetches, each with its own child signal.  If the user dismisses one of those cards while it was still loading, we can abort that one child controller individually.  But it would clearly be a mistake to end up with one of those child signals as the current signal after <code>await Promise.all(childCards)</code>.</blockquote></mx-reply>Hmm...I can see value to <em>both</em> flows when it comes to cancellation, actually. But I assume the <em>inner</em> promises being awaited would just raise exceptions to the outer function doing the awaiting, allowing those to do their own exception handling? Personally though I feel like what you would actually <em>want</em> is for the level at which you do the run to be "around" scoped and then <em>nested</em> branches to be <em>through</em> scoped so it raises all the way up to the <em>intended</em> scope boundary and not introducing an additional exception type to intermediate layers. That seems like the same SES concern state above of communication between two points unexpectedly influencing the intermediate layers.</td></tr>
  <tr class="msg" id="L35"><td class="ts-cell"><a class="ts" href="#L35" alt="Wed May 22 2024 10:36:55 GMT-0700 (Pacific Daylight Time)">17:36</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> I think youâ€™re misinterpreting my statement. We can have flow-through semantics without <code data-md="`">enterWith</code>. <code data-md="`">enterWith</code> is a foot-gun that exposes an unfixable memory leak, and I specifically opose that. I will not accept a design that has an unparied enter/exit.</blockquote></mx-reply>It's <em>not</em> an unpaired enter/exit though. The enter/exit is just left up to the runtime. so a microtask boundary, or the execution scope of the top-level script or module. There's still a clearly defined scope you can use, and this is what <em>literally every other language does</em>, it's just under full control of the runtime to define them rather than leaving it up to the user to define their own <em>custom</em> boundaries, which are arguably <em>more</em> complex to reason about because the runtime can't do things like having the optimizer rearrange execution <em>around</em> these boundaries without breaking the context guarantees.</td></tr>
  <tr class="msg" id="L36"><td class="ts-cell"><a class="ts" href="#L36" alt="Wed May 22 2024 10:42:42 GMT-0700 (Pacific Daylight Time)">17:42</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><p>What all other languages which have <em>automatically</em> propagated context do is exactly this:</p>
<pre><code class="language-js">store.defineScope(() =&gt; {
  store.setForCurrentScope('foo')
})
</code></pre>
<p>With the exception that the <code>store.defineScope(...)</code> part is just implicitly encoded into many barriers within the language/runtime itself.</p>
</td></tr>
  <tr class="msg" id="L37"><td class="ts-cell"><a class="ts" href="#L37" alt="Wed May 22 2024 10:42:59 GMT-0700 (Pacific Daylight Time)">17:42</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">So .NET defines a scope around each async function call. Sync calls too actually, so it's even <em>more</em> consistent than AsyncContext is which just flows over linear time in a sync block of code.</td></tr>
  <tr class="msg" id="L38"><td class="ts-cell"><a class="ts" href="#L38" alt="Wed May 22 2024 10:43:17 GMT-0700 (Pacific Daylight Time)">17:43</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">Which produces exactly the semantics you are describing.</td></tr>
  <tr class="msg" id="L39"><td class="ts-cell"><a class="ts" href="#L39" alt="Wed May 22 2024 10:43:32 GMT-0700 (Pacific Daylight Time)">17:43</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">While <em>also</em> allowing mutability of the slot <em>within</em> that function <em>safely</em>.</td></tr>
  <tr class="msg" id="L40"><td class="ts-cell"><a class="ts" href="#L40" alt="Wed May 22 2024 10:45:16 GMT-0700 (Pacific Daylight Time)">17:45</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">The <em>only</em> difference with how AsyncContext is defined <em>presently</em> is just that the <code>defineScope(...)</code> and <code>setForCurrentScope(...)</code> concepts are forcefully made to be only possible to do at the same point, but in terms of actual safety and control they are identical.</td></tr>
  <tr class="msg" id="L41"><td class="ts-cell"><a class="ts" href="#L41" alt="Wed May 22 2024 10:45:37 GMT-0700 (Pacific Daylight Time)">17:45</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">And nothing <em>stops</em> us from <em>also</em> providing users the ability to describe <em>additional</em> scopes.</td></tr>
  <tr class="msg" id="L42"><td class="ts-cell"><a class="ts" href="#L42" alt="Wed May 22 2024 10:46:56 GMT-0700 (Pacific Daylight Time)">17:46</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">We're also <em>essentially</em> already <em>doing</em> this with capture scopes around things like awaits. They are just another manifestation of setting a value for some synchronous window. The fact that it is propagated from elsewhere is somewhat immaterial.</td></tr>
  <tr class="msg" id="L43"><td class="ts-cell"><a class="ts" href="#L43" alt="Wed May 22 2024 10:49:31 GMT-0700 (Pacific Daylight Time)">17:49</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">The set/get style is <em>much</em> better in terms of closure reduction, more flexible and better suited to async/await flows, and <em>equally</em> as safe as the <code><a href="http://store.run">store.run</a>(...)</code> form.</td></tr>
  <tr class="msg" id="L44"><td class="ts-cell"><a class="ts" href="#L44" alt="Wed May 22 2024 11:02:50 GMT-0700 (Pacific Daylight Time)">18:02</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-1" title="@jridgewell:matrix.org">Justin Ridgewell</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote>Cancellation is an example of a use case where bind-around is what we want.  Suppose we have a "globally well-known" <code>abort: AsyncContext.Variable&lt;AbortSignal&gt;</code> for the current task.  Well-behaved jobs can inspect it and <code>throwIfAborted</code>, pass it along to things like <code>fetch</code> (or even have <code>fetch</code> use it implicitly), etc.  Suppose you want to do something that can be cancelled independently of the upstream abort - you can <code>const c = new AbortController()</code> and then <code><a href="http://abort.run">abort.run</a>(AbortSignal.any(abort.get(), c.signal), ...)</code>, and the child task can be cancelled by either the parent or the new child controller.  Now imagine you've just programmatically added 5 cards to a view, which each need to fetch data and render themselves.  You might kick off 5 fetches, each with its own child signal.  If the user dismisses one of those cards while it was still loading, we can abort that one child controller individually.  But it would clearly be a mistake to end up with one of those child signals as the current signal after <code>await Promise.all(childCards)</code>.</blockquote></mx-reply>I think we can extend this as well. Imagine the parent is doing a fetch and creates an abort signal, then passes that same signal to the children to perform their fetches. They each setup their own fetch state otherwise, maybe logging. Itâ€™d be surprising that the parent aborting their fetch causes the childâ€™s fetch to inherit the parentâ€™s fetch state.</td></tr>

</tbody></table></div></div></div>
</body></html>