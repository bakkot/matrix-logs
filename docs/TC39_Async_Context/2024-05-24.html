<!DOCTYPE html><html><head>
  <title>TC39 Async Context on 2024-05-24</title>
  <link rel="stylesheet" href="../style.css">
  <script>window.room = "TC39 Async Context";</script><script src="../render-roomlist.js"></script>
  <script src="../logs.js"></script>
</head>
<body><div class="wrapper">
<div class="sidebar">
<div class="title">TC39 Async Context<br>2024-05-24<br><a href="plaintext/">plaintext logs</a></div>
<div class="nav">
<a href="2024-05-23" class="nav-link"><span>prev</span></a>
<span style="float:right">next</span>
</div>
    <div class="all-rooms"><noscript>JavaScript is required to load the channel index, but you can go to <a href="../..">the static index</a> directly.</noscript></div>
<div class="footer"><a href="https://github.com/bakkot/matrix-archive-bot">source on github</a></div>
</div>
<div class="rhs">
<div class="rhs-header">
<span id="error" style="color: red; display:none">error</span>

<input type="text" id="query" size="25" placeholder="Search TC39 Async Context">
<a id="search-submit" class="button icon-link" title="Search">
  <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg>
</a>
</div>

<div class="log"><table id="log-table"><tbody id="log-tbody">

  <tr class="msg" id="L0"><td class="ts-cell"><a class="ts" href="#L0" alt="Thu May 23 2024 18:57:09 GMT-0700 (Pacific Daylight Time)">01:57</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@stephenhicks:matrix.org">Steve Hicks</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> <p>So there are two cases.</p>
<ol>
<li>User registered the click event handler in zone1, and user click the button with mouse, the click behavior happens in a noop zone (the default zone), and the handler should run in the registered zone.</li>
<li>User registered the click event handler in zone1, and user trigger the zone programmatically with something like dispatchEvent in zone2, so in this case, it is confusing that which zone should the handler run into, from the zone.js unified policy perspective, it should be zone1, otherwise in the 1st usecase, the handler should run in the noop zone,  but some user may want to see zone2 in some scenario.</li>
</ol>
<p>I still belive the current policy (run callback in the register zone) make more senses, and maybe in some cases let use can also access both the register zone and the trigger zone will be better.</p></blockquote></mx-reply>I agree that the inconsistency of falling back is troubling. But I guess I don't see what the problem is with having interactions trigger in the null zone? Out of the three options (fall back with inconsistency, always registration but no reasonable way to access the trigger, or always trigger but sometimes/often that's the null zone) I'm happiest with the trade-off of sometimes exposing the null zone.</td></tr>
  <tr class="msg" id="L1"><td class="ts-cell"><a class="ts" href="#L1" alt="Thu May 23 2024 19:37:09 GMT-0700 (Pacific Daylight Time)">02:37</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">When is the null zone what you want?</td></tr>
  <tr class="msg" id="L2"><td class="ts-cell"><a class="ts" href="#L2" alt="Thu May 23 2024 19:37:57 GMT-0700 (Pacific Daylight Time)">02:37</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">The registration time zone is often what you want, on the other hand, eg for onload, setTimeout, etc. I don’t see how we could have any sort of consistent principle that you never get the registration context.</td></tr>
  <tr class="msg" id="L3"><td class="ts-cell"><a class="ts" href="#L3" alt="Thu May 23 2024 20:02:26 GMT-0700 (Pacific Daylight Time)">03:02</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@stephenhicks:matrix.org">Steve Hicks</span>&gt;</div></td><td class="msg-cell">It's a spectrum. "Never registration" is one extreme end, and I don't think it's tenable. But for any _given_ API (e.g. events as a whole, or possibly split-out per event emitter/type) I'm very wary of a zalgoesque situation where the callback might run in one of two different contexts depending on unpredictable future conditions. I think that in the same way that it's important to know precisely whether a callback will run synchronously or not, it's similarly important to know ahead of time which context it will run in, and having a fallback muddies it and is (in my view) a worse trade-off than running in a "useless" context by default.</td></tr>
  <tr class="msg" id="L4"><td class="ts-cell"><a class="ts" href="#L4" alt="Thu May 23 2024 20:06:38 GMT-0700 (Pacific Daylight Time)">03:06</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">For something like onclick, the normal case is that it was triggered by the mouse, and the exceptional case is where JS dispatched the event. What should happen for that?</td></tr>
  <tr class="msg" id="L5"><td class="ts-cell"><a class="ts" href="#L5" alt="Thu May 23 2024 20:08:08 GMT-0700 (Pacific Daylight Time)">03:08</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">I would prefer to never expose a null context. If we can avoid that, then the value of all of your variables is always derived from previous code which triggered this one. Sorry, that is a theoretical argument and not a use-case-driven one, but it feels like an important property to preserve.</td></tr>
  <tr class="msg" id="L6"><td class="ts-cell"><a class="ts" href="#L6" alt="Thu May 23 2024 20:08:56 GMT-0700 (Pacific Daylight Time)">03:08</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell">I can relate to the vague Zalgo concern but am not sure if that is the overriding, most important thing to drive the decision</td></tr>
  <tr class="msg" id="L7"><td class="ts-cell"><a class="ts" href="#L7" alt="Fri May 24 2024 02:55:21 GMT-0700 (Pacific Daylight Time)">09:55</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-16" title="@mcollina:matrix.org">Matteo Collina</span>&gt;</div></td><td class="msg-cell">Hello! <span class="nick-7">Chengzhong Wu</span> told me to join here :D</td></tr>
  <tr class="msg" id="L8"><td class="ts-cell"><a class="ts" href="#L8" alt="Fri May 24 2024 05:11:27 GMT-0700 (Pacific Daylight Time)">12:11</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> <blockquote data-md=">">The exit is the end of the scope function<br></blockquote><br>Which means there’s a leak until the end of the function. <a href="https://gist.github.com/jridgewell/4aa2d6458f41d4574d6aeb580dc80d5d">https://gist.github.com/jridgewell/4aa2d6458f41d4574d6aeb580dc80d5d</a></blockquote></mx-reply><code>enterWith(...)</code> is <em>not</em> the same thing as a <em>correctly formed</em> <code>set</code>/<code>get</code> interface. The <code>enterWith(...)</code> API is a hack and the docs explicitly advise people <em>not to use it</em> as it <em>does not</em> have any any scope end and context is not guaranteed to derive from any sort of root context, so it's an incorrect interface. It only exists because <em>sometimes</em> it's the only way to do something in certain cases, but you need to <em>really</em> understand the implications. It basically only exists as a tool for APM vendors that needed the capability even if it was unsafe.</td></tr>
  <tr class="msg" id="L9"><td class="ts-cell"><a class="ts" href="#L9" alt="Fri May 24 2024 05:12:47 GMT-0700 (Pacific Daylight Time)">12:12</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> <blockquote data-md=">">And yes, there most certainly is a way to know when execution ends: any time the runtime would become idle and/or transition to microtask processing it knows it has reached the end of the current selection of synchronous code. <br></blockquote><br>How do you propose expsoing this API to libraries?</blockquote></mx-reply><p>We can have the same sort of scoping mechanism we have already, just remove the value setting part from it. So users can use exactly the example I shared above:</p>
<pre><code class="language-js">store.defineScope(() =&gt; {
  store.setForCurrentScope('foo')
})
</code></pre>
</td></tr>
  <tr class="msg" id="L10"><td class="ts-cell"><a class="ts" href="#L10" alt="Fri May 24 2024 05:25:06 GMT-0700 (Pacific Daylight Time)">12:25</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> <blockquote data-md=">">However, you don't actually need to know when an end occurs if all execution descends from a root at the beginning of execution as then the start of any execution would be propagating and therefore swapping out the context value anyway<br></blockquote><br>This doesn’t fully remove the need for the above end of task detection, becuase the last object placed there can’t be freed until the event loops replaces the context. It also means that Jobs would place an empty context when they return, which is OK I guess.</blockquote></mx-reply><p>You can know synchronously if the value still needs to be held. If an async task is scheduled in a sync tick where that context is set then it is captured to be propagated. This creates a GC reference that holds it open. If a sync tick <em>doesn't</em> create any further async tasks then it knows at the end of that sync tick that it created no new references.</p>
<p>In branching scenarios you would get each branch flowing up to exactly where it stops directly <em>causing</em> async code and then would have no more references. Each sync tick would only hold the reference while running, and then each async task would hold a reference until it would run. After the task runs it can discard <em>its</em> reference, but that would happen after new references were created for any children. Thus the GC would just function as-normal.</p>
<p>Now it <em>is</em> the case that data might live <em>quite a long time</em> sometimes, but this is <em>intentional</em> as it will only live long if descending execution of that point in context continues for long so it <em>should</em> be holding that value as anywhere in that descending code should be able to retrieve that data.</p>
<p>The risk of things living super long though is also easily mitigated by just emptying the context in some way, such as setting it to <code>undefined</code> when you've decided you're done with it.</p>
<p>My point is that in a <em>correctly formed</em> <code>set</code>/<code>get</code> system with clearly defined execution boundaries you would get a context flow that is perfectly safe from a memory usage perspective, have equivalent security characteristics to what is being proposed now (especially if a user-usable scope definition interface is added, and <em>most</em> importantly would actually match the behaviour which basically every user of AsyncLocalStorage (which is <em>a lot</em>--literally every single Fortune 500) is <em>expecting</em> from it.</p>
</td></tr>
  <tr class="msg" id="L11"><td class="ts-cell"><a class="ts" href="#L11" alt="Fri May 24 2024 13:05:53 GMT-0700 (Pacific Daylight Time)">20:05</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@littledan:matrix.org">littledan</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Hello! <span class="nick-7">Chengzhong Wu</span> told me to join here :D</blockquote></mx-reply>So… what do you think about the big question, of what the context should be after await? The main thing I am wondering is, how bad is AsyncLocalStorage’s behavior, and what would the practical benefits be of the change</td></tr>
  <tr class="msg" id="L12"><td class="ts-cell"><a class="ts" href="#L12" alt="Fri May 24 2024 14:09:35 GMT-0700 (Pacific Daylight Time)">21:09</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-1" title="@jridgewell:matrix.org">Justin Ridgewell</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote><p>We can have the same sort of scoping mechanism we have already, just remove the value setting part from it. So users can use exactly the example I shared above:</p>
<pre><code class="language-js">store.defineScope(() =&gt; {
  store.setForCurrentScope('foo')
})
</code></pre>
</blockquote></mx-reply>This seems funcionally equivalent to <a href="https://github.com/tc39/proposal-async-context/issues/60#issuecomment-2050457550">https://github.com/tc39/proposal-async-context/issues/60#issuecomment-2050457550</a>, which solves the global leak issue by having a wrapping try-catch reset the vaules after exiting the closure. It’s still not my favorite implementation becuase of mutability and odering of async functions causing unrelated breakages, eg if <a data-md="" href="https://gist.github.com/jridgewell/4aa2d6458f41d4574d6aeb580dc80d5d">main</a> started with an <code data-md="`">await 0</code> before entering <code data-md="`">’bar’</code>, the outside caller sees different behavior. It feels like Zalgo-lite.</td></tr>
  <tr class="msg" id="L13"><td class="ts-cell"><a class="ts" href="#L13" alt="Fri May 24 2024 14:12:29 GMT-0700 (Pacific Daylight Time)">21:12</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-1" title="@jridgewell:matrix.org">Justin Ridgewell</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote><p>You can know synchronously if the value still needs to be held. If an async task is scheduled in a sync tick where that context is set then it is captured to be propagated. This creates a GC reference that holds it open. If a sync tick <em>doesn't</em> create any further async tasks then it knows at the end of that sync tick that it created no new references.</p>
<p>In branching scenarios you would get each branch flowing up to exactly where it stops directly <em>causing</em> async code and then would have no more references. Each sync tick would only hold the reference while running, and then each async task would hold a reference until it would run. After the task runs it can discard <em>its</em> reference, but that would happen after new references were created for any children. Thus the GC would just function as-normal.</p>
<p>Now it <em>is</em> the case that data might live <em>quite a long time</em> sometimes, but this is <em>intentional</em> as it will only live long if descending execution of that point in context continues for long so it <em>should</em> be holding that value as anywhere in that descending code should be able to retrieve that data.</p>
<p>The risk of things living super long though is also easily mitigated by just emptying the context in some way, such as setting it to <code>undefined</code> when you've decided you're done with it.</p>
<p>My point is that in a <em>correctly formed</em> <code>set</code>/<code>get</code> system with clearly defined execution boundaries you would get a context flow that is perfectly safe from a memory usage perspective, have equivalent security characteristics to what is being proposed now (especially if a user-usable scope definition interface is added, and <em>most</em> importantly would actually match the behaviour which basically every user of AsyncLocalStorage (which is <em>a lot</em>--literally every single Fortune 500) is <em>expecting</em> from it.</p>
</blockquote></mx-reply>Everywhere except if it’s set within the global context, which persists beyond just the current sync execution. Your above <code data-md="`">defineScope(() =&gt; {})</code> solves this by definining an exit point that cleans the global context.</td></tr>

</tbody></table></div></div></div>
</body></html>