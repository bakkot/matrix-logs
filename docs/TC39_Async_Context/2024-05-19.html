<!DOCTYPE html><html><head>
  <title>TC39 Async Context on 2024-05-19</title>
  <link rel="stylesheet" href="../style.css">
  <script>window.room = "TC39 Async Context";</script><script src="../render-roomlist.js"></script>
  <script src="../logs.js"></script>
</head>
<body><div class="wrapper">
<div class="sidebar">
<div class="title">TC39 Async Context<br>2024-05-19<br><a href="plaintext/">plaintext logs</a></div>
<div class="nav">
<a href="2024-05-18" class="nav-link"><span>prev</span></a>
<span style="float:right">next</span>
</div>
    <div class="all-rooms"><noscript>JavaScript is required to load the channel index, but you can go to <a href="../..">the static index</a> directly.</noscript></div>
<div class="footer"><a href="https://github.com/bakkot/matrix-archive-bot">source on github</a></div>
</div>
<div class="rhs">
<div class="rhs-header">
<span id="error" style="color: red; display:none">error</span>

<input type="text" id="query" size="25" placeholder="Search TC39 Async Context">
<a id="search-submit" class="button icon-link" title="Search">
  <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg>
</a>
</div>

<div class="log"><table id="log-table"><tbody id="log-tbody">

  <tr class="msg" id="L0"><td class="ts-cell"><a class="ts" href="#L0" alt="Sun May 19 2024 06:07:31 GMT-0700 (Pacific Daylight Time)">13:07</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">Here's a new issue from Matteo about the exact issue I'm talking about with await binding. I've seen this user confusion come up <em>a lot</em>. <a href="https://github.com/nodejs/node/issues/53037">https://github.com/nodejs/node/issues/53037</a></td></tr>
  <tr class="msg" id="L1"><td class="ts-cell"><a class="ts" href="#L1" alt="Sun May 19 2024 06:08:11 GMT-0700 (Pacific Daylight Time)">13:08</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">It happens to use <code>enterWith(...)</code> rather than <code>run(...)</code>, but the confusion around expected flow is effectively the same.</td></tr>
  <tr class="msg" id="L2"><td class="ts-cell"><a class="ts" href="#L2" alt="Sun May 19 2024 06:26:33 GMT-0700 (Pacific Daylight Time)">13:26</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Do you have an example of this sort of fix, and the costs and benefits of it, that we can look into?</blockquote></mx-reply>We use it all over the place in the Datadog tracer, though we've been gradually migrating away to doing context recovery using TracingChannel instead as we don't break other users and tracing products that way. The cost is not really much, and like I said <em>will</em> happen whether we provide fast-paths for it or not--you can just do <code>store.get()</code> and <code><a href="http://store.run">store.run</a>(...)</code> in a closure, but then you're making a closure and doing some extra steps which could <em>probably</em> be more optimizable as an instance-scoped bind method of some sort.</td></tr>
  <tr class="msg" id="L3"><td class="ts-cell"><a class="ts" href="#L3" alt="Sun May 19 2024 06:28:42 GMT-0700 (Pacific Daylight Time)">13:28</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> Catching up on a lot here. I think I'm starting to come around a bit more to Stephen's perspective w.r.t. context flowing out from resolves.  I think he's right that, in general (when people do the right thing) it ends up maintaining the same root for the context tree, since the resolved promise generally comes from earlier in the same scope, and I like the fact that it aligns the opt-in for registration time with something that's actually quite reasonable to implement. I believe it's also pretty trivial to do a paranoid await-wrapping: `await bindTask(() =&gt; untrustedApi())` which would guarantee the untrustedApi can't change the context on you. Where it still feels wrong to me is Andreu's concern. The really nice property in the current proposal is that it's really well encapsulated. Context variable behave just like lexical consts, where you have guarantees that anything you can't see can never change them out from under you, and that's a _very attractive_ guarantee. Whereas the flows-out approach seems very brittle if any single bad/careless actor anywhere in your downstream call chain is able to irretrievably break the flow. I think that's where this disconnect is coming from - the encapsulation purists in the group are very hesitant to give up that guarantee.<br><br>I wonder if there's some middle ground where you could at least detect when an abrupt context change has occurred? For instance, I could imagine something along the lines of `using _ = contextMonitor();` at the top of the function.  It could install a new variable and if it detected that the variable has changed at the end of the scope, it knows something fishy has happened. And if we're giving up the encapsulation, I suspect mutating variables with `using` might actually be reasonable as well...</blockquote></mx-reply>The bad actor changing your value is only a problem if you explicitly give them the store and let them <em>do</em> that. If you just keep your stores private this is not a real problem.</td></tr>
  <tr class="msg" id="L4"><td class="ts-cell"><a class="ts" href="#L4" alt="Sun May 19 2024 06:33:49 GMT-0700 (Pacific Daylight Time)">13:33</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell">Also, the <code>using</code> syntax doesn't play particularly nice with async context as it not only crosses <em>over</em> async barriers, but <em>also</em> (as far as I'm aware) does nothing to signal any sort of change of state around awaits in its scope so if you, for example, mutate a global in whatever the <code>using</code> is doing and then expect it to restore the value when the use expires it may <em>also</em> be required that the value is altered to match the appropriate value between async code, so I expect that is going to be a bit of a footgun when combined with async code.</td></tr>
  <tr class="msg" id="L5"><td class="ts-cell"><a class="ts" href="#L5" alt="Sun May 19 2024 06:36:16 GMT-0700 (Pacific Daylight Time)">13:36</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-10" title="@stephenbelanger:matrix.org">Stephen Belanger</span>&gt;</div></td><td class="msg-cell"><mx-reply><blockquote> If you are coming around to this point, do you have ideas about answers to the questions I was asking? Namely, what do we hope to get from merge points, which happen all the time?</blockquote></mx-reply>I have less of a specific intuition on what to do about merge points, though as I have expressed previously I care a lot less about what merges look like as that just produces a <em>mildly</em> incorrect execution flow graph while the await binding produces a <em>very</em> incorrect flow graph which we have to do a bunch of work to patch around, which I described earlier with needing to store everything in a whole request trace and essentially <em>guess</em> from which thing the current path is a continuation.</td></tr>

</tbody></table></div></div></div>
</body></html>