2023-11-08
[06:00:42.0905] <jmdyck>
Let me see if I've got this straight...

[06:01:30.0673] <jmdyck>
Symbols can be put into 3 categories:

[06:01:39.0294] <jmdyck>
- Well-known symbols

[06:03:29.0800] <jmdyck>
- Symbols created by the Symbol constructor

[06:03:51.0419] <jmdyck>
- Symbols created by Symbol.for

[06:13:14.0866] <jmdyck>
Symbols created by the Symbol constructor have language identity, the others don't. So Symbols created by Symbol() are suitable for use as a weak reference, and the others aren't, *except* that well-known symbols are.

[06:16:33.0948] <jmdyck>
So in the one place that the spec uses the concept of 'language identity' (in the Note for CanBeHeldWeakly), it isn't even exactly the necessary concept.

[07:00:31.0994] <jmdyck>
(Actually, the 'Identity' section implies that well-known symbols *have* language identity, but I don't see how that could be. E.g., you can manifest @@match just by saying `Symbol.match`.)

[11:42:08.0770] <jmdyck>
so.... any thoughts on whether well-known symbols have language identity?

[11:46:19.0540] <shu>
they do

[11:46:38.0171] <shu>
kinda by fiat, i guess

[11:46:45.0500] <shu>
let me see if i can dig up any discussion

[11:48:58.0985] <shu>
i cannot dig up discussion

[11:49:52.0872] <jmdyck>
So how to reconcile that with the ability to manifest them without prior reference?

[11:50:36.0008] <shu>
i can only offer the practical GC difference, which is that well-known symbols are eternal roots and there is a bounded set of them. it doesn't matter much whether we say they have or have not language identity, there is no danger in holding them weakly because they will never be collected

[11:51:10.0659] <shu>
it was decided it was easier to think of them as having identity, since that's the line we wanted to draw for CanBeHeldWeakly, and identity was the best-matched concept to explain the line to draw

[11:51:31.0329] <shu>
Symbol.for symbols are unbounded and users can generate new ones (the "manifesting")

[11:51:39.0299] <shu>
i don't think of "manifesting" as simply referencing

[11:51:47.0202] <shu>
i don't "manifest" the built-in Object by typing `Object`

[11:52:34.0182] <jmdyck>
Hm, spec doesn't define "manifest".

[11:52:47.0825] <shu>
indeed it does not

[11:52:55.0139] <shu>
i don't think we have it in us to define manifest either

[11:53:08.0868] <shu>
but it's something like "causing things to be created that wasn't already there"

[11:53:29.0147] <shu>
but that is like, a concrete way to think about it, not a spec way to think about it

[11:53:53.0427] <shu>
the spec does not preclude a world where, for example, the set of all floating point Number values are already there, just floating around

[11:54:03.0963] <jmdyck>
and that idea doesn't work with "Values without identity may be manifest ..."

[11:54:04.0769] <shu>
and each time you need one you just "reference" it instead of "manifest" it

[11:54:20.0040] <shu>
> and that idea doesn't work with "Values without identity may be manifest ..."

how so?

