2025-01-03
[14:14:07.0911] <Michael Ficarra>
I have a work on-site next week, so I don't think I'll be able to attend editor call


2025-01-08
[14:33:03.0152] <ljharb>
shu, kevin, are yall attending today? it's just me and jmdyck rn

[14:33:23.0110] <bakkot>
yeah just a minute


2025-01-14
[19:19:16.0812] <ljharb>
is it weird to anyone else that https://tc39.es/ecma262/#sec-property-descriptor-specification-type says that an empty Record is a Property Descriptor?

[19:33:45.0104] <bakkot>
it is, though

[19:33:55.0823] <bakkot>
that's so `Object.defineProperty(foo, 'bar', {})` works

[23:32:26.0900] <ljharb>
i mean i get that an empty object has to work in a number of places. but since `{ enumerable: true }` isn't a property descriptor record either (that'd be `{ [[Enumerable]]: true }`) i'm not sure why an empty record needs to be one

[09:24:55.0943] <bakkot>
if you look at how `Object.defineProperty` works it basically mechanically converts the object into a spec record by copying over each of the relevant fields https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-topropertydescriptor

[09:26:08.0934] <bakkot>
and then passing it to definePropertyOrThrow which switches on presence of various fields

[09:32:47.0429] <bakkot>
it could work some other way but the reason an empty record is a property descriptor record is to allow it to be written this way

[09:34:23.0359] <bakkot>
I think if we were writing it today we'd probably avoid having optional fields in the record, which we usually avoid, but it would require a bit more machinery

[09:45:36.0783] <ljharb>
I definitely understand why it's written this way

[09:46:00.0803] <ljharb>
i'm wondering if it would be cleaner to special-case "no fields" rather than having the bottom type of all records be Property Descriptor

[10:01:21.0893] <bakkot>
ah

[10:01:44.0264] <bakkot>
I prefer not to; I don't think of records as really sharing types

[10:02:10.0775] <bakkot>
it's not like you come across a random record with no context in the spec; they're always being passed around between specific algorithms which make it clear what kind of thing they're working with

[10:25:00.0257] <Michael Ficarra>
lmao is this guy trying to save disk space on GitHub's servers? https://github.com/tc39/ecma262/pull/3478#issuecomment-2589138113

[10:25:02.0465] <Michael Ficarra>
who does this?

[10:29:06.0425] <jmdyck>
Maybe he's saving space locally then pushing to github?

[10:45:25.0342] <jmdyck>
ljharb: Given `Let _e_ be Record {}. If _e_ is a Property Descriptor, then ...`, are you thinking that the condition would succeed?

[10:47:35.0394] <ljharb>
> <@michaelficarra:matrix.org> who does this?

I’ve encountered many; some are the rare folks who use the PRs and issues tab, and are also stuck on the idea of “clean”, meaning they want to remove things from the list, and that requires closing PRs. In this case, i think he looks at his own profile and says “ick, too many forks” and tries to “clean” them up. But this is like the third time this guy;s done this with the same 262 PR, so i dunno what he’s thinking

[10:47:49.0956] <ljharb>
> <@jmdyck:matrix.org> ljharb: Given `Let _e_ be Record {}. If _e_ is a Property Descriptor, then ...`, are you thinking that the condition would succeed?

it does, right now, to my reading.

[10:49:58.0792] <jmdyck>
So you think "is a Foo Record" could be true of any record, regardless of how created, as long as it only has fields that a Foo Record can have?

[10:51:20.0786] <ljharb>
yes, we have structural not nominal typing on records

[10:53:07.0502] <jmdyck>
What suggests this to you?

[10:56:59.0636] <bakkot>
well, we do for property descriptors specifically per the introductory paragraph of https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-property-descriptor-specification-type

[10:57:42.0071] <bakkot>
I think/hope that everywhere else in the spec the difference would be never be observable; we're not really switching on the types of internal records much (ever?)

[10:58:42.0160] <shu>
there're a few places around Reference Records, and class fields

[10:59:02.0581] <shu>
but yes i also hope the difference is never observable

[11:00:02.0254] <shu>
more specifically i hope, for named records, we never create record literals without the name (but with all the fields) and use it like the named records

[11:02:28.0308] <bakkot>
ooh, found one but it's silly https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-symbol.for

[11:02:55.0535] <jmdyck>
bakkot: you're saying that that intro paragraph says that property descriptors have structural not nominal typing?

[11:03:30.0674] <shu>
oh boo but at least it's right above the table

[11:03:32.0636] <bakkot>
jmdyck that's my reading of it yes:

> Property Descriptor values may be further classified as data Property Descriptors and accessor Property Descriptors based upon the existence or use of certain fields

[11:04:58.0617] <bakkot>
I also really dislike the reference to the ambient "GlobalSymbolRegistry List" in `Symbol.for`

[11:05:02.0067] <bakkot>
I'm sure Michael Ficarra dislikes it more

[11:05:03.0771] <jmdyck>
oh, the *second* paragraph, hm.

[11:05:27.0726] <bakkot>
oh sorry yes

[11:06:26.0456] <shu>
but it really is so global

[11:06:32.0076] <shu>
it transcends all realms

[11:06:38.0801] <bakkot>
yes but we should `<dfn>` it or something at the very least

[11:07:17.0669] <shu>
yeah, and... i guess we should also build in locking?

[11:07:41.0466] <bakkot>
oh yeah fun

[11:07:44.0188] <bakkot>
we can just handwave that

[11:07:57.0421] <bakkot>
actually, would it be observable? they're not cloneable

[11:08:06.0299] <bakkot>
* actually, would it be observable? they're not structured-cloneable

[11:09:20.0093] <jmdyck>
(GlobalSymbolRegistry is called out in MF's 2724: https://github.com/tc39/ecma262/issues/2724#issuecomment-1093579455)

[11:09:30.0546] <bakkot>
ah, good good

[11:10:09.0564] <shu>
i didn't realize they weren't actually

[11:10:48.0053] <bakkot>
symbols aren't cloneable at all

[11:10:54.0664] <bakkot>
it's a bit silly

[11:10:59.0413] <bakkot>
registered symbols probably should be

[11:11:25.0928] <bakkot>
https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal step 5

[11:12:53.0936] <shu>
that is eminently silly yes

[11:19:32.0370] <jmdyck>
I think you can read the second para of 6.2.6 as classifying values that you've already established are Property Descriptors. So it doesn't address whether an empty schema-less Record qualifies as a Property Descriptor.

[11:22:16.0333] <bakkot>
right, yeah; by "we have structural typing for property descriptors" I meant only "within the property descriptor type we have structural typing", not that we have it for discriminating property descriptors from other kinds of things

[11:32:53.0891] <jmdyck>
okay, so to the question of `Given Let _e_ be Record {}. If _e_ is a Property Descriptor, then ...`, does the condition succeed, your answer is (roughly): the spec doesn't say, and I hope there's never a case where we'd need an answer ?

[11:33:34.0512] <jmdyck>
(such a case would be an editorial error?)

[11:34:59.0522] <bakkot>
correct

[11:35:24.0983] <bakkot>
though the one case in `Symbol.for` needs fixing for that to be strictly true

[11:35:54.0985] <jmdyck>
i don't understand the Symbol.for example.

[11:36:01.0158] <jmdyck>
what exactly?

[11:36:27.0686] <bakkot>
we create a record with specific fields, and do not call out that it is a GlobalSymbolRegistry Record, and then put it in a list of GlobalSymbolRegistry Records

[11:36:55.0745] <shu>
jmdyck, specifically step 5

[11:36:56.0104] <bakkot>
this implies that an anonymous Record having the fields of a GlobalSymbolRegistry Record is sufficient to _be_ a GlobalSymbolRegistry Record, i.e., it implies we are using structural typing for records

[11:44:56.0162] <jmdyck>
gotcha.

[11:45:20.0541] <jmdyck>
In my static analysis, that's the only error of that kind.

[11:47:13.0191] <jmdyck>
It goes back to ES6.

[11:51:03.0970] <jmdyck>
Re GlobalSymbolRegsitry transcending all realms, see https://github.com/tc39/ecma262/issues/824

[11:54:05.0081] <shu>
wait, _does_ each agent have its own registry?

[11:54:27.0244] <shu>
i thought it was truly global to the agent cluster, but i may be misremembering since i also thought this was observable (but turns out it isn't due to structured cloning not working)

[11:54:54.0404] <bakkot>
all we know is "The GlobalSymbolRegistry is an append-only List that is globally available. It is shared by all realms."

[11:54:59.0252] <jmdyck>
* Re GlobalSymbolRegistry transcending all realms, see https://github.com/tc39/ecma262/issues/824

[11:55:30.0291] <bakkot>
I would parse "globally available" as meaning "across agent" but it's not observable so /shrug

[12:12:51.0896] <jmdyck>
AWB thought that GlobalSymbolRegistry was per-Agent: https://github.com/tc39/ecma262/issues/882#issuecomment-293334655, which was quoted in issue 1357.

[13:11:17.0764] <ljharb>
even without that section, if i make a record and give it all the slots of an X record, how is it not thus an X record?

[13:12:29.0581] <Michael Ficarra>
@ljharb:matrix.org we just try not to do that

[13:12:55.0574] <Michael Ficarra>
if something needs a record of a particular kind, I construct it with that in mind

