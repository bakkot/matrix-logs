2021-08-01

2021-08-02

2021-08-03

2021-08-04
[14:32:28.0308] <shu>
editors call?

[14:33:49.0770] <shu>
bakkot: 


2021-08-05

2021-08-06

2021-08-07

2021-08-08

2021-08-09

2021-08-10

2021-08-11

2021-08-12

2021-08-13

2021-08-14
[09:37:42.0683] <bakkot>
ljharb: https://github.com/tc39/ecma262/pull/2408 is ready when you have time 

[09:39:20.0637] <ljharb>
cool, will get to it today


2021-08-15
[13:44:41.0731] <ljharb>
bakkot: why does https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values have `aoid="Type"` on it? it's not an AO

[13:55:30.0007] <bakkot>
it's used like one, so presumably the point of `aoid` is to make its usages link


2021-08-16
[19:48:25.0970] <ljharb>
ohhh for Type()

[19:48:31.0627] <ljharb>
right

[19:49:00.0720] <ljharb>
the new type="abstract operation" changes are breaking my es-abstract operation scraping, and i'm trying to fix it

[15:03:09.0779] <bakkot>
shu: do you want to look at https://github.com/tc39/ecma262/pull/2489, or should I just mark as ready-to-merge with michael's stamp?

[15:03:31.0488] <bakkot>
It's just about the language we use, nothing major

[15:22:04.0344] <shu>
go ahead and ready-to-merge, i don't think it needs another set of eyes given the description

[15:22:18.0587] <shu>
the only thing i would've dug into is set vs set objects, and you already called that out


2021-08-17

2021-08-18
[09:04:43.0371] <ljharb>
Michael Ficarra: why did you merge https://github.com/tc39/ecma262/pull/2491 ??

[09:05:11.0415] <ljharb>
ahhh nvm, it wasn't a PR to master

[09:05:13.0760] <ljharb>
disregard


2021-08-19
[09:40:29.0385] <ljharb>
bakkot: the new "duplicate ID" warning in ecmarkup is breaking my proposal technique of adding muitiple `<emu-clause id="sec-placeholder">` sections so i can artificially start the numbering later. is there another workaround for that?

[09:40:46.0606] <ljharb>
 * bakkot: the new "duplicate ID" warning in ecmarkup is breaking my proposal technique of adding muitiple `<emu-clause id="sec-placeholder">` sections so i can artificially start the numbering later. is there another workaround for that? or can i disable the `duplicate-id` check?

[09:59:29.0522] <bakkot>
just build without `--strict`

[10:00:15.0440] <bakkot>
it'll still print warnings but you'll get your build artifact

[11:20:40.0337] <ljharb>
oof, ok

[11:20:52.0691] <ljharb>
i did `sec-placeholderN` and tweaked my code, and that works too

[11:21:04.0655] <ljharb>
it'd be really nice to have a first-class feature to start numbering tho

[11:24:39.0091] <bakkot>
PRs welcome!

[14:43:21.0186] <bakkot>
https://github.com/tc39/ecma262/pull/2492


2021-08-20

2021-08-21
[22:31:58.0775] <ljharb>
seems like StringToBigInt is missing an assertion that its input is a String - does that seem right? If so i'll make a PR


2021-08-22

2021-08-23
[10:01:15.0024] <Michael Ficarra>
eww, I really don't like StringToBigInt

[10:01:33.0796] <Michael Ficarra>
ljharb: how about you rewrite it instead to not be modifying a different algorithm?

[10:02:37.0321] <Michael Ficarra>
bakkot shu: what do you think about removing the Type(x) notation?

[10:35:03.0176] <ljharb>
> <@michaelficarra:matrix.org> ljharb: how about you rewrite it instead to not be modifying a different algorithm?

you mean just inline the steps?

[10:35:23.0872] <ljharb>
> <@michaelficarra:matrix.org> bakkot shu: what do you think about removing the Type(x) notation?

and replacing it with what? Type() is used quite heavily

[10:47:42.0873] <bakkot>
ljharb: I stamped https://github.com/tc39/ecma262/pull/2492 as ready-to-merge. it should go in as two commits: one with just the ecmarkup bump, one with everything else


2021-08-24
[18:57:21.0506] <ljharb>
bakkot: 2489, squashed or separate?

[19:13:43.0421] <bakkot>
one commit is good I think

[19:26:35.0439] <ljharb>
kk

[19:53:55.0585] <bakkot>
ljharb: hang on, just noticed a typo

[19:53:59.0712] <jmdyck>
`Type(x) is T` can be replaced with `x is a T`

[19:54:10.0285] <jmdyck>
the one on line 955?

[19:54:31.0887] <ljharb>
Why is prose an improvement over an AO?

[19:55:21.0537] <bakkot>
ok fixed

[19:55:53.0698] <bakkot>
jmdyck: #2489 doesn't touch line 955; which typo are you referring to?

[19:57:45.0477] <jmdyck>
`<dfn id="integral-number"variants="integral Numbers">` missing space before "variants"

[19:58:03.0771] <jmdyck>
(#2492)

[19:58:07.0940] <bakkot>
ah, whoops, that landed

[20:16:04.0069] <jmdyck>
ljharb: One advantage of the `x is a T` form is that it can be more precise, e.g. `x is a declarative Environment Record` or `x is a function object` or `x is an Object with a [[Foo]] internal slot`

[20:18:09.0503] <ljharb>
How can that be more precise than an AO that has the same semantics? We can make AOs that are more precise than Type() is - that’s not an argument for inline prose, just an argument for “better than Type”

[20:22:18.0315] <jmdyck>
Currently, we can say `x is a Record` or `x is an Environment Record` or `x is a declarative Environment Record` or `x is a function Environment Record` and they can all be true. Even if you create a "better than Type" AO, it's still only going to return one thing for x, so it's only going to be equivalent to *one* of those four.

[20:25:59.0316] <jmdyck>
And what could a better-than-Type AO return that would give it the precision of `x is an Object with a [[Foo]] internal slot`?

[10:09:41.0780] <ljharb>
We already have that one - `RequireInternalSlot(x, [[Foo]])`

[10:09:59.0310] <ljharb>
i'd expect an `IsEnvironmentRecord` AO for the other examples

[10:21:54.0975] <bakkot>
I would much prefer to stick with either `Type` or `x is an Environment Record` over introducing an `IsEnvironmentRecord` AO

[10:35:35.0882] <shu>
i agree with that

[10:35:45.0880] <shu>
seems like churn for sake of churn

[10:47:00.0943] <jmdyck>
So if x is a function Environment Record, IsEnvironmentRecord(x) would be true, but again, that only addresses one 'level' of precision. If I want to know if x is a declarative ER or a function ER, IsEnvironmentRecord(x) doesn't help.

[13:47:02.0076] <shu>
bakkot: thoughts on of "When applied to extended mathematical values, the operators refer to the usual mathematical operations over the extended real numbers; indeterminate forms are undefined and their use in this specification should be considered an editorial error." ?

[13:54:34.0645] <bakkot>
shu: WFM

